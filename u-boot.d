
u-boot:     file format elf32-littlearm


Disassembly of section .text:

57e00000 <_start>:
 *
 *************************************************************************
 */

.globl _start
_start: b	reset
57e00000:	ea000014 	b	57e00058 <reset>
#ifndef CONFIG_NAND_SPL
	ldr	pc, _undefined_instruction
57e00004:	e59ff014 	ldr	pc, [pc, #20]	; 57e00020 <_undefined_instruction>
	ldr	pc, _software_interrupt
57e00008:	e59ff014 	ldr	pc, [pc, #20]	; 57e00024 <_software_interrupt>
	ldr	pc, _prefetch_abort
57e0000c:	e59ff014 	ldr	pc, [pc, #20]	; 57e00028 <_prefetch_abort>
	ldr	pc, _data_abort
57e00010:	e59ff014 	ldr	pc, [pc, #20]	; 57e0002c <_data_abort>
	ldr	pc, _not_used
57e00014:	e59ff014 	ldr	pc, [pc, #20]	; 57e00030 <_not_used>
	ldr	pc, _irq
57e00018:	e59ff014 	ldr	pc, [pc, #20]	; 57e00034 <_irq>
	ldr	pc, _fiq
57e0001c:	e59ff014 	ldr	pc, [pc, #20]	; 57e00038 <_fiq>

57e00020 <_undefined_instruction>:
57e00020:	57e00180 	.word	0x57e00180

57e00024 <_software_interrupt>:
57e00024:	57e001e0 	.word	0x57e001e0

57e00028 <_prefetch_abort>:
57e00028:	57e00240 	.word	0x57e00240

57e0002c <_data_abort>:
57e0002c:	57e002a0 	.word	0x57e002a0

57e00030 <_not_used>:
57e00030:	57e00300 	.word	0x57e00300

57e00034 <_irq>:
57e00034:	57e00360 	.word	0x57e00360

57e00038 <_fiq>:
57e00038:	57e003c0 	.word	0x57e003c0

57e0003c <_pad>:
57e0003c:	12345678 	.word	0x12345678

57e00040 <_TEXT_BASE>:
57e00040:	57e00000 	.word	0x57e00000

57e00044 <_TEXT_PHY_BASE>:
57e00044:	57e00000 	.word	0x57e00000

57e00048 <_bss_start_ofs>:
57e00048:	000381f8 	.word	0x000381f8

57e0004c <_bss_end_ofs>:
57e0004c:	0007c064 	.word	0x0007c064

57e00050 <_end_ofs>:
57e00050:	0003ded8 	.word	0x0003ded8

57e00054 <IRQ_STACK_START_IN>:
57e00054:	0badc0de 	.word	0x0badc0de

57e00058 <reset>:

reset:
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0, cpsr
57e00058:	e10f0000 	mrs	r0, CPSR
	bic	r0, r0, #0x3f
57e0005c:	e3c0003f 	bic	r0, r0, #63	; 0x3f
	orr	r0, r0, #0xd3
57e00060:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr, r0
57e00064:	e129f000 	msr	CPSR_fc, r0

57e00068 <cpu_init_crit>:
	 
#ifndef CONFIG_NAND_SPL
	/*
	 * flush v4 I/D caches
	 */
	mov	r0, #0
57e00068:	e3a00000 	mov	r0, #0
	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
57e0006c:	ee070f17 	mcr	15, 0, r0, cr7, cr7, {0}
	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
57e00070:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
	
	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
57e00074:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
57e00078:	e3c00c23 	bic	r0, r0, #8960	; 0x2300
	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
57e0007c:	e3c00087 	bic	r0, r0, #135	; 0x87
	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
57e00080:	e3800002 	orr	r0, r0, #2
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
57e00084:	e3800a01 	orr	r0, r0, #4096	; 0x1000

	/* Prepare to disable the MMU */
	adr	r2, mmu_disable_phys
57e00088:	e28f2020 	add	r2, pc, #32
	sub	r2, r2, #(CONFIG_SYS_PHY_UBOOT_BASE - CONFIG_SYS_TEXT_BASE)
57e0008c:	e2422000 	sub	r2, r2, #0
	b	mmu_disable
57e00090:	ea000002 	b	57e000a0 <mmu_disable>
57e00094:	e1a00000 	nop			; (mov r0, r0)
57e00098:	e1a00000 	nop			; (mov r0, r0)
57e0009c:	e1a00000 	nop			; (mov r0, r0)

57e000a0 <mmu_disable>:

	.align 5
	/* Run in a single cache-line */
mmu_disable:
	mcr	p15, 0, r0, c1, c0, 0
57e000a0:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	nop
57e000a4:	e1a00000 	nop			; (mov r0, r0)
	nop
57e000a8:	e1a00000 	nop			; (mov r0, r0)
	mov	pc, r2
57e000ac:	e1a0f002 	mov	pc, r2

57e000b0 <mmu_disable_phys>:
#endif

#ifdef CONFIG_PERIPORT_REMAP
	/* Peri port setup */

	ldr	r0, =CONFIG_PERIPORT_BASE
57e000b0:	e3a00207 	mov	r0, #1879048192	; 0x70000000
	orr	r0, r0, #CONFIG_PERIPORT_SIZE
57e000b4:	e3800013 	orr	r0, r0, #19
	mcr	p15,0,r0,c15,c2,4
57e000b8:	ee0f0f92 	mcr	15, 0, r0, cr15, cr2, {4}

	/*
	 * Go setup Memory and board specific bits prior to relocation.
	 */
	 
	bl	lowlevel_init		/* go setup pll,mux,memory */
57e000bc:	eb0000d8 	bl	57e00424 <lowlevel_init>

	bl	_main
57e000c0:	eb0002ab 	bl	57e00b74 <_main>

57e000c4 <relocate_code>:
 * after relocating the monitor code.
 *
 */
	.globl	relocate_code
relocate_code:
	mov	r4, r0	/* save addr_sp */
57e000c4:	e1a04000 	mov	r4, r0
	mov	r5, r1	/* save addr of gd */
57e000c8:	e1a05001 	mov	r5, r1
	mov	r6, r2	/* save addr of destination */
57e000cc:	e1a06002 	mov	r6, r2

	adr	r0, _start
57e000d0:	e24f00d8 	sub	r0, pc, #216	; 0xd8
	cmp	r0, r6
57e000d4:	e1500006 	cmp	r0, r6
	moveq	r9, #0		/* no relocation. relocation offset(r9) = 0 */
57e000d8:	03a09000 	moveq	r9, #0
	beq	relocate_done		/* skip relocation */
57e000dc:	0a000022 	beq	57e0016c <relocate_done>
	mov	r1, r6			/* r1 <- scratch for copy_loop */
57e000e0:	e1a01006 	mov	r1, r6
	ldr	r3, _bss_start_ofs
57e000e4:	e51f30a4 	ldr	r3, [pc, #-164]	; 57e00048 <_bss_start_ofs>
	add	r2, r0, r3		/* r2 <- source end address	    */
57e000e8:	e0802003 	add	r2, r0, r3

57e000ec <copy_loop>:

copy_loop:
	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
57e000ec:	e8b00600 	ldm	r0!, {r9, sl}
	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
57e000f0:	e8a10600 	stmia	r1!, {r9, sl}
	cmp	r0, r2			/* until source end address [r2]    */
57e000f4:	e1500002 	cmp	r0, r2
	blo	copy_loop
57e000f8:	3afffffb 	bcc	57e000ec <copy_loop>

#ifndef CONFIG_SPL_BUILD
	/*
	 * fix .rel.dyn relocations
	 */
	ldr	r0, _TEXT_BASE		/* r0 <- Text base */
57e000fc:	e51f00c4 	ldr	r0, [pc, #-196]	; 57e00040 <_TEXT_BASE>
	sub	r9, r6, r0		/* r9 <- relocation offset */
57e00100:	e0469000 	sub	r9, r6, r0
	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
57e00104:	e59fa06c 	ldr	sl, [pc, #108]	; 57e00178 <_dynsym_start_ofs>
	add	r10, r10, r0		/* r10 <- sym table in FLASH */
57e00108:	e08aa000 	add	sl, sl, r0
	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
57e0010c:	e59f205c 	ldr	r2, [pc, #92]	; 57e00170 <_rel_dyn_start_ofs>
	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH */
57e00110:	e0822000 	add	r2, r2, r0
	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
57e00114:	e59f3058 	ldr	r3, [pc, #88]	; 57e00174 <_rel_dyn_end_ofs>
	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH */
57e00118:	e0833000 	add	r3, r3, r0

57e0011c <fixloop>:
fixloop:
	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! */
57e0011c:	e5920000 	ldr	r0, [r2]
	add	r0, r0, r9		/* r0 <- location to fix up in RAM */
57e00120:	e0800009 	add	r0, r0, r9
	ldr	r1, [r2, #4]
57e00124:	e5921004 	ldr	r1, [r2, #4]
	and	r7, r1, #0xff
57e00128:	e20170ff 	and	r7, r1, #255	; 0xff
	cmp	r7, #23			/* relative fixup? */
57e0012c:	e3570017 	cmp	r7, #23
	beq	fixrel
57e00130:	0a000007 	beq	57e00154 <fixrel>
	cmp	r7, #2			/* absolute fixup? */
57e00134:	e3570002 	cmp	r7, #2
	beq	fixabs
57e00138:	0a000000 	beq	57e00140 <fixabs>
	/* ignore unknown type of fixup */
	b	fixnext
57e0013c:	ea000006 	b	57e0015c <fixnext>

57e00140 <fixabs>:
fixabs:
	/* absolute fix: set location to (offset) symbol value */
	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
57e00140:	e1a01221 	lsr	r1, r1, #4
	add	r1, r10, r1		/* r1 <- address of symbol in table */
57e00144:	e08a1001 	add	r1, sl, r1
	ldr	r1, [r1, #4]		/* r1 <- symbol value */
57e00148:	e5911004 	ldr	r1, [r1, #4]
	add	r1, r1, r9		/* r1 <- relocated sym addr */
57e0014c:	e0811009 	add	r1, r1, r9
	b	fixnext
57e00150:	ea000001 	b	57e0015c <fixnext>

57e00154 <fixrel>:
fixrel:
	/* relative fix: increase location by offset */
	ldr	r1, [r0]
57e00154:	e5901000 	ldr	r1, [r0]
	add	r1, r1, r9
57e00158:	e0811009 	add	r1, r1, r9

57e0015c <fixnext>:
fixnext:
	str	r1, [r0]
57e0015c:	e5801000 	str	r1, [r0]
	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
57e00160:	e2822008 	add	r2, r2, #8
	cmp	r2, r3
57e00164:	e1520003 	cmp	r2, r3
	blo	fixloop
57e00168:	3affffeb 	bcc	57e0011c <fixloop>

57e0016c <relocate_done>:
skip_hw_init:
#endif

relocate_done:

	bx	lr
57e0016c:	e12fff1e 	bx	lr

57e00170 <_rel_dyn_start_ofs>:
57e00170:	000381f8 	.word	0x000381f8

57e00174 <_rel_dyn_end_ofs>:
57e00174:	0003dde8 	.word	0x0003dde8

57e00178 <_dynsym_start_ofs>:
57e00178:	0003dde8 	.word	0x0003dde8

57e0017c <c_runtime_cpu_setup>:
#endif

	.globl	c_runtime_cpu_setup
c_runtime_cpu_setup:

	mov	pc, lr
57e0017c:	e1a0f00e 	mov	pc, lr

57e00180 <undefined_instruction>:
/*
 * exception handlers
 */
	.align	5
undefined_instruction:
	get_bad_stack
57e00180:	e51fd134 	ldr	sp, [pc, #-308]	; 57e00054 <IRQ_STACK_START_IN>
57e00184:	e58de000 	str	lr, [sp]
57e00188:	e14fe000 	mrs	lr, SPSR
57e0018c:	e58de004 	str	lr, [sp, #4]
57e00190:	e3a0d013 	mov	sp, #19
57e00194:	e169f00d 	msr	SPSR_fc, sp
57e00198:	e1a0e00f 	mov	lr, pc
57e0019c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
57e001a0:	e24dd048 	sub	sp, sp, #72	; 0x48
57e001a4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
57e001a8:	e51f215c 	ldr	r2, [pc, #-348]	; 57e00054 <IRQ_STACK_START_IN>
57e001ac:	e892000c 	ldm	r2, {r2, r3}
57e001b0:	e28d0048 	add	r0, sp, #72	; 0x48
57e001b4:	e28d5034 	add	r5, sp, #52	; 0x34
57e001b8:	e1a0100e 	mov	r1, lr
57e001bc:	e885000f 	stm	r5, {r0, r1, r2, r3}
57e001c0:	e1a0000d 	mov	r0, sp
	bl	do_undefined_instruction
57e001c4:	eb00042c 	bl	57e0127c <do_undefined_instruction>
57e001c8:	e1a00000 	nop			; (mov r0, r0)
57e001cc:	e1a00000 	nop			; (mov r0, r0)
57e001d0:	e1a00000 	nop			; (mov r0, r0)
57e001d4:	e1a00000 	nop			; (mov r0, r0)
57e001d8:	e1a00000 	nop			; (mov r0, r0)
57e001dc:	e1a00000 	nop			; (mov r0, r0)

57e001e0 <software_interrupt>:

	.align	5
software_interrupt:
	get_bad_stack_swi
57e001e0:	e24dd004 	sub	sp, sp, #4
57e001e4:	e58d0000 	str	r0, [sp]
57e001e8:	e51fd19c 	ldr	sp, [pc, #-412]	; 57e00054 <IRQ_STACK_START_IN>
57e001ec:	e580e000 	str	lr, [r0]
57e001f0:	e14f0000 	mrs	r0, SPSR
57e001f4:	e580e004 	str	lr, [r0, #4]
57e001f8:	e59d0000 	ldr	r0, [sp]
57e001fc:	e28dd004 	add	sp, sp, #4
	bad_save_user_regs
57e00200:	e24dd048 	sub	sp, sp, #72	; 0x48
57e00204:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
57e00208:	e51f21bc 	ldr	r2, [pc, #-444]	; 57e00054 <IRQ_STACK_START_IN>
57e0020c:	e892000c 	ldm	r2, {r2, r3}
57e00210:	e28d0048 	add	r0, sp, #72	; 0x48
57e00214:	e28d5034 	add	r5, sp, #52	; 0x34
57e00218:	e1a0100e 	mov	r1, lr
57e0021c:	e885000f 	stm	r5, {r0, r1, r2, r3}
57e00220:	e1a0000d 	mov	r0, sp
	bl	do_software_interrupt
57e00224:	eb00041d 	bl	57e012a0 <do_software_interrupt>
57e00228:	e1a00000 	nop			; (mov r0, r0)
57e0022c:	e1a00000 	nop			; (mov r0, r0)
57e00230:	e1a00000 	nop			; (mov r0, r0)
57e00234:	e1a00000 	nop			; (mov r0, r0)
57e00238:	e1a00000 	nop			; (mov r0, r0)
57e0023c:	e1a00000 	nop			; (mov r0, r0)

57e00240 <prefetch_abort>:

	.align	5
prefetch_abort:
	get_bad_stack
57e00240:	e51fd1f4 	ldr	sp, [pc, #-500]	; 57e00054 <IRQ_STACK_START_IN>
57e00244:	e58de000 	str	lr, [sp]
57e00248:	e14fe000 	mrs	lr, SPSR
57e0024c:	e58de004 	str	lr, [sp, #4]
57e00250:	e3a0d013 	mov	sp, #19
57e00254:	e169f00d 	msr	SPSR_fc, sp
57e00258:	e1a0e00f 	mov	lr, pc
57e0025c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
57e00260:	e24dd048 	sub	sp, sp, #72	; 0x48
57e00264:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
57e00268:	e51f221c 	ldr	r2, [pc, #-540]	; 57e00054 <IRQ_STACK_START_IN>
57e0026c:	e892000c 	ldm	r2, {r2, r3}
57e00270:	e28d0048 	add	r0, sp, #72	; 0x48
57e00274:	e28d5034 	add	r5, sp, #52	; 0x34
57e00278:	e1a0100e 	mov	r1, lr
57e0027c:	e885000f 	stm	r5, {r0, r1, r2, r3}
57e00280:	e1a0000d 	mov	r0, sp
	bl	do_prefetch_abort
57e00284:	eb00040e 	bl	57e012c4 <do_prefetch_abort>
57e00288:	e1a00000 	nop			; (mov r0, r0)
57e0028c:	e1a00000 	nop			; (mov r0, r0)
57e00290:	e1a00000 	nop			; (mov r0, r0)
57e00294:	e1a00000 	nop			; (mov r0, r0)
57e00298:	e1a00000 	nop			; (mov r0, r0)
57e0029c:	e1a00000 	nop			; (mov r0, r0)

57e002a0 <data_abort>:

	.align	5
data_abort:
	get_bad_stack
57e002a0:	e51fd254 	ldr	sp, [pc, #-596]	; 57e00054 <IRQ_STACK_START_IN>
57e002a4:	e58de000 	str	lr, [sp]
57e002a8:	e14fe000 	mrs	lr, SPSR
57e002ac:	e58de004 	str	lr, [sp, #4]
57e002b0:	e3a0d013 	mov	sp, #19
57e002b4:	e169f00d 	msr	SPSR_fc, sp
57e002b8:	e1a0e00f 	mov	lr, pc
57e002bc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
57e002c0:	e24dd048 	sub	sp, sp, #72	; 0x48
57e002c4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
57e002c8:	e51f227c 	ldr	r2, [pc, #-636]	; 57e00054 <IRQ_STACK_START_IN>
57e002cc:	e892000c 	ldm	r2, {r2, r3}
57e002d0:	e28d0048 	add	r0, sp, #72	; 0x48
57e002d4:	e28d5034 	add	r5, sp, #52	; 0x34
57e002d8:	e1a0100e 	mov	r1, lr
57e002dc:	e885000f 	stm	r5, {r0, r1, r2, r3}
57e002e0:	e1a0000d 	mov	r0, sp
	bl	do_data_abort
57e002e4:	eb0003ff 	bl	57e012e8 <do_data_abort>
57e002e8:	e1a00000 	nop			; (mov r0, r0)
57e002ec:	e1a00000 	nop			; (mov r0, r0)
57e002f0:	e1a00000 	nop			; (mov r0, r0)
57e002f4:	e1a00000 	nop			; (mov r0, r0)
57e002f8:	e1a00000 	nop			; (mov r0, r0)
57e002fc:	e1a00000 	nop			; (mov r0, r0)

57e00300 <not_used>:

	.align	5
not_used:
	get_bad_stack
57e00300:	e51fd2b4 	ldr	sp, [pc, #-692]	; 57e00054 <IRQ_STACK_START_IN>
57e00304:	e58de000 	str	lr, [sp]
57e00308:	e14fe000 	mrs	lr, SPSR
57e0030c:	e58de004 	str	lr, [sp, #4]
57e00310:	e3a0d013 	mov	sp, #19
57e00314:	e169f00d 	msr	SPSR_fc, sp
57e00318:	e1a0e00f 	mov	lr, pc
57e0031c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
57e00320:	e24dd048 	sub	sp, sp, #72	; 0x48
57e00324:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
57e00328:	e51f22dc 	ldr	r2, [pc, #-732]	; 57e00054 <IRQ_STACK_START_IN>
57e0032c:	e892000c 	ldm	r2, {r2, r3}
57e00330:	e28d0048 	add	r0, sp, #72	; 0x48
57e00334:	e28d5034 	add	r5, sp, #52	; 0x34
57e00338:	e1a0100e 	mov	r1, lr
57e0033c:	e885000f 	stm	r5, {r0, r1, r2, r3}
57e00340:	e1a0000d 	mov	r0, sp
	bl	do_not_used
57e00344:	eb0003f0 	bl	57e0130c <do_not_used>
57e00348:	e1a00000 	nop			; (mov r0, r0)
57e0034c:	e1a00000 	nop			; (mov r0, r0)
57e00350:	e1a00000 	nop			; (mov r0, r0)
57e00354:	e1a00000 	nop			; (mov r0, r0)
57e00358:	e1a00000 	nop			; (mov r0, r0)
57e0035c:	e1a00000 	nop			; (mov r0, r0)

57e00360 <irq>:

	.align	5
irq:
	get_bad_stack
57e00360:	e51fd314 	ldr	sp, [pc, #-788]	; 57e00054 <IRQ_STACK_START_IN>
57e00364:	e58de000 	str	lr, [sp]
57e00368:	e14fe000 	mrs	lr, SPSR
57e0036c:	e58de004 	str	lr, [sp, #4]
57e00370:	e3a0d013 	mov	sp, #19
57e00374:	e169f00d 	msr	SPSR_fc, sp
57e00378:	e1a0e00f 	mov	lr, pc
57e0037c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
57e00380:	e24dd048 	sub	sp, sp, #72	; 0x48
57e00384:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
57e00388:	e51f233c 	ldr	r2, [pc, #-828]	; 57e00054 <IRQ_STACK_START_IN>
57e0038c:	e892000c 	ldm	r2, {r2, r3}
57e00390:	e28d0048 	add	r0, sp, #72	; 0x48
57e00394:	e28d5034 	add	r5, sp, #52	; 0x34
57e00398:	e1a0100e 	mov	r1, lr
57e0039c:	e885000f 	stm	r5, {r0, r1, r2, r3}
57e003a0:	e1a0000d 	mov	r0, sp
	bl	do_irq
57e003a4:	eb0003ea 	bl	57e01354 <do_irq>
57e003a8:	e1a00000 	nop			; (mov r0, r0)
57e003ac:	e1a00000 	nop			; (mov r0, r0)
57e003b0:	e1a00000 	nop			; (mov r0, r0)
57e003b4:	e1a00000 	nop			; (mov r0, r0)
57e003b8:	e1a00000 	nop			; (mov r0, r0)
57e003bc:	e1a00000 	nop			; (mov r0, r0)

57e003c0 <fiq>:

	.align	5
fiq:
	get_bad_stack
57e003c0:	e51fd374 	ldr	sp, [pc, #-884]	; 57e00054 <IRQ_STACK_START_IN>
57e003c4:	e58de000 	str	lr, [sp]
57e003c8:	e14fe000 	mrs	lr, SPSR
57e003cc:	e58de004 	str	lr, [sp, #4]
57e003d0:	e3a0d013 	mov	sp, #19
57e003d4:	e169f00d 	msr	SPSR_fc, sp
57e003d8:	e1a0e00f 	mov	lr, pc
57e003dc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
57e003e0:	e24dd048 	sub	sp, sp, #72	; 0x48
57e003e4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
57e003e8:	e51f239c 	ldr	r2, [pc, #-924]	; 57e00054 <IRQ_STACK_START_IN>
57e003ec:	e892000c 	ldm	r2, {r2, r3}
57e003f0:	e28d0048 	add	r0, sp, #72	; 0x48
57e003f4:	e28d5034 	add	r5, sp, #52	; 0x34
57e003f8:	e1a0100e 	mov	r1, lr
57e003fc:	e885000f 	stm	r5, {r0, r1, r2, r3}
57e00400:	e1a0000d 	mov	r0, sp
	bl	do_fiq
57e00404:	eb0003c9 	bl	57e01330 <do_fiq>
57e00408:	e1a00000 	nop			; (mov r0, r0)
57e0040c:	e1a00000 	nop			; (mov r0, r0)
57e00410:	e1a00000 	nop			; (mov r0, r0)
57e00414:	e1a00000 	nop			; (mov r0, r0)
57e00418:	e1a00000 	nop			; (mov r0, r0)
57e0041c:	e1a00000 	nop			; (mov r0, r0)

57e00420 <_TEXT_BASE>:
57e00420:	57e00000 	.word	0x57e00000

57e00424 <lowlevel_init>:
_TEXT_BASE:
	.word	CONFIG_SYS_TEXT_BASE

	.globl lowlevel_init
lowlevel_init:
	mov	r12, lr
57e00424:	e1a0c00e 	mov	ip, lr
	

	/* LED on only #8 */
	ldr	r0, =ELFIN_GPIO_BASE
57e00428:	e59f01c0 	ldr	r0, [pc, #448]	; 57e005f0 <nand_asm_init+0x24>
	ldr	r1, =0x55540000
57e0042c:	e59f11c0 	ldr	r1, [pc, #448]	; 57e005f4 <nand_asm_init+0x28>
	str	r1, [r0, #GPNCON_OFFSET]
57e00430:	e5801830 	str	r1, [r0, #2096]	; 0x830

	ldr	r1, =0x55555555
57e00434:	e59f11bc 	ldr	r1, [pc, #444]	; 57e005f8 <nand_asm_init+0x2c>
	str	r1, [r0, #GPNPUD_OFFSET]
57e00438:	e5801838 	str	r1, [r0, #2104]	; 0x838

	ldr	r1, =0xf000
57e0043c:	e3a01a0f 	mov	r1, #61440	; 0xf000
	str	r1, [r0, #GPNDAT_OFFSET]
57e00440:	e5801834 	str	r1, [r0, #2100]	; 0x834

	/* Disable Watchdog */
	ldr	r0, =0x7e000000		@0x7e004000
57e00444:	e3a0047e 	mov	r0, #2113929216	; 0x7e000000
	orr	r0, r0, #0x4000
57e00448:	e3800901 	orr	r0, r0, #16384	; 0x4000
	mov	r1, #0
57e0044c:	e3a01000 	mov	r1, #0
	str	r1, [r0]
57e00450:	e5801000 	str	r1, [r0]

	/* External interrupt pending clear */
	ldr	r0, =(ELFIN_GPIO_BASE+EINTPEND_OFFSET)	/*EINTPEND*/
57e00454:	e59f01a0 	ldr	r0, [pc, #416]	; 57e005fc <nand_asm_init+0x30>
	ldr	r1, [r0]
57e00458:	e5901000 	ldr	r1, [r0]
	str	r1, [r0]
57e0045c:	e5801000 	str	r1, [r0]

	ldr	r0, =ELFIN_VIC0_BASE_ADDR	@0x71200000
57e00460:	e59f0198 	ldr	r0, [pc, #408]	; 57e00600 <nand_asm_init+0x34>
	ldr	r1, =ELFIN_VIC1_BASE_ADDR	@0x71300000
57e00464:	e59f1198 	ldr	r1, [pc, #408]	; 57e00604 <nand_asm_init+0x38>

	/* Disable all interrupts (VIC0 and VIC1) */
	mvn	r3, #0x0
57e00468:	e3e03000 	mvn	r3, #0
	str	r3, [r0, #oINTMSK]
57e0046c:	e5803014 	str	r3, [r0, #20]
	str	r3, [r1, #oINTMSK]
57e00470:	e5813014 	str	r3, [r1, #20]

	/* Set all interrupts as IRQ */
	mov	r3, #0x0
57e00474:	e3a03000 	mov	r3, #0
	str	r3, [r0, #oINTMOD]
57e00478:	e580300c 	str	r3, [r0, #12]
	str	r3, [r1, #oINTMOD]
57e0047c:	e581300c 	str	r3, [r1, #12]

	/* Pending Interrupt Clear */
	mov	r3, #0x0
57e00480:	e3a03000 	mov	r3, #0
	str	r3, [r0, #oVECTADDR]
57e00484:	e5803f00 	str	r3, [r0, #3840]	; 0xf00
	str	r3, [r1, #oVECTADDR]
57e00488:	e5813f00 	str	r3, [r1, #3840]	; 0xf00

	/* init system clock */
	
	bl system_clock_init
57e0048c:	eb000017 	bl	57e004f0 <system_clock_init>
	
#ifndef CONFIG_NAND_SPL
	/* for UART */
	bl uart_asm_init
57e00490:	eb00003b 	bl	57e00584 <uart_asm_init>
#endif

#ifdef CONFIG_BOOT_NAND
	/* simple init for NAND */
	bl nand_asm_init
57e00494:	eb00004c 	bl	57e005cc <nand_asm_init>
#endif

	/* Memory subsystem address 0x7e00f120 */
	ldr	r0, =ELFIN_MEM_SYS_CFG
57e00498:	e59f0168 	ldr	r0, [pc, #360]	; 57e00608 <nand_asm_init+0x3c>

	/* Xm0CSn2 = NFCON CS0, Xm0CSn3 = NFCON CS1 */
	mov	r1, #S3C64XX_MEM_SYS_CFG_NAND
57e0049c:	e3a01008 	mov	r1, #8
	str	r1, [r0]
57e004a0:	e5801000 	str	r1, [r0]

	bl	mem_ctrl_asm_init
57e004a4:	eb000075 	bl	57e00680 <mem_ctrl_asm_init>

/* Wakeup support. Don't know if it's going to be used, untested. */
	ldr	r0, =(ELFIN_CLOCK_POWER_BASE + RST_STAT_OFFSET)
57e004a8:	e59f015c 	ldr	r0, [pc, #348]	; 57e0060c <nand_asm_init+0x40>
	ldr	r1, [r0]
57e004ac:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #0xfffffff7
57e004b0:	e2011008 	and	r1, r1, #8
	cmp	r1, #0x8
57e004b4:	e3510008 	cmp	r1, #8
	beq	wakeup_reset
57e004b8:	0a000001 	beq	57e004c4 <wakeup_reset>

1:
	mov	lr, r12
57e004bc:	e1a0e00c 	mov	lr, ip
	mov	pc, lr
57e004c0:	e1a0f00e 	mov	pc, lr

57e004c4 <wakeup_reset>:


wakeup_reset:

	/* Clear wakeup status register */
	ldr	r0, =(ELFIN_CLOCK_POWER_BASE + WAKEUP_STAT_OFFSET)
57e004c4:	e59f0144 	ldr	r0, [pc, #324]	; 57e00610 <nand_asm_init+0x44>
	ldr	r1, [r0]
57e004c8:	e5901000 	ldr	r1, [r0]
	str	r1, [r0]
57e004cc:	e5801000 	str	r1, [r0]

	/* LED test */
	ldr	r0, =ELFIN_GPIO_BASE
57e004d0:	e59f0118 	ldr	r0, [pc, #280]	; 57e005f0 <nand_asm_init+0x24>
	ldr	r1, =0x3000
57e004d4:	e3a01a03 	mov	r1, #12288	; 0x3000
	str	r1, [r0, #GPNDAT_OFFSET]
57e004d8:	e5801834 	str	r1, [r0, #2100]	; 0x834

	/* Load return address and jump to kernel */
	ldr	r0, =(ELFIN_CLOCK_POWER_BASE + INF_REG0_OFFSET)
57e004dc:	e59f0130 	ldr	r0, [pc, #304]	; 57e00614 <nand_asm_init+0x48>
	/* r1 = physical address of s3c6400_cpu_resume function */
	ldr	r1, [r0]
57e004e0:	e5901000 	ldr	r1, [r0]
	/* Jump to kernel (sleep-s3c6400.S) */
	mov	pc, r1
57e004e4:	e1a0f001 	mov	pc, r1
	nop
57e004e8:	e1a00000 	nop			; (mov r0, r0)
	nop
57e004ec:	e1a00000 	nop			; (mov r0, r0)

57e004f0 <system_clock_init>:
/*
 * system_clock_init: Initialize core clock and bus clock.
 * void system_clock_init(void)
 */
system_clock_init:
	bl light_led2
57e004f0:	eb00002e 	bl	57e005b0 <light_led2>
	ldr	r0, =ELFIN_CLOCK_POWER_BASE	/* 0x7e00f000 */
57e004f4:	e59f011c 	ldr	r0, [pc, #284]	; 57e00618 <nand_asm_init+0x4c>
	bl light_led
57e004f8:	eb000025 	bl	57e00594 <light_led>
	ldr	r2, =0xf00
	and	r1, r1, r2
	cmp	r1, #0xf00
	bne	check_syncack
#else	/* ASYNC Mode */
	nop
57e004fc:	e1a00000 	nop			; (mov r0, r0)
	nop
57e00500:	e1a00000 	nop			; (mov r0, r0)
	nop
57e00504:	e1a00000 	nop			; (mov r0, r0)
	nop
57e00508:	e1a00000 	nop			; (mov r0, r0)
	nop
57e0050c:	e1a00000 	nop			; (mov r0, r0)
	and	r1, r1, #0xf00
	cmp	r1, #0x0
	bne	wait_for_async
#endif

	ldr	r1, [r0, #OTHERS_OFFSET]
57e00510:	e5901900 	ldr	r1, [r0, #2304]	; 0x900
	bic	r1, r1, #0x40
57e00514:	e3c11040 	bic	r1, r1, #64	; 0x40
	str	r1, [r0, #OTHERS_OFFSET]
57e00518:	e5801900 	str	r1, [r0, #2304]	; 0x900
#endif

	mov	r1, #0xff00
57e0051c:	e3a01cff 	mov	r1, #65280	; 0xff00
	orr	r1, r1, #0xff
57e00520:	e38110ff 	orr	r1, r1, #255	; 0xff
	str	r1, [r0, #APLL_LOCK_OFFSET]
57e00524:	e5801000 	str	r1, [r0]
	str	r1, [r0, #MPLL_LOCK_OFFSET]
57e00528:	e5801004 	str	r1, [r0, #4]

	/* Set Clock Divider */
	ldr	r1, [r0, #CLK_DIV0_OFFSET]
57e0052c:	e5901020 	ldr	r1, [r0, #32]
	bic	r1, r1, #0x30000
57e00530:	e3c11803 	bic	r1, r1, #196608	; 0x30000
	bic	r1, r1, #0xff00
57e00534:	e3c11cff 	bic	r1, r1, #65280	; 0xff00
	bic	r1, r1, #0xff
57e00538:	e3c110ff 	bic	r1, r1, #255	; 0xff
	ldr	r2, =CLK_DIV_VAL
57e0053c:	e59f20d8 	ldr	r2, [pc, #216]	; 57e0061c <nand_asm_init+0x50>
	orr	r1, r1, r2
57e00540:	e1811002 	orr	r1, r1, r2
	str	r1, [r0, #CLK_DIV0_OFFSET]
57e00544:	e5801020 	str	r1, [r0, #32]

	ldr	r1, =APLL_VAL
57e00548:	e59f10d0 	ldr	r1, [pc, #208]	; 57e00620 <nand_asm_init+0x54>
	str	r1, [r0, #APLL_CON_OFFSET]
57e0054c:	e580100c 	str	r1, [r0, #12]
	ldr	r1, =MPLL_VAL
57e00550:	e59f10c8 	ldr	r1, [pc, #200]	; 57e00620 <nand_asm_init+0x54>
	str	r1, [r0, #MPLL_CON_OFFSET]
57e00554:	e5801010 	str	r1, [r0, #16]

	/* FOUT of EPLL is 96MHz */
	ldr	r1, =0x200203
57e00558:	e59f10c4 	ldr	r1, [pc, #196]	; 57e00624 <nand_asm_init+0x58>
	str	r1, [r0, #EPLL_CON0_OFFSET]
57e0055c:	e5801014 	str	r1, [r0, #20]
	ldr	r1, =0x0
57e00560:	e3a01000 	mov	r1, #0
	str	r1, [r0, #EPLL_CON1_OFFSET]
57e00564:	e5801018 	str	r1, [r0, #24]

	/* APLL, MPLL, EPLL select to Fout */
	ldr	r1, [r0, #CLK_SRC_OFFSET]
57e00568:	e590101c 	ldr	r1, [r0, #28]
	orr	r1, r1, #0x7
57e0056c:	e3811007 	orr	r1, r1, #7
	str	r1, [r0, #CLK_SRC_OFFSET]
57e00570:	e580101c 	str	r1, [r0, #28]

	/* wait at least 200us to stablize all clock */
	mov	r1, #0x10000
57e00574:	e3a01801 	mov	r1, #65536	; 0x10000
1:	subs	r1, r1, #1
57e00578:	e2511001 	subs	r1, r1, #1
	bne	1b
57e0057c:	1afffffd 	bne	57e00578 <system_clock_init+0x88>
	/* According to 661558um_S3C6400X_rev10.pdf 0x20 is reserved */
	ldr	r1, [r0, #OTHERS_OFFSET]
	bic	r1, r1, #0x20
	str	r1, [r0, #OTHERS_OFFSET]
#endif
	mov	pc, lr
57e00580:	e1a0f00e 	mov	pc, lr

57e00584 <uart_asm_init>:
/*
 * uart_asm_init: Initialize UART's pins
 */
uart_asm_init:
	/* set GPIO to enable UART */
	ldr	r0, =ELFIN_GPIO_BASE
57e00584:	e59f0064 	ldr	r0, [pc, #100]	; 57e005f0 <nand_asm_init+0x24>
	ldr	r1, =0x220022
57e00588:	e59f1098 	ldr	r1, [pc, #152]	; 57e00628 <nand_asm_init+0x5c>
	str	r1, [r0, #GPACON_OFFSET]
57e0058c:	e5801000 	str	r1, [r0]
	mov	pc, lr
57e00590:	e1a0f00e 	mov	pc, lr

57e00594 <light_led>:
#endif

#define GPKCON 0x7f008800
#define GPKDAT 0x7f008808
light_led:
	ldr r0, =GPKCON
57e00594:	e59f0090 	ldr	r0, [pc, #144]	; 57e0062c <nand_asm_init+0x60>
	ldr r1, =0x11110000
57e00598:	e59f1090 	ldr	r1, [pc, #144]	; 57e00630 <nand_asm_init+0x64>
	str r1, [r0]
57e0059c:	e5801000 	str	r1, [r0]
	
	ldr r0, =GPKDAT
57e005a0:	e59f008c 	ldr	r0, [pc, #140]	; 57e00634 <nand_asm_init+0x68>
	ldr r1, =0x00
57e005a4:	e3a01000 	mov	r1, #0
	str r1, [r0]
57e005a8:	e5801000 	str	r1, [r0]
	mov pc, lr
57e005ac:	e1a0f00e 	mov	pc, lr

57e005b0 <light_led2>:

light_led2:
	ldr r0, =GPKCON
57e005b0:	e59f0074 	ldr	r0, [pc, #116]	; 57e0062c <nand_asm_init+0x60>
	ldr r1, =0x11110000
57e005b4:	e59f1074 	ldr	r1, [pc, #116]	; 57e00630 <nand_asm_init+0x64>
	str r1, [r0]
57e005b8:	e5801000 	str	r1, [r0]
	
	ldr r0, =GPKDAT
57e005bc:	e59f0070 	ldr	r0, [pc, #112]	; 57e00634 <nand_asm_init+0x68>
	ldr r1, =0xa0
57e005c0:	e3a010a0 	mov	r1, #160	; 0xa0
	str r1, [r0]
57e005c4:	e5801000 	str	r1, [r0]
	mov pc, lr
57e005c8:	e1a0f00e 	mov	pc, lr

57e005cc <nand_asm_init>:
#ifdef CONFIG_BOOT_NAND
/*
 * NAND Interface init for SMDK6400
 */
nand_asm_init:
	ldr	r0, =ELFIN_NAND_BASE
57e005cc:	e59f0064 	ldr	r0, [pc, #100]	; 57e00638 <nand_asm_init+0x6c>
	ldr	r1, [r0, #NFCONF_OFFSET]
57e005d0:	e5901000 	ldr	r1, [r0]
	orr	r1, r1, #0x70
57e005d4:	e3811070 	orr	r1, r1, #112	; 0x70
	orr	r1, r1, #0x7700
57e005d8:	e3811c77 	orr	r1, r1, #30464	; 0x7700
	str	r1, [r0, #NFCONF_OFFSET]
57e005dc:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #NFCONT_OFFSET]
57e005e0:	e5901004 	ldr	r1, [r0, #4]
	orr	r1, r1, #0x07
57e005e4:	e3811007 	orr	r1, r1, #7
	str	r1, [r0, #NFCONT_OFFSET]
57e005e8:	e5801004 	str	r1, [r0, #4]

	mov	pc, lr
57e005ec:	e1a0f00e 	mov	pc, lr
57e005f0:	7f008000 	.word	0x7f008000
57e005f4:	55540000 	.word	0x55540000
57e005f8:	55555555 	.word	0x55555555
57e005fc:	7f008924 	.word	0x7f008924
57e00600:	71200000 	.word	0x71200000
57e00604:	71300000 	.word	0x71300000
57e00608:	7e00f120 	.word	0x7e00f120
57e0060c:	7e00f904 	.word	0x7e00f904
57e00610:	7e00f908 	.word	0x7e00f908
57e00614:	7e00fa00 	.word	0x7e00fa00
57e00618:	7e00f000 	.word	0x7e00f000
57e0061c:	00003310 	.word	0x00003310
57e00620:	82150601 	.word	0x82150601
57e00624:	00200203 	.word	0x00200203
57e00628:	00220022 	.word	0x00220022
57e0062c:	7f008800 	.word	0x7f008800
57e00630:	11110000 	.word	0x11110000
57e00634:	7f008808 	.word	0x7f008808
57e00638:	70200000 	.word	0x70200000

57e0063c <cleanup_before_linux>:
#include <asm/system.h>

static void cache_flush (void);

int cleanup_before_linux (void)
{
57e0063c:	e92d4008 	push	{r3, lr}
	 * it prepares the processor for linux
	 *
	 * we turn off caches etc ...
	 */

	disable_interrupts ();
57e00640:	eb0002b7 	bl	57e01124 <disable_interrupts>

	/* turn off I/D-cache */
	icache_disable();
57e00644:	eb0003bc 	bl	57e0153c <icache_disable>
	dcache_disable();
57e00648:	eb0003c4 	bl	57e01560 <dcache_disable>

/* flush I/D-cache */
static void cache_flush (void)
{
	/* invalidate both caches and flush btb */
	asm ("mcr p15, 0, %0, c7, c7, 0": :"r" (0));
57e0064c:	e3a03000 	mov	r3, #0
57e00650:	ee073f17 	mcr	15, 0, r3, cr7, cr7, {0}
	/* mem barrier to sync things */
	asm ("mcr p15, 0, %0, c7, c10, 4": :"r" (0));
57e00654:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
	dcache_disable();
	/* flush I/D-cache */
	cache_flush();

	return 0;
}
57e00658:	e3a00000 	mov	r0, #0
57e0065c:	e8bd8008 	pop	{r3, pc}

57e00660 <reset_cpu>:

#include <asm/arch/s3c6400.h>

.globl reset_cpu
reset_cpu:
	ldr	r1, =ELFIN_CLOCK_POWER_BASE
57e00660:	e59f1010 	ldr	r1, [pc, #16]	; 57e00678 <_loop_forever+0x4>
	ldr	r2, [r1, #SYS_ID_OFFSET]
57e00664:	e5912118 	ldr	r2, [r1, #280]	; 0x118
	ldr	r3, =0xffff
57e00668:	e59f300c 	ldr	r3, [pc, #12]	; 57e0067c <_loop_forever+0x8>
	and	r2, r3, r2, lsr #12
57e0066c:	e0032622 	and	r2, r3, r2, lsr #12
	str	r2, [r1, #SW_RST_OFFSET]
57e00670:	e5812114 	str	r2, [r1, #276]	; 0x114

57e00674 <_loop_forever>:
_loop_forever:
	b	_loop_forever
57e00674:	eafffffe 	b	57e00674 <_loop_forever>
57e00678:	7e00f000 	.word	0x7e00f000
57e0067c:	0000ffff 	.word	0x0000ffff

57e00680 <mem_ctrl_asm_init>:
#include <asm/arch/s3c6400.h>

	.globl mem_ctrl_asm_init
mem_ctrl_asm_init:
	/* DMC1 base address 0x7e001000 */
	ldr	r0, =ELFIN_DMC1_BASE
57e00680:	e59f0104 	ldr	r0, [pc, #260]	; 57e0078c <check_dmc1_ready+0x1c>

	ldr	r1, =0x4
57e00684:	e3a01004 	mov	r1, #4
	str	r1, [r0, #INDEX_DMC_MEMC_CMD]
57e00688:	e5801004 	str	r1, [r0, #4]

	ldr	r1, =DMC_DDR_REFRESH_PRD
57e0068c:	e59f10fc 	ldr	r1, [pc, #252]	; 57e00790 <check_dmc1_ready+0x20>
	str	r1, [r0, #INDEX_DMC_REFRESH_PRD]
57e00690:	e5801010 	str	r1, [r0, #16]

	ldr	r1, =DMC_DDR_CAS_LATENCY
57e00694:	e3a01006 	mov	r1, #6
	str	r1, [r0, #INDEX_DMC_CAS_LATENCY]
57e00698:	e5801014 	str	r1, [r0, #20]

	ldr	r1, =DMC_DDR_t_DQSS
57e0069c:	e3a01001 	mov	r1, #1
	str	r1, [r0, #INDEX_DMC_T_DQSS]
57e006a0:	e5801018 	str	r1, [r0, #24]

	ldr	r1, =DMC_DDR_t_MRD
57e006a4:	e3a01002 	mov	r1, #2
	str	r1, [r0, #INDEX_DMC_T_MRD]
57e006a8:	e580101c 	str	r1, [r0, #28]

	ldr	r1, =DMC_DDR_t_RAS
57e006ac:	e3a01006 	mov	r1, #6
	str	r1, [r0, #INDEX_DMC_T_RAS]
57e006b0:	e5801020 	str	r1, [r0, #32]

	ldr	r1, =DMC_DDR_t_RC
57e006b4:	e3a0100a 	mov	r1, #10
	str	r1, [r0, #INDEX_DMC_T_RC]
57e006b8:	e5801024 	str	r1, [r0, #36]	; 0x24

	ldr	r1, =DMC_DDR_t_RCD
57e006bc:	e3a01004 	mov	r1, #4
	ldr	r2, =DMC_DDR_schedule_RCD
57e006c0:	e3a02008 	mov	r2, #8
	orr	r1, r1, r2
57e006c4:	e1811002 	orr	r1, r1, r2
	str	r1, [r0, #INDEX_DMC_T_RCD]
57e006c8:	e5801028 	str	r1, [r0, #40]	; 0x28

	ldr	r1, =DMC_DDR_t_RFC
57e006cc:	e3a0100b 	mov	r1, #11
	ldr	r2, =DMC_DDR_schedule_RFC
57e006d0:	e3a02c01 	mov	r2, #256	; 0x100
	orr	r1, r1, r2
57e006d4:	e1811002 	orr	r1, r1, r2
	str	r1, [r0, #INDEX_DMC_T_RFC]
57e006d8:	e580102c 	str	r1, [r0, #44]	; 0x2c

	ldr	r1, =DMC_DDR_t_RP
57e006dc:	e3a01004 	mov	r1, #4
	ldr	r2, =DMC_DDR_schedule_RP
57e006e0:	e3a02008 	mov	r2, #8
	orr	r1, r1, r2
57e006e4:	e1811002 	orr	r1, r1, r2
	str	r1, [r0, #INDEX_DMC_T_RP]
57e006e8:	e5801030 	str	r1, [r0, #48]	; 0x30

	ldr	r1, =DMC_DDR_t_RRD
57e006ec:	e3a01002 	mov	r1, #2
	str	r1, [r0, #INDEX_DMC_T_RRD]
57e006f0:	e5801034 	str	r1, [r0, #52]	; 0x34

	ldr	r1, =DMC_DDR_t_WR
57e006f4:	e3a01002 	mov	r1, #2
	str	r1, [r0, #INDEX_DMC_T_WR]
57e006f8:	e5801038 	str	r1, [r0, #56]	; 0x38

	ldr	r1, =DMC_DDR_t_WTR
57e006fc:	e3a01002 	mov	r1, #2
	str	r1, [r0, #INDEX_DMC_T_WTR]
57e00700:	e580103c 	str	r1, [r0, #60]	; 0x3c

	ldr	r1, =DMC_DDR_t_XP
57e00704:	e3a01002 	mov	r1, #2
	str	r1, [r0, #INDEX_DMC_T_XP]
57e00708:	e5801040 	str	r1, [r0, #64]	; 0x40

	ldr	r1, =DMC_DDR_t_XSR
57e0070c:	e3a01010 	mov	r1, #16
	str	r1, [r0, #INDEX_DMC_T_XSR]
57e00710:	e5801044 	str	r1, [r0, #68]	; 0x44

	ldr	r1, =DMC_DDR_t_ESR
57e00714:	e3a01010 	mov	r1, #16
	str	r1, [r0, #INDEX_DMC_T_ESR]
57e00718:	e5801048 	str	r1, [r0, #72]	; 0x48

	ldr	r1, =DMC1_MEM_CFG
57e0071c:	e59f1070 	ldr	r1, [pc, #112]	; 57e00794 <check_dmc1_ready+0x24>
	str	r1, [r0, #INDEX_DMC_MEMORY_CFG]
57e00720:	e580100c 	str	r1, [r0, #12]

	ldr	r1, =DMC1_MEM_CFG2
57e00724:	e59f106c 	ldr	r1, [pc, #108]	; 57e00798 <check_dmc1_ready+0x28>
	str	r1, [r0, #INDEX_DMC_MEMORY_CFG2]
57e00728:	e580104c 	str	r1, [r0, #76]	; 0x4c

	ldr	r1, =DMC1_CHIP0_CFG
57e0072c:	e59f1068 	ldr	r1, [pc, #104]	; 57e0079c <check_dmc1_ready+0x2c>
	str	r1, [r0, #INDEX_DMC_CHIP_0_CFG]
57e00730:	e5801200 	str	r1, [r0, #512]	; 0x200

	ldr	r1, =DMC_DDR_32_CFG
57e00734:	e3a01000 	mov	r1, #0
	str	r1, [r0, #INDEX_DMC_USER_CONFIG]
57e00738:	e5801304 	str	r1, [r0, #772]	; 0x304

	/* DMC0 DDR Chip 0 configuration direct command reg */
	ldr	r1, =DMC_NOP0
57e0073c:	e3a01703 	mov	r1, #786432	; 0xc0000
	str	r1, [r0, #INDEX_DMC_DIRECT_CMD]
57e00740:	e5801008 	str	r1, [r0, #8]

	/* Precharge All */
	ldr	r1, =DMC_PA0
57e00744:	e3a01000 	mov	r1, #0
	str	r1, [r0, #INDEX_DMC_DIRECT_CMD]
57e00748:	e5801008 	str	r1, [r0, #8]

	/* Auto Refresh 2 time */
	ldr	r1, =DMC_AR0
57e0074c:	e3a01701 	mov	r1, #262144	; 0x40000
	str	r1, [r0, #INDEX_DMC_DIRECT_CMD]
57e00750:	e5801008 	str	r1, [r0, #8]
	str	r1, [r0, #INDEX_DMC_DIRECT_CMD]
57e00754:	e5801008 	str	r1, [r0, #8]

	/* MRS */
	ldr	r1, =DMC_mDDR_EMR0
57e00758:	e3a0180a 	mov	r1, #655360	; 0xa0000
	str	r1, [r0, #INDEX_DMC_DIRECT_CMD]
57e0075c:	e5801008 	str	r1, [r0, #8]

	/* Mode Reg */
	ldr	r1, =DMC_mDDR_MR0
57e00760:	e59f1038 	ldr	r1, [pc, #56]	; 57e007a0 <check_dmc1_ready+0x30>
	str	r1, [r0, #INDEX_DMC_DIRECT_CMD]
57e00764:	e5801008 	str	r1, [r0, #8]

	/* Enable DMC1 */
	mov	r1, #0x0
57e00768:	e3a01000 	mov	r1, #0
	str	r1, [r0, #INDEX_DMC_MEMC_CMD]
57e0076c:	e5801004 	str	r1, [r0, #4]

57e00770 <check_dmc1_ready>:

check_dmc1_ready:
	ldr	r1, [r0, #INDEX_DMC_MEMC_STATUS]
57e00770:	e5901000 	ldr	r1, [r0]
	mov	r2, #0x3
57e00774:	e3a02003 	mov	r2, #3
	and	r1, r1, r2
57e00778:	e0011002 	and	r1, r1, r2
	cmp	r1, #0x1
57e0077c:	e3510001 	cmp	r1, #1
	bne	check_dmc1_ready
57e00780:	1afffffa 	bne	57e00770 <check_dmc1_ready>
	nop
57e00784:	e1a00000 	nop			; (mov r0, r0)

	mov	pc, lr
57e00788:	e1a0f00e 	mov	pc, lr
57e0078c:	7e001000 	.word	0x7e001000
57e00790:	0000040f 	.word	0x0000040f
57e00794:	00010012 	.word	0x00010012
57e00798:	00000b45 	.word	0x00000b45
57e0079c:	000150f8 	.word	0x000150f8
57e007a0:	00080032 	.word	0x00080032

57e007a4 <get_PLLCLK>:

static ulong get_PLLCLK(int pllreg)
{
	ulong r, m, p, s;

	switch (pllreg) {
57e007a4:	e3500001 	cmp	r0, #1
 * the specified bus in HZ.
 */
/* ------------------------------------------------------------------------- */

static ulong get_PLLCLK(int pllreg)
{
57e007a8:	e92d4010 	push	{r4, lr}
	ulong r, m, p, s;

	switch (pllreg) {
57e007ac:	0a000006 	beq	57e007cc <get_PLLCLK+0x28>
57e007b0:	e3500002 	cmp	r0, #2
57e007b4:	0a000007 	beq	57e007d8 <get_PLLCLK+0x34>
57e007b8:	e3500000 	cmp	r0, #0
	case APLL:
		r = APLL_CON_REG;
57e007bc:	059f304c 	ldreq	r3, [pc, #76]	; 57e00810 <get_PLLCLK+0x6c>
57e007c0:	0593400c 	ldreq	r4, [r3, #12]

static ulong get_PLLCLK(int pllreg)
{
	ulong r, m, p, s;

	switch (pllreg) {
57e007c4:	0a000007 	beq	57e007e8 <get_PLLCLK+0x44>
57e007c8:	ea000005 	b	57e007e4 <get_PLLCLK+0x40>
	case APLL:
		r = APLL_CON_REG;
		break;
	case MPLL:
		r = MPLL_CON_REG;
57e007cc:	e59f303c 	ldr	r3, [pc, #60]	; 57e00810 <get_PLLCLK+0x6c>
57e007d0:	e5934010 	ldr	r4, [r3, #16]
		break;
57e007d4:	ea000003 	b	57e007e8 <get_PLLCLK+0x44>
	case EPLL:
		r = EPLL_CON0_REG;
57e007d8:	e59f3030 	ldr	r3, [pc, #48]	; 57e00810 <get_PLLCLK+0x6c>
57e007dc:	e5934014 	ldr	r4, [r3, #20]
		break;
57e007e0:	ea000000 	b	57e007e8 <get_PLLCLK+0x44>
	default:
		hang();
57e007e4:	eb00012c 	bl	57e00c9c <hang>
	}

	m = (r >> 16) & 0x3ff;
	p = (r >> 8) & 0x3f;
57e007e8:	e1a01424 	lsr	r1, r4, #8
	s = r & 0x7;
57e007ec:	e2043007 	and	r3, r4, #7
	default:
		hang();
	}

	m = (r >> 16) & 0x3ff;
	p = (r >> 8) & 0x3f;
57e007f0:	e201103f 	and	r1, r1, #63	; 0x3f
	s = r & 0x7;

	return m * (CONFIG_SYS_CLK_FREQ / (p * (1 << s)));
57e007f4:	e1a01311 	lsl	r1, r1, r3
57e007f8:	e59f0014 	ldr	r0, [pc, #20]	; 57e00814 <get_PLLCLK+0x70>
57e007fc:	eb00abeb 	bl	57e2b7b0 <__udivsi3>
		break;
	default:
		hang();
	}

	m = (r >> 16) & 0x3ff;
57e00800:	e1a04304 	lsl	r4, r4, #6
57e00804:	e1a04b24 	lsr	r4, r4, #22
	p = (r >> 8) & 0x3f;
	s = r & 0x7;

	return m * (CONFIG_SYS_CLK_FREQ / (p * (1 << s)));
}
57e00808:	e0000094 	mul	r0, r4, r0
57e0080c:	e8bd8010 	pop	{r4, pc}
57e00810:	7e00f000 	.word	0x7e00f000
57e00814:	00b71b00 	.word	0x00b71b00

57e00818 <get_ARMCLK>:
/* return ARMCORE frequency */
ulong get_ARMCLK(void)
{
	ulong div;

	div = CLK_DIV0_REG;
57e00818:	e59f301c 	ldr	r3, [pc, #28]	; 57e0083c <get_ARMCLK+0x24>
	return m * (CONFIG_SYS_CLK_FREQ / (p * (1 << s)));
}

/* return ARMCORE frequency */
ulong get_ARMCLK(void)
{
57e0081c:	e92d4010 	push	{r4, lr}
	ulong div;

	div = CLK_DIV0_REG;
57e00820:	e5934020 	ldr	r4, [r3, #32]

	return get_PLLCLK(APLL) / ((div & 0x7) + 1);
57e00824:	e3a00000 	mov	r0, #0
57e00828:	ebffffdd 	bl	57e007a4 <get_PLLCLK>
57e0082c:	e2041007 	and	r1, r4, #7
57e00830:	e2811001 	add	r1, r1, #1
57e00834:	eb00abdd 	bl	57e2b7b0 <__udivsi3>
}
57e00838:	e8bd8010 	pop	{r4, pc}
57e0083c:	7e00f000 	.word	0x7e00f000

57e00840 <get_FCLK>:

/* return FCLK frequency */
ulong get_FCLK(void)
{
	return get_PLLCLK(APLL);
57e00840:	e3a00000 	mov	r0, #0
57e00844:	eaffffd6 	b	57e007a4 <get_PLLCLK>

57e00848 <get_HCLK>:
}

/* return HCLK frequency */
ulong get_HCLK(void)
{
57e00848:	e92d4038 	push	{r3, r4, r5, lr}
	ulong fclk;

	uint hclkx2_div = ((CLK_DIV0_REG >> 9) & 0x7) + 1;
57e0084c:	e59f3044 	ldr	r3, [pc, #68]	; 57e00898 <get_HCLK+0x50>
57e00850:	e5935020 	ldr	r5, [r3, #32]
	uint hclk_div = ((CLK_DIV0_REG >> 8) & 0x1) + 1;
57e00854:	e5934020 	ldr	r4, [r3, #32]

	/*
	 * Bit 7 exists on s3c6410, and not on s3c6400, it is reserved on
	 * s3c6400 and is always 0, and it is indeed running in ASYNC mode
	 */
	if (OTHERS_REG & 0x80)
57e00858:	e5933900 	ldr	r3, [r3, #2304]	; 0x900
/* return HCLK frequency */
ulong get_HCLK(void)
{
	ulong fclk;

	uint hclkx2_div = ((CLK_DIV0_REG >> 9) & 0x7) + 1;
57e0085c:	e1a054a5 	lsr	r5, r5, #9
	uint hclk_div = ((CLK_DIV0_REG >> 8) & 0x1) + 1;
57e00860:	e1a04424 	lsr	r4, r4, #8
/* return HCLK frequency */
ulong get_HCLK(void)
{
	ulong fclk;

	uint hclkx2_div = ((CLK_DIV0_REG >> 9) & 0x7) + 1;
57e00864:	e2055007 	and	r5, r5, #7
	uint hclk_div = ((CLK_DIV0_REG >> 8) & 0x1) + 1;
57e00868:	e2044001 	and	r4, r4, #1

	/*
	 * Bit 7 exists on s3c6410, and not on s3c6400, it is reserved on
	 * s3c6400 and is always 0, and it is indeed running in ASYNC mode
	 */
	if (OTHERS_REG & 0x80)
57e0086c:	e3130080 	tst	r3, #128	; 0x80
/* return HCLK frequency */
ulong get_HCLK(void)
{
	ulong fclk;

	uint hclkx2_div = ((CLK_DIV0_REG >> 9) & 0x7) + 1;
57e00870:	e2855001 	add	r5, r5, #1
	uint hclk_div = ((CLK_DIV0_REG >> 8) & 0x1) + 1;
57e00874:	e2844001 	add	r4, r4, #1

	/*
	 * Bit 7 exists on s3c6410, and not on s3c6400, it is reserved on
	 * s3c6400 and is always 0, and it is indeed running in ASYNC mode
	 */
	if (OTHERS_REG & 0x80)
57e00878:	0a000001 	beq	57e00884 <get_HCLK+0x3c>
		fclk = get_FCLK();		/* SYNC Mode	*/
57e0087c:	ebffffef 	bl	57e00840 <get_FCLK>
57e00880:	ea000001 	b	57e0088c <get_HCLK+0x44>
	else
		fclk = get_PLLCLK(MPLL);	/* ASYNC Mode	*/
57e00884:	e3a00001 	mov	r0, #1
57e00888:	ebffffc5 	bl	57e007a4 <get_PLLCLK>

	return fclk / (hclk_div * hclkx2_div);
57e0088c:	e0010495 	mul	r1, r5, r4
57e00890:	eb00abc6 	bl	57e2b7b0 <__udivsi3>
}
57e00894:	e8bd8038 	pop	{r3, r4, r5, pc}
57e00898:	7e00f000 	.word	0x7e00f000

57e0089c <get_PCLK>:

/* return PCLK frequency */
ulong get_PCLK(void)
{
57e0089c:	e92d4038 	push	{r3, r4, r5, lr}
	ulong fclk;
	uint hclkx2_div = ((CLK_DIV0_REG >> 9) & 0x7) + 1;
57e008a0:	e59f3044 	ldr	r3, [pc, #68]	; 57e008ec <get_PCLK+0x50>
57e008a4:	e5935020 	ldr	r5, [r3, #32]
	uint pre_div = ((CLK_DIV0_REG >> 12) & 0xf) + 1;
57e008a8:	e5934020 	ldr	r4, [r3, #32]

	if (OTHERS_REG & 0x80)
57e008ac:	e5933900 	ldr	r3, [r3, #2304]	; 0x900

/* return PCLK frequency */
ulong get_PCLK(void)
{
	ulong fclk;
	uint hclkx2_div = ((CLK_DIV0_REG >> 9) & 0x7) + 1;
57e008b0:	e1a054a5 	lsr	r5, r5, #9
	uint pre_div = ((CLK_DIV0_REG >> 12) & 0xf) + 1;
57e008b4:	e1a04624 	lsr	r4, r4, #12

/* return PCLK frequency */
ulong get_PCLK(void)
{
	ulong fclk;
	uint hclkx2_div = ((CLK_DIV0_REG >> 9) & 0x7) + 1;
57e008b8:	e2055007 	and	r5, r5, #7
	uint pre_div = ((CLK_DIV0_REG >> 12) & 0xf) + 1;
57e008bc:	e204400f 	and	r4, r4, #15

	if (OTHERS_REG & 0x80)
57e008c0:	e3130080 	tst	r3, #128	; 0x80

/* return PCLK frequency */
ulong get_PCLK(void)
{
	ulong fclk;
	uint hclkx2_div = ((CLK_DIV0_REG >> 9) & 0x7) + 1;
57e008c4:	e2855001 	add	r5, r5, #1
	uint pre_div = ((CLK_DIV0_REG >> 12) & 0xf) + 1;
57e008c8:	e2844001 	add	r4, r4, #1

	if (OTHERS_REG & 0x80)
57e008cc:	0a000001 	beq	57e008d8 <get_PCLK+0x3c>
		fclk = get_FCLK();		/* SYNC Mode	*/
57e008d0:	ebffffda 	bl	57e00840 <get_FCLK>
57e008d4:	ea000001 	b	57e008e0 <get_PCLK+0x44>
	else
		fclk = get_PLLCLK(MPLL);	/* ASYNC Mode	*/
57e008d8:	e3a00001 	mov	r0, #1
57e008dc:	ebffffb0 	bl	57e007a4 <get_PLLCLK>

	return fclk / (hclkx2_div * pre_div);
57e008e0:	e0010495 	mul	r1, r5, r4
57e008e4:	eb00abb1 	bl	57e2b7b0 <__udivsi3>
}
57e008e8:	e8bd8038 	pop	{r3, r4, r5, pc}
57e008ec:	7e00f000 	.word	0x7e00f000

57e008f0 <get_UCLK>:

/* return UCLK frequency */
ulong get_UCLK(void)
{
	return get_PLLCLK(EPLL);
57e008f0:	e3a00002 	mov	r0, #2
57e008f4:	eaffffaa 	b	57e007a4 <get_PLLCLK>

57e008f8 <print_cpuinfo>:
}

int print_cpuinfo(void)
{
57e008f8:	e92d4070 	push	{r4, r5, r6, lr}
	printf("\nCPU:     S3C6400@%luMHz\n", get_ARMCLK() / 1000000);
57e008fc:	ebffffc5 	bl	57e00818 <get_ARMCLK>
57e00900:	e59f1084 	ldr	r1, [pc, #132]	; 57e0098c <print_cpuinfo+0x94>
57e00904:	eb00aba9 	bl	57e2b7b0 <__udivsi3>
57e00908:	e1a01000 	mov	r1, r0
57e0090c:	e59f007c 	ldr	r0, [pc, #124]	; 57e00990 <print_cpuinfo+0x98>
57e00910:	eb0022cd 	bl	57e0944c <printf>
	printf("         Fclk = %luMHz, Hclk = %luMHz, Pclk = %luMHz ",
	       get_FCLK() / 1000000, get_HCLK() / 1000000,
57e00914:	ebffffc9 	bl	57e00840 <get_FCLK>
57e00918:	e1a05000 	mov	r5, r0
57e0091c:	ebffffc9 	bl	57e00848 <get_HCLK>
57e00920:	e1a04000 	mov	r4, r0
	       get_PCLK() / 1000000);
57e00924:	ebffffdc 	bl	57e0089c <get_PCLK>
}

int print_cpuinfo(void)
{
	printf("\nCPU:     S3C6400@%luMHz\n", get_ARMCLK() / 1000000);
	printf("         Fclk = %luMHz, Hclk = %luMHz, Pclk = %luMHz ",
57e00928:	e59f105c 	ldr	r1, [pc, #92]	; 57e0098c <print_cpuinfo+0x94>
	       get_FCLK() / 1000000, get_HCLK() / 1000000,
	       get_PCLK() / 1000000);
57e0092c:	e1a06000 	mov	r6, r0
}

int print_cpuinfo(void)
{
	printf("\nCPU:     S3C6400@%luMHz\n", get_ARMCLK() / 1000000);
	printf("         Fclk = %luMHz, Hclk = %luMHz, Pclk = %luMHz ",
57e00930:	e1a00005 	mov	r0, r5
57e00934:	eb00ab9d 	bl	57e2b7b0 <__udivsi3>
57e00938:	e59f104c 	ldr	r1, [pc, #76]	; 57e0098c <print_cpuinfo+0x94>
57e0093c:	e1a05000 	mov	r5, r0
57e00940:	e1a00004 	mov	r0, r4
57e00944:	eb00ab99 	bl	57e2b7b0 <__udivsi3>
57e00948:	e59f103c 	ldr	r1, [pc, #60]	; 57e0098c <print_cpuinfo+0x94>
57e0094c:	e1a04000 	mov	r4, r0
57e00950:	e1a00006 	mov	r0, r6
57e00954:	eb00ab95 	bl	57e2b7b0 <__udivsi3>
57e00958:	e1a01005 	mov	r1, r5
57e0095c:	e1a03000 	mov	r3, r0
57e00960:	e1a02004 	mov	r2, r4
57e00964:	e59f0028 	ldr	r0, [pc, #40]	; 57e00994 <print_cpuinfo+0x9c>
57e00968:	eb0022b7 	bl	57e0944c <printf>
	       get_FCLK() / 1000000, get_HCLK() / 1000000,
	       get_PCLK() / 1000000);

	if (OTHERS_REG & 0x80)
57e0096c:	e59f3024 	ldr	r3, [pc, #36]	; 57e00998 <print_cpuinfo+0xa0>
57e00970:	e5933900 	ldr	r3, [r3, #2304]	; 0x900
57e00974:	e3130080 	tst	r3, #128	; 0x80
		printf("(SYNC Mode) \n");
57e00978:	159f001c 	ldrne	r0, [pc, #28]	; 57e0099c <print_cpuinfo+0xa4>
	else
		printf("(ASYNC Mode) \n");
57e0097c:	059f001c 	ldreq	r0, [pc, #28]	; 57e009a0 <print_cpuinfo+0xa8>
57e00980:	eb0022b1 	bl	57e0944c <printf>
	return 0;
}
57e00984:	e3a00000 	mov	r0, #0
57e00988:	e8bd8070 	pop	{r4, r5, r6, pc}
57e0098c:	000f4240 	.word	0x000f4240
57e00990:	57e2dfdf 	.word	0x57e2dfdf
57e00994:	57e2dff9 	.word	0x57e2dff9
57e00998:	7e00f000 	.word	0x7e00f000
57e0099c:	57e2e02f 	.word	0x57e2e02f
57e009a0:	57e2e03d 	.word	0x57e2e03d

57e009a4 <timer_init>:
static unsigned long lastdec;
/* Monotonic incrementing timer */
static unsigned long long timestamp;

int timer_init(void)
{
57e009a4:	e92d4038 	push	{r3, r4, r5, lr}
	 * keep values up to 40,000s, i.e., 11 hours. This should be
	 * enough for most uses:-) Possible optimizations: select a
	 * binary-friendly frequency, e.g., 1ms / 128. Also calculate
	 * the prescaler automatically for other PCLK frequencies.
	 */
	timers->TCFG0 = PRESCALER << 8;
57e009a8:	e59f408c 	ldr	r4, [pc, #140]	; 57e00a3c <timer_init+0x98>
	if (timer_load_val == 0) {
57e009ac:	e59f508c 	ldr	r5, [pc, #140]	; 57e00a40 <timer_init+0x9c>
	 * keep values up to 40,000s, i.e., 11 hours. This should be
	 * enough for most uses:-) Possible optimizations: select a
	 * binary-friendly frequency, e.g., 1ms / 128. Also calculate
	 * the prescaler automatically for other PCLK frequencies.
	 */
	timers->TCFG0 = PRESCALER << 8;
57e009b0:	e3a03ca7 	mov	r3, #42752	; 0xa700
57e009b4:	e5843000 	str	r3, [r4]
	if (timer_load_val == 0) {
57e009b8:	e5953000 	ldr	r3, [r5]
57e009bc:	e3530000 	cmp	r3, #0
57e009c0:	1a000009 	bne	57e009ec <timer_init+0x48>
		timer_load_val = get_PCLK() / PRESCALER * (100 / 4); /* 100s */
57e009c4:	ebffffb4 	bl	57e0089c <get_PCLK>
57e009c8:	e3a010a7 	mov	r1, #167	; 0xa7
57e009cc:	eb00ab77 	bl	57e2b7b0 <__udivsi3>
57e009d0:	e3a03019 	mov	r3, #25
57e009d4:	e0030390 	mul	r3, r0, r3
57e009d8:	e5853000 	str	r3, [r5]
		timers->TCFG1 = (timers->TCFG1 & ~0xf0000) | 0x20000;
57e009dc:	e5943004 	ldr	r3, [r4, #4]
57e009e0:	e3c3380f 	bic	r3, r3, #983040	; 0xf0000
57e009e4:	e3833802 	orr	r3, r3, #131072	; 0x20000
57e009e8:	e5843004 	str	r3, [r4, #4]
	}

	/* load value for 10 ms timeout */
	lastdec = timers->TCNTB4 = timer_load_val;
57e009ec:	e59f204c 	ldr	r2, [pc, #76]	; 57e00a40 <timer_init+0x9c>
57e009f0:	e59f3044 	ldr	r3, [pc, #68]	; 57e00a3c <timer_init+0x98>
57e009f4:	e5921000 	ldr	r1, [r2]
	timers->TCON = (timers->TCON & ~0x00700000) | TCON_4_AUTO |
		TCON_4_UPDATE;

	/* auto load, start Timer 4 */
	timers->TCON = (timers->TCON & ~0x00700000) | TCON_4_AUTO | COUNT_4_ON;
	timestamp = 0;
57e009f8:	e3a04000 	mov	r4, #0
		timer_load_val = get_PCLK() / PRESCALER * (100 / 4); /* 100s */
		timers->TCFG1 = (timers->TCFG1 & ~0xf0000) | 0x20000;
	}

	/* load value for 10 ms timeout */
	lastdec = timers->TCNTB4 = timer_load_val;
57e009fc:	e583103c 	str	r1, [r3, #60]	; 0x3c
57e00a00:	e593103c 	ldr	r1, [r3, #60]	; 0x3c
	/* auto load, start Timer 4 */
	timers->TCON = (timers->TCON & ~0x00700000) | TCON_4_AUTO | COUNT_4_ON;
	timestamp = 0;

	return 0;
}
57e00a04:	e3a00000 	mov	r0, #0
		timer_load_val = get_PCLK() / PRESCALER * (100 / 4); /* 100s */
		timers->TCFG1 = (timers->TCFG1 & ~0xf0000) | 0x20000;
	}

	/* load value for 10 ms timeout */
	lastdec = timers->TCNTB4 = timer_load_val;
57e00a08:	e5821004 	str	r1, [r2, #4]
	/* auto load, manual update of Timer 4 */
	timers->TCON = (timers->TCON & ~0x00700000) | TCON_4_AUTO |
57e00a0c:	e5931008 	ldr	r1, [r3, #8]
57e00a10:	e3c11607 	bic	r1, r1, #7340032	; 0x700000
57e00a14:	e3811606 	orr	r1, r1, #6291456	; 0x600000
57e00a18:	e5831008 	str	r1, [r3, #8]
		TCON_4_UPDATE;

	/* auto load, start Timer 4 */
	timers->TCON = (timers->TCON & ~0x00700000) | TCON_4_AUTO | COUNT_4_ON;
57e00a1c:	e5931008 	ldr	r1, [r3, #8]
57e00a20:	e3c11607 	bic	r1, r1, #7340032	; 0x700000
57e00a24:	e3811605 	orr	r1, r1, #5242880	; 0x500000
57e00a28:	e5831008 	str	r1, [r3, #8]
	timestamp = 0;
57e00a2c:	e3a03000 	mov	r3, #0
57e00a30:	e5823008 	str	r3, [r2, #8]
57e00a34:	e582400c 	str	r4, [r2, #12]

	return 0;
}
57e00a38:	e8bd8038 	pop	{r3, r4, r5, pc}
57e00a3c:	7f006000 	.word	0x7f006000
57e00a40:	57e381f8 	.word	0x57e381f8

57e00a44 <get_ticks>:
/* macro to read the 16 bit timer */
static inline ulong read_timer(void)
{
	s3c64xx_timers *const timers = s3c64xx_get_base_timers();

	return timers->TCNTO4;
57e00a44:	e59f3044 	ldr	r3, [pc, #68]	; 57e00a90 <get_ticks+0x4c>
57e00a48:	e5932040 	ldr	r2, [r3, #64]	; 0x40
 */
unsigned long long get_ticks(void)
{
	ulong now = read_timer();

	if (lastdec >= now) {
57e00a4c:	e59f3040 	ldr	r3, [pc, #64]	; 57e00a94 <get_ticks+0x50>
57e00a50:	e5931004 	ldr	r1, [r3, #4]
57e00a54:	e1510002 	cmp	r1, r2
		/* normal mode */
		timestamp += lastdec - now;
	} else {
		/* we have an overflow ... */
		timestamp += lastdec + timer_load_val - now;
57e00a58:	3593c000 	ldrcc	ip, [r3]
57e00a5c:	3081100c 	addcc	r1, r1, ip
57e00a60:	e062c001 	rsb	ip, r2, r1
57e00a64:	e2831008 	add	r1, r3, #8
57e00a68:	e8910003 	ldm	r1, {r0, r1}
57e00a6c:	e090000c 	adds	r0, r0, ip
57e00a70:	e2a11000 	adc	r1, r1, #0
57e00a74:	e5830008 	str	r0, [r3, #8]
57e00a78:	e583100c 	str	r1, [r3, #12]
	}
	lastdec = now;
57e00a7c:	e59f3010 	ldr	r3, [pc, #16]	; 57e00a94 <get_ticks+0x50>
57e00a80:	e5832004 	str	r2, [r3, #4]

	return timestamp;
}
57e00a84:	e5930008 	ldr	r0, [r3, #8]
57e00a88:	e593100c 	ldr	r1, [r3, #12]
57e00a8c:	e12fff1e 	bx	lr
57e00a90:	7f006000 	.word	0x7f006000
57e00a94:	57e381f8 	.word	0x57e381f8

57e00a98 <get_tbclk>:
/*
 * This function is derived from PowerPC code (timebase clock frequency).
 * On ARM it returns the number of timer ticks per second.
 */
ulong get_tbclk(void)
{
57e00a98:	e92d4008 	push	{r3, lr}
	/* We overrun in 100s */
	return (ulong)(timer_load_val / 100);
57e00a9c:	e59f300c 	ldr	r3, [pc, #12]	; 57e00ab0 <get_tbclk+0x18>
57e00aa0:	e3a01064 	mov	r1, #100	; 0x64
57e00aa4:	e5930000 	ldr	r0, [r3]
57e00aa8:	eb00ab40 	bl	57e2b7b0 <__udivsi3>
}
57e00aac:	e8bd8008 	pop	{r3, pc}
57e00ab0:	57e381f8 	.word	0x57e381f8

57e00ab4 <get_timer_masked>:

ulong get_timer_masked(void)
{
57e00ab4:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	unsigned long long res = get_ticks();
57e00ab8:	ebffffe1 	bl	57e00a44 <get_ticks>
	do_div (res, (timer_load_val / (100 * CONFIG_SYS_HZ)));
57e00abc:	e59f3040 	ldr	r3, [pc, #64]	; 57e00b04 <get_timer_masked+0x50>
	return (ulong)(timer_load_val / 100);
}

ulong get_timer_masked(void)
{
	unsigned long long res = get_ticks();
57e00ac0:	e1a05001 	mov	r5, r1
57e00ac4:	e88d0003 	stm	sp, {r0, r1}
57e00ac8:	e1a04000 	mov	r4, r0
	do_div (res, (timer_load_val / (100 * CONFIG_SYS_HZ)));
57e00acc:	e59f1034 	ldr	r1, [pc, #52]	; 57e00b08 <get_timer_masked+0x54>
57e00ad0:	e5930000 	ldr	r0, [r3]
57e00ad4:	eb00ab35 	bl	57e2b7b0 <__udivsi3>
57e00ad8:	e3550000 	cmp	r5, #0
57e00adc:	e1a01000 	mov	r1, r0
57e00ae0:	1a000003 	bne	57e00af4 <get_timer_masked+0x40>
57e00ae4:	e1a00004 	mov	r0, r4
57e00ae8:	eb00ab30 	bl	57e2b7b0 <__udivsi3>
57e00aec:	e58d0000 	str	r0, [sp]
57e00af0:	ea000001 	b	57e00afc <get_timer_masked+0x48>
57e00af4:	e1a0000d 	mov	r0, sp
57e00af8:	eb008683 	bl	57e2250c <__div64_32>
	return res;
}
57e00afc:	e59d0000 	ldr	r0, [sp]
57e00b00:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
57e00b04:	57e381f8 	.word	0x57e381f8
57e00b08:	000186a0 	.word	0x000186a0

57e00b0c <get_timer>:

ulong get_timer(ulong base)
{
57e00b0c:	e92d4010 	push	{r4, lr}
57e00b10:	e1a04000 	mov	r4, r0
	return get_timer_masked() - base;
57e00b14:	ebffffe6 	bl	57e00ab4 <get_timer_masked>
}
57e00b18:	e0640000 	rsb	r0, r4, r0
57e00b1c:	e8bd8010 	pop	{r4, pc}

57e00b20 <__udelay>:

void __udelay(unsigned long usec)
{
57e00b20:	e92d4070 	push	{r4, r5, r6, lr}
57e00b24:	e1a06000 	mov	r6, r0
	unsigned long long tmp;
	ulong tmo;

	tmo = (usec + 9) / 10;
	tmp = get_ticks() + tmo;	/* get current timestamp */
57e00b28:	ebffffc5 	bl	57e00a44 <get_ticks>
57e00b2c:	e1a04000 	mov	r4, r0
57e00b30:	e1a05001 	mov	r5, r1
void __udelay(unsigned long usec)
{
	unsigned long long tmp;
	ulong tmo;

	tmo = (usec + 9) / 10;
57e00b34:	e2860009 	add	r0, r6, #9
57e00b38:	e3a0100a 	mov	r1, #10
57e00b3c:	eb00ab1b 	bl	57e2b7b0 <__udivsi3>
	tmp = get_ticks() + tmo;	/* get current timestamp */
57e00b40:	e0944000 	adds	r4, r4, r0
57e00b44:	e2a55000 	adc	r5, r5, #0

	while (get_ticks() < tmp)/* loop till event */
57e00b48:	ebffffbd 	bl	57e00a44 <get_ticks>
57e00b4c:	e1550001 	cmp	r5, r1
57e00b50:	8afffffc 	bhi	57e00b48 <__udelay+0x28>
57e00b54:	18bd8070 	popne	{r4, r5, r6, pc}
57e00b58:	e1540000 	cmp	r4, r0
57e00b5c:	8afffff9 	bhi	57e00b48 <__udelay+0x28>
57e00b60:	e8bd8070 	pop	{r4, r5, r6, pc}

57e00b64 <arch_cpu_init>:
 */

#include<common.h>

int arch_cpu_init(void)
{
57e00b64:	e92d4008 	push	{r3, lr}
	icache_enable();
57e00b68:	eb000271 	bl	57e01534 <icache_enable>

	return 0;
}
57e00b6c:	e3a00000 	mov	r0, #0
57e00b70:	e8bd8008 	pop	{r3, pc}

57e00b74 <_main>:
	/* deprecated, use instead CONFIG_SPL_BUILD */
	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
#elif defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
	ldr	sp, =(CONFIG_SPL_STACK)
#else
	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
57e00b74:	e59fd074 	ldr	sp, [pc, #116]	; 57e00bf0 <clbss_l+0x24>
#endif
	bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */
57e00b78:	e3cdd007 	bic	sp, sp, #7
	sub	sp, #GD_SIZE	/* allocate one GD above SP */
57e00b7c:	e24dd078 	sub	sp, sp, #120	; 0x78
	bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */
57e00b80:	e3cdd007 	bic	sp, sp, #7
	mov	r8, sp		/* GD is above SP */
57e00b84:	e1a0800d 	mov	r8, sp
	mov	r0, #0
57e00b88:	e3a00000 	mov	r0, #0
	bl	board_init_f
57e00b8c:	eb000081 	bl	57e00d98 <board_init_f>
 * Set up intermediate environment (new sp and gd) and call
 * relocate_code(addr_sp, gd, addr_moni). Trick here is that
 * we'll return 'here' but relocated.
 */

	ldr	sp, [r8, #GD_START_ADDR_SP]	/* r8 = gd->start_addr_sp */
57e00b90:	e598d044 	ldr	sp, [r8, #68]	; 0x44
	bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */
57e00b94:	e3cdd007 	bic	sp, sp, #7
	ldr	r8, [r8, #GD_BD]		/* r8 = gd->bd */
57e00b98:	e5988000 	ldr	r8, [r8]
	sub	r8, r8, #GD_SIZE		/* new GD is below bd */
57e00b9c:	e2488078 	sub	r8, r8, #120	; 0x78

	adr	lr, here
57e00ba0:	e28fe014 	add	lr, pc, #20
	ldr	r0, [r8, #GD_RELOC_OFF]		/* lr = gd->start_addr_sp */
57e00ba4:	e5980048 	ldr	r0, [r8, #72]	; 0x48
	add	lr, lr, r0
57e00ba8:	e08ee000 	add	lr, lr, r0
	ldr	r0, [r8, #GD_START_ADDR_SP]	/* r0 = gd->start_addr_sp */
57e00bac:	e5980044 	ldr	r0, [r8, #68]	; 0x44
	mov	r1, r8				/* r1 = gd */
57e00bb0:	e1a01008 	mov	r1, r8
	ldr	r2, [r8, #GD_RELOCADDR]		/* r2 = gd->relocaddr */
57e00bb4:	e5982034 	ldr	r2, [r8, #52]	; 0x34
	b	relocate_code
57e00bb8:	eafffd41 	b	57e000c4 <relocate_code>

57e00bbc <here>:
here:

/* Set up final (full) environment */

	bl	c_runtime_cpu_setup	/* we still call old routine here */
57e00bbc:	ebfffd6e 	bl	57e0017c <c_runtime_cpu_setup>

	ldr	r0, =__bss_start	/* this is auto-relocated! */
57e00bc0:	e59f002c 	ldr	r0, [pc, #44]	; 57e00bf4 <clbss_l+0x28>
	ldr	r1, =__bss_end__	/* this is auto-relocated! */
57e00bc4:	e59f102c 	ldr	r1, [pc, #44]	; 57e00bf8 <clbss_l+0x2c>

	mov	r2, #0x00000000		/* prepare zero to clear BSS */
57e00bc8:	e3a02000 	mov	r2, #0

57e00bcc <clbss_l>:

clbss_l:cmp	r0, r1			/* while not at end of BSS */
57e00bcc:	e1500001 	cmp	r0, r1
	strlo	r2, [r0]		/* clear 32-bit BSS word */
57e00bd0:	35802000 	strcc	r2, [r0]
	addlo	r0, r0, #4		/* move to next */
57e00bd4:	32800004 	addcc	r0, r0, #4
	blo	clbss_l
57e00bd8:	3afffffb 	bcc	57e00bcc <clbss_l>

#ifndef CONFIG_NAND_SPL
	bl coloured_LED_init
57e00bdc:	eb00001a 	bl	57e00c4c <__coloured_LED_init>
	bl red_led_on
57e00be0:	eb00001a 	bl	57e00c50 <__red_led_on>
	ldr     pc, =nand_boot

#else

	/* call board_init_r(gd_t *id, ulong dest_addr) */
	mov	r0, r8			/* gd_t */
57e00be4:	e1a00008 	mov	r0, r8
	ldr	r1, [r8, #GD_RELOCADDR]	/* dest_addr */
57e00be8:	e5981034 	ldr	r1, [r8, #52]	; 0x34
	/* call board_init_r */
	ldr	pc, =board_init_r	/* this is auto-relocated! */
57e00bec:	e59ff008 	ldr	pc, [pc, #8]	; 57e00bfc <clbss_l+0x30>
57e00bf0:	0c001f80 	.word	0x0c001f80
	...
57e00bfc:	57e00cb0 	.word	0x57e00cb0

57e00c00 <display_banner>:
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
	return 0;
}

static int display_banner(void)
{
57e00c00:	e92d4008 	push	{r3, lr}
	printf("\n\n%s\n\n", version_string);
57e00c04:	e59f100c 	ldr	r1, [pc, #12]	; 57e00c18 <display_banner+0x18>
57e00c08:	e59f000c 	ldr	r0, [pc, #12]	; 57e00c1c <display_banner+0x1c>
57e00c0c:	eb00220e 	bl	57e0944c <printf>
	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif

	return (0);
}
57e00c10:	e3a00000 	mov	r0, #0
57e00c14:	e8bd8008 	pop	{r3, pc}
57e00c18:	57e2bdc0 	.word	0x57e2bdc0
57e00c1c:	57e2e04c 	.word	0x57e2e04c

57e00c20 <init_baudrate>:
#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
#define CONFIG_BAUDRATE 115200
#endif

static int init_baudrate(void)
{
57e00c20:	e92d4010 	push	{r4, lr}
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
57e00c24:	e3a0100a 	mov	r1, #10
57e00c28:	e59f2014 	ldr	r2, [pc, #20]	; 57e00c44 <init_baudrate+0x24>
57e00c2c:	e59f0014 	ldr	r0, [pc, #20]	; 57e00c48 <init_baudrate+0x28>
57e00c30:	e1a04008 	mov	r4, r8
57e00c34:	eb001ae3 	bl	57e077c8 <getenv_ulong>
57e00c38:	e5840008 	str	r0, [r4, #8]
	return 0;
}
57e00c3c:	e3a00000 	mov	r0, #0
57e00c40:	e8bd8010 	pop	{r4, pc}
57e00c44:	0001c200 	.word	0x0001c200
57e00c48:	57e2e053 	.word	0x57e2e053

57e00c4c <__coloured_LED_init>:
/************************************************************************
 * Coloured LED functionality
 ************************************************************************
 * May be supplied by boards if desired
 */
inline void __coloured_LED_init(void) {}
57e00c4c:	e12fff1e 	bx	lr

57e00c50 <__red_led_on>:
void coloured_LED_init(void)
	__attribute__((weak, alias("__coloured_LED_init")));
inline void __red_led_on(void) {}
57e00c50:	e12fff1e 	bx	lr

57e00c54 <__red_led_off>:
void red_led_on(void) __attribute__((weak, alias("__red_led_on")));
inline void __red_led_off(void) {}
57e00c54:	e12fff1e 	bx	lr

57e00c58 <__green_led_on>:
void red_led_off(void) __attribute__((weak, alias("__red_led_off")));
inline void __green_led_on(void) {}
57e00c58:	e12fff1e 	bx	lr

57e00c5c <__green_led_off>:
void green_led_on(void) __attribute__((weak, alias("__green_led_on")));
inline void __green_led_off(void) {}
57e00c5c:	e12fff1e 	bx	lr

57e00c60 <__yellow_led_on>:
void green_led_off(void) __attribute__((weak, alias("__green_led_off")));
inline void __yellow_led_on(void) {}
57e00c60:	e12fff1e 	bx	lr

57e00c64 <__yellow_led_off>:
void yellow_led_on(void) __attribute__((weak, alias("__yellow_led_on")));
inline void __yellow_led_off(void) {}
57e00c64:	e12fff1e 	bx	lr

57e00c68 <__blue_led_on>:
void yellow_led_off(void) __attribute__((weak, alias("__yellow_led_off")));
inline void __blue_led_on(void) {}
57e00c68:	e12fff1e 	bx	lr

57e00c6c <__blue_led_off>:
void blue_led_on(void) __attribute__((weak, alias("__blue_led_on")));
inline void __blue_led_off(void) {}
57e00c6c:	e12fff1e 	bx	lr

57e00c70 <__dram_init_banksize>:

int print_cpuinfo(void);

void __dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
57e00c70:	e5982000 	ldr	r2, [r8]
57e00c74:	e3a01205 	mov	r1, #1342177280	; 0x50000000
57e00c78:	e5821018 	str	r1, [r2, #24]
	gd->bd->bi_dram[0].size =  gd->ram_size;
57e00c7c:	e5982000 	ldr	r2, [r8]
57e00c80:	e5983038 	ldr	r3, [r8, #56]	; 0x38
57e00c84:	e582301c 	str	r3, [r2, #28]
}
57e00c88:	e12fff1e 	bx	lr

57e00c8c <__arch_cpu_init>:
	__attribute__((weak, alias("__dram_init_banksize")));

int __arch_cpu_init(void)
{
	return 0;
}
57e00c8c:	e3a00000 	mov	r0, #0
57e00c90:	e12fff1e 	bx	lr

57e00c94 <__power_init_board>:
	__attribute__((weak, alias("__arch_cpu_init")));

int __power_init_board(void)
{
	return 0;
}
57e00c94:	e3a00000 	mov	r0, #0
57e00c98:	e12fff1e 	bx	lr

57e00c9c <hang>:

	/* NOTREACHED - no way out of command loop except booting */
}

void hang(void)
{
57e00c9c:	e92d4008 	push	{r3, lr}
	puts("### ERROR ### Please RESET the board ###\n");
57e00ca0:	e59f0004 	ldr	r0, [pc, #4]	; 57e00cac <hang+0x10>
57e00ca4:	eb0021de 	bl	57e09424 <puts>
57e00ca8:	eafffffe 	b	57e00ca8 <hang+0xc>
57e00cac:	57e2e05c 	.word	0x57e2e05c

57e00cb0 <board_init_r>:
	ulong malloc_start;
#if !defined(CONFIG_SYS_NO_FLASH)
	ulong flash_size;
#endif

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
57e00cb0:	e5982004 	ldr	r2, [r8, #4]
 *
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
57e00cb4:	e92d4008 	push	{r3, lr}
#endif

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

	monitor_flash_len = _end_ofs;
57e00cb8:	e59f30b4 	ldr	r3, [pc, #180]	; 57e00d74 <board_init_r+0xc4>
	ulong malloc_start;
#if !defined(CONFIG_SYS_NO_FLASH)
	ulong flash_size;
#endif

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
57e00cbc:	e3822001 	orr	r2, r2, #1
57e00cc0:	e5882004 	str	r2, [r8, #4]
	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

	monitor_flash_len = _end_ofs;
57e00cc4:	e5932000 	ldr	r2, [r3]
57e00cc8:	e59f30a8 	ldr	r3, [pc, #168]	; 57e00d78 <board_init_r+0xc8>
 *
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
57e00ccc:	e1a04001 	mov	r4, r1
#endif

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

	monitor_flash_len = _end_ofs;
57e00cd0:	e5832000 	str	r2, [r3]

	/* Enable caches */
	enable_caches();
57e00cd4:	eb0001b7 	bl	57e013b8 <__enable_caches>

	debug("monitor flash len: %08lX\n", monitor_flash_len);
	board_init();	/* Setup chipselects */
57e00cd8:	eb00aa76 	bl	57e2b6b8 <board_init>
	 * implement this.
	 */
#ifdef CONFIG_CLOCKS
	set_cpu_clk_info(); /* Setup clock information */
#endif
	serial_initialize();
57e00cdc:	eb0070ac 	bl	57e1cf94 <serial_initialize>
	post_output_backlog();
#endif

	/* The Malloc area is immediately below the monitor copy in DRAM */
	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
57e00ce0:	e3a01942 	mov	r1, #1081344	; 0x108000
57e00ce4:	e2440942 	sub	r0, r4, #1081344	; 0x108000
57e00ce8:	eb0022ef 	bl	57e098ac <mem_malloc_init>

#ifdef CONFIG_ARCH_EARLY_INIT_R
	arch_early_init_r();
#endif
	power_init_board();
57e00cec:	ebffffe8 	bl	57e00c94 <__power_init_board>

#if !defined(CONFIG_SYS_NO_FLASH)
	puts("Flash: ");
57e00cf0:	e59f0084 	ldr	r0, [pc, #132]	; 57e00d7c <board_init_r+0xcc>
57e00cf4:	eb0021ca 	bl	57e09424 <puts>

	flash_size = flash_init();
57e00cf8:	eb0053c4 	bl	57e15c10 <flash_init>
	if (flash_size > 0) {
57e00cfc:	e3500000 	cmp	r0, #0
57e00d00:	0a000016 	beq	57e00d60 <board_init_r+0xb0>
				(const unsigned char *) CONFIG_SYS_FLASH_BASE,
				flash_size));
		}
		putc('\n');
# else	/* !CONFIG_SYS_FLASH_CHECKSUM */
		print_size(flash_size, "\n");
57e00d04:	e3a01000 	mov	r1, #0
57e00d08:	e59f2070 	ldr	r2, [pc, #112]	; 57e00d80 <board_init_r+0xd0>
57e00d0c:	eb008557 	bl	57e22270 <print_size>
		hang();
	}
#endif

#if defined(CONFIG_CMD_NAND)
	puts("NAND:  ");
57e00d10:	e59f006c 	ldr	r0, [pc, #108]	; 57e00d84 <board_init_r+0xd4>
57e00d14:	eb0021c2 	bl	57e09424 <puts>
	nand_init();		/* go init the NAND */
57e00d18:	eb0054bb 	bl	57e1600c <nand_init>
	AT91F_DataflashInit();
	dataflash_print_info();
#endif

	/* initialize environment */
	env_relocate();
57e00d1c:	eb0028ae 	bl	57e0afdc <env_relocate>

#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
	arm_pci_init();
#endif

	stdio_init();	/* get the devices list going. */
57e00d20:	eb003b30 	bl	57e0f9e8 <stdio_init>

	jumptable_init();
57e00d24:	eb002b29 	bl	57e0b9d0 <jumptable_init>
#if defined(CONFIG_API)
	/* Initialize API */
	api_init();
#endif

	console_init_r();	/* fully init console as a device */
57e00d28:	eb00228e 	bl	57e09768 <console_init_r>
	interrupt_init();
	/* enable exceptions */
	enable_interrupts();

	/* Initialize from environment */
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
57e00d2c:	e59f4054 	ldr	r4, [pc, #84]	; 57e00d88 <board_init_r+0xd8>
	/* miscellaneous platform dependent initialisations */
	misc_init_r();
#endif

	 /* set up exceptions */
	interrupt_init();
57e00d30:	eb0000f3 	bl	57e01104 <interrupt_init>
	/* enable exceptions */
	enable_interrupts();
57e00d34:	eb0000f9 	bl	57e01120 <enable_interrupts>

	/* Initialize from environment */
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
57e00d38:	e3a01010 	mov	r1, #16
57e00d3c:	e5942000 	ldr	r2, [r4]
57e00d40:	e59f0044 	ldr	r0, [pc, #68]	; 57e00d8c <board_init_r+0xdc>
57e00d44:	eb001a9f 	bl	57e077c8 <getenv_ulong>
57e00d48:	e5840000 	str	r0, [r4]

#ifdef CONFIG_BITBANGMII
	bb_miiphy_init();
#endif
#if defined(CONFIG_CMD_NET)
	puts("Net:   ");
57e00d4c:	e59f003c 	ldr	r0, [pc, #60]	; 57e00d90 <board_init_r+0xe0>
57e00d50:	eb0021b3 	bl	57e09424 <puts>
	eth_initialize(gd->bd);
57e00d54:	e5980000 	ldr	r0, [r8]
57e00d58:	eb009f27 	bl	57e289fc <eth_initialize>
57e00d5c:	ea000002 	b	57e00d6c <board_init_r+0xbc>
		putc('\n');
# else	/* !CONFIG_SYS_FLASH_CHECKSUM */
		print_size(flash_size, "\n");
# endif /* CONFIG_SYS_FLASH_CHECKSUM */
	} else {
		puts(failed);
57e00d60:	e59f002c 	ldr	r0, [pc, #44]	; 57e00d94 <board_init_r+0xe4>
57e00d64:	eb0021ae 	bl	57e09424 <puts>
		hang();
57e00d68:	ebffffcb 	bl	57e00c9c <hang>
	}
#endif

	/* main_loop() can return to retry autoboot, if so just run it again. */
	for (;;) {
		main_loop();
57e00d6c:	eb00398a 	bl	57e0f39c <main_loop>
57e00d70:	eafffffd 	b	57e00d6c <board_init_r+0xbc>
57e00d74:	57e00050 	.word	0x57e00050
57e00d78:	57e38208 	.word	0x57e38208
57e00d7c:	57e2e086 	.word	0x57e2e086
57e00d80:	57e32390 	.word	0x57e32390
57e00d84:	57e2e08e 	.word	0x57e2e08e
57e00d88:	57e36e60 	.word	0x57e36e60
57e00d8c:	57e2e096 	.word	0x57e2e096
57e00d90:	57e2e09f 	.word	0x57e2e09f
57e00d94:	57e2e0a7 	.word	0x57e2e0a7

57e00d98 <board_init_f>:
	dram_init,		/* configure available RAM banks */
	NULL,
};

void board_init_f(ulong bootflag)
{
57e00d98:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	void *new_fdt = NULL;
	size_t fdt_size = 0;

	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");

	memset((void *)gd, 0, sizeof(gd_t));
57e00d9c:	e3a01000 	mov	r1, #0
57e00da0:	e3a02078 	mov	r2, #120	; 0x78
57e00da4:	e1a00008 	mov	r0, r8
57e00da8:	eb008d33 	bl	57e2427c <memset>

	gd->mon_len = _bss_end_ofs;
57e00dac:	e59f30e8 	ldr	r3, [pc, #232]	; 57e00e9c <board_init_f+0x104>
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
57e00db0:	e59f00e8 	ldr	r0, [pc, #232]	; 57e00ea0 <board_init_f+0x108>

	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
57e00db4:	e5933000 	ldr	r3, [r3]
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
57e00db8:	e3a01010 	mov	r1, #16

	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
57e00dbc:	e588303c 	str	r3, [r8, #60]	; 0x3c
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
						(uintptr_t)gd->fdt_blob);
57e00dc0:	e5982050 	ldr	r2, [r8, #80]	; 0x50

	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
57e00dc4:	e1a04008 	mov	r4, r8
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
57e00dc8:	eb001a7e 	bl	57e077c8 <getenv_ulong>
57e00dcc:	e5840050 	str	r0, [r4, #80]	; 0x50
57e00dd0:	e59f40cc 	ldr	r4, [pc, #204]	; 57e00ea4 <board_init_f+0x10c>
						(uintptr_t)gd->fdt_blob);

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
57e00dd4:	ea000003 	b	57e00de8 <board_init_f+0x50>
		if ((*init_fnc_ptr)() != 0) {
57e00dd8:	e12fff37 	blx	r7
57e00ddc:	e3500000 	cmp	r0, #0
57e00de0:	0a000000 	beq	57e00de8 <board_init_f+0x50>
			hang ();
57e00de4:	ebffffac 	bl	57e00c9c <hang>
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
						(uintptr_t)gd->fdt_blob);

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
57e00de8:	e5b47004 	ldr	r7, [r4, #4]!
57e00dec:	e3570000 	cmp	r7, #0
57e00df0:	1afffff8 	bne	57e00dd8 <board_init_f+0x40>
	 * get fixed.
	 */
	gd->ram_size -= CONFIG_SYS_MEM_TOP_HIDE;
#endif

	addr = CONFIG_SYS_SDRAM_BASE + gd->ram_size;
57e00df4:	e5982038 	ldr	r2, [r8, #56]	; 0x38
	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
#endif /* CONFIG_PRAM */

#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	/* reserve TLB table */
	addr -= (4096 * 4);
57e00df8:	e59f40a8 	ldr	r4, [pc, #168]	; 57e00ea8 <board_init_f+0x110>
	gd->bd = bd;
	debug("Reserving %zu Bytes for Board Info at: %08lx\n",
			sizeof (bd_t), addr_sp);

#ifdef CONFIG_MACH_TYPE
	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
57e00dfc:	e59f10a8 	ldr	r1, [pc, #168]	; 57e00eac <board_init_f+0x114>
	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
#endif /* CONFIG_PRAM */

#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	/* reserve TLB table */
	addr -= (4096 * 4);
57e00e00:	e0824004 	add	r4, r2, r4

	/* round down to next 64 kB limit */
	addr &= ~(0x10000 - 1);
57e00e04:	e1a04824 	lsr	r4, r4, #16
57e00e08:	e1a04804 	lsl	r4, r4, #16

	gd->tlb_addr = addr;
57e00e0c:	e588404c 	str	r4, [r8, #76]	; 0x4c

	/*
	 * reserve memory for U-Boot code, data & bss
	 * round down to next 4 kB limit
	 */
	addr -= gd->mon_len;
57e00e10:	e598203c 	ldr	r2, [r8, #60]	; 0x3c
57e00e14:	e0624004 	rsb	r4, r2, r4
	addr &= ~(4096 - 1);
57e00e18:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
57e00e1c:	e3c4400f 	bic	r4, r4, #15
			TOTAL_MALLOC_LEN >> 10, addr_sp);
	/*
	 * (permanently) allocate a Board Info struct
	 * and a permanent copy of the "global" data
	 */
	addr_sp -= sizeof (bd_t);
57e00e20:	e2446942 	sub	r6, r4, #1081344	; 0x108000
57e00e24:	e2462020 	sub	r2, r6, #32
	bd = (bd_t *) addr_sp;
	gd->bd = bd;
57e00e28:	e5882000 	str	r2, [r8]
	debug("Reserving %zu Bytes for Board Info at: %08lx\n",
			sizeof (bd_t), addr_sp);

#ifdef CONFIG_MACH_TYPE
	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
57e00e2c:	e5982000 	ldr	r2, [r8]
#endif

	addr_sp -= sizeof (gd_t);
57e00e30:	e2465098 	sub	r5, r6, #152	; 0x98
	gd->bd = bd;
	debug("Reserving %zu Bytes for Board Info at: %08lx\n",
			sizeof (bd_t), addr_sp);

#ifdef CONFIG_MACH_TYPE
	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
57e00e34:	e5821004 	str	r1, [r2, #4]
		      fdt_size, addr_sp);
	}
#endif

	/* setup stackpointer for exeptions */
	gd->irq_sp = addr_sp;
57e00e38:	e5885040 	str	r5, [r8, #64]	; 0x40
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
57e00e3c:	e5982000 	ldr	r2, [r8]
57e00e40:	e5983008 	ldr	r3, [r8, #8]
#endif
	/* leave 3 words for abort-stack    */
	addr_sp -= 12;

	/* 8-byte alignment for ABI compliance */
	addr_sp &= ~0x07;
57e00e44:	e24660a8 	sub	r6, r6, #168	; 0xa8
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
57e00e48:	e5823000 	str	r3, [r2]
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
57e00e4c:	eb00aa2c 	bl	57e2b704 <dram_init_banksize>
	}
#else
	ulong size = 0;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
		size += gd->bd->bi_dram[i].size;
57e00e50:	e5983000 	ldr	r3, [r8]

	puts("DRAM:  ");
57e00e54:	e59f0054 	ldr	r0, [pc, #84]	; 57e00eb0 <board_init_f+0x118>
	}
#else
	ulong size = 0;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
		size += gd->bd->bi_dram[i].size;
57e00e58:	e593a01c 	ldr	sl, [r3, #28]

	puts("DRAM:  ");
57e00e5c:	eb002170 	bl	57e09424 <puts>
	print_size(size, "\n");
57e00e60:	e1a0000a 	mov	r0, sl
57e00e64:	e1a01007 	mov	r1, r7
57e00e68:	e59f2044 	ldr	r2, [pc, #68]	; 57e00eb4 <board_init_f+0x11c>
57e00e6c:	eb0084ff 	bl	57e22270 <print_size>
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
57e00e70:	e59f3040 	ldr	r3, [pc, #64]	; 57e00eb8 <board_init_f+0x120>
	gd->bd->bi_baudrate = gd->baudrate;
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
57e00e74:	e5884034 	str	r4, [r8, #52]	; 0x34
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
57e00e78:	e5933000 	ldr	r3, [r3]
	gd->bd->bi_baudrate = gd->baudrate;
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
57e00e7c:	e1a01008 	mov	r1, r8
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
57e00e80:	e0634004 	rsb	r4, r3, r4
	debug("relocation Offset is: %08lx\n", gd->reloc_off);
	if (new_fdt) {
		memcpy(new_fdt, gd->fdt_blob, fdt_size);
		gd->fdt_blob = new_fdt;
	}
	memcpy(id, (void *)gd, sizeof(gd_t));
57e00e84:	e1a00005 	mov	r0, r5
57e00e88:	e3a02078 	mov	r2, #120	; 0x78
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
57e00e8c:	e5886044 	str	r6, [r8, #68]	; 0x44
	gd->reloc_off = addr - _TEXT_BASE;
57e00e90:	e5884048 	str	r4, [r8, #72]	; 0x48
	if (new_fdt) {
		memcpy(new_fdt, gd->fdt_blob, fdt_size);
		gd->fdt_blob = new_fdt;
	}
	memcpy(id, (void *)gd, sizeof(gd_t));
}
57e00e94:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	debug("relocation Offset is: %08lx\n", gd->reloc_off);
	if (new_fdt) {
		memcpy(new_fdt, gd->fdt_blob, fdt_size);
		gd->fdt_blob = new_fdt;
	}
	memcpy(id, (void *)gd, sizeof(gd_t));
57e00e98:	ea008d1b 	b	57e2430c <memcpy>
57e00e9c:	57e0004c 	.word	0x57e0004c
57e00ea0:	57e2e0b7 	.word	0x57e2e0b7
57e00ea4:	57e35f40 	.word	0x57e35f40
57e00ea8:	4fffc000 	.word	0x4fffc000
57e00eac:	000004f6 	.word	0x000004f6
57e00eb0:	57e2e0c6 	.word	0x57e2e0c6
57e00eb4:	57e32390 	.word	0x57e32390
57e00eb8:	57e00040 	.word	0x57e00040

57e00ebc <boot_jump_linux.clone.5>:
#endif /* all tags */
	}
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
57e00ebc:	e92d4013 	push	{r0, r1, r4, lr}
{
	unsigned long machid = gd->bd->bi_arch_number;
57e00ec0:	e5983000 	ldr	r3, [r8]
#endif /* all tags */
	}
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
57e00ec4:	e1a04000 	mov	r4, r0
{
	unsigned long machid = gd->bd->bi_arch_number;
57e00ec8:	e5933004 	ldr	r3, [r3, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
57e00ecc:	e59f0050 	ldr	r0, [pc, #80]	; 57e00f24 <boot_jump_linux.clone.5+0x68>
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
{
	unsigned long machid = gd->bd->bi_arch_number;
57e00ed0:	e58d3004 	str	r3, [sp, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
57e00ed4:	eb001a03 	bl	57e076e8 <getenv>
	if (s) {
57e00ed8:	e3500000 	cmp	r0, #0
57e00edc:	0a000005 	beq	57e00ef8 <boot_jump_linux.clone.5+0x3c>
		strict_strtoul(s, 16, &machid);
57e00ee0:	e3a01010 	mov	r1, #16
57e00ee4:	e28d2004 	add	r2, sp, #4
57e00ee8:	eb009098 	bl	57e25150 <strict_strtoul>
		printf("Using machid 0x%lx from environment\n", machid);
57e00eec:	e59f0034 	ldr	r0, [pc, #52]	; 57e00f28 <boot_jump_linux.clone.5+0x6c>
57e00ef0:	e59d1004 	ldr	r1, [sp, #4]
57e00ef4:	eb002154 	bl	57e0944c <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e00ef8:	e3a0000f 	mov	r0, #15
57e00efc:	eb003698 	bl	57e0e964 <__show_boot_progress>
}
#endif

static void announce_and_cleanup(void)
{
	printf("\nStarting kernel ...\n\n");
57e00f00:	e59f0024 	ldr	r0, [pc, #36]	; 57e00f2c <boot_jump_linux.clone.5+0x70>
57e00f04:	eb002150 	bl	57e0944c <printf>
#endif

#ifdef CONFIG_USB_DEVICE
	udc_disconnect();
#endif
	cleanup_before_linux();
57e00f08:	ebfffdcb 	bl	57e0063c <cleanup_before_linux>
#ifdef CONFIG_OF_LIBFDT
	if (images->ft_len)
		r2 = (unsigned long)images->ft_addr;
	else
#endif
		r2 = gd->bd->bi_boot_params;
57e00f0c:	e5983000 	ldr	r3, [r8]

	kernel_entry(0, machid, r2);
57e00f10:	e3a00000 	mov	r0, #0
57e00f14:	e59d1004 	ldr	r1, [sp, #4]
57e00f18:	e5932008 	ldr	r2, [r3, #8]
57e00f1c:	e12fff34 	blx	r4
}
57e00f20:	e8bd801c 	pop	{r2, r3, r4, pc}
57e00f24:	57e2e0ce 	.word	0x57e2e0ce
57e00f28:	57e2e0d5 	.word	0x57e2e0d5
57e00f2c:	57e2e0fa 	.word	0x57e2e0fa

57e00f30 <arch_lmb_reserve>:
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
57e00f30:	e598c000 	ldr	ip, [r8]
57e00f34:	e5983000 	ldr	r3, [r8]

static ulong get_sp(void)
{
	ulong ret;

	asm("mov %0, sp" : "=r"(ret) : );
57e00f38:	e1a0100d 	mov	r1, sp
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
57e00f3c:	e593201c 	ldr	r2, [r3, #28]
57e00f40:	e59c3018 	ldr	r3, [ip, #24]
	 */
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
57e00f44:	e2411a01 	sub	r1, r1, #4096	; 0x1000
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
57e00f48:	e0822003 	add	r2, r2, r3
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
57e00f4c:	e0612002 	rsb	r2, r1, r2
57e00f50:	ea008ad8 	b	57e23ab8 <lmb_reserve>

57e00f54 <setup_board_tags>:

	return 0;
}
#endif

__weak void setup_board_tags(struct tag **in_params) {}
57e00f54:	e12fff1e 	bx	lr

57e00f58 <boot_prep_linux>:

/* Subcommand: PREP */
static void boot_prep_linux(bootm_headers_t *images)
{
57e00f58:	e92d4070 	push	{r4, r5, r6, lr}
57e00f5c:	e1a05000 	mov	r5, r0
#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv("bootargs");
57e00f60:	e59f012c 	ldr	r0, [pc, #300]	; 57e01094 <boot_prep_linux+0x13c>
57e00f64:	eb0019df 	bl	57e076e8 <getenv>
	defined(CONFIG_CMDLINE_TAG) || \
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
		debug("using: ATAGS\n");
		setup_start_tag(gd->bd);
57e00f68:	e5983000 	ldr	r3, [r8]

	params->u.core.flags = 0;
	params->u.core.pagesize = 0;
	params->u.core.rootdev = 0;

	params = tag_next (params);
57e00f6c:	e59f1124 	ldr	r1, [pc, #292]	; 57e01098 <boot_prep_linux+0x140>
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;
57e00f70:	e5934008 	ldr	r4, [r3, #8]

	params->hdr.tag = ATAG_CORE;
57e00f74:	e59f3120 	ldr	r3, [pc, #288]	; 57e0109c <boot_prep_linux+0x144>
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
57e00f78:	e3500000 	cmp	r0, #0
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;

	params->hdr.tag = ATAG_CORE;
57e00f7c:	e5843004 	str	r3, [r4, #4]
	params->hdr.size = tag_size (tag_core);
57e00f80:	e3a03005 	mov	r3, #5
57e00f84:	e5843000 	str	r3, [r4]

	params->u.core.flags = 0;
57e00f88:	e3a03000 	mov	r3, #0
57e00f8c:	e5843008 	str	r3, [r4, #8]
	params->u.core.pagesize = 0;
57e00f90:	e584300c 	str	r3, [r4, #12]
	params->u.core.rootdev = 0;
57e00f94:	e5843010 	str	r3, [r4, #16]

	params = tag_next (params);
57e00f98:	e2843014 	add	r3, r4, #20
57e00f9c:	e5813000 	str	r3, [r1]
		setup_start_tag(gd->bd);
#ifdef CONFIG_SERIAL_TAG
		setup_serial_tag(&params);
#endif
#ifdef CONFIG_CMDLINE_TAG
		setup_commandline_tag(gd->bd, commandline);
57e00fa0:	e5982000 	ldr	r2, [r8]
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
57e00fa4:	0a000015 	beq	57e01000 <boot_prep_linux+0xa8>
57e00fa8:	e1a06000 	mov	r6, r0
		return;

	/* eat leading white space */
	for (p = commandline; *p == ' '; p++);
57e00fac:	e4d02001 	ldrb	r2, [r0], #1
57e00fb0:	e3520020 	cmp	r2, #32
57e00fb4:	0afffffb 	beq	57e00fa8 <boot_prep_linux+0x50>

	/* skip non-existent command lines so the kernel will still
	 * use its default command line.
	 */
	if (*p == '\0')
57e00fb8:	e3520000 	cmp	r2, #0
57e00fbc:	0a00000f 	beq	57e01000 <boot_prep_linux+0xa8>
		return;

	params->hdr.tag = ATAG_CMDLINE;
57e00fc0:	e59f20d8 	ldr	r2, [pc, #216]	; 57e010a0 <boot_prep_linux+0x148>
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
57e00fc4:	e1a00006 	mov	r0, r6
	 * use its default command line.
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
57e00fc8:	e5832004 	str	r2, [r3, #4]
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
57e00fcc:	eb008c1f 	bl	57e24050 <strlen>
57e00fd0:	e280000d 	add	r0, r0, #13
57e00fd4:	e1a00120 	lsr	r0, r0, #2
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
	params->hdr.size =
57e00fd8:	e5840014 	str	r0, [r4, #20]
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;

	strcpy (params->u.cmdline.cmdline, p);
57e00fdc:	e59f40b4 	ldr	r4, [pc, #180]	; 57e01098 <boot_prep_linux+0x140>
57e00fe0:	e1a01006 	mov	r1, r6
57e00fe4:	e5940000 	ldr	r0, [r4]
57e00fe8:	e2800008 	add	r0, r0, #8
57e00fec:	eb008bbb 	bl	57e23ee0 <strcpy>

	params = tag_next (params);
57e00ff0:	e5943000 	ldr	r3, [r4]
57e00ff4:	e5932000 	ldr	r2, [r3]
57e00ff8:	e0833102 	add	r3, r3, r2, lsl #2
57e00ffc:	e5843000 	str	r3, [r4]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
57e01000:	e59f1090 	ldr	r1, [pc, #144]	; 57e01098 <boot_prep_linux+0x140>
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
57e01004:	e5982000 	ldr	r2, [r8]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
57e01008:	e5913000 	ldr	r3, [r1]
57e0100c:	e59f0090 	ldr	r0, [pc, #144]	; 57e010a4 <boot_prep_linux+0x14c>
		params->hdr.size = tag_size (tag_mem32);
57e01010:	e3a0e004 	mov	lr, #4
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
57e01014:	e5830004 	str	r0, [r3, #4]
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
57e01018:	e5920018 	ldr	r0, [r2, #24]
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);
57e0101c:	e583e000 	str	lr, [r3]

		params->u.mem.start = bd->bi_dram[i].start;
57e01020:	e583000c 	str	r0, [r3, #12]
		params->u.mem.size = bd->bi_dram[i].size;
57e01024:	e592201c 	ldr	r2, [r2, #28]
57e01028:	e5832008 	str	r2, [r3, #8]
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
57e0102c:	e5950064 	ldr	r0, [r5, #100]	; 0x64
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;

		params = tag_next (params);
57e01030:	e2832010 	add	r2, r3, #16
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
57e01034:	e3500000 	cmp	r0, #0
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;

		params = tag_next (params);
57e01038:	e5812000 	str	r2, [r1]
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
57e0103c:	0a00000b 	beq	57e01070 <boot_prep_linux+0x118>
57e01040:	e595c068 	ldr	ip, [r5, #104]	; 0x68
57e01044:	e35c0000 	cmp	ip, #0
57e01048:	0a000008 	beq	57e01070 <boot_prep_linux+0x118>
			setup_initrd_tag(gd->bd, images->rd_start,
57e0104c:	e5984000 	ldr	r4, [r8]
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
57e01050:	e59f4050 	ldr	r4, [pc, #80]	; 57e010a8 <boot_prep_linux+0x150>
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
57e01054:	e5820008 	str	r0, [r2, #8]
	params->u.initrd.size = initrd_end - initrd_start;
57e01058:	e060000c 	rsb	r0, r0, ip
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
57e0105c:	e5824004 	str	r4, [r2, #4]
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;
57e01060:	e582000c 	str	r0, [r2, #12]

	params = tag_next (params);
57e01064:	e2822010 	add	r2, r2, #16
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
	params->hdr.size = tag_size (tag_initrd);
57e01068:	e583e010 	str	lr, [r3, #16]

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;

	params = tag_next (params);
57e0106c:	e5812000 	str	r2, [r1]
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
			setup_initrd_tag(gd->bd, images->rd_start,
			images->rd_end);
#endif
		setup_board_tags(&params);
57e01070:	e59f4020 	ldr	r4, [pc, #32]	; 57e01098 <boot_prep_linux+0x140>
57e01074:	e1a00004 	mov	r0, r4
57e01078:	ebffffb5 	bl	57e00f54 <setup_board_tags>
		setup_end_tag(gd->bd);
57e0107c:	e5983000 	ldr	r3, [r8]
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_end_tag(bd_t *bd)
{
	params->hdr.tag = ATAG_NONE;
57e01080:	e5943000 	ldr	r3, [r4]
57e01084:	e3a02000 	mov	r2, #0
57e01088:	e5832004 	str	r2, [r3, #4]
	params->hdr.size = 0;
57e0108c:	e5832000 	str	r2, [r3]
#else /* all tags */
		printf("FDT and ATAGS support not compiled in - hanging\n");
		hang();
#endif /* all tags */
	}
}
57e01090:	e8bd8070 	pop	{r4, r5, r6, pc}
57e01094:	57e2e111 	.word	0x57e2e111
57e01098:	57e3820c 	.word	0x57e3820c
57e0109c:	54410001 	.word	0x54410001
57e010a0:	54410009 	.word	0x54410009
57e010a4:	54410002 	.word	0x54410002
57e010a8:	54420005 	.word	0x54420005

57e010ac <do_bootm_linux>:
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
57e010ac:	e92d4070 	push	{r4, r5, r6, lr}
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
57e010b0:	e2105030 	ands	r5, r0, #48	; 0x30
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
57e010b4:	e1a04003 	mov	r4, r3
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
		return -1;
57e010b8:	13e05000 	mvnne	r5, #0
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
57e010bc:	1a00000e 	bne	57e010fc <do_bootm_linux+0x50>
		return -1;

	if (flag & BOOTM_STATE_OS_PREP) {
57e010c0:	e2106040 	ands	r6, r0, #64	; 0x40
57e010c4:	0a000002 	beq	57e010d4 <do_bootm_linux+0x28>
		boot_prep_linux(images);
57e010c8:	e1a00003 	mov	r0, r3
57e010cc:	ebffffa1 	bl	57e00f58 <boot_prep_linux>
		return 0;
57e010d0:	ea000009 	b	57e010fc <do_bootm_linux+0x50>
	}

	if (flag & BOOTM_STATE_OS_GO) {
57e010d4:	e2105080 	ands	r5, r0, #128	; 0x80
57e010d8:	0a000003 	beq	57e010ec <do_bootm_linux+0x40>
		boot_jump_linux(images);
57e010dc:	e5930060 	ldr	r0, [r3, #96]	; 0x60
57e010e0:	ebffff75 	bl	57e00ebc <boot_jump_linux.clone.5>
		return 0;
57e010e4:	e1a05006 	mov	r5, r6
57e010e8:	ea000003 	b	57e010fc <do_bootm_linux+0x50>
	}

	boot_prep_linux(images);
57e010ec:	e1a00003 	mov	r0, r3
57e010f0:	ebffff98 	bl	57e00f58 <boot_prep_linux>
	boot_jump_linux(images);
57e010f4:	e5940060 	ldr	r0, [r4, #96]	; 0x60
57e010f8:	ebffff6f 	bl	57e00ebc <boot_jump_linux.clone.5>
	return 0;
}
57e010fc:	e1a00005 	mov	r0, r5
57e01100:	e8bd8070 	pop	{r4, r5, r6, pc}

57e01104 <interrupt_init>:
int interrupt_init (void)
{
	/*
	 * setup up stacks if necessary
	 */
	IRQ_STACK_START_IN = gd->irq_sp + 8;
57e01104:	e5982040 	ldr	r2, [r8, #64]	; 0x40
57e01108:	e59f300c 	ldr	r3, [pc, #12]	; 57e0111c <interrupt_init+0x18>
57e0110c:	e2822008 	add	r2, r2, #8
57e01110:	e5832000 	str	r2, [r3]

	return 0;
}
57e01114:	e3a00000 	mov	r0, #0
57e01118:	e12fff1e 	bx	lr
57e0111c:	57e00054 	.word	0x57e00054

57e01120 <enable_interrupts>:

void enable_interrupts (void)
{
	return;
}
57e01120:	e12fff1e 	bx	lr

57e01124 <disable_interrupts>:
int disable_interrupts (void)
{
	return 0;
}
57e01124:	e3a00000 	mov	r0, #0
57e01128:	e12fff1e 	bx	lr

57e0112c <bad_mode>:
#endif


void bad_mode (void)
{
57e0112c:	e92d4008 	push	{r3, lr}
	panic ("Resetting CPU ...\n");
57e01130:	e59f0000 	ldr	r0, [pc, #0]	; 57e01138 <bad_mode+0xc>
57e01134:	eb00908c 	bl	57e2536c <panic>
57e01138:	57e2e11a 	.word	0x57e2e11a

57e0113c <show_regs>:
	reset_cpu (0);
}

void show_regs (struct pt_regs *regs)
{
57e0113c:	e92d4070 	push	{r4, r5, r6, lr}
57e01140:	e24dd088 	sub	sp, sp, #136	; 0x88
57e01144:	e1a04000 	mov	r4, r0
	unsigned long flags;
	const char *processor_modes[] = {
57e01148:	e59f1104 	ldr	r1, [pc, #260]	; 57e01254 <show_regs+0x118>
57e0114c:	e28d0008 	add	r0, sp, #8
57e01150:	e3a02080 	mov	r2, #128	; 0x80
57e01154:	eb008c6c 	bl	57e2430c <memcpy>
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
57e01158:	e5943030 	ldr	r3, [r4, #48]	; 0x30
57e0115c:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
57e01160:	e58d3000 	str	r3, [sp]
57e01164:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
57e01168:	e5942038 	ldr	r2, [r4, #56]	; 0x38
57e0116c:	e58d3004 	str	r3, [sp, #4]
57e01170:	e59f00e0 	ldr	r0, [pc, #224]	; 57e01258 <show_regs+0x11c>
57e01174:	e5943034 	ldr	r3, [r4, #52]	; 0x34
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
57e01178:	e5945040 	ldr	r5, [r4, #64]	; 0x40

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
57e0117c:	eb0020b2 	bl	57e0944c <printf>
		"sp : %08lx  ip : %08lx	 fp : %08lx\n",
		instruction_pointer (regs),
		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
	printf ("r10: %08lx  r9 : %08lx	 r8 : %08lx\n",
57e01180:	e5941028 	ldr	r1, [r4, #40]	; 0x28
57e01184:	e5942024 	ldr	r2, [r4, #36]	; 0x24
57e01188:	e5943020 	ldr	r3, [r4, #32]
57e0118c:	e59f00c8 	ldr	r0, [pc, #200]	; 57e0125c <show_regs+0x120>
57e01190:	eb0020ad 	bl	57e0944c <printf>
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
57e01194:	e5943010 	ldr	r3, [r4, #16]
57e01198:	e594101c 	ldr	r1, [r4, #28]
57e0119c:	e58d3000 	str	r3, [sp]
57e011a0:	e5942018 	ldr	r2, [r4, #24]
57e011a4:	e5943014 	ldr	r3, [r4, #20]
57e011a8:	e59f00b0 	ldr	r0, [pc, #176]	; 57e01260 <show_regs+0x124>
57e011ac:	eb0020a6 	bl	57e0944c <printf>
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
57e011b0:	e5943000 	ldr	r3, [r4]
57e011b4:	e594100c 	ldr	r1, [r4, #12]
57e011b8:	e58d3000 	str	r3, [sp]
57e011bc:	e5942008 	ldr	r2, [r4, #8]
57e011c0:	e5943004 	ldr	r3, [r4, #4]
57e011c4:	e59f0098 	ldr	r0, [pc, #152]	; 57e01264 <show_regs+0x128>
57e011c8:	eb00209f 	bl	57e0944c <printf>
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
57e011cc:	e3150101 	tst	r5, #1073741824	; 0x40000000
57e011d0:	03a0207a 	moveq	r2, #122	; 0x7a
57e011d4:	13a0205a 	movne	r2, #90	; 0x5a
57e011d8:	e3150202 	tst	r5, #536870912	; 0x20000000
57e011dc:	03a03063 	moveq	r3, #99	; 0x63
57e011e0:	13a03043 	movne	r3, #67	; 0x43
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
57e011e4:	e205620f 	and	r6, r5, #-268435456	; 0xf0000000
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
57e011e8:	e3150201 	tst	r5, #268435456	; 0x10000000
57e011ec:	03a01076 	moveq	r1, #118	; 0x76
57e011f0:	13a01056 	movne	r1, #86	; 0x56
57e011f4:	e3560000 	cmp	r6, #0
57e011f8:	e58d1000 	str	r1, [sp]
57e011fc:	e59f0064 	ldr	r0, [pc, #100]	; 57e01268 <show_regs+0x12c>
57e01200:	a3a0106e 	movge	r1, #110	; 0x6e
57e01204:	b3a0104e 	movlt	r1, #78	; 0x4e
57e01208:	eb00208f 	bl	57e0944c <printf>
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
		interrupts_enabled (regs) ? "on" : "off",
57e0120c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
57e01210:	e59fc054 	ldr	ip, [pc, #84]	; 57e0126c <show_regs+0x130>
57e01214:	e59f2054 	ldr	r2, [pc, #84]	; 57e01270 <show_regs+0x134>
57e01218:	e3130080 	tst	r3, #128	; 0x80
57e0121c:	01a0100c 	moveq	r1, ip
57e01220:	11a01002 	movne	r1, r2
57e01224:	e28d0088 	add	r0, sp, #136	; 0x88
57e01228:	e3130040 	tst	r3, #64	; 0x40
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
57e0122c:	e203301f 	and	r3, r3, #31
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
57e01230:	e0803103 	add	r3, r0, r3, lsl #2
57e01234:	e59f0038 	ldr	r0, [pc, #56]	; 57e01274 <show_regs+0x138>
57e01238:	01a0200c 	moveq	r2, ip
57e0123c:	e58d0000 	str	r0, [sp]
57e01240:	e5133080 	ldr	r3, [r3, #-128]	; 0x80
57e01244:	e59f002c 	ldr	r0, [pc, #44]	; 57e01278 <show_regs+0x13c>
57e01248:	eb00207f 	bl	57e0944c <printf>
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
		thumb_mode (regs) ? " (T)" : "");
}
57e0124c:	e28dd088 	add	sp, sp, #136	; 0x88
57e01250:	e8bd8070 	pop	{r4, r5, r6, pc}
57e01254:	57e2bc60 	.word	0x57e2bc60
57e01258:	57e2e12d 	.word	0x57e2e12d
57e0125c:	57e2e172 	.word	0x57e2e172
57e01260:	57e2e196 	.word	0x57e2e196
57e01264:	57e2e1c6 	.word	0x57e2e1c6
57e01268:	57e2e1f6 	.word	0x57e2e1f6
57e0126c:	57e357fe 	.word	0x57e357fe
57e01270:	57e2e48c 	.word	0x57e2e48c
57e01274:	57e302de 	.word	0x57e302de
57e01278:	57e2e206 	.word	0x57e2e206

57e0127c <do_undefined_instruction>:

void do_undefined_instruction (struct pt_regs *pt_regs)
{
57e0127c:	e92d4010 	push	{r4, lr}
57e01280:	e1a04000 	mov	r4, r0
	printf ("undefined instruction\n");
57e01284:	e59f0010 	ldr	r0, [pc, #16]	; 57e0129c <do_undefined_instruction+0x20>
57e01288:	eb00206f 	bl	57e0944c <printf>
	show_regs (pt_regs);
57e0128c:	e1a00004 	mov	r0, r4
57e01290:	ebffffa9 	bl	57e0113c <show_regs>
	bad_mode ();
}
57e01294:	e8bd4010 	pop	{r4, lr}

void do_undefined_instruction (struct pt_regs *pt_regs)
{
	printf ("undefined instruction\n");
	show_regs (pt_regs);
	bad_mode ();
57e01298:	eaffffa3 	b	57e0112c <bad_mode>
57e0129c:	57e2e225 	.word	0x57e2e225

57e012a0 <do_software_interrupt>:
}

void do_software_interrupt (struct pt_regs *pt_regs)
{
57e012a0:	e92d4010 	push	{r4, lr}
57e012a4:	e1a04000 	mov	r4, r0
	printf ("software interrupt\n");
57e012a8:	e59f0010 	ldr	r0, [pc, #16]	; 57e012c0 <do_software_interrupt+0x20>
57e012ac:	eb002066 	bl	57e0944c <printf>
	show_regs (pt_regs);
57e012b0:	e1a00004 	mov	r0, r4
57e012b4:	ebffffa0 	bl	57e0113c <show_regs>
	bad_mode ();
}
57e012b8:	e8bd4010 	pop	{r4, lr}

void do_software_interrupt (struct pt_regs *pt_regs)
{
	printf ("software interrupt\n");
	show_regs (pt_regs);
	bad_mode ();
57e012bc:	eaffff9a 	b	57e0112c <bad_mode>
57e012c0:	57e2e23c 	.word	0x57e2e23c

57e012c4 <do_prefetch_abort>:
}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
57e012c4:	e92d4010 	push	{r4, lr}
57e012c8:	e1a04000 	mov	r4, r0
	printf ("prefetch abort\n");
57e012cc:	e59f0010 	ldr	r0, [pc, #16]	; 57e012e4 <do_prefetch_abort+0x20>
57e012d0:	eb00205d 	bl	57e0944c <printf>
	show_regs (pt_regs);
57e012d4:	e1a00004 	mov	r0, r4
57e012d8:	ebffff97 	bl	57e0113c <show_regs>
	bad_mode ();
}
57e012dc:	e8bd4010 	pop	{r4, lr}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
	printf ("prefetch abort\n");
	show_regs (pt_regs);
	bad_mode ();
57e012e0:	eaffff91 	b	57e0112c <bad_mode>
57e012e4:	57e2e250 	.word	0x57e2e250

57e012e8 <do_data_abort>:
}

void do_data_abort (struct pt_regs *pt_regs)
{
57e012e8:	e92d4010 	push	{r4, lr}
57e012ec:	e1a04000 	mov	r4, r0
	printf ("data abort\n\n    MAYBE you should read doc/README.arm-unaligned-accesses\n\n");
57e012f0:	e59f0010 	ldr	r0, [pc, #16]	; 57e01308 <do_data_abort+0x20>
57e012f4:	eb002054 	bl	57e0944c <printf>
	show_regs (pt_regs);
57e012f8:	e1a00004 	mov	r0, r4
57e012fc:	ebffff8e 	bl	57e0113c <show_regs>
	bad_mode ();
}
57e01300:	e8bd4010 	pop	{r4, lr}

void do_data_abort (struct pt_regs *pt_regs)
{
	printf ("data abort\n\n    MAYBE you should read doc/README.arm-unaligned-accesses\n\n");
	show_regs (pt_regs);
	bad_mode ();
57e01304:	eaffff88 	b	57e0112c <bad_mode>
57e01308:	57e2e260 	.word	0x57e2e260

57e0130c <do_not_used>:
}

void do_not_used (struct pt_regs *pt_regs)
{
57e0130c:	e92d4010 	push	{r4, lr}
57e01310:	e1a04000 	mov	r4, r0
	printf ("not used\n");
57e01314:	e59f0010 	ldr	r0, [pc, #16]	; 57e0132c <do_not_used+0x20>
57e01318:	eb00204b 	bl	57e0944c <printf>
	show_regs (pt_regs);
57e0131c:	e1a00004 	mov	r0, r4
57e01320:	ebffff85 	bl	57e0113c <show_regs>
	bad_mode ();
}
57e01324:	e8bd4010 	pop	{r4, lr}

void do_not_used (struct pt_regs *pt_regs)
{
	printf ("not used\n");
	show_regs (pt_regs);
	bad_mode ();
57e01328:	eaffff7f 	b	57e0112c <bad_mode>
57e0132c:	57e2e2aa 	.word	0x57e2e2aa

57e01330 <do_fiq>:
}

void do_fiq (struct pt_regs *pt_regs)
{
57e01330:	e92d4010 	push	{r4, lr}
57e01334:	e1a04000 	mov	r4, r0
	printf ("fast interrupt request\n");
57e01338:	e59f0010 	ldr	r0, [pc, #16]	; 57e01350 <do_fiq+0x20>
57e0133c:	eb002042 	bl	57e0944c <printf>
	show_regs (pt_regs);
57e01340:	e1a00004 	mov	r0, r4
57e01344:	ebffff7c 	bl	57e0113c <show_regs>
	bad_mode ();
}
57e01348:	e8bd4010 	pop	{r4, lr}

void do_fiq (struct pt_regs *pt_regs)
{
	printf ("fast interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
57e0134c:	eaffff76 	b	57e0112c <bad_mode>
57e01350:	57e2e2b4 	.word	0x57e2e2b4

57e01354 <do_irq>:
}

#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
57e01354:	e92d4010 	push	{r4, lr}
57e01358:	e1a04000 	mov	r4, r0
	printf ("interrupt request\n");
57e0135c:	e59f0010 	ldr	r0, [pc, #16]	; 57e01374 <do_irq+0x20>
57e01360:	eb002039 	bl	57e0944c <printf>
	show_regs (pt_regs);
57e01364:	e1a00004 	mov	r0, r4
57e01368:	ebffff73 	bl	57e0113c <show_regs>
	bad_mode ();
}
57e0136c:	e8bd4010 	pop	{r4, lr}
#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
	printf ("interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
57e01370:	eaffff6d 	b	57e0112c <bad_mode>
57e01374:	57e2e2b9 	.word	0x57e2e2b9

57e01378 <do_reset>:
 */

#include <common.h>

int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e01378:	e92d4008 	push	{r3, lr}
	puts ("resetting ...\n");
57e0137c:	e59f001c 	ldr	r0, [pc, #28]	; 57e013a0 <do_reset+0x28>
57e01380:	eb002027 	bl	57e09424 <puts>

	udelay (50000);				/* wait 50 ms */
57e01384:	e59f0018 	ldr	r0, [pc, #24]	; 57e013a4 <do_reset+0x2c>
57e01388:	eb008c6a 	bl	57e24538 <udelay>

	disable_interrupts();
57e0138c:	ebffff64 	bl	57e01124 <disable_interrupts>
	reset_cpu(0);
57e01390:	e3a00000 	mov	r0, #0
57e01394:	ebfffcb1 	bl	57e00660 <reset_cpu>

	/*NOTREACHED*/
	return 0;
}
57e01398:	e3a00000 	mov	r0, #0
57e0139c:	e8bd8008 	pop	{r3, pc}
57e013a0:	57e2e3b8 	.word	0x57e2e3b8
57e013a4:	0000c350 	.word	0x0000c350

57e013a8 <__flush_cache>:
	asm("0: mrc p15, 0, r15, c7, c10, 3\n\t" "bne 0b\n" : : : "memory");
	/* disable write buffer as well (page 2-22) */
	asm("mcr p15, 0, %0, c7, c10, 4" : : "r" (0));
#endif
	return;
}
57e013a8:	e12fff1e 	bx	lr

57e013ac <__flush_dcache_all>:
 * Default implementation:
 * do a range flush for the entire range
 */
void	__flush_dcache_all(void)
{
	flush_cache(0, ~0);
57e013ac:	e3a00000 	mov	r0, #0
57e013b0:	e3e01000 	mvn	r1, #0
57e013b4:	eafffffb 	b	57e013a8 <__flush_cache>

57e013b8 <__enable_caches>:
 * Default implementation of enable_caches()
 * Real implementation should be in platform code
 */
void __enable_caches(void)
{
	puts("WARNING: Caches not enabled\n");
57e013b8:	e59f0000 	ldr	r0, [pc, #0]	; 57e013c0 <__enable_caches+0x8>
57e013bc:	ea002018 	b	57e09424 <puts>
57e013c0:	57e2e3c7 	.word	0x57e2e3c7

57e013c4 <cp_delay>:
}
void arm_init_before_mmu(void)
	__attribute__((weak, alias("__arm_init_before_mmu")));

static void cp_delay (void)
{
57e013c4:	e24dd008 	sub	sp, sp, #8
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
57e013c8:	e3a03000 	mov	r3, #0
57e013cc:	ea000002 	b	57e013dc <cp_delay+0x18>
		nop();
57e013d0:	e1a00000 	nop			; (mov r0, r0)
static void cp_delay (void)
{
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
57e013d4:	e59d3004 	ldr	r3, [sp, #4]
57e013d8:	e2833001 	add	r3, r3, #1
57e013dc:	e58d3004 	str	r3, [sp, #4]
57e013e0:	e59d3004 	ldr	r3, [sp, #4]
57e013e4:	e3530063 	cmp	r3, #99	; 0x63
57e013e8:	dafffff8 	ble	57e013d0 <cp_delay+0xc>
		nop();
	asm volatile("" : : : "memory");
}
57e013ec:	e28dd008 	add	sp, sp, #8
57e013f0:	e12fff1e 	bx	lr

57e013f4 <cache_disable>:
	set_cr(reg | cache_bit);
}

/* cache_bit must be either CR_I or CR_C */
static void cache_disable(uint32_t cache_bit)
{
57e013f4:	e92d4038 	push	{r3, r4, r5, lr}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
57e013f8:	ee115f10 	mrc	15, 0, r5, cr1, cr0, {0}
57e013fc:	e1a04000 	mov	r4, r0
	uint32_t reg;

	reg = get_cr();
	cp_delay();
57e01400:	ebffffef 	bl	57e013c4 <cp_delay>

	if (cache_bit == CR_C) {
57e01404:	e3540004 	cmp	r4, #4
57e01408:	1a000003 	bne	57e0141c <cache_disable+0x28>
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
57e0140c:	e3150004 	tst	r5, #4
57e01410:	08bd8038 	popeq	{r3, r4, r5, pc}
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
		flush_dcache_all();
57e01414:	ebffffe4 	bl	57e013ac <__flush_dcache_all>
	if (cache_bit == CR_C) {
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
57e01418:	e2844001 	add	r4, r4, #1
		flush_dcache_all();
	}
	set_cr(reg & ~cache_bit);
57e0141c:	e1c54004 	bic	r4, r5, r4
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
57e01420:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	  : : "r" (val) : "cc");
	isb();
57e01424:	e8bd8038 	pop	{r3, r4, r5, pc}

57e01428 <__arm_init_before_mmu>:

DECLARE_GLOBAL_DATA_PTR;

void __arm_init_before_mmu(void)
{
}
57e01428:	e12fff1e 	bx	lr

57e0142c <set_section_dcache>:
	asm volatile("" : : : "memory");
}

void set_section_dcache(int section, enum dcache_option option)
{
	u32 *page_table = (u32 *)gd->tlb_addr;
57e0142c:	e598304c 	ldr	r3, [r8, #76]	; 0x4c
	u32 value;

	value = (section << MMU_SECTION_SHIFT) | (3 << 10);
57e01430:	e1811a00 	orr	r1, r1, r0, lsl #20
	value |= option;
57e01434:	e3811b03 	orr	r1, r1, #3072	; 0xc00
	page_table[section] = value;
57e01438:	e7831100 	str	r1, [r3, r0, lsl #2]
}
57e0143c:	e12fff1e 	bx	lr

57e01440 <cache_enable>:
static void cache_enable(uint32_t cache_bit)
{
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
57e01440:	e3500004 	cmp	r0, #4
	return get_cr() & CR_M;
}

/* cache_bit must be either CR_I or CR_C */
static void cache_enable(uint32_t cache_bit)
{
57e01444:	e92d4070 	push	{r4, r5, r6, lr}
57e01448:	e1a06000 	mov	r6, r0
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
57e0144c:	1a00001e 	bne	57e014cc <cache_enable+0x8c>
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
57e01450:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
57e01454:	e2144001 	ands	r4, r4, #1
57e01458:	1a00001b 	bne	57e014cc <cache_enable+0x8c>
static inline void mmu_setup(void)
{
	int i;
	u32 reg;

	arm_init_before_mmu();
57e0145c:	ebfffff1 	bl	57e01428 <__arm_init_before_mmu>
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
		set_section_dcache(i, DCACHE_OFF);
57e01460:	e1a00004 	mov	r0, r4
57e01464:	e3a01012 	mov	r1, #18
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
57e01468:	e2844001 	add	r4, r4, #1
		set_section_dcache(i, DCACHE_OFF);
57e0146c:	ebffffee 	bl	57e0142c <set_section_dcache>
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
57e01470:	e3540a01 	cmp	r4, #4096	; 0x1000
57e01474:	1afffff9 	bne	57e01460 <cache_enable+0x20>
	mmu_page_table_flush((u32)&page_table[start], (u32)&page_table[end]);
}

static inline void dram_bank_mmu_setup(int bank)
{
	bd_t *bd = gd->bd;
57e01478:	e5985000 	ldr	r5, [r8]
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
57e0147c:	e5954018 	ldr	r4, [r5, #24]
57e01480:	e1a04a24 	lsr	r4, r4, #20
57e01484:	ea000003 	b	57e01498 <cache_enable+0x58>
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
	     i++) {
#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
		set_section_dcache(i, DCACHE_WRITETHROUGH);
#else
		set_section_dcache(i, DCACHE_WRITEBACK);
57e01488:	e1a00004 	mov	r0, r4
57e0148c:	e3a0101e 	mov	r1, #30
57e01490:	ebffffe5 	bl	57e0142c <set_section_dcache>
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
	     i++) {
57e01494:	e2844001 	add	r4, r4, #1
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
57e01498:	e595201c 	ldr	r2, [r5, #28]
57e0149c:	e5953018 	ldr	r3, [r5, #24]
57e014a0:	e0823003 	add	r3, r2, r3
{
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
57e014a4:	e1540a23 	cmp	r4, r3, lsr #20
57e014a8:	3afffff6 	bcc	57e01488 <cache_enable+0x48>
		dram_bank_mmu_setup(i);
	}

	/* Copy the page table address to cp15 */
	asm volatile("mcr p15, 0, %0, c2, c0, 0"
		     : : "r" (gd->tlb_addr) : "memory");
57e014ac:	e598304c 	ldr	r3, [r8, #76]	; 0x4c
	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		dram_bank_mmu_setup(i);
	}

	/* Copy the page table address to cp15 */
	asm volatile("mcr p15, 0, %0, c2, c0, 0"
57e014b0:	ee023f10 	mcr	15, 0, r3, cr2, cr0, {0}
		     : : "r" (gd->tlb_addr) : "memory");
	/* Set the access control to all-supervisor */
	asm volatile("mcr p15, 0, %0, c3, c0, 0"
57e014b4:	e3e03000 	mvn	r3, #0
57e014b8:	ee033f10 	mcr	15, 0, r3, cr3, cr0, {0}
		     : : "r" (~0));
	/* and enable the mmu */
	reg = get_cr();	/* get control reg. */
	cp_delay();
57e014bc:	ebffffc0 	bl	57e013c4 <cp_delay>
57e014c0:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	set_cr(reg | CR_M);
57e014c4:	e3844001 	orr	r4, r4, #1
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
57e014c8:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
57e014cc:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
		mmu_setup();
	reg = get_cr();	/* get control reg. */
	cp_delay();
57e014d0:	ebffffbb 	bl	57e013c4 <cp_delay>
	set_cr(reg | cache_bit);
57e014d4:	e1846006 	orr	r6, r4, r6
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
57e014d8:	ee016f10 	mcr	15, 0, r6, cr1, cr0, {0}
}
57e014dc:	e8bd8070 	pop	{r4, r5, r6, pc}

57e014e0 <__mmu_page_table_flush>:
}

void __mmu_page_table_flush(unsigned long start, unsigned long stop)
{
	debug("%s: Warning: not implemented\n", __func__);
}
57e014e0:	e12fff1e 	bx	lr

57e014e4 <mmu_set_region_dcache_behaviour>:
void mmu_page_table_flush(unsigned long start, unsigned long stop)
	__attribute__((weak, alias("__mmu_page_table_flush")));

void mmu_set_region_dcache_behaviour(u32 start, int size,
				     enum dcache_option option)
{
57e014e4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	u32 *page_table = (u32 *)gd->tlb_addr;
	u32 upto, end;

	end = ALIGN(start + size, MMU_SECTION_SIZE) >> MMU_SECTION_SHIFT;
57e014e8:	e240637f 	sub	r6, r0, #-67108863	; 0xfc000001
57e014ec:	e246663f 	sub	r6, r6, #66060288	; 0x3f00000
57e014f0:	e0866001 	add	r6, r6, r1
	start = start >> MMU_SECTION_SHIFT;
57e014f4:	e1a07a20 	lsr	r7, r0, #20
void mmu_page_table_flush(unsigned long start, unsigned long stop)
	__attribute__((weak, alias("__mmu_page_table_flush")));

void mmu_set_region_dcache_behaviour(u32 start, int size,
				     enum dcache_option option)
{
57e014f8:	e1a0a002 	mov	sl, r2
	u32 *page_table = (u32 *)gd->tlb_addr;
57e014fc:	e598504c 	ldr	r5, [r8, #76]	; 0x4c
	u32 upto, end;

	end = ALIGN(start + size, MMU_SECTION_SIZE) >> MMU_SECTION_SHIFT;
57e01500:	e1a06a26 	lsr	r6, r6, #20
	start = start >> MMU_SECTION_SHIFT;
	debug("%s: start=%x, size=%x, option=%d\n", __func__, start, size,
	      option);
	for (upto = start; upto < end; upto++)
57e01504:	e1a04007 	mov	r4, r7
57e01508:	ea000003 	b	57e0151c <mmu_set_region_dcache_behaviour+0x38>
		set_section_dcache(upto, option);
57e0150c:	e1a00004 	mov	r0, r4
57e01510:	e1a0100a 	mov	r1, sl
57e01514:	ebffffc4 	bl	57e0142c <set_section_dcache>

	end = ALIGN(start + size, MMU_SECTION_SIZE) >> MMU_SECTION_SHIFT;
	start = start >> MMU_SECTION_SHIFT;
	debug("%s: start=%x, size=%x, option=%d\n", __func__, start, size,
	      option);
	for (upto = start; upto < end; upto++)
57e01518:	e2844001 	add	r4, r4, #1
57e0151c:	e1540006 	cmp	r4, r6
57e01520:	3afffff9 	bcc	57e0150c <mmu_set_region_dcache_behaviour+0x28>
		set_section_dcache(upto, option);
	mmu_page_table_flush((u32)&page_table[start], (u32)&page_table[end]);
57e01524:	e0850107 	add	r0, r5, r7, lsl #2
57e01528:	e0851106 	add	r1, r5, r6, lsl #2
}
57e0152c:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	start = start >> MMU_SECTION_SHIFT;
	debug("%s: start=%x, size=%x, option=%d\n", __func__, start, size,
	      option);
	for (upto = start; upto < end; upto++)
		set_section_dcache(upto, option);
	mmu_page_table_flush((u32)&page_table[start], (u32)&page_table[end]);
57e01530:	eaffffea 	b	57e014e0 <__mmu_page_table_flush>

57e01534 <icache_enable>:
	return 0;					/* always off */
}
#else
void icache_enable(void)
{
	cache_enable(CR_I);
57e01534:	e3a00a01 	mov	r0, #4096	; 0x1000
57e01538:	eaffffc0 	b	57e01440 <cache_enable>

57e0153c <icache_disable>:
}

void icache_disable(void)
{
	cache_disable(CR_I);
57e0153c:	e3a00a01 	mov	r0, #4096	; 0x1000
57e01540:	eaffffab 	b	57e013f4 <cache_disable>

57e01544 <icache_status>:
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
57e01544:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
}

int icache_status(void)
{
	return (get_cr() & CR_I) != 0;
57e01548:	e3130a01 	tst	r3, #4096	; 0x1000
}
57e0154c:	03a00000 	moveq	r0, #0
57e01550:	13a00001 	movne	r0, #1
57e01554:	e12fff1e 	bx	lr

57e01558 <dcache_enable>:
	return 0;					/* always off */
}
#else
void dcache_enable(void)
{
	cache_enable(CR_C);
57e01558:	e3a00004 	mov	r0, #4
57e0155c:	eaffffb7 	b	57e01440 <cache_enable>

57e01560 <dcache_disable>:
}

void dcache_disable(void)
{
	cache_disable(CR_C);
57e01560:	e3a00004 	mov	r0, #4
57e01564:	eaffffa2 	b	57e013f4 <cache_disable>

57e01568 <dcache_status>:
57e01568:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
}

int dcache_status(void)
{
	return (get_cr() & CR_C) != 0;
57e0156c:	e3130004 	tst	r3, #4
}
57e01570:	03a00000 	moveq	r0, #0
57e01574:	13a00001 	movne	r0, #1
57e01578:	e12fff1e 	bx	lr

57e0157c <do_bdinfo>:
}

#elif defined(CONFIG_ARM)

int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e0157c:	e92d4030 	push	{r4, r5, lr}
	int i;
	bd_t *bd = gd->bd;
57e01580:	e5984000 	ldr	r4, [r8]
}

#elif defined(CONFIG_ARM)

int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e01584:	e24dd014 	sub	sp, sp, #20
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
57e01588:	e5942004 	ldr	r2, [r4, #4]
57e0158c:	e59f1100 	ldr	r1, [pc, #256]	; 57e01694 <do_bdinfo+0x118>
57e01590:	e59f0100 	ldr	r0, [pc, #256]	; 57e01698 <do_bdinfo+0x11c>
57e01594:	eb001fac 	bl	57e0944c <printf>
57e01598:	e5942008 	ldr	r2, [r4, #8]
57e0159c:	e59f10f8 	ldr	r1, [pc, #248]	; 57e0169c <do_bdinfo+0x120>
57e015a0:	e59f00f0 	ldr	r0, [pc, #240]	; 57e01698 <do_bdinfo+0x11c>
57e015a4:	eb001fa8 	bl	57e0944c <printf>
57e015a8:	e59f10f0 	ldr	r1, [pc, #240]	; 57e016a0 <do_bdinfo+0x124>
57e015ac:	e3a02000 	mov	r2, #0
57e015b0:	e59f00e0 	ldr	r0, [pc, #224]	; 57e01698 <do_bdinfo+0x11c>
57e015b4:	eb001fa4 	bl	57e0944c <printf>
57e015b8:	e5942018 	ldr	r2, [r4, #24]
57e015bc:	e59f10e0 	ldr	r1, [pc, #224]	; 57e016a4 <do_bdinfo+0x128>
57e015c0:	e59f00d0 	ldr	r0, [pc, #208]	; 57e01698 <do_bdinfo+0x11c>
57e015c4:	eb001fa0 	bl	57e0944c <printf>
{
	char name[10], *val;
	if (idx)
		sprintf(name, "eth%iaddr", idx);
	else
		strcpy(name, "ethaddr");
57e015c8:	e28d5004 	add	r5, sp, #4
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
57e015cc:	e594201c 	ldr	r2, [r4, #28]
57e015d0:	e59f10d0 	ldr	r1, [pc, #208]	; 57e016a8 <do_bdinfo+0x12c>
57e015d4:	e59f00bc 	ldr	r0, [pc, #188]	; 57e01698 <do_bdinfo+0x11c>
57e015d8:	eb001f9b 	bl	57e0944c <printf>
{
	char name[10], *val;
	if (idx)
		sprintf(name, "eth%iaddr", idx);
	else
		strcpy(name, "ethaddr");
57e015dc:	e59f10c8 	ldr	r1, [pc, #200]	; 57e016ac <do_bdinfo+0x130>
57e015e0:	e1a00005 	mov	r0, r5
57e015e4:	eb008a3d 	bl	57e23ee0 <strcpy>
	val = getenv(name);
57e015e8:	e1a00005 	mov	r0, r5
57e015ec:	eb00183d 	bl	57e076e8 <getenv>
	if (!val)
		val = "(not set)";
57e015f0:	e3500000 	cmp	r0, #0
57e015f4:	e59f20b4 	ldr	r2, [pc, #180]	; 57e016b0 <do_bdinfo+0x134>
	printf("%-12s= %s\n", name, val);
57e015f8:	e1a01005 	mov	r1, r5
		sprintf(name, "eth%iaddr", idx);
	else
		strcpy(name, "ethaddr");
	val = getenv(name);
	if (!val)
		val = "(not set)";
57e015fc:	11a02000 	movne	r2, r0
	printf("%-12s= %s\n", name, val);
57e01600:	e59f00ac 	ldr	r0, [pc, #172]	; 57e016b4 <do_bdinfo+0x138>
57e01604:	eb001f90 	bl	57e0944c <printf>
		print_num("-> size",	bd->bi_dram[i].size);
	}

#if defined(CONFIG_CMD_NET)
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
57e01608:	e59f00a8 	ldr	r0, [pc, #168]	; 57e016b8 <do_bdinfo+0x13c>
57e0160c:	eb001835 	bl	57e076e8 <getenv>
57e01610:	e1a01000 	mov	r1, r0
57e01614:	e59f00a0 	ldr	r0, [pc, #160]	; 57e016bc <do_bdinfo+0x140>
57e01618:	eb001f8b 	bl	57e0944c <printf>
#endif
	printf("baudrate    = %u bps\n", bd->bi_baudrate);
57e0161c:	e5941000 	ldr	r1, [r4]
57e01620:	e59f0098 	ldr	r0, [pc, #152]	; 57e016c0 <do_bdinfo+0x144>
57e01624:	eb001f88 	bl	57e0944c <printf>
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
57e01628:	e59f1094 	ldr	r1, [pc, #148]	; 57e016c4 <do_bdinfo+0x148>
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
#endif
	printf("baudrate    = %u bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
57e0162c:	e598204c 	ldr	r2, [r8, #76]	; 0x4c
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
57e01630:	e59f0060 	ldr	r0, [pc, #96]	; 57e01698 <do_bdinfo+0x11c>
57e01634:	eb001f84 	bl	57e0944c <printf>
57e01638:	e59f1088 	ldr	r1, [pc, #136]	; 57e016c8 <do_bdinfo+0x14c>
#endif
	printf("baudrate    = %u bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
57e0163c:	e5982034 	ldr	r2, [r8, #52]	; 0x34
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
57e01640:	e59f0050 	ldr	r0, [pc, #80]	; 57e01698 <do_bdinfo+0x11c>
57e01644:	eb001f80 	bl	57e0944c <printf>
57e01648:	e59f107c 	ldr	r1, [pc, #124]	; 57e016cc <do_bdinfo+0x150>
	printf("baudrate    = %u bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
57e0164c:	e5982048 	ldr	r2, [r8, #72]	; 0x48
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
57e01650:	e59f0040 	ldr	r0, [pc, #64]	; 57e01698 <do_bdinfo+0x11c>
57e01654:	eb001f7c 	bl	57e0944c <printf>
57e01658:	e59f1070 	ldr	r1, [pc, #112]	; 57e016d0 <do_bdinfo+0x154>
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
57e0165c:	e5982040 	ldr	r2, [r8, #64]	; 0x40
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
57e01660:	e59f0030 	ldr	r0, [pc, #48]	; 57e01698 <do_bdinfo+0x11c>
57e01664:	eb001f78 	bl	57e0944c <printf>
57e01668:	e59f1064 	ldr	r1, [pc, #100]	; 57e016d4 <do_bdinfo+0x158>
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
57e0166c:	e5982044 	ldr	r2, [r8, #68]	; 0x44
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
57e01670:	e59f0020 	ldr	r0, [pc, #32]	; 57e01698 <do_bdinfo+0x11c>
57e01674:	eb001f74 	bl	57e0944c <printf>
57e01678:	e59f1058 	ldr	r1, [pc, #88]	; 57e016d8 <do_bdinfo+0x15c>
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
	print_num("FB base  ", gd->fb_base);
57e0167c:	e5982018 	ldr	r2, [r8, #24]
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
57e01680:	e59f0010 	ldr	r0, [pc, #16]	; 57e01698 <do_bdinfo+0x11c>
57e01684:	eb001f70 	bl	57e0944c <printf>
	printf("ARM frequency = %ld MHz\n", gd->bd->bi_arm_freq);
	printf("DSP frequency = %ld MHz\n", gd->bd->bi_dsp_freq);
	printf("DDR frequency = %ld MHz\n", gd->bd->bi_ddr_freq);
#endif
	return 0;
}
57e01688:	e3a00000 	mov	r0, #0
57e0168c:	e28dd014 	add	sp, sp, #20
57e01690:	e8bd8030 	pop	{r4, r5, pc}
57e01694:	57e2e3fe 	.word	0x57e2e3fe
57e01698:	57e2e3ee 	.word	0x57e2e3ee
57e0169c:	57e2e40a 	.word	0x57e2e40a
57e016a0:	57e2e416 	.word	0x57e2e416
57e016a4:	57e2e420 	.word	0x57e2e420
57e016a8:	57e2e429 	.word	0x57e2e429
57e016ac:	57e2e431 	.word	0x57e2e431
57e016b0:	57e2e3e4 	.word	0x57e2e3e4
57e016b4:	57e2e439 	.word	0x57e2e439
57e016b8:	57e2e444 	.word	0x57e2e444
57e016bc:	57e2e44b 	.word	0x57e2e44b
57e016c0:	57e2e45d 	.word	0x57e2e45d
57e016c4:	57e2e473 	.word	0x57e2e473
57e016c8:	57e2e47c 	.word	0x57e2e47c
57e016cc:	57e2e486 	.word	0x57e2e486
57e016d0:	57e2e490 	.word	0x57e2e490
57e016d4:	57e2e497 	.word	0x57e2e497
57e016d8:	57e2e4a1 	.word	0x57e2e4a1

57e016dc <do_go_exec>:

/* Allow ports to override the default behavior */
__attribute__((weak))
unsigned long do_go_exec(ulong (*entry)(int, char * const []), int argc,
				 char * const argv[])
{
57e016dc:	e92d4008 	push	{r3, lr}
57e016e0:	e1a03000 	mov	r3, r0
	return entry (argc, argv);
57e016e4:	e1a00001 	mov	r0, r1
57e016e8:	e1a01002 	mov	r1, r2
57e016ec:	e12fff33 	blx	r3
}
57e016f0:	e8bd8008 	pop	{r3, pc}

57e016f4 <do_go>:
static int do_go(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
57e016f4:	e3520001 	cmp	r2, #1
{
	return entry (argc, argv);
}

static int do_go(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e016f8:	e92d4070 	push	{r4, r5, r6, lr}
57e016fc:	e1a04002 	mov	r4, r2
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
		return CMD_RET_USAGE;
57e01700:	d3e04000 	mvnle	r4, #0
static int do_go(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
57e01704:	da000011 	ble	57e01750 <do_go+0x5c>
		return CMD_RET_USAGE;

	addr = simple_strtoul(argv[1], NULL, 16);
57e01708:	e5930004 	ldr	r0, [r3, #4]
57e0170c:	e3a02010 	mov	r2, #16
57e01710:	e3a01000 	mov	r1, #0
57e01714:	e2835004 	add	r5, r3, #4
57e01718:	eb008e61 	bl	57e250a4 <simple_strtoul>
57e0171c:	e1a06000 	mov	r6, r0

	printf ("## Starting application at 0x%08lX ...\n", addr);
57e01720:	e1a01006 	mov	r1, r6
57e01724:	e59f002c 	ldr	r0, [pc, #44]	; 57e01758 <do_go+0x64>
57e01728:	eb001f47 	bl	57e0944c <printf>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
57e0172c:	e2441001 	sub	r1, r4, #1
57e01730:	e1a00006 	mov	r0, r6
57e01734:	e1a02005 	mov	r2, r5
57e01738:	ebffffe7 	bl	57e016dc <do_go_exec>
}

static int do_go(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;
57e0173c:	e1a01000 	mov	r1, r0
57e01740:	e2504000 	subs	r4, r0, #0
57e01744:	13a04001 	movne	r4, #1
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
	if (rc != 0) rcode = 1;

	printf ("## Application terminated, rc = 0x%lX\n", rc);
57e01748:	e59f000c 	ldr	r0, [pc, #12]	; 57e0175c <do_go+0x68>
57e0174c:	eb001f3e 	bl	57e0944c <printf>
	return rcode;
}
57e01750:	e1a00004 	mov	r0, r4
57e01754:	e8bd8070 	pop	{r4, r5, r6, pc}
57e01758:	57e2e4cd 	.word	0x57e2e4cd
57e0175c:	57e2e4f5 	.word	0x57e2e4f5

57e01760 <do_imls>:
/*******************************************************************/
/* imls - list all images found in flash */
/*******************************************************************/
#if defined(CONFIG_CMD_IMLS)
static int do_imls(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e01760:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	void *hdr;

	for (i = 0, info = &flash_info[0];
		i < CONFIG_SYS_MAX_FLASH_BANKS; ++i, ++info) {

		if (info->flash_id == FLASH_UNKNOWN)
57e01764:	e59f7090 	ldr	r7, [pc, #144]	; 57e017fc <do_imls+0x9c>
57e01768:	e59f3090 	ldr	r3, [pc, #144]	; 57e01800 <do_imls+0xa0>
57e0176c:	e5972008 	ldr	r2, [r7, #8]
57e01770:	e1520003 	cmp	r2, r3
57e01774:	12876008 	addne	r6, r7, #8
57e01778:	13a05000 	movne	r5, #0
57e0177c:	1a000019 	bne	57e017e8 <do_imls+0x88>
57e01780:	ea00001b 	b	57e017f4 <do_imls+0x94>
			goto next_bank;
		for (j = 0; j < info->sector_count; ++j) {

			hdr = (void *)info->start[j];
57e01784:	e5b64004 	ldr	r4, [r6, #4]!
			if (!hdr)
57e01788:	e3540000 	cmp	r4, #0
57e0178c:	0a000014 	beq	57e017e4 <do_imls+0x84>
				goto next_sector;

			switch (genimg_get_format(hdr)) {
57e01790:	e1a00004 	mov	r0, r4
57e01794:	eb00330e 	bl	57e0e3d4 <genimg_get_format>
57e01798:	e3500001 	cmp	r0, #1
57e0179c:	1a000010 	bne	57e017e4 <do_imls+0x84>
			case IMAGE_FORMAT_LEGACY:
				if (!image_check_hcrc(hdr))
57e017a0:	e1a00004 	mov	r0, r4
57e017a4:	eb0031b1 	bl	57e0de70 <image_check_hcrc>
57e017a8:	e3500000 	cmp	r0, #0
57e017ac:	0a00000c 	beq	57e017e4 <do_imls+0x84>
					goto next_sector;

				printf("Legacy Image at %08lX:\n", (ulong)hdr);
57e017b0:	e1a01004 	mov	r1, r4
57e017b4:	e59f0048 	ldr	r0, [pc, #72]	; 57e01804 <do_imls+0xa4>
57e017b8:	eb001f23 	bl	57e0944c <printf>
				image_print_contents(hdr);
57e017bc:	e1a00004 	mov	r0, r4
57e017c0:	eb00326d 	bl	57e0e17c <image_print_contents>

				puts("   Verifying Checksum ... ");
57e017c4:	e59f003c 	ldr	r0, [pc, #60]	; 57e01808 <do_imls+0xa8>
57e017c8:	eb001f15 	bl	57e09424 <puts>
				if (!image_check_dcrc(hdr)) {
57e017cc:	e1a00004 	mov	r0, r4
57e017d0:	eb0031bf 	bl	57e0ded4 <image_check_dcrc>
57e017d4:	e3500000 	cmp	r0, #0
					puts("Bad Data CRC\n");
57e017d8:	059f002c 	ldreq	r0, [pc, #44]	; 57e0180c <do_imls+0xac>
				} else {
					puts("OK\n");
57e017dc:	159f002c 	ldrne	r0, [pc, #44]	; 57e01810 <do_imls+0xb0>
57e017e0:	eb001f0f 	bl	57e09424 <puts>
	for (i = 0, info = &flash_info[0];
		i < CONFIG_SYS_MAX_FLASH_BANKS; ++i, ++info) {

		if (info->flash_id == FLASH_UNKNOWN)
			goto next_bank;
		for (j = 0; j < info->sector_count; ++j) {
57e017e4:	e2855001 	add	r5, r5, #1
57e017e8:	e1d730b4 	ldrh	r3, [r7, #4]
57e017ec:	e1550003 	cmp	r5, r3
57e017f0:	baffffe3 	blt	57e01784 <do_imls+0x24>
		}
next_bank:	;
	}

	return (0);
}
57e017f4:	e3a00000 	mov	r0, #0
57e017f8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e017fc:	57e47684 	.word	0x57e47684
57e01800:	0000ffff 	.word	0x0000ffff
57e01804:	57e2e5bc 	.word	0x57e2e5bc
57e01808:	57e2e5d4 	.word	0x57e2e5d4
57e0180c:	57e2e657 	.word	0x57e2e657
57e01810:	57e3455d 	.word	0x57e3455d

57e01814 <image_info>:
	}
	return rcode;
}

static int image_info(ulong addr)
{
57e01814:	e92d4038 	push	{r3, r4, r5, lr}
57e01818:	e1a04000 	mov	r4, r0
	void *hdr = (void *)addr;

	printf("\n## Checking Image at %08lx ...\n", addr);
57e0181c:	e1a01004 	mov	r1, r4
57e01820:	e59f00ac 	ldr	r0, [pc, #172]	; 57e018d4 <image_info+0xc0>
57e01824:	eb001f08 	bl	57e0944c <printf>

	switch (genimg_get_format(hdr)) {
57e01828:	e1a00004 	mov	r0, r4
57e0182c:	eb0032e8 	bl	57e0e3d4 <genimg_get_format>
57e01830:	e3500001 	cmp	r0, #1
57e01834:	e1a05000 	mov	r5, r0
57e01838:	1a000020 	bne	57e018c0 <image_info+0xac>
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
57e0183c:	e59f0094 	ldr	r0, [pc, #148]	; 57e018d8 <image_info+0xc4>
57e01840:	eb001ef7 	bl	57e09424 <puts>
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e01844:	e5943000 	ldr	r3, [r4]
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
57e01848:	e1a02c03 	lsl	r2, r3, #24
57e0184c:	e1822c23 	orr	r2, r2, r3, lsr #24
57e01850:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e01854:	e1822401 	orr	r2, r2, r1, lsl #8
57e01858:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e0185c:	e1823423 	orr	r3, r2, r3, lsr #8
	printf("\n## Checking Image at %08lx ...\n", addr);

	switch (genimg_get_format(hdr)) {
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
		if (!image_check_magic(hdr)) {
57e01860:	e59f2074 	ldr	r2, [pc, #116]	; 57e018dc <image_info+0xc8>
57e01864:	e1530002 	cmp	r3, r2
			puts("   Bad Magic Number\n");
57e01868:	159f0070 	ldrne	r0, [pc, #112]	; 57e018e0 <image_info+0xcc>
	printf("\n## Checking Image at %08lx ...\n", addr);

	switch (genimg_get_format(hdr)) {
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
		if (!image_check_magic(hdr)) {
57e0186c:	1a000004 	bne	57e01884 <image_info+0x70>
			puts("   Bad Magic Number\n");
			return 1;
		}

		if (!image_check_hcrc(hdr)) {
57e01870:	e1a00004 	mov	r0, r4
57e01874:	eb00317d 	bl	57e0de70 <image_check_hcrc>
57e01878:	e3500000 	cmp	r0, #0
57e0187c:	1a000002 	bne	57e0188c <image_info+0x78>
			puts("   Bad Header Checksum\n");
57e01880:	e59f005c 	ldr	r0, [pc, #92]	; 57e018e4 <image_info+0xd0>
57e01884:	eb001ee6 	bl	57e09424 <puts>
			return 1;
57e01888:	ea00000f 	b	57e018cc <image_info+0xb8>
		}

		image_print_contents(hdr);
57e0188c:	e1a00004 	mov	r0, r4
57e01890:	eb003239 	bl	57e0e17c <image_print_contents>

		puts("   Verifying Checksum ... ");
57e01894:	e59f004c 	ldr	r0, [pc, #76]	; 57e018e8 <image_info+0xd4>
57e01898:	eb001ee1 	bl	57e09424 <puts>
		if (!image_check_dcrc(hdr)) {
57e0189c:	e1a00004 	mov	r0, r4
57e018a0:	eb00318b 	bl	57e0ded4 <image_check_dcrc>
57e018a4:	e3500000 	cmp	r0, #0
			puts("   Bad Data CRC\n");
57e018a8:	059f003c 	ldreq	r0, [pc, #60]	; 57e018ec <image_info+0xd8>
		}

		image_print_contents(hdr);

		puts("   Verifying Checksum ... ");
		if (!image_check_dcrc(hdr)) {
57e018ac:	0afffff4 	beq	57e01884 <image_info+0x70>
			puts("   Bad Data CRC\n");
			return 1;
		}
		puts("OK\n");
57e018b0:	e59f0038 	ldr	r0, [pc, #56]	; 57e018f0 <image_info+0xdc>
57e018b4:	eb001eda 	bl	57e09424 <puts>
		return 0;
57e018b8:	e3a05000 	mov	r5, #0
57e018bc:	ea000002 	b	57e018cc <image_info+0xb8>
		}

		return 0;
#endif
	default:
		puts("Unknown image format!\n");
57e018c0:	e59f002c 	ldr	r0, [pc, #44]	; 57e018f4 <image_info+0xe0>
57e018c4:	eb001ed6 	bl	57e09424 <puts>
		break;
	}

	return 1;
57e018c8:	e3a05001 	mov	r5, #1
}
57e018cc:	e1a00005 	mov	r0, r5
57e018d0:	e8bd8038 	pop	{r3, r4, r5, pc}
57e018d4:	57e2e5ef 	.word	0x57e2e5ef
57e018d8:	57e2e610 	.word	0x57e2e610
57e018dc:	27051956 	.word	0x27051956
57e018e0:	57e2e627 	.word	0x57e2e627
57e018e4:	57e2e63c 	.word	0x57e2e63c
57e018e8:	57e2e5d4 	.word	0x57e2e5d4
57e018ec:	57e2e654 	.word	0x57e2e654
57e018f0:	57e3455d 	.word	0x57e3455d
57e018f4:	57e2e665 	.word	0x57e2e665

57e018f8 <do_iminfo>:
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
57e018f8:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* iminfo - print header info for a requested image */
/*******************************************************************/
#if defined(CONFIG_CMD_IMI)
static int do_iminfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e018fc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
57e01900:	e1a04002 	mov	r4, r2
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
57e01904:	c1a07003 	movgt	r7, r3
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
57e01908:	c3a05000 	movgt	r5, #0
57e0190c:	c3a06001 	movgt	r6, #1
57e01910:	ca000003 	bgt	57e01924 <do_iminfo+0x2c>
		return image_info(load_addr);
57e01914:	e59f3038 	ldr	r3, [pc, #56]	; 57e01954 <do_iminfo+0x5c>
57e01918:	e5930000 	ldr	r0, [r3]
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
57e0191c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
57e01920:	eaffffbb 	b	57e01814 <image_info>
	}

	for (arg = 1; arg < argc; ++arg) {
		addr = simple_strtoul(argv[arg], NULL, 16);
57e01924:	e3a01000 	mov	r1, #0
57e01928:	e3a02010 	mov	r2, #16
57e0192c:	e5b70004 	ldr	r0, [r7, #4]!
57e01930:	eb008ddb 	bl	57e250a4 <simple_strtoul>
		if (image_info(addr) != 0)
57e01934:	ebffffb6 	bl	57e01814 <image_info>

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
57e01938:	e2866001 	add	r6, r6, #1
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
57e0193c:	e3500000 	cmp	r0, #0
57e01940:	13a05001 	movne	r5, #1

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
57e01944:	e1560004 	cmp	r6, r4
57e01948:	bafffff5 	blt	57e01924 <do_iminfo+0x2c>
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
57e0194c:	e1a00005 	mov	r0, r5
57e01950:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
57e01954:	57e36e60 	.word	0x57e36e60

57e01958 <do_bootd>:
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e01958:	e92d4010 	push	{r4, lr}
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
57e0195c:	e59f0014 	ldr	r0, [pc, #20]	; 57e01978 <do_bootd+0x20>
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e01960:	e1a04001 	mov	r4, r1
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
57e01964:	eb00175f 	bl	57e076e8 <getenv>
57e01968:	e1a01004 	mov	r1, r4
57e0196c:	eb003671 	bl	57e0f338 <run_command>
		rcode = 1;
	return rcode;
}
57e01970:	e1a00fa0 	lsr	r0, r0, #31
57e01974:	e8bd8010 	pop	{r4, pc}
57e01978:	57e2e67c 	.word	0x57e2e67c

57e0197c <do_bootm_qnxelf>:
	return 1;
}

static int do_bootm_qnxelf(int flag, int argc, char * const argv[],
			    bootm_headers_t *images)
{
57e0197c:	e92d4070 	push	{r4, r5, r6, lr}
	char *local_args[2];
	char str[16];

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
57e01980:	e3500080 	cmp	r0, #128	; 0x80
57e01984:	13500000 	cmpne	r0, #0
	return 1;
}

static int do_bootm_qnxelf(int flag, int argc, char * const argv[],
			    bootm_headers_t *images)
{
57e01988:	e24dd018 	sub	sp, sp, #24
57e0198c:	e1a04002 	mov	r4, r2
	char *local_args[2];
	char str[16];

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
57e01990:	03a06000 	moveq	r6, #0
57e01994:	13a06001 	movne	r6, #1
57e01998:	1a00000c 	bne	57e019d0 <do_bootm_qnxelf+0x54>
		fit_unsupported_reset("QNX");
		return 1;
	}
#endif

	sprintf(str, "%lx", images->ep); /* write entry-point into string */
57e0199c:	e5932060 	ldr	r2, [r3, #96]	; 0x60
57e019a0:	e59f1034 	ldr	r1, [pc, #52]	; 57e019dc <do_bootm_qnxelf+0x60>
57e019a4:	e1a0000d 	mov	r0, sp
57e019a8:	eb008e66 	bl	57e25348 <sprintf>
	local_args[0] = argv[0];
57e019ac:	e5943000 	ldr	r3, [r4]
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);
57e019b0:	e1a00006 	mov	r0, r6
		return 1;
	}
#endif

	sprintf(str, "%lx", images->ep); /* write entry-point into string */
	local_args[0] = argv[0];
57e019b4:	e58d3010 	str	r3, [sp, #16]
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);
57e019b8:	e1a01006 	mov	r1, r6
57e019bc:	e3a02002 	mov	r2, #2
57e019c0:	e28d3010 	add	r3, sp, #16
		fit_unsupported_reset("QNX");
		return 1;
	}
#endif

	sprintf(str, "%lx", images->ep); /* write entry-point into string */
57e019c4:	e1a0500d 	mov	r5, sp
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
57e019c8:	e58dd014 	str	sp, [sp, #20]
	do_bootelf(NULL, 0, 2, local_args);
57e019cc:	eb00056a 	bl	57e02f7c <do_bootelf>

	return 1;
}
57e019d0:	e3a00001 	mov	r0, #1
57e019d4:	e28dd018 	add	sp, sp, #24
57e019d8:	e8bd8070 	pop	{r4, r5, r6, pc}
57e019dc:	57e2e684 	.word	0x57e2e684

57e019e0 <do_bootm_vxworks>:
#endif /* CONFIG_BOOTM_OSE */

#if defined(CONFIG_CMD_ELF)
static int do_bootm_vxworks(int flag, int argc, char * const argv[],
			     bootm_headers_t *images)
{
57e019e0:	e92d4030 	push	{r4, r5, lr}
	char str[80];

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
57e019e4:	e3500080 	cmp	r0, #128	; 0x80
57e019e8:	13500000 	cmpne	r0, #0
#endif /* CONFIG_BOOTM_OSE */

#if defined(CONFIG_CMD_ELF)
static int do_bootm_vxworks(int flag, int argc, char * const argv[],
			     bootm_headers_t *images)
{
57e019ec:	e24dd054 	sub	sp, sp, #84	; 0x54
	char str[80];

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
57e019f0:	03a05000 	moveq	r5, #0
57e019f4:	13a05001 	movne	r5, #1
57e019f8:	1a00000c 	bne	57e01a30 <do_bootm_vxworks+0x50>
		fit_unsupported_reset("VxWorks");
		return 1;
	}
#endif

	sprintf(str, "%lx", images->ep); /* write entry-point into string */
57e019fc:	e5932060 	ldr	r2, [r3, #96]	; 0x60
57e01a00:	e59f1034 	ldr	r1, [pc, #52]	; 57e01a3c <do_bootm_vxworks+0x5c>
57e01a04:	e1a0000d 	mov	r0, sp
57e01a08:	eb008e4e 	bl	57e25348 <sprintf>
	setenv("loadaddr", str);
57e01a0c:	e1a0100d 	mov	r1, sp
57e01a10:	e59f0028 	ldr	r0, [pc, #40]	; 57e01a40 <do_bootm_vxworks+0x60>
57e01a14:	eb001625 	bl	57e072b0 <setenv>
	do_bootvx(NULL, 0, 0, NULL);
57e01a18:	e1a00005 	mov	r0, r5
57e01a1c:	e1a01005 	mov	r1, r5
57e01a20:	e1a02005 	mov	r2, r5
57e01a24:	e1a03005 	mov	r3, r5
		fit_unsupported_reset("VxWorks");
		return 1;
	}
#endif

	sprintf(str, "%lx", images->ep); /* write entry-point into string */
57e01a28:	e1a0400d 	mov	r4, sp
	setenv("loadaddr", str);
	do_bootvx(NULL, 0, 0, NULL);
57e01a2c:	eb0004ab 	bl	57e02ce0 <do_bootvx>

	return 1;
}
57e01a30:	e3a00001 	mov	r0, #1
57e01a34:	e28dd054 	add	sp, sp, #84	; 0x54
57e01a38:	e8bd8030 	pop	{r4, r5, pc}
57e01a3c:	57e2e684 	.word	0x57e2e684
57e01a40:	57e2e096 	.word	0x57e2e096

57e01a44 <do_bootm_rtems>:
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
57e01a44:	e3500080 	cmp	r0, #128	; 0x80
57e01a48:	13500000 	cmpne	r0, #0
#endif /* CONFIG_LYNXKDI */

#ifdef CONFIG_BOOTM_RTEMS
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
57e01a4c:	e92d4010 	push	{r4, lr}
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
57e01a50:	1a000007 	bne	57e01a74 <do_bootm_rtems+0x30>
		fit_unsupported_reset("RTEMS");
		return 1;
	}
#endif

	entry_point = (void (*)(bd_t *))images->ep;
57e01a54:	e5934060 	ldr	r4, [r3, #96]	; 0x60

	printf("## Transferring control to RTEMS (at address %08lx) ...\n",
57e01a58:	e59f001c 	ldr	r0, [pc, #28]	; 57e01a7c <do_bootm_rtems+0x38>
57e01a5c:	e1a01004 	mov	r1, r4
57e01a60:	eb001e79 	bl	57e0944c <printf>
57e01a64:	e3a0000f 	mov	r0, #15
57e01a68:	eb0033bd 	bl	57e0e964 <__show_boot_progress>

	/*
	 * RTEMS Parameters:
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);
57e01a6c:	e5980000 	ldr	r0, [r8]
57e01a70:	e12fff34 	blx	r4

	return 1;
}
57e01a74:	e3a00001 	mov	r0, #1
57e01a78:	e8bd8010 	pop	{r4, pc}
57e01a7c:	57e2e688 	.word	0x57e2e688

57e01a80 <do_bootm_netbsd>:
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
57e01a80:	e3500080 	cmp	r0, #128	; 0x80
57e01a84:	13500000 	cmpne	r0, #0
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
			    bootm_headers_t *images)
{
57e01a88:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
57e01a8c:	e1a05001 	mov	r5, r1
57e01a90:	e1a07002 	mov	r7, r2
57e01a94:	e1a04003 	mov	r4, r3
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
57e01a98:	03a00000 	moveq	r0, #0
57e01a9c:	13a00001 	movne	r0, #1
57e01aa0:	1a00003e 	bne	57e01ba0 <do_bootm_netbsd+0x120>
	if (!images->legacy_hdr_valid) {
		fit_unsupported_reset("NetBSD");
		return 1;
	}
#endif
	hdr = images->legacy_hdr_os;
57e01aa4:	e5936000 	ldr	r6, [r3]
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
57e01aa8:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
57e01aac:	e3530004 	cmp	r3, #4
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
57e01ab0:	11a06000 	movne	r6, r0
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
57e01ab4:	1a000007 	bne	57e01ad8 <do_bootm_netbsd+0x58>
		image_multi_getimg(hdr, 1, &kernel_data, &kernel_len);
57e01ab8:	e1a00006 	mov	r0, r6
57e01abc:	e28d3008 	add	r3, sp, #8
57e01ac0:	e3a01001 	mov	r1, #1
57e01ac4:	e28d200c 	add	r2, sp, #12
57e01ac8:	eb003121 	bl	57e0df54 <image_multi_getimg>
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
57e01acc:	e59d3008 	ldr	r3, [sp, #8]
57e01ad0:	e3530000 	cmp	r3, #0
57e01ad4:	03a06000 	moveq	r6, #0
	consdev = "scc2";
#elif defined(CONFIG_8xx_CONS_SCC3)
	consdev = "scc3";
#endif

	if (argc > 2) {
57e01ad8:	e3550002 	cmp	r5, #2
57e01adc:	da00001f 	ble	57e01b60 <do_bootm_netbsd+0xe0>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
57e01ae0:	e287b004 	add	fp, r7, #4
57e01ae4:	e3a09002 	mov	r9, #2
57e01ae8:	e3a0a000 	mov	sl, #0
	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
57e01aec:	e5bb0004 	ldr	r0, [fp, #4]!
57e01af0:	eb008956 	bl	57e24050 <strlen>

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
57e01af4:	e2899001 	add	r9, r9, #1
			len += strlen(argv[i]) + 1;
57e01af8:	e080a00a 	add	sl, r0, sl

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
57e01afc:	e1590005 	cmp	r9, r5
			len += strlen(argv[i]) + 1;
57e01b00:	e28aa001 	add	sl, sl, #1

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
57e01b04:	bafffff8 	blt	57e01aec <do_bootm_netbsd+0x6c>
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
57e01b08:	e1a0000a 	mov	r0, sl
57e01b0c:	eb00202c 	bl	57e09bc4 <malloc>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
57e01b10:	e2877008 	add	r7, r7, #8
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
57e01b14:	e1a0a000 	mov	sl, r0

		for (i = 2, len = 0; i < argc; i += 1) {
57e01b18:	e3a0b002 	mov	fp, #2
57e01b1c:	e3a09000 	mov	r9, #0
			if (i > 2)
				cmdline[len++] = ' ';
57e01b20:	e3a03020 	mov	r3, #32
57e01b24:	ea000002 	b	57e01b34 <do_bootm_netbsd+0xb4>
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
57e01b28:	e0809009 	add	r9, r0, r9
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
			if (i > 2)
				cmdline[len++] = ' ';
57e01b2c:	e7ca3009 	strb	r3, [sl, r9]
57e01b30:	e2899001 	add	r9, r9, #1
			strcpy(&cmdline[len], argv[i]);
57e01b34:	e5971000 	ldr	r1, [r7]
57e01b38:	e08a0009 	add	r0, sl, r9
57e01b3c:	e58d3004 	str	r3, [sp, #4]

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
57e01b40:	e28bb001 	add	fp, fp, #1
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
57e01b44:	eb0088e5 	bl	57e23ee0 <strcpy>
			len += strlen(argv[i]);
57e01b48:	e4970004 	ldr	r0, [r7], #4
57e01b4c:	eb00893f 	bl	57e24050 <strlen>

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
57e01b50:	e15b0005 	cmp	fp, r5
57e01b54:	e59d3004 	ldr	r3, [sp, #4]
57e01b58:	bafffff2 	blt	57e01b28 <do_bootm_netbsd+0xa8>
57e01b5c:	ea000004 	b	57e01b74 <do_bootm_netbsd+0xf4>
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
		}
	} else if ((cmdline = getenv("bootargs")) == NULL) {
57e01b60:	e59f0044 	ldr	r0, [pc, #68]	; 57e01bac <do_bootm_netbsd+0x12c>
57e01b64:	eb0016df 	bl	57e076e8 <getenv>
		cmdline = "";
57e01b68:	e3500000 	cmp	r0, #0
57e01b6c:	e59fa03c 	ldr	sl, [pc, #60]	; 57e01bb0 <do_bootm_netbsd+0x130>
57e01b70:	11a0a000 	movne	sl, r0
	}

	loader = (void (*)(bd_t *, image_header_t *, char *, char *))images->ep;
57e01b74:	e5944060 	ldr	r4, [r4, #96]	; 0x60

	printf("## Transferring control to NetBSD stage-2 loader "
57e01b78:	e59f0034 	ldr	r0, [pc, #52]	; 57e01bb4 <do_bootm_netbsd+0x134>
57e01b7c:	e1a01004 	mov	r1, r4
57e01b80:	eb001e31 	bl	57e0944c <printf>
57e01b84:	e3a0000f 	mov	r0, #15
57e01b88:	eb003375 	bl	57e0e964 <__show_boot_progress>
	 *   r3: ptr to board info data
	 *   r4: image address
	 *   r5: console device
	 *   r6: boot args string
	 */
	(*loader)(gd->bd, os_hdr, consdev, cmdline);
57e01b8c:	e1a01006 	mov	r1, r6
57e01b90:	e5980000 	ldr	r0, [r8]
57e01b94:	e59f2014 	ldr	r2, [pc, #20]	; 57e01bb0 <do_bootm_netbsd+0x130>
57e01b98:	e1a0300a 	mov	r3, sl
57e01b9c:	e12fff34 	blx	r4

	return 1;
}
57e01ba0:	e3a00001 	mov	r0, #1
57e01ba4:	e28dd010 	add	sp, sp, #16
57e01ba8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e01bac:	57e2e111 	.word	0x57e2e111
57e01bb0:	57e302de 	.word	0x57e302de
57e01bb4:	57e2e6c1 	.word	0x57e2e6c1

57e01bb8 <bootm_load_os.clone.18>:
}

#define BOOTM_ERR_RESET		-1
#define BOOTM_ERR_OVERLAP	-2
#define BOOTM_ERR_UNIMPLEMENTED	-3
static int bootm_load_os(image_info_t os, ulong *load_end, int boot_progress)
57e01bb8:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
57e01bbc:	e1a07000 	mov	r7, r0
57e01bc0:	e5dd0030 	ldrb	r0, [sp, #48]	; 0x30
57e01bc4:	e1a09001 	mov	r9, r1
57e01bc8:	e5dd602c 	ldrb	r6, [sp, #44]	; 0x2c
57e01bcc:	e1a0a002 	mov	sl, r2
57e01bd0:	e59d4028 	ldr	r4, [sp, #40]	; 0x28
57e01bd4:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
	uint8_t comp = os.comp;
	ulong load = os.load;
	ulong blob_start = os.start;
	ulong blob_end = os.end;
	ulong image_start = os.image_start;
	ulong image_len = os.image_len;
57e01bd8:	e58d3004 	str	r3, [sp, #4]
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
57e01bdc:	eb00315a 	bl	57e0e14c <genimg_get_type_name>

	switch (comp) {
57e01be0:	e3560000 	cmp	r6, #0
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
57e01be4:	e1a01000 	mov	r1, r0

	switch (comp) {
57e01be8:	0a000002 	beq	57e01bf8 <bootm_load_os.clone.18+0x40>
57e01bec:	e3560001 	cmp	r6, #1
57e01bf0:	1a00002a 	bne	57e01ca0 <bootm_load_os.clone.18+0xe8>
57e01bf4:	ea000015 	b	57e01c50 <bootm_load_os.clone.18+0x98>
	case IH_COMP_NONE:
		if (load == blob_start || load == image_start) {
57e01bf8:	e1540007 	cmp	r4, r7
57e01bfc:	1154000a 	cmpne	r4, sl
57e01c00:	13a06000 	movne	r6, #0
57e01c04:	03a06001 	moveq	r6, #1
57e01c08:	1a000003 	bne	57e01c1c <bootm_load_os.clone.18+0x64>
			printf("   XIP %s ... ", type_name);
57e01c0c:	e59f00f8 	ldr	r0, [pc, #248]	; 57e01d0c <bootm_load_os.clone.18+0x154>
57e01c10:	eb001e0d 	bl	57e0944c <printf>
			no_overlap = 1;
57e01c14:	e3a06001 	mov	r6, #1
57e01c18:	ea000006 	b	57e01c38 <bootm_load_os.clone.18+0x80>
		} else {
			printf("   Loading %s ... ", type_name);
57e01c1c:	e59f00ec 	ldr	r0, [pc, #236]	; 57e01d10 <bootm_load_os.clone.18+0x158>
57e01c20:	eb001e09 	bl	57e0944c <printf>
			memmove_wd((void *)load, (void *)image_start,
57e01c24:	e1a00004 	mov	r0, r4
57e01c28:	e1a0100a 	mov	r1, sl
57e01c2c:	e59d2004 	ldr	r2, [sp, #4]
57e01c30:	e3a03801 	mov	r3, #65536	; 0x10000
57e01c34:	eb00311e 	bl	57e0e0b4 <memmove_wd>
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
57e01c38:	e59d3004 	ldr	r3, [sp, #4]
		puts("OK\n");
57e01c3c:	e59f00d0 	ldr	r0, [pc, #208]	; 57e01d14 <bootm_load_os.clone.18+0x15c>
		} else {
			printf("   Loading %s ... ", type_name);
			memmove_wd((void *)load, (void *)image_start,
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
57e01c40:	e0843003 	add	r3, r4, r3
57e01c44:	e5853000 	str	r3, [r5]
		puts("OK\n");
57e01c48:	eb001df5 	bl	57e09424 <puts>
57e01c4c:	ea000018 	b	57e01cb4 <bootm_load_os.clone.18+0xfc>
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
57e01c50:	e59f00c0 	ldr	r0, [pc, #192]	; 57e01d18 <bootm_load_os.clone.18+0x160>
57e01c54:	eb001dfc 	bl	57e0944c <printf>
		if (gunzip((void *)load, unc_len,
57e01c58:	e28d3004 	add	r3, sp, #4
57e01c5c:	e1a00004 	mov	r0, r4
57e01c60:	e3a01502 	mov	r1, #8388608	; 0x800000
57e01c64:	e1a0200a 	mov	r2, sl
57e01c68:	eb0082ac 	bl	57e22720 <gunzip>
57e01c6c:	e2506000 	subs	r6, r0, #0
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
		}

		*load_end = load + image_len;
57e01c70:	059d3004 	ldreq	r3, [sp, #4]
57e01c74:	00843003 	addeq	r3, r4, r3
57e01c78:	05853000 	streq	r3, [r5]
		puts("OK\n");
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
		if (gunzip((void *)load, unc_len,
57e01c7c:	0a00000c 	beq	57e01cb4 <bootm_load_os.clone.18+0xfc>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
57e01c80:	e59f0094 	ldr	r0, [pc, #148]	; 57e01d1c <bootm_load_os.clone.18+0x164>
57e01c84:	eb001de6 	bl	57e09424 <puts>
				"error - must RESET board to recover\n");
			if (boot_progress)
57e01c88:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
57e01c8c:	e3530000 	cmp	r3, #0
57e01c90:	0a00001b 	beq	57e01d04 <bootm_load_os.clone.18+0x14c>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e01c94:	e3e00005 	mvn	r0, #5
57e01c98:	eb003331 	bl	57e0e964 <__show_boot_progress>
57e01c9c:	ea000018 	b	57e01d04 <bootm_load_os.clone.18+0x14c>

		*load_end = load + unc_len;
		break;
#endif /* CONFIG_LZO */
	default:
		printf("Unimplemented compression type %d\n", comp);
57e01ca0:	e59f0078 	ldr	r0, [pc, #120]	; 57e01d20 <bootm_load_os.clone.18+0x168>
57e01ca4:	e1a01006 	mov	r1, r6
57e01ca8:	eb001de7 	bl	57e0944c <printf>
		return BOOTM_ERR_UNIMPLEMENTED;
57e01cac:	e3e00002 	mvn	r0, #2
57e01cb0:	ea000014 	b	57e01d08 <bootm_load_os.clone.18+0x150>
	}

	flush_cache(load, (*load_end - load) * sizeof(ulong));
57e01cb4:	e5951000 	ldr	r1, [r5]
57e01cb8:	e1a00004 	mov	r0, r4
57e01cbc:	e0641001 	rsb	r1, r4, r1
57e01cc0:	e1a01101 	lsl	r1, r1, #2
57e01cc4:	ebfffdb7 	bl	57e013a8 <__flush_cache>

	puts("OK\n");
57e01cc8:	e59f0044 	ldr	r0, [pc, #68]	; 57e01d14 <bootm_load_os.clone.18+0x15c>
57e01ccc:	eb001dd4 	bl	57e09424 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e01cd0:	e3a00007 	mov	r0, #7
57e01cd4:	eb003322 	bl	57e0e964 <__show_boot_progress>
	debug("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);

	if (!no_overlap && (load < blob_end) && (*load_end > blob_start)) {
57e01cd8:	e2760001 	rsbs	r0, r6, #1
57e01cdc:	33a00000 	movcc	r0, #0
57e01ce0:	e1540009 	cmp	r4, r9
57e01ce4:	23a00000 	movcs	r0, #0
57e01ce8:	e3500000 	cmp	r0, #0
57e01cec:	0a000005 	beq	57e01d08 <bootm_load_os.clone.18+0x150>
57e01cf0:	e5953000 	ldr	r3, [r5]
57e01cf4:	e1530007 	cmp	r3, r7
			*load_end);

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
57e01cf8:	83e00001 	mvnhi	r0, #1
57e01cfc:	93a00000 	movls	r0, #0
57e01d00:	ea000000 	b	57e01d08 <bootm_load_os.clone.18+0x150>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
				"error - must RESET board to recover\n");
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
57e01d04:	e3e00000 	mvn	r0, #0

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
}
57e01d08:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
57e01d0c:	57e2e70a 	.word	0x57e2e70a
57e01d10:	57e2e719 	.word	0x57e2e719
57e01d14:	57e3455d 	.word	0x57e3455d
57e01d18:	57e2e72c 	.word	0x57e2e72c
57e01d1c:	57e2e745 	.word	0x57e2e745
57e01d20:	57e2e796 	.word	0x57e2e796

57e01d24 <bootm_start.clone.17>:
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
57e01d24:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
57e01d28:	e59f43c0 	ldr	r4, [pc, #960]	; 57e020f0 <bootm_start.clone.17+0x3cc>
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
57e01d2c:	e1a07001 	mov	r7, r1
57e01d30:	e1a0a000 	mov	sl, r0
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
57e01d34:	e3a01000 	mov	r1, #0
57e01d38:	e1a00004 	mov	r0, r4
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
57e01d3c:	e1a06002 	mov	r6, r2
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
57e01d40:	e3a02f4b 	mov	r2, #300	; 0x12c
57e01d44:	eb00894c 	bl	57e2427c <memset>
	images.verify = getenv_yesno("verify");
57e01d48:	e59f03a4 	ldr	r0, [pc, #932]	; 57e020f4 <bootm_start.clone.17+0x3d0>
57e01d4c:	eb00240f 	bl	57e0ad90 <getenv_yesno>
57e01d50:	e5840084 	str	r0, [r4, #132]	; 0x84
static void boot_start_lmb(bootm_headers_t *images)
{
	ulong		mem_start;
	phys_size_t	mem_size;

	lmb_init(&images->lmb);
57e01d54:	e284008c 	add	r0, r4, #140	; 0x8c
57e01d58:	eb008701 	bl	57e23964 <lmb_init>

	mem_start = getenv_bootm_low();
57e01d5c:	eb0030a5 	bl	57e0dff8 <getenv_bootm_low>
57e01d60:	e1a05000 	mov	r5, r0
	mem_size = getenv_bootm_size();
57e01d64:	eb0030af 	bl	57e0e028 <getenv_bootm_size>

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
57e01d68:	e1a01005 	mov	r1, r5
	phys_size_t	mem_size;

	lmb_init(&images->lmb);

	mem_start = getenv_bootm_low();
	mem_size = getenv_bootm_size();
57e01d6c:	e1a02000 	mov	r2, r0

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
57e01d70:	e284008c 	add	r0, r4, #140	; 0x8c
57e01d74:	eb008704 	bl	57e2398c <lmb_add>

	arch_lmb_reserve(&images->lmb);
57e01d78:	e284008c 	add	r0, r4, #140	; 0x8c
57e01d7c:	ebfffc6b 	bl	57e00f30 <arch_lmb_reserve>
	board_lmb_reserve(&images->lmb);
57e01d80:	e284008c 	add	r0, r4, #140	; 0x8c
57e01d84:	eb0087d5 	bl	57e23ce0 <__board_lmb_reserve>
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
57e01d88:	e3570001 	cmp	r7, #1
		img_addr = load_addr;
57e01d8c:	d59f3364 	ldrle	r3, [pc, #868]	; 57e020f8 <bootm_start.clone.17+0x3d4>
57e01d90:	d5934000 	ldrle	r4, [r3]
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
57e01d94:	da000004 	ble	57e01dac <bootm_start.clone.17+0x88>
							&fit_uname_kernel)) {
		debug("*  kernel: subimage '%s' from image at 0x%08lx\n",
				fit_uname_kernel, img_addr);
#endif
	} else {
		img_addr = simple_strtoul(argv[1], NULL, 16);
57e01d98:	e5960004 	ldr	r0, [r6, #4]
57e01d9c:	e3a01000 	mov	r1, #0
57e01da0:	e3a02010 	mov	r2, #16
57e01da4:	eb008cbe 	bl	57e250a4 <simple_strtoul>
57e01da8:	e1a04000 	mov	r4, r0
57e01dac:	e3a00001 	mov	r0, #1
57e01db0:	eb0032eb 	bl	57e0e964 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
57e01db4:	e1a00004 	mov	r0, r4
57e01db8:	eb003192 	bl	57e0e408 <genimg_get_image>

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
57e01dbc:	e59fb32c 	ldr	fp, [pc, #812]	; 57e020f0 <bootm_start.clone.17+0x3cc>
57e01dc0:	e3a09000 	mov	r9, #0
57e01dc4:	e58b9054 	str	r9, [fp, #84]	; 0x54
57e01dc8:	e58b9050 	str	r9, [fp, #80]	; 0x50
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
57e01dcc:	e1a04000 	mov	r4, r0

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
57e01dd0:	e1a05000 	mov	r5, r0
57e01dd4:	eb00317e 	bl	57e0e3d4 <genimg_get_format>
57e01dd8:	e3500001 	cmp	r0, #1
57e01ddc:	1a000067 	bne	57e01f80 <bootm_start.clone.17+0x25c>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
57e01de0:	e1a01004 	mov	r1, r4
57e01de4:	e59f0310 	ldr	r0, [pc, #784]	; 57e020fc <bootm_start.clone.17+0x3d8>
57e01de8:	eb001d97 	bl	57e0944c <printf>
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e01dec:	e5943000 	ldr	r3, [r4]
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
57e01df0:	e59b9084 	ldr	r9, [fp, #132]	; 0x84
57e01df4:	e1a02c03 	lsl	r2, r3, #24
57e01df8:	e1822c23 	orr	r2, r2, r3, lsr #24
57e01dfc:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e01e00:	e1822401 	orr	r2, r2, r1, lsl #8
57e01e04:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e01e08:	e1823423 	orr	r3, r2, r3, lsr #8
 */
static image_header_t *image_get_kernel(ulong img_addr, int verify)
{
	image_header_t *hdr = (image_header_t *)img_addr;

	if (!image_check_magic(hdr)) {
57e01e0c:	e59f22ec 	ldr	r2, [pc, #748]	; 57e02100 <bootm_start.clone.17+0x3dc>
57e01e10:	e1530002 	cmp	r3, r2
57e01e14:	0a000003 	beq	57e01e28 <bootm_start.clone.17+0x104>
		puts("Bad Magic Number\n");
57e01e18:	e59f02e4 	ldr	r0, [pc, #740]	; 57e02104 <bootm_start.clone.17+0x3e0>
57e01e1c:	eb001d80 	bl	57e09424 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e01e20:	e3e00000 	mvn	r0, #0
57e01e24:	ea000023 	b	57e01eb8 <bootm_start.clone.17+0x194>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e01e28:	e3a00002 	mov	r0, #2
57e01e2c:	eb0032cc 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_MAGIC);
		return NULL;
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_HEADER);

	if (!image_check_hcrc(hdr)) {
57e01e30:	e1a00004 	mov	r0, r4
57e01e34:	eb00300d 	bl	57e0de70 <image_check_hcrc>
57e01e38:	e3500000 	cmp	r0, #0
57e01e3c:	1a000003 	bne	57e01e50 <bootm_start.clone.17+0x12c>
		puts("Bad Header Checksum\n");
57e01e40:	e59f02c0 	ldr	r0, [pc, #704]	; 57e02108 <bootm_start.clone.17+0x3e4>
57e01e44:	eb001d76 	bl	57e09424 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e01e48:	e3e00001 	mvn	r0, #1
57e01e4c:	ea000019 	b	57e01eb8 <bootm_start.clone.17+0x194>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e01e50:	e3a00003 	mov	r0, #3
57e01e54:	eb0032c2 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_HEADER);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_CHECKSUM);
	image_print_contents(hdr);
57e01e58:	e1a00004 	mov	r0, r4
57e01e5c:	eb0030c6 	bl	57e0e17c <image_print_contents>

	if (verify) {
57e01e60:	e3590000 	cmp	r9, #0
57e01e64:	0a00000b 	beq	57e01e98 <bootm_start.clone.17+0x174>
		puts("   Verifying Checksum ... ");
57e01e68:	e59f029c 	ldr	r0, [pc, #668]	; 57e0210c <bootm_start.clone.17+0x3e8>
57e01e6c:	eb001d6c 	bl	57e09424 <puts>
		if (!image_check_dcrc(hdr)) {
57e01e70:	e1a00004 	mov	r0, r4
57e01e74:	eb003016 	bl	57e0ded4 <image_check_dcrc>
57e01e78:	e3500000 	cmp	r0, #0
57e01e7c:	1a000003 	bne	57e01e90 <bootm_start.clone.17+0x16c>
			printf("Bad Data CRC\n");
57e01e80:	e59f0288 	ldr	r0, [pc, #648]	; 57e02110 <bootm_start.clone.17+0x3ec>
57e01e84:	eb001d70 	bl	57e0944c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e01e88:	e3e00002 	mvn	r0, #2
57e01e8c:	ea000009 	b	57e01eb8 <bootm_start.clone.17+0x194>
			bootstage_error(BOOTSTAGE_ID_CHECK_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
57e01e90:	e59f027c 	ldr	r0, [pc, #636]	; 57e02114 <bootm_start.clone.17+0x3f0>
57e01e94:	eb001d62 	bl	57e09424 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e01e98:	e3a00004 	mov	r0, #4
57e01e9c:	eb0032b0 	bl	57e0e964 <__show_boot_progress>
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e01ea0:	e5d4101d 	ldrb	r1, [r4, #29]
		}
		puts("OK\n");
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_ARCH);

	if (!image_check_target_arch(hdr)) {
57e01ea4:	e3510002 	cmp	r1, #2
57e01ea8:	0a000005 	beq	57e01ec4 <bootm_start.clone.17+0x1a0>
		printf("Unsupported Architecture 0x%x\n", image_get_arch(hdr));
57e01eac:	e59f0264 	ldr	r0, [pc, #612]	; 57e02118 <bootm_start.clone.17+0x3f4>
57e01eb0:	eb001d65 	bl	57e0944c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e01eb4:	e3e00003 	mvn	r0, #3
57e01eb8:	eb0032a9 	bl	57e0e964 <__show_boot_progress>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
		if (!hdr)
			return NULL;
57e01ebc:	e3a05000 	mov	r5, #0
57e01ec0:	ea000034 	b	57e01f98 <bootm_start.clone.17+0x274>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e01ec4:	e3a00005 	mov	r0, #5
57e01ec8:	eb0032a5 	bl	57e0e964 <__show_boot_progress>
		bootstage_mark(BOOTSTAGE_ID_CHECK_IMAGETYPE);

		/* get os_data and os_len */
		switch (image_get_type(hdr)) {
57e01ecc:	e5d4301e 	ldrb	r3, [r4, #30]
57e01ed0:	e3530002 	cmp	r3, #2
57e01ed4:	0a00000d 	beq	57e01f10 <bootm_start.clone.17+0x1ec>
57e01ed8:	8a000001 	bhi	57e01ee4 <bootm_start.clone.17+0x1c0>
57e01edc:	e3530001 	cmp	r3, #1
57e01ee0:	ea000002 	b	57e01ef0 <bootm_start.clone.17+0x1cc>
57e01ee4:	e3530004 	cmp	r3, #4
57e01ee8:	0a000002 	beq	57e01ef8 <bootm_start.clone.17+0x1d4>
57e01eec:	e353000e 	cmp	r3, #14
57e01ef0:	1a000012 	bne	57e01f40 <bootm_start.clone.17+0x21c>
57e01ef4:	ea000005 	b	57e01f10 <bootm_start.clone.17+0x1ec>
		case IH_TYPE_KERNEL_NOLOAD:
			*os_data = image_get_data(hdr);
			*os_len = image_get_data_size(hdr);
			break;
		case IH_TYPE_MULTI:
			image_multi_getimg(hdr, 0, os_data, os_len);
57e01ef8:	e59f221c 	ldr	r2, [pc, #540]	; 57e0211c <bootm_start.clone.17+0x3f8>
57e01efc:	e1a00004 	mov	r0, r4
57e01f00:	e3a01000 	mov	r1, #0
57e01f04:	e2823004 	add	r3, r2, #4
57e01f08:	eb003011 	bl	57e0df54 <image_multi_getimg>
57e01f0c:	ea000010 	b	57e01f54 <bootm_start.clone.17+0x230>
			break;
		case IH_TYPE_STANDALONE:
			*os_data = image_get_data(hdr);
57e01f10:	e59f21d8 	ldr	r2, [pc, #472]	; 57e020f0 <bootm_start.clone.17+0x3cc>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
57e01f14:	e2843040 	add	r3, r4, #64	; 0x40
57e01f18:	e5823050 	str	r3, [r2, #80]	; 0x50
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e01f1c:	e594300c 	ldr	r3, [r4, #12]
57e01f20:	e1a01c03 	lsl	r1, r3, #24
57e01f24:	e1811c23 	orr	r1, r1, r3, lsr #24
57e01f28:	e2030cff 	and	r0, r3, #65280	; 0xff00
57e01f2c:	e1811400 	orr	r1, r1, r0, lsl #8
57e01f30:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e01f34:	e1813423 	orr	r3, r1, r3, lsr #8
		case IH_TYPE_MULTI:
			image_multi_getimg(hdr, 0, os_data, os_len);
			break;
		case IH_TYPE_STANDALONE:
			*os_data = image_get_data(hdr);
			*os_len = image_get_data_size(hdr);
57e01f38:	e5823054 	str	r3, [r2, #84]	; 0x54
57e01f3c:	ea000004 	b	57e01f54 <bootm_start.clone.17+0x230>
			break;
		default:
			printf("Wrong Image Type for %s command\n",
57e01f40:	e59f01d8 	ldr	r0, [pc, #472]	; 57e02120 <bootm_start.clone.17+0x3fc>
57e01f44:	e59a1000 	ldr	r1, [sl]
57e01f48:	eb001d3f 	bl	57e0944c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e01f4c:	e3e00004 	mvn	r0, #4
57e01f50:	eaffffd8 	b	57e01eb8 <bootm_start.clone.17+0x194>

		/*
		 * copy image header to allow for image overwrites during
		 * kernel decompression.
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
57e01f54:	e59fa194 	ldr	sl, [pc, #404]	; 57e020f0 <bootm_start.clone.17+0x3cc>
57e01f58:	e1a01004 	mov	r1, r4
57e01f5c:	e28a0004 	add	r0, sl, #4
57e01f60:	e3a02040 	mov	r2, #64	; 0x40
57e01f64:	eb008905 	bl	57e24380 <memmove>
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;

		images->legacy_hdr_valid = 1;
57e01f68:	e3a03001 	mov	r3, #1
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;
57e01f6c:	e58a4000 	str	r4, [sl]

		images->legacy_hdr_valid = 1;
57e01f70:	e58a3044 	str	r3, [sl, #68]	; 0x44
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e01f74:	e3a00006 	mov	r0, #6
57e01f78:	eb003279 	bl	57e0e964 <__show_boot_progress>
57e01f7c:	ea000005 	b	57e01f98 <bootm_start.clone.17+0x274>
		images->fit_uname_os = fit_uname_kernel;
		images->fit_noffset_os = os_noffset;
		break;
#endif
	default:
		printf("Wrong Image Format for %s command\n", cmdtp->name);
57e01f80:	e59a1000 	ldr	r1, [sl]
57e01f84:	e59f0198 	ldr	r0, [pc, #408]	; 57e02124 <bootm_start.clone.17+0x400>
57e01f88:	eb001d2f 	bl	57e0944c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e01f8c:	e3e0006b 	mvn	r0, #107	; 0x6b
57e01f90:	eb003273 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);
		return NULL;
57e01f94:	e1a05009 	mov	r5, r9
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
57e01f98:	e59f4150 	ldr	r4, [pc, #336]	; 57e020f0 <bootm_start.clone.17+0x3cc>
57e01f9c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
57e01fa0:	e3530000 	cmp	r3, #0
		puts("ERROR: can't get kernel image!\n");
57e01fa4:	059f017c 	ldreq	r0, [pc, #380]	; 57e02128 <bootm_start.clone.17+0x404>
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
57e01fa8:	0a000021 	beq	57e02034 <bootm_start.clone.17+0x310>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
57e01fac:	e1a00005 	mov	r0, r5
57e01fb0:	eb003107 	bl	57e0e3d4 <genimg_get_format>
57e01fb4:	e3500001 	cmp	r0, #1
57e01fb8:	e1a0a000 	mov	sl, r0
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
57e01fbc:	159f0168 	ldrne	r0, [pc, #360]	; 57e0212c <bootm_start.clone.17+0x408>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
57e01fc0:	1a00001b 	bne	57e02034 <bootm_start.clone.17+0x310>
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e01fc4:	e5d5301e 	ldrb	r3, [r5, #30]
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
57e01fc8:	e5c4305d 	strb	r3, [r4, #93]	; 0x5d
		images.os.comp = image_get_comp(os_hdr);
57e01fcc:	e5d5201f 	ldrb	r2, [r5, #31]
57e01fd0:	e5c4205c 	strb	r2, [r4, #92]	; 0x5c
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e01fd4:	e5d5101c 	ldrb	r1, [r5, #28]
	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);
57e01fd8:	e5c4105e 	strb	r1, [r4, #94]	; 0x5e
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e01fdc:	e595200c 	ldr	r2, [r5, #12]
57e01fe0:	e1a00c02 	lsl	r0, r2, #24
57e01fe4:	e202ccff 	and	ip, r2, #65280	; 0xff00
57e01fe8:	e1800c22 	orr	r0, r0, r2, lsr #24
57e01fec:	e180040c 	orr	r0, r0, ip, lsl #8
57e01ff0:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
57e01ff4:	e1802422 	orr	r2, r0, r2, lsr #8
}

static inline uint32_t image_get_image_size(const image_header_t *hdr)
{
	return (image_get_size(hdr) + image_get_header_size());
57e01ff8:	e2822040 	add	r2, r2, #64	; 0x40
}
static inline ulong image_get_image_end(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_image_size(hdr));
57e01ffc:	e0852002 	add	r2, r5, r2
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);

		images.os.end = image_get_image_end(os_hdr);
57e02000:	e584204c 	str	r2, [r4, #76]	; 0x4c
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e02004:	e5952010 	ldr	r2, [r5, #16]
57e02008:	e1a00c02 	lsl	r0, r2, #24
57e0200c:	e1800c22 	orr	r0, r0, r2, lsr #24
57e02010:	e202ccff 	and	ip, r2, #65280	; 0xff00
57e02014:	e180040c 	orr	r0, r0, ip, lsl #8
57e02018:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
57e0201c:	e1802422 	orr	r2, r0, r2, lsr #8
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);

		images.os.end = image_get_image_end(os_hdr);
		images.os.load = image_get_load(os_hdr);
57e02020:	e5842058 	str	r2, [r4, #88]	; 0x58
		puts("ERROR: unknown image format type!\n");
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
57e02024:	e5942044 	ldr	r2, [r4, #68]	; 0x44
57e02028:	e3520000 	cmp	r2, #0
57e0202c:	1a000003 	bne	57e02040 <bootm_start.clone.17+0x31c>
57e02030:	ea00000d 	b	57e0206c <bootm_start.clone.17+0x348>
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
57e02034:	eb001cfa 	bl	57e09424 <puts>
		return 1;
57e02038:	e3a00001 	mov	r0, #1
57e0203c:	ea00002a 	b	57e020ec <bootm_start.clone.17+0x3c8>
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e02040:	e5942018 	ldr	r2, [r4, #24]
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
57e02044:	e353000e 	cmp	r3, #14
57e02048:	e1a00c02 	lsl	r0, r2, #24
57e0204c:	e1800c22 	orr	r0, r0, r2, lsr #24
57e02050:	e202ccff 	and	ip, r2, #65280	; 0xff00
57e02054:	e180040c 	orr	r0, r0, ip, lsl #8
57e02058:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
57e0205c:	e1802422 	orr	r2, r0, r2, lsr #8
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
		images.ep = image_get_ep(&images.legacy_hdr_os_copy);
57e02060:	e5842060 	str	r2, [r4, #96]	; 0x60
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
57e02064:	1a000008 	bne	57e0208c <bootm_start.clone.17+0x368>
57e02068:	ea000003 	b	57e0207c <bootm_start.clone.17+0x358>
			puts("Can't get entry point property!\n");
			return 1;
		}
#endif
	} else {
		puts("Could not find kernel entry point!\n");
57e0206c:	e59f00bc 	ldr	r0, [pc, #188]	; 57e02130 <bootm_start.clone.17+0x40c>
57e02070:	eb001ceb 	bl	57e09424 <puts>
		return 1;
57e02074:	e1a0000a 	mov	r0, sl
57e02078:	ea00001b 	b	57e020ec <bootm_start.clone.17+0x3c8>
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
		images.os.load = images.os.image_start;
57e0207c:	e5940050 	ldr	r0, [r4, #80]	; 0x50
		images.ep += images.os.load;
57e02080:	e0822000 	add	r2, r2, r0
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
		images.os.load = images.os.image_start;
57e02084:	e5840058 	str	r0, [r4, #88]	; 0x58
		images.ep += images.os.load;
57e02088:	e5842060 	str	r2, [r4, #96]	; 0x60
	}

	if (((images.os.type == IH_TYPE_KERNEL) ||
57e0208c:	e3530002 	cmp	r3, #2
57e02090:	1353000e 	cmpne	r3, #14
57e02094:	0a000001 	beq	57e020a0 <bootm_start.clone.17+0x37c>
	     (images.os.type == IH_TYPE_KERNEL_NOLOAD) ||
57e02098:	e3530004 	cmp	r3, #4
57e0209c:	1a00000d 	bne	57e020d8 <bootm_start.clone.17+0x3b4>
	     (images.os.type == IH_TYPE_MULTI)) &&
57e020a0:	e3510005 	cmp	r1, #5
57e020a4:	1a00000b 	bne	57e020d8 <bootm_start.clone.17+0x3b4>
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
57e020a8:	e59f3084 	ldr	r3, [pc, #132]	; 57e02134 <bootm_start.clone.17+0x410>
57e020ac:	e1a00007 	mov	r0, r7
57e020b0:	e58d3000 	str	r3, [sp]
57e020b4:	e2833004 	add	r3, r3, #4
57e020b8:	e58d3004 	str	r3, [sp, #4]
57e020bc:	e1a01006 	mov	r1, r6
57e020c0:	e59f2028 	ldr	r2, [pc, #40]	; 57e020f0 <bootm_start.clone.17+0x3cc>
57e020c4:	e3a03002 	mov	r3, #2
57e020c8:	eb0030d1 	bl	57e0e414 <boot_get_ramdisk>
				&images.rd_start, &images.rd_end);
		if (ret) {
57e020cc:	e3500000 	cmp	r0, #0
			puts("Ramdisk image is corrupt or invalid\n");
57e020d0:	159f0060 	ldrne	r0, [pc, #96]	; 57e02138 <bootm_start.clone.17+0x414>
	     (images.os.type == IH_TYPE_MULTI)) &&
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
				&images.rd_start, &images.rd_end);
		if (ret) {
57e020d4:	1affffd6 	bne	57e02034 <bootm_start.clone.17+0x310>

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
57e020d8:	e59f3010 	ldr	r3, [pc, #16]	; 57e020f0 <bootm_start.clone.17+0x3cc>
	images.state = BOOTM_STATE_START;
57e020dc:	e3a02001 	mov	r2, #1

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
57e020e0:	e5835048 	str	r5, [r3, #72]	; 0x48
	images.state = BOOTM_STATE_START;
57e020e4:	e5832088 	str	r2, [r3, #136]	; 0x88

	return 0;
57e020e8:	e3a00000 	mov	r0, #0
}
57e020ec:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e020f0:	57e38240 	.word	0x57e38240
57e020f4:	57e2e7b9 	.word	0x57e2e7b9
57e020f8:	57e36e60 	.word	0x57e36e60
57e020fc:	57e2e7c0 	.word	0x57e2e7c0
57e02100:	27051956 	.word	0x27051956
57e02104:	57e2e62a 	.word	0x57e2e62a
57e02108:	57e2e63f 	.word	0x57e2e63f
57e0210c:	57e2e5d4 	.word	0x57e2e5d4
57e02110:	57e2e657 	.word	0x57e2e657
57e02114:	57e3455d 	.word	0x57e3455d
57e02118:	57e2e7f2 	.word	0x57e2e7f2
57e0211c:	57e38290 	.word	0x57e38290
57e02120:	57e2e811 	.word	0x57e2e811
57e02124:	57e2e832 	.word	0x57e2e832
57e02128:	57e2e855 	.word	0x57e2e855
57e0212c:	57e2e875 	.word	0x57e2e875
57e02130:	57e2e898 	.word	0x57e2e898
57e02134:	57e382a4 	.word	0x57e382a4
57e02138:	57e2e8bc 	.word	0x57e2e8bc

57e0213c <do_bootm>:
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e0213c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
57e02140:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e02144:	e24dd048 	sub	sp, sp, #72	; 0x48
	ulong		iflag;
	ulong		load_end = 0;
57e02148:	e3a0a000 	mov	sl, #0
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e0214c:	e1a07000 	mov	r7, r0
57e02150:	e1a0b001 	mov	fp, r1
57e02154:	e1a05002 	mov	r5, r2
57e02158:	e1a04003 	mov	r4, r3
	ulong		iflag;
	ulong		load_end = 0;
57e0215c:	e58da044 	str	sl, [sp, #68]	; 0x44
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
57e02160:	da000086 	ble	57e02380 <do_bootm+0x244>
		char *endp;

		simple_strtoul(argv[1], &endp, 16);
57e02164:	e5930004 	ldr	r0, [r3, #4]
57e02168:	e28d1040 	add	r1, sp, #64	; 0x40
57e0216c:	e3a02010 	mov	r2, #16
57e02170:	e2836004 	add	r6, r3, #4
57e02174:	eb008bca 	bl	57e250a4 <simple_strtoul>
		 * If endp is ':' or '#' assume a FIT identifier so pass
		 * along for normal processing.
		 *
		 * Right now we assume the first arg should never be '-'
		 */
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
57e02178:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
57e0217c:	e5d33000 	ldrb	r3, [r3]
57e02180:	e353003a 	cmp	r3, #58	; 0x3a
57e02184:	1153000a 	cmpne	r3, sl
57e02188:	0a00007c 	beq	57e02380 <do_bootm+0x244>
57e0218c:	e3530023 	cmp	r3, #35	; 0x23
57e02190:	0a00007a 	beq	57e02380 <do_bootm+0x244>
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
57e02194:	e5940004 	ldr	r0, [r4, #4]
57e02198:	e59f1400 	ldr	r1, [pc, #1024]	; 57e025a0 <do_bootm+0x464>
57e0219c:	e3a02007 	mov	r2, #7
57e021a0:	eb001b21 	bl	57e08e2c <find_cmd_tbl>

	if (c) {
57e021a4:	e3500000 	cmp	r0, #0
57e021a8:	0a000072 	beq	57e02378 <do_bootm+0x23c>
		state = (long)c->cmd;
57e021ac:	e590000c 	ldr	r0, [r0, #12]

		/* treat start special since it resets the state machine */
		if (state == BOOTM_STATE_START) {
57e021b0:	e3500001 	cmp	r0, #1
57e021b4:	1a000005 	bne	57e021d0 <do_bootm+0x94>
			argc--;
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
57e021b8:	e2451001 	sub	r1, r5, #1
57e021bc:	e1a00007 	mov	r0, r7
57e021c0:	e1a02006 	mov	r2, r6
57e021c4:	ebfffed6 	bl	57e01d24 <bootm_start.clone.17>
57e021c8:	e1a05000 	mov	r5, r0
57e021cc:	ea0000f0 	b	57e02594 <do_bootm+0x458>
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
	}

	if (images.state >= state) {
57e021d0:	e59f33cc 	ldr	r3, [pc, #972]	; 57e025a4 <do_bootm+0x468>
57e021d4:	e5932088 	ldr	r2, [r3, #136]	; 0x88
57e021d8:	e1520000 	cmp	r2, r0
57e021dc:	ba000002 	blt	57e021ec <do_bootm+0xb0>
		printf("Trying to execute a command out of order\n");
57e021e0:	e59f03c0 	ldr	r0, [pc, #960]	; 57e025a8 <do_bootm+0x46c>
57e021e4:	eb001c98 	bl	57e0944c <printf>
57e021e8:	ea000062 	b	57e02378 <do_bootm+0x23c>
		return CMD_RET_USAGE;
	}

	images.state |= state;
57e021ec:	e1802002 	orr	r2, r0, r2
57e021f0:	e5832088 	str	r2, [r3, #136]	; 0x88
	boot_fn = boot_os[images.os.os];
57e021f4:	e5d3105e 	ldrb	r1, [r3, #94]	; 0x5e
57e021f8:	e59f23ac 	ldr	r2, [pc, #940]	; 57e025ac <do_bootm+0x470>

	switch (state) {
57e021fc:	e3500010 	cmp	r0, #16
		printf("Trying to execute a command out of order\n");
		return CMD_RET_USAGE;
	}

	images.state |= state;
	boot_fn = boot_os[images.os.os];
57e02200:	e7926101 	ldr	r6, [r2, r1, lsl #2]

	switch (state) {
57e02204:	0a00003c 	beq	57e022fc <do_bootm+0x1c0>
57e02208:	ca000004 	bgt	57e02220 <do_bootm+0xe4>
57e0220c:	e3500002 	cmp	r0, #2
57e02210:	0a000009 	beq	57e0223c <do_bootm+0x100>
57e02214:	e3500004 	cmp	r0, #4
57e02218:	1a0000b9 	bne	57e02504 <do_bootm+0x3c8>
57e0221c:	ea00001b 	b	57e02290 <do_bootm+0x154>
57e02220:	e3500040 	cmp	r0, #64	; 0x40
57e02224:	0a000043 	beq	57e02338 <do_bootm+0x1fc>
57e02228:	e3500080 	cmp	r0, #128	; 0x80
57e0222c:	0a000049 	beq	57e02358 <do_bootm+0x21c>
57e02230:	e3500020 	cmp	r0, #32
57e02234:	1a0000b2 	bne	57e02504 <do_bootm+0x3c8>
57e02238:	ea000036 	b	57e02318 <do_bootm+0x1dc>
		ulong load_end;
		case BOOTM_STATE_START:
			/* should never occur */
			break;
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
57e0223c:	e5932058 	ldr	r2, [r3, #88]	; 0x58
57e02240:	e58d2000 	str	r2, [sp]
57e02244:	e5d3205c 	ldrb	r2, [r3, #92]	; 0x5c
57e02248:	e58d2004 	str	r2, [sp, #4]
57e0224c:	e5d3205d 	ldrb	r2, [r3, #93]	; 0x5d
57e02250:	e58da010 	str	sl, [sp, #16]
57e02254:	e58d2008 	str	r2, [sp, #8]
57e02258:	e28d203c 	add	r2, sp, #60	; 0x3c
57e0225c:	e58d200c 	str	r2, [sp, #12]
57e02260:	e2830048 	add	r0, r3, #72	; 0x48
57e02264:	e890000f 	ldm	r0, {r0, r1, r2, r3}
57e02268:	ebfffe52 	bl	57e01bb8 <bootm_load_os.clone.18>
			if (ret)
57e0226c:	e2505000 	subs	r5, r0, #0
57e02270:	1a0000c7 	bne	57e02594 <do_bootm+0x458>
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
					(load_end - images.os.load));
57e02274:	e59f0328 	ldr	r0, [pc, #808]	; 57e025a4 <do_bootm+0x468>
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
			if (ret)
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
57e02278:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
					(load_end - images.os.load));
57e0227c:	e5901058 	ldr	r1, [r0, #88]	; 0x58
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
			if (ret)
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
57e02280:	e280008c 	add	r0, r0, #140	; 0x8c
57e02284:	e0612002 	rsb	r2, r1, r2
57e02288:	eb00860a 	bl	57e23ab8 <lmb_reserve>
57e0228c:	ea0000c0 	b	57e02594 <do_bootm+0x458>
					(load_end - images.os.load));
			break;
#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
		case BOOTM_STATE_RAMDISK:
		{
			ulong rd_len = images.rd_end - images.rd_start;
57e02290:	e59f430c 	ldr	r4, [pc, #780]	; 57e025a4 <do_bootm+0x468>
57e02294:	e5941064 	ldr	r1, [r4, #100]	; 0x64
57e02298:	e5942068 	ldr	r2, [r4, #104]	; 0x68
			char str[17];

			ret = boot_ramdisk_high(&images.lmb, images.rd_start,
57e0229c:	e2843074 	add	r3, r4, #116	; 0x74
57e022a0:	e58d3000 	str	r3, [sp]
57e022a4:	e284008c 	add	r0, r4, #140	; 0x8c
57e022a8:	e0612002 	rsb	r2, r1, r2
57e022ac:	e2843070 	add	r3, r4, #112	; 0x70
57e022b0:	eb0030ef 	bl	57e0e674 <boot_ramdisk_high>
				rd_len, &images.initrd_start, &images.initrd_end);
			if (ret)
57e022b4:	e2505000 	subs	r5, r0, #0
57e022b8:	1a0000b5 	bne	57e02594 <do_bootm+0x458>
				return ret;

			sprintf(str, "%lx", images.initrd_start);
57e022bc:	e28d601c 	add	r6, sp, #28
57e022c0:	e5942070 	ldr	r2, [r4, #112]	; 0x70
57e022c4:	e1a00006 	mov	r0, r6
57e022c8:	e59f12e0 	ldr	r1, [pc, #736]	; 57e025b0 <do_bootm+0x474>
57e022cc:	eb008c1d 	bl	57e25348 <sprintf>
			setenv("initrd_start", str);
57e022d0:	e1a01006 	mov	r1, r6
57e022d4:	e59f02d8 	ldr	r0, [pc, #728]	; 57e025b4 <do_bootm+0x478>
57e022d8:	eb0013f4 	bl	57e072b0 <setenv>
			sprintf(str, "%lx", images.initrd_end);
57e022dc:	e1a00006 	mov	r0, r6
57e022e0:	e59f12c8 	ldr	r1, [pc, #712]	; 57e025b0 <do_bootm+0x474>
57e022e4:	e5942074 	ldr	r2, [r4, #116]	; 0x74
57e022e8:	eb008c16 	bl	57e25348 <sprintf>
			setenv("initrd_end", str);
57e022ec:	e1a01006 	mov	r1, r6
57e022f0:	e59f02c0 	ldr	r0, [pc, #704]	; 57e025b8 <do_bootm+0x47c>
57e022f4:	eb0013ed 	bl	57e072b0 <setenv>
57e022f8:	ea0000a5 	b	57e02594 <do_bootm+0x458>
				&images.ft_addr, &images.ft_len);
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
57e022fc:	e1a01005 	mov	r1, r5
57e02300:	e1a02004 	mov	r2, r4
57e02304:	e12fff36 	blx	r6
			if (ret)
57e02308:	e2505000 	subs	r5, r0, #0
				printf("cmdline subcommand not supported\n");
57e0230c:	159f02a8 	ldrne	r0, [pc, #680]	; 57e025bc <do_bootm+0x480>
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
			if (ret)
57e02310:	0a00009f 	beq	57e02594 <do_bootm+0x458>
57e02314:	ea00000d 	b	57e02350 <do_bootm+0x214>
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
57e02318:	e1a01005 	mov	r1, r5
57e0231c:	e1a02004 	mov	r2, r4
57e02320:	e59f327c 	ldr	r3, [pc, #636]	; 57e025a4 <do_bootm+0x468>
57e02324:	e12fff36 	blx	r6
			if (ret)
57e02328:	e2505000 	subs	r5, r0, #0
				printf("bdt subcommand not supported\n");
57e0232c:	159f028c 	ldrne	r0, [pc, #652]	; 57e025c0 <do_bootm+0x484>
			if (ret)
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
			if (ret)
57e02330:	0a000097 	beq	57e02594 <do_bootm+0x458>
57e02334:	ea000005 	b	57e02350 <do_bootm+0x214>
				printf("bdt subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_PREP:
			ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, &images);
57e02338:	e1a01005 	mov	r1, r5
57e0233c:	e1a02004 	mov	r2, r4
57e02340:	e12fff36 	blx	r6
			if (ret)
57e02344:	e2505000 	subs	r5, r0, #0
57e02348:	0a000091 	beq	57e02594 <do_bootm+0x458>
				printf("prep subcommand not supported\n");
57e0234c:	e59f0270 	ldr	r0, [pc, #624]	; 57e025c4 <do_bootm+0x488>
57e02350:	eb001c3d 	bl	57e0944c <printf>
57e02354:	ea00008e 	b	57e02594 <do_bootm+0x458>
			break;
		case BOOTM_STATE_OS_GO:
			disable_interrupts();
57e02358:	ebfffb71 	bl	57e01124 <disable_interrupts>
			 * Stop the ethernet stack if NetConsole could have
			 * left it up
			 */
			eth_halt();
#endif
			arch_preboot_os();
57e0235c:	eb0000a0 	bl	57e025e4 <arch_preboot_os>
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
57e02360:	e1a01005 	mov	r1, r5
57e02364:	e1a02004 	mov	r2, r4
57e02368:	e59f3234 	ldr	r3, [pc, #564]	; 57e025a4 <do_bootm+0x468>
57e0236c:	e3a00080 	mov	r0, #128	; 0x80
57e02370:	e12fff36 	blx	r6
57e02374:	ea000062 	b	57e02504 <do_bootm+0x3c8>
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
		}
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
57e02378:	e3e05000 	mvn	r5, #0
57e0237c:	ea000084 	b	57e02594 <do_bootm+0x458>
		 */
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
	}

	if (bootm_start(cmdtp, flag, argc, argv))
57e02380:	e1a00007 	mov	r0, r7
57e02384:	e1a01005 	mov	r1, r5
57e02388:	e1a02004 	mov	r2, r4
57e0238c:	ebfffe64 	bl	57e01d24 <bootm_start.clone.17>
57e02390:	e3500000 	cmp	r0, #0
57e02394:	1a00007d 	bne	57e02590 <do_bootm+0x454>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
57e02398:	ebfffb61 	bl	57e01124 <disable_interrupts>
	local_args[0] = argv[0];
	local_args[1] = str;	/* and provide it via the arguments */
	do_bootelf(NULL, 0, 2, local_args);

	return 1;
}
57e0239c:	e59f6200 	ldr	r6, [pc, #512]	; 57e025a4 <do_bootm+0x468>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
57e023a0:	e1a09000 	mov	r9, r0
	 * lies within the SDRAM and the host controller writes continously to
	 * this area (as busmaster!). The HccaFrameNumber is for example
	 * updated every 1 ms within the HCCA structure in SDRAM! For more
	 * details see the OpenHCI specification.
	 */
	usb_stop();
57e023a4:	eb0035ce 	bl	57e0fae4 <usb_stop>
#endif

	ret = bootm_load_os(images.os, &load_end, 1);
57e023a8:	e5963058 	ldr	r3, [r6, #88]	; 0x58
57e023ac:	e58d3000 	str	r3, [sp]
57e023b0:	e5d6305c 	ldrb	r3, [r6, #92]	; 0x5c
57e023b4:	e58d3004 	str	r3, [sp, #4]
57e023b8:	e5d6305d 	ldrb	r3, [r6, #93]	; 0x5d
57e023bc:	e58d3008 	str	r3, [sp, #8]
57e023c0:	e28d3044 	add	r3, sp, #68	; 0x44
57e023c4:	e58d300c 	str	r3, [sp, #12]
57e023c8:	e3a03001 	mov	r3, #1
57e023cc:	e58d3010 	str	r3, [sp, #16]
57e023d0:	e2860048 	add	r0, r6, #72	; 0x48
57e023d4:	e890000f 	ldm	r0, {r0, r1, r2, r3}
57e023d8:	ebfffdf6 	bl	57e01bb8 <bootm_load_os.clone.18>

	if (ret < 0) {
57e023dc:	e3500000 	cmp	r0, #0
57e023e0:	aa00001d 	bge	57e0245c <do_bootm+0x320>
		if (ret == BOOTM_ERR_RESET)
57e023e4:	e3700001 	cmn	r0, #1
57e023e8:	0a00000e 	beq	57e02428 <do_bootm+0x2ec>
			do_reset(cmdtp, flag, argc, argv);
		if (ret == BOOTM_ERR_OVERLAP) {
57e023ec:	e3700002 	cmn	r0, #2
57e023f0:	1a000012 	bne	57e02440 <do_bootm+0x304>
			if (images.legacy_hdr_valid) {
57e023f4:	e5963044 	ldr	r3, [r6, #68]	; 0x44
57e023f8:	e3530000 	cmp	r3, #0
57e023fc:	0a000005 	beq	57e02418 <do_bootm+0x2dc>
				image_header_t *hdr;
				hdr = &images.legacy_hdr_os_copy;
				if (image_get_type(hdr) == IH_TYPE_MULTI)
57e02400:	e5d63022 	ldrb	r3, [r6, #34]	; 0x22
57e02404:	e3530004 	cmp	r3, #4
57e02408:	1a000013 	bne	57e0245c <do_bootm+0x320>
					puts("WARNING: legacy format multi "
57e0240c:	e59f01b4 	ldr	r0, [pc, #436]	; 57e025c8 <do_bootm+0x48c>
57e02410:	eb001c03 	bl	57e09424 <puts>
57e02414:	ea000010 	b	57e0245c <do_bootm+0x320>
						"component image "
						"overwritten\n");
			} else {
				puts("ERROR: new format image overwritten - "
57e02418:	e59f01ac 	ldr	r0, [pc, #428]	; 57e025cc <do_bootm+0x490>
57e0241c:	eb001c00 	bl	57e09424 <puts>
57e02420:	e3e00070 	mvn	r0, #112	; 0x70
57e02424:	eb00314e 	bl	57e0e964 <__show_boot_progress>
					"must RESET the board to recover\n");
				bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);
				do_reset(cmdtp, flag, argc, argv);
57e02428:	e1a00007 	mov	r0, r7
57e0242c:	e1a0100b 	mov	r1, fp
57e02430:	e1a02005 	mov	r2, r5
57e02434:	e1a03004 	mov	r3, r4
57e02438:	ebfffbce 	bl	57e01378 <do_reset>
57e0243c:	ea000006 	b	57e0245c <do_bootm+0x320>
			}
		}
		if (ret == BOOTM_ERR_UNIMPLEMENTED) {
57e02440:	e3700003 	cmn	r0, #3
57e02444:	1a000004 	bne	57e0245c <do_bootm+0x320>
			if (iflag)
57e02448:	e3590000 	cmp	r9, #0
57e0244c:	0a000000 	beq	57e02454 <do_bootm+0x318>
				enable_interrupts();
57e02450:	ebfffb32 	bl	57e01120 <enable_interrupts>
57e02454:	e3e00006 	mvn	r0, #6
57e02458:	ea00003d 	b	57e02554 <do_bootm+0x418>
			bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);
			return 1;
		}
	}

	lmb_reserve(&images.lmb, images.os.load, (load_end - images.os.load));
57e0245c:	e59fa140 	ldr	sl, [pc, #320]	; 57e025a4 <do_bootm+0x468>
57e02460:	e59d2044 	ldr	r2, [sp, #68]	; 0x44
57e02464:	e59a1058 	ldr	r1, [sl, #88]	; 0x58
57e02468:	e28a008c 	add	r0, sl, #140	; 0x8c
57e0246c:	e0612002 	rsb	r2, r1, r2
57e02470:	eb008590 	bl	57e23ab8 <lmb_reserve>

	if (images.os.type == IH_TYPE_STANDALONE) {
57e02474:	e5da305d 	ldrb	r3, [sl, #93]	; 0x5d
57e02478:	e3530001 	cmp	r3, #1
57e0247c:	1a000022 	bne	57e0250c <do_bootm+0x3d0>
		if (iflag)
57e02480:	e3590000 	cmp	r9, #0
57e02484:	0a000000 	beq	57e0248c <do_bootm+0x350>
			enable_interrupts();
57e02488:	ebfffb24 	bl	57e01120 <enable_interrupts>
{
	char  *s;
	int   (*appl)(int, char * const []);

	/* Don't start if "autostart" is set to "no" */
	if (((s = getenv("autostart")) != NULL) && (strcmp(s, "no") == 0)) {
57e0248c:	e59f013c 	ldr	r0, [pc, #316]	; 57e025d0 <do_bootm+0x494>
57e02490:	eb001494 	bl	57e076e8 <getenv>
57e02494:	e3500000 	cmp	r0, #0
57e02498:	0a00000e 	beq	57e024d8 <do_bootm+0x39c>
57e0249c:	e59f1130 	ldr	r1, [pc, #304]	; 57e025d4 <do_bootm+0x498>
57e024a0:	eb0086bf 	bl	57e23fa4 <strcmp>
57e024a4:	e2506000 	subs	r6, r0, #0
57e024a8:	1a00000a 	bne	57e024d8 <do_bootm+0x39c>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
57e024ac:	e59f30f0 	ldr	r3, [pc, #240]	; 57e025a4 <do_bootm+0x468>
57e024b0:	e28d401c 	add	r4, sp, #28
57e024b4:	e59f111c 	ldr	r1, [pc, #284]	; 57e025d8 <do_bootm+0x49c>
57e024b8:	e5932054 	ldr	r2, [r3, #84]	; 0x54
57e024bc:	e1a00004 	mov	r0, r4
57e024c0:	eb008ba0 	bl	57e25348 <sprintf>
		setenv("filesize", buf);
57e024c4:	e59f0110 	ldr	r0, [pc, #272]	; 57e025dc <do_bootm+0x4a0>
57e024c8:	e1a01004 	mov	r1, r4
57e024cc:	eb001377 	bl	57e072b0 <setenv>
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
57e024d0:	e1a05006 	mov	r5, r6
57e024d4:	ea00002e 	b	57e02594 <do_bootm+0x458>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
57e024d8:	e59f30c4 	ldr	r3, [pc, #196]	; 57e025a4 <do_bootm+0x468>
	(*appl)(argc-1, &argv[1]);
57e024dc:	e2450001 	sub	r0, r5, #1
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
57e024e0:	e5932060 	ldr	r2, [r3, #96]	; 0x60
57e024e4:	e1a03c02 	lsl	r3, r2, #24
57e024e8:	e2021cff 	and	r1, r2, #65280	; 0xff00
57e024ec:	e1833c22 	orr	r3, r3, r2, lsr #24
57e024f0:	e1833401 	orr	r3, r3, r1, lsl #8
57e024f4:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
57e024f8:	e1833422 	orr	r3, r3, r2, lsr #8
	(*appl)(argc-1, &argv[1]);
57e024fc:	e2841004 	add	r1, r4, #4
57e02500:	e12fff33 	blx	r3
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
57e02504:	e3a05000 	mov	r5, #0
57e02508:	ea000021 	b	57e02594 <do_bootm+0x458>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e0250c:	e3a00008 	mov	r0, #8
57e02510:	eb003113 	bl	57e0e964 <__show_boot_progress>
#ifdef CONFIG_SILENT_CONSOLE
	if (images.os.os == IH_OS_LINUX)
		fixup_silent_linux();
#endif

	boot_fn = boot_os[images.os.os];
57e02514:	e5da205e 	ldrb	r2, [sl, #94]	; 0x5e
57e02518:	e59f308c 	ldr	r3, [pc, #140]	; 57e025ac <do_bootm+0x470>
57e0251c:	e7936102 	ldr	r6, [r3, r2, lsl #2]

	if (boot_fn == NULL) {
57e02520:	e3560000 	cmp	r6, #0
57e02524:	1a00000c 	bne	57e0255c <do_bootm+0x420>
		if (iflag)
57e02528:	e3590000 	cmp	r9, #0
57e0252c:	0a000000 	beq	57e02534 <do_bootm+0x3f8>
			enable_interrupts();
57e02530:	ebfffafa 	bl	57e01120 <enable_interrupts>
		printf("ERROR: booting os '%s' (%d) is not supported\n",
57e02534:	e59f4068 	ldr	r4, [pc, #104]	; 57e025a4 <do_bootm+0x468>
57e02538:	e5d4005e 	ldrb	r0, [r4, #94]	; 0x5e
57e0253c:	eb002ef6 	bl	57e0e11c <genimg_get_os_name>
57e02540:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
57e02544:	e1a01000 	mov	r1, r0
57e02548:	e59f0090 	ldr	r0, [pc, #144]	; 57e025e0 <do_bootm+0x4a4>
57e0254c:	eb001bbe 	bl	57e0944c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e02550:	e3e00007 	mvn	r0, #7
57e02554:	eb003102 	bl	57e0e964 <__show_boot_progress>
57e02558:	ea00000c 	b	57e02590 <do_bootm+0x454>
			genimg_get_os_name(images.os.os), images.os.os);
		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);
		return 1;
	}

	arch_preboot_os();
57e0255c:	eb000020 	bl	57e025e4 <arch_preboot_os>

	boot_fn(0, argc, argv, &images);
57e02560:	e1a01005 	mov	r1, r5
57e02564:	e1a02004 	mov	r2, r4
57e02568:	e1a0300a 	mov	r3, sl
57e0256c:	e3a00000 	mov	r0, #0
57e02570:	e12fff36 	blx	r6
57e02574:	e3e00008 	mvn	r0, #8
57e02578:	eb0030f9 	bl	57e0e964 <__show_boot_progress>

	bootstage_error(BOOTSTAGE_ID_BOOT_OS_RETURNED);
#ifdef DEBUG
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);
57e0257c:	e1a00007 	mov	r0, r7
57e02580:	e1a0100b 	mov	r1, fp
57e02584:	e1a02005 	mov	r2, r5
57e02588:	e1a03004 	mov	r3, r4
57e0258c:	ebfffb79 	bl	57e01378 <do_reset>
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
	}

	if (bootm_start(cmdtp, flag, argc, argv))
		return 1;
57e02590:	e3a05001 	mov	r5, #1
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);

	return 1;
}
57e02594:	e1a00005 	mov	r0, r5
57e02598:	e28dd048 	add	sp, sp, #72	; 0x48
57e0259c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e025a0:	57e35f70 	.word	0x57e35f70
57e025a4:	57e38240 	.word	0x57e38240
57e025a8:	57e2e8e1 	.word	0x57e2e8e1
57e025ac:	57e2bce0 	.word	0x57e2bce0
57e025b0:	57e2e684 	.word	0x57e2e684
57e025b4:	57e2e90b 	.word	0x57e2e90b
57e025b8:	57e2e918 	.word	0x57e2e918
57e025bc:	57e2e923 	.word	0x57e2e923
57e025c0:	57e2e945 	.word	0x57e2e945
57e025c4:	57e2e963 	.word	0x57e2e963
57e025c8:	57e2e982 	.word	0x57e2e982
57e025cc:	57e2e9bc 	.word	0x57e2e9bc
57e025d0:	57e2ea03 	.word	0x57e2ea03
57e025d4:	57e2ea0d 	.word	0x57e2ea0d
57e025d8:	57e2ea10 	.word	0x57e2ea10
57e025dc:	57e2ea14 	.word	0x57e2ea14
57e025e0:	57e2ea1d 	.word	0x57e2ea1d

57e025e4 <arch_preboot_os>:

/* Allow for arch specific config before we boot */
static void __arch_preboot_os(void)
{
	/* please define platform specific arch_preboot_os() */
}
57e025e4:	e12fff1e 	bx	lr

57e025e8 <bootm_maybe_autostart>:

	return 1;
}

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
57e025e8:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
57e025ec:	e1a05000 	mov	r5, r0
	const char *ep = getenv("autostart");
57e025f0:	e59f0054 	ldr	r0, [pc, #84]	; 57e0264c <bootm_maybe_autostart+0x64>

	return 1;
}

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
57e025f4:	e1a06001 	mov	r6, r1
	const char *ep = getenv("autostart");
57e025f8:	eb00143a 	bl	57e076e8 <getenv>

	if (ep && !strcmp(ep, "yes")) {
57e025fc:	e2503000 	subs	r3, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
57e02600:	01a00003 	moveq	r0, r3

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
57e02604:	0a00000f 	beq	57e02648 <bootm_maybe_autostart+0x60>
57e02608:	e59f1040 	ldr	r1, [pc, #64]	; 57e02650 <bootm_maybe_autostart+0x68>
57e0260c:	eb008664 	bl	57e23fa4 <strcmp>
57e02610:	e2504000 	subs	r4, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
57e02614:	13a00000 	movne	r0, #0

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
57e02618:	1a00000a 	bne	57e02648 <bootm_maybe_autostart+0x60>
		char *local_args[2];
		local_args[0] = (char *)cmd;
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
57e0261c:	e59f3030 	ldr	r3, [pc, #48]	; 57e02654 <bootm_maybe_autostart+0x6c>
57e02620:	e59f0030 	ldr	r0, [pc, #48]	; 57e02658 <bootm_maybe_autostart+0x70>
57e02624:	e5931000 	ldr	r1, [r3]
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
		char *local_args[2];
		local_args[0] = (char *)cmd;
57e02628:	e58d6000 	str	r6, [sp]
		local_args[1] = NULL;
57e0262c:	e58d4004 	str	r4, [sp, #4]
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
57e02630:	eb001b85 	bl	57e0944c <printf>
		return do_bootm(cmdtp, 0, 1, local_args);
57e02634:	e1a00005 	mov	r0, r5
57e02638:	e1a01004 	mov	r1, r4
57e0263c:	e3a02001 	mov	r2, #1
57e02640:	e1a0300d 	mov	r3, sp
57e02644:	ebfffebc 	bl	57e0213c <do_bootm>
	}

	return 0;
}
57e02648:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
57e0264c:	57e2ea03 	.word	0x57e2ea03
57e02650:	57e2ea4b 	.word	0x57e2ea4b
57e02654:	57e36e60 	.word	0x57e36e60
57e02658:	57e2ea4f 	.word	0x57e2ea4f

57e0265c <parse_argv>:
	}
	return 0;
}

static int parse_argv(const char *s)
{
57e0265c:	e92d4010 	push	{r4, lr}
	if (strcmp(s, "flush") == 0)
57e02660:	e59f1044 	ldr	r1, [pc, #68]	; 57e026ac <parse_argv+0x50>
	}
	return 0;
}

static int parse_argv(const char *s)
{
57e02664:	e1a04000 	mov	r4, r0
	if (strcmp(s, "flush") == 0)
57e02668:	eb00864d 	bl	57e23fa4 <strcmp>
57e0266c:	e3500000 	cmp	r0, #0
		return 2;
57e02670:	03a00002 	moveq	r0, #2
	return 0;
}

static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
57e02674:	08bd8010 	popeq	{r4, pc}
		return 2;
	else if (strcmp(s, "on") == 0)
57e02678:	e1a00004 	mov	r0, r4
57e0267c:	e59f102c 	ldr	r1, [pc, #44]	; 57e026b0 <parse_argv+0x54>
57e02680:	eb008647 	bl	57e23fa4 <strcmp>
57e02684:	e3500000 	cmp	r0, #0
57e02688:	0a000005 	beq	57e026a4 <parse_argv+0x48>
		return 1;
	else if (strcmp(s, "off") == 0)
57e0268c:	e1a00004 	mov	r0, r4
57e02690:	e59f101c 	ldr	r1, [pc, #28]	; 57e026b4 <parse_argv+0x58>
57e02694:	eb008642 	bl	57e23fa4 <strcmp>
57e02698:	e3500000 	cmp	r0, #0
		return 0;
57e0269c:	13e00000 	mvnne	r0, #0
57e026a0:	e8bd8010 	pop	{r4, pc}
static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
		return 2;
	else if (strcmp(s, "on") == 0)
		return 1;
57e026a4:	e3a00001 	mov	r0, #1
	else if (strcmp(s, "off") == 0)
		return 0;

	return -1;
}
57e026a8:	e8bd8010 	pop	{r4, pc}
57e026ac:	57e2ec72 	.word	0x57e2ec72
57e026b0:	57e357fe 	.word	0x57e357fe
57e026b4:	57e2e48c 	.word	0x57e2e48c

57e026b8 <invalidate_icache_all>:
static int parse_argv(const char *);

void __weak invalidate_icache_all(void)
{
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
57e026b8:	e59f0000 	ldr	r0, [pc, #0]	; 57e026c0 <invalidate_icache_all+0x8>
57e026bc:	ea001b58 	b	57e09424 <puts>
57e026c0:	57e2ec78 	.word	0x57e2ec78

57e026c4 <do_icache>:
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
57e026c4:	e3520001 	cmp	r2, #1
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e026c8:	e92d4010 	push	{r4, lr}
	switch (argc) {
57e026cc:	0a000012 	beq	57e0271c <do_icache+0x58>
57e026d0:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
57e026d4:	13e00000 	mvnne	r0, #0
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
57e026d8:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
57e026dc:	e5930004 	ldr	r0, [r3, #4]
57e026e0:	ebffffdd 	bl	57e0265c <parse_argv>
57e026e4:	e3500001 	cmp	r0, #1
57e026e8:	e1a04000 	mov	r4, r0
57e026ec:	0a000006 	beq	57e0270c <do_icache+0x48>
57e026f0:	e3500002 	cmp	r0, #2
57e026f4:	0a000006 	beq	57e02714 <do_icache+0x50>
57e026f8:	e3500000 	cmp	r0, #0
57e026fc:	1a00000f 	bne	57e02740 <do_icache+0x7c>
		case 0:
			icache_disable();
57e02700:	ebfffb8d 	bl	57e0153c <icache_disable>
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
57e02704:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
		case 0:
			icache_disable();
			break;
57e02708:	e8bd8010 	pop	{r4, pc}
		case 1:
			icache_enable();
57e0270c:	ebfffb88 	bl	57e01534 <icache_enable>
57e02710:	ea000008 	b	57e02738 <do_icache+0x74>
			break;
		case 2:
			invalidate_icache_all();
57e02714:	ebffffe7 	bl	57e026b8 <invalidate_icache_all>
57e02718:	ea000006 	b	57e02738 <do_icache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
57e0271c:	ebfffb88 	bl	57e01544 <icache_status>
			invalidate_icache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
57e02720:	e59f3020 	ldr	r3, [pc, #32]	; 57e02748 <do_icache+0x84>
57e02724:	e3500000 	cmp	r0, #0
57e02728:	e59f101c 	ldr	r1, [pc, #28]	; 57e0274c <do_icache+0x88>
57e0272c:	e59f001c 	ldr	r0, [pc, #28]	; 57e02750 <do_icache+0x8c>
57e02730:	11a01003 	movne	r1, r3
57e02734:	eb001b44 	bl	57e0944c <printf>
			icache_status() ? "ON" : "OFF");
		return 0;
57e02738:	e3a00000 	mov	r0, #0
57e0273c:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
57e02740:	e3a00000 	mov	r0, #0
}
57e02744:	e8bd8010 	pop	{r4, pc}
57e02748:	57e323e1 	.word	0x57e323e1
57e0274c:	57e2ecab 	.word	0x57e2ecab
57e02750:	57e2ecaf 	.word	0x57e2ecaf

void __weak flush_dcache_all(void)
{
	puts("No arch specific flush_dcache_all available!\n");
57e02754:	e59f0000 	ldr	r0, [pc, #0]	; 57e0275c <do_icache+0x98>
57e02758:	ea001b31 	b	57e09424 <puts>
57e0275c:	57e2ecc8 	.word	0x57e2ecc8

57e02760 <do_dcache>:
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
57e02760:	e3520001 	cmp	r2, #1
	puts("No arch specific flush_dcache_all available!\n");
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e02764:	e92d4010 	push	{r4, lr}
	switch (argc) {
57e02768:	0a000012 	beq	57e027b8 <do_dcache+0x58>
57e0276c:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
57e02770:	13e00000 	mvnne	r0, #0
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
57e02774:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
57e02778:	e5930004 	ldr	r0, [r3, #4]
57e0277c:	ebffffb6 	bl	57e0265c <parse_argv>
57e02780:	e3500001 	cmp	r0, #1
57e02784:	e1a04000 	mov	r4, r0
57e02788:	0a000006 	beq	57e027a8 <do_dcache+0x48>
57e0278c:	e3500002 	cmp	r0, #2
57e02790:	0a000006 	beq	57e027b0 <do_dcache+0x50>
57e02794:	e3500000 	cmp	r0, #0
57e02798:	1a00000f 	bne	57e027dc <do_dcache+0x7c>
		case 0:
			dcache_disable();
57e0279c:	ebfffb6f 	bl	57e01560 <dcache_disable>
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
57e027a0:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
		case 0:
			dcache_disable();
			break;
57e027a4:	e8bd8010 	pop	{r4, pc}
		case 1:
			dcache_enable();
57e027a8:	ebfffb6a 	bl	57e01558 <dcache_enable>
57e027ac:	ea000008 	b	57e027d4 <do_dcache+0x74>
			break;
		case 2:
			flush_dcache_all();
57e027b0:	ebfffafd 	bl	57e013ac <__flush_dcache_all>
57e027b4:	ea000006 	b	57e027d4 <do_dcache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
57e027b8:	ebfffb6a 	bl	57e01568 <dcache_status>
			flush_dcache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
57e027bc:	e59f3020 	ldr	r3, [pc, #32]	; 57e027e4 <do_dcache+0x84>
57e027c0:	e3500000 	cmp	r0, #0
57e027c4:	e59f101c 	ldr	r1, [pc, #28]	; 57e027e8 <do_dcache+0x88>
57e027c8:	e59f001c 	ldr	r0, [pc, #28]	; 57e027ec <do_dcache+0x8c>
57e027cc:	11a01003 	movne	r1, r3
57e027d0:	eb001b1d 	bl	57e0944c <printf>
			dcache_status() ? "ON" : "OFF");
		return 0;
57e027d4:	e3a00000 	mov	r0, #0
57e027d8:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
57e027dc:	e3a00000 	mov	r0, #0
}
57e027e0:	e8bd8010 	pop	{r4, pc}
57e027e4:	57e323e1 	.word	0x57e323e1
57e027e8:	57e2ecab 	.word	0x57e2ecab
57e027ec:	57e2ecf6 	.word	0x57e2ecf6

57e027f0 <do_coninfo>:
#include <command.h>
#include <stdio_dev.h>

extern void _do_coninfo (void);
static int do_coninfo(cmd_tbl_t *cmd, int flag, int argc, char * const argv[])
{
57e027f0:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	int l;
	struct list_head *list = stdio_get_list();
57e027f4:	eb003444 	bl	57e0f90c <stdio_get_list>
57e027f8:	e1a05000 	mov	r5, r0
	struct list_head *pos;
	struct stdio_dev *dev;

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");
57e027fc:	e59f0090 	ldr	r0, [pc, #144]	; 57e02894 <do_coninfo+0xa4>
57e02800:	eb001b07 	bl	57e09424 <puts>
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
57e02804:	e59f708c 	ldr	r7, [pc, #140]	; 57e02898 <do_coninfo+0xa8>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
57e02808:	e5954000 	ldr	r4, [r5]
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
57e0280c:	e59fa088 	ldr	sl, [pc, #136]	; 57e0289c <do_coninfo+0xac>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
57e02810:	ea00001b 	b	57e02884 <do_coninfo+0x94>
		dev = list_entry(pos, struct stdio_dev, list);

		printf ("%-8s %08x %c%c%c ",
			dev->name,
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
57e02814:	e5142034 	ldr	r2, [r4, #-52]	; 0x34
	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
		dev = list_entry(pos, struct stdio_dev, list);
57e02818:	e2446034 	sub	r6, r4, #52	; 0x34

		printf ("%-8s %08x %c%c%c ",
57e0281c:	e3120001 	tst	r2, #1
57e02820:	03a0102e 	moveq	r1, #46	; 0x2e
57e02824:	13a01049 	movne	r1, #73	; 0x49
57e02828:	e3120002 	tst	r2, #2
57e0282c:	03a0302e 	moveq	r3, #46	; 0x2e
57e02830:	13a0304f 	movne	r3, #79	; 0x4f
57e02834:	e3520000 	cmp	r2, #0
57e02838:	e88d000a 	stm	sp, {r1, r3}
57e0283c:	e59f005c 	ldr	r0, [pc, #92]	; 57e028a0 <do_coninfo+0xb0>
57e02840:	e2861008 	add	r1, r6, #8
57e02844:	a3a0302e 	movge	r3, #46	; 0x2e
57e02848:	b3a03053 	movlt	r3, #83	; 0x53
57e0284c:	eb001afe 	bl	57e0944c <printf>
57e02850:	e3a09000 	mov	r9, #0
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
57e02854:	e7993007 	ldr	r3, [r9, r7]
57e02858:	e1530006 	cmp	r3, r6
57e0285c:	1a000002 	bne	57e0286c <do_coninfo+0x7c>
				printf ("%s ", stdio_names[l]);
57e02860:	e59f003c 	ldr	r0, [pc, #60]	; 57e028a4 <do_coninfo+0xb4>
57e02864:	e799100a 	ldr	r1, [r9, sl]
57e02868:	eb001af7 	bl	57e0944c <printf>
57e0286c:	e2899004 	add	r9, r9, #4
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
57e02870:	e359000c 	cmp	r9, #12
57e02874:	1afffff6 	bne	57e02854 <do_coninfo+0x64>
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
			}
		}
		putc ('\n');
57e02878:	e3a0000a 	mov	r0, #10
57e0287c:	eb001ade 	bl	57e093fc <putc>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
57e02880:	e5944000 	ldr	r4, [r4]
57e02884:	e1540005 	cmp	r4, r5
57e02888:	1affffe1 	bne	57e02814 <do_coninfo+0x24>
			}
		}
		putc ('\n');
	}
	return 0;
}
57e0288c:	e3a00000 	mov	r0, #0
57e02890:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
57e02894:	57e2edf4 	.word	0x57e2edf4
57e02898:	57e39c2c 	.word	0x57e39c2c
57e0289c:	57e36e68 	.word	0x57e36e68
57e028a0:	57e2ee10 	.word	0x57e2ee10
57e028a4:	57e31d21 	.word	0x57e31d21

57e028a8 <common_diskboot>:

#if defined(CONFIG_CMD_IDE) || defined(CONFIG_CMD_SCSI) || \
	defined(CONFIG_USB_STORAGE)
int common_diskboot(cmd_tbl_t *cmdtp, const char *intf, int argc,
		    char *const argv[])
{
57e028a8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e028ac:	e24dd068 	sub	sp, sp, #104	; 0x68
57e028b0:	e58d000c 	str	r0, [sp, #12]
57e028b4:	e1a05002 	mov	r5, r2
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e028b8:	e3a00029 	mov	r0, #41	; 0x29
57e028bc:	e1a0a001 	mov	sl, r1
57e028c0:	e58d3008 	str	r3, [sp, #8]
57e028c4:	eb003026 	bl	57e0e964 <__show_boot_progress>
#if defined(CONFIG_FIT)
	const void *fit_hdr = NULL;
#endif

	bootstage_mark(BOOTSTAGE_ID_IDE_START);
	if (argc > 3) {
57e028c8:	e3550003 	cmp	r5, #3
57e028cc:	da000003 	ble	57e028e0 <common_diskboot+0x38>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e028d0:	e3e00029 	mvn	r0, #41	; 0x29
57e028d4:	eb003022 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_IDE_ADDR);
		return CMD_RET_USAGE;
57e028d8:	e3e06000 	mvn	r6, #0
57e028dc:	ea00007f 	b	57e02ae0 <common_diskboot+0x238>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e028e0:	e3a0002a 	mov	r0, #42	; 0x2a
57e028e4:	eb00301e 	bl	57e0e964 <__show_boot_progress>
	}
	bootstage_mark(BOOTSTAGE_ID_IDE_ADDR);

	if (argc > 1)
57e028e8:	e3550001 	cmp	r5, #1
	defined(CONFIG_USB_STORAGE)
int common_diskboot(cmd_tbl_t *cmdtp, const char *intf, int argc,
		    char *const argv[])
{
	int dev, part;
	ulong addr = CONFIG_SYS_LOAD_ADDR;
57e028ec:	d3a04205 	movle	r4, #1342177280	; 0x50000000
		bootstage_error(BOOTSTAGE_ID_IDE_ADDR);
		return CMD_RET_USAGE;
	}
	bootstage_mark(BOOTSTAGE_ID_IDE_ADDR);

	if (argc > 1)
57e028f0:	da000005 	ble	57e0290c <common_diskboot+0x64>
		addr = simple_strtoul(argv[1], NULL, 16);
57e028f4:	e59d3008 	ldr	r3, [sp, #8]
57e028f8:	e3a01000 	mov	r1, #0
57e028fc:	e5930004 	ldr	r0, [r3, #4]
57e02900:	e3a02010 	mov	r2, #16
57e02904:	eb0089e6 	bl	57e250a4 <simple_strtoul>
57e02908:	e1a04000 	mov	r4, r0
57e0290c:	e3a0002b 	mov	r0, #43	; 0x2b
57e02910:	eb003013 	bl	57e0e964 <__show_boot_progress>

	bootstage_mark(BOOTSTAGE_ID_IDE_BOOT_DEVICE);

	part = get_device_and_partition(intf, (argc == 3) ? argv[2] : NULL,
57e02914:	e3550003 	cmp	r5, #3
57e02918:	059d3008 	ldreq	r3, [sp, #8]
57e0291c:	e28d7014 	add	r7, sp, #20
57e02920:	05931008 	ldreq	r1, [r3, #8]
57e02924:	13a01000 	movne	r1, #0
57e02928:	e3a06001 	mov	r6, #1
57e0292c:	e1a0000a 	mov	r0, sl
57e02930:	e28d2064 	add	r2, sp, #100	; 0x64
57e02934:	e1a03007 	mov	r3, r7
57e02938:	e58d6000 	str	r6, [sp]
57e0293c:	eb004273 	bl	57e13310 <get_device_and_partition>
					&dev_desc, &info, 1);
	if (part < 0) {
57e02940:	e2509000 	subs	r9, r0, #0
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e02944:	b3e0002b 	mvnlt	r0, #43	; 0x2b
57e02948:	ba00001b 	blt	57e029bc <common_diskboot+0x114>
		bootstage_error(BOOTSTAGE_ID_IDE_TYPE);
		return 1;
	}

	dev = dev_desc->dev;
57e0294c:	e59d3064 	ldr	r3, [sp, #100]	; 0x64
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e02950:	e3a0002c 	mov	r0, #44	; 0x2c
57e02954:	e5935004 	ldr	r5, [r3, #4]
57e02958:	eb003001 	bl	57e0e964 <__show_boot_progress>
	bootstage_mark(BOOTSTAGE_ID_IDE_TYPE);

	printf("\nLoading from %s device %d, partition %d: "
57e0295c:	e287300c 	add	r3, r7, #12
57e02960:	e58d3000 	str	r3, [sp]
57e02964:	e287702c 	add	r7, r7, #44	; 0x2c
57e02968:	e1a0100a 	mov	r1, sl
57e0296c:	e1a02005 	mov	r2, r5
57e02970:	e1a03009 	mov	r3, r9
57e02974:	e59f0170 	ldr	r0, [pc, #368]	; 57e02aec <common_diskboot+0x244>
57e02978:	e58d7004 	str	r7, [sp, #4]
57e0297c:	eb001ab2 	bl	57e0944c <printf>
	       info.type);

	debug("First Block: %ld,  # of blocks: %ld, Block Size: %ld\n",
	      info.start, info.size, info.blksz);

	if (dev_desc->block_read(dev, info.start, 1, (ulong *) addr) != 1) {
57e02980:	e59d3064 	ldr	r3, [sp, #100]	; 0x64
57e02984:	e1a00005 	mov	r0, r5
57e02988:	e593c060 	ldr	ip, [r3, #96]	; 0x60
57e0298c:	e59d1014 	ldr	r1, [sp, #20]
57e02990:	e1a02006 	mov	r2, r6
57e02994:	e1a03004 	mov	r3, r4
57e02998:	e12fff3c 	blx	ip
57e0299c:	e3500001 	cmp	r0, #1
57e029a0:	e1a07000 	mov	r7, r0
57e029a4:	0a000006 	beq	57e029c4 <common_diskboot+0x11c>
		printf("** Read error on %d:%d\n", dev, part);
57e029a8:	e59f0140 	ldr	r0, [pc, #320]	; 57e02af0 <common_diskboot+0x248>
57e029ac:	e1a01005 	mov	r1, r5
57e029b0:	e1a02009 	mov	r2, r9
57e029b4:	eb001aa4 	bl	57e0944c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e029b8:	e3e0002f 	mvn	r0, #47	; 0x2f
57e029bc:	eb002fe8 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_IDE_PART_READ);
		return 1;
57e029c0:	ea000046 	b	57e02ae0 <common_diskboot+0x238>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e029c4:	e3a00030 	mov	r0, #48	; 0x30
57e029c8:	eb002fe5 	bl	57e0e964 <__show_boot_progress>
	}
	bootstage_mark(BOOTSTAGE_ID_IDE_PART_READ);

	switch (genimg_get_format((void *) addr)) {
57e029cc:	e1a00004 	mov	r0, r4
57e029d0:	eb002e7f 	bl	57e0e3d4 <genimg_get_format>
57e029d4:	e3500001 	cmp	r0, #1
57e029d8:	e1a06000 	mov	r6, r0
57e029dc:	1a000026 	bne	57e02a7c <common_diskboot+0x1d4>
57e029e0:	e3a00031 	mov	r0, #49	; 0x31
57e029e4:	eb002fde 	bl	57e0e964 <__show_boot_progress>
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *) addr;

		bootstage_mark(BOOTSTAGE_ID_IDE_FORMAT);

		if (!image_check_hcrc(hdr)) {
57e029e8:	e1a00004 	mov	r0, r4
57e029ec:	eb002d1f 	bl	57e0de70 <image_check_hcrc>
57e029f0:	e3500000 	cmp	r0, #0
57e029f4:	1a000003 	bne	57e02a08 <common_diskboot+0x160>
			puts("\n** Bad Header Checksum **\n");
57e029f8:	e59f00f4 	ldr	r0, [pc, #244]	; 57e02af4 <common_diskboot+0x24c>
57e029fc:	eb001a88 	bl	57e09424 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e02a00:	e3e00031 	mvn	r0, #49	; 0x31
57e02a04:	eaffffec 	b	57e029bc <common_diskboot+0x114>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e02a08:	e3a00032 	mov	r0, #50	; 0x32
57e02a0c:	eb002fd4 	bl	57e0e964 <__show_boot_progress>
			bootstage_error(BOOTSTAGE_ID_IDE_CHECKSUM);
			return 1;
		}
		bootstage_mark(BOOTSTAGE_ID_IDE_CHECKSUM);

		image_print_contents(hdr);
57e02a10:	e1a00004 	mov	r0, r4
57e02a14:	eb002dd8 	bl	57e0e17c <image_print_contents>

	/* Loading ok, update default load address */
	load_addr = addr;

	return bootm_maybe_autostart(cmdtp, argv[0]);
}
57e02a18:	e594300c 	ldr	r3, [r4, #12]
		bootstage_error(BOOTSTAGE_ID_IDE_FORMAT);
		puts("** Unknown image type\n");
		return 1;
	}

	cnt += info.blksz - 1;
57e02a1c:	e59da01c 	ldr	sl, [sp, #28]
57e02a20:	e1a02c03 	lsl	r2, r3, #24
57e02a24:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e02a28:	e1822c23 	orr	r2, r2, r3, lsr #24
57e02a2c:	e1822401 	orr	r2, r2, r1, lsl #8
57e02a30:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e02a34:	e1823423 	orr	r3, r2, r3, lsr #8
57e02a38:	e28a003f 	add	r0, sl, #63	; 0x3f
	cnt /= info.blksz;
57e02a3c:	e0800003 	add	r0, r0, r3
57e02a40:	e1a0100a 	mov	r1, sl
57e02a44:	eb00a359 	bl	57e2b7b0 <__udivsi3>
	cnt -= 1;

	if (dev_desc->block_read(dev, info.start + 1, cnt,
57e02a48:	e59d3064 	ldr	r3, [sp, #100]	; 0x64
57e02a4c:	e59d1014 	ldr	r1, [sp, #20]
		return 1;
	}

	cnt += info.blksz - 1;
	cnt /= info.blksz;
	cnt -= 1;
57e02a50:	e2407001 	sub	r7, r0, #1

	if (dev_desc->block_read(dev, info.start + 1, cnt,
57e02a54:	e593c060 	ldr	ip, [r3, #96]	; 0x60
		puts("** Unknown image type\n");
		return 1;
	}

	cnt += info.blksz - 1;
	cnt /= info.blksz;
57e02a58:	e1a0b000 	mov	fp, r0
	cnt -= 1;

	if (dev_desc->block_read(dev, info.start + 1, cnt,
57e02a5c:	e2811001 	add	r1, r1, #1
57e02a60:	e1a00005 	mov	r0, r5
57e02a64:	e1a02007 	mov	r2, r7
57e02a68:	e084300a 	add	r3, r4, sl
57e02a6c:	e12fff3c 	blx	ip
57e02a70:	e1500007 	cmp	r0, r7
57e02a74:	1a000006 	bne	57e02a94 <common_diskboot+0x1ec>
57e02a78:	ea00000b 	b	57e02aac <common_diskboot+0x204>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e02a7c:	e3e00030 	mvn	r0, #48	; 0x30
57e02a80:	eb002fb7 	bl	57e0e964 <__show_boot_progress>
		cnt = fit_get_size(fit_hdr);
		break;
#endif
	default:
		bootstage_error(BOOTSTAGE_ID_IDE_FORMAT);
		puts("** Unknown image type\n");
57e02a84:	e59f006c 	ldr	r0, [pc, #108]	; 57e02af8 <common_diskboot+0x250>
57e02a88:	eb001a65 	bl	57e09424 <puts>
		return 1;
57e02a8c:	e1a06007 	mov	r6, r7
57e02a90:	ea000012 	b	57e02ae0 <common_diskboot+0x238>
	cnt /= info.blksz;
	cnt -= 1;

	if (dev_desc->block_read(dev, info.start + 1, cnt,
					 (ulong *)(addr + info.blksz)) != cnt) {
		printf("** Read error on %d:%d\n", dev, part);
57e02a94:	e59f0054 	ldr	r0, [pc, #84]	; 57e02af0 <common_diskboot+0x248>
57e02a98:	e1a01005 	mov	r1, r5
57e02a9c:	e1a02009 	mov	r2, r9
57e02aa0:	eb001a69 	bl	57e0944c <printf>
57e02aa4:	e3e00032 	mvn	r0, #50	; 0x32
57e02aa8:	eaffffc3 	b	57e029bc <common_diskboot+0x114>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e02aac:	e3a00033 	mov	r0, #51	; 0x33
57e02ab0:	eb002fab 	bl	57e0e964 <__show_boot_progress>
		bootstage_mark(BOOTSTAGE_ID_IDE_FIT_READ_OK);
		fit_print_contents(fit_hdr);
	}
#endif

	flush_cache(addr, (cnt+1)*info.blksz);
57e02ab4:	e59d101c 	ldr	r1, [sp, #28]
57e02ab8:	e1a00004 	mov	r0, r4
57e02abc:	e001019b 	mul	r1, fp, r1
57e02ac0:	ebfffa38 	bl	57e013a8 <__flush_cache>

	/* Loading ok, update default load address */
	load_addr = addr;
57e02ac4:	e59f3030 	ldr	r3, [pc, #48]	; 57e02afc <common_diskboot+0x254>

	return bootm_maybe_autostart(cmdtp, argv[0]);
57e02ac8:	e59d000c 	ldr	r0, [sp, #12]
#endif

	flush_cache(addr, (cnt+1)*info.blksz);

	/* Loading ok, update default load address */
	load_addr = addr;
57e02acc:	e5834000 	str	r4, [r3]

	return bootm_maybe_autostart(cmdtp, argv[0]);
57e02ad0:	e59d3008 	ldr	r3, [sp, #8]
57e02ad4:	e5931000 	ldr	r1, [r3]
57e02ad8:	ebfffec2 	bl	57e025e8 <bootm_maybe_autostart>
57e02adc:	e1a06000 	mov	r6, r0
}
57e02ae0:	e1a00006 	mov	r0, r6
57e02ae4:	e28dd068 	add	sp, sp, #104	; 0x68
57e02ae8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e02aec:	57e2ee50 	.word	0x57e2ee50
57e02af0:	57e2ee94 	.word	0x57e2ee94
57e02af4:	57e2eeac 	.word	0x57e2eeac
57e02af8:	57e2eec8 	.word	0x57e2eec8
57e02afc:	57e36e60 	.word	0x57e36e60

57e02b00 <do_echo>:

#include <common.h>
#include <command.h>

static int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e02b00:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i;
	int putnl = 1;
57e02b04:	e3a07001 	mov	r7, #1

#include <common.h>
#include <command.h>

static int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e02b08:	e1a04002 	mov	r4, r2
57e02b0c:	e1a0a003 	mov	sl, r3
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
57e02b10:	e1a06007 	mov	r6, r7
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
57e02b14:	e3a0b000 	mov	fp, #0
				puts(prenls);
				*nls = '\\';
57e02b18:	e3a0905c 	mov	r9, #92	; 0x5c
static int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
57e02b1c:	ea00001e 	b	57e02b9c <do_echo+0x9c>
		char *p = argv[i];
		char *nls; /* new-line suppression */

		if (i > 1)
57e02b20:	e3560001 	cmp	r6, #1
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
		char *p = argv[i];
57e02b24:	e5ba5004 	ldr	r5, [sl, #4]!
		char *nls; /* new-line suppression */

		if (i > 1)
57e02b28:	da000001 	ble	57e02b34 <do_echo+0x34>
			putc(' ');
57e02b2c:	e3a00020 	mov	r0, #32
57e02b30:	eb001a31 	bl	57e093fc <putc>

		nls = strstr(p, "\\c");
57e02b34:	e1a00005 	mov	r0, r5
57e02b38:	e59f107c 	ldr	r1, [pc, #124]	; 57e02bbc <do_echo+0xbc>
57e02b3c:	eb00863d 	bl	57e24438 <strstr>
		if (nls) {
57e02b40:	e2503000 	subs	r3, r0, #0
57e02b44:	0a000011 	beq	57e02b90 <do_echo+0x90>
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
57e02b48:	e5c3b000 	strb	fp, [r3]
				puts(prenls);
57e02b4c:	e1a00005 	mov	r0, r5
57e02b50:	e58d3004 	str	r3, [sp, #4]
57e02b54:	eb001a32 	bl	57e09424 <puts>
				*nls = '\\';
57e02b58:	e59d3004 	ldr	r3, [sp, #4]
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
57e02b5c:	e59f1058 	ldr	r1, [pc, #88]	; 57e02bbc <do_echo+0xbc>
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
				puts(prenls);
				*nls = '\\';
57e02b60:	e1a05003 	mov	r5, r3
57e02b64:	e4c59002 	strb	r9, [r5], #2
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
57e02b68:	e1a00005 	mov	r0, r5
57e02b6c:	eb008631 	bl	57e24438 <strstr>
			putnl = 0;
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
57e02b70:	e2503000 	subs	r3, r0, #0
57e02b74:	1afffff3 	bne	57e02b48 <do_echo+0x48>
				puts(prenls);
				*nls = '\\';
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
57e02b78:	e1a00005 	mov	r0, r5
57e02b7c:	e58d3004 	str	r3, [sp, #4]
57e02b80:	eb001a27 	bl	57e09424 <puts>

		nls = strstr(p, "\\c");
		if (nls) {
			char *prenls = p;

			putnl = 0;
57e02b84:	e59d3004 	ldr	r3, [sp, #4]
57e02b88:	e1a07003 	mov	r7, r3
57e02b8c:	ea000001 	b	57e02b98 <do_echo+0x98>
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
		} else {
			puts(p);
57e02b90:	e1a00005 	mov	r0, r5
57e02b94:	eb001a22 	bl	57e09424 <puts>
static int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
57e02b98:	e2866001 	add	r6, r6, #1
57e02b9c:	e1560004 	cmp	r6, r4
57e02ba0:	baffffde 	blt	57e02b20 <do_echo+0x20>
		} else {
			puts(p);
		}
	}

	if (putnl)
57e02ba4:	e3570000 	cmp	r7, #0
57e02ba8:	0a000001 	beq	57e02bb4 <do_echo+0xb4>
		putc('\n');
57e02bac:	e3a0000a 	mov	r0, #10
57e02bb0:	eb001a11 	bl	57e093fc <putc>

	return 0;
}
57e02bb4:	e3a00000 	mov	r0, #0
57e02bb8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e02bbc:	57e2eedf 	.word	0x57e2eedf

57e02bc0 <load_elf_image_shdr>:

	return ehdr->e_entry;
}

static unsigned long load_elf_image_shdr(unsigned long addr)
{
57e02bc0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}

	if (shdr->sh_type == SHT_STRTAB)
		strtab = (unsigned char *) (addr + shdr->sh_offset);

	/* Load each appropriate section */
	for (i = 0; i < ehdr->e_shnum; ++i) {
57e02bc4:	e3a06000 	mov	r6, #0

	return ehdr->e_entry;
}

static unsigned long load_elf_image_shdr(unsigned long addr)
{
57e02bc8:	e1a05000 	mov	r5, r0

	if (shdr->sh_type == SHT_STRTAB)
		strtab = (unsigned char *) (addr + shdr->sh_offset);

	/* Load each appropriate section */
	for (i = 0; i < ehdr->e_shnum; ++i) {
57e02bcc:	e1a07006 	mov	r7, r6
57e02bd0:	ea000019 	b	57e02c3c <load_elf_image_shdr+0x7c>
		shdr = (Elf32_Shdr *) (addr + ehdr->e_shoff +
57e02bd4:	e5954020 	ldr	r4, [r5, #32]
57e02bd8:	e0854004 	add	r4, r5, r4
57e02bdc:	e0844006 	add	r4, r4, r6
				       (i * sizeof(Elf32_Shdr)));

		if (!(shdr->sh_flags & SHF_ALLOC)
57e02be0:	e5943008 	ldr	r3, [r4, #8]
57e02be4:	e3130002 	tst	r3, #2
57e02be8:	0a000011 	beq	57e02c34 <load_elf_image_shdr+0x74>
		   || shdr->sh_addr == 0 || shdr->sh_size == 0) {
57e02bec:	e594000c 	ldr	r0, [r4, #12]
57e02bf0:	e3500000 	cmp	r0, #0
57e02bf4:	0a00000e 	beq	57e02c34 <load_elf_image_shdr+0x74>
57e02bf8:	e5942014 	ldr	r2, [r4, #20]
57e02bfc:	e3520000 	cmp	r2, #0
57e02c00:	0a00000b 	beq	57e02c34 <load_elf_image_shdr+0x74>
				&strtab[shdr->sh_name],
				(unsigned long) shdr->sh_addr,
				(long) shdr->sh_size);
		}

		if (shdr->sh_type == SHT_NOBITS) {
57e02c04:	e5943004 	ldr	r3, [r4, #4]
57e02c08:	e3530008 	cmp	r3, #8
57e02c0c:	1a000002 	bne	57e02c1c <load_elf_image_shdr+0x5c>
			memset((void *)(uintptr_t) shdr->sh_addr, 0,
57e02c10:	e3a01000 	mov	r1, #0
57e02c14:	eb008598 	bl	57e2427c <memset>
57e02c18:	ea000002 	b	57e02c28 <load_elf_image_shdr+0x68>
				shdr->sh_size);
		} else {
			image = (unsigned char *) addr + shdr->sh_offset;
57e02c1c:	e5941010 	ldr	r1, [r4, #16]
			memcpy((void *)(uintptr_t) shdr->sh_addr,
57e02c20:	e0851001 	add	r1, r5, r1
57e02c24:	eb0085b8 	bl	57e2430c <memcpy>
				(const void *) image,
				shdr->sh_size);
		}
		flush_cache(shdr->sh_addr, shdr->sh_size);
57e02c28:	e594000c 	ldr	r0, [r4, #12]
57e02c2c:	e5941014 	ldr	r1, [r4, #20]
57e02c30:	ebfff9dc 	bl	57e013a8 <__flush_cache>

	if (shdr->sh_type == SHT_STRTAB)
		strtab = (unsigned char *) (addr + shdr->sh_offset);

	/* Load each appropriate section */
	for (i = 0; i < ehdr->e_shnum; ++i) {
57e02c34:	e2877001 	add	r7, r7, #1
57e02c38:	e2866028 	add	r6, r6, #40	; 0x28
57e02c3c:	e1d533b0 	ldrh	r3, [r5, #48]	; 0x30
57e02c40:	e1570003 	cmp	r7, r3
57e02c44:	baffffe2 	blt	57e02bd4 <load_elf_image_shdr+0x14>
		}
		flush_cache(shdr->sh_addr, shdr->sh_size);
	}

	return ehdr->e_entry;
}
57e02c48:	e5950018 	ldr	r0, [r5, #24]
57e02c4c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e02c50 <do_bootelf_exec>:

/* Allow ports to override the default behavior */
__attribute__((weak))
unsigned long do_bootelf_exec(ulong (*entry)(int, char * const[]),
			       int argc, char * const argv[])
{
57e02c50:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e02c54:	e1a04000 	mov	r4, r0
57e02c58:	e1a06001 	mov	r6, r1
57e02c5c:	e1a07002 	mov	r7, r2

	/*
	 * QNX images require the data cache is disabled.
	 * Data cache is already flushed, so just turn it off.
	 */
	int dcache = dcache_status();
57e02c60:	ebfffa40 	bl	57e01568 <dcache_status>
	if (dcache)
57e02c64:	e2505000 	subs	r5, r0, #0
57e02c68:	0a000000 	beq	57e02c70 <do_bootelf_exec+0x20>
		dcache_disable();
57e02c6c:	ebfffa3b 	bl	57e01560 <dcache_disable>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	ret = entry(argc, argv);
57e02c70:	e1a00006 	mov	r0, r6
57e02c74:	e1a01007 	mov	r1, r7
57e02c78:	e12fff34 	blx	r4

	if (dcache)
57e02c7c:	e3550000 	cmp	r5, #0

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	ret = entry(argc, argv);
57e02c80:	e1a04000 	mov	r4, r0

	if (dcache)
57e02c84:	0a000000 	beq	57e02c8c <do_bootelf_exec+0x3c>
		dcache_enable();
57e02c88:	ebfffa32 	bl	57e01558 <dcache_enable>

	return ret;
}
57e02c8c:	e1a00004 	mov	r0, r4
57e02c90:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e02c94 <valid_elf_image>:
 * Determine if a valid ELF image exists at the given memory location.
 * First looks at the ELF header magic field, the makes sure that it is
 * executable and makes sure that it is for a PowerPC.
 * ====================================================================== */
int valid_elf_image(unsigned long addr)
{
57e02c94:	e92d4008 	push	{r3, lr}

	/* -------------------------------------------------- */

	ehdr = (Elf32_Ehdr *) addr;

	if (!IS_ELF(*ehdr)) {
57e02c98:	e59f3034 	ldr	r3, [pc, #52]	; 57e02cd4 <valid_elf_image+0x40>
57e02c9c:	e5902000 	ldr	r2, [r0]
 * Determine if a valid ELF image exists at the given memory location.
 * First looks at the ELF header magic field, the makes sure that it is
 * executable and makes sure that it is for a PowerPC.
 * ====================================================================== */
int valid_elf_image(unsigned long addr)
{
57e02ca0:	e1a01000 	mov	r1, r0

	/* -------------------------------------------------- */

	ehdr = (Elf32_Ehdr *) addr;

	if (!IS_ELF(*ehdr)) {
57e02ca4:	e1520003 	cmp	r2, r3
		printf("## No elf image at address 0x%08lx\n", addr);
57e02ca8:	159f0028 	ldrne	r0, [pc, #40]	; 57e02cd8 <valid_elf_image+0x44>

	/* -------------------------------------------------- */

	ehdr = (Elf32_Ehdr *) addr;

	if (!IS_ELF(*ehdr)) {
57e02cac:	1a000003 	bne	57e02cc0 <valid_elf_image+0x2c>
		printf("## No elf image at address 0x%08lx\n", addr);
		return 0;
	}

	if (ehdr->e_type != ET_EXEC) {
57e02cb0:	e1d131b0 	ldrh	r3, [r1, #16]
57e02cb4:	e3530002 	cmp	r3, #2
57e02cb8:	0a000003 	beq	57e02ccc <valid_elf_image+0x38>
		printf("## Not a 32-bit elf image at address 0x%08lx\n", addr);
57e02cbc:	e59f0018 	ldr	r0, [pc, #24]	; 57e02cdc <valid_elf_image+0x48>
57e02cc0:	eb0019e1 	bl	57e0944c <printf>
		return 0;
57e02cc4:	e3a00000 	mov	r0, #0
57e02cc8:	e8bd8008 	pop	{r3, pc}
		printf("## Not a PowerPC elf image at address 0x%08lx\n", addr);
		return 0;
	}
#endif

	return 1;
57e02ccc:	e3a00001 	mov	r0, #1
}
57e02cd0:	e8bd8008 	pop	{r3, pc}
57e02cd4:	464c457f 	.word	0x464c457f
57e02cd8:	57e2ef32 	.word	0x57e2ef32
57e02cdc:	57e2ef56 	.word	0x57e2ef56

57e02ce0 <do_bootvx>:
 * Interpreter command to boot VxWorks from a memory image.  The image can
 * be either an ELF image or a raw binary.  Will attempt to setup the
 * bootline and other parameters correctly.
 * ====================================================================== */
int do_bootvx(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e02ce0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	 *
	 * Check the loadaddr variable.
	 * If we don't know where the image is then we're done.
	 */

	if (argc < 2)
57e02ce4:	e3520001 	cmp	r2, #1
 * Interpreter command to boot VxWorks from a memory image.  The image can
 * be either an ELF image or a raw binary.  Will attempt to setup the
 * bootline and other parameters correctly.
 * ====================================================================== */
int do_bootvx(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e02ce8:	e1a06003 	mov	r6, r3
	 * Check the loadaddr variable.
	 * If we don't know where the image is then we're done.
	 */

	if (argc < 2)
		addr = load_addr;
57e02cec:	d59f3234 	ldrle	r3, [pc, #564]	; 57e02f28 <do_bootvx+0x248>
 * Interpreter command to boot VxWorks from a memory image.  The image can
 * be either an ELF image or a raw binary.  Will attempt to setup the
 * bootline and other parameters correctly.
 * ====================================================================== */
int do_bootvx(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e02cf0:	e24dd084 	sub	sp, sp, #132	; 0x84
57e02cf4:	e1a05002 	mov	r5, r2
	 * Check the loadaddr variable.
	 * If we don't know where the image is then we're done.
	 */

	if (argc < 2)
		addr = load_addr;
57e02cf8:	d5934000 	ldrle	r4, [r3]
	 *
	 * Check the loadaddr variable.
	 * If we don't know where the image is then we're done.
	 */

	if (argc < 2)
57e02cfc:	da000012 	ble	57e02d4c <do_bootvx+0x6c>
		addr = load_addr;
	else
		addr = simple_strtoul(argv[1], NULL, 16);
57e02d00:	e5960004 	ldr	r0, [r6, #4]
57e02d04:	e3a01000 	mov	r1, #0
57e02d08:	e3a02010 	mov	r2, #16
57e02d0c:	eb0088e4 	bl	57e250a4 <simple_strtoul>

#if defined(CONFIG_CMD_NET)
	/*
	 * Check to see if we need to tftp the image ourselves before starting
	 */
	if ((argc == 2) && (strcmp(argv[1], "tftp") == 0)) {
57e02d10:	e3550002 	cmp	r5, #2
	 */

	if (argc < 2)
		addr = load_addr;
	else
		addr = simple_strtoul(argv[1], NULL, 16);
57e02d14:	e1a04000 	mov	r4, r0

#if defined(CONFIG_CMD_NET)
	/*
	 * Check to see if we need to tftp the image ourselves before starting
	 */
	if ((argc == 2) && (strcmp(argv[1], "tftp") == 0)) {
57e02d18:	1a00000b 	bne	57e02d4c <do_bootvx+0x6c>
57e02d1c:	e5960004 	ldr	r0, [r6, #4]
57e02d20:	e59f1204 	ldr	r1, [pc, #516]	; 57e02f2c <do_bootvx+0x24c>
57e02d24:	eb00849e 	bl	57e23fa4 <strcmp>
57e02d28:	e3500000 	cmp	r0, #0
57e02d2c:	1a000006 	bne	57e02d4c <do_bootvx+0x6c>
		if (NetLoop(TFTPGET) <= 0)
57e02d30:	e2800003 	add	r0, r0, #3
57e02d34:	eb009b34 	bl	57e29a0c <NetLoop>
57e02d38:	e3500000 	cmp	r0, #0
57e02d3c:	da000076 	ble	57e02f1c <do_bootvx+0x23c>
			return 1;
		printf("Automatic boot of VxWorks image at address 0x%08lx ...\n",
57e02d40:	e59f01e8 	ldr	r0, [pc, #488]	; 57e02f30 <do_bootvx+0x250>
57e02d44:	e1a01004 	mov	r1, r4
57e02d48:	eb0019bf 	bl	57e0944c <printf>
#elif defined(CONFIG_SYS_VXWORKS_MAC_PTR)
	tmp = (char *) CONFIG_SYS_VXWORKS_MAC_PTR;
	eth_getenv_enetaddr("ethaddr", (uchar *)build_buf);
	memcpy(tmp, build_buf, 6);
#else
	puts("## Ethernet MAC address not copied to NV RAM\n");
57e02d4c:	e59f01e0 	ldr	r0, [pc, #480]	; 57e02f34 <do_bootvx+0x254>
57e02d50:	eb0019b3 	bl	57e09424 <puts>
	 * Use bootaddr to find the location in memory that VxWorks
	 * will look for the bootline string. The default value for
	 * PowerPC is LOCAL_MEM_LOCAL_ADRS + BOOT_LINE_OFFSET which
	 * defaults to 0x4200
	 */
	tmp = getenv("bootaddr");
57e02d54:	e59f01dc 	ldr	r0, [pc, #476]	; 57e02f38 <do_bootvx+0x258>
57e02d58:	eb001262 	bl	57e076e8 <getenv>
	if (tmp)
57e02d5c:	e2501000 	subs	r1, r0, #0
		bootaddr = CONFIG_SYS_VXWORKS_BOOT_ADDR;
57e02d60:	13a05c42 	movne	r5, #16896	; 0x4200
	 * will look for the bootline string. The default value for
	 * PowerPC is LOCAL_MEM_LOCAL_ADRS + BOOT_LINE_OFFSET which
	 * defaults to 0x4200
	 */
	tmp = getenv("bootaddr");
	if (tmp)
57e02d64:	1a000002 	bne	57e02d74 <do_bootvx+0x94>
		bootaddr = CONFIG_SYS_VXWORKS_BOOT_ADDR;
	else
		bootaddr = simple_strtoul(tmp, NULL, 16);
57e02d68:	e3a02010 	mov	r2, #16
57e02d6c:	eb0088cc 	bl	57e250a4 <simple_strtoul>
57e02d70:	e1a05000 	mov	r5, r0
	/*
	 * Check to see if the bootline is defined in the 'bootargs'
	 * parameter. If it is not defined, we may be able to
	 * construct the info
	 */
	bootline = getenv("bootargs");
57e02d74:	e59f01c0 	ldr	r0, [pc, #448]	; 57e02f3c <do_bootvx+0x25c>
57e02d78:	eb00125a 	bl	57e076e8 <getenv>
	if (bootline) {
57e02d7c:	e2506000 	subs	r6, r0, #0
57e02d80:	0a000008 	beq	57e02da8 <do_bootvx+0xc8>
		memcpy((void *) bootaddr, bootline,
			max(strlen(bootline), 255));
57e02d84:	eb0084b1 	bl	57e24050 <strlen>
	 * parameter. If it is not defined, we may be able to
	 * construct the info
	 */
	bootline = getenv("bootargs");
	if (bootline) {
		memcpy((void *) bootaddr, bootline,
57e02d88:	e1a01006 	mov	r1, r6
			max(strlen(bootline), 255));
57e02d8c:	e35000ff 	cmp	r0, #255	; 0xff
57e02d90:	21a02000 	movcs	r2, r0
57e02d94:	33a020ff 	movcc	r2, #255	; 0xff
	 * parameter. If it is not defined, we may be able to
	 * construct the info
	 */
	bootline = getenv("bootargs");
	if (bootline) {
		memcpy((void *) bootaddr, bootline,
57e02d98:	e1a00005 	mov	r0, r5
57e02d9c:	eb00855a 	bl	57e2430c <memcpy>
			max(strlen(bootline), 255));
		flush_cache(bootaddr, max(strlen(bootline), 255));
57e02da0:	e1a00006 	mov	r0, r6
57e02da4:	ea000040 	b	57e02eac <do_bootvx+0x1cc>
	} else {
		sprintf(build_buf, CONFIG_SYS_VXWORKS_BOOT_DEVICE);
57e02da8:	e59f1190 	ldr	r1, [pc, #400]	; 57e02f40 <do_bootvx+0x260>
57e02dac:	e1a0000d 	mov	r0, sp
57e02db0:	eb008964 	bl	57e25348 <sprintf>
		tmp = getenv("bootfile");
57e02db4:	e59f0188 	ldr	r0, [pc, #392]	; 57e02f44 <do_bootvx+0x264>
57e02db8:	eb00124a 	bl	57e076e8 <getenv>
		if (tmp)
57e02dbc:	e2506000 	subs	r6, r0, #0
	if (bootline) {
		memcpy((void *) bootaddr, bootline,
			max(strlen(bootline), 255));
		flush_cache(bootaddr, max(strlen(bootline), 255));
	} else {
		sprintf(build_buf, CONFIG_SYS_VXWORKS_BOOT_DEVICE);
57e02dc0:	e1a0700d 	mov	r7, sp
		tmp = getenv("bootfile");
		if (tmp)
57e02dc4:	0a000007 	beq	57e02de8 <do_bootvx+0x108>
			sprintf(&build_buf[strlen(build_buf)],
57e02dc8:	e1a0000d 	mov	r0, sp
57e02dcc:	eb00849f 	bl	57e24050 <strlen>
57e02dd0:	e59f1170 	ldr	r1, [pc, #368]	; 57e02f48 <do_bootvx+0x268>
57e02dd4:	e08d0000 	add	r0, sp, r0
57e02dd8:	e59f216c 	ldr	r2, [pc, #364]	; 57e02f4c <do_bootvx+0x26c>
57e02ddc:	e1a03006 	mov	r3, r6
57e02de0:	eb008958 	bl	57e25348 <sprintf>
57e02de4:	ea000005 	b	57e02e00 <do_bootvx+0x120>
				 "%s:%s ", CONFIG_SYS_VXWORKS_SERVERNAME, tmp);
		else
			sprintf(&build_buf[strlen(build_buf)],
57e02de8:	e1a0000d 	mov	r0, sp
57e02dec:	eb008497 	bl	57e24050 <strlen>
57e02df0:	e59f1158 	ldr	r1, [pc, #344]	; 57e02f50 <do_bootvx+0x270>
57e02df4:	e08d0000 	add	r0, sp, r0
57e02df8:	e59f214c 	ldr	r2, [pc, #332]	; 57e02f4c <do_bootvx+0x26c>
57e02dfc:	eb008951 	bl	57e25348 <sprintf>
				 "%s:file ", CONFIG_SYS_VXWORKS_SERVERNAME);

		tmp = getenv("ipaddr");
57e02e00:	e59f014c 	ldr	r0, [pc, #332]	; 57e02f54 <do_bootvx+0x274>
57e02e04:	eb001237 	bl	57e076e8 <getenv>
		if (tmp)
57e02e08:	e2506000 	subs	r6, r0, #0
57e02e0c:	0a000006 	beq	57e02e2c <do_bootvx+0x14c>
			sprintf(&build_buf[strlen(build_buf)], "e=%s ", tmp);
57e02e10:	e1a0000d 	mov	r0, sp
57e02e14:	eb00848d 	bl	57e24050 <strlen>
57e02e18:	e59f1138 	ldr	r1, [pc, #312]	; 57e02f58 <do_bootvx+0x278>
57e02e1c:	e08d0000 	add	r0, sp, r0
57e02e20:	e1a02006 	mov	r2, r6
57e02e24:	e1a0700d 	mov	r7, sp
57e02e28:	eb008946 	bl	57e25348 <sprintf>

		tmp = getenv("serverip");
57e02e2c:	e59f0128 	ldr	r0, [pc, #296]	; 57e02f5c <do_bootvx+0x27c>
57e02e30:	eb00122c 	bl	57e076e8 <getenv>
		if (tmp)
57e02e34:	e2506000 	subs	r6, r0, #0
57e02e38:	0a000006 	beq	57e02e58 <do_bootvx+0x178>
			sprintf(&build_buf[strlen(build_buf)], "h=%s ", tmp);
57e02e3c:	e1a0000d 	mov	r0, sp
57e02e40:	eb008482 	bl	57e24050 <strlen>
57e02e44:	e59f1114 	ldr	r1, [pc, #276]	; 57e02f60 <do_bootvx+0x280>
57e02e48:	e08d0000 	add	r0, sp, r0
57e02e4c:	e1a02006 	mov	r2, r6
57e02e50:	e1a0700d 	mov	r7, sp
57e02e54:	eb00893b 	bl	57e25348 <sprintf>

		tmp = getenv("hostname");
57e02e58:	e59f0104 	ldr	r0, [pc, #260]	; 57e02f64 <do_bootvx+0x284>
57e02e5c:	eb001221 	bl	57e076e8 <getenv>
		if (tmp)
57e02e60:	e2506000 	subs	r6, r0, #0
57e02e64:	0a000006 	beq	57e02e84 <do_bootvx+0x1a4>
			sprintf(&build_buf[strlen(build_buf)], "tn=%s ", tmp);
57e02e68:	e1a0000d 	mov	r0, sp
57e02e6c:	eb008477 	bl	57e24050 <strlen>
57e02e70:	e59f10f0 	ldr	r1, [pc, #240]	; 57e02f68 <do_bootvx+0x288>
57e02e74:	e08d0000 	add	r0, sp, r0
57e02e78:	e1a02006 	mov	r2, r6
57e02e7c:	e1a0700d 	mov	r7, sp
57e02e80:	eb008930 	bl	57e25348 <sprintf>
		sprintf(&build_buf[strlen(build_buf)],
			 CONFIG_SYS_VXWORKS_ADD_PARAMS);
#endif

		memcpy((void *) bootaddr, build_buf,
			max(strlen(build_buf), 255));
57e02e84:	e1a0000d 	mov	r0, sp
57e02e88:	eb008470 	bl	57e24050 <strlen>
#ifdef CONFIG_SYS_VXWORKS_ADD_PARAMS
		sprintf(&build_buf[strlen(build_buf)],
			 CONFIG_SYS_VXWORKS_ADD_PARAMS);
#endif

		memcpy((void *) bootaddr, build_buf,
57e02e8c:	e1a0100d 	mov	r1, sp
			max(strlen(build_buf), 255));
57e02e90:	e35000ff 	cmp	r0, #255	; 0xff
57e02e94:	21a02000 	movcs	r2, r0
57e02e98:	33a020ff 	movcc	r2, #255	; 0xff
#ifdef CONFIG_SYS_VXWORKS_ADD_PARAMS
		sprintf(&build_buf[strlen(build_buf)],
			 CONFIG_SYS_VXWORKS_ADD_PARAMS);
#endif

		memcpy((void *) bootaddr, build_buf,
57e02e9c:	e1a00005 	mov	r0, r5
57e02ea0:	eb008519 	bl	57e2430c <memcpy>
			max(strlen(build_buf), 255));
57e02ea4:	e1a0600d 	mov	r6, sp
		flush_cache(bootaddr, max(strlen(build_buf), 255));
57e02ea8:	e1a0000d 	mov	r0, sp
57e02eac:	eb008467 	bl	57e24050 <strlen>
57e02eb0:	e35000ff 	cmp	r0, #255	; 0xff
57e02eb4:	21a01000 	movcs	r1, r0
57e02eb8:	33a010ff 	movcc	r1, #255	; 0xff
57e02ebc:	e1a00005 	mov	r0, r5
57e02ec0:	ebfff938 	bl	57e013a8 <__flush_cache>
	 * If the data at the load address is an elf image, then
	 * treat it like an elf image. Otherwise, assume that it is a
	 * binary image
	 */

	if (valid_elf_image(addr)) {
57e02ec4:	e1a00004 	mov	r0, r4
57e02ec8:	ebffff71 	bl	57e02c94 <valid_elf_image>
57e02ecc:	e3500000 	cmp	r0, #0
57e02ed0:	0a000003 	beq	57e02ee4 <do_bootvx+0x204>
		addr = load_elf_image_shdr(addr);
57e02ed4:	e1a00004 	mov	r0, r4
57e02ed8:	ebffff38 	bl	57e02bc0 <load_elf_image_shdr>
57e02edc:	e1a04000 	mov	r4, r0
57e02ee0:	ea000001 	b	57e02eec <do_bootvx+0x20c>
	} else {
		puts("## Not an ELF image, assuming binary\n");
57e02ee4:	e59f0080 	ldr	r0, [pc, #128]	; 57e02f6c <do_bootvx+0x28c>
57e02ee8:	eb00194d 	bl	57e09424 <puts>
		/* leave addr as load_addr */
	}

	printf("## Using bootline (@ 0x%lx): %s\n", bootaddr,
57e02eec:	e1a02005 	mov	r2, r5
57e02ef0:	e1a01005 	mov	r1, r5
57e02ef4:	e59f0074 	ldr	r0, [pc, #116]	; 57e02f70 <do_bootvx+0x290>
57e02ef8:	eb001953 	bl	57e0944c <printf>
			(char *) bootaddr);
	printf("## Starting vxWorks at 0x%08lx ...\n", addr);
57e02efc:	e1a01004 	mov	r1, r4
57e02f00:	e59f006c 	ldr	r0, [pc, #108]	; 57e02f74 <do_bootvx+0x294>
57e02f04:	eb001950 	bl	57e0944c <printf>

	dcache_disable();
57e02f08:	ebfff994 	bl	57e01560 <dcache_disable>
	((void (*)(int)) addr) (0);
57e02f0c:	e3a00000 	mov	r0, #0
57e02f10:	e12fff34 	blx	r4

	puts("## vxWorks terminated\n");
57e02f14:	e59f005c 	ldr	r0, [pc, #92]	; 57e02f78 <do_bootvx+0x298>
57e02f18:	eb001941 	bl	57e09424 <puts>
	return 1;
}
57e02f1c:	e3a00001 	mov	r0, #1
57e02f20:	e28dd084 	add	sp, sp, #132	; 0x84
57e02f24:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
57e02f28:	57e36e60 	.word	0x57e36e60
57e02f2c:	57e2ef84 	.word	0x57e2ef84
57e02f30:	57e2ef89 	.word	0x57e2ef89
57e02f34:	57e2efc1 	.word	0x57e2efc1
57e02f38:	57e2efef 	.word	0x57e2efef
57e02f3c:	57e2e111 	.word	0x57e2e111
57e02f40:	57e2eff8 	.word	0x57e2eff8
57e02f44:	57e2f001 	.word	0x57e2f001
57e02f48:	57e2f00a 	.word	0x57e2f00a
57e02f4c:	57e2f011 	.word	0x57e2f011
57e02f50:	57e2f015 	.word	0x57e2f015
57e02f54:	57e2e444 	.word	0x57e2e444
57e02f58:	57e2f01e 	.word	0x57e2f01e
57e02f5c:	57e2f024 	.word	0x57e2f024
57e02f60:	57e2f02d 	.word	0x57e2f02d
57e02f64:	57e2f033 	.word	0x57e2f033
57e02f68:	57e2f03c 	.word	0x57e2f03c
57e02f6c:	57e2f043 	.word	0x57e2f043
57e02f70:	57e2f069 	.word	0x57e2f069
57e02f74:	57e2f08a 	.word	0x57e2f08a
57e02f78:	57e2f0ae 	.word	0x57e2f0ae

57e02f7c <do_bootelf>:

	/* -------------------------------------------------- */
	int rcode = 0;

	sload = saddr = NULL;
	if (argc == 3) {
57e02f7c:	e3520003 	cmp	r2, #3

/* ======================================================================
 * Interpreter command to boot an arbitrary ELF image from memory.
 * ====================================================================== */
int do_bootelf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e02f80:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	int rcode = 0;

	sload = saddr = NULL;
	if (argc == 3) {
		sload = argv[1];
		saddr = argv[2];
57e02f84:	05930008 	ldreq	r0, [r3, #8]

/* ======================================================================
 * Interpreter command to boot an arbitrary ELF image from memory.
 * ====================================================================== */
int do_bootelf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e02f88:	e1a09002 	mov	r9, r2
57e02f8c:	e1a06003 	mov	r6, r3
	/* -------------------------------------------------- */
	int rcode = 0;

	sload = saddr = NULL;
	if (argc == 3) {
		sload = argv[1];
57e02f90:	05935004 	ldreq	r5, [r3, #4]

	/* -------------------------------------------------- */
	int rcode = 0;

	sload = saddr = NULL;
	if (argc == 3) {
57e02f94:	0a000008 	beq	57e02fbc <do_bootelf+0x40>
		sload = argv[1];
		saddr = argv[2];
	} else if (argc == 2) {
57e02f98:	e3520002 	cmp	r2, #2
	char *sload, *saddr;

	/* -------------------------------------------------- */
	int rcode = 0;

	sload = saddr = NULL;
57e02f9c:	13a05000 	movne	r5, #0
	if (argc == 3) {
		sload = argv[1];
		saddr = argv[2];
	} else if (argc == 2) {
57e02fa0:	1a00000c 	bne	57e02fd8 <do_bootelf+0x5c>
		if (argv[1][0] == '-')
57e02fa4:	e5935004 	ldr	r5, [r3, #4]
57e02fa8:	e5d53000 	ldrb	r3, [r5]
57e02fac:	e353002d 	cmp	r3, #45	; 0x2d
57e02fb0:	0a000008 	beq	57e02fd8 <do_bootelf+0x5c>
57e02fb4:	e1a00005 	mov	r0, r5
	char *sload, *saddr;

	/* -------------------------------------------------- */
	int rcode = 0;

	sload = saddr = NULL;
57e02fb8:	e3a05000 	mov	r5, #0
			sload = argv[1];
		else
			saddr = argv[1];
	}

	if (saddr)
57e02fbc:	e3500000 	cmp	r0, #0
57e02fc0:	0a000004 	beq	57e02fd8 <do_bootelf+0x5c>
		addr = simple_strtoul(saddr, NULL, 16);
57e02fc4:	e3a01000 	mov	r1, #0
57e02fc8:	e3a02010 	mov	r2, #16
57e02fcc:	eb008834 	bl	57e250a4 <simple_strtoul>
57e02fd0:	e1a04000 	mov	r4, r0
57e02fd4:	ea000001 	b	57e02fe0 <do_bootelf+0x64>
	else
		addr = load_addr;
57e02fd8:	e59f30e4 	ldr	r3, [pc, #228]	; 57e030c4 <do_bootelf+0x148>
57e02fdc:	e5934000 	ldr	r4, [r3]

	if (!valid_elf_image(addr))
57e02fe0:	e1a00004 	mov	r0, r4
57e02fe4:	ebffff2a 	bl	57e02c94 <valid_elf_image>
57e02fe8:	e3500000 	cmp	r0, #0
		return 1;
57e02fec:	03a04001 	moveq	r4, #1
	if (saddr)
		addr = simple_strtoul(saddr, NULL, 16);
	else
		addr = load_addr;

	if (!valid_elf_image(addr))
57e02ff0:	0a000031 	beq	57e030bc <do_bootelf+0x140>
		return 1;

	if (sload && sload[1] == 'p')
57e02ff4:	e3550000 	cmp	r5, #0
57e02ff8:	0a000020 	beq	57e03080 <do_bootelf+0x104>
57e02ffc:	e5d53001 	ldrb	r3, [r5, #1]
57e03000:	e3530070 	cmp	r3, #112	; 0x70
	Elf32_Ehdr *ehdr;		/* Elf header structure pointer     */
	Elf32_Phdr *phdr;		/* Program header structure pointer */
	int i;

	ehdr = (Elf32_Ehdr *) addr;
	phdr = (Elf32_Phdr *) (addr + ehdr->e_phoff);
57e03004:	0594501c 	ldreq	r5, [r4, #28]

	/* Load each program header */
	for (i = 0; i < ehdr->e_phnum; ++i) {
57e03008:	03a07000 	moveq	r7, #0
	Elf32_Ehdr *ehdr;		/* Elf header structure pointer     */
	Elf32_Phdr *phdr;		/* Program header structure pointer */
	int i;

	ehdr = (Elf32_Ehdr *) addr;
	phdr = (Elf32_Phdr *) (addr + ehdr->e_phoff);
57e0300c:	00845005 	addeq	r5, r4, r5
		addr = load_addr;

	if (!valid_elf_image(addr))
		return 1;

	if (sload && sload[1] == 'p')
57e03010:	1a00001a 	bne	57e03080 <do_bootelf+0x104>
57e03014:	ea000014 	b	57e0306c <do_bootelf+0xf0>
	for (i = 0; i < ehdr->e_phnum; ++i) {
		void *dst = (void *)(uintptr_t) phdr->p_paddr;
		void *src = (void *) addr + phdr->p_offset;
		debug("Loading phdr %i to 0x%p (%i bytes)\n",
			i, dst, phdr->p_filesz);
		if (phdr->p_filesz)
57e03018:	e5952010 	ldr	r2, [r5, #16]
	ehdr = (Elf32_Ehdr *) addr;
	phdr = (Elf32_Phdr *) (addr + ehdr->e_phoff);

	/* Load each program header */
	for (i = 0; i < ehdr->e_phnum; ++i) {
		void *dst = (void *)(uintptr_t) phdr->p_paddr;
57e0301c:	e595a00c 	ldr	sl, [r5, #12]
		void *src = (void *) addr + phdr->p_offset;
		debug("Loading phdr %i to 0x%p (%i bytes)\n",
			i, dst, phdr->p_filesz);
		if (phdr->p_filesz)
57e03020:	e3520000 	cmp	r2, #0
	phdr = (Elf32_Phdr *) (addr + ehdr->e_phoff);

	/* Load each program header */
	for (i = 0; i < ehdr->e_phnum; ++i) {
		void *dst = (void *)(uintptr_t) phdr->p_paddr;
		void *src = (void *) addr + phdr->p_offset;
57e03024:	e5951004 	ldr	r1, [r5, #4]
		debug("Loading phdr %i to 0x%p (%i bytes)\n",
			i, dst, phdr->p_filesz);
		if (phdr->p_filesz)
57e03028:	0a000002 	beq	57e03038 <do_bootelf+0xbc>
			memcpy(dst, src, phdr->p_filesz);
57e0302c:	e1a0000a 	mov	r0, sl
57e03030:	e0841001 	add	r1, r4, r1
57e03034:	eb0084b4 	bl	57e2430c <memcpy>
		if (phdr->p_filesz != phdr->p_memsz)
57e03038:	e5953010 	ldr	r3, [r5, #16]
57e0303c:	e5952014 	ldr	r2, [r5, #20]
57e03040:	e1530002 	cmp	r3, r2
57e03044:	0a000003 	beq	57e03058 <do_bootelf+0xdc>
			memset(dst + phdr->p_filesz, 0x00,
57e03048:	e08a0003 	add	r0, sl, r3
57e0304c:	e3a01000 	mov	r1, #0
57e03050:	e0632002 	rsb	r2, r3, r2
57e03054:	eb008488 	bl	57e2427c <memset>
				phdr->p_memsz - phdr->p_filesz);
		flush_cache((unsigned long)dst, phdr->p_filesz);
57e03058:	e5951010 	ldr	r1, [r5, #16]
57e0305c:	e1a0000a 	mov	r0, sl
57e03060:	ebfff8d0 	bl	57e013a8 <__flush_cache>
		++phdr;
57e03064:	e2855020 	add	r5, r5, #32

	ehdr = (Elf32_Ehdr *) addr;
	phdr = (Elf32_Phdr *) (addr + ehdr->e_phoff);

	/* Load each program header */
	for (i = 0; i < ehdr->e_phnum; ++i) {
57e03068:	e2877001 	add	r7, r7, #1
57e0306c:	e1d432bc 	ldrh	r3, [r4, #44]	; 0x2c
57e03070:	e1570003 	cmp	r7, r3
57e03074:	baffffe7 	blt	57e03018 <do_bootelf+0x9c>
				phdr->p_memsz - phdr->p_filesz);
		flush_cache((unsigned long)dst, phdr->p_filesz);
		++phdr;
	}

	return ehdr->e_entry;
57e03078:	e5944018 	ldr	r4, [r4, #24]

	if (!valid_elf_image(addr))
		return 1;

	if (sload && sload[1] == 'p')
		addr = load_elf_image_phdr(addr);
57e0307c:	ea000002 	b	57e0308c <do_bootelf+0x110>
	else
		addr = load_elf_image_shdr(addr);
57e03080:	e1a00004 	mov	r0, r4
57e03084:	ebfffecd 	bl	57e02bc0 <load_elf_image_shdr>
57e03088:	e1a04000 	mov	r4, r0

	printf("## Starting application at 0x%08lx ...\n", addr);
57e0308c:	e1a01004 	mov	r1, r4
57e03090:	e59f0030 	ldr	r0, [pc, #48]	; 57e030c8 <do_bootelf+0x14c>
57e03094:	eb0018ec 	bl	57e0944c <printf>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	rc = do_bootelf_exec((void *)addr, argc - 1, argv + 1);
57e03098:	e1a00004 	mov	r0, r4
57e0309c:	e2491001 	sub	r1, r9, #1
57e030a0:	e2862004 	add	r2, r6, #4
57e030a4:	ebfffee9 	bl	57e02c50 <do_bootelf_exec>
	unsigned long addr;		/* Address of the ELF image     */
	unsigned long rc;		/* Return value from user code  */
	char *sload, *saddr;

	/* -------------------------------------------------- */
	int rcode = 0;
57e030a8:	e1a01000 	mov	r1, r0
57e030ac:	e2504000 	subs	r4, r0, #0
57e030b0:	13a04001 	movne	r4, #1
	 */
	rc = do_bootelf_exec((void *)addr, argc - 1, argv + 1);
	if (rc != 0)
		rcode = 1;

	printf("## Application terminated, rc = 0x%lx\n", rc);
57e030b4:	e59f0010 	ldr	r0, [pc, #16]	; 57e030cc <do_bootelf+0x150>
57e030b8:	eb0018e3 	bl	57e0944c <printf>
	return rcode;
}
57e030bc:	e1a00004 	mov	r0, r4
57e030c0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
57e030c4:	57e36e60 	.word	0x57e36e60
57e030c8:	57e2f0c5 	.word	0x57e2f0c5
57e030cc:	57e2f0ed 	.word	0x57e2f0ed

57e030d0 <do_exit>:
static int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int r;

	r = 0;
	if (argc > 1)
57e030d0:	e3520001 	cmp	r2, #1

#include <common.h>
#include <command.h>

static int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e030d4:	e92d4008 	push	{r3, lr}
	int r;

	r = 0;
57e030d8:	d3a03000 	movle	r3, #0
	if (argc > 1)
57e030dc:	da000004 	ble	57e030f4 <do_exit+0x24>
		r = simple_strtoul(argv[1], NULL, 10);
57e030e0:	e5930004 	ldr	r0, [r3, #4]
57e030e4:	e3a01000 	mov	r1, #0
57e030e8:	e3a0200a 	mov	r2, #10
57e030ec:	eb0087ec 	bl	57e250a4 <simple_strtoul>
57e030f0:	e1a03000 	mov	r3, r0

	return -r - 2;
}
57e030f4:	e3e00001 	mvn	r0, #1
57e030f8:	e0630000 	rsb	r0, r3, r0
57e030fc:	e8bd8008 	pop	{r3, pc}

57e03100 <do_ext2load>:

/******************************************************************************
 * Ext2fs boot command intepreter. Derived from diskboot
 */
int do_ext2load (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e03100:	e92d4007 	push	{r0, r1, r2, lr}
	return do_load(cmdtp, flag, argc, argv, FS_TYPE_EXT, 16);
57e03104:	e3a0c002 	mov	ip, #2
57e03108:	e58dc000 	str	ip, [sp]
57e0310c:	e28cc00e 	add	ip, ip, #14
57e03110:	e58dc004 	str	ip, [sp, #4]
57e03114:	eb007b5d 	bl	57e21e90 <do_load>
}
57e03118:	e8bd800e 	pop	{r1, r2, r3, pc}

57e0311c <do_ext2ls>:
 * Ext2fs support
 */
#include <fs.h>

int do_ext2ls (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e0311c:	e92d4007 	push	{r0, r1, r2, lr}
	return do_ls(cmdtp, flag, argc, argv, FS_TYPE_EXT);
57e03120:	e3a0c002 	mov	ip, #2
57e03124:	e58dc000 	str	ip, [sp]
57e03128:	eb007bd1 	bl	57e22074 <do_ls>
}
57e0312c:	e8bd800e 	pop	{r1, r2, r3, pc}

57e03130 <do_fat_fsinfo>:
	"    - list files from 'dev' on 'interface' in a 'directory'"
);

static int do_fat_fsinfo(cmd_tbl_t *cmdtp, int flag, int argc,
			 char * const argv[])
{
57e03130:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int dev, part;
	block_dev_desc_t *dev_desc;
	disk_partition_t info;

	if (argc < 2) {
57e03134:	e3520001 	cmp	r2, #1
	"    - list files from 'dev' on 'interface' in a 'directory'"
);

static int do_fat_fsinfo(cmd_tbl_t *cmdtp, int flag, int argc,
			 char * const argv[])
{
57e03138:	e24dd060 	sub	sp, sp, #96	; 0x60
57e0313c:	e1a05003 	mov	r5, r3
	int dev, part;
	block_dev_desc_t *dev_desc;
	disk_partition_t info;

	if (argc < 2) {
57e03140:	ca000003 	bgt	57e03154 <do_fat_fsinfo+0x24>
		printf("usage: fatinfo <interface> [<dev[:part]>]\n");
57e03144:	e59f0070 	ldr	r0, [pc, #112]	; 57e031bc <do_fat_fsinfo+0x8c>
57e03148:	eb0018bf 	bl	57e0944c <printf>
		return 0;
57e0314c:	e3a00000 	mov	r0, #0
57e03150:	ea000017 	b	57e031b4 <do_fat_fsinfo+0x84>
	}

	part = get_device_and_partition(argv[1], argv[2], &dev_desc, &info, 1);
57e03154:	e3a04001 	mov	r4, #1
57e03158:	e58d4000 	str	r4, [sp]
57e0315c:	e28d600c 	add	r6, sp, #12
57e03160:	e9930003 	ldmib	r3, {r0, r1}
57e03164:	e28d205c 	add	r2, sp, #92	; 0x5c
57e03168:	e1a03006 	mov	r3, r6
57e0316c:	eb004067 	bl	57e13310 <get_device_and_partition>
	if (part < 0)
57e03170:	e2507000 	subs	r7, r0, #0
57e03174:	ba00000d 	blt	57e031b0 <do_fat_fsinfo+0x80>
		return 1;

	dev = dev_desc->dev;
57e03178:	e59d005c 	ldr	r0, [sp, #92]	; 0x5c
	if (fat_set_blk_dev(dev_desc, &info) != 0) {
57e0317c:	e1a01006 	mov	r1, r6

	part = get_device_and_partition(argv[1], argv[2], &dev_desc, &info, 1);
	if (part < 0)
		return 1;

	dev = dev_desc->dev;
57e03180:	e590a004 	ldr	sl, [r0, #4]
	if (fat_set_blk_dev(dev_desc, &info) != 0) {
57e03184:	eb007625 	bl	57e20a20 <fat_set_blk_dev>
57e03188:	e3500000 	cmp	r0, #0
57e0318c:	0a000005 	beq	57e031a8 <do_fat_fsinfo+0x78>
		printf("\n** Unable to use %s %d:%d for fatinfo **\n",
57e03190:	e5951004 	ldr	r1, [r5, #4]
57e03194:	e1a0200a 	mov	r2, sl
57e03198:	e1a03007 	mov	r3, r7
57e0319c:	e59f001c 	ldr	r0, [pc, #28]	; 57e031c0 <do_fat_fsinfo+0x90>
57e031a0:	eb0018a9 	bl	57e0944c <printf>
57e031a4:	ea000001 	b	57e031b0 <do_fat_fsinfo+0x80>
			argv[1], dev, part);
		return 1;
	}
	return file_fat_detectfs();
57e031a8:	eb007958 	bl	57e21710 <file_fat_detectfs>
57e031ac:	ea000000 	b	57e031b4 <do_fat_fsinfo+0x84>
		return 0;
	}

	part = get_device_and_partition(argv[1], argv[2], &dev_desc, &info, 1);
	if (part < 0)
		return 1;
57e031b0:	e1a00004 	mov	r0, r4
		printf("\n** Unable to use %s %d:%d for fatinfo **\n",
			argv[1], dev, part);
		return 1;
	}
	return file_fat_detectfs();
}
57e031b4:	e28dd060 	add	sp, sp, #96	; 0x60
57e031b8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e031bc:	57e2f39d 	.word	0x57e2f39d
57e031c0:	57e2f3c8 	.word	0x57e2f3c8

57e031c4 <do_fat_ls>:
	"      the load stops on end of file.\n"
	"      All numeric parameters are assumed to be hex."
);

static int do_fat_ls(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e031c4:	e92d4007 	push	{r0, r1, r2, lr}
	return do_ls(cmdtp, flag, argc, argv, FS_TYPE_FAT);
57e031c8:	e3a0c001 	mov	ip, #1
57e031cc:	e58dc000 	str	ip, [sp]
57e031d0:	eb007ba7 	bl	57e22074 <do_ls>
}
57e031d4:	e8bd800e 	pop	{r1, r2, r3, pc}

57e031d8 <do_fat_fsload>:
#include <part.h>
#include <fat.h>
#include <fs.h>

int do_fat_fsload (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e031d8:	e92d4007 	push	{r0, r1, r2, lr}
	return do_load(cmdtp, flag, argc, argv, FS_TYPE_FAT, 16);
57e031dc:	e3a0c001 	mov	ip, #1
57e031e0:	e58dc000 	str	ip, [sp]
57e031e4:	e28cc00f 	add	ip, ip, #15
57e031e8:	e58dc004 	str	ip, [sp, #4]
57e031ec:	eb007b27 	bl	57e21e90 <do_load>
}
57e031f0:	e8bd800e 	pop	{r1, r2, r3, pc}

57e031f4 <flash_fill_sect_ranges>:

static int
flash_fill_sect_ranges (ulong addr_first, ulong addr_last,
			int *s_first, int *s_last,
			int *s_count )
{
57e031f4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
57e031f8:	e59db030 	ldr	fp, [sp, #48]	; 0x30
	int rcode = 0;

	*s_count = 0;

	for (bank=0; bank < CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
		s_first[bank] = -1;	/* first sector to erase	*/
57e031fc:	e3e0c000 	mvn	ip, #0
{
	flash_info_t *info;
	ulong bank;
	int rcode = 0;

	*s_count = 0;
57e03200:	e3a04000 	mov	r4, #0
57e03204:	e58b4000 	str	r4, [fp]

	for (bank=0; bank < CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
		s_first[bank] = -1;	/* first sector to erase	*/
57e03208:	e582c000 	str	ip, [r2]
		s_last [bank] = -1;	/* last  sector to erase	*/
57e0320c:	e583c000 	str	ip, [r3]
57e03210:	e59fc184 	ldr	ip, [pc, #388]	; 57e0339c <flash_fill_sect_ranges+0x1a8>
57e03214:	ea000057 	b	57e03378 <flash_fill_sect_ranges+0x184>
	     ++bank, ++info) {
		ulong b_end;
		int sect;
		short s_end;

		if (info->flash_id == FLASH_UNKNOWN) {
57e03218:	e59c4008 	ldr	r4, [ip, #8]
57e0321c:	e59f517c 	ldr	r5, [pc, #380]	; 57e033a0 <flash_fill_sect_ranges+0x1ac>
57e03220:	e1540005 	cmp	r4, r5
57e03224:	0a000051 	beq	57e03370 <flash_fill_sect_ranges+0x17c>
			continue;
		}

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
		s_end = info->sector_count - 1;			/* last sector   */
57e03228:	e1dc70b4 	ldrh	r7, [ip, #4]

		if (info->flash_id == FLASH_UNKNOWN) {
			continue;
		}

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
57e0322c:	e59c400c 	ldr	r4, [ip, #12]
57e03230:	e59c6000 	ldr	r6, [ip]
		s_end = info->sector_count - 1;			/* last sector   */
57e03234:	e58d7008 	str	r7, [sp, #8]
57e03238:	e2477001 	sub	r7, r7, #1
57e0323c:	e1a07807 	lsl	r7, r7, #16


		for (sect=0; sect < info->sector_count; ++sect) {
			ulong end;	/* last address in current sect	*/

			end = (sect == s_end) ? b_end : info->start[sect + 1] - 1;
57e03240:	e1a0a827 	lsr	sl, r7, #16

		if (info->flash_id == FLASH_UNKNOWN) {
			continue;
		}

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
57e03244:	e0866004 	add	r6, r6, r4


		for (sect=0; sect < info->sector_count; ++sect) {
			ulong end;	/* last address in current sect	*/

			end = (sect == s_end) ? b_end : info->start[sect + 1] - 1;
57e03248:	e1a07847 	asr	r7, r7, #16
57e0324c:	e58da004 	str	sl, [sp, #4]

		if (info->flash_id == FLASH_UNKNOWN) {
			continue;
		}

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
57e03250:	e2469001 	sub	r9, r6, #1
		s_end = info->sector_count - 1;			/* last sector   */


		for (sect=0; sect < info->sector_count; ++sect) {
57e03254:	e1a0500c 	mov	r5, ip
57e03258:	e3a04000 	mov	r4, #0
			ulong end;	/* last address in current sect	*/

			end = (sect == s_end) ? b_end : info->start[sect + 1] - 1;
57e0325c:	e58d700c 	str	r7, [sp, #12]
57e03260:	e1a0a00c 	mov	sl, ip

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
		s_end = info->sector_count - 1;			/* last sector   */


		for (sect=0; sect < info->sector_count; ++sect) {
57e03264:	ea00000f 	b	57e032a8 <flash_fill_sect_ranges+0xb4>
			ulong end;	/* last address in current sect	*/

			end = (sect == s_end) ? b_end : info->start[sect + 1] - 1;
57e03268:	e59dc00c 	ldr	ip, [sp, #12]
57e0326c:	e154000c 	cmp	r4, ip
57e03270:	1595c010 	ldrne	ip, [r5, #16]
57e03274:	01a0c009 	moveq	ip, r9
57e03278:	124cc001 	subne	ip, ip, #1

			if (addr_first > end)
57e0327c:	e150000c 	cmp	r0, ip
57e03280:	8a000006 	bhi	57e032a0 <flash_fill_sect_ranges+0xac>
				continue;
			if (addr_last < info->start[sect])
57e03284:	e595700c 	ldr	r7, [r5, #12]
57e03288:	e1510007 	cmp	r1, r7
57e0328c:	3a000003 	bcc	57e032a0 <flash_fill_sect_ranges+0xac>
				continue;

			if (addr_first == info->start[sect]) {
57e03290:	e1500007 	cmp	r0, r7
				s_first[bank] = sect;
57e03294:	05824000 	streq	r4, [r2]
			}
			if (addr_last  == end) {
57e03298:	e151000c 	cmp	r1, ip
				s_last[bank]  = sect;
57e0329c:	05834000 	streq	r4, [r3]

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
		s_end = info->sector_count - 1;			/* last sector   */


		for (sect=0; sect < info->sector_count; ++sect) {
57e032a0:	e2844001 	add	r4, r4, #1
57e032a4:	e2855004 	add	r5, r5, #4
57e032a8:	e59d7008 	ldr	r7, [sp, #8]
57e032ac:	e1540007 	cmp	r4, r7
57e032b0:	baffffec 	blt	57e03268 <flash_fill_sect_ranges+0x74>
			}
			if (addr_last  == end) {
				s_last[bank]  = sect;
			}
		}
		if (s_first[bank] >= 0) {
57e032b4:	e5924000 	ldr	r4, [r2]
57e032b8:	e1a0c00a 	mov	ip, sl
57e032bc:	e3540000 	cmp	r4, #0
57e032c0:	ba00001d 	blt	57e0333c <flash_fill_sect_ranges+0x148>
			if (s_last[bank] < 0) {
57e032c4:	e5930000 	ldr	r0, [r3]
57e032c8:	e3500000 	cmp	r0, #0
57e032cc:	aa000006 	bge	57e032ec <flash_fill_sect_ranges+0xf8>
				if (addr_last > b_end) {
57e032d0:	e1510009 	cmp	r1, r9
					s_last[bank] = s_end;
57e032d4:	859da004 	ldrhi	sl, [sp, #4]
57e032d8:	81a0080a 	lslhi	r0, sl, #16
57e032dc:	81a00840 	asrhi	r0, r0, #16
57e032e0:	85830000 	strhi	r0, [r3]
				} else {
					puts ("Error: end address"
57e032e4:	959f00b8 	ldrls	r0, [pc, #184]	; 57e033a4 <flash_fill_sect_ranges+0x1b0>
57e032e8:	9a000004 	bls	57e03300 <flash_fill_sect_ranges+0x10c>
						" not on sector boundary\n");
					rcode = 1;
					break;
				}
			}
			if (s_last[bank] < s_first[bank]) {
57e032ec:	e5930000 	ldr	r0, [r3]
57e032f0:	e5924000 	ldr	r4, [r2]
57e032f4:	e1500004 	cmp	r0, r4
57e032f8:	aa000003 	bge	57e0330c <flash_fill_sect_ranges+0x118>
				puts ("Error: end sector"
57e032fc:	e59f00a4 	ldr	r0, [pc, #164]	; 57e033a8 <flash_fill_sect_ranges+0x1b4>
57e03300:	eb001847 	bl	57e09424 <puts>
					" precedes start sector\n");
				rcode = 1;
57e03304:	e3a00001 	mov	r0, #1
				break;
57e03308:	ea000021 	b	57e03394 <flash_fill_sect_ranges+0x1a0>
			}
			sect = s_last[bank];
			addr_first = (sect == s_end) ? b_end + 1: info->start[sect + 1];
57e0330c:	e59d7004 	ldr	r7, [sp, #4]
57e03310:	e1a05807 	lsl	r5, r7, #16
57e03314:	e1500845 	cmp	r0, r5, asr #16
57e03318:	108c5100 	addne	r5, ip, r0, lsl #2
			(*s_count) += s_last[bank] - s_first[bank] + 1;
57e0331c:	e0640000 	rsb	r0, r4, r0
57e03320:	e59b4000 	ldr	r4, [fp]
					" precedes start sector\n");
				rcode = 1;
				break;
			}
			sect = s_last[bank];
			addr_first = (sect == s_end) ? b_end + 1: info->start[sect + 1];
57e03324:	15956010 	ldrne	r6, [r5, #16]
			(*s_count) += s_last[bank] - s_first[bank] + 1;
57e03328:	e2800001 	add	r0, r0, #1
57e0332c:	e0840000 	add	r0, r4, r0
57e03330:	e58b0000 	str	r0, [fp]
					" precedes start sector\n");
				rcode = 1;
				break;
			}
			sect = s_last[bank];
			addr_first = (sect == s_end) ? b_end + 1: info->start[sect + 1];
57e03334:	e1a00006 	mov	r0, r6
57e03338:	ea00000c 	b	57e03370 <flash_fill_sect_ranges+0x17c>
			(*s_count) += s_last[bank] - s_first[bank] + 1;
		} else if (addr_first >= info->start[0] && addr_first < b_end) {
57e0333c:	e59a400c 	ldr	r4, [sl, #12]
57e03340:	e1500009 	cmp	r0, r9
57e03344:	23a09000 	movcs	r9, #0
57e03348:	33a09001 	movcc	r9, #1
57e0334c:	e1500004 	cmp	r0, r4
57e03350:	33a09000 	movcc	r9, #0
57e03354:	e3590000 	cmp	r9, #0
			puts ("Error: start address not on sector boundary\n");
57e03358:	159f004c 	ldrne	r0, [pc, #76]	; 57e033ac <flash_fill_sect_ranges+0x1b8>
57e0335c:	1affffe7 	bne	57e03300 <flash_fill_sect_ranges+0x10c>
			rcode = 1;
			break;
		} else if (s_last[bank] >= 0) {
57e03360:	e5934000 	ldr	r4, [r3]
57e03364:	e3540000 	cmp	r4, #0
			puts ("Error: cannot span across banks when they are"
57e03368:	a59f0040 	ldrge	r0, [pc, #64]	; 57e033b0 <flash_fill_sect_ranges+0x1bc>
57e0336c:	aaffffe3 	bge	57e03300 <flash_fill_sect_ranges+0x10c>
		s_last [bank] = -1;	/* last  sector to erase	*/
	}

	for (bank=0,info = &flash_info[0];
	     (bank < CONFIG_SYS_MAX_FLASH_BANKS) && (addr_first <= addr_last);
	     ++bank, ++info) {
57e03370:	e28ccf42 	add	ip, ip, #264	; 0x108
57e03374:	e3a04001 	mov	r4, #1
		s_first[bank] = -1;	/* first sector to erase	*/
		s_last [bank] = -1;	/* last  sector to erase	*/
	}

	for (bank=0,info = &flash_info[0];
	     (bank < CONFIG_SYS_MAX_FLASH_BANKS) && (addr_first <= addr_last);
57e03378:	e2244001 	eor	r4, r4, #1
	for (bank=0; bank < CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
		s_first[bank] = -1;	/* first sector to erase	*/
		s_last [bank] = -1;	/* last  sector to erase	*/
	}

	for (bank=0,info = &flash_info[0];
57e0337c:	e1500001 	cmp	r0, r1
57e03380:	83a04000 	movhi	r4, #0
57e03384:	92044001 	andls	r4, r4, #1
57e03388:	e3540000 	cmp	r4, #0
57e0338c:	1affffa1 	bne	57e03218 <flash_fill_sect_ranges+0x24>
			int *s_first, int *s_last,
			int *s_count )
{
	flash_info_t *info;
	ulong bank;
	int rcode = 0;
57e03390:	e1a00004 	mov	r0, r4
			break;
		}
	}

	return rcode;
}
57e03394:	e28dd010 	add	sp, sp, #16
57e03398:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0339c:	57e47684 	.word	0x57e47684
57e033a0:	0000ffff 	.word	0x0000ffff
57e033a4:	57e2f6cd 	.word	0x57e2f6cd
57e033a8:	57e2f6f8 	.word	0x57e2f6f8
57e033ac:	57e2f721 	.word	0x57e2f721
57e033b0:	57e2f74e 	.word	0x57e2f74e

57e033b4 <abbrev_spec>:
 *			  a parsing error, a number out of range,
 *			  or an invalid flash bank.
 */
static int
abbrev_spec (char *str, flash_info_t ** pinfo, int *psf, int *psl)
{
57e033b4:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e033b8:	e1a09001 	mov	r9, r1
	flash_info_t *fp;
	int bank, first, last;
	char *p, *ep;

	if ((p = strchr (str, ':')) == NULL)
57e033bc:	e3a0103a 	mov	r1, #58	; 0x3a
 *			  a parsing error, a number out of range,
 *			  or an invalid flash bank.
 */
static int
abbrev_spec (char *str, flash_info_t ** pinfo, int *psf, int *psl)
{
57e033c0:	e1a04000 	mov	r4, r0
57e033c4:	e1a0b002 	mov	fp, r2
57e033c8:	e1a0a003 	mov	sl, r3
	flash_info_t *fp;
	int bank, first, last;
	char *p, *ep;

	if ((p = strchr (str, ':')) == NULL)
57e033cc:	eb008312 	bl	57e2401c <strchr>
57e033d0:	e2506000 	subs	r6, r0, #0
		return 0;
57e033d4:	01a00006 	moveq	r0, r6
{
	flash_info_t *fp;
	int bank, first, last;
	char *p, *ep;

	if ((p = strchr (str, ':')) == NULL)
57e033d8:	0a000045 	beq	57e034f4 <abbrev_spec+0x140>
		return 0;
	*p++ = '\0';
57e033dc:	e3a03000 	mov	r3, #0
57e033e0:	e5c63000 	strb	r3, [r6]

	bank = simple_strtoul (str, &ep, 10);
57e033e4:	e1a00004 	mov	r0, r4
57e033e8:	e28d1004 	add	r1, sp, #4
57e033ec:	e3a0200a 	mov	r2, #10
57e033f0:	eb00872b 	bl	57e250a4 <simple_strtoul>
	if (ep == str || *ep != '\0' ||
57e033f4:	e59d3004 	ldr	r3, [sp, #4]
57e033f8:	e1530004 	cmp	r3, r4
57e033fc:	0a00003b 	beq	57e034f0 <abbrev_spec+0x13c>
57e03400:	e5d35000 	ldrb	r5, [r3]
57e03404:	e2555000 	subs	r5, r5, #0
57e03408:	13a05001 	movne	r5, #1
57e0340c:	e3500000 	cmp	r0, #0
57e03410:	d3855001 	orrle	r5, r5, #1
57e03414:	e3550000 	cmp	r5, #0
57e03418:	1a000034 	bne	57e034f0 <abbrev_spec+0x13c>
		bank < 1 || bank > CONFIG_SYS_MAX_FLASH_BANKS ||
57e0341c:	e3500001 	cmp	r0, #1
57e03420:	1a000032 	bne	57e034f0 <abbrev_spec+0x13c>
		(fp = &flash_info[bank - 1])->flash_id == FLASH_UNKNOWN)
57e03424:	e59f30cc 	ldr	r3, [pc, #204]	; 57e034f8 <abbrev_spec+0x144>
		return 0;
	*p++ = '\0';

	bank = simple_strtoul (str, &ep, 10);
	if (ep == str || *ep != '\0' ||
		bank < 1 || bank > CONFIG_SYS_MAX_FLASH_BANKS ||
57e03428:	e5932008 	ldr	r2, [r3, #8]
57e0342c:	e59f30c8 	ldr	r3, [pc, #200]	; 57e034fc <abbrev_spec+0x148>
57e03430:	e1520003 	cmp	r2, r3
57e03434:	0a00002d 	beq	57e034f0 <abbrev_spec+0x13c>
	int bank, first, last;
	char *p, *ep;

	if ((p = strchr (str, ':')) == NULL)
		return 0;
	*p++ = '\0';
57e03438:	e2866001 	add	r6, r6, #1
		bank < 1 || bank > CONFIG_SYS_MAX_FLASH_BANKS ||
		(fp = &flash_info[bank - 1])->flash_id == FLASH_UNKNOWN)
		return -1;

	str = p;
	if ((p = strchr (str, '-')) != NULL)
57e0343c:	e3a0102d 	mov	r1, #45	; 0x2d
57e03440:	e1a00006 	mov	r0, r6
57e03444:	eb0082f4 	bl	57e2401c <strchr>
		*p++ = '\0';

	first = simple_strtoul (str, &ep, 10);
57e03448:	e28d7004 	add	r7, sp, #4
		bank < 1 || bank > CONFIG_SYS_MAX_FLASH_BANKS ||
		(fp = &flash_info[bank - 1])->flash_id == FLASH_UNKNOWN)
		return -1;

	str = p;
	if ((p = strchr (str, '-')) != NULL)
57e0344c:	e2504000 	subs	r4, r0, #0
		*p++ = '\0';
57e03450:	14c45001 	strbne	r5, [r4], #1

	first = simple_strtoul (str, &ep, 10);
57e03454:	e1a00006 	mov	r0, r6
57e03458:	e1a01007 	mov	r1, r7
57e0345c:	e3a0200a 	mov	r2, #10
57e03460:	eb00870f 	bl	57e250a4 <simple_strtoul>
	if (ep == str || *ep != '\0' || first >= fp->sector_count)
57e03464:	e59d3004 	ldr	r3, [sp, #4]

	str = p;
	if ((p = strchr (str, '-')) != NULL)
		*p++ = '\0';

	first = simple_strtoul (str, &ep, 10);
57e03468:	e1a05000 	mov	r5, r0
	if (ep == str || *ep != '\0' || first >= fp->sector_count)
57e0346c:	e1530006 	cmp	r3, r6
57e03470:	0a00001e 	beq	57e034f0 <abbrev_spec+0x13c>
57e03474:	e5d33000 	ldrb	r3, [r3]
57e03478:	e3530000 	cmp	r3, #0
57e0347c:	1a00001b 	bne	57e034f0 <abbrev_spec+0x13c>
57e03480:	e59f6070 	ldr	r6, [pc, #112]	; 57e034f8 <abbrev_spec+0x144>
57e03484:	e1d630b4 	ldrh	r3, [r6, #4]
57e03488:	e1500003 	cmp	r0, r3
57e0348c:	aa000017 	bge	57e034f0 <abbrev_spec+0x13c>
		return -1;

	if (p != NULL) {
57e03490:	e3540000 	cmp	r4, #0
57e03494:	01a03000 	moveq	r3, r0
57e03498:	0a00000e 	beq	57e034d8 <abbrev_spec+0x124>
		last = simple_strtoul (p, &ep, 10);
57e0349c:	e3a0200a 	mov	r2, #10
57e034a0:	e1a00004 	mov	r0, r4
57e034a4:	e1a01007 	mov	r1, r7
57e034a8:	eb0086fd 	bl	57e250a4 <simple_strtoul>
		if (ep == p || *ep != '\0' ||
57e034ac:	e59d2004 	ldr	r2, [sp, #4]
57e034b0:	e1520004 	cmp	r2, r4
57e034b4:	0a00000d 	beq	57e034f0 <abbrev_spec+0x13c>
57e034b8:	e5d22000 	ldrb	r2, [r2]
	first = simple_strtoul (str, &ep, 10);
	if (ep == str || *ep != '\0' || first >= fp->sector_count)
		return -1;

	if (p != NULL) {
		last = simple_strtoul (p, &ep, 10);
57e034bc:	e1a03000 	mov	r3, r0
		if (ep == p || *ep != '\0' ||
57e034c0:	e1500005 	cmp	r0, r5
57e034c4:	a3520000 	cmpge	r2, #0
57e034c8:	1a000008 	bne	57e034f0 <abbrev_spec+0x13c>
			last < first || last >= fp->sector_count)
57e034cc:	e1d620b4 	ldrh	r2, [r6, #4]
57e034d0:	e1500002 	cmp	r0, r2
57e034d4:	aa000005 	bge	57e034f0 <abbrev_spec+0x13c>
	*p++ = '\0';

	bank = simple_strtoul (str, &ep, 10);
	if (ep == str || *ep != '\0' ||
		bank < 1 || bank > CONFIG_SYS_MAX_FLASH_BANKS ||
		(fp = &flash_info[bank - 1])->flash_id == FLASH_UNKNOWN)
57e034d8:	e59f2018 	ldr	r2, [pc, #24]	; 57e034f8 <abbrev_spec+0x144>

	*pinfo = fp;
	*psf = first;
	*psl = last;

	return 1;
57e034dc:	e3a00001 	mov	r0, #1
			return -1;
	} else {
		last = first;
	}

	*pinfo = fp;
57e034e0:	e5892000 	str	r2, [r9]
	*psf = first;
57e034e4:	e58b5000 	str	r5, [fp]
	*psl = last;
57e034e8:	e58a3000 	str	r3, [sl]

	return 1;
57e034ec:	ea000000 	b	57e034f4 <abbrev_spec+0x140>

	if (p != NULL) {
		last = simple_strtoul (p, &ep, 10);
		if (ep == p || *ep != '\0' ||
			last < first || last >= fp->sector_count)
			return -1;
57e034f0:	e3e00000 	mvn	r0, #0
	*pinfo = fp;
	*psf = first;
	*psl = last;

	return 1;
}
57e034f4:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e034f8:	57e47684 	.word	0x57e47684
57e034fc:	0000ffff 	.word	0x0000ffff

57e03500 <do_flinfo>:
#ifdef CONFIG_HAS_DATAFLASH
	dataflash_print_info();
#endif

#ifndef CONFIG_SYS_NO_FLASH
	if (argc == 1) {	/* print info for all FLASH banks */
57e03500:	e3520001 	cmp	r2, #1
	return rcode;
}
#endif /* CONFIG_SYS_NO_FLASH */

static int do_flinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e03504:	e92d4008 	push	{r3, lr}
#ifdef CONFIG_HAS_DATAFLASH
	dataflash_print_info();
#endif

#ifndef CONFIG_SYS_NO_FLASH
	if (argc == 1) {	/* print info for all FLASH banks */
57e03508:	1a000006 	bne	57e03528 <do_flinfo+0x28>
		for (bank=0; bank <CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
			printf ("\nBank # %ld: ", bank+1);
57e0350c:	e1a01002 	mov	r1, r2
57e03510:	e59f0058 	ldr	r0, [pc, #88]	; 57e03570 <do_flinfo+0x70>
57e03514:	eb0017cc 	bl	57e0944c <printf>

			flash_print_info (&flash_info[bank]);
57e03518:	e59f0054 	ldr	r0, [pc, #84]	; 57e03574 <do_flinfo+0x74>
57e0351c:	eb0046a0 	bl	57e14fa4 <flash_print_info>
		}
		return 0;
57e03520:	e3a00000 	mov	r0, #0
57e03524:	e8bd8008 	pop	{r3, pc}
	}

	bank = simple_strtoul(argv[1], NULL, 16);
57e03528:	e3a01000 	mov	r1, #0
57e0352c:	e5930004 	ldr	r0, [r3, #4]
57e03530:	e3a02010 	mov	r2, #16
57e03534:	eb0086da 	bl	57e250a4 <simple_strtoul>
	if ((bank < 1) || (bank > CONFIG_SYS_MAX_FLASH_BANKS)) {
57e03538:	e3500001 	cmp	r0, #1
			flash_print_info (&flash_info[bank]);
		}
		return 0;
	}

	bank = simple_strtoul(argv[1], NULL, 16);
57e0353c:	e1a01000 	mov	r1, r0
	if ((bank < 1) || (bank > CONFIG_SYS_MAX_FLASH_BANKS)) {
57e03540:	0a000004 	beq	57e03558 <do_flinfo+0x58>
		printf ("Only FLASH Banks # 1 ... # %d supported\n",
57e03544:	e59f002c 	ldr	r0, [pc, #44]	; 57e03578 <do_flinfo+0x78>
57e03548:	e3a01001 	mov	r1, #1
57e0354c:	eb0017be 	bl	57e0944c <printf>
			CONFIG_SYS_MAX_FLASH_BANKS);
		return 1;
57e03550:	e3a00001 	mov	r0, #1
57e03554:	e8bd8008 	pop	{r3, pc}
	}
	printf ("\nBank # %ld: ", bank);
57e03558:	e59f0010 	ldr	r0, [pc, #16]	; 57e03570 <do_flinfo+0x70>
57e0355c:	eb0017ba 	bl	57e0944c <printf>
	flash_print_info (&flash_info[bank-1]);
57e03560:	e59f000c 	ldr	r0, [pc, #12]	; 57e03574 <do_flinfo+0x74>
57e03564:	eb00468e 	bl	57e14fa4 <flash_print_info>
#endif /* CONFIG_SYS_NO_FLASH */
	return 0;
57e03568:	e3a00000 	mov	r0, #0
}
57e0356c:	e8bd8008 	pop	{r3, pc}
57e03570:	57e2f795 	.word	0x57e2f795
57e03574:	57e47684 	.word	0x57e47684
57e03578:	57e2f7a3 	.word	0x57e2f7a3

57e0357c <flash_sect_roundb>:
	ulong bank, sector_end_addr;
	char found;
	int i;

	/* find the end addr of the sector where the *addr is */
	found = 0;
57e0357c:	e3a02000 	mov	r2, #0

/*
 * Take *addr in Flash and adjust it to fall on the end of its sector
 */
int flash_sect_roundb (ulong *addr)
{
57e03580:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	char found;
	int i;

	/* find the end addr of the sector where the *addr is */
	found = 0;
	for (bank = 0; bank < CONFIG_SYS_MAX_FLASH_BANKS && !found; ++bank) {
57e03584:	e1a01002 	mov	r1, r2

/*
 * Take *addr in Flash and adjust it to fall on the end of its sector
 */
int flash_sect_roundb (ulong *addr)
{
57e03588:	e1a03000 	mov	r3, r0

	/* find the end addr of the sector where the *addr is */
	found = 0;
	for (bank = 0; bank < CONFIG_SYS_MAX_FLASH_BANKS && !found; ++bank) {
		info = &flash_info[bank];
		for (i = 0; i < info->sector_count && !found; ++i) {
57e0358c:	e59fc0ac 	ldr	ip, [pc, #172]	; 57e03640 <flash_sect_roundb+0xc4>
	char found;
	int i;

	/* find the end addr of the sector where the *addr is */
	found = 0;
	for (bank = 0; bank < CONFIG_SYS_MAX_FLASH_BANKS && !found; ++bank) {
57e03590:	ea000019 	b	57e035fc <flash_sect_roundb+0x80>
		info = &flash_info[bank];
		for (i = 0; i < info->sector_count && !found; ++i) {
			/* get the end address of the sector */
			if (i == info->sector_count - 1) {
57e03594:	e1510006 	cmp	r1, r6
				sector_end_addr = info->start[0] +
57e03598:	059c400c 	ldreq	r4, [ip, #12]
57e0359c:	059c2000 	ldreq	r2, [ip]
								info->size - 1;
			} else {
				sector_end_addr = info->start[i+1] - 1;
57e035a0:	15902010 	ldrne	r2, [r0, #16]
	for (bank = 0; bank < CONFIG_SYS_MAX_FLASH_BANKS && !found; ++bank) {
		info = &flash_info[bank];
		for (i = 0; i < info->sector_count && !found; ++i) {
			/* get the end address of the sector */
			if (i == info->sector_count - 1) {
				sector_end_addr = info->start[0] +
57e035a4:	00842002 	addeq	r2, r4, r2
								info->size - 1;
			} else {
				sector_end_addr = info->start[i+1] - 1;
			}

			if (*addr <= sector_end_addr &&
57e035a8:	e5934000 	ldr	r4, [r3]
			/* get the end address of the sector */
			if (i == info->sector_count - 1) {
				sector_end_addr = info->start[0] +
								info->size - 1;
			} else {
				sector_end_addr = info->start[i+1] - 1;
57e035ac:	e2422001 	sub	r2, r2, #1
			}

			if (*addr <= sector_end_addr &&
57e035b0:	e1540002 	cmp	r4, r2
57e035b4:	8a000006 	bhi	57e035d4 <flash_sect_roundb+0x58>
57e035b8:	e590700c 	ldr	r7, [r0, #12]
57e035bc:	e1540007 	cmp	r4, r7
57e035c0:	3a000003 	bcc	57e035d4 <flash_sect_roundb+0x58>
						*addr >= info->start[i]) {
				found = 1;
				/* adjust *addr if necessary */
				if (*addr < sector_end_addr)
57e035c4:	e1540002 	cmp	r4, r2
					*addr = sector_end_addr;
57e035c8:	35832000 	strcc	r2, [r3]
				sector_end_addr = info->start[i+1] - 1;
			}

			if (*addr <= sector_end_addr &&
						*addr >= info->start[i]) {
				found = 1;
57e035cc:	e3a02001 	mov	r2, #1
57e035d0:	ea000000 	b	57e035d8 <flash_sect_roundb+0x5c>
								info->size - 1;
			} else {
				sector_end_addr = info->start[i+1] - 1;
			}

			if (*addr <= sector_end_addr &&
57e035d4:	e3a02000 	mov	r2, #0

	/* find the end addr of the sector where the *addr is */
	found = 0;
	for (bank = 0; bank < CONFIG_SYS_MAX_FLASH_BANKS && !found; ++bank) {
		info = &flash_info[bank];
		for (i = 0; i < info->sector_count && !found; ++i) {
57e035d8:	e2811001 	add	r1, r1, #1
57e035dc:	e2800004 	add	r0, r0, #4
57e035e0:	e2224001 	eor	r4, r2, #1
57e035e4:	e1510005 	cmp	r1, r5
57e035e8:	a3a04000 	movge	r4, #0
57e035ec:	b2044001 	andlt	r4, r4, #1
57e035f0:	e3540000 	cmp	r4, #0
57e035f4:	1affffe6 	bne	57e03594 <flash_sect_roundb+0x18>
	char found;
	int i;

	/* find the end addr of the sector where the *addr is */
	found = 0;
	for (bank = 0; bank < CONFIG_SYS_MAX_FLASH_BANKS && !found; ++bank) {
57e035f8:	e3a01001 	mov	r1, #1
57e035fc:	e2220001 	eor	r0, r2, #1
57e03600:	e2211001 	eor	r1, r1, #1
57e03604:	e0100001 	ands	r0, r0, r1
57e03608:	0a000005 	beq	57e03624 <flash_sect_roundb+0xa8>
		info = &flash_info[bank];
		for (i = 0; i < info->sector_count && !found; ++i) {
57e0360c:	e1dc50b4 	ldrh	r5, [ip, #4]
			/* get the end address of the sector */
			if (i == info->sector_count - 1) {
57e03610:	e3a02000 	mov	r2, #0
57e03614:	e2456001 	sub	r6, r5, #1
57e03618:	e59f0020 	ldr	r0, [pc, #32]	; 57e03640 <flash_sect_roundb+0xc4>
57e0361c:	e1a01002 	mov	r1, r2
57e03620:	eaffffee 	b	57e035e0 <flash_sect_roundb+0x64>
				if (*addr < sector_end_addr)
					*addr = sector_end_addr;
			} /* sector */
		} /* bank */
	}
	if (!found) {
57e03624:	e3520000 	cmp	r2, #0
57e03628:	18bd80f8 	popne	{r3, r4, r5, r6, r7, pc}
		/* error, address not in flash */
		printf("Error: end address (0x%08lx) not in flash!\n", *addr);
57e0362c:	e5931000 	ldr	r1, [r3]
57e03630:	e59f000c 	ldr	r0, [pc, #12]	; 57e03644 <flash_sect_roundb+0xc8>
57e03634:	eb001784 	bl	57e0944c <printf>
		return 1;
57e03638:	e3a00001 	mov	r0, #1
	}

	return 0;
}
57e0363c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e03640:	57e47684 	.word	0x57e47684
57e03644:	57e2f7cc 	.word	0x57e2f7cc

57e03648 <addr_spec>:
 *    1: success
 *   -1: failure (bad format, bad address).
*/
static int
addr_spec(char *arg1, char *arg2, ulong *addr_first, ulong *addr_last)
{
57e03648:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
57e0364c:	e1a05002 	mov	r5, r2
57e03650:	e1a04001 	mov	r4, r1
	char *ep;
	char len_used; /* indicates if the "start +length" form used */

	*addr_first = simple_strtoul(arg1, &ep, 16);
57e03654:	e3a02010 	mov	r2, #16
57e03658:	e28d1004 	add	r1, sp, #4
 *    1: success
 *   -1: failure (bad format, bad address).
*/
static int
addr_spec(char *arg1, char *arg2, ulong *addr_first, ulong *addr_last)
{
57e0365c:	e1a06000 	mov	r6, r0
57e03660:	e1a07003 	mov	r7, r3
	char *ep;
	char len_used; /* indicates if the "start +length" form used */

	*addr_first = simple_strtoul(arg1, &ep, 16);
57e03664:	eb00868e 	bl	57e250a4 <simple_strtoul>
	if (ep == arg1 || *ep != '\0')
57e03668:	e59d3004 	ldr	r3, [sp, #4]
addr_spec(char *arg1, char *arg2, ulong *addr_first, ulong *addr_last)
{
	char *ep;
	char len_used; /* indicates if the "start +length" form used */

	*addr_first = simple_strtoul(arg1, &ep, 16);
57e0366c:	e5850000 	str	r0, [r5]
	if (ep == arg1 || *ep != '\0')
57e03670:	e1530006 	cmp	r3, r6
57e03674:	0a000021 	beq	57e03700 <addr_spec+0xb8>
57e03678:	e5d36000 	ldrb	r6, [r3]
57e0367c:	e3560000 	cmp	r6, #0
57e03680:	1a00001e 	bne	57e03700 <addr_spec+0xb8>
		return -1;

	len_used = 0;
	if (arg2 && *arg2 == '+'){
57e03684:	e3540000 	cmp	r4, #0

	*addr_first = simple_strtoul(arg1, &ep, 16);
	if (ep == arg1 || *ep != '\0')
		return -1;

	len_used = 0;
57e03688:	01a06004 	moveq	r6, r4
	if (arg2 && *arg2 == '+'){
57e0368c:	0a000003 	beq	57e036a0 <addr_spec+0x58>
57e03690:	e5d43000 	ldrb	r3, [r4]
57e03694:	e353002b 	cmp	r3, #43	; 0x2b
		len_used = 1;
		++arg2;
57e03698:	02844001 	addeq	r4, r4, #1
	if (ep == arg1 || *ep != '\0')
		return -1;

	len_used = 0;
	if (arg2 && *arg2 == '+'){
		len_used = 1;
57e0369c:	02866001 	addeq	r6, r6, #1
		++arg2;
	}

	*addr_last = simple_strtoul(arg2, &ep, 16);
57e036a0:	e1a00004 	mov	r0, r4
57e036a4:	e28d1004 	add	r1, sp, #4
57e036a8:	e3a02010 	mov	r2, #16
57e036ac:	eb00867c 	bl	57e250a4 <simple_strtoul>
	if (ep == arg2 || *ep != '\0')
57e036b0:	e59d3004 	ldr	r3, [sp, #4]
	if (arg2 && *arg2 == '+'){
		len_used = 1;
		++arg2;
	}

	*addr_last = simple_strtoul(arg2, &ep, 16);
57e036b4:	e5870000 	str	r0, [r7]
	if (ep == arg2 || *ep != '\0')
57e036b8:	e1530004 	cmp	r3, r4
57e036bc:	0a00000f 	beq	57e03700 <addr_spec+0xb8>
57e036c0:	e5d33000 	ldrb	r3, [r3]
57e036c4:	e3530000 	cmp	r3, #0
57e036c8:	1a00000c 	bne	57e03700 <addr_spec+0xb8>
		return -1;

	if (len_used){
57e036cc:	e3560000 	cmp	r6, #0

		if (flash_sect_roundb(addr_last) > 0)
			return -1;
	} /* "start +length" from used */

	return 1;
57e036d0:	03a00001 	moveq	r0, #1

	*addr_last = simple_strtoul(arg2, &ep, 16);
	if (ep == arg2 || *ep != '\0')
		return -1;

	if (len_used){
57e036d4:	0a00000a 	beq	57e03704 <addr_spec+0xbc>
		/*
		 * *addr_last has the length, compute correct *addr_last
		 * XXX watch out for the integer overflow! Right now it is
		 * checked for in both the callers.
		 */
		*addr_last = *addr_first + *addr_last - 1;
57e036d8:	e5953000 	ldr	r3, [r5]
57e036dc:	e2433001 	sub	r3, r3, #1
57e036e0:	e0830000 	add	r0, r3, r0
57e036e4:	e5870000 	str	r0, [r7]
		 * It may happen that *addr_last doesn't fall on the sector
		 * boundary. We want to round such an address to the next
		 * sector boundary, so that the commands don't fail later on.
		 */

		if (flash_sect_roundb(addr_last) > 0)
57e036e8:	e1a00007 	mov	r0, r7
57e036ec:	ebffffa2 	bl	57e0357c <flash_sect_roundb>
57e036f0:	e3500000 	cmp	r0, #0
			return -1;
	} /* "start +length" from used */

	return 1;
57e036f4:	c3e00000 	mvngt	r0, #0
57e036f8:	d3a00001 	movle	r0, #1
57e036fc:	ea000000 	b	57e03704 <addr_spec+0xbc>
		++arg2;
	}

	*addr_last = simple_strtoul(arg2, &ep, 16);
	if (ep == arg2 || *ep != '\0')
		return -1;
57e03700:	e3e00000 	mvn	r0, #0
		if (flash_sect_roundb(addr_last) > 0)
			return -1;
	} /* "start +length" from used */

	return 1;
}
57e03704:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

57e03708 <flash_sect_erase>:
#endif /* CONFIG_SYS_NO_FLASH */
}

#ifndef CONFIG_SYS_NO_FLASH
int flash_sect_erase (ulong addr_first, ulong addr_last)
{
57e03708:	e92d4070 	push	{r4, r5, r6, lr}
57e0370c:	e24dd018 	sub	sp, sp, #24
	int s_first[CONFIG_SYS_MAX_FLASH_BANKS], s_last[CONFIG_SYS_MAX_FLASH_BANKS];
	int erased = 0;
	int planned;
	int rcode = 0;

	rcode = flash_fill_sect_ranges (addr_first, addr_last,
57e03710:	e28d300c 	add	r3, sp, #12
57e03714:	e58d3000 	str	r3, [sp]
57e03718:	e28d2014 	add	r2, sp, #20
57e0371c:	e28d3010 	add	r3, sp, #16
57e03720:	ebfffeb3 	bl	57e031f4 <flash_fill_sect_ranges>
					s_first, s_last, &planned );

	if (planned && (rcode == 0)) {
57e03724:	e59d200c 	ldr	r2, [sp, #12]
57e03728:	e2703001 	rsbs	r3, r0, #1
57e0372c:	33a03000 	movcc	r3, #0
57e03730:	e3520000 	cmp	r2, #0
57e03734:	03a02000 	moveq	r2, #0
57e03738:	12032001 	andne	r2, r3, #1
57e0373c:	e3520000 	cmp	r2, #0
57e03740:	e1a06000 	mov	r6, r0
57e03744:	0a00001d 	beq	57e037c0 <flash_sect_erase+0xb8>
57e03748:	e3a06000 	mov	r6, #0
57e0374c:	e1a04006 	mov	r4, r6
57e03750:	e1a03006 	mov	r3, r6
57e03754:	e59f5084 	ldr	r5, [pc, #132]	; 57e037e0 <flash_sect_erase+0xd8>
57e03758:	ea00000c 	b	57e03790 <flash_sect_erase+0x88>
		for (bank=0,info = &flash_info[0];
		     (bank < CONFIG_SYS_MAX_FLASH_BANKS) && (rcode == 0);
		     ++bank, ++info) {
			if (s_first[bank]>=0) {
57e0375c:	e59d1014 	ldr	r1, [sp, #20]
57e03760:	e3510000 	cmp	r1, #0
57e03764:	b3a06000 	movlt	r6, #0
57e03768:	ba000006 	blt	57e03788 <flash_sect_erase+0x80>
				erased += s_last[bank] - s_first[bank] + 1;
57e0376c:	e59d2010 	ldr	r2, [sp, #16]
					info->start[s_first[bank]],
					(s_last[bank] == info->sector_count) ?
						info->start[0] + info->size - 1:
						info->start[s_last[bank]+1] - 1,
					bank+1);
				rcode = flash_erase (info, s_first[bank], s_last[bank]);
57e03770:	e1a00005 	mov	r0, r5
	if (planned && (rcode == 0)) {
		for (bank=0,info = &flash_info[0];
		     (bank < CONFIG_SYS_MAX_FLASH_BANKS) && (rcode == 0);
		     ++bank, ++info) {
			if (s_first[bank]>=0) {
				erased += s_last[bank] - s_first[bank] + 1;
57e03774:	e2823001 	add	r3, r2, #1
57e03778:	e0613003 	rsb	r3, r1, r3
57e0377c:	e0844003 	add	r4, r4, r3
					info->start[s_first[bank]],
					(s_last[bank] == info->sector_count) ?
						info->start[0] + info->size - 1:
						info->start[s_last[bank]+1] - 1,
					bank+1);
				rcode = flash_erase (info, s_first[bank], s_last[bank]);
57e03780:	eb004582 	bl	57e14d90 <flash_erase>
57e03784:	e1a06000 	mov	r6, r0
					s_first, s_last, &planned );

	if (planned && (rcode == 0)) {
		for (bank=0,info = &flash_info[0];
		     (bank < CONFIG_SYS_MAX_FLASH_BANKS) && (rcode == 0);
		     ++bank, ++info) {
57e03788:	e2855f42 	add	r5, r5, #264	; 0x108
57e0378c:	e3a03001 	mov	r3, #1
	rcode = flash_fill_sect_ranges (addr_first, addr_last,
					s_first, s_last, &planned );

	if (planned && (rcode == 0)) {
		for (bank=0,info = &flash_info[0];
		     (bank < CONFIG_SYS_MAX_FLASH_BANKS) && (rcode == 0);
57e03790:	e2233001 	eor	r3, r3, #1

	rcode = flash_fill_sect_ranges (addr_first, addr_last,
					s_first, s_last, &planned );

	if (planned && (rcode == 0)) {
		for (bank=0,info = &flash_info[0];
57e03794:	e3560000 	cmp	r6, #0
57e03798:	13a03000 	movne	r3, #0
57e0379c:	02033001 	andeq	r3, r3, #1
57e037a0:	e3530000 	cmp	r3, #0
57e037a4:	1affffec 	bne	57e0375c <flash_sect_erase+0x54>
						info->start[s_last[bank]+1] - 1,
					bank+1);
				rcode = flash_erase (info, s_first[bank], s_last[bank]);
			}
		}
		if (rcode == 0)
57e037a8:	e3560000 	cmp	r6, #0
57e037ac:	1a000008 	bne	57e037d4 <flash_sect_erase+0xcc>
			printf("Erased %d sectors\n", erased);
57e037b0:	e1a01004 	mov	r1, r4
57e037b4:	e59f0028 	ldr	r0, [pc, #40]	; 57e037e4 <flash_sect_erase+0xdc>
57e037b8:	eb001723 	bl	57e0944c <printf>
57e037bc:	ea000004 	b	57e037d4 <flash_sect_erase+0xcc>
	} else if (rcode == 0) {
57e037c0:	e3530000 	cmp	r3, #0
57e037c4:	0a000002 	beq	57e037d4 <flash_sect_erase+0xcc>
		puts ("Error: start and/or end address"
57e037c8:	e59f0018 	ldr	r0, [pc, #24]	; 57e037e8 <flash_sect_erase+0xe0>
57e037cc:	eb001714 	bl	57e09424 <puts>
			" not on sector boundary\n");
		rcode = 1;
57e037d0:	e3a06001 	mov	r6, #1
	}
	return rcode;
}
57e037d4:	e1a00006 	mov	r0, r6
57e037d8:	e28dd018 	add	sp, sp, #24
57e037dc:	e8bd8070 	pop	{r4, r5, r6, pc}
57e037e0:	57e47684 	.word	0x57e47684
57e037e4:	57e2f7f8 	.word	0x57e2f7f8
57e037e8:	57e2f80b 	.word	0x57e2f80b

57e037ec <do_flerase>:
#endif /* CONFIG_SYS_NO_FLASH */
	return 0;
}

static int do_flerase(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e037ec:	e92d4070 	push	{r4, r5, r6, lr}
	struct part_info *part;
	u8 dev_type, dev_num, pnum;
#endif
	int rcode = 0;

	if (argc < 2)
57e037f0:	e3520001 	cmp	r2, #1
#endif /* CONFIG_SYS_NO_FLASH */
	return 0;
}

static int do_flerase(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e037f4:	e24dd018 	sub	sp, sp, #24
57e037f8:	e1a04003 	mov	r4, r3
#ifndef CONFIG_SYS_NO_FLASH
	flash_info_t *info = NULL;
57e037fc:	e3a03000 	mov	r3, #0
#endif /* CONFIG_SYS_NO_FLASH */
	return 0;
}

static int do_flerase(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e03800:	e1a05002 	mov	r5, r2
#ifndef CONFIG_SYS_NO_FLASH
	flash_info_t *info = NULL;
57e03804:	e58d3014 	str	r3, [sp, #20]
	ulong bank, addr_first, addr_last;
	int n, sect_first = 0, sect_last = 0;
57e03808:	e58d3008 	str	r3, [sp, #8]
57e0380c:	e58d3004 	str	r3, [sp, #4]
	struct part_info *part;
	u8 dev_type, dev_num, pnum;
#endif
	int rcode = 0;

	if (argc < 2)
57e03810:	da000051 	ble	57e0395c <do_flerase+0x170>
		return CMD_RET_USAGE;

	if (strcmp(argv[1], "all") == 0) {
57e03814:	e5940004 	ldr	r0, [r4, #4]
57e03818:	e59f1148 	ldr	r1, [pc, #328]	; 57e03968 <do_flerase+0x17c>
57e0381c:	eb0081e0 	bl	57e23fa4 <strcmp>
57e03820:	e2506000 	subs	r6, r0, #0
57e03824:	1a000007 	bne	57e03848 <do_flerase+0x5c>
		for (bank=1; bank<=CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
			printf ("Erase Flash Bank # %ld ", bank);
57e03828:	e3a01001 	mov	r1, #1
57e0382c:	e59f0138 	ldr	r0, [pc, #312]	; 57e0396c <do_flerase+0x180>
57e03830:	eb001705 	bl	57e0944c <printf>
			info = &flash_info[bank-1];
57e03834:	e59f0134 	ldr	r0, [pc, #308]	; 57e03970 <do_flerase+0x184>
			rcode = flash_erase (info, 0, info->sector_count-1);
57e03838:	e1a01006 	mov	r1, r6
		return CMD_RET_USAGE;

	if (strcmp(argv[1], "all") == 0) {
		for (bank=1; bank<=CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
			printf ("Erase Flash Bank # %ld ", bank);
			info = &flash_info[bank-1];
57e0383c:	e58d0014 	str	r0, [sp, #20]
			rcode = flash_erase (info, 0, info->sector_count-1);
57e03840:	e1d020b4 	ldrh	r2, [r0, #4]
57e03844:	ea000032 	b	57e03914 <do_flerase+0x128>
		}
		return rcode;
	}

	if ((n = abbrev_spec(argv[1], &info, &sect_first, &sect_last)) != 0) {
57e03848:	e5940004 	ldr	r0, [r4, #4]
57e0384c:	e28d1014 	add	r1, sp, #20
57e03850:	e28d2008 	add	r2, sp, #8
57e03854:	e28d3004 	add	r3, sp, #4
57e03858:	ebfffed5 	bl	57e033b4 <abbrev_spec>
57e0385c:	e3500000 	cmp	r0, #0
57e03860:	0a000013 	beq	57e038b4 <do_flerase+0xc8>
		if (n < 0) {
57e03864:	aa000002 	bge	57e03874 <do_flerase+0x88>
			puts ("Bad sector specification\n");
57e03868:	e59f0104 	ldr	r0, [pc, #260]	; 57e03974 <do_flerase+0x188>
57e0386c:	eb0016ec 	bl	57e09424 <puts>
57e03870:	ea000031 	b	57e0393c <do_flerase+0x150>
			return 1;
		}
		printf ("Erase Flash Sectors %d-%d in Bank # %zu ",
			sect_first, sect_last, (info-flash_info)+1);
57e03874:	e59d2014 	ldr	r2, [sp, #20]
57e03878:	e59f30f0 	ldr	r3, [pc, #240]	; 57e03970 <do_flerase+0x184>
	if ((n = abbrev_spec(argv[1], &info, &sect_first, &sect_last)) != 0) {
		if (n < 0) {
			puts ("Bad sector specification\n");
			return 1;
		}
		printf ("Erase Flash Sectors %d-%d in Bank # %zu ",
57e0387c:	e59d1008 	ldr	r1, [sp, #8]
			sect_first, sect_last, (info-flash_info)+1);
57e03880:	e0633002 	rsb	r3, r3, r2
57e03884:	e59f20ec 	ldr	r2, [pc, #236]	; 57e03978 <do_flerase+0x18c>
57e03888:	e1a031c3 	asr	r3, r3, #3
57e0388c:	e0030392 	mul	r3, r2, r3
	if ((n = abbrev_spec(argv[1], &info, &sect_first, &sect_last)) != 0) {
		if (n < 0) {
			puts ("Bad sector specification\n");
			return 1;
		}
		printf ("Erase Flash Sectors %d-%d in Bank # %zu ",
57e03890:	e59f00e4 	ldr	r0, [pc, #228]	; 57e0397c <do_flerase+0x190>
57e03894:	e59d2004 	ldr	r2, [sp, #4]
57e03898:	e2833001 	add	r3, r3, #1
57e0389c:	eb0016ea 	bl	57e0944c <printf>
			sect_first, sect_last, (info-flash_info)+1);
		rcode = flash_erase(info, sect_first, sect_last);
57e038a0:	e59d0014 	ldr	r0, [sp, #20]
57e038a4:	e59d1008 	ldr	r1, [sp, #8]
57e038a8:	e59d2004 	ldr	r2, [sp, #4]
57e038ac:	eb004537 	bl	57e14d90 <flash_erase>
		return rcode;
57e038b0:	ea00002a 	b	57e03960 <do_flerase+0x174>
			return 1;
		}
	}
#endif

	if (argc != 3)
57e038b4:	e3550003 	cmp	r5, #3
57e038b8:	1a000027 	bne	57e0395c <do_flerase+0x170>
		return CMD_RET_USAGE;

	if (strcmp(argv[1], "bank") == 0) {
57e038bc:	e5940004 	ldr	r0, [r4, #4]
57e038c0:	e59f10b8 	ldr	r1, [pc, #184]	; 57e03980 <do_flerase+0x194>
57e038c4:	eb0081b6 	bl	57e23fa4 <strcmp>
57e038c8:	e2505000 	subs	r5, r0, #0
57e038cc:	1a000012 	bne	57e0391c <do_flerase+0x130>
		bank = simple_strtoul(argv[2], NULL, 16);
57e038d0:	e1a01005 	mov	r1, r5
57e038d4:	e5940008 	ldr	r0, [r4, #8]
57e038d8:	e3a02010 	mov	r2, #16
57e038dc:	eb0085f0 	bl	57e250a4 <simple_strtoul>
		if ((bank < 1) || (bank > CONFIG_SYS_MAX_FLASH_BANKS)) {
57e038e0:	e3500001 	cmp	r0, #1

	if (argc != 3)
		return CMD_RET_USAGE;

	if (strcmp(argv[1], "bank") == 0) {
		bank = simple_strtoul(argv[2], NULL, 16);
57e038e4:	e1a01000 	mov	r1, r0
		if ((bank < 1) || (bank > CONFIG_SYS_MAX_FLASH_BANKS)) {
57e038e8:	0a000003 	beq	57e038fc <do_flerase+0x110>
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
57e038ec:	e3a01001 	mov	r1, #1
57e038f0:	e59f008c 	ldr	r0, [pc, #140]	; 57e03984 <do_flerase+0x198>
57e038f4:	eb0016d4 	bl	57e0944c <printf>
57e038f8:	ea00000f 	b	57e0393c <do_flerase+0x150>
				CONFIG_SYS_MAX_FLASH_BANKS);
			return 1;
		}
		printf ("Erase Flash Bank # %ld ", bank);
57e038fc:	e59f0068 	ldr	r0, [pc, #104]	; 57e0396c <do_flerase+0x180>
57e03900:	eb0016d1 	bl	57e0944c <printf>
		info = &flash_info[bank-1];
57e03904:	e59f0064 	ldr	r0, [pc, #100]	; 57e03970 <do_flerase+0x184>
		rcode = flash_erase (info, 0, info->sector_count-1);
57e03908:	e1a01005 	mov	r1, r5
57e0390c:	e1d020b4 	ldrh	r2, [r0, #4]
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
				CONFIG_SYS_MAX_FLASH_BANKS);
			return 1;
		}
		printf ("Erase Flash Bank # %ld ", bank);
		info = &flash_info[bank-1];
57e03910:	e58d0014 	str	r0, [sp, #20]
		rcode = flash_erase (info, 0, info->sector_count-1);
57e03914:	e2422001 	sub	r2, r2, #1
57e03918:	eaffffe3 	b	57e038ac <do_flerase+0xc0>
		return rcode;
	}

	if (addr_spec(argv[1], argv[2], &addr_first, &addr_last) < 0){
57e0391c:	e9940003 	ldmib	r4, {r0, r1}
57e03920:	e28d2010 	add	r2, sp, #16
57e03924:	e28d300c 	add	r3, sp, #12
57e03928:	ebffff46 	bl	57e03648 <addr_spec>
57e0392c:	e3500000 	cmp	r0, #0
57e03930:	aa000003 	bge	57e03944 <do_flerase+0x158>
		printf ("Bad address format\n");
57e03934:	e59f004c 	ldr	r0, [pc, #76]	; 57e03988 <do_flerase+0x19c>
57e03938:	eb0016c3 	bl	57e0944c <printf>
		return 1;
57e0393c:	e3a00001 	mov	r0, #1
57e03940:	ea000006 	b	57e03960 <do_flerase+0x174>
	}

	if (addr_first >= addr_last)
57e03944:	e59d0010 	ldr	r0, [sp, #16]
57e03948:	e59d100c 	ldr	r1, [sp, #12]
57e0394c:	e1500001 	cmp	r0, r1
57e03950:	2a000001 	bcs	57e0395c <do_flerase+0x170>
		return CMD_RET_USAGE;

	rcode = flash_sect_erase(addr_first, addr_last);
57e03954:	ebffff6b 	bl	57e03708 <flash_sect_erase>
	return rcode;
57e03958:	ea000000 	b	57e03960 <do_flerase+0x174>
		printf ("Bad address format\n");
		return 1;
	}

	if (addr_first >= addr_last)
		return CMD_RET_USAGE;
57e0395c:	e3e00000 	mvn	r0, #0
	rcode = flash_sect_erase(addr_first, addr_last);
	return rcode;
#else
	return 0;
#endif /* CONFIG_SYS_NO_FLASH */
}
57e03960:	e28dd018 	add	sp, sp, #24
57e03964:	e8bd8070 	pop	{r4, r5, r6, pc}
57e03968:	57e2f843 	.word	0x57e2f843
57e0396c:	57e2f847 	.word	0x57e2f847
57e03970:	57e47684 	.word	0x57e47684
57e03974:	57e2f85f 	.word	0x57e2f85f
57e03978:	3e0f83e1 	.word	0x3e0f83e1
57e0397c:	57e2f879 	.word	0x57e2f879
57e03980:	57e2e41b 	.word	0x57e2e41b
57e03984:	57e2f7a3 	.word	0x57e2f7a3
57e03988:	57e2f8a2 	.word	0x57e2f8a2

57e0398c <flash_sect_protect>:
	return rcode;
}

#ifndef CONFIG_SYS_NO_FLASH
int flash_sect_protect (int p, ulong addr_first, ulong addr_last)
{
57e0398c:	e92d4010 	push	{r4, lr}
57e03990:	e24dd018 	sub	sp, sp, #24
	int s_first[CONFIG_SYS_MAX_FLASH_BANKS], s_last[CONFIG_SYS_MAX_FLASH_BANKS];
	int protected, i;
	int planned;
	int rcode;

	rcode = flash_fill_sect_ranges( addr_first, addr_last, s_first, s_last, &planned );
57e03994:	e28d300c 	add	r3, sp, #12
57e03998:	e58d3000 	str	r3, [sp]
	return rcode;
}

#ifndef CONFIG_SYS_NO_FLASH
int flash_sect_protect (int p, ulong addr_first, ulong addr_last)
{
57e0399c:	e1a04000 	mov	r4, r0
	int s_first[CONFIG_SYS_MAX_FLASH_BANKS], s_last[CONFIG_SYS_MAX_FLASH_BANKS];
	int protected, i;
	int planned;
	int rcode;

	rcode = flash_fill_sect_ranges( addr_first, addr_last, s_first, s_last, &planned );
57e039a0:	e28d3010 	add	r3, sp, #16
57e039a4:	e1a00001 	mov	r0, r1
57e039a8:	e1a01002 	mov	r1, r2
57e039ac:	e28d2014 	add	r2, sp, #20
57e039b0:	ebfffe0f 	bl	57e031f4 <flash_fill_sect_ranges>

	protected = 0;

	if (planned && (rcode == 0)) {
57e039b4:	e59d200c 	ldr	r2, [sp, #12]
57e039b8:	e2703001 	rsbs	r3, r0, #1
57e039bc:	33a03000 	movcc	r3, #0
57e039c0:	e3520000 	cmp	r2, #0
57e039c4:	03a02000 	moveq	r2, #0
57e039c8:	12032001 	andne	r2, r3, #1
57e039cc:	e3520000 	cmp	r2, #0
57e039d0:	1a000020 	bne	57e03a58 <flash_sect_protect+0xcc>
57e039d4:	ea000018 	b	57e03a3c <flash_sect_protect+0xb0>
		for (bank=0,info = &flash_info[0]; bank < CONFIG_SYS_MAX_FLASH_BANKS; ++bank, ++info) {
			if (info->flash_id == FLASH_UNKNOWN) {
				continue;
			}

			if (s_first[bank]>=0 && s_first[bank]<=s_last[bank]) {
57e039d8:	e59d3014 	ldr	r3, [sp, #20]
57e039dc:	e3530000 	cmp	r3, #0
57e039e0:	ba00000c 	blt	57e03a18 <flash_sect_protect+0x8c>
57e039e4:	e59d0010 	ldr	r0, [sp, #16]
57e039e8:	e1530000 	cmp	r3, r0
57e039ec:	ca000009 	bgt	57e03a18 <flash_sect_protect+0x8c>
				debug ("%sProtecting sectors %d..%d in bank %ld\n",
					p ? "" : "Un-",
					s_first[bank], s_last[bank], bank+1);
				protected += s_last[bank] - s_first[bank] + 1;
57e039f0:	e2802001 	add	r2, r0, #1
57e039f4:	e0632002 	rsb	r2, r3, r2
#endif /* CONFIG_SYS_NO_FLASH */
	return rcode;
}

#ifndef CONFIG_SYS_NO_FLASH
int flash_sect_protect (int p, ulong addr_first, ulong addr_last)
57e039f8:	e0813003 	add	r3, r1, r3
57e039fc:	e28110ac 	add	r1, r1, #172	; 0xac
57e03a00:	e28330ab 	add	r3, r3, #171	; 0xab
57e03a04:	e0810000 	add	r0, r1, r0
#if defined(CONFIG_SYS_FLASH_PROTECTION)
					if (flash_real_protect(info, i, p))
						rcode = 1;
					putc ('.');
#else
					info->protect[i] = p;
57e03a08:	e5e34001 	strb	r4, [r3, #1]!
			if (s_first[bank]>=0 && s_first[bank]<=s_last[bank]) {
				debug ("%sProtecting sectors %d..%d in bank %ld\n",
					p ? "" : "Un-",
					s_first[bank], s_last[bank], bank+1);
				protected += s_last[bank] - s_first[bank] + 1;
				for (i=s_first[bank]; i<=s_last[bank]; ++i) {
57e03a0c:	e1530000 	cmp	r3, r0
57e03a10:	1afffffc 	bne	57e03a08 <flash_sect_protect+0x7c>
57e03a14:	ea000000 	b	57e03a1c <flash_sect_protect+0x90>

	protected = 0;

	if (planned && (rcode == 0)) {
		for (bank=0,info = &flash_info[0]; bank < CONFIG_SYS_MAX_FLASH_BANKS; ++bank, ++info) {
			if (info->flash_id == FLASH_UNKNOWN) {
57e03a18:	e3a02000 	mov	r2, #0
		}
#if defined(CONFIG_SYS_FLASH_PROTECTION)
		puts (" done\n");
#endif	/* CONFIG_SYS_FLASH_PROTECTION */

		printf ("%sProtected %d sectors\n",
57e03a1c:	e59f304c 	ldr	r3, [pc, #76]	; 57e03a70 <flash_sect_protect+0xe4>
57e03a20:	e3540000 	cmp	r4, #0
57e03a24:	e59f1048 	ldr	r1, [pc, #72]	; 57e03a74 <flash_sect_protect+0xe8>
57e03a28:	e59f0048 	ldr	r0, [pc, #72]	; 57e03a78 <flash_sect_protect+0xec>
57e03a2c:	11a01003 	movne	r1, r3
57e03a30:	eb001685 	bl	57e0944c <printf>
57e03a34:	e3a00000 	mov	r0, #0
57e03a38:	ea000004 	b	57e03a50 <flash_sect_protect+0xc4>
			p ? "" : "Un-", protected);
	} else if (rcode == 0) {
57e03a3c:	e3530000 	cmp	r3, #0
57e03a40:	0a000002 	beq	57e03a50 <flash_sect_protect+0xc4>
		puts ("Error: start and/or end address"
57e03a44:	e59f0030 	ldr	r0, [pc, #48]	; 57e03a7c <flash_sect_protect+0xf0>
57e03a48:	eb001675 	bl	57e09424 <puts>
			" not on sector boundary\n");
		rcode = 1;
57e03a4c:	e3a00001 	mov	r0, #1
	}
	return rcode;
}
57e03a50:	e28dd018 	add	sp, sp, #24
57e03a54:	e8bd8010 	pop	{r4, pc}

	protected = 0;

	if (planned && (rcode == 0)) {
		for (bank=0,info = &flash_info[0]; bank < CONFIG_SYS_MAX_FLASH_BANKS; ++bank, ++info) {
			if (info->flash_id == FLASH_UNKNOWN) {
57e03a58:	e59f1020 	ldr	r1, [pc, #32]	; 57e03a80 <flash_sect_protect+0xf4>
57e03a5c:	e59f3020 	ldr	r3, [pc, #32]	; 57e03a84 <flash_sect_protect+0xf8>
57e03a60:	e5912008 	ldr	r2, [r1, #8]
57e03a64:	e1520003 	cmp	r2, r3
57e03a68:	1affffda 	bne	57e039d8 <flash_sect_protect+0x4c>
57e03a6c:	eaffffe9 	b	57e03a18 <flash_sect_protect+0x8c>
57e03a70:	57e302de 	.word	0x57e302de
57e03a74:	57e2f8b6 	.word	0x57e2f8b6
57e03a78:	57e2f8ba 	.word	0x57e2f8ba
57e03a7c:	57e2f80b 	.word	0x57e2f80b
57e03a80:	57e47684 	.word	0x57e47684
57e03a84:	0000ffff 	.word	0x0000ffff

57e03a88 <do_protect>:
	return rcode;
}
#endif /* CONFIG_SYS_NO_FLASH */

static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e03a88:	e92d40f0 	push	{r4, r5, r6, r7, lr}
#if !defined(CONFIG_SYS_NO_FLASH) || defined(CONFIG_HAS_DATAFLASH)
	int p;
	ulong addr_first, addr_last;
#endif

	if (argc < 3)
57e03a8c:	e3520002 	cmp	r2, #2
	return rcode;
}
#endif /* CONFIG_SYS_NO_FLASH */

static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e03a90:	e24dd024 	sub	sp, sp, #36	; 0x24
57e03a94:	e1a05003 	mov	r5, r3
	int rcode = 0;
#ifndef CONFIG_SYS_NO_FLASH
	flash_info_t *info = NULL;
57e03a98:	e3a03000 	mov	r3, #0
	return rcode;
}
#endif /* CONFIG_SYS_NO_FLASH */

static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e03a9c:	e1a06002 	mov	r6, r2
	int rcode = 0;
#ifndef CONFIG_SYS_NO_FLASH
	flash_info_t *info = NULL;
57e03aa0:	e58d301c 	str	r3, [sp, #28]
	ulong bank;
	int i, n, sect_first = 0, sect_last = 0;
57e03aa4:	e58d3018 	str	r3, [sp, #24]
57e03aa8:	e58d3014 	str	r3, [sp, #20]
#if !defined(CONFIG_SYS_NO_FLASH) || defined(CONFIG_HAS_DATAFLASH)
	int p;
	ulong addr_first, addr_last;
#endif

	if (argc < 3)
57e03aac:	da000088 	ble	57e03cd4 <do_protect+0x24c>
		return CMD_RET_USAGE;

#if !defined(CONFIG_SYS_NO_FLASH) || defined(CONFIG_HAS_DATAFLASH)
	if (strcmp(argv[1], "off") == 0)
57e03ab0:	e5950004 	ldr	r0, [r5, #4]
57e03ab4:	e59f1224 	ldr	r1, [pc, #548]	; 57e03ce0 <do_protect+0x258>
57e03ab8:	eb008139 	bl	57e23fa4 <strcmp>
57e03abc:	e2504000 	subs	r4, r0, #0
57e03ac0:	0a000005 	beq	57e03adc <do_protect+0x54>
		p = 0;
	else if (strcmp(argv[1], "on") == 0)
57e03ac4:	e5950004 	ldr	r0, [r5, #4]
57e03ac8:	e59f1214 	ldr	r1, [pc, #532]	; 57e03ce4 <do_protect+0x25c>
57e03acc:	eb008134 	bl	57e23fa4 <strcmp>
57e03ad0:	e3500000 	cmp	r0, #0
57e03ad4:	1a00007e 	bne	57e03cd4 <do_protect+0x24c>
		p = 1;
57e03ad8:	e3a04001 	mov	r4, #1
		}
	}
#endif

#ifndef CONFIG_SYS_NO_FLASH
	if (strcmp(argv[2], "all") == 0) {
57e03adc:	e5950008 	ldr	r0, [r5, #8]
57e03ae0:	e59f1200 	ldr	r1, [pc, #512]	; 57e03ce8 <do_protect+0x260>
57e03ae4:	eb00812e 	bl	57e23fa4 <strcmp>
57e03ae8:	e2507000 	subs	r7, r0, #0
57e03aec:	1a000016 	bne	57e03b4c <do_protect+0xc4>
		for (bank=1; bank<=CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
			info = &flash_info[bank-1];
57e03af0:	e59f31f4 	ldr	r3, [pc, #500]	; 57e03cec <do_protect+0x264>
			if (info->flash_id == FLASH_UNKNOWN) {
57e03af4:	e5932008 	ldr	r2, [r3, #8]
#endif

#ifndef CONFIG_SYS_NO_FLASH
	if (strcmp(argv[2], "all") == 0) {
		for (bank=1; bank<=CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
			info = &flash_info[bank-1];
57e03af8:	e58d301c 	str	r3, [sp, #28]
			if (info->flash_id == FLASH_UNKNOWN) {
57e03afc:	e59f31ec 	ldr	r3, [pc, #492]	; 57e03cf0 <do_protect+0x268>
57e03b00:	e1520003 	cmp	r2, r3
			}
#if defined(CONFIG_SYS_FLASH_PROTECTION)
			if (!rcode) puts (" done\n");
#endif	/* CONFIG_SYS_FLASH_PROTECTION */
		}
		return rcode;
57e03b04:	01a00007 	moveq	r0, r7

#ifndef CONFIG_SYS_NO_FLASH
	if (strcmp(argv[2], "all") == 0) {
		for (bank=1; bank<=CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
			info = &flash_info[bank-1];
			if (info->flash_id == FLASH_UNKNOWN) {
57e03b08:	0a000072 	beq	57e03cd8 <do_protect+0x250>
				continue;
			}
			printf ("%sProtect Flash Bank # %ld\n",
57e03b0c:	e59f31e0 	ldr	r3, [pc, #480]	; 57e03cf4 <do_protect+0x26c>
57e03b10:	e3540000 	cmp	r4, #0
57e03b14:	e59f11dc 	ldr	r1, [pc, #476]	; 57e03cf8 <do_protect+0x270>
57e03b18:	e3a02001 	mov	r2, #1
57e03b1c:	11a01003 	movne	r1, r3
57e03b20:	e59f01d4 	ldr	r0, [pc, #468]	; 57e03cfc <do_protect+0x274>
57e03b24:	eb001648 	bl	57e0944c <printf>
				p ? "" : "Un-", bank);

			for (i=0; i<info->sector_count; ++i) {
57e03b28:	e59d301c 	ldr	r3, [sp, #28]
57e03b2c:	e1d320b4 	ldrh	r2, [r3, #4]
	}
	return rcode;
}
#endif /* CONFIG_SYS_NO_FLASH */

static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
57e03b30:	e28330ab 	add	r3, r3, #171	; 0xab
				continue;
			}
			printf ("%sProtect Flash Bank # %ld\n",
				p ? "" : "Un-", bank);

			for (i=0; i<info->sector_count; ++i) {
57e03b34:	ea000001 	b	57e03b40 <do_protect+0xb8>
#if defined(CONFIG_SYS_FLASH_PROTECTION)
				if (flash_real_protect(info, i, p))
					rcode = 1;
				putc ('.');
#else
				info->protect[i] = p;
57e03b38:	e5e34001 	strb	r4, [r3, #1]!
				continue;
			}
			printf ("%sProtect Flash Bank # %ld\n",
				p ? "" : "Un-", bank);

			for (i=0; i<info->sector_count; ++i) {
57e03b3c:	e2877001 	add	r7, r7, #1
57e03b40:	e1570002 	cmp	r7, r2
57e03b44:	bafffffb 	blt	57e03b38 <do_protect+0xb0>
57e03b48:	ea00004d 	b	57e03c84 <do_protect+0x1fc>
#endif	/* CONFIG_SYS_FLASH_PROTECTION */
		}
		return rcode;
	}

	if ((n = abbrev_spec(argv[2], &info, &sect_first, &sect_last)) != 0) {
57e03b4c:	e5950008 	ldr	r0, [r5, #8]
57e03b50:	e28d101c 	add	r1, sp, #28
57e03b54:	e28d2018 	add	r2, sp, #24
57e03b58:	e28d3014 	add	r3, sp, #20
57e03b5c:	ebfffe14 	bl	57e033b4 <abbrev_spec>
57e03b60:	e3500000 	cmp	r0, #0
57e03b64:	0a00001e 	beq	57e03be4 <do_protect+0x15c>
		if (n < 0) {
57e03b68:	aa000002 	bge	57e03b78 <do_protect+0xf0>
			puts ("Bad sector specification\n");
57e03b6c:	e59f018c 	ldr	r0, [pc, #396]	; 57e03d00 <do_protect+0x278>
57e03b70:	eb00162b 	bl	57e09424 <puts>
57e03b74:	ea00004d 	b	57e03cb0 <do_protect+0x228>
			return 1;
		}
		printf("%sProtect Flash Sectors %d-%d in Bank # %zu\n",
			p ? "" : "Un-", sect_first, sect_last,
			(info-flash_info)+1);
57e03b78:	e59d201c 	ldr	r2, [sp, #28]
57e03b7c:	e59f3168 	ldr	r3, [pc, #360]	; 57e03cec <do_protect+0x264>
	if ((n = abbrev_spec(argv[2], &info, &sect_first, &sect_last)) != 0) {
		if (n < 0) {
			puts ("Bad sector specification\n");
			return 1;
		}
		printf("%sProtect Flash Sectors %d-%d in Bank # %zu\n",
57e03b80:	e3540000 	cmp	r4, #0
			p ? "" : "Un-", sect_first, sect_last,
			(info-flash_info)+1);
57e03b84:	e0633002 	rsb	r3, r3, r2
57e03b88:	e59f2174 	ldr	r2, [pc, #372]	; 57e03d04 <do_protect+0x27c>
57e03b8c:	e1a031c3 	asr	r3, r3, #3
57e03b90:	e0030392 	mul	r3, r2, r3
	if ((n = abbrev_spec(argv[2], &info, &sect_first, &sect_last)) != 0) {
		if (n < 0) {
			puts ("Bad sector specification\n");
			return 1;
		}
		printf("%sProtect Flash Sectors %d-%d in Bank # %zu\n",
57e03b94:	e2833001 	add	r3, r3, #1
57e03b98:	e58d3000 	str	r3, [sp]
57e03b9c:	e59f3150 	ldr	r3, [pc, #336]	; 57e03cf4 <do_protect+0x26c>
57e03ba0:	e59f1150 	ldr	r1, [pc, #336]	; 57e03cf8 <do_protect+0x270>
57e03ba4:	e59d2018 	ldr	r2, [sp, #24]
57e03ba8:	11a01003 	movne	r1, r3
57e03bac:	e59f0154 	ldr	r0, [pc, #340]	; 57e03d08 <do_protect+0x280>
57e03bb0:	e59d3014 	ldr	r3, [sp, #20]
57e03bb4:	eb001624 	bl	57e0944c <printf>
			p ? "" : "Un-", sect_first, sect_last,
			(info-flash_info)+1);
		for (i = sect_first; i <= sect_last; i++) {
57e03bb8:	e59d3018 	ldr	r3, [sp, #24]
	}
	return rcode;
}
#endif /* CONFIG_SYS_NO_FLASH */

static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
57e03bbc:	e59d201c 	ldr	r2, [sp, #28]
			return 1;
		}
		printf("%sProtect Flash Sectors %d-%d in Bank # %zu\n",
			p ? "" : "Un-", sect_first, sect_last,
			(info-flash_info)+1);
		for (i = sect_first; i <= sect_last; i++) {
57e03bc0:	e59d1014 	ldr	r1, [sp, #20]
	}
	return rcode;
}
#endif /* CONFIG_SYS_NO_FLASH */

static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
57e03bc4:	e0822003 	add	r2, r2, r3
57e03bc8:	e28220ab 	add	r2, r2, #171	; 0xab
			return 1;
		}
		printf("%sProtect Flash Sectors %d-%d in Bank # %zu\n",
			p ? "" : "Un-", sect_first, sect_last,
			(info-flash_info)+1);
		for (i = sect_first; i <= sect_last; i++) {
57e03bcc:	ea000001 	b	57e03bd8 <do_protect+0x150>
#if defined(CONFIG_SYS_FLASH_PROTECTION)
			if (flash_real_protect(info, i, p))
				rcode =  1;
			putc ('.');
#else
			info->protect[i] = p;
57e03bd0:	e5e24001 	strb	r4, [r2, #1]!
			return 1;
		}
		printf("%sProtect Flash Sectors %d-%d in Bank # %zu\n",
			p ? "" : "Un-", sect_first, sect_last,
			(info-flash_info)+1);
		for (i = sect_first; i <= sect_last; i++) {
57e03bd4:	e2833001 	add	r3, r3, #1
57e03bd8:	e1530001 	cmp	r3, r1
57e03bdc:	dafffffb 	ble	57e03bd0 <do_protect+0x148>
57e03be0:	ea000027 	b	57e03c84 <do_protect+0x1fc>
			return 1;
		}
	}
#endif

	if (argc != 4)
57e03be4:	e3560004 	cmp	r6, #4
57e03be8:	1a000039 	bne	57e03cd4 <do_protect+0x24c>
		return CMD_RET_USAGE;

	if (strcmp(argv[2], "bank") == 0) {
57e03bec:	e59f1118 	ldr	r1, [pc, #280]	; 57e03d0c <do_protect+0x284>
57e03bf0:	e5950008 	ldr	r0, [r5, #8]
57e03bf4:	eb0080ea 	bl	57e23fa4 <strcmp>
57e03bf8:	e2501000 	subs	r1, r0, #0
57e03bfc:	1a000022 	bne	57e03c8c <do_protect+0x204>
		bank = simple_strtoul(argv[3], NULL, 16);
57e03c00:	e595000c 	ldr	r0, [r5, #12]
57e03c04:	e3a02010 	mov	r2, #16
57e03c08:	eb008525 	bl	57e250a4 <simple_strtoul>
		if ((bank < 1) || (bank > CONFIG_SYS_MAX_FLASH_BANKS)) {
57e03c0c:	e3500001 	cmp	r0, #1

	if (argc != 4)
		return CMD_RET_USAGE;

	if (strcmp(argv[2], "bank") == 0) {
		bank = simple_strtoul(argv[3], NULL, 16);
57e03c10:	e1a05000 	mov	r5, r0
		if ((bank < 1) || (bank > CONFIG_SYS_MAX_FLASH_BANKS)) {
57e03c14:	0a000003 	beq	57e03c28 <do_protect+0x1a0>
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
57e03c18:	e3a01001 	mov	r1, #1
57e03c1c:	e59f00ec 	ldr	r0, [pc, #236]	; 57e03d10 <do_protect+0x288>
57e03c20:	eb001609 	bl	57e0944c <printf>
57e03c24:	ea000021 	b	57e03cb0 <do_protect+0x228>
				CONFIG_SYS_MAX_FLASH_BANKS);
			return 1;
		}
		printf ("%sProtect Flash Bank # %ld\n",
57e03c28:	e59f30c4 	ldr	r3, [pc, #196]	; 57e03cf4 <do_protect+0x26c>
57e03c2c:	e3540000 	cmp	r4, #0
57e03c30:	e59f10c0 	ldr	r1, [pc, #192]	; 57e03cf8 <do_protect+0x270>
57e03c34:	e1a02005 	mov	r2, r5
57e03c38:	11a01003 	movne	r1, r3
57e03c3c:	e59f00b8 	ldr	r0, [pc, #184]	; 57e03cfc <do_protect+0x274>
57e03c40:	eb001601 	bl	57e0944c <printf>
			p ? "" : "Un-", bank);
		info = &flash_info[bank-1];
57e03c44:	e59f20a0 	ldr	r2, [pc, #160]	; 57e03cec <do_protect+0x264>

		if (info->flash_id == FLASH_UNKNOWN) {
57e03c48:	e59f30a0 	ldr	r3, [pc, #160]	; 57e03cf0 <do_protect+0x268>
57e03c4c:	e5921008 	ldr	r1, [r2, #8]
				CONFIG_SYS_MAX_FLASH_BANKS);
			return 1;
		}
		printf ("%sProtect Flash Bank # %ld\n",
			p ? "" : "Un-", bank);
		info = &flash_info[bank-1];
57e03c50:	e58d201c 	str	r2, [sp, #28]

		if (info->flash_id == FLASH_UNKNOWN) {
57e03c54:	e1510003 	cmp	r1, r3
57e03c58:	128230ab 	addne	r3, r2, #171	; 0xab
	}
	return rcode;
}
#endif /* CONFIG_SYS_NO_FLASH */

static int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
57e03c5c:	11d220b4 	ldrhne	r2, [r2, #4]
57e03c60:	10832002 	addne	r2, r3, r2
		}
		printf ("%sProtect Flash Bank # %ld\n",
			p ? "" : "Un-", bank);
		info = &flash_info[bank-1];

		if (info->flash_id == FLASH_UNKNOWN) {
57e03c64:	1a000004 	bne	57e03c7c <do_protect+0x1f4>
			puts ("missing or unknown FLASH type\n");
57e03c68:	e59f00a4 	ldr	r0, [pc, #164]	; 57e03d14 <do_protect+0x28c>
57e03c6c:	eb0015ec 	bl	57e09424 <puts>
			return 1;
57e03c70:	e1a00005 	mov	r0, r5
57e03c74:	ea000017 	b	57e03cd8 <do_protect+0x250>
#if defined(CONFIG_SYS_FLASH_PROTECTION)
			if (flash_real_protect(info, i, p))
				rcode =  1;
			putc ('.');
#else
			info->protect[i] = p;
57e03c78:	e5e34001 	strb	r4, [r3, #1]!

		if (info->flash_id == FLASH_UNKNOWN) {
			puts ("missing or unknown FLASH type\n");
			return 1;
		}
		for (i=0; i<info->sector_count; ++i) {
57e03c7c:	e1530002 	cmp	r3, r2
57e03c80:	1afffffc 	bne	57e03c78 <do_protect+0x1f0>

#if defined(CONFIG_SYS_FLASH_PROTECTION)
		if (!rcode) puts (" done\n");
#endif	/* CONFIG_SYS_FLASH_PROTECTION */

		return rcode;
57e03c84:	e3a00000 	mov	r0, #0
57e03c88:	ea000012 	b	57e03cd8 <do_protect+0x250>
	}

	if (addr_spec(argv[2], argv[3], &addr_first, &addr_last) < 0){
57e03c8c:	e5950008 	ldr	r0, [r5, #8]
57e03c90:	e595100c 	ldr	r1, [r5, #12]
57e03c94:	e28d2010 	add	r2, sp, #16
57e03c98:	e28d300c 	add	r3, sp, #12
57e03c9c:	ebfffe69 	bl	57e03648 <addr_spec>
57e03ca0:	e3500000 	cmp	r0, #0
57e03ca4:	aa000003 	bge	57e03cb8 <do_protect+0x230>
		printf("Bad address format\n");
57e03ca8:	e59f0068 	ldr	r0, [pc, #104]	; 57e03d18 <do_protect+0x290>
57e03cac:	eb0015e6 	bl	57e0944c <printf>
		return 1;
57e03cb0:	e3a00001 	mov	r0, #1
57e03cb4:	ea000007 	b	57e03cd8 <do_protect+0x250>
	}

	if (addr_first >= addr_last)
57e03cb8:	e59d1010 	ldr	r1, [sp, #16]
57e03cbc:	e59d200c 	ldr	r2, [sp, #12]
57e03cc0:	e1510002 	cmp	r1, r2
57e03cc4:	2a000002 	bcs	57e03cd4 <do_protect+0x24c>
		return CMD_RET_USAGE;

	rcode = flash_sect_protect (p, addr_first, addr_last);
57e03cc8:	e1a00004 	mov	r0, r4
57e03ccc:	ebffff2e 	bl	57e0398c <flash_sect_protect>
#endif /* CONFIG_SYS_NO_FLASH */
	return rcode;
57e03cd0:	ea000000 	b	57e03cd8 <do_protect+0x250>
		printf("Bad address format\n");
		return 1;
	}

	if (addr_first >= addr_last)
		return CMD_RET_USAGE;
57e03cd4:	e3e00000 	mvn	r0, #0

	rcode = flash_sect_protect (p, addr_first, addr_last);
#endif /* CONFIG_SYS_NO_FLASH */
	return rcode;
}
57e03cd8:	e28dd024 	add	sp, sp, #36	; 0x24
57e03cdc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
57e03ce0:	57e2e48c 	.word	0x57e2e48c
57e03ce4:	57e357fe 	.word	0x57e357fe
57e03ce8:	57e2f843 	.word	0x57e2f843
57e03cec:	57e47684 	.word	0x57e47684
57e03cf0:	0000ffff 	.word	0x0000ffff
57e03cf4:	57e302de 	.word	0x57e302de
57e03cf8:	57e2f8b6 	.word	0x57e2f8b6
57e03cfc:	57e2f8d2 	.word	0x57e2f8d2
57e03d00:	57e2f85f 	.word	0x57e2f85f
57e03d04:	3e0f83e1 	.word	0x3e0f83e1
57e03d08:	57e2f8ee 	.word	0x57e2f8ee
57e03d0c:	57e2e41b 	.word	0x57e2e41b
57e03d10:	57e2f7a3 	.word	0x57e2f7a3
57e03d14:	57e2f91b 	.word	0x57e2f91b
57e03d18:	57e2f8a2 	.word	0x57e2f8a2

57e03d1c <do_help>:

#include <common.h>
#include <command.h>

static int do_help(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e03d1c:	e92d4007 	push	{r0, r1, r2, lr}
57e03d20:	e1a0c001 	mov	ip, r1
57e03d24:	e1a0e000 	mov	lr, r0
	cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
	const int len = ll_entry_count(cmd_tbl_t, cmd);
57e03d28:	e59f1028 	ldr	r1, [pc, #40]	; 57e03d58 <do_help+0x3c>
	return _do_help(start, len, cmdtp, flag, argc, argv);
57e03d2c:	e59f0028 	ldr	r0, [pc, #40]	; 57e03d5c <do_help+0x40>
57e03d30:	e58d3004 	str	r3, [sp, #4]
#include <command.h>

static int do_help(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
	const int len = ll_entry_count(cmd_tbl_t, cmd);
57e03d34:	e0601001 	rsb	r1, r0, r1
	return _do_help(start, len, cmdtp, flag, argc, argv);
57e03d38:	e59f3020 	ldr	r3, [pc, #32]	; 57e03d60 <do_help+0x44>
#include <command.h>

static int do_help(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
	const int len = ll_entry_count(cmd_tbl_t, cmd);
57e03d3c:	e1a011c1 	asr	r1, r1, #3
	return _do_help(start, len, cmdtp, flag, argc, argv);
57e03d40:	e58d2000 	str	r2, [sp]
57e03d44:	e0010193 	mul	r1, r3, r1
57e03d48:	e1a0200e 	mov	r2, lr
57e03d4c:	e1a0300c 	mov	r3, ip
57e03d50:	eb00147d 	bl	57e08f4c <_do_help>
}
57e03d54:	e8bd800e 	pop	{r1, r2, r3, pc}
	...
57e03d60:	aaaaaaab 	.word	0xaaaaaaab

57e03d64 <evalstr>:
}

static char * evalstr(char *s)
{
	/* if the parameter starts with a * then assume a string pointer else its a literal */
	if (s[0] == '*') {
57e03d64:	e5d02000 	ldrb	r2, [r0]
57e03d68:	e352002a 	cmp	r2, #42	; 0x2a
57e03d6c:	112fff1e 	bxne	lr
		return (char *)simple_strtoul(&s[1], NULL, 16);
57e03d70:	e2800001 	add	r0, r0, #1
57e03d74:	e3a01000 	mov	r1, #0
57e03d78:	e3a02010 	mov	r2, #16
57e03d7c:	ea0084c8 	b	57e250a4 <simple_strtoul>

57e03d80 <evalexp>:
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
57e03d80:	e92d4010 	push	{r4, lr}
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
57e03d84:	e5d02000 	ldrb	r2, [r0]
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
57e03d88:	e1a04001 	mov	r4, r1
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
57e03d8c:	e352002a 	cmp	r2, #42	; 0x2a
57e03d90:	1a00000d 	bne	57e03dcc <evalexp+0x4c>
		p = (long *)simple_strtoul(&s[1], NULL, 16);
57e03d94:	e2800001 	add	r0, r0, #1
57e03d98:	e3a01000 	mov	r1, #0
57e03d9c:	e3a02010 	mov	r2, #16
57e03da0:	eb0084bf 	bl	57e250a4 <simple_strtoul>
		switch (w) {
57e03da4:	e3540002 	cmp	r4, #2
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
57e03da8:	01d000b0 	ldrheq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
57e03dac:	08bd8010 	popeq	{r4, pc}
57e03db0:	e3540004 	cmp	r4, #4
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
57e03db4:	05900000 	ldreq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
57e03db8:	08bd8010 	popeq	{r4, pc}
57e03dbc:	e3540001 	cmp	r4, #1
		case 1: return((long)(*(unsigned char *)p));
57e03dc0:	05d00000 	ldrbeq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
57e03dc4:	1a000004 	bne	57e03ddc <evalexp+0x5c>
57e03dc8:	e8bd8010 	pop	{r4, pc}
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
57e03dcc:	e3a01000 	mov	r1, #0
57e03dd0:	e3a02010 	mov	r2, #16
57e03dd4:	eb0084b2 	bl	57e250a4 <simple_strtoul>
57e03dd8:	ea000000 	b	57e03de0 <evalexp+0x60>
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
	long l = 0;
57e03ddc:	e3a00000 	mov	r0, #0
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
	}

	return (l & ((1 << (w * 8)) - 1));
57e03de0:	e1a04184 	lsl	r4, r4, #3
57e03de4:	e3e03000 	mvn	r3, #0
57e03de8:	e1c00413 	bic	r0, r0, r3, lsl r4
}
57e03dec:	e8bd8010 	pop	{r4, pc}

57e03df0 <binary_test>:
	}
	return (0);
}

static int binary_test(char *op, char *arg1, char *arg2, int w)
{
57e03df0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e03df4:	e1a09000 	mov	r9, r0
57e03df8:	e1a05001 	mov	r5, r1
57e03dfc:	e1a04002 	mov	r4, r2
57e03e00:	e1a07003 	mov	r7, r3
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
57e03e04:	eb008091 	bl	57e24050 <strlen>
	case GE: return (l >= r);
	}
	return (0);
}

static int binary_test(char *op, char *arg1, char *arg2, int w)
57e03e08:	e59fb190 	ldr	fp, [pc, #400]	; 57e03fa0 <binary_test+0x1b0>
{
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
57e03e0c:	e1a0a000 	mov	sl, r0

	for (optp = (op_tbl_t *)&op_table, i = 0;
57e03e10:	e59f618c 	ldr	r6, [pc, #396]	; 57e03fa4 <binary_test+0x1b4>
57e03e14:	ea000058 	b	57e03f7c <binary_test+0x18c>
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {

		if ((strncmp (op, optp->op, len) == 0) && (len == strlen (optp->op))) {
57e03e18:	e1a00009 	mov	r0, r9
57e03e1c:	e5961000 	ldr	r1, [r6]
57e03e20:	e1a0200a 	mov	r2, sl
57e03e24:	eb00806a 	bl	57e23fd4 <strncmp>
57e03e28:	e3500000 	cmp	r0, #0
57e03e2c:	1a000051 	bne	57e03f78 <binary_test+0x188>
57e03e30:	e5960000 	ldr	r0, [r6]
57e03e34:	eb008085 	bl	57e24050 <strlen>
57e03e38:	e15a0000 	cmp	sl, r0
57e03e3c:	1a00004d 	bne	57e03f78 <binary_test+0x188>
			if (w == 0) {
57e03e40:	e3570000 	cmp	r7, #0
57e03e44:	e5966004 	ldr	r6, [r6, #4]
57e03e48:	1a000023 	bne	57e03edc <binary_test+0xec>
static int stringcomp(char *s, char *t, int op)
{
	int p;
	char *l, *r;

	l = evalstr(s);
57e03e4c:	e1a00005 	mov	r0, r5
57e03e50:	ebffffc3 	bl	57e03d64 <evalstr>
57e03e54:	e1a05000 	mov	r5, r0
	r = evalstr(t);
57e03e58:	e1a00004 	mov	r0, r4
57e03e5c:	ebffffc0 	bl	57e03d64 <evalstr>
57e03e60:	e1a01000 	mov	r1, r0

	p = strcmp(l, r);
57e03e64:	e1a00005 	mov	r0, r5
57e03e68:	eb00804d 	bl	57e23fa4 <strcmp>
	switch (op) {
57e03e6c:	e3560005 	cmp	r6, #5
57e03e70:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
57e03e74:	ea000045 	b	57e03f90 <binary_test+0x1a0>
57e03e78:	57e03e90 	.word	0x57e03e90
57e03e7c:	57e03e9c 	.word	0x57e03e9c
57e03e80:	57e03ea8 	.word	0x57e03ea8
57e03e84:	57e03eb0 	.word	0x57e03eb0
57e03e88:	57e03ec0 	.word	0x57e03ec0
57e03e8c:	57e03ed0 	.word	0x57e03ed0
	case EQ: return (p == 0);
57e03e90:	e2700001 	rsbs	r0, r0, #1
57e03e94:	33a00000 	movcc	r0, #0
57e03e98:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (p != 0);
57e03e9c:	e2500000 	subs	r0, r0, #0
57e03ea0:	13a00001 	movne	r0, #1
57e03ea4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (p < 0);
57e03ea8:	e1a00fa0 	lsr	r0, r0, #31
57e03eac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (p > 0);
57e03eb0:	e3500000 	cmp	r0, #0
57e03eb4:	d3a00000 	movle	r0, #0
57e03eb8:	c3a00001 	movgt	r0, #1
57e03ebc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (p <= 0);
57e03ec0:	e3500000 	cmp	r0, #0
57e03ec4:	c3a00000 	movgt	r0, #0
57e03ec8:	d3a00001 	movle	r0, #1
57e03ecc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (p >= 0);
57e03ed0:	e1e00000 	mvn	r0, r0
57e03ed4:	e1a00fa0 	lsr	r0, r0, #31
57e03ed8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
57e03edc:	e1a00005 	mov	r0, r5
57e03ee0:	e1a01007 	mov	r1, r7
57e03ee4:	ebffffa5 	bl	57e03d80 <evalexp>
	r = evalexp (t, w);
57e03ee8:	e1a01007 	mov	r1, r7

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
57e03eec:	e1a05000 	mov	r5, r0
	r = evalexp (t, w);
57e03ef0:	e1a00004 	mov	r0, r4
57e03ef4:	ebffffa1 	bl	57e03d80 <evalexp>

	switch (op) {
57e03ef8:	e3560005 	cmp	r6, #5
57e03efc:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
57e03f00:	ea000024 	b	57e03f98 <binary_test+0x1a8>
57e03f04:	57e03f1c 	.word	0x57e03f1c
57e03f08:	57e03f2c 	.word	0x57e03f2c
57e03f0c:	57e03f38 	.word	0x57e03f38
57e03f10:	57e03f48 	.word	0x57e03f48
57e03f14:	57e03f58 	.word	0x57e03f58
57e03f18:	57e03f68 	.word	0x57e03f68
	case EQ: return (l == r);
57e03f1c:	e1550000 	cmp	r5, r0
57e03f20:	13a00000 	movne	r0, #0
57e03f24:	03a00001 	moveq	r0, #1
57e03f28:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (l != r);
57e03f2c:	e0550000 	subs	r0, r5, r0
57e03f30:	13a00001 	movne	r0, #1
57e03f34:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
57e03f38:	e1550000 	cmp	r5, r0
57e03f3c:	a3a00000 	movge	r0, #0
57e03f40:	b3a00001 	movlt	r0, #1
57e03f44:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (l > r);
57e03f48:	e1550000 	cmp	r5, r0
57e03f4c:	d3a00000 	movle	r0, #0
57e03f50:	c3a00001 	movgt	r0, #1
57e03f54:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (l <= r);
57e03f58:	e1550000 	cmp	r5, r0
57e03f5c:	c3a00000 	movgt	r0, #0
57e03f60:	d3a00001 	movle	r0, #1
57e03f64:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (l >= r);
57e03f68:	e1550000 	cmp	r5, r0
57e03f6c:	b3a00000 	movlt	r0, #0
57e03f70:	a3a00001 	movge	r0, #1
57e03f74:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {
57e03f78:	e2866008 	add	r6, r6, #8
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
57e03f7c:	e156000b 	cmp	r6, fp
57e03f80:	1affffa4 	bne	57e03e18 <binary_test+0x28>
				return (arithcomp (arg1, arg2, optp->opcode, w));
			}
		}
	}

	printf("Unknown operator '%s'\n", op);
57e03f84:	e59f001c 	ldr	r0, [pc, #28]	; 57e03fa8 <binary_test+0x1b8>
57e03f88:	e1a01009 	mov	r1, r9
57e03f8c:	eb00152e 	bl	57e0944c <printf>
	case LT: return (p < 0);
	case GT: return (p > 0);
	case LE: return (p <= 0);
	case GE: return (p >= 0);
	}
	return (0);
57e03f90:	e3a00000 	mov	r0, #0
57e03f94:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
	case GT: return (l > r);
	case LE: return (l <= r);
	case GE: return (l >= r);
	}
	return (0);
57e03f98:	e3a00000 	mov	r0, #0
		}
	}

	printf("Unknown operator '%s'\n", op);
	return 0;	/* op code not found */
}
57e03f9c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e03fa0:	57e2bd94 	.word	0x57e2bd94
57e03fa4:	57e2bd2c 	.word	0x57e2bd2c
57e03fa8:	57e2fe8a 	.word	0x57e2fe8a

57e03fac <do_itest>:
static int do_itest(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
57e03fac:	e3520004 	cmp	r2, #4
	return 0;	/* op code not found */
}

/* command line interface to the shell test */
static int do_itest(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e03fb0:	e92d4010 	push	{r4, lr}
57e03fb4:	e1a04003 	mov	r4, r3
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
57e03fb8:	1a00001e 	bne	57e04038 <do_itest+0x8c>

	/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 */
	switch (w = cmd_get_data_size(argv[0], 4)) {
57e03fbc:	e5930000 	ldr	r0, [r3]
57e03fc0:	e1a01002 	mov	r1, r2
57e03fc4:	eb001442 	bl	57e090d4 <cmd_get_data_size>
57e03fc8:	e2802002 	add	r2, r0, #2
57e03fcc:	e1a03000 	mov	r3, r0
57e03fd0:	e3520006 	cmp	r2, #6
57e03fd4:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
57e03fd8:	ea000010 	b	57e04020 <do_itest+0x74>
57e03fdc:	57e04008 	.word	0x57e04008
57e03fe0:	57e04020 	.word	0x57e04020
57e03fe4:	57e04020 	.word	0x57e04020
57e03fe8:	57e03ff8 	.word	0x57e03ff8
57e03fec:	57e03ff8 	.word	0x57e03ff8
57e03ff0:	57e04020 	.word	0x57e04020
57e03ff4:	57e03ff8 	.word	0x57e03ff8
	case 1:
	case 2:
	case 4:
		value = binary_test (argv[2], argv[1], argv[3], w);
57e03ff8:	e5940008 	ldr	r0, [r4, #8]
57e03ffc:	e5941004 	ldr	r1, [r4, #4]
57e04000:	e594200c 	ldr	r2, [r4, #12]
57e04004:	ea000003 	b	57e04018 <do_itest+0x6c>
		break;
	case -2:
		value = binary_test (argv[2], argv[1], argv[3], 0);
57e04008:	e5940008 	ldr	r0, [r4, #8]
57e0400c:	e5941004 	ldr	r1, [r4, #4]
57e04010:	e594200c 	ldr	r2, [r4, #12]
57e04014:	e3a03000 	mov	r3, #0
57e04018:	ebffff74 	bl	57e03df0 <binary_test>
		break;
57e0401c:	ea000002 	b	57e0402c <do_itest+0x80>
	case -1:
	default:
		puts("Invalid data width specifier\n");
57e04020:	e59f0018 	ldr	r0, [pc, #24]	; 57e04040 <do_itest+0x94>
57e04024:	eb0014fe 	bl	57e09424 <puts>
		value = 0;
57e04028:	e3a00000 	mov	r0, #0
		break;
	}

	return !value;
57e0402c:	e2700001 	rsbs	r0, r0, #1
57e04030:	33a00000 	movcc	r0, #0
57e04034:	e8bd8010 	pop	{r4, pc}
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
		return CMD_RET_USAGE;
57e04038:	e3e00000 	mvn	r0, #0
		value = 0;
		break;
	}

	return !value;
}
57e0403c:	e8bd8010 	pop	{r4, pc}
57e04040:	57e2fea1 	.word	0x57e2fea1

57e04044 <ktrans>:
}

/* converts escaped kermit char to binary char */
static char ktrans(char in)
{
	if ((in & 0x60) == 0x40) {
57e04044:	e2003060 	and	r3, r0, #96	; 0x60
57e04048:	e3530040 	cmp	r3, #64	; 0x40
		return (char) (in & ~0x40);
57e0404c:	020000bf 	andeq	r0, r0, #191	; 0xbf
}

/* converts escaped kermit char to binary char */
static char ktrans(char in)
{
	if ((in & 0x60) == 0x40) {
57e04050:	012fff1e 	bxeq	lr
		return (char) (in & ~0x40);
	} else if ((in & 0x7f) == 0x3f) {
57e04054:	e200307f 	and	r3, r0, #127	; 0x7f
57e04058:	e353003f 	cmp	r3, #63	; 0x3f
		return (char) (in | 0x40);
57e0405c:	03800040 	orreq	r0, r0, #64	; 0x40
	} else
		return in;
}
57e04060:	e12fff1e 	bx	lr

57e04064 <bin_data_init>:
static char *os_data_addr, *os_data_addr_saved;
static char *bin_start_address;

static void bin_data_init(void)
{
	os_data_state = 0;
57e04064:	e59f3010 	ldr	r3, [pc, #16]	; 57e0407c <bin_data_init+0x18>
57e04068:	e3a02000 	mov	r2, #0
57e0406c:	e5832000 	str	r2, [r3]
	os_data_addr = bin_start_address;
57e04070:	e5932008 	ldr	r2, [r3, #8]
57e04074:	e5832004 	str	r2, [r3, #4]
}
57e04078:	e12fff1e 	bx	lr
57e0407c:	57e3836c 	.word	0x57e3836c

57e04080 <bin_data_char>:
	os_data_addr = os_data_addr_saved;
}

static void bin_data_char(char new_char)
{
	switch (os_data_state) {
57e04080:	e59f3014 	ldr	r3, [pc, #20]	; 57e0409c <bin_data_char+0x1c>
57e04084:	e5932000 	ldr	r2, [r3]
57e04088:	e3520000 	cmp	r2, #0
	case 0:					/* data */
		*os_data_addr++ = new_char;
57e0408c:	05932004 	ldreq	r2, [r3, #4]
57e04090:	04c20001 	strbeq	r0, [r2], #1
57e04094:	05832004 	streq	r2, [r3, #4]
57e04098:	e12fff1e 	bx	lr
57e0409c:	57e3836c 	.word	0x57e3836c

57e040a0 <k_data_save>:
	os_data_init();
}

static void k_data_save(void)
{
	k_data_escape_saved = k_data_escape;
57e040a0:	e59f3018 	ldr	r3, [pc, #24]	; 57e040c0 <k_data_save+0x20>
57e040a4:	e5932010 	ldr	r2, [r3, #16]
57e040a8:	e583200c 	str	r2, [r3, #12]
	os_data_addr = bin_start_address;
}

static void os_data_save(void)
{
	os_data_state_saved = os_data_state;
57e040ac:	e5932000 	ldr	r2, [r3]
57e040b0:	e5832014 	str	r2, [r3, #20]
	os_data_addr_saved = os_data_addr;
57e040b4:	e5932004 	ldr	r2, [r3, #4]
57e040b8:	e5832018 	str	r2, [r3, #24]

static void k_data_save(void)
{
	k_data_escape_saved = k_data_escape;
	os_data_save();
}
57e040bc:	e12fff1e 	bx	lr
57e040c0:	57e3836c 	.word	0x57e3836c

57e040c4 <k_data_restore>:

static void k_data_restore(void)
{
	k_data_escape = k_data_escape_saved;
57e040c4:	e59f3018 	ldr	r3, [pc, #24]	; 57e040e4 <k_data_restore+0x20>
57e040c8:	e593200c 	ldr	r2, [r3, #12]
57e040cc:	e5832010 	str	r2, [r3, #16]
	os_data_addr_saved = os_data_addr;
}

static void os_data_restore(void)
{
	os_data_state = os_data_state_saved;
57e040d0:	e5932014 	ldr	r2, [r3, #20]
57e040d4:	e5832000 	str	r2, [r3]
	os_data_addr = os_data_addr_saved;
57e040d8:	e5932018 	ldr	r2, [r3, #24]
57e040dc:	e5832004 	str	r2, [r3, #4]

static void k_data_restore(void)
{
	k_data_escape = k_data_escape_saved;
	os_data_restore();
}
57e040e0:	e12fff1e 	bx	lr
57e040e4:	57e3836c 	.word	0x57e3836c

57e040e8 <load_serial_ymodem>:
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem(ulong offset)
{
57e040e8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e040ec:	e24dde43 	sub	sp, sp, #1072	; 0x430
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open(&info, &err);
57e040f0:	e28d9e42 	add	r9, sp, #1056	; 0x420
57e040f4:	e289900c 	add	r9, r9, #12
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
57e040f8:	e3a03002 	mov	r3, #2
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem(ulong offset)
{
57e040fc:	e1a05000 	mov	r5, r0
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open(&info, &err);
57e04100:	e1a01009 	mov	r1, r9
57e04104:	e28d0e42 	add	r0, sp, #1056	; 0x420
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
57e04108:	e58d3424 	str	r3, [sp, #1060]	; 0x424
	res = xyzModem_stream_open(&info, &err);
57e0410c:	eb003a09 	bl	57e12938 <xyzModem_stream_open>
	if (!res) {
57e04110:	e2506000 	subs	r6, r0, #0
57e04114:	01a04006 	moveq	r4, r6

		while ((res =
			xyzModem_stream_read(ymodemBuf, 1024, &err)) > 0) {
57e04118:	01a0a00d 	moveq	sl, sp
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open(&info, &err);
	if (!res) {
57e0411c:	0a000014 	beq	57e04174 <load_serial_ymodem+0x8c>
57e04120:	ea00001a 	b	57e04190 <load_serial_ymodem+0xa8>

		while ((res =
			xyzModem_stream_read(ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
57e04124:	e086b005 	add	fp, r6, r5
			size += res;
			addr += res;
#ifndef CONFIG_SYS_NO_FLASH
			if (addr2info(store_addr)) {
57e04128:	e1a0000b 	mov	r0, fp
57e0412c:	eb001eca 	bl	57e0bc5c <addr2info>
57e04130:	e3500000 	cmp	r0, #0
57e04134:	0a000008 	beq	57e0415c <load_serial_ymodem+0x74>
				int rc;

				rc = flash_write((char *) ymodemBuf,
57e04138:	e1a0000d 	mov	r0, sp
57e0413c:	e1a0100b 	mov	r1, fp
57e04140:	e1a02007 	mov	r2, r7
57e04144:	eb001ed8 	bl	57e0bcac <flash_write>
						  store_addr, res);
				if (rc != 0) {
57e04148:	e3500000 	cmp	r0, #0
57e0414c:	0a000006 	beq	57e0416c <load_serial_ymodem+0x84>
					flash_perror (rc);
57e04150:	eb001f2d 	bl	57e0be0c <flash_perror>
					return (~0);
57e04154:	e3e05000 	mvn	r5, #0
57e04158:	ea000027 	b	57e041fc <load_serial_ymodem+0x114>
				}
			} else
#endif
			{
				memcpy((char *)(store_addr), ymodemBuf,
57e0415c:	e1a0000b 	mov	r0, fp
57e04160:	e1a0100d 	mov	r1, sp
57e04164:	e1a02007 	mov	r2, r7
57e04168:	eb008067 	bl	57e2430c <memcpy>
	if (!res) {

		while ((res =
			xyzModem_stream_read(ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
			size += res;
57e0416c:	e0844007 	add	r4, r4, r7
			addr += res;
57e04170:	e0866007 	add	r6, r6, r7
	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open(&info, &err);
	if (!res) {

		while ((res =
57e04174:	e1a0000d 	mov	r0, sp
57e04178:	e3a01b01 	mov	r1, #1024	; 0x400
57e0417c:	e1a02009 	mov	r2, r9
57e04180:	eb003a7e 	bl	57e12b80 <xyzModem_stream_read>
57e04184:	e2507000 	subs	r7, r0, #0
57e04188:	caffffe5 	bgt	57e04124 <load_serial_ymodem+0x3c>
57e0418c:	ea000005 	b	57e041a8 <load_serial_ymodem+0xc0>
					res);
			}

		}
	} else {
		printf("%s\n", xyzModem_error(err));
57e04190:	e59d042c 	ldr	r0, [sp, #1068]	; 0x42c
57e04194:	eb003b46 	bl	57e12eb4 <xyzModem_error>
57e04198:	e1a01000 	mov	r1, r0
57e0419c:	e59f0064 	ldr	r0, [pc, #100]	; 57e04208 <load_serial_ymodem+0x120>
57e041a0:	eb0014a9 	bl	57e0944c <printf>
	connection_info_t info;
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
57e041a4:	e3a04000 	mov	r4, #0
		}
	} else {
		printf("%s\n", xyzModem_error(err));
	}

	xyzModem_stream_close(&err);
57e041a8:	e28d0e42 	add	r0, sp, #1056	; 0x420
57e041ac:	e280000c 	add	r0, r0, #12
57e041b0:	eb003b06 	bl	57e12dd0 <xyzModem_stream_close>
	xyzModem_stream_terminate(false, &getcxmodem);
57e041b4:	e3a00000 	mov	r0, #0
57e041b8:	e59f104c 	ldr	r1, [pc, #76]	; 57e0420c <load_serial_ymodem+0x124>
57e041bc:	eb003b17 	bl	57e12e20 <xyzModem_stream_terminate>


	flush_cache(offset, size);
57e041c0:	e1a00005 	mov	r0, r5
57e041c4:	e1a01004 	mov	r1, r4
57e041c8:	ebfff476 	bl	57e013a8 <__flush_cache>

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf(buf, "%X", size);
57e041cc:	e28d6b01 	add	r6, sp, #1024	; 0x400
	xyzModem_stream_terminate(false, &getcxmodem);


	flush_cache(offset, size);

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
57e041d0:	e1a01004 	mov	r1, r4
57e041d4:	e1a02004 	mov	r2, r4
57e041d8:	e59f0030 	ldr	r0, [pc, #48]	; 57e04210 <load_serial_ymodem+0x128>
57e041dc:	eb00149a 	bl	57e0944c <printf>
	sprintf(buf, "%X", size);
57e041e0:	e59f102c 	ldr	r1, [pc, #44]	; 57e04214 <load_serial_ymodem+0x12c>
57e041e4:	e1a00006 	mov	r0, r6
57e041e8:	e1a02004 	mov	r2, r4
57e041ec:	eb008455 	bl	57e25348 <sprintf>
	setenv("filesize", buf);
57e041f0:	e59f0020 	ldr	r0, [pc, #32]	; 57e04218 <load_serial_ymodem+0x130>
57e041f4:	e1a01006 	mov	r1, r6
57e041f8:	eb000c2c 	bl	57e072b0 <setenv>

	return offset;
}
57e041fc:	e1a00005 	mov	r0, r5
57e04200:	e28dde43 	add	sp, sp, #1072	; 0x430
57e04204:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e04208:	57e31b63 	.word	0x57e31b63
57e0420c:	57e0421c 	.word	0x57e0421c
57e04210:	57e2ff3d 	.word	0x57e2ff3d
57e04214:	57e2ff65 	.word	0x57e2ff65
57e04218:	57e2ea14 	.word	0x57e2ea14

57e0421c <getcxmodem>:
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
57e0421c:	e92d4010 	push	{r4, lr}
	if (tstc())
57e04220:	eb00146c 	bl	57e093d8 <tstc>
57e04224:	e3500000 	cmp	r0, #0
57e04228:	0a000001 	beq	57e04234 <getcxmodem+0x18>
		return (getc());
	return -1;
}
57e0422c:	e8bd4010 	pop	{r4, lr}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
	if (tstc())
		return (getc());
57e04230:	ea00145f 	b	57e093b4 <getc>
	return -1;
}
57e04234:	e3e00000 	mvn	r0, #0
57e04238:	e8bd8010 	pop	{r4, pc}

57e0423c <load_serial>:
#endif
	return rcode;
}

static ulong load_serial(long offset)
{
57e0423c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;
57e04240:	e3a05000 	mov	r5, #0
#endif
	return rcode;
}

static ulong load_serial(long offset)
{
57e04244:	e24ddd0d 	sub	sp, sp, #832	; 0x340
	int	type;				/* return code for record type	*/
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
57e04248:	e3e04000 	mvn	r4, #0
#endif
	return rcode;
}

static ulong load_serial(long offset)
{
57e0424c:	e58d000c 	str	r0, [sp, #12]
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
57e04250:	e1a07005 	mov	r7, r5
	}
#endif
	return rcode;
}

static ulong load_serial(long offset)
57e04254:	e28d9f85 	add	r9, sp, #532	; 0x214

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
		if (do_echo)
57e04258:	e59f6204 	ldr	r6, [pc, #516]	; 57e04464 <load_serial+0x228>
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
57e0425c:	e1a0b005 	mov	fp, r5
57e04260:	e1a0a004 	mov	sl, r4
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
57e04264:	ea000050 	b	57e043ac <load_serial+0x170>
		type = srec_decode(record, &binlen, &addr, binbuf);
57e04268:	e28d0010 	add	r0, sp, #16
57e0426c:	e28d1fcf 	add	r1, sp, #828	; 0x33c
57e04270:	e28d2fce 	add	r2, sp, #824	; 0x338
57e04274:	e28d3f86 	add	r3, sp, #536	; 0x218
57e04278:	eb002d05 	bl	57e0f694 <srec_decode>

		if (type < 0) {
57e0427c:	e3500000 	cmp	r0, #0
57e04280:	ba000074 	blt	57e04458 <load_serial+0x21c>
			return (~0);		/* Invalid S-Record		*/
		}

		switch (type) {
57e04284:	e2400001 	sub	r0, r0, #1
57e04288:	e3500008 	cmp	r0, #8
57e0428c:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
57e04290:	ea00003a 	b	57e04380 <load_serial+0x144>
57e04294:	57e042b8 	.word	0x57e042b8
57e04298:	57e042b8 	.word	0x57e042b8
57e0429c:	57e042b8 	.word	0x57e042b8
57e042a0:	57e04380 	.word	0x57e04380
57e042a4:	57e04380 	.word	0x57e04380
57e042a8:	57e04380 	.word	0x57e04380
57e042ac:	57e04324 	.word	0x57e04324
57e042b0:	57e04324 	.word	0x57e04324
57e042b4:	57e04324 	.word	0x57e04324
		case SREC_DATA2:
		case SREC_DATA3:
		case SREC_DATA4:
		    store_addr = addr + offset;
57e042b8:	e59d4338 	ldr	r4, [sp, #824]	; 0x338
57e042bc:	e59d200c 	ldr	r2, [sp, #12]
57e042c0:	e0824004 	add	r4, r2, r4
#ifndef CONFIG_SYS_NO_FLASH
		    if (addr2info(store_addr)) {
57e042c4:	e1a00004 	mov	r0, r4
57e042c8:	eb001e63 	bl	57e0bc5c <addr2info>
57e042cc:	e3500000 	cmp	r0, #0
57e042d0:	e28d1f86 	add	r1, sp, #536	; 0x218
57e042d4:	0a000007 	beq	57e042f8 <load_serial+0xbc>
			int rc;

			rc = flash_write((char *)binbuf,store_addr,binlen);
57e042d8:	e1a00001 	mov	r0, r1
57e042dc:	e59d233c 	ldr	r2, [sp, #828]	; 0x33c
57e042e0:	e1a01004 	mov	r1, r4
57e042e4:	eb001e70 	bl	57e0bcac <flash_write>
			if (rc != 0) {
57e042e8:	e3500000 	cmp	r0, #0
57e042ec:	0a000004 	beq	57e04304 <load_serial+0xc8>
				flash_perror(rc);
57e042f0:	eb001ec5 	bl	57e0be0c <flash_perror>
57e042f4:	ea000057 	b	57e04458 <load_serial+0x21c>
				return (~0);
			}
		    } else
#endif
		    {
			memcpy((char *)(store_addr), binbuf, binlen);
57e042f8:	e1a00004 	mov	r0, r4
57e042fc:	e59d233c 	ldr	r2, [sp, #828]	; 0x33c
57e04300:	eb008001 	bl	57e2430c <memcpy>
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
57e04304:	e59d333c 	ldr	r3, [sp, #828]	; 0x33c
				return (~0);
			}
		    } else
#endif
		    {
			memcpy((char *)(store_addr), binbuf, binlen);
57e04308:	e15a0004 	cmp	sl, r4
57e0430c:	21a0a004 	movcs	sl, r4
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
57e04310:	e2433001 	sub	r3, r3, #1
57e04314:	e0834004 	add	r4, r3, r4
57e04318:	e1570004 	cmp	r7, r4
57e0431c:	31a07004 	movcc	r7, r4
57e04320:	ea000016 	b	57e04380 <load_serial+0x144>
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay(10000);
		    size = end_addr - start_addr + 1;
57e04324:	e2875001 	add	r5, r7, #1
57e04328:	e06a5005 	rsb	r5, sl, r5
			end_addr = store_addr + binlen - 1;
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay(10000);
57e0432c:	e59f0134 	ldr	r0, [pc, #308]	; 57e04468 <load_serial+0x22c>
57e04330:	eb008080 	bl	57e24538 <udelay>
		    size = end_addr - start_addr + 1;
		    printf("\n"
57e04334:	e1a03005 	mov	r3, r5
57e04338:	e1a02007 	mov	r2, r7
57e0433c:	e1a0100a 	mov	r1, sl
57e04340:	e59f0124 	ldr	r0, [pc, #292]	; 57e0446c <load_serial+0x230>
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache(start_addr, size);
		    sprintf(buf, "%lX", size);
57e04344:	e28d4fc6 	add	r4, sp, #792	; 0x318
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay(10000);
		    size = end_addr - start_addr + 1;
		    printf("\n"
57e04348:	e58d5000 	str	r5, [sp]
57e0434c:	eb00143e 	bl	57e0944c <printf>
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache(start_addr, size);
57e04350:	e1a0000a 	mov	r0, sl
57e04354:	e1a01005 	mov	r1, r5
57e04358:	ebfff412 	bl	57e013a8 <__flush_cache>
		    sprintf(buf, "%lX", size);
57e0435c:	e59f110c 	ldr	r1, [pc, #268]	; 57e04470 <load_serial+0x234>
57e04360:	e1a02005 	mov	r2, r5
57e04364:	e1a00004 	mov	r0, r4
57e04368:	eb0083f6 	bl	57e25348 <sprintf>
		    setenv("filesize", buf);
57e0436c:	e59f0100 	ldr	r0, [pc, #256]	; 57e04474 <load_serial+0x238>
57e04370:	e1a01004 	mov	r1, r4
57e04374:	eb000bcd 	bl	57e072b0 <setenv>
		    return (addr);
57e04378:	e59d0338 	ldr	r0, [sp, #824]	; 0x338
57e0437c:	ea000036 	b	57e0445c <load_serial+0x220>
		case SREC_START:
		    break;
		default:
		    break;
		}
		if (!do_echo) {	/* print a '.' every 100 lines */
57e04380:	e5963000 	ldr	r3, [r6]
57e04384:	e3530000 	cmp	r3, #0
57e04388:	1a000007 	bne	57e043ac <load_serial+0x170>
			if ((++line_count % 100) == 0)
57e0438c:	e2855001 	add	r5, r5, #1
57e04390:	e1a00005 	mov	r0, r5
57e04394:	e3a01064 	mov	r1, #100	; 0x64
57e04398:	eb009e0f 	bl	57e2bbdc <__aeabi_idivmod>
57e0439c:	e3510000 	cmp	r1, #0
57e043a0:	1a000001 	bne	57e043ac <load_serial+0x170>
				putc('.');
57e043a4:	e3a0002e 	mov	r0, #46	; 0x2e
57e043a8:	eb001413 	bl	57e093fc <putc>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
57e043ac:	e28d3010 	add	r3, sp, #16
57e043b0:	e58d5008 	str	r5, [sp, #8]
57e043b4:	e1a05003 	mov	r5, r3
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
57e043b8:	eb0013fd 	bl	57e093b4 <getc>
		if (do_echo)
57e043bc:	e5963000 	ldr	r3, [r6]
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
57e043c0:	e20040ff 	and	r4, r0, #255	; 0xff
		if (do_echo)
57e043c4:	e3530000 	cmp	r3, #0
57e043c8:	0a000001 	beq	57e043d4 <load_serial+0x198>
			putc(c);	/* ... and echo it		*/
57e043cc:	e1a00004 	mov	r0, r4
57e043d0:	eb001409 	bl	57e093fc <putc>

		switch (c) {
57e043d4:	e3540003 	cmp	r4, #3
57e043d8:	0a00001e 	beq	57e04458 <load_serial+0x21c>
57e043dc:	8a000002 	bhi	57e043ec <load_serial+0x1b0>
57e043e0:	e3540000 	cmp	r4, #0
57e043e4:	0a00001b 	beq	57e04458 <load_serial+0x21c>
57e043e8:	ea000009 	b	57e04414 <load_serial+0x1d8>
57e043ec:	e354000a 	cmp	r4, #10
57e043f0:	0a000001 	beq	57e043fc <load_serial+0x1c0>
57e043f4:	e354000d 	cmp	r4, #13
57e043f8:	1a000005 	bne	57e04414 <load_serial+0x1d8>
57e043fc:	e1a03005 	mov	r3, r5
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
57e04400:	e28d2010 	add	r2, sp, #16
57e04404:	e59d5008 	ldr	r5, [sp, #8]
			putc(c);	/* ... and echo it		*/

		switch (c) {
		case '\r':
		case '\n':
			*p = '\0';
57e04408:	e5c3b000 	strb	fp, [r3]
			return (p - buf);
57e0440c:	e0623003 	rsb	r3, r2, r3
57e04410:	ea00000e 	b	57e04450 <load_serial+0x214>
		case '\0':
		case 0x03:			/* ^C - Control C		*/
			return (-1);
		default:
			*p = c;
57e04414:	e4c54001 	strb	r4, [r5], #1
		}

	    /* Check for the console hangup (if any different from serial) */
	    if (gd->jt[XF_getc] != getc) {
57e04418:	e5983054 	ldr	r3, [r8, #84]	; 0x54
57e0441c:	e59f2054 	ldr	r2, [pc, #84]	; 57e04478 <load_serial+0x23c>
57e04420:	e5933004 	ldr	r3, [r3, #4]
57e04424:	e1530002 	cmp	r3, r2
57e04428:	0a000002 	beq	57e04438 <load_serial+0x1fc>
		if (ctrlc()) {
57e0442c:	eb00142b 	bl	57e094e0 <ctrlc>
57e04430:	e3500000 	cmp	r0, #0
57e04434:	1a000007 	bne	57e04458 <load_serial+0x21c>
	char *p;
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
57e04438:	e1550009 	cmp	r5, r9
57e0443c:	1affffdd 	bne	57e043b8 <load_serial+0x17c>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
57e04440:	e28d3010 	add	r3, sp, #16
57e04444:	e59d5008 	ldr	r5, [sp, #8]
	    }
	}

	/* line too long - truncate */
	*p = '\0';
	return (p - buf);
57e04448:	e0633009 	rsb	r3, r3, r9
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
57e0444c:	e5c9b000 	strb	fp, [r9]
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
57e04450:	e3530000 	cmp	r3, #0
57e04454:	aaffff83 	bge	57e04268 <load_serial+0x2c>
			if ((++line_count % 100) == 0)
				putc('.');
		}
	}

	return (~0);			/* Download aborted		*/
57e04458:	e3e00000 	mvn	r0, #0
}
57e0445c:	e28ddd0d 	add	sp, sp, #832	; 0x340
57e04460:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e04464:	57e36224 	.word	0x57e36224
57e04468:	00002710 	.word	0x00002710
57e0446c:	57e2ff68 	.word	0x57e2ff68
57e04470:	57e2ea10 	.word	0x57e2ea10
57e04474:	57e2ea14 	.word	0x57e2ea14
57e04478:	57e093b4 	.word	0x57e093b4

57e0447c <do_load_serial>:
/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
static int do_load_serial(cmd_tbl_t *cmdtp, int flag, int argc,
			  char * const argv[])
{
57e0447c:	e92d4038 	push	{r3, r4, r5, lr}
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
57e04480:	e59f00b8 	ldr	r0, [pc, #184]	; 57e04540 <do_load_serial+0xc4>
/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
static int do_load_serial(cmd_tbl_t *cmdtp, int flag, int argc,
			  char * const argv[])
{
57e04484:	e1a04002 	mov	r4, r2
57e04488:	e1a05003 	mov	r5, r3
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
57e0448c:	eb000c95 	bl	57e076e8 <getenv>
57e04490:	e3500000 	cmp	r0, #0
57e04494:	0a000003 	beq	57e044a8 <do_load_serial+0x2c>
57e04498:	e5d03000 	ldrb	r3, [r0]
57e0449c:	e3530031 	cmp	r3, #49	; 0x31
		do_echo = 1;
57e044a0:	03a02001 	moveq	r2, #1
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
57e044a4:	0a000000 	beq	57e044ac <do_load_serial+0x30>
		do_echo = 1;
	} else {
		do_echo = 0;
57e044a8:	e3a02000 	mov	r2, #0
57e044ac:	e59f3090 	ldr	r3, [pc, #144]	; 57e04544 <do_load_serial+0xc8>
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
57e044b0:	e3540002 	cmp	r4, #2
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
		do_echo = 1;
	} else {
		do_echo = 0;
57e044b4:	e5832000 	str	r2, [r3]

#if defined(CONFIG_CMD_LOADS)
static int do_load_serial(cmd_tbl_t *cmdtp, int flag, int argc,
			  char * const argv[])
{
	long offset = 0;
57e044b8:	13a04000 	movne	r4, #0
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
57e044bc:	1a000004 	bne	57e044d4 <do_load_serial+0x58>
		offset = simple_strtol(argv[1], NULL, 16);
57e044c0:	e5950004 	ldr	r0, [r5, #4]
57e044c4:	e3a01000 	mov	r1, #0
57e044c8:	e3a02010 	mov	r2, #16
57e044cc:	eb00833d 	bl	57e251c8 <simple_strtol>
57e044d0:	e1a04000 	mov	r4, r0
	}
#endif	/* CONFIG_SYS_LOADS_BAUD_CHANGE */

	printf("## Ready for S-Record download ...\n");
57e044d4:	e59f006c 	ldr	r0, [pc, #108]	; 57e04548 <do_load_serial+0xcc>
57e044d8:	eb0013db 	bl	57e0944c <printf>

	addr = load_serial(offset);
57e044dc:	e1a00004 	mov	r0, r4
57e044e0:	ebffff55 	bl	57e0423c <load_serial>
57e044e4:	e3a04064 	mov	r4, #100	; 0x64
57e044e8:	e1a05000 	mov	r5, r0
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
57e044ec:	eb0013b9 	bl	57e093d8 <tstc>
57e044f0:	e3500000 	cmp	r0, #0
57e044f4:	0a000000 	beq	57e044fc <do_load_serial+0x80>
			(void) getc();
57e044f8:	eb0013ad 	bl	57e093b4 <getc>
		}
		udelay(1000);
57e044fc:	e3a00ffa 	mov	r0, #1000	; 0x3e8
57e04500:	eb00800c 	bl	57e24538 <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
57e04504:	e2544001 	subs	r4, r4, #1
57e04508:	1afffff7 	bne	57e044ec <do_load_serial+0x70>
			(void) getc();
		}
		udelay(1000);
	}

	if (addr == ~0) {
57e0450c:	e3750001 	cmn	r5, #1
57e04510:	1a000003 	bne	57e04524 <do_load_serial+0xa8>
		printf("## S-Record download aborted\n");
57e04514:	e59f0030 	ldr	r0, [pc, #48]	; 57e0454c <do_load_serial+0xd0>
57e04518:	eb0013cb 	bl	57e0944c <printf>
		rcode = 1;
57e0451c:	e3a00001 	mov	r0, #1
57e04520:	e8bd8038 	pop	{r3, r4, r5, pc}
	} else {
		printf("## Start Addr      = 0x%08lX\n", addr);
57e04524:	e1a01005 	mov	r1, r5
57e04528:	e59f0020 	ldr	r0, [pc, #32]	; 57e04550 <do_load_serial+0xd4>
57e0452c:	eb0013c6 	bl	57e0944c <printf>
		load_addr = addr;
57e04530:	e59f301c 	ldr	r3, [pc, #28]	; 57e04554 <do_load_serial+0xd8>
{
	long offset = 0;
	ulong addr;
	int i;
	char *env_echo;
	int rcode = 0;
57e04534:	e1a00004 	mov	r0, r4
	if (addr == ~0) {
		printf("## S-Record download aborted\n");
		rcode = 1;
	} else {
		printf("## Start Addr      = 0x%08lX\n", addr);
		load_addr = addr;
57e04538:	e5835000 	str	r5, [r3]
				break;
		}
	}
#endif
	return rcode;
}
57e0453c:	e8bd8038 	pop	{r3, r4, r5, pc}
57e04540:	57e2ffcd 	.word	0x57e2ffcd
57e04544:	57e36224 	.word	0x57e36224
57e04548:	57e2ffd8 	.word	0x57e2ffd8
57e0454c:	57e2fffc 	.word	0x57e2fffc
57e04550:	57e3001a 	.word	0x57e3001a
57e04554:	57e36e60 	.word	0x57e36e60

57e04558 <s1_sendpacket.clone.0>:
		total += *buffer++;
	}
	return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
}

static void s1_sendpacket(char *packet)
57e04558:	e92d4038 	push	{r3, r4, r5, lr}
57e0455c:	e59f5034 	ldr	r5, [pc, #52]	; 57e04598 <s1_sendpacket.clone.0+0x40>
57e04560:	e595401c 	ldr	r4, [r5, #28]
57e04564:	ea000002 	b	57e04574 <s1_sendpacket.clone.0+0x1c>
static void send_pad(void)
{
	int count = his_pad_count;

	while (count-- > 0)
		putc(his_pad_char);
57e04568:	e5d50020 	ldrb	r0, [r5, #32]
57e0456c:	eb0013a2 	bl	57e093fc <putc>
57e04570:	e2444001 	sub	r4, r4, #1

static void send_pad(void)
{
	int count = his_pad_count;

	while (count-- > 0)
57e04574:	e3540000 	cmp	r4, #0
57e04578:	cafffffa 	bgt	57e04568 <s1_sendpacket.clone.0+0x10>
57e0457c:	e59f4018 	ldr	r4, [pc, #24]	; 57e0459c <s1_sendpacket.clone.0+0x44>
57e04580:	ea000000 	b	57e04588 <s1_sendpacket.clone.0+0x30>

static void s1_sendpacket(char *packet)
{
	send_pad();
	while (*packet) {
		putc(*packet++);
57e04584:	eb00139c 	bl	57e093fc <putc>
}

static void s1_sendpacket(char *packet)
{
	send_pad();
	while (*packet) {
57e04588:	e5f40001 	ldrb	r0, [r4, #1]!
57e0458c:	e3500000 	cmp	r0, #0
57e04590:	1afffffb 	bne	57e04584 <s1_sendpacket.clone.0+0x2c>
		putc(*packet++);
	}
}
57e04594:	e8bd8038 	pop	{r3, r4, r5, pc}
57e04598:	57e3836c 	.word	0x57e3836c
57e0459c:	57e3838f 	.word	0x57e3838f

57e045a0 <chk1.clone.1>:
		return in;
}

static int chk1(char *buffer)
{
	int total = 0;
57e045a0:	e59f2024 	ldr	r2, [pc, #36]	; 57e045cc <chk1.clone.1+0x2c>
57e045a4:	e3a03000 	mov	r3, #0
57e045a8:	ea000000 	b	57e045b0 <chk1.clone.1+0x10>

	while (*buffer) {
		total += *buffer++;
57e045ac:	e0833001 	add	r3, r3, r1

static int chk1(char *buffer)
{
	int total = 0;

	while (*buffer) {
57e045b0:	e5f21001 	ldrb	r1, [r2, #1]!
57e045b4:	e3510000 	cmp	r1, #0
57e045b8:	1afffffb 	bne	57e045ac <chk1.clone.1+0xc>
		total += *buffer++;
	}
	return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
57e045bc:	e1a02c03 	lsl	r2, r3, #24
57e045c0:	e0833f22 	add	r3, r3, r2, lsr #30
}
57e045c4:	e203003f 	and	r0, r3, #63	; 0x3f
57e045c8:	e12fff1e 	bx	lr
57e045cc:	57e38390 	.word	0x57e38390

57e045d0 <do_load_serial_bin>:
static char his_pad_char;   /* pad chars he needs */
static char his_quote;      /* quote chars he'll use */

static int do_load_serial_bin(cmd_tbl_t *cmdtp, int flag, int argc,
			      char * const argv[])
{
57e045d0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
57e045d4:	e59f0654 	ldr	r0, [pc, #1620]	; 57e04c30 <do_load_serial_bin+0x660>
static char his_pad_char;   /* pad chars he needs */
static char his_quote;      /* quote chars he'll use */

static int do_load_serial_bin(cmd_tbl_t *cmdtp, int flag, int argc,
			      char * const argv[])
{
57e045d8:	e24dd030 	sub	sp, sp, #48	; 0x30
57e045dc:	e1a05002 	mov	r5, r2
57e045e0:	e1a06003 	mov	r6, r3

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
57e045e4:	eb000c3f 	bl	57e076e8 <getenv>
57e045e8:	e3500000 	cmp	r0, #0
	int load_baudrate, current_baudrate;
	int rcode = 0;
	char *s;

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;
57e045ec:	03a04205 	moveq	r4, #1342177280	; 0x50000000

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
57e045f0:	0a000003 	beq	57e04604 <do_load_serial_bin+0x34>
		offset = simple_strtoul(s, NULL, 16);
57e045f4:	e3a01000 	mov	r1, #0
57e045f8:	e3a02010 	mov	r2, #16
57e045fc:	eb0082a8 	bl	57e250a4 <simple_strtoul>
57e04600:	e1a04000 	mov	r4, r0
	}

	load_baudrate = current_baudrate = gd->baudrate;
57e04604:	e5983008 	ldr	r3, [r8, #8]

	if (argc >= 2) {
57e04608:	e3550001 	cmp	r5, #1
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
57e0460c:	e58d3008 	str	r3, [sp, #8]

	if (argc >= 2) {
57e04610:	da00017f 	ble	57e04c14 <do_load_serial_bin+0x644>
		offset = simple_strtoul(argv[1], NULL, 16);
57e04614:	e5960004 	ldr	r0, [r6, #4]
57e04618:	e3a01000 	mov	r1, #0
57e0461c:	e3a02010 	mov	r2, #16
57e04620:	eb00829f 	bl	57e250a4 <simple_strtoul>
	}
	if (argc == 3) {
57e04624:	e3550003 	cmp	r5, #3
	}

	load_baudrate = current_baudrate = gd->baudrate;

	if (argc >= 2) {
		offset = simple_strtoul(argv[1], NULL, 16);
57e04628:	e1a04000 	mov	r4, r0
	}
	if (argc == 3) {
57e0462c:	1a000178 	bne	57e04c14 <do_load_serial_bin+0x644>
		load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
57e04630:	e5960008 	ldr	r0, [r6, #8]
57e04634:	e3a01000 	mov	r1, #0
57e04638:	e3a0200a 	mov	r2, #10
57e0463c:	eb008298 	bl	57e250a4 <simple_strtoul>

		/* default to current baudrate */
		if (load_baudrate == 0)
57e04640:	e2505000 	subs	r5, r0, #0
57e04644:	0a000172 	beq	57e04c14 <do_load_serial_bin+0x644>
			load_baudrate = current_baudrate;
	}

	if (load_baudrate != current_baudrate) {
57e04648:	e59d1008 	ldr	r1, [sp, #8]
57e0464c:	e1550001 	cmp	r5, r1
57e04650:	0a00000b 	beq	57e04684 <do_load_serial_bin+0xb4>
		printf("## Switch baudrate to %d bps and press ENTER ...\n",
57e04654:	e1a01005 	mov	r1, r5
57e04658:	e59f05d4 	ldr	r0, [pc, #1492]	; 57e04c34 <do_load_serial_bin+0x664>
57e0465c:	eb00137a 	bl	57e0944c <printf>
			load_baudrate);
		udelay(50000);
57e04660:	e59f05d0 	ldr	r0, [pc, #1488]	; 57e04c38 <do_load_serial_bin+0x668>
57e04664:	eb007fb3 	bl	57e24538 <udelay>
		gd->baudrate = load_baudrate;
57e04668:	e5885008 	str	r5, [r8, #8]
		serial_setbrg();
57e0466c:	eb00628e 	bl	57e1d0ac <serial_setbrg>
		udelay(50000);
57e04670:	e59f05c0 	ldr	r0, [pc, #1472]	; 57e04c38 <do_load_serial_bin+0x668>
57e04674:	eb007faf 	bl	57e24538 <udelay>
		for (;;) {
			if (getc() == '\r')
57e04678:	eb00134d 	bl	57e093b4 <getc>
57e0467c:	e350000d 	cmp	r0, #13
57e04680:	1afffffc 	bne	57e04678 <do_load_serial_bin+0xa8>
				break;
		}
	}

	if (strcmp(argv[0],"loady")==0) {
57e04684:	e5960000 	ldr	r0, [r6]
57e04688:	e59f15ac 	ldr	r1, [pc, #1452]	; 57e04c3c <do_load_serial_bin+0x66c>
57e0468c:	eb007e44 	bl	57e23fa4 <strcmp>
57e04690:	e2507000 	subs	r7, r0, #0
57e04694:	1a000006 	bne	57e046b4 <do_load_serial_bin+0xe4>
		printf("## Ready for binary (ymodem) download "
57e04698:	e1a01004 	mov	r1, r4
57e0469c:	e1a02005 	mov	r2, r5
57e046a0:	e59f0598 	ldr	r0, [pc, #1432]	; 57e04c40 <do_load_serial_bin+0x670>
57e046a4:	eb001368 	bl	57e0944c <printf>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);

		addr = load_serial_ymodem(offset);
57e046a8:	e1a00004 	mov	r0, r4
57e046ac:	ebfffe8d 	bl	57e040e8 <load_serial_ymodem>
57e046b0:	ea000144 	b	57e04bc8 <do_load_serial_bin+0x5f8>

	} else {

		printf("## Ready for binary (kermit) download "
57e046b4:	e1a02005 	mov	r2, r5
57e046b8:	e1a01004 	mov	r1, r4
57e046bc:	e59f0580 	ldr	r0, [pc, #1408]	; 57e04c44 <do_load_serial_bin+0x674>
57e046c0:	eb001361 	bl	57e0944c <printf>
	}
}

static void set_kerm_bin_mode(unsigned long *addr)
{
	bin_start_address = (char *) addr;
57e046c4:	e59f657c 	ldr	r6, [pc, #1404]	; 57e04c48 <do_load_serial_bin+0x678>
	os_data_init = bin_data_init;
57e046c8:	e59f357c 	ldr	r3, [pc, #1404]	; 57e04c4c <do_load_serial_bin+0x67c>
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
57e046cc:	e3a07000 	mov	r7, #0
}

static void set_kerm_bin_mode(unsigned long *addr)
{
	bin_start_address = (char *) addr;
	os_data_init = bin_data_init;
57e046d0:	e586303c 	str	r3, [r6, #60]	; 0x3c
	os_data_char = bin_data_char;
57e046d4:	e59f3574 	ldr	r3, [pc, #1396]	; 57e04c50 <do_load_serial_bin+0x680>
	}
}

static void set_kerm_bin_mode(unsigned long *addr)
{
	bin_start_address = (char *) addr;
57e046d8:	e5864008 	str	r4, [r6, #8]
	os_data_init = bin_data_init;
	os_data_char = bin_data_char;
57e046dc:	e5863040 	str	r3, [r6, #64]	; 0x40
	int length;
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
57e046e0:	e3a0300d 	mov	r3, #13
57e046e4:	e5c63044 	strb	r3, [r6, #68]	; 0x44
	his_pad_count = 0;
	his_pad_char = '\0';
	his_quote = K_ESCAPE;
57e046e8:	e2833016 	add	r3, r3, #22
57e046ec:	e5c63045 	strb	r3, [r6, #69]	; 0x45
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
57e046f0:	e586701c 	str	r7, [r6, #28]
	his_pad_char = '\0';
57e046f4:	e5c67020 	strb	r7, [r6, #32]

/* k_data_* simply handles the kermit escape translations */
static int k_data_escape, k_data_escape_saved;
static void k_data_init(void)
{
	k_data_escape = 0;
57e046f8:	e5867010 	str	r7, [r6, #16]
	os_data_init();
57e046fc:	ebfffe58 	bl	57e04064 <bin_data_init>
	/* initialize the k_recv and k_data state machine */
	done = 0;
	k_state = 0;
	k_data_init();
	k_state_saved = k_state;
	k_data_save();
57e04700:	ebfffe66 	bl	57e040a0 <k_data_save>
	n = 0;				/* just to get rid of a warning */
	last_n = -1;
57e04704:	e3e0b000 	mvn	fp, #0
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
57e04708:	e58d500c 	str	r5, [sp, #12]
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar(3);
	a_b[2] = tochar(n);
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
57e0470c:	e1a0a007 	mov	sl, r7
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
57e04710:	e1a05004 	mov	r5, r4
	 */

	/* enter main loop */
	while (!done) {
		/* set the send packet pointer to begining of send packet parms */
		send_ptr = send_parms;
57e04714:	e59f3538 	ldr	r3, [pc, #1336]	; 57e04c54 <do_load_serial_bin+0x684>
57e04718:	e5863048 	str	r3, [r6, #72]	; 0x48
#endif

		/* get a packet */
		/* wait for the starting character or ^C */
		for (;;) {
			switch (getc ()) {
57e0471c:	eb001324 	bl	57e093b4 <getc>
57e04720:	e3500001 	cmp	r0, #1
57e04724:	0a000002 	beq	57e04734 <do_load_serial_bin+0x164>
57e04728:	e3500003 	cmp	r0, #3
57e0472c:	1afffffa 	bne	57e0471c <do_load_serial_bin+0x14c>
57e04730:	ea0000fd 	b	57e04b2c <do_load_serial_bin+0x55c>
			}
		}
START:
		/* get length of packet */
		sum = 0;
		new_char = getc();
57e04734:	eb00131e 	bl	57e093b4 <getc>
		if ((new_char & 0xE0) == 0)
57e04738:	e31000e0 	tst	r0, #224	; 0xe0
57e0473c:	e20040ff 	and	r4, r0, #255	; 0xff
57e04740:	0a000066 	beq	57e048e0 <do_load_serial_bin+0x310>
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar(new_char);
		/* get sequence number */
		new_char = getc();
57e04744:	eb00131a 	bl	57e093b4 <getc>
		if ((new_char & 0xE0) == 0)
57e04748:	e31000e0 	tst	r0, #224	; 0xe0
57e0474c:	e20090ff 	and	r9, r0, #255	; 0xff
57e04750:	0a000062 	beq	57e048e0 <do_load_serial_bin+0x310>
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar(new_char);
57e04754:	e2497020 	sub	r7, r9, #32
57e04758:	e20770ff 	and	r7, r7, #255	; 0xff
		 * received.  Handling an invalid sequence number adds another layer
		 * of complexity that may not be needed - yet!  At this time, I'm hoping
		 * that I don't need to buffer the incoming data packets and can write
		 * the data into memory in real time.
		 */
		if (n == last_n) {
57e0475c:	e157000b 	cmp	r7, fp
57e04760:	1a000001 	bne	57e0476c <do_load_serial_bin+0x19c>
			/* same sequence number, restore the previous state */
			k_state = k_state_saved;
			k_data_restore();
57e04764:	ebfffe56 	bl	57e040c4 <k_data_restore>
57e04768:	ea000000 	b	57e04770 <do_load_serial_bin+0x1a0>
		} else {
			/* new sequence number, checkpoint the download */
			last_n = n;
			k_state_saved = k_state;
			k_data_save();
57e0476c:	ebfffe4b 	bl	57e040a0 <k_data_save>
		}
		/* END NEW CODE */

		/* get packet type */
		new_char = getc();
57e04770:	eb00130f 	bl	57e093b4 <getc>
		if ((new_char & 0xE0) == 0)
57e04774:	e31000e0 	tst	r0, #224	; 0xe0
			k_data_save();
		}
		/* END NEW CODE */

		/* get packet type */
		new_char = getc();
57e04778:	e200b0ff 	and	fp, r0, #255	; 0xff
		if ((new_char & 0xE0) == 0)
57e0477c:	0a000056 	beq	57e048dc <do_load_serial_bin+0x30c>
		length = untochar(new_char);
		/* get sequence number */
		new_char = getc();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
57e04780:	e0899004 	add	r9, r9, r4
		sum = 0;
		new_char = getc();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar(new_char);
57e04784:	e2444020 	sub	r4, r4, #32
57e04788:	e20440ff 	and	r4, r4, #255	; 0xff
		new_char = getc();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		k_state = new_char;
		--length;
57e0478c:	e2444002 	sub	r4, r4, #2
		/* check for extended length */
		if (length == -2) {
57e04790:	e3740002 	cmn	r4, #2

		/* get packet type */
		new_char = getc();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
57e04794:	e089900b 	add	r9, r9, fp
		k_state = new_char;
		--length;
		/* check for extended length */
		if (length == -2) {
57e04798:	1a00003f 	bne	57e0489c <do_load_serial_bin+0x2cc>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc();
57e0479c:	eb001304 	bl	57e093b4 <getc>
			if ((new_char & 0xE0) == 0)
57e047a0:	e31000e0 	tst	r0, #224	; 0xe0
57e047a4:	e20040ff 	and	r4, r0, #255	; 0xff
57e047a8:	0a00004b 	beq	57e048dc <do_load_serial_bin+0x30c>
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar(new_char);
			new_char = getc();
57e047ac:	eb001300 	bl	57e093b4 <getc>
			if ((new_char & 0xE0) == 0)
57e047b0:	e31000e0 	tst	r0, #224	; 0xe0
57e047b4:	e20030ff 	and	r3, r0, #255	; 0xff
57e047b8:	0a000047 	beq	57e048dc <do_load_serial_bin+0x30c>
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar(new_char);
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc();
57e047bc:	e58d3004 	str	r3, [sp, #4]
57e047c0:	eb0012fb 	bl	57e093b4 <getc>
			if ((new_char & 0xE0) == 0)
57e047c4:	e31000e0 	tst	r0, #224	; 0xe0
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar(new_char);
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc();
57e047c8:	e20020ff 	and	r2, r0, #255	; 0xff
			if ((new_char & 0xE0) == 0)
57e047cc:	e59d3004 	ldr	r3, [sp, #4]
57e047d0:	0a000041 	beq	57e048dc <do_load_serial_bin+0x30c>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
57e047d4:	e0849009 	add	r9, r4, r9
			len_hi = untochar(new_char);
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
57e047d8:	e0899003 	add	r9, r9, r3
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar((sum + ((sum >> 6) & 0x03)) & 0x3f))
57e047dc:	e1a01c09 	lsl	r1, r9, #24
57e047e0:	e0891f21 	add	r1, r9, r1, lsr #30
57e047e4:	e201103f 	and	r1, r1, #63	; 0x3f
57e047e8:	e2811020 	add	r1, r1, #32
57e047ec:	e1520001 	cmp	r2, r1
57e047f0:	1a000039 	bne	57e048dc <do_load_serial_bin+0x30c>
			len_hi = untochar(new_char);
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar(new_char);
57e047f4:	e2433020 	sub	r3, r3, #32
			/* get the two length bytes */
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar(new_char);
57e047f8:	e2444020 	sub	r4, r4, #32
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar(new_char);
57e047fc:	e20330ff 	and	r3, r3, #255	; 0xff
			/* get the two length bytes */
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar(new_char);
57e04800:	e20440ff 	and	r4, r4, #255	; 0xff
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar(new_char);
			length = len_hi * 95 + len_lo;
57e04804:	e3a0105f 	mov	r1, #95	; 0x5f
57e04808:	e0243491 	mla	r4, r1, r4, r3
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar((sum + ((sum >> 6) & 0x03)) & 0x3f))
				goto packet_error;
			sum += new_char & 0xff;
57e0480c:	e0829009 	add	r9, r2, r9
57e04810:	ea000021 	b	57e0489c <do_load_serial_bin+0x2cc>
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc();
57e04814:	eb0012e6 	bl	57e093b4 <getc>
57e04818:	e1a03000 	mov	r3, r0
			if ((new_char & 0xE0) == 0)
57e0481c:	e31300e0 	tst	r3, #224	; 0xe0
			sum += new_char & 0xff;
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc();
57e04820:	e20000ff 	and	r0, r0, #255	; 0xff
			if ((new_char & 0xE0) == 0)
57e04824:	0a00002c 	beq	57e048dc <do_load_serial_bin+0x30c>
				goto packet_error;
			sum += new_char & 0xff;
			--length;
			if (k_state == DATA_TYPE) {
57e04828:	e35b0044 	cmp	fp, #68	; 0x44
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
57e0482c:	e0899000 	add	r9, r9, r0
			--length;
57e04830:	e2444001 	sub	r4, r4, #1
			if (k_state == DATA_TYPE) {
57e04834:	1a00000f 	bne	57e04878 <do_load_serial_bin+0x2a8>
	os_data_restore();
}

static void k_data_char(char new_char)
{
	if (k_data_escape) {
57e04838:	e5963010 	ldr	r3, [r6, #16]
57e0483c:	e3530000 	cmp	r3, #0
57e04840:	0a000004 	beq	57e04858 <do_load_serial_bin+0x288>
		/* last char was escape - translate this character */
		os_data_char(ktrans(new_char));
57e04844:	ebfffdfe 	bl	57e04044 <ktrans>
57e04848:	e5963040 	ldr	r3, [r6, #64]	; 0x40
57e0484c:	e12fff33 	blx	r3
		k_data_escape = 0;
57e04850:	e586a010 	str	sl, [r6, #16]
57e04854:	ea000010 	b	57e0489c <do_load_serial_bin+0x2cc>
	} else {
		if (new_char == his_quote) {
57e04858:	e5d63045 	ldrb	r3, [r6, #69]	; 0x45
57e0485c:	e1530000 	cmp	r3, r0
			/* this char is escape - remember */
			k_data_escape = 1;
57e04860:	03a02001 	moveq	r2, #1
57e04864:	05862010 	streq	r2, [r6, #16]
	if (k_data_escape) {
		/* last char was escape - translate this character */
		os_data_char(ktrans(new_char));
		k_data_escape = 0;
	} else {
		if (new_char == his_quote) {
57e04868:	0a00000b 	beq	57e0489c <do_load_serial_bin+0x2cc>
			/* this char is escape - remember */
			k_data_escape = 1;
		} else {
			/* otherwise send this char as-is */
			os_data_char(new_char);
57e0486c:	e5963040 	ldr	r3, [r6, #64]	; 0x40
57e04870:	e12fff33 	blx	r3
57e04874:	ea000008 	b	57e0489c <do_load_serial_bin+0x2cc>
			sum += new_char & 0xff;
			--length;
			if (k_state == DATA_TYPE) {
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
			} else if (k_state == SEND_TYPE) {
57e04878:	e35b0053 	cmp	fp, #83	; 0x53
57e0487c:	1a000006 	bne	57e0489c <do_load_serial_bin+0x2cc>
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
57e04880:	e5962048 	ldr	r2, [r6, #72]	; 0x48
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
57e04884:	e59f13cc 	ldr	r1, [pc, #972]	; 57e04c58 <do_load_serial_bin+0x688>
			if (k_state == DATA_TYPE) {
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
			} else if (k_state == SEND_TYPE) {
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
57e04888:	e1a03002 	mov	r3, r2
57e0488c:	e4c30001 	strb	r0, [r3], #1
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
57e04890:	e1530001 	cmp	r3, r1
					--send_ptr;
57e04894:	21a03002 	movcs	r3, r2
57e04898:	e5863048 	str	r3, [r6, #72]	; 0x48
				goto packet_error;
			sum += new_char & 0xff;
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
57e0489c:	e3540001 	cmp	r4, #1
57e048a0:	caffffdb 	bgt	57e04814 <do_load_serial_bin+0x244>
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
					--send_ptr;
			}
		}
		/* get and validate checksum character */
		new_char = getc();
57e048a4:	eb0012c2 	bl	57e093b4 <getc>
		if ((new_char & 0xE0) == 0)
57e048a8:	e31000e0 	tst	r0, #224	; 0xe0
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
					--send_ptr;
			}
		}
		/* get and validate checksum character */
		new_char = getc();
57e048ac:	e20030ff 	and	r3, r0, #255	; 0xff
		if ((new_char & 0xE0) == 0)
57e048b0:	0a000009 	beq	57e048dc <do_load_serial_bin+0x30c>
			goto packet_error;
		if (new_char != tochar((sum + ((sum >> 6) & 0x03)) & 0x3f))
57e048b4:	e1a02c09 	lsl	r2, r9, #24
57e048b8:	e0899f22 	add	r9, r9, r2, lsr #30
57e048bc:	e209903f 	and	r9, r9, #63	; 0x3f
57e048c0:	e2899020 	add	r9, r9, #32
57e048c4:	e1530009 	cmp	r3, r9
57e048c8:	1a000003 	bne	57e048dc <do_load_serial_bin+0x30c>
			goto packet_error;
		/* get END_CHAR */
		new_char = getc();
57e048cc:	eb0012b8 	bl	57e093b4 <getc>
		if (new_char != END_CHAR) {
57e048d0:	e20000ff 	and	r0, r0, #255	; 0xff
57e048d4:	e350000d 	cmp	r0, #13
57e048d8:	0a000014 	beq	57e04930 <do_load_serial_bin+0x360>
		/* get sequence number */
		new_char = getc();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar(new_char);
57e048dc:	e1a0b007 	mov	fp, r7
		new_char = getc();
		if (new_char != END_CHAR) {
		  packet_error:
			/* restore state machines */
			k_state = k_state_saved;
			k_data_restore();
57e048e0:	ebfffdf7 	bl	57e040c4 <k_data_restore>
}

static void send_nack(int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar(3);
57e048e4:	e3a03023 	mov	r3, #35	; 0x23
57e048e8:	e5c63025 	strb	r3, [r6, #37]	; 0x25
	a_b[2] = tochar(n);
57e048ec:	e2873020 	add	r3, r7, #32
	s1_sendpacket(a_b);
}

static void send_nack(int n)
{
	a_b[0] = START_CHAR;
57e048f0:	e3a02001 	mov	r2, #1
	a_b[1] = tochar(3);
	a_b[2] = tochar(n);
57e048f4:	e5c63026 	strb	r3, [r6, #38]	; 0x26
	a_b[3] = NACK_TYPE;
57e048f8:	e3a0304e 	mov	r3, #78	; 0x4e
	s1_sendpacket(a_b);
}

static void send_nack(int n)
{
	a_b[0] = START_CHAR;
57e048fc:	e5c62024 	strb	r2, [r6, #36]	; 0x24
	a_b[1] = tochar(3);
	a_b[2] = tochar(n);
	a_b[3] = NACK_TYPE;
57e04900:	e5c63027 	strb	r3, [r6, #39]	; 0x27
	a_b[4] = '\0';
57e04904:	e5c6a028 	strb	sl, [r6, #40]	; 0x28
	a_b[4] = tochar(chk1(&a_b[1]));
57e04908:	ebffff24 	bl	57e045a0 <chk1.clone.1>
	a_b[5] = his_eol;
57e0490c:	e5d63044 	ldrb	r3, [r6, #68]	; 0x44
	a_b[0] = START_CHAR;
	a_b[1] = tochar(3);
	a_b[2] = tochar(n);
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar(chk1(&a_b[1]));
57e04910:	e2800020 	add	r0, r0, #32
	a_b[5] = his_eol;
57e04914:	e5c63029 	strb	r3, [r6, #41]	; 0x29
	a_b[0] = START_CHAR;
	a_b[1] = tochar(3);
	a_b[2] = tochar(n);
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar(chk1(&a_b[1]));
57e04918:	e5c60028 	strb	r0, [r6, #40]	; 0x28
	a_b[5] = his_eol;
	a_b[6] = '\0';
57e0491c:	e5c6a02a 	strb	sl, [r6, #42]	; 0x2a
	s1_sendpacket(a_b);
57e04920:	ebffff0c 	bl	57e04558 <s1_sendpacket.clone.0>
57e04924:	e1a03007 	mov	r3, r7
57e04928:	e1a0700b 	mov	r7, fp
57e0492c:	ea00007b 	b	57e04b20 <do_load_serial_bin+0x550>
			/* restore state machines */
			k_state = k_state_saved;
			k_data_restore();
			/* send a negative acknowledge packet in */
			send_nack(n);
		} else if (k_state == SEND_TYPE) {
57e04930:	e35b0053 	cmp	fp, #83	; 0x53
57e04934:	1a000065 	bne	57e04ad0 <do_load_serial_bin+0x500>

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
	his_pad_char = '\0';
	his_quote = K_ESCAPE;
57e04938:	e3a03023 	mov	r3, #35	; 0x23

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
57e0493c:	e5962048 	ldr	r2, [r6, #72]	; 0x48

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
	his_pad_char = '\0';
	his_quote = K_ESCAPE;
57e04940:	e5c63045 	strb	r3, [r6, #69]	; 0x45

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
57e04944:	e59f3310 	ldr	r3, [pc, #784]	; 57e04c5c <do_load_serial_bin+0x68c>
{
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
57e04948:	e5c60044 	strb	r0, [r6, #68]	; 0x44
	his_pad_count = 0;
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
57e0494c:	e1520003 	cmp	r2, r3
		--send_ptr;
57e04950:	059f3308 	ldreq	r3, [pc, #776]	; 57e04c60 <do_load_serial_bin+0x690>
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
57e04954:	e586a01c 	str	sl, [r6, #28]
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
57e04958:	05863048 	streq	r3, [r6, #72]	; 0x48
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
57e0495c:	e5964048 	ldr	r4, [r6, #72]	; 0x48
57e04960:	e59f32ec 	ldr	r3, [pc, #748]	; 57e04c54 <do_load_serial_bin+0x684>
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
	his_pad_char = '\0';
57e04964:	e5c6a020 	strb	sl, [r6, #32]
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
57e04968:	e0634004 	rsb	r4, r3, r4
	do {
		if (bytes-- <= 0)
57e0496c:	e3540000 	cmp	r4, #0

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
static void handle_send_packet(int n)
{
	int length = 3;
57e04970:	d3a04003 	movle	r4, #3
	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
	do {
		if (bytes-- <= 0)
57e04974:	da000040 	ble	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar(94);
57e04978:	e3a0307e 	mov	r3, #126	; 0x7e
		if (bytes-- <= 0)
57e0497c:	e2544001 	subs	r4, r4, #1
	do {
		if (bytes-- <= 0)
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar(94);
57e04980:	e5c63028 	strb	r3, [r6, #40]	; 0x28
57e04984:	03a04004 	moveq	r4, #4
		if (bytes-- <= 0)
57e04988:	0a00003b 	beq	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar(1);
57e0498c:	e3a03021 	mov	r3, #33	; 0x21
		if (bytes-- <= 0)
57e04990:	e2544001 	subs	r4, r4, #1
		a_b[++length] = tochar(94);
		if (bytes-- <= 0)
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar(1);
57e04994:	e5c63029 	strb	r3, [r6, #41]	; 0x29
57e04998:	03a04005 	moveq	r4, #5
		if (bytes-- <= 0)
57e0499c:	0a000036 	beq	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar(send_parms[2]);
57e049a0:	e5d6304e 	ldrb	r3, [r6, #78]	; 0x4e
		a_b[++length] = tochar(0);
		if (bytes-- <= 0)
57e049a4:	e2544001 	subs	r4, r4, #1
		a_b[++length] = tochar(1);
		if (bytes-- <= 0)
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar(send_parms[2]);
57e049a8:	e2433020 	sub	r3, r3, #32
57e049ac:	e20330ff 	and	r3, r3, #255	; 0xff
57e049b0:	e586301c 	str	r3, [r6, #28]
		a_b[++length] = tochar(0);
57e049b4:	e3a03020 	mov	r3, #32
57e049b8:	e5c6302a 	strb	r3, [r6, #42]	; 0x2a
57e049bc:	03a04006 	moveq	r4, #6
		if (bytes-- <= 0)
57e049c0:	0a00002d 	beq	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans(send_parms[3]);
57e049c4:	e5d6004f 	ldrb	r0, [r6, #79]	; 0x4f
57e049c8:	ebfffd9d 	bl	57e04044 <ktrans>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar(send_parms[2]);
		a_b[++length] = tochar(0);
		if (bytes-- <= 0)
57e049cc:	e2444001 	sub	r4, r4, #1
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans(send_parms[3]);
		a_b[++length] = 0x40;	/* He should ignore this */
57e049d0:	e3a03040 	mov	r3, #64	; 0x40
		if (bytes-- <= 0)
57e049d4:	e3540000 	cmp	r4, #0
		a_b[++length] = tochar(0);
		if (bytes-- <= 0)
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans(send_parms[3]);
57e049d8:	e5c60020 	strb	r0, [r6, #32]
		a_b[++length] = 0x40;	/* He should ignore this */
57e049dc:	e5c6302b 	strb	r3, [r6, #43]	; 0x2b
57e049e0:	03a04007 	moveq	r4, #7
		if (bytes-- <= 0)
57e049e4:	0a000024 	beq	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar(send_parms[4]);
57e049e8:	e5d63050 	ldrb	r3, [r6, #80]	; 0x50
		a_b[++length] = tochar(END_CHAR);
		if (bytes-- <= 0)
57e049ec:	e2544001 	subs	r4, r4, #1
		a_b[++length] = 0x40;	/* He should ignore this */
		if (bytes-- <= 0)
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar(send_parms[4]);
57e049f0:	e2433020 	sub	r3, r3, #32
57e049f4:	e5c63044 	strb	r3, [r6, #68]	; 0x44
		a_b[++length] = tochar(END_CHAR);
57e049f8:	e3a0302d 	mov	r3, #45	; 0x2d
57e049fc:	e5c6302c 	strb	r3, [r6, #44]	; 0x2c
57e04a00:	03a04008 	moveq	r4, #8
		if (bytes-- <= 0)
57e04a04:	0a00001c 	beq	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
57e04a08:	e5d63051 	ldrb	r3, [r6, #81]	; 0x51
		a_b[++length] = '#';
		if (bytes-- <= 0)
57e04a0c:	e2544001 	subs	r4, r4, #1
		a_b[++length] = tochar(END_CHAR);
		if (bytes-- <= 0)
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
57e04a10:	e5c63045 	strb	r3, [r6, #69]	; 0x45
		a_b[++length] = '#';
57e04a14:	e3a03023 	mov	r3, #35	; 0x23
57e04a18:	e5c6302d 	strb	r3, [r6, #45]	; 0x2d
57e04a1c:	03a04009 	moveq	r4, #9
		if (bytes-- <= 0)
57e04a20:	0a000015 	beq	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
57e04a24:	e283302b 	add	r3, r3, #43	; 0x2b
		if (bytes-- <= 0)
57e04a28:	e2544001 	subs	r4, r4, #1
		a_b[++length] = '#';
		if (bytes-- <= 0)
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
57e04a2c:	e5c6302e 	strb	r3, [r6, #46]	; 0x2e
57e04a30:	03a0400a 	moveq	r4, #10
		if (bytes-- <= 0)
57e04a34:	0a000010 	beq	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
57e04a38:	e3a02031 	mov	r2, #49	; 0x31
		if (bytes-- <= 0)
57e04a3c:	e2544001 	subs	r4, r4, #1
		a_b[++length] = 'N';
		if (bytes-- <= 0)
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
57e04a40:	e5c6202f 	strb	r2, [r6, #47]	; 0x2f
57e04a44:	03a0400b 	moveq	r4, #11
		if (bytes-- <= 0)
57e04a48:	0a00000b 	beq	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
		if (bytes-- <= 0)
57e04a4c:	e3540001 	cmp	r4, #1
		a_b[++length] = '1';
		if (bytes-- <= 0)
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
57e04a50:	e5c63030 	strb	r3, [r6, #48]	; 0x30
57e04a54:	03a0400c 	moveq	r4, #12
		if (bytes-- <= 0)
57e04a58:	0a000007 	beq	57e04a7c <do_load_serial_bin+0x4ac>
			break;
		/* handle CAPAS - the capabilities mask */
		/* ignore what he says - I only do long packets - I don't do windows */
		a_b[++length] = tochar(2);	/* only long packets */
57e04a5c:	e3a03022 	mov	r3, #34	; 0x22
57e04a60:	e5c63031 	strb	r3, [r6, #49]	; 0x31
		a_b[++length] = tochar(0);	/* no windows */
57e04a64:	e3a03020 	mov	r3, #32
57e04a68:	e5c63032 	strb	r3, [r6, #50]	; 0x32
		a_b[++length] = tochar(94);	/* large packet msb */
57e04a6c:	e283305e 	add	r3, r3, #94	; 0x5e
57e04a70:	e5c63033 	strb	r3, [r6, #51]	; 0x33
		a_b[++length] = tochar(94);	/* large packet lsb */
57e04a74:	e5c63034 	strb	r3, [r6, #52]	; 0x34
57e04a78:	e3a04010 	mov	r4, #16
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar(length);
57e04a7c:	e2843020 	add	r3, r4, #32
57e04a80:	e5c63025 	strb	r3, [r6, #37]	; 0x25
	a_b[2] = tochar(n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
57e04a84:	e2844001 	add	r4, r4, #1
		a_b[++length] = tochar(94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar(length);
	a_b[2] = tochar(n);
57e04a88:	e2873020 	add	r3, r7, #32
57e04a8c:	e5c63026 	strb	r3, [r6, #38]	; 0x26
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
57e04a90:	e0869004 	add	r9, r6, r4
		a_b[++length] = tochar(0);	/* no windows */
		a_b[++length] = tochar(94);	/* large packet msb */
		a_b[++length] = tochar(94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
57e04a94:	e3a01001 	mov	r1, #1
	a_b[1] = tochar(length);
	a_b[2] = tochar(n);
	a_b[3] = ACK_TYPE;
57e04a98:	e3a03059 	mov	r3, #89	; 0x59
57e04a9c:	e5c63027 	strb	r3, [r6, #39]	; 0x27
		a_b[++length] = tochar(0);	/* no windows */
		a_b[++length] = tochar(94);	/* large packet msb */
		a_b[++length] = tochar(94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
57e04aa0:	e5c61024 	strb	r1, [r6, #36]	; 0x24
	a_b[1] = tochar(length);
	a_b[2] = tochar(n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
57e04aa4:	e5c9a024 	strb	sl, [r9, #36]	; 0x24
	a_b[length] = tochar(chk1(&a_b[1]));
57e04aa8:	ebfffebc 	bl	57e045a0 <chk1.clone.1>
	a_b[++length] = his_eol;
57e04aac:	e2844001 	add	r4, r4, #1
57e04ab0:	e5d63044 	ldrb	r3, [r6, #68]	; 0x44
57e04ab4:	e0864004 	add	r4, r6, r4
	a_b[0] = START_CHAR;
	a_b[1] = tochar(length);
	a_b[2] = tochar(n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar(chk1(&a_b[1]));
57e04ab8:	e2800020 	add	r0, r0, #32
57e04abc:	e5c90024 	strb	r0, [r9, #36]	; 0x24
	a_b[++length] = his_eol;
57e04ac0:	e5c43024 	strb	r3, [r4, #36]	; 0x24
	a_b[++length] = '\0';
57e04ac4:	e5c4a025 	strb	sl, [r4, #37]	; 0x25
	s1_sendpacket(a_b);
57e04ac8:	ebfffea2 	bl	57e04558 <s1_sendpacket.clone.0>
57e04acc:	ea000012 	b	57e04b1c <do_load_serial_bin+0x54c>

static char a_b[24];
static void send_ack(int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar(3);
57e04ad0:	e3a03023 	mov	r3, #35	; 0x23
57e04ad4:	e5c63025 	strb	r3, [r6, #37]	; 0x25
	a_b[2] = tochar(n);
57e04ad8:	e2873020 	add	r3, r7, #32
}

static char a_b[24];
static void send_ack(int n)
{
	a_b[0] = START_CHAR;
57e04adc:	e3a02001 	mov	r2, #1
	a_b[1] = tochar(3);
	a_b[2] = tochar(n);
57e04ae0:	e5c63026 	strb	r3, [r6, #38]	; 0x26
	a_b[3] = ACK_TYPE;
57e04ae4:	e3a03059 	mov	r3, #89	; 0x59
}

static char a_b[24];
static void send_ack(int n)
{
	a_b[0] = START_CHAR;
57e04ae8:	e5c62024 	strb	r2, [r6, #36]	; 0x24
	a_b[1] = tochar(3);
	a_b[2] = tochar(n);
	a_b[3] = ACK_TYPE;
57e04aec:	e5c63027 	strb	r3, [r6, #39]	; 0x27
	a_b[4] = '\0';
57e04af0:	e5c6a028 	strb	sl, [r6, #40]	; 0x28
	a_b[4] = tochar(chk1(&a_b[1]));
57e04af4:	ebfffea9 	bl	57e045a0 <chk1.clone.1>
	a_b[5] = his_eol;
57e04af8:	e5d63044 	ldrb	r3, [r6, #68]	; 0x44
	a_b[0] = START_CHAR;
	a_b[1] = tochar(3);
	a_b[2] = tochar(n);
	a_b[3] = ACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar(chk1(&a_b[1]));
57e04afc:	e2800020 	add	r0, r0, #32
57e04b00:	e5c60028 	strb	r0, [r6, #40]	; 0x28
	a_b[5] = his_eol;
57e04b04:	e5c63029 	strb	r3, [r6, #41]	; 0x29
	a_b[6] = '\0';
57e04b08:	e5c6a02a 	strb	sl, [r6, #42]	; 0x2a
	s1_sendpacket(a_b);
57e04b0c:	ebfffe91 	bl	57e04558 <s1_sendpacket.clone.0>
			handle_send_packet(n);
		} else {
			/* send simple acknowledge packet in */
			send_ack(n);
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
57e04b10:	e35b0042 	cmp	fp, #66	; 0x42
}

static char a_b[24];
static void send_ack(int n)
{
	a_b[0] = START_CHAR;
57e04b14:	e59f912c 	ldr	r9, [pc, #300]	; 57e04c48 <do_load_serial_bin+0x678>
			handle_send_packet(n);
		} else {
			/* send simple acknowledge packet in */
			send_ack(n);
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
57e04b18:	0a00003f 	beq	57e04c1c <do_load_serial_bin+0x64c>
		/* get sequence number */
		new_char = getc();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar(new_char);
57e04b1c:	e1a03007 	mov	r3, r7
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
57e04b20:	e1a0b007 	mov	fp, r7
57e04b24:	e1a07003 	mov	r7, r3
57e04b28:	eafffef9 	b	57e04714 <do_load_serial_bin+0x144>
57e04b2c:	e1a04005 	mov	r4, r5
57e04b30:	e59d500c 	ldr	r5, [sp, #12]
		for (;;) {
			switch (getc ()) {
			case START_CHAR:	/* start packet */
				goto START;
			case ETX_CHAR:		/* ^C waiting for packet */
				return (0);
57e04b34:	e3a06000 	mov	r6, #0
57e04b38:	e3a07064 	mov	r7, #100	; 0x64
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
57e04b3c:	eb001225 	bl	57e093d8 <tstc>
57e04b40:	e3500000 	cmp	r0, #0
57e04b44:	0a000000 	beq	57e04b4c <do_load_serial_bin+0x57c>
			(void) getc();
57e04b48:	eb001219 	bl	57e093b4 <getc>
		}
		udelay(1000);
57e04b4c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
57e04b50:	eb007e78 	bl	57e24538 <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
57e04b54:	e2577001 	subs	r7, r7, #1
57e04b58:	1afffff7 	bne	57e04b3c <do_load_serial_bin+0x56c>
			(void) getc();
		}
		udelay(1000);
	}

	flush_cache(offset, size);
57e04b5c:	e1a01006 	mov	r1, r6
57e04b60:	e1a00004 	mov	r0, r4
57e04b64:	ebfff20f 	bl	57e013a8 <__flush_cache>

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf(buf, "%X", size);
57e04b68:	e28da010 	add	sl, sp, #16
		udelay(1000);
	}

	flush_cache(offset, size);

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
57e04b6c:	e1a01006 	mov	r1, r6
57e04b70:	e1a02006 	mov	r2, r6
57e04b74:	e59f00e8 	ldr	r0, [pc, #232]	; 57e04c64 <do_load_serial_bin+0x694>
57e04b78:	eb001233 	bl	57e0944c <printf>
	sprintf(buf, "%X", size);
57e04b7c:	e1a02006 	mov	r2, r6
57e04b80:	e59f10e0 	ldr	r1, [pc, #224]	; 57e04c68 <do_load_serial_bin+0x698>
57e04b84:	e1a0000a 	mov	r0, sl
57e04b88:	eb0081ee 	bl	57e25348 <sprintf>
	setenv("filesize", buf);
57e04b8c:	e59f00d8 	ldr	r0, [pc, #216]	; 57e04c6c <do_load_serial_bin+0x69c>
57e04b90:	e1a0100a 	mov	r1, sl
57e04b94:	eb0009c5 	bl	57e072b0 <setenv>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);
		addr = load_serial_bin(offset);

		if (addr == ~0) {
57e04b98:	e3740001 	cmn	r4, #1
57e04b9c:	e59f60cc 	ldr	r6, [pc, #204]	; 57e04c70 <do_load_serial_bin+0x6a0>
57e04ba0:	1a000004 	bne	57e04bb8 <do_load_serial_bin+0x5e8>
			load_addr = 0;
57e04ba4:	e5867000 	str	r7, [r6]
			printf("## Binary (kermit) download aborted\n");
57e04ba8:	e59f00c4 	ldr	r0, [pc, #196]	; 57e04c74 <do_load_serial_bin+0x6a4>
57e04bac:	eb001226 	bl	57e0944c <printf>
			rcode = 1;
57e04bb0:	e3a07001 	mov	r7, #1
57e04bb4:	ea000003 	b	57e04bc8 <do_load_serial_bin+0x5f8>
		} else {
			printf("## Start Addr      = 0x%08lX\n", addr);
57e04bb8:	e59f00b8 	ldr	r0, [pc, #184]	; 57e04c78 <do_load_serial_bin+0x6a8>
57e04bbc:	e1a01004 	mov	r1, r4
57e04bc0:	eb001221 	bl	57e0944c <printf>
			load_addr = addr;
57e04bc4:	e5864000 	str	r4, [r6]
		}
	}
	if (load_baudrate != current_baudrate) {
57e04bc8:	e59d3008 	ldr	r3, [sp, #8]
57e04bcc:	e1550003 	cmp	r5, r3
57e04bd0:	0a00000c 	beq	57e04c08 <do_load_serial_bin+0x638>
		printf("## Switch baudrate to %d bps and press ESC ...\n",
57e04bd4:	e1a01003 	mov	r1, r3
57e04bd8:	e59f009c 	ldr	r0, [pc, #156]	; 57e04c7c <do_load_serial_bin+0x6ac>
57e04bdc:	eb00121a 	bl	57e0944c <printf>
			current_baudrate);
		udelay(50000);
57e04be0:	e59f0050 	ldr	r0, [pc, #80]	; 57e04c38 <do_load_serial_bin+0x668>
57e04be4:	eb007e53 	bl	57e24538 <udelay>
		gd->baudrate = current_baudrate;
57e04be8:	e59d1008 	ldr	r1, [sp, #8]
57e04bec:	e5881008 	str	r1, [r8, #8]
		serial_setbrg();
57e04bf0:	eb00612d 	bl	57e1d0ac <serial_setbrg>
		udelay(50000);
57e04bf4:	e59f003c 	ldr	r0, [pc, #60]	; 57e04c38 <do_load_serial_bin+0x668>
57e04bf8:	eb007e4e 	bl	57e24538 <udelay>
		for (;;) {
			if (getc() == 0x1B) /* ESC */
57e04bfc:	eb0011ec 	bl	57e093b4 <getc>
57e04c00:	e350001b 	cmp	r0, #27
57e04c04:	1afffffc 	bne	57e04bfc <do_load_serial_bin+0x62c>
				break;
		}
	}

	return rcode;
}
57e04c08:	e1a00007 	mov	r0, r7
57e04c0c:	e28dd030 	add	sp, sp, #48	; 0x30
57e04c10:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
57e04c14:	e59d5008 	ldr	r5, [sp, #8]
57e04c18:	eafffe99 	b	57e04684 <do_load_serial_bin+0xb4>
57e04c1c:	e1a04005 	mov	r4, r5
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
				done = 1;
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
57e04c20:	e9990044 	ldmib	r9, {r2, r6}
57e04c24:	e0426006 	sub	r6, r2, r6
57e04c28:	e59d500c 	ldr	r5, [sp, #12]
57e04c2c:	eaffffc1 	b	57e04b38 <do_load_serial_bin+0x568>
57e04c30:	57e2e096 	.word	0x57e2e096
57e04c34:	57e30038 	.word	0x57e30038
57e04c38:	0000c350 	.word	0x0000c350
57e04c3c:	57e3006a 	.word	0x57e3006a
57e04c40:	57e30070 	.word	0x57e30070
57e04c44:	57e300af 	.word	0x57e300af
57e04c48:	57e3836c 	.word	0x57e3836c
57e04c4c:	57e04064 	.word	0x57e04064
57e04c50:	57e04080 	.word	0x57e04080
57e04c54:	57e383b8 	.word	0x57e383b8
57e04c58:	57e383cc 	.word	0x57e383cc
57e04c5c:	57e383cb 	.word	0x57e383cb
57e04c60:	57e383ca 	.word	0x57e383ca
57e04c64:	57e2ff3d 	.word	0x57e2ff3d
57e04c68:	57e2ff65 	.word	0x57e2ff65
57e04c6c:	57e2ea14 	.word	0x57e2ea14
57e04c70:	57e36e60 	.word	0x57e36e60
57e04c74:	57e300ee 	.word	0x57e300ee
57e04c78:	57e3001a 	.word	0x57e3001a
57e04c7c:	57e30113 	.word	0x57e30113

57e04c80 <do_mem_base>:
}

static int do_mem_base(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
	if (argc > 1) {
57e04c80:	e3520001 	cmp	r2, #1
	return 0;
}

static int do_mem_base(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
57e04c84:	e92d4008 	push	{r3, lr}
	if (argc > 1) {
57e04c88:	da000005 	ble	57e04ca4 <do_mem_base+0x24>
		/* Set new base address.
		*/
		base_address = simple_strtoul(argv[1], NULL, 16);
57e04c8c:	e5930004 	ldr	r0, [r3, #4]
57e04c90:	e3a01000 	mov	r1, #0
57e04c94:	e3a02010 	mov	r2, #16
57e04c98:	eb008101 	bl	57e250a4 <simple_strtoul>
57e04c9c:	e59f3018 	ldr	r3, [pc, #24]	; 57e04cbc <do_mem_base+0x3c>
57e04ca0:	e5830000 	str	r0, [r3]
	}
	/* Print the current base address.
	*/
	printf("Base Address: 0x%08lx\n", base_address);
57e04ca4:	e59f3010 	ldr	r3, [pc, #16]	; 57e04cbc <do_mem_base+0x3c>
57e04ca8:	e59f0010 	ldr	r0, [pc, #16]	; 57e04cc0 <do_mem_base+0x40>
57e04cac:	e5931000 	ldr	r1, [r3]
57e04cb0:	eb0011e5 	bl	57e0944c <printf>
	return 0;
}
57e04cb4:	e3a00000 	mov	r0, #0
57e04cb8:	e8bd8008 	pop	{r3, pc}
57e04cbc:	57e383cc 	.word	0x57e383cc
57e04cc0:	57e30276 	.word	0x57e30276

57e04cc4 <do_mem_mtest>:
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
57e04cc4:	e3520001 	cmp	r2, #1
 * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
 * interrupted by ctrl-c or by a failure of one of the sub-tests.
 */
static int do_mem_mtest(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
57e04cc8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e04ccc:	e1a05002 	mov	r5, r2
57e04cd0:	e1a06003 	mov	r6, r3
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
57e04cd4:	da000056 	ble	57e04e34 <do_mem_mtest+0x170>
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
57e04cd8:	e5930004 	ldr	r0, [r3, #4]
57e04cdc:	e3a01000 	mov	r1, #0
57e04ce0:	e3a02010 	mov	r2, #16
57e04ce4:	eb0080ee 	bl	57e250a4 <simple_strtoul>
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
57e04ce8:	e3550002 	cmp	r5, #2
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
57e04cec:	e58d0000 	str	r0, [sp]
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
57e04cf0:	0a000051 	beq	57e04e3c <do_mem_mtest+0x178>
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
57e04cf4:	e5960008 	ldr	r0, [r6, #8]
57e04cf8:	e3a01000 	mov	r1, #0
57e04cfc:	e3a02010 	mov	r2, #16
57e04d00:	eb0080e7 	bl	57e250a4 <simple_strtoul>
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
57e04d04:	e3550003 	cmp	r5, #3
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
57e04d08:	e58d0004 	str	r0, [sp, #4]
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
57e04d0c:	0a00004c 	beq	57e04e44 <do_mem_mtest+0x180>
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
57e04d10:	e596000c 	ldr	r0, [r6, #12]
57e04d14:	e3a01000 	mov	r1, #0
57e04d18:	e3a02010 	mov	r2, #16
57e04d1c:	eb0080e0 	bl	57e250a4 <simple_strtoul>
	else
		pattern = 0;

	if (argc > 4)
57e04d20:	e3550004 	cmp	r5, #4
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
57e04d24:	e1a04000 	mov	r4, r0
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
57e04d28:	03a0b000 	moveq	fp, #0
	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
	else
		pattern = 0;

	if (argc > 4)
57e04d2c:	0a000004 	beq	57e04d44 <do_mem_mtest+0x80>
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
57e04d30:	e5960010 	ldr	r0, [r6, #16]
57e04d34:	e3a01000 	mov	r1, #0
57e04d38:	e3a02010 	mov	r2, #16
57e04d3c:	eb0080d8 	bl	57e250a4 <simple_strtoul>
57e04d40:	e1a0b000 	mov	fp, r0
		    start[offset] = 0;
		}
	}

#else /* The original, quickie test */
	incr = 1;
57e04d44:	e3a05001 	mov	r5, #1
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
	int iterations = 1;
57e04d48:	e1a0a005 	mov	sl, r5
			char * const argv[])
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
57e04d4c:	e3a09000 	mov	r9, #0
	}

#else /* The original, quickie test */
	incr = 1;
	for (;;) {
		if (ctrlc()) {
57e04d50:	eb0011e2 	bl	57e094e0 <ctrlc>
57e04d54:	e3500000 	cmp	r0, #0
57e04d58:	1a000025 	bne	57e04df4 <do_mem_mtest+0x130>
			putc ('\n');
			return 1;
		}

		if (iteration_limit && iterations > iteration_limit) {
57e04d5c:	e35b0000 	cmp	fp, #0
57e04d60:	115a000b 	cmpne	sl, fp
57e04d64:	da000006 	ble	57e04d84 <do_mem_mtest+0xc0>
			printf("Tested %d iteration(s) with %lu errors.\n",
57e04d68:	e59f00e0 	ldr	r0, [pc, #224]	; 57e04e50 <do_mem_mtest+0x18c>
57e04d6c:	e24a1001 	sub	r1, sl, #1
57e04d70:	e1a02009 	mov	r2, r9
57e04d74:	eb0011b4 	bl	57e0944c <printf>
				iterations-1, errs);
			return errs != 0;
57e04d78:	e2590000 	subs	r0, r9, #0
57e04d7c:	13a00001 	movne	r0, #1
57e04d80:	ea00002a 	b	57e04e30 <do_mem_mtest+0x16c>
		}
		++iterations;

		printf ("\rPattern %08lX  Writing..."
57e04d84:	e59f20c8 	ldr	r2, [pc, #200]	; 57e04e54 <do_mem_mtest+0x190>
57e04d88:	e59f00c8 	ldr	r0, [pc, #200]	; 57e04e58 <do_mem_mtest+0x194>
57e04d8c:	e1a01004 	mov	r1, r4
57e04d90:	eb0011ad 	bl	57e0944c <printf>
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
57e04d94:	e1a02004 	mov	r2, r4
57e04d98:	e59d3000 	ldr	r3, [sp]
57e04d9c:	ea000001 	b	57e04da8 <do_mem_mtest+0xe4>
			WATCHDOG_RESET();
			*addr = val;
57e04da0:	e4832004 	str	r2, [r3], #4
			val  += incr;
57e04da4:	e0822005 	add	r2, r2, r5
		printf ("\rPattern %08lX  Writing..."
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
57e04da8:	e59d1004 	ldr	r1, [sp, #4]
57e04dac:	e1530001 	cmp	r3, r1
57e04db0:	3afffffa 	bcc	57e04da0 <do_mem_mtest+0xdc>
			WATCHDOG_RESET();
			*addr = val;
			val  += incr;
		}

		puts ("Reading...");
57e04db4:	e59f00a0 	ldr	r0, [pc, #160]	; 57e04e5c <do_mem_mtest+0x198>
57e04db8:	eb001199 	bl	57e09424 <puts>

		for (addr=start,val=pattern; addr<end; addr++) {
57e04dbc:	e1a07004 	mov	r7, r4
57e04dc0:	e59d6000 	ldr	r6, [sp]
57e04dc4:	ea000010 	b	57e04e0c <do_mem_mtest+0x148>
			WATCHDOG_RESET();
			readback = *addr;
57e04dc8:	e5962000 	ldr	r2, [r6]
			if (readback != val) {
57e04dcc:	e1520007 	cmp	r2, r7
57e04dd0:	0a00000b 	beq	57e04e04 <do_mem_mtest+0x140>
				printf ("\nMem error @ 0x%08X: "
57e04dd4:	e1a01006 	mov	r1, r6
57e04dd8:	e1a03007 	mov	r3, r7
57e04ddc:	e59f007c 	ldr	r0, [pc, #124]	; 57e04e60 <do_mem_mtest+0x19c>
57e04de0:	eb001199 	bl	57e0944c <printf>
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
				if (ctrlc()) {
57e04de4:	eb0011bd 	bl	57e094e0 <ctrlc>
57e04de8:	e3500000 	cmp	r0, #0
			readback = *addr;
			if (readback != val) {
				printf ("\nMem error @ 0x%08X: "
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
57e04dec:	02899001 	addeq	r9, r9, #1
57e04df0:	0a000003 	beq	57e04e04 <do_mem_mtest+0x140>
				if (ctrlc()) {
					putc ('\n');
57e04df4:	e3a0000a 	mov	r0, #10
57e04df8:	eb00117f 	bl	57e093fc <putc>
					return 1;
57e04dfc:	e3a00001 	mov	r0, #1
57e04e00:	ea00000a 	b	57e04e30 <do_mem_mtest+0x16c>
				}
			}
			val += incr;
57e04e04:	e0877005 	add	r7, r7, r5
			val  += incr;
		}

		puts ("Reading...");

		for (addr=start,val=pattern; addr<end; addr++) {
57e04e08:	e2866004 	add	r6, r6, #4
57e04e0c:	e59d3004 	ldr	r3, [sp, #4]
57e04e10:	e1560003 	cmp	r6, r3
57e04e14:	3affffeb 	bcc	57e04dc8 <do_mem_mtest+0x104>
		 * Flip the pattern each time to make lots of zeros and
		 * then, the next time, lots of ones.  We decrement
		 * the "negative" patterns and increment the "positive"
		 * patterns to preserve this feature.
		 */
		if(pattern & 0x80000000) {
57e04e18:	e3540000 	cmp	r4, #0
			pattern = -pattern;	/* complement & increment */
57e04e1c:	b2644000 	rsblt	r4, r4, #0
		}
		else {
			pattern = ~pattern;
57e04e20:	a1e04004 	mvnge	r4, r4
		if (iteration_limit && iterations > iteration_limit) {
			printf("Tested %d iteration(s) with %lu errors.\n",
				iterations-1, errs);
			return errs != 0;
		}
		++iterations;
57e04e24:	e28aa001 	add	sl, sl, #1
			pattern = -pattern;	/* complement & increment */
		}
		else {
			pattern = ~pattern;
		}
		incr = -incr;
57e04e28:	e2655000 	rsb	r5, r5, #0
	}
57e04e2c:	eaffffc7 	b	57e04d50 <do_mem_mtest+0x8c>
#endif
	return 0;	/* not reached */
}
57e04e30:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;
57e04e34:	e3a01205 	mov	r1, #1342177280	; 0x50000000
57e04e38:	e58d1000 	str	r1, [sp]
57e04e3c:	e59f3020 	ldr	r3, [pc, #32]	; 57e04e64 <do_mem_mtest+0x1a0>
57e04e40:	e58d3004 	str	r3, [sp, #4]
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
57e04e44:	e3a04000 	mov	r4, #0
57e04e48:	e1a0b004 	mov	fp, r4
57e04e4c:	eaffffbc 	b	57e04d44 <do_mem_mtest+0x80>
57e04e50:	57e3028d 	.word	0x57e3028d
57e04e54:	57e302de 	.word	0x57e302de
57e04e58:	57e302b6 	.word	0x57e302b6
57e04e5c:	57e302df 	.word	0x57e302df
57e04e60:	57e302ea 	.word	0x57e302ea
57e04e64:	57e00000 	.word	0x57e00000

57e04e68 <do_mem_loop>:
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
57e04e68:	e3520002 	cmp	r2, #2
	return 0;
}

static int do_mem_loop(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
57e04e6c:	e92d4070 	push	{r4, r5, r6, lr}
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
		return CMD_RET_USAGE;
57e04e70:	d3e00000 	mvnle	r0, #0
	return 0;
}

static int do_mem_loop(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
57e04e74:	e1a06003 	mov	r6, r3
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
57e04e78:	d8bd8070 	pople	{r4, r5, r6, pc}
		return CMD_RET_USAGE;

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
57e04e7c:	e5930000 	ldr	r0, [r3]
57e04e80:	e3a01004 	mov	r1, #4
57e04e84:	eb001092 	bl	57e090d4 <cmd_get_data_size>
57e04e88:	e2505000 	subs	r5, r0, #0
57e04e8c:	ba000030 	blt	57e04f54 <do_mem_loop+0xec>
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
57e04e90:	e3a01000 	mov	r1, #0
57e04e94:	e3a02010 	mov	r2, #16
57e04e98:	e5960004 	ldr	r0, [r6, #4]
57e04e9c:	eb008080 	bl	57e250a4 <simple_strtoul>

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
57e04ea0:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
57e04ea4:	e1a04000 	mov	r4, r0

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
57e04ea8:	e3a02010 	mov	r2, #16
57e04eac:	e5960008 	ldr	r0, [r6, #8]
57e04eb0:	eb00807b 	bl	57e250a4 <simple_strtoul>

	/* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
57e04eb4:	e3500001 	cmp	r0, #1
57e04eb8:	1a000009 	bne	57e04ee4 <do_mem_loop+0x7c>
		if (size == 4) {
57e04ebc:	e3550004 	cmp	r5, #4
57e04ec0:	1a000001 	bne	57e04ecc <do_mem_loop+0x64>
			longp = (uint *)addr;
			for (;;)
				i = *longp;
57e04ec4:	e5943000 	ldr	r3, [r4]
57e04ec8:	eafffffd 	b	57e04ec4 <do_mem_loop+0x5c>
		}
		if (size == 2) {
57e04ecc:	e3550002 	cmp	r5, #2
57e04ed0:	1a000001 	bne	57e04edc <do_mem_loop+0x74>
			shortp = (ushort *)addr;
			for (;;)
				i = *shortp;
57e04ed4:	e1d430b0 	ldrh	r3, [r4]
57e04ed8:	eafffffd 	b	57e04ed4 <do_mem_loop+0x6c>
		}
		cp = (u_char *)addr;
		for (;;)
			i = *cp;
57e04edc:	e5d43000 	ldrb	r3, [r4]
57e04ee0:	eafffffd 	b	57e04edc <do_mem_loop+0x74>
	}

	if (size == 4) {
57e04ee4:	e3550004 	cmp	r5, #4
57e04ee8:	1a000007 	bne	57e04f0c <do_mem_loop+0xa4>
		for (;;) {
			longp = (uint *)addr;
57e04eec:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
57e04ef0:	e1a03000 	mov	r3, r0
57e04ef4:	ea000001 	b	57e04f00 <do_mem_loop+0x98>
				*longp++;
57e04ef8:	e4921004 	ldr	r1, [r2], #4
57e04efc:	e2433001 	sub	r3, r3, #1

	if (size == 4) {
		for (;;) {
			longp = (uint *)addr;
			i = length;
			while (i-- > 0)
57e04f00:	e3530000 	cmp	r3, #0
57e04f04:	0afffff8 	beq	57e04eec <do_mem_loop+0x84>
57e04f08:	eafffffa 	b	57e04ef8 <do_mem_loop+0x90>
				*longp++;
		}
	}
	if (size == 2) {
57e04f0c:	e3550002 	cmp	r5, #2
57e04f10:	1a000007 	bne	57e04f34 <do_mem_loop+0xcc>
		for (;;) {
			shortp = (ushort *)addr;
57e04f14:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
57e04f18:	e1a03000 	mov	r3, r0
57e04f1c:	ea000001 	b	57e04f28 <do_mem_loop+0xc0>
				*shortp++;
57e04f20:	e0d210b2 	ldrh	r1, [r2], #2
57e04f24:	e2433001 	sub	r3, r3, #1
	}
	if (size == 2) {
		for (;;) {
			shortp = (ushort *)addr;
			i = length;
			while (i-- > 0)
57e04f28:	e3530000 	cmp	r3, #0
57e04f2c:	0afffff8 	beq	57e04f14 <do_mem_loop+0xac>
57e04f30:	eafffffa 	b	57e04f20 <do_mem_loop+0xb8>
				*shortp++;
		}
	}
	for (;;) {
		cp = (u_char *)addr;
57e04f34:	e1a02004 	mov	r2, r4
		i = length;
		while (i-- > 0)
57e04f38:	e1a03000 	mov	r3, r0
57e04f3c:	ea000001 	b	57e04f48 <do_mem_loop+0xe0>
			*cp++;
57e04f40:	e4d21001 	ldrb	r1, [r2], #1
57e04f44:	e2433001 	sub	r3, r3, #1
		}
	}
	for (;;) {
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
57e04f48:	e3530000 	cmp	r3, #0
57e04f4c:	0afffff8 	beq	57e04f34 <do_mem_loop+0xcc>
57e04f50:	eafffffa 	b	57e04f40 <do_mem_loop+0xd8>

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
57e04f54:	e3a00001 	mov	r0, #1
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
			*cp++;
	}
}
57e04f58:	e8bd8070 	pop	{r4, r5, r6, pc}

57e04f5c <do_mem_cmp>:
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

static int do_mem_cmp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e04f5c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
57e04f60:	e3520004 	cmp	r2, #4
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

static int do_mem_cmp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e04f64:	e24dd018 	sub	sp, sp, #24
57e04f68:	e1a05003 	mov	r5, r3
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
		return CMD_RET_USAGE;
57e04f6c:	13e06000 	mvnne	r6, #0
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
57e04f70:	1a00003f 	bne	57e05074 <do_mem_cmp+0x118>
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
57e04f74:	e5930000 	ldr	r0, [r3]
57e04f78:	e1a01002 	mov	r1, r2
57e04f7c:	eb001054 	bl	57e090d4 <cmd_get_data_size>
57e04f80:	e2506000 	subs	r6, r0, #0
		return 1;
57e04f84:	b3a06001 	movlt	r6, #1
	if (argc != 4)
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
57e04f88:	ba000039 	blt	57e05074 <do_mem_cmp+0x118>
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";
57e04f8c:	e3560004 	cmp	r6, #4
57e04f90:	059f40e8 	ldreq	r4, [pc, #232]	; 57e05080 <do_mem_cmp+0x124>
57e04f94:	0a000003 	beq	57e04fa8 <do_mem_cmp+0x4c>
57e04f98:	e59f30e4 	ldr	r3, [pc, #228]	; 57e05084 <do_mem_cmp+0x128>
57e04f9c:	e3560002 	cmp	r6, #2
57e04fa0:	e59f40e0 	ldr	r4, [pc, #224]	; 57e05088 <do_mem_cmp+0x12c>
57e04fa4:	01a04003 	moveq	r4, r3

	addr1 = simple_strtoul(argv[1], NULL, 16);
57e04fa8:	e5950004 	ldr	r0, [r5, #4]
57e04fac:	e3a01000 	mov	r1, #0
57e04fb0:	e3a02010 	mov	r2, #16
57e04fb4:	eb00803a 	bl	57e250a4 <simple_strtoul>
	addr1 += base_address;
57e04fb8:	e59fa0cc 	ldr	sl, [pc, #204]	; 57e0508c <do_mem_cmp+0x130>

	addr2 = simple_strtoul(argv[2], NULL, 16);
57e04fbc:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
57e04fc0:	e59a7000 	ldr	r7, [sl]

	addr2 = simple_strtoul(argv[2], NULL, 16);
57e04fc4:	e3a02010 	mov	r2, #16
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
57e04fc8:	e0807007 	add	r7, r0, r7

	addr2 = simple_strtoul(argv[2], NULL, 16);
57e04fcc:	e5950008 	ldr	r0, [r5, #8]
57e04fd0:	eb008033 	bl	57e250a4 <simple_strtoul>
	addr2 += base_address;
57e04fd4:	e59aa000 	ldr	sl, [sl]

	count = simple_strtoul(argv[3], NULL, 16);
57e04fd8:	e3a01000 	mov	r1, #0

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;

	addr2 = simple_strtoul(argv[2], NULL, 16);
	addr2 += base_address;
57e04fdc:	e080a00a 	add	sl, r0, sl

	count = simple_strtoul(argv[3], NULL, 16);
57e04fe0:	e3a02010 	mov	r2, #16
57e04fe4:	e595000c 	ldr	r0, [r5, #12]
57e04fe8:	eb00802d 	bl	57e250a4 <simple_strtoul>
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
57e04fec:	e3a05000 	mov	r5, #0
57e04ff0:	ea000018 	b	57e05058 <do_mem_cmp+0xfc>
		ulong word1, word2;
		if (size == 4) {
57e04ff4:	e3560004 	cmp	r6, #4
			word1 = *(ulong *)addr1;
57e04ff8:	05972000 	ldreq	r2, [r7]
			word2 = *(ulong *)addr2;
57e04ffc:	059a3000 	ldreq	r3, [sl]
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
		ulong word1, word2;
		if (size == 4) {
57e05000:	0a000004 	beq	57e05018 <do_mem_cmp+0xbc>
			word1 = *(ulong *)addr1;
			word2 = *(ulong *)addr2;
		} else if (size == 2) {
57e05004:	e3560002 	cmp	r6, #2
			word1 = *(ushort *)addr1;
57e05008:	01d720b0 	ldrheq	r2, [r7]
			word2 = *(ushort *)addr2;
57e0500c:	01da30b0 	ldrheq	r3, [sl]
		} else {
			word1 = *(u_char *)addr1;
57e05010:	15d72000 	ldrbne	r2, [r7]
			word2 = *(u_char *)addr2;
57e05014:	15da3000 	ldrbne	r3, [sl]
		}
		if (word1 != word2) {
57e05018:	e1520003 	cmp	r2, r3
57e0501c:	0a00000a 	beq	57e0504c <do_mem_cmp+0xf0>
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
57e05020:	e58d2000 	str	r2, [sp]
57e05024:	e58d3010 	str	r3, [sp, #16]
57e05028:	e59f0060 	ldr	r0, [pc, #96]	; 57e05090 <do_mem_cmp+0x134>
57e0502c:	e1a03006 	mov	r3, r6
57e05030:	e1a01004 	mov	r1, r4
57e05034:	e1a02007 	mov	r2, r7
57e05038:	e58d600c 	str	r6, [sp, #12]
57e0503c:	e98d0410 	stmib	sp, {r4, sl}
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
57e05040:	e3a06001 	mov	r6, #1
		} else {
			word1 = *(u_char *)addr1;
			word2 = *(u_char *)addr2;
		}
		if (word1 != word2) {
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
57e05044:	eb001100 	bl	57e0944c <printf>
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
			break;
57e05048:	ea000005 	b	57e05064 <do_mem_cmp+0x108>
		}

		addr1 += size;
57e0504c:	e0877006 	add	r7, r7, r6
57e05050:	e08aa006 	add	sl, sl, r6
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
57e05054:	e2855001 	add	r5, r5, #1
57e05058:	e1550000 	cmp	r5, r0
57e0505c:	3affffe4 	bcc	57e04ff4 <do_mem_cmp+0x98>

static int do_mem_cmp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
57e05060:	e3a06000 	mov	r6, #0
		/* reset watchdog from time to time */
		if ((ngood % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}

	printf("Total of %ld %s(s) were the same\n", ngood, type);
57e05064:	e59f0028 	ldr	r0, [pc, #40]	; 57e05094 <do_mem_cmp+0x138>
57e05068:	e1a01005 	mov	r1, r5
57e0506c:	e1a02004 	mov	r2, r4
57e05070:	eb0010f5 	bl	57e0944c <printf>
	return rcode;
}
57e05074:	e1a00006 	mov	r0, r6
57e05078:	e28dd018 	add	sp, sp, #24
57e0507c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e05080:	57e30325 	.word	0x57e30325
57e05084:	57e30321 	.word	0x57e30321
57e05088:	57e3031c 	.word	0x57e3031c
57e0508c:	57e383cc 	.word	0x57e383cc
57e05090:	57e3032a 	.word	0x57e3032a
57e05094:	57e3035c 	.word	0x57e3035c

57e05098 <do_mem_mw>:
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

static int do_mem_mw(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e05098:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e0509c:	e1a06003 	mov	r6, r3
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
57e050a0:	e2423003 	sub	r3, r2, #3
57e050a4:	e3530001 	cmp	r3, #1
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

static int do_mem_mw(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e050a8:	e1a04002 	mov	r4, r2
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
		return CMD_RET_USAGE;
57e050ac:	83e00000 	mvnhi	r0, #0
static int do_mem_mw(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
57e050b0:	88bd84f0 	pophi	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
57e050b4:	e5960000 	ldr	r0, [r6]
57e050b8:	e3a01004 	mov	r1, #4
57e050bc:	eb001004 	bl	57e090d4 <cmd_get_data_size>
57e050c0:	e2507000 	subs	r7, r0, #0
57e050c4:	da00001e 	ble	57e05144 <do_mem_mw+0xac>
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
57e050c8:	e3a01000 	mov	r1, #0
57e050cc:	e3a02010 	mov	r2, #16
57e050d0:	e5960004 	ldr	r0, [r6, #4]
57e050d4:	eb007ff2 	bl	57e250a4 <simple_strtoul>
	addr += base_address;
57e050d8:	e59f306c 	ldr	r3, [pc, #108]	; 57e0514c <do_mem_mw+0xb4>

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
57e050dc:	e3a01000 	mov	r1, #0
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
57e050e0:	e5935000 	ldr	r5, [r3]

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
57e050e4:	e3a02010 	mov	r2, #16
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
57e050e8:	e0805005 	add	r5, r0, r5

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
57e050ec:	e5960008 	ldr	r0, [r6, #8]
57e050f0:	eb007feb 	bl	57e250a4 <simple_strtoul>

	/* Count ? */
	if (argc == 4) {
57e050f4:	e3540004 	cmp	r4, #4
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
57e050f8:	e1a0a000 	mov	sl, r0

	/* Count ? */
	if (argc == 4) {
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
57e050fc:	13a00001 	movne	r0, #1
	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);

	/* Count ? */
	if (argc == 4) {
57e05100:	1a00000c 	bne	57e05138 <do_mem_mw+0xa0>
		count = simple_strtoul(argv[3], NULL, 16);
57e05104:	e596000c 	ldr	r0, [r6, #12]
57e05108:	e3a01000 	mov	r1, #0
57e0510c:	e3a02010 	mov	r2, #16
57e05110:	eb007fe3 	bl	57e250a4 <simple_strtoul>
57e05114:	ea000007 	b	57e05138 <do_mem_mw+0xa0>
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
57e05118:	e3570004 	cmp	r7, #4
			*((ulong  *)addr) = (ulong )writeval;
57e0511c:	0585a000 	streq	sl, [r5]
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
57e05120:	0a000002 	beq	57e05130 <do_mem_mw+0x98>
			*((ulong  *)addr) = (ulong )writeval;
		else if (size == 2)
57e05124:	e3570002 	cmp	r7, #2
			*((ushort *)addr) = (ushort)writeval;
57e05128:	01c5a0b0 	strheq	sl, [r5]
		else
			*((u_char *)addr) = (u_char)writeval;
57e0512c:	15c5a000 	strbne	sl, [r5]
57e05130:	e0855007 	add	r5, r5, r7
57e05134:	e2400001 	sub	r0, r0, #1
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
	}

	while (count-- > 0) {
57e05138:	e3500000 	cmp	r0, #0
57e0513c:	1afffff5 	bne	57e05118 <do_mem_mw+0x80>
57e05140:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
		return 1;
57e05144:	e3a00001 	mov	r0, #1
		else
			*((u_char *)addr) = (u_char)writeval;
		addr += size;
	}
	return 0;
}
57e05148:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e0514c:	57e383cc 	.word	0x57e383cc

57e05150 <do_mem_crc>:
{
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
57e05150:	e3520002 	cmp	r2, #2
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

static int do_mem_crc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e05154:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
		return CMD_RET_USAGE;
57e05158:	d3e00000 	mvnle	r0, #0
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

static int do_mem_crc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e0515c:	e1a07002 	mov	r7, r2
57e05160:	e1a04003 	mov	r4, r3
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
57e05164:	d8bd84f0 	pople	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
57e05168:	e5930004 	ldr	r0, [r3, #4]
57e0516c:	e3a01000 	mov	r1, #0
57e05170:	e3a02010 	mov	r2, #16
57e05174:	eb007fca 	bl	57e250a4 <simple_strtoul>
	addr += base_address;
57e05178:	e59f3074 	ldr	r3, [pc, #116]	; 57e051f4 <do_mem_crc+0xa4>

	length = simple_strtoul (argv[2], NULL, 16);
57e0517c:	e3a01000 	mov	r1, #0

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
57e05180:	e5935000 	ldr	r5, [r3]

	length = simple_strtoul (argv[2], NULL, 16);
57e05184:	e3a02010 	mov	r2, #16

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
57e05188:	e0805005 	add	r5, r0, r5

	length = simple_strtoul (argv[2], NULL, 16);
57e0518c:	e5940008 	ldr	r0, [r4, #8]
57e05190:	eb007fc3 	bl	57e250a4 <simple_strtoul>
57e05194:	e1a06000 	mov	r6, r0

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
57e05198:	e1a01005 	mov	r1, r5
57e0519c:	e1a02006 	mov	r2, r6
57e051a0:	e3a03801 	mov	r3, #65536	; 0x10000
57e051a4:	e3a00000 	mov	r0, #0
57e051a8:	eb00741d 	bl	57e22224 <crc32_wd>

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
			addr, addr + length - 1, crc);
57e051ac:	e2462001 	sub	r2, r6, #1
	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;

	length = simple_strtoul (argv[2], NULL, 16);

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
57e051b0:	e1a0a000 	mov	sl, r0

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
57e051b4:	e1a01005 	mov	r1, r5
57e051b8:	e59f0038 	ldr	r0, [pc, #56]	; 57e051f8 <do_mem_crc+0xa8>
57e051bc:	e0822005 	add	r2, r2, r5
57e051c0:	e1a0300a 	mov	r3, sl
57e051c4:	eb0010a0 	bl	57e0944c <printf>
			addr, addr + length - 1, crc);

	if (argc > 3) {
57e051c8:	e3570003 	cmp	r7, #3
57e051cc:	0a000006 	beq	57e051ec <do_mem_crc+0x9c>
		ptr = (ulong *) simple_strtoul (argv[3], NULL, 16);
57e051d0:	e594000c 	ldr	r0, [r4, #12]
57e051d4:	e3a01000 	mov	r1, #0
57e051d8:	e3a02010 	mov	r2, #16
57e051dc:	eb007fb0 	bl	57e250a4 <simple_strtoul>
		*ptr = crc;
57e051e0:	e580a000 	str	sl, [r0]
	}

	return 0;
57e051e4:	e3a00000 	mov	r0, #0
57e051e8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e051ec:	e3a00000 	mov	r0, #0
}
57e051f0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e051f4:	57e383cc 	.word	0x57e383cc
57e051f8:	57e3037e 	.word	0x57e3037e

57e051fc <do_mem_cp>:
static int do_mem_cp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
57e051fc:	e3520004 	cmp	r2, #4
	printf("Total of %ld %s(s) were the same\n", ngood, type);
	return rcode;
}

static int do_mem_cp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e05200:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
57e05204:	e1a05003 	mov	r5, r3
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
		return CMD_RET_USAGE;
57e05208:	13e05000 	mvnne	r5, #0
static int do_mem_cp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
57e0520c:	1a00003c 	bne	57e05304 <do_mem_cp+0x108>
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
57e05210:	e5950000 	ldr	r0, [r5]
57e05214:	e1a01002 	mov	r1, r2
57e05218:	eb000fad 	bl	57e090d4 <cmd_get_data_size>
57e0521c:	e2504000 	subs	r4, r0, #0
57e05220:	ba000036 	blt	57e05300 <do_mem_cp+0x104>
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
57e05224:	e5950004 	ldr	r0, [r5, #4]
57e05228:	e3a01000 	mov	r1, #0
57e0522c:	e3a02010 	mov	r2, #16
57e05230:	eb007f9b 	bl	57e250a4 <simple_strtoul>
	addr += base_address;
57e05234:	e59f60d0 	ldr	r6, [pc, #208]	; 57e0530c <do_mem_cp+0x110>

	dest = simple_strtoul(argv[2], NULL, 16);
57e05238:	e3a01000 	mov	r1, #0
57e0523c:	e3a02010 	mov	r2, #16
	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
57e05240:	e1a0a000 	mov	sl, r0
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
57e05244:	e5950008 	ldr	r0, [r5, #8]
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
57e05248:	e5967000 	ldr	r7, [r6]

	dest = simple_strtoul(argv[2], NULL, 16);
57e0524c:	eb007f94 	bl	57e250a4 <simple_strtoul>
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
57e05250:	e3a01000 	mov	r1, #0
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
57e05254:	e1a09000 	mov	r9, r0
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
57e05258:	e3a02010 	mov	r2, #16
57e0525c:	e595000c 	ldr	r0, [r5, #12]

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
57e05260:	e5966000 	ldr	r6, [r6]

	count = simple_strtoul(argv[3], NULL, 16);
57e05264:	eb007f8e 	bl	57e250a4 <simple_strtoul>

	if (count == 0) {
57e05268:	e2505000 	subs	r5, r0, #0
57e0526c:	1a000002 	bne	57e0527c <do_mem_cp+0x80>
		puts ("Zero length ???\n");
57e05270:	e59f0098 	ldr	r0, [pc, #152]	; 57e05310 <do_mem_cp+0x114>
57e05274:	eb00106a 	bl	57e09424 <puts>
57e05278:	ea000020 	b	57e05300 <do_mem_cp+0x104>

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
57e0527c:	e0896006 	add	r6, r9, r6
		return 1;
	}

#ifndef CONFIG_SYS_NO_FLASH
	/* check if we are copying to Flash */
	if ( (addr2info(dest) != NULL)
57e05280:	e1a00006 	mov	r0, r6
57e05284:	eb001a74 	bl	57e0bc5c <addr2info>
57e05288:	e3500000 	cmp	r0, #0
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
57e0528c:	e08a7007 	add	r7, sl, r7
		return 1;
	}

#ifndef CONFIG_SYS_NO_FLASH
	/* check if we are copying to Flash */
	if ( (addr2info(dest) != NULL)
57e05290:	0a00000c 	beq	57e052c8 <do_mem_cp+0xcc>
	   && (!addr_dataflash(dest))
#endif
	   ) {
		int rc;

		puts ("Copy to Flash... ");
57e05294:	e59f0078 	ldr	r0, [pc, #120]	; 57e05314 <do_mem_cp+0x118>
57e05298:	eb001061 	bl	57e09424 <puts>

		rc = flash_write ((char *)addr, dest, count*size);
57e0529c:	e0020594 	mul	r2, r4, r5
57e052a0:	e1a00007 	mov	r0, r7
57e052a4:	e1a01006 	mov	r1, r6
57e052a8:	eb001a7f 	bl	57e0bcac <flash_write>
		if (rc != 0) {
57e052ac:	e2505000 	subs	r5, r0, #0
57e052b0:	0a000001 	beq	57e052bc <do_mem_cp+0xc0>
			flash_perror (rc);
57e052b4:	eb001ad4 	bl	57e0be0c <flash_perror>
57e052b8:	ea000010 	b	57e05300 <do_mem_cp+0x104>
			return (1);
		}
		puts ("done\n");
57e052bc:	e59f0054 	ldr	r0, [pc, #84]	; 57e05318 <do_mem_cp+0x11c>
57e052c0:	eb001057 	bl	57e09424 <puts>
		return 0;
57e052c4:	ea00000e 	b	57e05304 <do_mem_cp+0x108>
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
57e052c8:	e3540004 	cmp	r4, #4
			*((ulong  *)dest) = *((ulong  *)addr);
57e052cc:	05973000 	ldreq	r3, [r7]
57e052d0:	05863000 	streq	r3, [r6]
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
57e052d4:	0a000004 	beq	57e052ec <do_mem_cp+0xf0>
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
57e052d8:	e3540002 	cmp	r4, #2
			*((ushort *)dest) = *((ushort *)addr);
57e052dc:	01d730b0 	ldrheq	r3, [r7]
		else
			*((u_char *)dest) = *((u_char *)addr);
57e052e0:	15d73000 	ldrbne	r3, [r7]

	while (count-- > 0) {
		if (size == 4)
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
57e052e4:	01c630b0 	strheq	r3, [r6]
		else
			*((u_char *)dest) = *((u_char *)addr);
57e052e8:	15c63000 	strbne	r3, [r6]
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
57e052ec:	e2555001 	subs	r5, r5, #1
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
		else
			*((u_char *)dest) = *((u_char *)addr);
		addr += size;
57e052f0:	e0877004 	add	r7, r7, r4
57e052f4:	e0866004 	add	r6, r6, r4
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
57e052f8:	1afffff2 	bne	57e052c8 <do_mem_cp+0xcc>
57e052fc:	ea000000 	b	57e05304 <do_mem_cp+0x108>
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
57e05300:	e3a05001 	mov	r5, #1
		/* reset watchdog from time to time */
		if ((count % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}
	return 0;
}
57e05304:	e1a00005 	mov	r0, r5
57e05308:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
57e0530c:	57e383cc 	.word	0x57e383cc
57e05310:	57e303a3 	.word	0x57e303a3
57e05314:	57e303b4 	.word	0x57e303b4
57e05318:	57e35bf2 	.word	0x57e35bf2

57e0531c <do_mem_md>:
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
static int do_mem_md(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e0531c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
57e05320:	e59fa0b8 	ldr	sl, [pc, #184]	; 57e053e0 <do_mem_md+0xc4>
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
static int do_mem_md(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e05324:	e1a07003 	mov	r7, r3
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;
57e05328:	e59f30b4 	ldr	r3, [pc, #180]	; 57e053e4 <do_mem_md+0xc8>

	if (argc < 2)
57e0532c:	e3520001 	cmp	r2, #1
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
static int do_mem_md(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e05330:	e1a0b002 	mov	fp, r2
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
57e05334:	e59a6004 	ldr	r6, [sl, #4]
	size = dp_last_size;
57e05338:	e59a4008 	ldr	r4, [sl, #8]
	length = dp_last_length;
57e0533c:	e5935000 	ldr	r5, [r3]

	if (argc < 2)
		return CMD_RET_USAGE;
57e05340:	d3e00000 	mvnle	r0, #0
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;

	if (argc < 2)
57e05344:	da000024 	ble	57e053dc <do_mem_md+0xc0>
		return CMD_RET_USAGE;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
57e05348:	e2119001 	ands	r9, r1, #1
57e0534c:	1a000012 	bne	57e0539c <do_mem_md+0x80>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
57e05350:	e5970000 	ldr	r0, [r7]
57e05354:	e3a01004 	mov	r1, #4
57e05358:	eb000f5d 	bl	57e090d4 <cmd_get_data_size>
57e0535c:	e2504000 	subs	r4, r0, #0
			return 1;
57e05360:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
57e05364:	ba00001c 	blt	57e053dc <do_mem_md+0xc0>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
57e05368:	e5970004 	ldr	r0, [r7, #4]
57e0536c:	e1a01009 	mov	r1, r9
57e05370:	e3a02010 	mov	r2, #16
57e05374:	eb007f4a 	bl	57e250a4 <simple_strtoul>
		addr += base_address;
57e05378:	e59a6000 	ldr	r6, [sl]

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
57e0537c:	e35b0002 	cmp	fp, #2
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
		addr += base_address;
57e05380:	e0806006 	add	r6, r0, r6

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
57e05384:	0a000004 	beq	57e0539c <do_mem_md+0x80>
			length = simple_strtoul(argv[2], NULL, 16);
57e05388:	e5970008 	ldr	r0, [r7, #8]
57e0538c:	e1a01009 	mov	r1, r9
57e05390:	e3a02010 	mov	r2, #16
57e05394:	eb007f42 	bl	57e250a4 <simple_strtoul>
57e05398:	e1a05000 	mov	r5, r0
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
57e0539c:	e1a01004 	mov	r1, r4
57e053a0:	e3a00010 	mov	r0, #16
57e053a4:	eb009984 	bl	57e2b9bc <__divsi3>
57e053a8:	e1a01006 	mov	r1, r6
57e053ac:	e58d0000 	str	r0, [sp]
57e053b0:	e1a00006 	mov	r0, r6
		addr += size*length;
57e053b4:	e0266495 	mla	r6, r5, r4, r6
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
57e053b8:	e1a02004 	mov	r2, r4
57e053bc:	e1a03005 	mov	r3, r5
57e053c0:	eb0073f6 	bl	57e223a0 <print_buffer>
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
57e053c4:	e59f3014 	ldr	r3, [pc, #20]	; 57e053e0 <do_mem_md+0xc4>
	dp_last_length = length;
57e053c8:	e59f2014 	ldr	r2, [pc, #20]	; 57e053e4 <do_mem_md+0xc8>
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
57e053cc:	e5836004 	str	r6, [r3, #4]
	dp_last_length = length;
57e053d0:	e5825000 	str	r5, [r2]
	dp_last_size = size;
57e053d4:	e5834008 	str	r4, [r3, #8]
	return (rc);
57e053d8:	e3a00000 	mov	r0, #0
}
57e053dc:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e053e0:	57e383cc 	.word	0x57e383cc
57e053e4:	57e36228 	.word	0x57e36228

57e053e8 <mod_mem.clone.0>:
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
57e053e8:	e3520002 	cmp	r2, #2
 * Syntax:
 *	mm{.b, .w, .l} {addr}
 *	nm{.b, .w, .l} {addr}
 */
static int
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
57e053ec:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
57e053f0:	e1a04000 	mov	r4, r0
57e053f4:	e1a0a003 	mov	sl, r3
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
		return CMD_RET_USAGE;
57e053f8:	13e00000 	mvnne	r0, #0
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
57e053fc:	1a000040 	bne	57e05504 <mod_mem.clone.0+0x11c>
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
57e05400:	e59f7114 	ldr	r7, [pc, #276]	; 57e0551c <mod_mem.clone.0+0x134>
	size = mm_last_size;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
57e05404:	e2119001 	ands	r9, r1, #1
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
57e05408:	e597500c 	ldr	r5, [r7, #12]
	size = mm_last_size;
57e0540c:	e5976010 	ldr	r6, [r7, #16]

	if ((flag & CMD_FLAG_REPEAT) == 0) {
57e05410:	1a00000b 	bne	57e05444 <mod_mem.clone.0+0x5c>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
57e05414:	e5930000 	ldr	r0, [r3]
57e05418:	e3a01004 	mov	r1, #4
57e0541c:	eb000f2c 	bl	57e090d4 <cmd_get_data_size>
57e05420:	e2506000 	subs	r6, r0, #0
			return 1;
57e05424:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
57e05428:	ba000035 	blt	57e05504 <mod_mem.clone.0+0x11c>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
57e0542c:	e59a0004 	ldr	r0, [sl, #4]
57e05430:	e1a01009 	mov	r1, r9
57e05434:	e3a02010 	mov	r2, #16
57e05438:	eb007f19 	bl	57e250a4 <simple_strtoul>
		addr += base_address;
57e0543c:	e5975000 	ldr	r5, [r7]
57e05440:	e0805005 	add	r5, r0, r5
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
57e05444:	e59f70d4 	ldr	r7, [pc, #212]	; 57e05520 <mod_mem.clone.0+0x138>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
				addr += nbytes ? -size : size;
57e05448:	e266a000 	rsb	sl, r6, #0
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
57e0544c:	e28d9004 	add	r9, sp, #4

	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
57e05450:	e1a01005 	mov	r1, r5
57e05454:	e59f00c8 	ldr	r0, [pc, #200]	; 57e05524 <mod_mem.clone.0+0x13c>
57e05458:	eb000ffb 	bl	57e0944c <printf>
		if (size == 4)
57e0545c:	e3560004 	cmp	r6, #4
			printf(" %08x", *((uint   *)addr));
57e05460:	059f00c0 	ldreq	r0, [pc, #192]	; 57e05528 <mod_mem.clone.0+0x140>
57e05464:	05951000 	ldreq	r1, [r5]
	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
		if (size == 4)
57e05468:	0a000004 	beq	57e05480 <mod_mem.clone.0+0x98>
			printf(" %08x", *((uint   *)addr));
		else if (size == 2)
57e0546c:	e3560002 	cmp	r6, #2
			printf(" %04x", *((ushort *)addr));
57e05470:	059f00b4 	ldreq	r0, [pc, #180]	; 57e0552c <mod_mem.clone.0+0x144>
57e05474:	01d510b0 	ldrheq	r1, [r5]
		else
			printf(" %02x", *((u_char *)addr));
57e05478:	159f00b0 	ldrne	r0, [pc, #176]	; 57e05530 <mod_mem.clone.0+0x148>
57e0547c:	15d51000 	ldrbne	r1, [r5]
57e05480:	eb000ff1 	bl	57e0944c <printf>

		nbytes = readline (" ? ");
57e05484:	e59f00a8 	ldr	r0, [pc, #168]	; 57e05534 <mod_mem.clone.0+0x14c>
57e05488:	eb002782 	bl	57e0f298 <readline>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
57e0548c:	e3500000 	cmp	r0, #0
57e05490:	0a000004 	beq	57e054a8 <mod_mem.clone.0+0xc0>
57e05494:	e3500001 	cmp	r0, #1
57e05498:	1a000009 	bne	57e054c4 <mod_mem.clone.0+0xdc>
57e0549c:	e5d73000 	ldrb	r3, [r7]
57e054a0:	e353002d 	cmp	r3, #45	; 0x2d
57e054a4:	1a000006 	bne	57e054c4 <mod_mem.clone.0+0xdc>
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
57e054a8:	e3540000 	cmp	r4, #0
57e054ac:	0affffe7 	beq	57e05450 <mod_mem.clone.0+0x68>
				addr += nbytes ? -size : size;
57e054b0:	e3500000 	cmp	r0, #0
57e054b4:	01a03006 	moveq	r3, r6
57e054b8:	11a0300a 	movne	r3, sl
57e054bc:	e0855003 	add	r5, r5, r3
57e054c0:	eaffffe2 	b	57e05450 <mod_mem.clone.0+0x68>
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
57e054c4:	e59f0054 	ldr	r0, [pc, #84]	; 57e05520 <mod_mem.clone.0+0x138>
57e054c8:	e1a01009 	mov	r1, r9
57e054cc:	e3a02010 	mov	r2, #16
57e054d0:	eb007ef3 	bl	57e250a4 <simple_strtoul>
			nbytes = endp - console_buffer;
			if (nbytes) {
57e054d4:	e59d3004 	ldr	r3, [sp, #4]
57e054d8:	e1530007 	cmp	r3, r7
57e054dc:	0a000009 	beq	57e05508 <mod_mem.clone.0+0x120>
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
57e054e0:	e3560004 	cmp	r6, #4
					*((uint   *)addr) = i;
57e054e4:	05850000 	streq	r0, [r5]
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
57e054e8:	0a000002 	beq	57e054f8 <mod_mem.clone.0+0x110>
					*((uint   *)addr) = i;
				else if (size == 2)
57e054ec:	e3560002 	cmp	r6, #2
					*((ushort *)addr) = i;
57e054f0:	01c500b0 	strheq	r0, [r5]
				else
					*((u_char *)addr) = i;
57e054f4:	15c50000 	strbne	r0, [r5]
				if (incrflag)
57e054f8:	e3540000 	cmp	r4, #0
					addr += size;
57e054fc:	10855006 	addne	r5, r5, r6
57e05500:	eaffffd2 	b	57e05450 <mod_mem.clone.0+0x68>
	} while (nbytes);

	mm_last_addr = addr;
	mm_last_size = size;
	return 0;
}
57e05504:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
57e05508:	e59f300c 	ldr	r3, [pc, #12]	; 57e0551c <mod_mem.clone.0+0x134>
	mm_last_size = size;
	return 0;
57e0550c:	e3a00000 	mov	r0, #0
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
57e05510:	e583500c 	str	r5, [r3, #12]
	mm_last_size = size;
57e05514:	e5836010 	str	r6, [r3, #16]
57e05518:	eafffff9 	b	57e05504 <mod_mem.clone.0+0x11c>
57e0551c:	57e383cc 	.word	0x57e383cc
57e05520:	57e39aec 	.word	0x57e39aec
57e05524:	57e303c6 	.word	0x57e303c6
57e05528:	57e303cd 	.word	0x57e303cd
57e0552c:	57e303d3 	.word	0x57e303d3
57e05530:	57e303d9 	.word	0x57e303d9
57e05534:	57e303df 	.word	0x57e303df

57e05538 <do_mem_nm>:
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
}
static int do_mem_nm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
57e05538:	e3a00000 	mov	r0, #0
57e0553c:	eaffffa9 	b	57e053e8 <mod_mem.clone.0>

57e05540 <do_mem_mm>:
	return (rc);
}

static int do_mem_mm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
57e05540:	e3a00001 	mov	r0, #1
57e05544:	eaffffa7 	b	57e053e8 <mod_mem.clone.0>

57e05548 <do_sleep>:
 */
#include <common.h>
#include <command.h>

static int do_sleep(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e05548:	e92d4070 	push	{r4, r5, r6, lr}
	ulong start = get_timer(0);
57e0554c:	e3a00000 	mov	r0, #0
 */
#include <common.h>
#include <command.h>

static int do_sleep(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e05550:	e1a05002 	mov	r5, r2
57e05554:	e1a06003 	mov	r6, r3
	ulong start = get_timer(0);
57e05558:	ebffed6b 	bl	57e00b0c <get_timer>
	ulong delay;

	if (argc != 2)
57e0555c:	e3550002 	cmp	r5, #2
#include <common.h>
#include <command.h>

static int do_sleep(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong start = get_timer(0);
57e05560:	e1a04000 	mov	r4, r0
	ulong delay;

	if (argc != 2)
		return CMD_RET_USAGE;
57e05564:	13e00000 	mvnne	r0, #0
static int do_sleep(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong start = get_timer(0);
	ulong delay;

	if (argc != 2)
57e05568:	18bd8070 	popne	{r4, r5, r6, pc}
		return CMD_RET_USAGE;

	delay = simple_strtoul(argv[1], NULL, 10) * CONFIG_SYS_HZ;
57e0556c:	e5960004 	ldr	r0, [r6, #4]
57e05570:	e3a01000 	mov	r1, #0
57e05574:	e3a0200a 	mov	r2, #10
57e05578:	eb007ec9 	bl	57e250a4 <simple_strtoul>
57e0557c:	e3a05ffa 	mov	r5, #1000	; 0x3e8
57e05580:	e0050590 	mul	r5, r0, r5

	while (get_timer(start) < delay) {
57e05584:	ea000004 	b	57e0559c <do_sleep+0x54>
		if (ctrlc())
57e05588:	eb000fd4 	bl	57e094e0 <ctrlc>
57e0558c:	e3500000 	cmp	r0, #0
57e05590:	1a000007 	bne	57e055b4 <do_sleep+0x6c>
			return (-1);

		udelay(100);
57e05594:	e2800064 	add	r0, r0, #100	; 0x64
57e05598:	eb007be6 	bl	57e24538 <udelay>
	if (argc != 2)
		return CMD_RET_USAGE;

	delay = simple_strtoul(argv[1], NULL, 10) * CONFIG_SYS_HZ;

	while (get_timer(start) < delay) {
57e0559c:	e1a00004 	mov	r0, r4
57e055a0:	ebffed59 	bl	57e00b0c <get_timer>
57e055a4:	e1500005 	cmp	r0, r5
57e055a8:	3afffff6 	bcc	57e05588 <do_sleep+0x40>
			return (-1);

		udelay(100);
	}

	return 0;
57e055ac:	e3a00000 	mov	r0, #0
57e055b0:	e8bd8070 	pop	{r4, r5, r6, pc}

	delay = simple_strtoul(argv[1], NULL, 10) * CONFIG_SYS_HZ;

	while (get_timer(start) < delay) {
		if (ctrlc())
			return (-1);
57e055b4:	e3e00000 	mvn	r0, #0

		udelay(100);
	}

	return 0;
}
57e055b8:	e8bd8070 	pop	{r4, r5, r6, pc}

57e055bc <do_nandboot>:
	return bootm_maybe_autostart(cmdtp, cmd);
}

static int do_nandboot(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
57e055bc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e055c0:	e1a04002 	mov	r4, r2
57e055c4:	e24dd018 	sub	sp, sp, #24
57e055c8:	e58d000c 	str	r0, [sp, #12]
		}
	}
#endif

	bootstage_mark(BOOTSTAGE_ID_NAND_PART);
	switch (argc) {
57e055cc:	e2444001 	sub	r4, r4, #1
57e055d0:	e3a00034 	mov	r0, #52	; 0x34
	return bootm_maybe_autostart(cmdtp, cmd);
}

static int do_nandboot(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
57e055d4:	e1a06003 	mov	r6, r3
57e055d8:	eb0024e1 	bl	57e0e964 <__show_boot_progress>
		}
	}
#endif

	bootstage_mark(BOOTSTAGE_ID_NAND_PART);
	switch (argc) {
57e055dc:	e3540003 	cmp	r4, #3
57e055e0:	979ff104 	ldrls	pc, [pc, r4, lsl #2]
57e055e4:	ea000026 	b	57e05684 <do_nandboot+0xc8>
57e055e8:	57e055f8 	.word	0x57e055f8
57e055ec:	57e05610 	.word	0x57e05610
57e055f0:	57e05634 	.word	0x57e05634
57e055f4:	57e05654 	.word	0x57e05654
	case 1:
		addr = CONFIG_SYS_LOAD_ADDR;
		boot_device = getenv("bootdevice");
57e055f8:	e59f0280 	ldr	r0, [pc, #640]	; 57e05880 <do_nandboot+0x2c4>
57e055fc:	eb000839 	bl	57e076e8 <getenv>
static int do_nandboot(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
	char *boot_device = NULL;
	int idx;
	ulong addr, offset = 0;
57e05600:	e3a05000 	mov	r5, #0

	bootstage_mark(BOOTSTAGE_ID_NAND_PART);
	switch (argc) {
	case 1:
		addr = CONFIG_SYS_LOAD_ADDR;
		boot_device = getenv("bootdevice");
57e05604:	e1a07000 	mov	r7, r0
#endif

	bootstage_mark(BOOTSTAGE_ID_NAND_PART);
	switch (argc) {
	case 1:
		addr = CONFIG_SYS_LOAD_ADDR;
57e05608:	e3a04205 	mov	r4, #1342177280	; 0x50000000
		boot_device = getenv("bootdevice");
		break;
57e0560c:	ea000020 	b	57e05694 <do_nandboot+0xd8>
	case 2:
		addr = simple_strtoul(argv[1], NULL, 16);
57e05610:	e3a01000 	mov	r1, #0
57e05614:	e3a02010 	mov	r2, #16
57e05618:	e5960004 	ldr	r0, [r6, #4]
57e0561c:	eb007ea0 	bl	57e250a4 <simple_strtoul>
57e05620:	e1a04000 	mov	r4, r0
		boot_device = getenv("bootdevice");
57e05624:	e59f0254 	ldr	r0, [pc, #596]	; 57e05880 <do_nandboot+0x2c4>
57e05628:	eb00082e 	bl	57e076e8 <getenv>
57e0562c:	e1a07000 	mov	r7, r0
57e05630:	ea000005 	b	57e0564c <do_nandboot+0x90>
		break;
	case 3:
		addr = simple_strtoul(argv[1], NULL, 16);
57e05634:	e5960004 	ldr	r0, [r6, #4]
57e05638:	e3a01000 	mov	r1, #0
57e0563c:	e3a02010 	mov	r2, #16
57e05640:	eb007e97 	bl	57e250a4 <simple_strtoul>
		boot_device = argv[2];
57e05644:	e5967008 	ldr	r7, [r6, #8]
	case 2:
		addr = simple_strtoul(argv[1], NULL, 16);
		boot_device = getenv("bootdevice");
		break;
	case 3:
		addr = simple_strtoul(argv[1], NULL, 16);
57e05648:	e1a04000 	mov	r4, r0
static int do_nandboot(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
	char *boot_device = NULL;
	int idx;
	ulong addr, offset = 0;
57e0564c:	e3a05000 	mov	r5, #0
		boot_device = getenv("bootdevice");
		break;
	case 3:
		addr = simple_strtoul(argv[1], NULL, 16);
		boot_device = argv[2];
		break;
57e05650:	ea00000f 	b	57e05694 <do_nandboot+0xd8>
	case 4:
		addr = simple_strtoul(argv[1], NULL, 16);
57e05654:	e3a01000 	mov	r1, #0
57e05658:	e3a02010 	mov	r2, #16
57e0565c:	e5960004 	ldr	r0, [r6, #4]
57e05660:	eb007e8f 	bl	57e250a4 <simple_strtoul>
		boot_device = argv[2];
		offset = simple_strtoul(argv[3], NULL, 16);
57e05664:	e3a01000 	mov	r1, #0
	case 3:
		addr = simple_strtoul(argv[1], NULL, 16);
		boot_device = argv[2];
		break;
	case 4:
		addr = simple_strtoul(argv[1], NULL, 16);
57e05668:	e1a04000 	mov	r4, r0
		boot_device = argv[2];
		offset = simple_strtoul(argv[3], NULL, 16);
57e0566c:	e3a02010 	mov	r2, #16
57e05670:	e596000c 	ldr	r0, [r6, #12]
		addr = simple_strtoul(argv[1], NULL, 16);
		boot_device = argv[2];
		break;
	case 4:
		addr = simple_strtoul(argv[1], NULL, 16);
		boot_device = argv[2];
57e05674:	e5967008 	ldr	r7, [r6, #8]
		offset = simple_strtoul(argv[3], NULL, 16);
57e05678:	eb007e89 	bl	57e250a4 <simple_strtoul>
57e0567c:	e1a05000 	mov	r5, r0
		break;
57e05680:	ea000003 	b	57e05694 <do_nandboot+0xd8>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e05684:	e3e00034 	mvn	r0, #52	; 0x34
57e05688:	eb0024b5 	bl	57e0e964 <__show_boot_progress>
	default:
#if defined(CONFIG_CMD_MTDPARTS)
usage:
#endif
		bootstage_error(BOOTSTAGE_ID_NAND_SUFFIX);
		return CMD_RET_USAGE;
57e0568c:	e3e00000 	mvn	r0, #0
57e05690:	ea000078 	b	57e05878 <do_nandboot+0x2bc>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e05694:	e3a00035 	mov	r0, #53	; 0x35
57e05698:	eb0024b1 	bl	57e0e964 <__show_boot_progress>
	}
	bootstage_mark(BOOTSTAGE_ID_NAND_SUFFIX);

	if (!boot_device) {
57e0569c:	e3570000 	cmp	r7, #0
57e056a0:	1a000003 	bne	57e056b4 <do_nandboot+0xf8>
		puts("\n** No boot device **\n");
57e056a4:	e59f01d8 	ldr	r0, [pc, #472]	; 57e05884 <do_nandboot+0x2c8>
57e056a8:	eb000f5d 	bl	57e09424 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e056ac:	e3e00035 	mvn	r0, #53	; 0x35
57e056b0:	ea00000e 	b	57e056f0 <do_nandboot+0x134>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e056b4:	e3a00036 	mov	r0, #54	; 0x36
57e056b8:	eb0024a9 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_NAND_BOOT_DEVICE);
		return 1;
	}
	bootstage_mark(BOOTSTAGE_ID_NAND_BOOT_DEVICE);

	idx = simple_strtoul(boot_device, NULL, 16);
57e056bc:	e3a01000 	mov	r1, #0
57e056c0:	e1a00007 	mov	r0, r7
57e056c4:	e3a02010 	mov	r2, #16
57e056c8:	eb007e75 	bl	57e250a4 <simple_strtoul>

	if (idx < 0 || idx >= CONFIG_SYS_MAX_NAND_DEVICE || !nand_info[idx].name) {
57e056cc:	e2501000 	subs	r1, r0, #0
57e056d0:	1a000003 	bne	57e056e4 <do_nandboot+0x128>
57e056d4:	e59f31ac 	ldr	r3, [pc, #428]	; 57e05888 <do_nandboot+0x2cc>
57e056d8:	e5933020 	ldr	r3, [r3, #32]
57e056dc:	e3530000 	cmp	r3, #0
57e056e0:	1a000004 	bne	57e056f8 <do_nandboot+0x13c>
		printf("\n** Device %d not available\n", idx);
57e056e4:	e59f01a0 	ldr	r0, [pc, #416]	; 57e0588c <do_nandboot+0x2d0>
57e056e8:	eb000f57 	bl	57e0944c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e056ec:	e3e00036 	mvn	r0, #54	; 0x36
57e056f0:	eb00249b 	bl	57e0e964 <__show_boot_progress>
57e056f4:	ea000050 	b	57e0583c <do_nandboot+0x280>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e056f8:	e3a00037 	mov	r0, #55	; 0x37
57e056fc:	eb002498 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_NAND_AVAILABLE);
		return 1;
	}
	bootstage_mark(BOOTSTAGE_ID_NAND_AVAILABLE);

	return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
57e05700:	e5969000 	ldr	r9, [r6]
	image_header_t *hdr;
#if defined(CONFIG_FIT)
	const void *fit_hdr = NULL;
#endif

	s = strchr(cmd, '.');
57e05704:	e3a0102e 	mov	r1, #46	; 0x2e
57e05708:	e1a00009 	mov	r0, r9
57e0570c:	eb007a42 	bl	57e2401c <strchr>
	if (s != NULL &&
57e05710:	e2506000 	subs	r6, r0, #0
57e05714:	0a000012 	beq	57e05764 <do_nandboot+0x1a8>
	    (strcmp(s, ".jffs2") && strcmp(s, ".e") && strcmp(s, ".i"))) {
57e05718:	e59f1170 	ldr	r1, [pc, #368]	; 57e05890 <do_nandboot+0x2d4>
57e0571c:	eb007a20 	bl	57e23fa4 <strcmp>
#if defined(CONFIG_FIT)
	const void *fit_hdr = NULL;
#endif

	s = strchr(cmd, '.');
	if (s != NULL &&
57e05720:	e3500000 	cmp	r0, #0
57e05724:	0a00000e 	beq	57e05764 <do_nandboot+0x1a8>
	    (strcmp(s, ".jffs2") && strcmp(s, ".e") && strcmp(s, ".i"))) {
57e05728:	e1a00006 	mov	r0, r6
57e0572c:	e59f1160 	ldr	r1, [pc, #352]	; 57e05894 <do_nandboot+0x2d8>
57e05730:	eb007a1b 	bl	57e23fa4 <strcmp>
57e05734:	e3500000 	cmp	r0, #0
57e05738:	0a000009 	beq	57e05764 <do_nandboot+0x1a8>
57e0573c:	e1a00006 	mov	r0, r6
57e05740:	e59f1150 	ldr	r1, [pc, #336]	; 57e05898 <do_nandboot+0x2dc>
57e05744:	eb007a16 	bl	57e23fa4 <strcmp>
57e05748:	e3500000 	cmp	r0, #0
57e0574c:	0a000004 	beq	57e05764 <do_nandboot+0x1a8>
		printf("Unknown nand load suffix '%s'\n", s);
57e05750:	e59f0144 	ldr	r0, [pc, #324]	; 57e0589c <do_nandboot+0x2e0>
57e05754:	e1a01006 	mov	r1, r6
57e05758:	eb000f3b 	bl	57e0944c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e0575c:	e3e00034 	mvn	r0, #52	; 0x34
57e05760:	eaffffe2 	b	57e056f0 <do_nandboot+0x134>
		bootstage_error(BOOTSTAGE_ID_NAND_AVAILABLE);
		return 1;
	}
	bootstage_mark(BOOTSTAGE_ID_NAND_AVAILABLE);

	return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
57e05764:	e59f611c 	ldr	r6, [pc, #284]	; 57e05888 <do_nandboot+0x2cc>
		printf("Unknown nand load suffix '%s'\n", s);
		bootstage_error(BOOTSTAGE_ID_NAND_SUFFIX);
		return 1;
	}

	printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
57e05768:	e1a02005 	mov	r2, r5
57e0576c:	e5961020 	ldr	r1, [r6, #32]
57e05770:	e59f0128 	ldr	r0, [pc, #296]	; 57e058a0 <do_nandboot+0x2e4>
57e05774:	eb000f34 	bl	57e0944c <printf>

	cnt = nand->writesize;
57e05778:	e5963014 	ldr	r3, [r6, #20]
57e0577c:	e28d7018 	add	r7, sp, #24
57e05780:	e5273004 	str	r3, [r7, #-4]!
	r = nand_read_skip_bad(nand, offset, &cnt, (u_char *) addr);
57e05784:	e1a00006 	mov	r0, r6
57e05788:	e1a02005 	mov	r2, r5
57e0578c:	e3a03000 	mov	r3, #0
57e05790:	e58d7000 	str	r7, [sp]
57e05794:	e58d4004 	str	r4, [sp, #4]
57e05798:	eb004ac7 	bl	57e182bc <nand_read_skip_bad>
	if (r) {
57e0579c:	e250b000 	subs	fp, r0, #0
57e057a0:	0a000002 	beq	57e057b0 <do_nandboot+0x1f4>
		puts("** Read error\n");
57e057a4:	e59f00f8 	ldr	r0, [pc, #248]	; 57e058a4 <do_nandboot+0x2e8>
57e057a8:	eb000f1d 	bl	57e09424 <puts>
57e057ac:	eaffffce 	b	57e056ec <do_nandboot+0x130>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e057b0:	e3a00037 	mov	r0, #55	; 0x37
57e057b4:	eb00246a 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_NAND_HDR_READ);
		return 1;
	}
	bootstage_mark(BOOTSTAGE_ID_NAND_HDR_READ);

	switch (genimg_get_format ((void *)addr)) {
57e057b8:	e1a00004 	mov	r0, r4
57e057bc:	eb002304 	bl	57e0e3d4 <genimg_get_format>
57e057c0:	e3500001 	cmp	r0, #1
57e057c4:	e1a0a000 	mov	sl, r0
57e057c8:	1a000017 	bne	57e0582c <do_nandboot+0x270>
57e057cc:	e3a00039 	mov	r0, #57	; 0x39
57e057d0:	eb002463 	bl	57e0e964 <__show_boot_progress>
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		bootstage_mark(BOOTSTAGE_ID_NAND_TYPE);
		image_print_contents (hdr);
57e057d4:	e1a00004 	mov	r0, r4
57e057d8:	eb002267 	bl	57e0e17c <image_print_contents>
	bootstage_mark(BOOTSTAGE_ID_NAND_AVAILABLE);

	return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
}

U_BOOT_CMD(nboot, 4, 1, do_nandboot,
57e057dc:	e594300c 	ldr	r3, [r4, #12]
57e057e0:	e3a00039 	mov	r0, #57	; 0x39
57e057e4:	e1a02c03 	lsl	r2, r3, #24
57e057e8:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e057ec:	e1822c23 	orr	r2, r2, r3, lsr #24
57e057f0:	e1822401 	orr	r2, r2, r1, lsl #8
57e057f4:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e057f8:	e1823423 	orr	r3, r2, r3, lsr #8
	return ((ulong)hdr + image_get_header_size());
}

static inline uint32_t image_get_image_size(const image_header_t *hdr)
{
	return (image_get_size(hdr) + image_get_header_size());
57e057fc:	e2833040 	add	r3, r3, #64	; 0x40
		hdr = (image_header_t *)addr;

		bootstage_mark(BOOTSTAGE_ID_NAND_TYPE);
		image_print_contents (hdr);

		cnt = image_get_image_size (hdr);
57e05800:	e58d3014 	str	r3, [sp, #20]
57e05804:	eb002456 	bl	57e0e964 <__show_boot_progress>
		puts ("** Unknown image type\n");
		return 1;
	}
	bootstage_mark(BOOTSTAGE_ID_NAND_TYPE);

	r = nand_read_skip_bad(nand, offset, &cnt, (u_char *) addr);
57e05808:	e1a00006 	mov	r0, r6
57e0580c:	e1a02005 	mov	r2, r5
57e05810:	e1a0300b 	mov	r3, fp
57e05814:	e58d7000 	str	r7, [sp]
57e05818:	e58d4004 	str	r4, [sp, #4]
57e0581c:	eb004aa6 	bl	57e182bc <nand_read_skip_bad>
	if (r) {
57e05820:	e3500000 	cmp	r0, #0
57e05824:	0a00000c 	beq	57e0585c <do_nandboot+0x2a0>
57e05828:	ea000005 	b	57e05844 <do_nandboot+0x288>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e0582c:	e3e00038 	mvn	r0, #56	; 0x38
57e05830:	eb00244b 	bl	57e0e964 <__show_boot_progress>
		cnt = fit_get_size (fit_hdr);
		break;
#endif
	default:
		bootstage_error(BOOTSTAGE_ID_NAND_TYPE);
		puts ("** Unknown image type\n");
57e05834:	e59f006c 	ldr	r0, [pc, #108]	; 57e058a8 <do_nandboot+0x2ec>
57e05838:	eb000ef9 	bl	57e09424 <puts>
		return 1;
57e0583c:	e3a00001 	mov	r0, #1
57e05840:	ea00000c 	b	57e05878 <do_nandboot+0x2bc>
	}
	bootstage_mark(BOOTSTAGE_ID_NAND_TYPE);

	r = nand_read_skip_bad(nand, offset, &cnt, (u_char *) addr);
	if (r) {
		puts("** Read error\n");
57e05844:	e59f0058 	ldr	r0, [pc, #88]	; 57e058a4 <do_nandboot+0x2e8>
57e05848:	eb000ef5 	bl	57e09424 <puts>
57e0584c:	e3e00039 	mvn	r0, #57	; 0x39
57e05850:	eb002443 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_NAND_READ);
		return 1;
57e05854:	e1a0000a 	mov	r0, sl
57e05858:	ea000006 	b	57e05878 <do_nandboot+0x2bc>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e0585c:	e3a0003a 	mov	r0, #58	; 0x3a
57e05860:	eb00243f 	bl	57e0e964 <__show_boot_progress>
	}
#endif

	/* Loading ok, update default load address */

	load_addr = addr;
57e05864:	e59f3040 	ldr	r3, [pc, #64]	; 57e058ac <do_nandboot+0x2f0>

	return bootm_maybe_autostart(cmdtp, cmd);
57e05868:	e59d000c 	ldr	r0, [sp, #12]
	}
#endif

	/* Loading ok, update default load address */

	load_addr = addr;
57e0586c:	e5834000 	str	r4, [r3]

	return bootm_maybe_autostart(cmdtp, cmd);
57e05870:	e1a01009 	mov	r1, r9
57e05874:	ebfff35b 	bl	57e025e8 <bootm_maybe_autostart>
		return 1;
	}
	bootstage_mark(BOOTSTAGE_ID_NAND_AVAILABLE);

	return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
}
57e05878:	e28dd018 	add	sp, sp, #24
57e0587c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e05880:	57e306f4 	.word	0x57e306f4
57e05884:	57e306ff 	.word	0x57e306ff
57e05888:	57e47798 	.word	0x57e47798
57e0588c:	57e30716 	.word	0x57e30716
57e05890:	57e30733 	.word	0x57e30733
57e05894:	57e3073a 	.word	0x57e3073a
57e05898:	57e3073d 	.word	0x57e3073d
57e0589c:	57e30740 	.word	0x57e30740
57e058a0:	57e3075f 	.word	0x57e3075f
57e058a4:	57e3077f 	.word	0x57e3077f
57e058a8:	57e2eec8 	.word	0x57e2eec8
57e058ac:	57e36e60 	.word	0x57e36e60

57e058b0 <nand_print_and_set_info>:
#endif

static void nand_print_and_set_info(int idx)
{
	nand_info_t *nand = &nand_info[idx];
	struct nand_chip *chip = nand->priv;
57e058b0:	e59f30dc 	ldr	r3, [pc, #220]	; 57e05994 <nand_print_and_set_info+0xe4>
57e058b4:	e3a020a8 	mov	r2, #168	; 0xa8
}

#endif

static void nand_print_and_set_info(int idx)
{
57e058b8:	e92d4070 	push	{r4, r5, r6, lr}
	nand_info_t *nand = &nand_info[idx];
	struct nand_chip *chip = nand->priv;
57e058bc:	e0233092 	mla	r3, r2, r0, r3
}

#endif

static void nand_print_and_set_info(int idx)
{
57e058c0:	e1a05000 	mov	r5, r0
	nand_info_t *nand = &nand_info[idx];
	struct nand_chip *chip = nand->priv;
57e058c4:	e5934094 	ldr	r4, [r3, #148]	; 0x94
	char buf[32];

	printf("Device %d: ", idx);
57e058c8:	e1a01005 	mov	r1, r5
}

#endif

static void nand_print_and_set_info(int idx)
{
57e058cc:	e24dd020 	sub	sp, sp, #32
	nand_info_t *nand = &nand_info[idx];
	struct nand_chip *chip = nand->priv;
	char buf[32];

	printf("Device %d: ", idx);
57e058d0:	e59f00c0 	ldr	r0, [pc, #192]	; 57e05998 <nand_print_and_set_info+0xe8>
57e058d4:	eb000edc 	bl	57e0944c <printf>
	if (chip->numchips > 1)
57e058d8:	e5941064 	ldr	r1, [r4, #100]	; 0x64
57e058dc:	e3510001 	cmp	r1, #1
57e058e0:	da000001 	ble	57e058ec <nand_print_and_set_info+0x3c>
		printf("%dx ", chip->numchips);
57e058e4:	e59f00b0 	ldr	r0, [pc, #176]	; 57e0599c <nand_print_and_set_info+0xec>
57e058e8:	eb000ed7 	bl	57e0944c <printf>
	printf("%s, sector size %u KiB\n",
57e058ec:	e59f30a0 	ldr	r3, [pc, #160]	; 57e05994 <nand_print_and_set_info+0xe4>
57e058f0:	e3a040a8 	mov	r4, #168	; 0xa8
57e058f4:	e0243495 	mla	r4, r5, r4, r3
57e058f8:	e5942010 	ldr	r2, [r4, #16]
	       nand->name, nand->erasesize >> 10);
57e058fc:	e2846010 	add	r6, r4, #16
	char buf[32];

	printf("Device %d: ", idx);
	if (chip->numchips > 1)
		printf("%dx ", chip->numchips);
	printf("%s, sector size %u KiB\n",
57e05900:	e1a02522 	lsr	r2, r2, #10
57e05904:	e5941020 	ldr	r1, [r4, #32]
57e05908:	e59f0090 	ldr	r0, [pc, #144]	; 57e059a0 <nand_print_and_set_info+0xf0>
57e0590c:	eb000ece 	bl	57e0944c <printf>
	       nand->name, nand->erasesize >> 10);
	printf("  Page size  %8d b\n", nand->writesize);
57e05910:	e5961004 	ldr	r1, [r6, #4]
57e05914:	e59f0088 	ldr	r0, [pc, #136]	; 57e059a4 <nand_print_and_set_info+0xf4>
57e05918:	eb000ecb 	bl	57e0944c <printf>
	printf("  OOB size   %8d b\n", nand->oobsize);
57e0591c:	e5941018 	ldr	r1, [r4, #24]
57e05920:	e59f0080 	ldr	r0, [pc, #128]	; 57e059a8 <nand_print_and_set_info+0xf8>
57e05924:	eb000ec8 	bl	57e0944c <printf>
	printf("  Erase size %8d b\n", nand->erasesize);
57e05928:	e5941010 	ldr	r1, [r4, #16]
57e0592c:	e59f0078 	ldr	r0, [pc, #120]	; 57e059ac <nand_print_and_set_info+0xfc>
57e05930:	eb000ec5 	bl	57e0944c <printf>

	/* Set geometry info */
	sprintf(buf, "%x", nand->writesize);
57e05934:	e5962004 	ldr	r2, [r6, #4]
57e05938:	e1a0000d 	mov	r0, sp
57e0593c:	e59f106c 	ldr	r1, [pc, #108]	; 57e059b0 <nand_print_and_set_info+0x100>
57e05940:	eb007e80 	bl	57e25348 <sprintf>
	setenv("nand_writesize", buf);
57e05944:	e1a0100d 	mov	r1, sp
57e05948:	e59f0064 	ldr	r0, [pc, #100]	; 57e059b4 <nand_print_and_set_info+0x104>
57e0594c:	eb000657 	bl	57e072b0 <setenv>

	sprintf(buf, "%x", nand->oobsize);
57e05950:	e5942018 	ldr	r2, [r4, #24]
57e05954:	e1a0000d 	mov	r0, sp
57e05958:	e59f1050 	ldr	r1, [pc, #80]	; 57e059b0 <nand_print_and_set_info+0x100>
57e0595c:	eb007e79 	bl	57e25348 <sprintf>
	setenv("nand_oobsize", buf);
57e05960:	e1a0100d 	mov	r1, sp
57e05964:	e59f004c 	ldr	r0, [pc, #76]	; 57e059b8 <nand_print_and_set_info+0x108>
57e05968:	eb000650 	bl	57e072b0 <setenv>

	sprintf(buf, "%x", nand->erasesize);
57e0596c:	e1a0000d 	mov	r0, sp
57e05970:	e59f1038 	ldr	r1, [pc, #56]	; 57e059b0 <nand_print_and_set_info+0x100>
57e05974:	e5942010 	ldr	r2, [r4, #16]
57e05978:	eb007e72 	bl	57e25348 <sprintf>
	setenv("nand_erasesize", buf);
57e0597c:	e1a0100d 	mov	r1, sp
57e05980:	e59f0034 	ldr	r0, [pc, #52]	; 57e059bc <nand_print_and_set_info+0x10c>
	printf("  Page size  %8d b\n", nand->writesize);
	printf("  OOB size   %8d b\n", nand->oobsize);
	printf("  Erase size %8d b\n", nand->erasesize);

	/* Set geometry info */
	sprintf(buf, "%x", nand->writesize);
57e05984:	e1a0500d 	mov	r5, sp

	sprintf(buf, "%x", nand->oobsize);
	setenv("nand_oobsize", buf);

	sprintf(buf, "%x", nand->erasesize);
	setenv("nand_erasesize", buf);
57e05988:	eb000648 	bl	57e072b0 <setenv>
}
57e0598c:	e28dd020 	add	sp, sp, #32
57e05990:	e8bd8070 	pop	{r4, r5, r6, pc}
57e05994:	57e47798 	.word	0x57e47798
57e05998:	57e3529d 	.word	0x57e3529d
57e0599c:	57e3078e 	.word	0x57e3078e
57e059a0:	57e30793 	.word	0x57e30793
57e059a4:	57e307ab 	.word	0x57e307ab
57e059a8:	57e307bf 	.word	0x57e307bf
57e059ac:	57e307d3 	.word	0x57e307d3
57e059b0:	57e353f3 	.word	0x57e353f3
57e059b4:	57e307e7 	.word	0x57e307e7
57e059b8:	57e307f6 	.word	0x57e307f6
57e059bc:	57e30803 	.word	0x57e30803

57e059c0 <arg_off>:
	return -1;
#endif
}

static int arg_off(const char *arg, int *idx, loff_t *off, loff_t *maxsize)
{
57e059c0:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
57e059c4:	e1a06002 	mov	r6, r2
57e059c8:	e1a04001 	mov	r4, r1

static inline int str2off(const char *p, loff_t *num)
{
	char *endptr;

	*num = simple_strtoull(p, &endptr, 16);
57e059cc:	e3a02010 	mov	r2, #16
57e059d0:	e28d1004 	add	r1, sp, #4
	return -1;
#endif
}

static int arg_off(const char *arg, int *idx, loff_t *off, loff_t *maxsize)
{
57e059d4:	e1a05000 	mov	r5, r0
57e059d8:	e1a07003 	mov	r7, r3

static inline int str2off(const char *p, loff_t *num)
{
	char *endptr;

	*num = simple_strtoull(p, &endptr, 16);
57e059dc:	eb007e20 	bl	57e25264 <simple_strtoull>
57e059e0:	e8860003 	stm	r6, {r0, r1}
	return *p != '\0' && *endptr == '\0';
57e059e4:	e5d53000 	ldrb	r3, [r5]
57e059e8:	e3530000 	cmp	r3, #0
57e059ec:	0a000015 	beq	57e05a48 <arg_off+0x88>
57e059f0:	e59d3004 	ldr	r3, [sp, #4]
57e059f4:	e5d33000 	ldrb	r3, [r3]
57e059f8:	e3530000 	cmp	r3, #0
57e059fc:	1a000011 	bne	57e05a48 <arg_off+0x88>
static int arg_off(const char *arg, int *idx, loff_t *off, loff_t *maxsize)
{
	if (!str2off(arg, off))
		return get_part(arg, idx, off, maxsize);

	if (*off >= nand_info[*idx].size) {
57e05a00:	e5943000 	ldr	r3, [r4]
57e05a04:	e59f204c 	ldr	r2, [pc, #76]	; 57e05a58 <arg_off+0x98>
57e05a08:	e3a0c0a8 	mov	ip, #168	; 0xa8
57e05a0c:	e023239c 	mla	r3, ip, r3, r2
57e05a10:	e2834008 	add	r4, r3, #8
57e05a14:	e8940018 	ldm	r4, {r3, r4}
57e05a18:	e1540001 	cmp	r4, r1
57e05a1c:	8a000004 	bhi	57e05a34 <arg_off+0x74>
57e05a20:	1a000001 	bne	57e05a2c <arg_off+0x6c>
57e05a24:	e1530000 	cmp	r3, r0
57e05a28:	8a000001 	bhi	57e05a34 <arg_off+0x74>
		puts("Offset exceeds device limit\n");
57e05a2c:	e59f0028 	ldr	r0, [pc, #40]	; 57e05a5c <arg_off+0x9c>
57e05a30:	ea000005 	b	57e05a4c <arg_off+0x8c>
		return -1;
	}

	*maxsize = nand_info[*idx].size - *off;
57e05a34:	e0530000 	subs	r0, r3, r0
57e05a38:	e0c41001 	sbc	r1, r4, r1
57e05a3c:	e8870003 	stm	r7, {r0, r1}
	return 0;
57e05a40:	e3a00000 	mov	r0, #0
}
57e05a44:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	if (ret)
		return ret;

	return 0;
#else
	puts("offset is not a number\n");
57e05a48:	e59f0010 	ldr	r0, [pc, #16]	; 57e05a60 <arg_off+0xa0>
57e05a4c:	eb000e74 	bl	57e09424 <puts>
}

static int arg_off(const char *arg, int *idx, loff_t *off, loff_t *maxsize)
{
	if (!str2off(arg, off))
		return get_part(arg, idx, off, maxsize);
57e05a50:	e3e00000 	mvn	r0, #0
57e05a54:	eafffffa 	b	57e05a44 <arg_off+0x84>
57e05a58:	57e47798 	.word	0x57e47798
57e05a5c:	57e30812 	.word	0x57e30812
57e05a60:	57e3082f 	.word	0x57e3082f

57e05a64 <arg_off_size>:
	return 0;
}

static int arg_off_size(int argc, char *const argv[], int *idx,
			loff_t *off, loff_t *size)
{
57e05a64:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e05a68:	e1a05002 	mov	r5, r2
57e05a6c:	e24dd018 	sub	sp, sp, #24
57e05a70:	e1a06003 	mov	r6, r3
	int ret;
	loff_t maxsize = 0;
57e05a74:	e3a02000 	mov	r2, #0
57e05a78:	e3a03000 	mov	r3, #0

	if (argc == 0) {
57e05a7c:	e250a000 	subs	sl, r0, #0
	return 0;
}

static int arg_off_size(int argc, char *const argv[], int *idx,
			loff_t *off, loff_t *size)
{
57e05a80:	e1a07001 	mov	r7, r1
57e05a84:	e59d4030 	ldr	r4, [sp, #48]	; 0x30
	int ret;
	loff_t maxsize = 0;
57e05a88:	e58d2008 	str	r2, [sp, #8]
57e05a8c:	e58d300c 	str	r3, [sp, #12]

	if (argc == 0) {
57e05a90:	1a000007 	bne	57e05ab4 <arg_off_size+0x50>
		*off = 0;
57e05a94:	e886000c 	stm	r6, {r2, r3}
		*size = nand_info[*idx].size;
57e05a98:	e59f2120 	ldr	r2, [pc, #288]	; 57e05bc0 <arg_off_size+0x15c>
57e05a9c:	e5953000 	ldr	r3, [r5]
57e05aa0:	e3a010a8 	mov	r1, #168	; 0xa8
57e05aa4:	e0232391 	mla	r3, r1, r3, r2
57e05aa8:	e2833008 	add	r3, r3, #8
57e05aac:	e893000c 	ldm	r3, {r2, r3}
57e05ab0:	ea00000a 	b	57e05ae0 <arg_off_size+0x7c>
		goto print;
	}

	ret = arg_off(argv[0], idx, off, &maxsize);
57e05ab4:	e5910000 	ldr	r0, [r1]
57e05ab8:	e1a02006 	mov	r2, r6
57e05abc:	e1a01005 	mov	r1, r5
57e05ac0:	e28d3008 	add	r3, sp, #8
57e05ac4:	ebffffbd 	bl	57e059c0 <arg_off>
	if (ret)
57e05ac8:	e3500000 	cmp	r0, #0
57e05acc:	1a000034 	bne	57e05ba4 <arg_off_size+0x140>
		return ret;

	if (argc == 1) {
57e05ad0:	e35a0001 	cmp	sl, #1
57e05ad4:	1a000003 	bne	57e05ae8 <arg_off_size+0x84>
		*size = maxsize;
57e05ad8:	e28d3008 	add	r3, sp, #8
57e05adc:	e893000c 	ldm	r3, {r2, r3}
57e05ae0:	e884000c 	stm	r4, {r2, r3}
		goto print;
57e05ae4:	ea000016 	b	57e05b44 <arg_off_size+0xe0>
	}

	if (!str2off(argv[1], size)) {
57e05ae8:	e597a004 	ldr	sl, [r7, #4]

static inline int str2off(const char *p, loff_t *num)
{
	char *endptr;

	*num = simple_strtoull(p, &endptr, 16);
57e05aec:	e28d1014 	add	r1, sp, #20
57e05af0:	e1a0000a 	mov	r0, sl
57e05af4:	e3a02010 	mov	r2, #16
57e05af8:	eb007dd9 	bl	57e25264 <simple_strtoull>
57e05afc:	e8840003 	stm	r4, {r0, r1}
	return *p != '\0' && *endptr == '\0';
57e05b00:	e5da3000 	ldrb	r3, [sl]
57e05b04:	e3530000 	cmp	r3, #0
57e05b08:	0a000027 	beq	57e05bac <arg_off_size+0x148>
57e05b0c:	e59d3014 	ldr	r3, [sp, #20]
57e05b10:	e5d33000 	ldrb	r3, [r3]
57e05b14:	e3530000 	cmp	r3, #0
57e05b18:	1a000023 	bne	57e05bac <arg_off_size+0x148>
	if (!str2off(argv[1], size)) {
		printf("'%s' is not a number\n", argv[1]);
		return -1;
	}

	if (*size > maxsize) {
57e05b1c:	e59d300c 	ldr	r3, [sp, #12]
57e05b20:	e1530001 	cmp	r3, r1
57e05b24:	ba000003 	blt	57e05b38 <arg_off_size+0xd4>
57e05b28:	1a000005 	bne	57e05b44 <arg_off_size+0xe0>
57e05b2c:	e59d3008 	ldr	r3, [sp, #8]
57e05b30:	e1530000 	cmp	r3, r0
57e05b34:	2a000002 	bcs	57e05b44 <arg_off_size+0xe0>
		puts("Size exceeds partition or device limit\n");
57e05b38:	e59f0084 	ldr	r0, [pc, #132]	; 57e05bc4 <arg_off_size+0x160>
57e05b3c:	eb000e38 	bl	57e09424 <puts>
57e05b40:	ea00001c 	b	57e05bb8 <arg_off_size+0x154>
		return -1;
	}

print:
	printf("device %d ", *idx);
57e05b44:	e5951000 	ldr	r1, [r5]
57e05b48:	e59f0078 	ldr	r0, [pc, #120]	; 57e05bc8 <arg_off_size+0x164>
57e05b4c:	eb000e3e 	bl	57e0944c <printf>
	if (*size == nand_info[*idx].size)
57e05b50:	e59f0068 	ldr	r0, [pc, #104]	; 57e05bc0 <arg_off_size+0x15c>
57e05b54:	e5951000 	ldr	r1, [r5]
57e05b58:	e3a0c0a8 	mov	ip, #168	; 0xa8
57e05b5c:	e021019c 	mla	r1, ip, r1, r0
57e05b60:	e5942000 	ldr	r2, [r4]
57e05b64:	e2810008 	add	r0, r1, #8
57e05b68:	e5911008 	ldr	r1, [r1, #8]
57e05b6c:	e5943004 	ldr	r3, [r4, #4]
57e05b70:	e1510002 	cmp	r1, r2
57e05b74:	1a000005 	bne	57e05b90 <arg_off_size+0x12c>
57e05b78:	e5901004 	ldr	r1, [r0, #4]
57e05b7c:	e1510003 	cmp	r1, r3
57e05b80:	1a000002 	bne	57e05b90 <arg_off_size+0x12c>
		puts("whole chip\n");
57e05b84:	e59f0040 	ldr	r0, [pc, #64]	; 57e05bcc <arg_off_size+0x168>
57e05b88:	eb000e25 	bl	57e09424 <puts>
57e05b8c:	ea000003 	b	57e05ba0 <arg_off_size+0x13c>
	else
		printf("offset 0x%llx, size 0x%llx\n",
57e05b90:	e88d000c 	stm	sp, {r2, r3}
57e05b94:	e59f0034 	ldr	r0, [pc, #52]	; 57e05bd0 <arg_off_size+0x16c>
57e05b98:	e896000c 	ldm	r6, {r2, r3}
57e05b9c:	eb000e2a 	bl	57e0944c <printf>
		       (unsigned long long)*off, (unsigned long long)*size);
	return 0;
57e05ba0:	e3a00000 	mov	r0, #0
}
57e05ba4:	e28dd018 	add	sp, sp, #24
57e05ba8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		*size = maxsize;
		goto print;
	}

	if (!str2off(argv[1], size)) {
		printf("'%s' is not a number\n", argv[1]);
57e05bac:	e59f0020 	ldr	r0, [pc, #32]	; 57e05bd4 <arg_off_size+0x170>
57e05bb0:	e5971004 	ldr	r1, [r7, #4]
57e05bb4:	eb000e24 	bl	57e0944c <printf>
		return -1;
57e05bb8:	e3e00000 	mvn	r0, #0
57e05bbc:	eafffff8 	b	57e05ba4 <arg_off_size+0x140>
57e05bc0:	57e47798 	.word	0x57e47798
57e05bc4:	57e30847 	.word	0x57e30847
57e05bc8:	57e3086f 	.word	0x57e3086f
57e05bcc:	57e3087a 	.word	0x57e3087a
57e05bd0:	57e30886 	.word	0x57e30886
57e05bd4:	57e308a2 	.word	0x57e308a2

57e05bd8 <do_nand>:

	return ret;
}

static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e05bd8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
#ifdef CONFIG_SYS_NAND_QUIET
	int quiet = CONFIG_SYS_NAND_QUIET;
#else
	int quiet = 0;
#endif
	const char *quiet_str = getenv("quiet");
57e05bdc:	e59f0b08 	ldr	r0, [pc, #2824]	; 57e066ec <do_nand+0xb14>

	return ret;
}

static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e05be0:	e24dd0b0 	sub	sp, sp, #176	; 0xb0
57e05be4:	e1a05002 	mov	r5, r2
57e05be8:	e1a06001 	mov	r6, r1
57e05bec:	e1a04003 	mov	r4, r3
#ifdef CONFIG_SYS_NAND_QUIET
	int quiet = CONFIG_SYS_NAND_QUIET;
#else
	int quiet = 0;
#endif
	const char *quiet_str = getenv("quiet");
57e05bf0:	eb0006bc 	bl	57e076e8 <getenv>
	int dev = nand_curr_device;
57e05bf4:	e59f2af4 	ldr	r2, [pc, #2804]	; 57e066f0 <do_nand+0xb18>
	int repeat = flag & CMD_FLAG_REPEAT;

	/* at least two arguments please */
	if (argc < 2)
57e05bf8:	e3550001 	cmp	r5, #1
	int quiet = CONFIG_SYS_NAND_QUIET;
#else
	int quiet = 0;
#endif
	const char *quiet_str = getenv("quiet");
	int dev = nand_curr_device;
57e05bfc:	e5922000 	ldr	r2, [r2]
57e05c00:	e58d20ac 	str	r2, [sp, #172]	; 0xac
	int repeat = flag & CMD_FLAG_REPEAT;

	/* at least two arguments please */
	if (argc < 2)
57e05c04:	da0002af 	ble	57e066c8 <do_nand+0xaf0>
		goto usage;

	if (quiet_str)
57e05c08:	e3500000 	cmp	r0, #0
	char *cmd, *s;
	nand_info_t *nand;
#ifdef CONFIG_SYS_NAND_QUIET
	int quiet = CONFIG_SYS_NAND_QUIET;
#else
	int quiet = 0;
57e05c0c:	058d0040 	streq	r0, [sp, #64]	; 0x40

	/* at least two arguments please */
	if (argc < 2)
		goto usage;

	if (quiet_str)
57e05c10:	0a000005 	beq	57e05c2c <do_nand+0x54>
		quiet = simple_strtoul(quiet_str, NULL, 0) != 0;
57e05c14:	e3a01000 	mov	r1, #0
57e05c18:	e1a02001 	mov	r2, r1
57e05c1c:	eb007d20 	bl	57e250a4 <simple_strtoul>
57e05c20:	e2500000 	subs	r0, r0, #0
57e05c24:	13a00001 	movne	r0, #1
57e05c28:	e58d0040 	str	r0, [sp, #64]	; 0x40

	cmd = argv[1];

	/* Only "dump" is repeatable. */
	if (repeat && strcmp(cmd, "dump"))
57e05c2c:	e2166001 	ands	r6, r6, #1
		goto usage;

	if (quiet_str)
		quiet = simple_strtoul(quiet_str, NULL, 0) != 0;

	cmd = argv[1];
57e05c30:	e2849004 	add	r9, r4, #4
57e05c34:	e594a004 	ldr	sl, [r4, #4]

	/* Only "dump" is repeatable. */
	if (repeat && strcmp(cmd, "dump"))
57e05c38:	0a000004 	beq	57e05c50 <do_nand+0x78>
57e05c3c:	e1a0000a 	mov	r0, sl
57e05c40:	e59f1aac 	ldr	r1, [pc, #2732]	; 57e066f4 <do_nand+0xb1c>
57e05c44:	eb0078d6 	bl	57e23fa4 <strcmp>
57e05c48:	e3500000 	cmp	r0, #0
57e05c4c:	1a000299 	bne	57e066b8 <do_nand+0xae0>
		return 0;

	if (strcmp(cmd, "info") == 0) {
57e05c50:	e1a0000a 	mov	r0, sl
57e05c54:	e59f1a9c 	ldr	r1, [pc, #2716]	; 57e066f8 <do_nand+0xb20>
57e05c58:	eb0078d1 	bl	57e23fa4 <strcmp>
57e05c5c:	e2507000 	subs	r7, r0, #0
57e05c60:	1a000008 	bne	57e05c88 <do_nand+0xb0>

		putc('\n');
57e05c64:	e280000a 	add	r0, r0, #10
57e05c68:	eb000de3 	bl	57e093fc <putc>
		for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++) {
			if (nand_info[i].name)
57e05c6c:	e59f3a88 	ldr	r3, [pc, #2696]	; 57e066fc <do_nand+0xb24>
57e05c70:	e5934020 	ldr	r4, [r3, #32]
57e05c74:	e3540000 	cmp	r4, #0
57e05c78:	0a000293 	beq	57e066cc <do_nand+0xaf4>
				nand_print_and_set_info(i);
57e05c7c:	e1a00007 	mov	r0, r7
57e05c80:	ebffff0a 	bl	57e058b0 <nand_print_and_set_info>
57e05c84:	ea00028d 	b	57e066c0 <do_nand+0xae8>
		}
		return 0;
	}

	if (strcmp(cmd, "device") == 0) {
57e05c88:	e1a0000a 	mov	r0, sl
57e05c8c:	e59f1a6c 	ldr	r1, [pc, #2668]	; 57e06700 <do_nand+0xb28>
57e05c90:	eb0078c3 	bl	57e23fa4 <strcmp>
57e05c94:	e2507000 	subs	r7, r0, #0
57e05c98:	1a000026 	bne	57e05d38 <do_nand+0x160>
		if (argc < 3) {
57e05c9c:	e3550002 	cmp	r5, #2
57e05ca0:	1a00000a 	bne	57e05cd0 <do_nand+0xf8>
			putc('\n');
57e05ca4:	e280000a 	add	r0, r0, #10
57e05ca8:	eb000dd3 	bl	57e093fc <putc>
			if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE)
57e05cac:	e59d40ac 	ldr	r4, [sp, #172]	; 0xac
57e05cb0:	e3540000 	cmp	r4, #0
57e05cb4:	0a000002 	beq	57e05cc4 <do_nand+0xec>
				puts("no devices available\n");
57e05cb8:	e59f0a44 	ldr	r0, [pc, #2628]	; 57e06704 <do_nand+0xb2c>
57e05cbc:	eb000dd8 	bl	57e09424 <puts>
57e05cc0:	ea00027e 	b	57e066c0 <do_nand+0xae8>
			else
				nand_print_and_set_info(dev);
57e05cc4:	e1a00004 	mov	r0, r4
57e05cc8:	ebfffef8 	bl	57e058b0 <nand_print_and_set_info>
57e05ccc:	ea00027e 	b	57e066cc <do_nand+0xaf4>
			return 0;
		}

		dev = (int)simple_strtoul(argv[2], NULL, 10);
57e05cd0:	e5940008 	ldr	r0, [r4, #8]
57e05cd4:	e1a01007 	mov	r1, r7
57e05cd8:	e3a0200a 	mov	r2, #10
57e05cdc:	eb007cf0 	bl	57e250a4 <simple_strtoul>

/* ------------------------------------------------------------------------- */

static int set_dev(int dev)
{
	if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE ||
57e05ce0:	e3500000 	cmp	r0, #0
			else
				nand_print_and_set_info(dev);
			return 0;
		}

		dev = (int)simple_strtoul(argv[2], NULL, 10);
57e05ce4:	e1a04000 	mov	r4, r0
57e05ce8:	e58d00ac 	str	r0, [sp, #172]	; 0xac

/* ------------------------------------------------------------------------- */

static int set_dev(int dev)
{
	if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE ||
57e05cec:	1a000003 	bne	57e05d00 <do_nand+0x128>
	    !nand_info[dev].name) {
57e05cf0:	e59f3a04 	ldr	r3, [pc, #2564]	; 57e066fc <do_nand+0xb24>
57e05cf4:	e5932020 	ldr	r2, [r3, #32]

/* ------------------------------------------------------------------------- */

static int set_dev(int dev)
{
	if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE ||
57e05cf8:	e3520000 	cmp	r2, #0
57e05cfc:	1a000002 	bne	57e05d0c <do_nand+0x134>
	    !nand_info[dev].name) {
		puts("No such device\n");
57e05d00:	e59f0a00 	ldr	r0, [pc, #2560]	; 57e06708 <do_nand+0xb30>
57e05d04:	eb000dc6 	bl	57e09424 <puts>
57e05d08:	ea00026a 	b	57e066b8 <do_nand+0xae0>
		return -1;
	}

	if (nand_curr_device == dev)
57e05d0c:	e59f59dc 	ldr	r5, [pc, #2524]	; 57e066f0 <do_nand+0xb18>
57e05d10:	e5957000 	ldr	r7, [r5]
57e05d14:	e3570000 	cmp	r7, #0
57e05d18:	0a000268 	beq	57e066c0 <do_nand+0xae8>
		return 0;

	printf("Device %d: %s", dev, nand_info[dev].name);
57e05d1c:	e1a01004 	mov	r1, r4
57e05d20:	e59f09e4 	ldr	r0, [pc, #2532]	; 57e0670c <do_nand+0xb34>
57e05d24:	eb000dc8 	bl	57e0944c <printf>
	puts("... is now current device\n");
57e05d28:	e59f09e0 	ldr	r0, [pc, #2528]	; 57e06710 <do_nand+0xb38>
57e05d2c:	eb000dbc 	bl	57e09424 <puts>
	nand_curr_device = dev;
57e05d30:	e5854000 	str	r4, [r5]
57e05d34:	ea000264 	b	57e066cc <do_nand+0xaf4>
	 * overridden by a partition specifier.  Note that if somehow the
	 * current device is invalid, it will have to be changed to a valid
	 * one before these commands can run, even if a partition specifier
	 * for another device is to be used.
	 */
	if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE ||
57e05d38:	e59d30ac 	ldr	r3, [sp, #172]	; 0xac
57e05d3c:	e3530000 	cmp	r3, #0
57e05d40:	1a000003 	bne	57e05d54 <do_nand+0x17c>
	    !nand_info[dev].name) {
57e05d44:	e59f79b0 	ldr	r7, [pc, #2480]	; 57e066fc <do_nand+0xb24>
	 * overridden by a partition specifier.  Note that if somehow the
	 * current device is invalid, it will have to be changed to a valid
	 * one before these commands can run, even if a partition specifier
	 * for another device is to be used.
	 */
	if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE ||
57e05d48:	e5973020 	ldr	r3, [r7, #32]
57e05d4c:	e3530000 	cmp	r3, #0
57e05d50:	1a000002 	bne	57e05d60 <do_nand+0x188>
	    !nand_info[dev].name) {
		puts("\nno devices available\n");
57e05d54:	e59f09b8 	ldr	r0, [pc, #2488]	; 57e06714 <do_nand+0xb3c>
57e05d58:	eb000db1 	bl	57e09424 <puts>
57e05d5c:	ea000260 	b	57e066e4 <do_nand+0xb0c>
		return 1;
	}
	nand = &nand_info[dev];

	if (strcmp(cmd, "bad") == 0) {
57e05d60:	e1a0000a 	mov	r0, sl
57e05d64:	e59f19ac 	ldr	r1, [pc, #2476]	; 57e06718 <do_nand+0xb40>
57e05d68:	eb00788d 	bl	57e23fa4 <strcmp>
57e05d6c:	e3500000 	cmp	r0, #0
57e05d70:	1a000022 	bne	57e05e00 <do_nand+0x228>
		printf("\nDevice %d bad blocks:\n", dev);
57e05d74:	e59f09a0 	ldr	r0, [pc, #2464]	; 57e0671c <do_nand+0xb44>
57e05d78:	e59d10ac 	ldr	r1, [sp, #172]	; 0xac
57e05d7c:	eb000db2 	bl	57e0944c <printf>
		for (off = 0; off < nand->size; off += nand->erasesize)
57e05d80:	e3a04000 	mov	r4, #0
57e05d84:	e3a03000 	mov	r3, #0
57e05d88:	e58d3098 	str	r3, [sp, #152]	; 0x98
57e05d8c:	e58d409c 	str	r4, [sp, #156]	; 0x9c
57e05d90:	e1a04007 	mov	r4, r7
57e05d94:	ea00000f 	b	57e05dd8 <do_nand+0x200>
	return info->write(info, ofs, *len, (size_t *)len, buf);
}

static inline int nand_block_isbad(nand_info_t *info, loff_t ofs)
{
	return info->block_isbad(info, ofs);
57e05d98:	e5941078 	ldr	r1, [r4, #120]	; 0x78
57e05d9c:	e59f0958 	ldr	r0, [pc, #2392]	; 57e066fc <do_nand+0xb24>
57e05da0:	e12fff31 	blx	r1
			if (nand_block_isbad(nand, off))
57e05da4:	e3500000 	cmp	r0, #0
57e05da8:	0a000003 	beq	57e05dbc <do_nand+0x1e4>
				printf("  %08llx\n", (unsigned long long)off);
57e05dac:	e59f096c 	ldr	r0, [pc, #2412]	; 57e06720 <do_nand+0xb48>
57e05db0:	e28d3098 	add	r3, sp, #152	; 0x98
57e05db4:	e893000c 	ldm	r3, {r2, r3}
57e05db8:	eb000da3 	bl	57e0944c <printf>
	}
	nand = &nand_info[dev];

	if (strcmp(cmd, "bad") == 0) {
		printf("\nDevice %d bad blocks:\n", dev);
		for (off = 0; off < nand->size; off += nand->erasesize)
57e05dbc:	e5941010 	ldr	r1, [r4, #16]
57e05dc0:	e28d3098 	add	r3, sp, #152	; 0x98
57e05dc4:	e893000c 	ldm	r3, {r2, r3}
57e05dc8:	e0922001 	adds	r2, r2, r1
57e05dcc:	e2a33000 	adc	r3, r3, #0
57e05dd0:	e58d2098 	str	r2, [sp, #152]	; 0x98
57e05dd4:	e58d309c 	str	r3, [sp, #156]	; 0x9c
57e05dd8:	e59d309c 	ldr	r3, [sp, #156]	; 0x9c
57e05ddc:	e594100c 	ldr	r1, [r4, #12]
57e05de0:	e59d2098 	ldr	r2, [sp, #152]	; 0x98
57e05de4:	e1510003 	cmp	r1, r3
57e05de8:	8affffea 	bhi	57e05d98 <do_nand+0x1c0>
57e05dec:	1a000231 	bne	57e066b8 <do_nand+0xae0>
57e05df0:	e5941008 	ldr	r1, [r4, #8]
57e05df4:	e1510002 	cmp	r1, r2
57e05df8:	8affffe6 	bhi	57e05d98 <do_nand+0x1c0>
57e05dfc:	ea00022d 	b	57e066b8 <do_nand+0xae0>
	/*
	 * Syntax is:
	 *   0    1     2       3    4
	 *   nand erase [clean] [off size]
	 */
	if (strncmp(cmd, "erase", 5) == 0 || strncmp(cmd, "scrub", 5) == 0) {
57e05e00:	e1a0000a 	mov	r0, sl
57e05e04:	e59f1918 	ldr	r1, [pc, #2328]	; 57e06724 <do_nand+0xb4c>
57e05e08:	e3a02005 	mov	r2, #5
57e05e0c:	eb007870 	bl	57e23fd4 <strncmp>
57e05e10:	e3500000 	cmp	r0, #0
57e05e14:	0a000005 	beq	57e05e30 <do_nand+0x258>
57e05e18:	e1a0000a 	mov	r0, sl
57e05e1c:	e59f1904 	ldr	r1, [pc, #2308]	; 57e06728 <do_nand+0xb50>
57e05e20:	e3a02005 	mov	r2, #5
57e05e24:	eb00786a 	bl	57e23fd4 <strncmp>
57e05e28:	e3500000 	cmp	r0, #0
57e05e2c:	1a00006f 	bne	57e05ff0 <do_nand+0x418>
		nand_erase_options_t opts;
		/* "clean" at index 2 means request to write cleanmarker */
		int clean = argc > 2 && !strcmp("clean", argv[2]);
57e05e30:	e3550002 	cmp	r5, #2
57e05e34:	03a06000 	moveq	r6, #0
		int scrub_yes = argc > 2 && !strcmp("-y", argv[2]);
57e05e38:	01a0b006 	moveq	fp, r6
	 *   nand erase [clean] [off size]
	 */
	if (strncmp(cmd, "erase", 5) == 0 || strncmp(cmd, "scrub", 5) == 0) {
		nand_erase_options_t opts;
		/* "clean" at index 2 means request to write cleanmarker */
		int clean = argc > 2 && !strcmp("clean", argv[2]);
57e05e3c:	0a000009 	beq	57e05e68 <do_nand+0x290>
57e05e40:	e5941008 	ldr	r1, [r4, #8]
57e05e44:	e59f08e0 	ldr	r0, [pc, #2272]	; 57e0672c <do_nand+0xb54>
57e05e48:	eb007855 	bl	57e23fa4 <strcmp>
		int scrub_yes = argc > 2 && !strcmp("-y", argv[2]);
57e05e4c:	e5941008 	ldr	r1, [r4, #8]
	 *   nand erase [clean] [off size]
	 */
	if (strncmp(cmd, "erase", 5) == 0 || strncmp(cmd, "scrub", 5) == 0) {
		nand_erase_options_t opts;
		/* "clean" at index 2 means request to write cleanmarker */
		int clean = argc > 2 && !strcmp("clean", argv[2]);
57e05e50:	e2706001 	rsbs	r6, r0, #1
57e05e54:	33a06000 	movcc	r6, #0
		int scrub_yes = argc > 2 && !strcmp("-y", argv[2]);
57e05e58:	e59f08d0 	ldr	r0, [pc, #2256]	; 57e06730 <do_nand+0xb58>
57e05e5c:	eb007850 	bl	57e23fa4 <strcmp>
57e05e60:	e270b001 	rsbs	fp, r0, #1
57e05e64:	33a0b000 	movcc	fp, #0
		int o = (clean || scrub_yes) ? 3 : 2;
57e05e68:	e196100b 	orrs	r1, r6, fp
		int scrub = !strncmp(cmd, "scrub", 5);
57e05e6c:	e3a02005 	mov	r2, #5
57e05e70:	e1a0000a 	mov	r0, sl
57e05e74:	e59f18ac 	ldr	r1, [pc, #2220]	; 57e06728 <do_nand+0xb50>
	if (strncmp(cmd, "erase", 5) == 0 || strncmp(cmd, "scrub", 5) == 0) {
		nand_erase_options_t opts;
		/* "clean" at index 2 means request to write cleanmarker */
		int clean = argc > 2 && !strcmp("clean", argv[2]);
		int scrub_yes = argc > 2 && !strcmp("-y", argv[2]);
		int o = (clean || scrub_yes) ? 3 : 2;
57e05e78:	13a09003 	movne	r9, #3
57e05e7c:	03a09002 	moveq	r9, #2
		int scrub = !strncmp(cmd, "scrub", 5);
57e05e80:	eb007853 	bl	57e23fd4 <strncmp>
57e05e84:	e58d004c 	str	r0, [sp, #76]	; 0x4c
			"Use this command only for testing purposes if you\n"
			"         "
			"are sure of what you are doing!\n"
			"\nReally scrub this NAND flash? <y/N>\n";

		if (cmd[5] != 0) {
57e05e88:	e5da2005 	ldrb	r2, [sl, #5]
57e05e8c:	e28a7005 	add	r7, sl, #5
57e05e90:	e3520000 	cmp	r2, #0
		int clean = argc > 2 && !strcmp("clean", argv[2]);
		int scrub_yes = argc > 2 && !strcmp("-y", argv[2]);
		int o = (clean || scrub_yes) ? 3 : 2;
		int scrub = !strncmp(cmd, "scrub", 5);
		int spread = 0;
		int args = 2;
57e05e94:	03a03002 	moveq	r3, #2
		/* "clean" at index 2 means request to write cleanmarker */
		int clean = argc > 2 && !strcmp("clean", argv[2]);
		int scrub_yes = argc > 2 && !strcmp("-y", argv[2]);
		int o = (clean || scrub_yes) ? 3 : 2;
		int scrub = !strncmp(cmd, "scrub", 5);
		int spread = 0;
57e05e98:	01a07002 	moveq	r7, r2
			"Use this command only for testing purposes if you\n"
			"         "
			"are sure of what you are doing!\n"
			"\nReally scrub this NAND flash? <y/N>\n";

		if (cmd[5] != 0) {
57e05e9c:	0a000013 	beq	57e05ef0 <do_nand+0x318>
			if (!strcmp(&cmd[5], ".spread")) {
57e05ea0:	e1a00007 	mov	r0, r7
57e05ea4:	e59f1888 	ldr	r1, [pc, #2184]	; 57e06734 <do_nand+0xb5c>
57e05ea8:	eb00783d 	bl	57e23fa4 <strcmp>
57e05eac:	e3500000 	cmp	r0, #0
		int clean = argc > 2 && !strcmp("clean", argv[2]);
		int scrub_yes = argc > 2 && !strcmp("-y", argv[2]);
		int o = (clean || scrub_yes) ? 3 : 2;
		int scrub = !strncmp(cmd, "scrub", 5);
		int spread = 0;
		int args = 2;
57e05eb0:	03a03002 	moveq	r3, #2
			"are sure of what you are doing!\n"
			"\nReally scrub this NAND flash? <y/N>\n";

		if (cmd[5] != 0) {
			if (!strcmp(&cmd[5], ".spread")) {
				spread = 1;
57e05eb4:	03a07001 	moveq	r7, #1
			"         "
			"are sure of what you are doing!\n"
			"\nReally scrub this NAND flash? <y/N>\n";

		if (cmd[5] != 0) {
			if (!strcmp(&cmd[5], ".spread")) {
57e05eb8:	0a00000c 	beq	57e05ef0 <do_nand+0x318>
				spread = 1;
			} else if (!strcmp(&cmd[5], ".part")) {
57e05ebc:	e1a00007 	mov	r0, r7
57e05ec0:	e59f1870 	ldr	r1, [pc, #2160]	; 57e06738 <do_nand+0xb60>
57e05ec4:	eb007836 	bl	57e23fa4 <strcmp>
57e05ec8:	e3500000 	cmp	r0, #0
				args = 1;
57e05ecc:	03a03001 	moveq	r3, #1
		/* "clean" at index 2 means request to write cleanmarker */
		int clean = argc > 2 && !strcmp("clean", argv[2]);
		int scrub_yes = argc > 2 && !strcmp("-y", argv[2]);
		int o = (clean || scrub_yes) ? 3 : 2;
		int scrub = !strncmp(cmd, "scrub", 5);
		int spread = 0;
57e05ed0:	01a07000 	moveq	r7, r0
			"\nReally scrub this NAND flash? <y/N>\n";

		if (cmd[5] != 0) {
			if (!strcmp(&cmd[5], ".spread")) {
				spread = 1;
			} else if (!strcmp(&cmd[5], ".part")) {
57e05ed4:	0a000005 	beq	57e05ef0 <do_nand+0x318>
				args = 1;
			} else if (!strcmp(&cmd[5], ".chip")) {
57e05ed8:	e1a00007 	mov	r0, r7
57e05edc:	e59f1858 	ldr	r1, [pc, #2136]	; 57e0673c <do_nand+0xb64>
57e05ee0:	eb00782f 	bl	57e23fa4 <strcmp>
57e05ee4:	e2503000 	subs	r3, r0, #0
		/* "clean" at index 2 means request to write cleanmarker */
		int clean = argc > 2 && !strcmp("clean", argv[2]);
		int scrub_yes = argc > 2 && !strcmp("-y", argv[2]);
		int o = (clean || scrub_yes) ? 3 : 2;
		int scrub = !strncmp(cmd, "scrub", 5);
		int spread = 0;
57e05ee8:	01a07003 	moveq	r7, r3
		if (cmd[5] != 0) {
			if (!strcmp(&cmd[5], ".spread")) {
				spread = 1;
			} else if (!strcmp(&cmd[5], ".part")) {
				args = 1;
			} else if (!strcmp(&cmd[5], ".chip")) {
57e05eec:	1a0001f5 	bne	57e066c8 <do_nand+0xaf0>
		/*
		 * Don't allow missing arguments to cause full chip/partition
		 * erases -- easy to do accidentally, e.g. with a misspelled
		 * variable name.
		 */
		if (argc != o + args)
57e05ef0:	e0833009 	add	r3, r3, r9
57e05ef4:	e1550003 	cmp	r5, r3
57e05ef8:	1a0001f2 	bne	57e066c8 <do_nand+0xaf0>
			goto usage;

		printf("\nNAND %s: ", cmd);
57e05efc:	e1a0100a 	mov	r1, sl
57e05f00:	e59f0838 	ldr	r0, [pc, #2104]	; 57e06740 <do_nand+0xb68>
57e05f04:	eb000d50 	bl	57e0944c <printf>
		/* skip first two or three arguments, look for offset and size */
		if (arg_off_size(argc - o, argv + o, &dev, &off, &size) != 0)
57e05f08:	e28d3090 	add	r3, sp, #144	; 0x90
57e05f0c:	e58d3000 	str	r3, [sp]
57e05f10:	e0841109 	add	r1, r4, r9, lsl #2
57e05f14:	e0690005 	rsb	r0, r9, r5
57e05f18:	e28d20ac 	add	r2, sp, #172	; 0xac
57e05f1c:	e28d3098 	add	r3, sp, #152	; 0x98
57e05f20:	ebfffecf 	bl	57e05a64 <arg_off_size>
57e05f24:	e2501000 	subs	r1, r0, #0
57e05f28:	1a0001ed 	bne	57e066e4 <do_nand+0xb0c>
			return 1;

		nand = &nand_info[dev];

		memset(&opts, 0, sizeof(opts));
57e05f2c:	e3a02020 	mov	r2, #32
57e05f30:	e28d0070 	add	r0, sp, #112	; 0x70
		printf("\nNAND %s: ", cmd);
		/* skip first two or three arguments, look for offset and size */
		if (arg_off_size(argc - o, argv + o, &dev, &off, &size) != 0)
			return 1;

		nand = &nand_info[dev];
57e05f34:	e59d40ac 	ldr	r4, [sp, #172]	; 0xac

		memset(&opts, 0, sizeof(opts));
57e05f38:	eb0078cf 	bl	57e2427c <memset>
		opts.offset = off;
57e05f3c:	e28d3098 	add	r3, sp, #152	; 0x98
57e05f40:	e893000c 	ldm	r3, {r2, r3}
57e05f44:	e58d2078 	str	r2, [sp, #120]	; 0x78
57e05f48:	e58d307c 	str	r3, [sp, #124]	; 0x7c
		opts.length = size;
57e05f4c:	e28d3090 	add	r3, sp, #144	; 0x90
57e05f50:	e893000c 	ldm	r3, {r2, r3}
57e05f54:	e58d2070 	str	r2, [sp, #112]	; 0x70
57e05f58:	e58d3074 	str	r3, [sp, #116]	; 0x74
		opts.jffs2  = clean;
		opts.quiet  = quiet;
		opts.spread = spread;

		if (scrub) {
57e05f5c:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c

		memset(&opts, 0, sizeof(opts));
		opts.offset = off;
		opts.length = size;
		opts.jffs2  = clean;
		opts.quiet  = quiet;
57e05f60:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
		opts.spread = spread;

		if (scrub) {
57e05f64:	e3530000 	cmp	r3, #0
		nand = &nand_info[dev];

		memset(&opts, 0, sizeof(opts));
		opts.offset = off;
		opts.length = size;
		opts.jffs2  = clean;
57e05f68:	e58d6084 	str	r6, [sp, #132]	; 0x84
		opts.quiet  = quiet;
57e05f6c:	e58d2080 	str	r2, [sp, #128]	; 0x80
		opts.spread = spread;
57e05f70:	e58d708c 	str	r7, [sp, #140]	; 0x8c

		if (scrub) {
57e05f74:	1a000010 	bne	57e05fbc <do_nand+0x3e4>
			if (!scrub_yes)
57e05f78:	e35b0000 	cmp	fp, #0
57e05f7c:	1a000009 	bne	57e05fa8 <do_nand+0x3d0>
				puts(scrub_warn);
57e05f80:	e59f07bc 	ldr	r0, [pc, #1980]	; 57e06744 <do_nand+0xb6c>
57e05f84:	eb000d26 	bl	57e09424 <puts>

			if (scrub_yes)
				opts.scrub = 1;
			else if (getc() == 'y') {
57e05f88:	eb000d09 	bl	57e093b4 <getc>
57e05f8c:	e3500079 	cmp	r0, #121	; 0x79
57e05f90:	1a000007 	bne	57e05fb4 <do_nand+0x3dc>
				puts("y");
57e05f94:	e59f07ac 	ldr	r0, [pc, #1964]	; 57e06748 <do_nand+0xb70>
57e05f98:	eb000d21 	bl	57e09424 <puts>
				if (getc() == '\r')
57e05f9c:	eb000d04 	bl	57e093b4 <getc>
57e05fa0:	e350000d 	cmp	r0, #13
57e05fa4:	1a000002 	bne	57e05fb4 <do_nand+0x3dc>
					opts.scrub = 1;
57e05fa8:	e3a03001 	mov	r3, #1
57e05fac:	e58d3088 	str	r3, [sp, #136]	; 0x88
57e05fb0:	ea000001 	b	57e05fbc <do_nand+0x3e4>
				else {
					puts("scrub aborted\n");
					return -1;
				}
			} else {
				puts("scrub aborted\n");
57e05fb4:	e59f0790 	ldr	r0, [pc, #1936]	; 57e0674c <do_nand+0xb74>
57e05fb8:	ea0000fa 	b	57e063a8 <do_nand+0x7d0>
				return -1;
			}
		}
		ret = nand_erase_opts(nand, &opts);
57e05fbc:	e59f3738 	ldr	r3, [pc, #1848]	; 57e066fc <do_nand+0xb24>
57e05fc0:	e3a000a8 	mov	r0, #168	; 0xa8
57e05fc4:	e0203094 	mla	r0, r4, r0, r3
57e05fc8:	e28d1070 	add	r1, sp, #112	; 0x70
57e05fcc:	eb004763 	bl	57e17d60 <nand_erase_opts>
		printf("%s\n", ret ? "ERROR" : "OK");
57e05fd0:	e59f3778 	ldr	r3, [pc, #1912]	; 57e06750 <do_nand+0xb78>
57e05fd4:	e3500000 	cmp	r0, #0
57e05fd8:	e1a04000 	mov	r4, r0
57e05fdc:	e59f1770 	ldr	r1, [pc, #1904]	; 57e06754 <do_nand+0xb7c>
57e05fe0:	e59f0770 	ldr	r0, [pc, #1904]	; 57e06758 <do_nand+0xb80>
57e05fe4:	11a01003 	movne	r1, r3
57e05fe8:	eb000d17 	bl	57e0944c <printf>
57e05fec:	ea000185 	b	57e06608 <do_nand+0xa30>

		return ret == 0 ? 0 : 1;
	}

	if (strncmp(cmd, "dump", 4) == 0) {
57e05ff0:	e59f16fc 	ldr	r1, [pc, #1788]	; 57e066f4 <do_nand+0xb1c>
57e05ff4:	e1a0000a 	mov	r0, sl
57e05ff8:	e3a02004 	mov	r2, #4
57e05ffc:	eb0077f4 	bl	57e23fd4 <strncmp>
57e06000:	e2501000 	subs	r1, r0, #0
57e06004:	1a000095 	bne	57e06260 <do_nand+0x688>
		if (argc < 3)
57e06008:	e3550002 	cmp	r5, #2
57e0600c:	0a0001ad 	beq	57e066c8 <do_nand+0xaf0>
			goto usage;

		off = (int)simple_strtoul(argv[2], NULL, 16);
57e06010:	e3a02010 	mov	r2, #16
57e06014:	e5940008 	ldr	r0, [r4, #8]
57e06018:	eb007c21 	bl	57e250a4 <simple_strtoul>
		ret = nand_dump(nand, off, !strcmp(&cmd[4], ".oob"), repeat);
57e0601c:	e59f1738 	ldr	r1, [pc, #1848]	; 57e0675c <do_nand+0xb84>

	if (strncmp(cmd, "dump", 4) == 0) {
		if (argc < 3)
			goto usage;

		off = (int)simple_strtoul(argv[2], NULL, 16);
57e06020:	e1a03000 	mov	r3, r0
57e06024:	e1a04fc3 	asr	r4, r3, #31
57e06028:	e1a07000 	mov	r7, r0
		ret = nand_dump(nand, off, !strcmp(&cmd[4], ".oob"), repeat);
57e0602c:	e28a0004 	add	r0, sl, #4

	if (strncmp(cmd, "dump", 4) == 0) {
		if (argc < 3)
			goto usage;

		off = (int)simple_strtoul(argv[2], NULL, 16);
57e06030:	e58d3098 	str	r3, [sp, #152]	; 0x98
57e06034:	e58d409c 	str	r4, [sp, #156]	; 0x9c
		ret = nand_dump(nand, off, !strcmp(&cmd[4], ".oob"), repeat);
57e06038:	eb0077d9 	bl	57e23fa4 <strcmp>
{
	int i;
	u_char *datbuf, *oobbuf, *p;
	static loff_t last;

	if (repeat)
57e0603c:	e3560000 	cmp	r6, #0
		off = last + nand->writesize;
57e06040:	159f3718 	ldrne	r3, [pc, #1816]	; 57e06760 <do_nand+0xb88>

	last = off;

	datbuf = memalign(ARCH_DMA_MINALIGN, nand->writesize);
57e06044:	e59f46b0 	ldr	r4, [pc, #1712]	; 57e066fc <do_nand+0xb24>
	int i;
	u_char *datbuf, *oobbuf, *p;
	static loff_t last;

	if (repeat)
		off = last + nand->writesize;
57e06048:	15937000 	ldrne	r7, [r3]
57e0604c:	159f36a8 	ldrne	r3, [pc, #1704]	; 57e066fc <do_nand+0xb24>

	last = off;
57e06050:	e3a02000 	mov	r2, #0
	int i;
	u_char *datbuf, *oobbuf, *p;
	static loff_t last;

	if (repeat)
		off = last + nand->writesize;
57e06054:	15933014 	ldrne	r3, [r3, #20]

	last = off;

	datbuf = memalign(ARCH_DMA_MINALIGN, nand->writesize);
57e06058:	e5941014 	ldr	r1, [r4, #20]
	int i;
	u_char *datbuf, *oobbuf, *p;
	static loff_t last;

	if (repeat)
		off = last + nand->writesize;
57e0605c:	10877003 	addne	r7, r7, r3

	last = off;
57e06060:	e59f36f8 	ldr	r3, [pc, #1784]	; 57e06760 <do_nand+0xb88>
	if (strncmp(cmd, "dump", 4) == 0) {
		if (argc < 3)
			goto usage;

		off = (int)simple_strtoul(argv[2], NULL, 16);
		ret = nand_dump(nand, off, !strcmp(&cmd[4], ".oob"), repeat);
57e06064:	e1a0b000 	mov	fp, r0
	static loff_t last;

	if (repeat)
		off = last + nand->writesize;

	last = off;
57e06068:	e5837000 	str	r7, [r3]
57e0606c:	e5832004 	str	r2, [r3, #4]

	datbuf = memalign(ARCH_DMA_MINALIGN, nand->writesize);
57e06070:	e3a00040 	mov	r0, #64	; 0x40
57e06074:	eb001078 	bl	57e0a25c <memalign>
	oobbuf = memalign(ARCH_DMA_MINALIGN, nand->oobsize);
57e06078:	e5941018 	ldr	r1, [r4, #24]
	if (repeat)
		off = last + nand->writesize;

	last = off;

	datbuf = memalign(ARCH_DMA_MINALIGN, nand->writesize);
57e0607c:	e1a06000 	mov	r6, r0
	oobbuf = memalign(ARCH_DMA_MINALIGN, nand->oobsize);
57e06080:	e3a00040 	mov	r0, #64	; 0x40
57e06084:	eb001074 	bl	57e0a25c <memalign>
	if (!datbuf || !oobbuf) {
57e06088:	e3560000 	cmp	r6, #0
57e0608c:	13500000 	cmpne	r0, #0
57e06090:	e1a05000 	mov	r5, r0
57e06094:	13a09000 	movne	r9, #0
57e06098:	03a09001 	moveq	r9, #1
57e0609c:	1a000002 	bne	57e060ac <do_nand+0x4d4>
		puts("No memory for page buffer\n");
57e060a0:	e59f06bc 	ldr	r0, [pc, #1724]	; 57e06764 <do_nand+0xb8c>
57e060a4:	eb000cde 	bl	57e09424 <puts>
57e060a8:	ea00001e 	b	57e06128 <do_nand+0x550>
		return 1;
	}
	off &= ~(nand->writesize - 1);
57e060ac:	e5943014 	ldr	r3, [r4, #20]
	loff_t addr = (loff_t) off;
	struct mtd_oob_ops ops;
	memset(&ops, 0, sizeof(ops));
57e060b0:	e28da050 	add	sl, sp, #80	; 0x50
	oobbuf = memalign(ARCH_DMA_MINALIGN, nand->oobsize);
	if (!datbuf || !oobbuf) {
		puts("No memory for page buffer\n");
		return 1;
	}
	off &= ~(nand->writesize - 1);
57e060b4:	e2633000 	rsb	r3, r3, #0
	loff_t addr = (loff_t) off;
	struct mtd_oob_ops ops;
	memset(&ops, 0, sizeof(ops));
57e060b8:	e1a01009 	mov	r1, r9
57e060bc:	e3a02020 	mov	r2, #32
57e060c0:	e1a0000a 	mov	r0, sl
	oobbuf = memalign(ARCH_DMA_MINALIGN, nand->oobsize);
	if (!datbuf || !oobbuf) {
		puts("No memory for page buffer\n");
		return 1;
	}
	off &= ~(nand->writesize - 1);
57e060c4:	e0077003 	and	r7, r7, r3
	loff_t addr = (loff_t) off;
	struct mtd_oob_ops ops;
	memset(&ops, 0, sizeof(ops));
57e060c8:	eb00786b 	bl	57e2427c <memset>
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
	ops.len = nand->writesize;
57e060cc:	e5943014 	ldr	r3, [r4, #20]
	}
	off &= ~(nand->writesize - 1);
	loff_t addr = (loff_t) off;
	struct mtd_oob_ops ops;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
57e060d0:	e58d6068 	str	r6, [sp, #104]	; 0x68
	ops.oobbuf = oobbuf;
	ops.len = nand->writesize;
57e060d4:	e58d3054 	str	r3, [sp, #84]	; 0x54
	ops.ooblen = nand->oobsize;
57e060d8:	e5943018 	ldr	r3, [r4, #24]
	ops.mode = MTD_OOB_RAW;
	i = nand->read_oob(nand, addr, &ops);
57e060dc:	e58da000 	str	sl, [sp]
	struct mtd_oob_ops ops;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
	ops.len = nand->writesize;
	ops.ooblen = nand->oobsize;
57e060e0:	e58d305c 	str	r3, [sp, #92]	; 0x5c
	ops.mode = MTD_OOB_RAW;
57e060e4:	e3a03002 	mov	r3, #2
57e060e8:	e58d3050 	str	r3, [sp, #80]	; 0x50
	i = nand->read_oob(nand, addr, &ops);
57e060ec:	e594104c 	ldr	r1, [r4, #76]	; 0x4c
	off &= ~(nand->writesize - 1);
	loff_t addr = (loff_t) off;
	struct mtd_oob_ops ops;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
57e060f0:	e58d506c 	str	r5, [sp, #108]	; 0x6c
	ops.len = nand->writesize;
	ops.ooblen = nand->oobsize;
	ops.mode = MTD_OOB_RAW;
	i = nand->read_oob(nand, addr, &ops);
57e060f4:	e1a00004 	mov	r0, r4
57e060f8:	e1a02007 	mov	r2, r7
57e060fc:	e1a03009 	mov	r3, r9
57e06100:	e12fff31 	blx	r1
	if (i < 0) {
57e06104:	e2501000 	subs	r1, r0, #0
57e06108:	aa000008 	bge	57e06130 <do_nand+0x558>
		printf("Error (%d) reading page %08lx\n", i, off);
57e0610c:	e1a02007 	mov	r2, r7
57e06110:	e59f0650 	ldr	r0, [pc, #1616]	; 57e06768 <do_nand+0xb90>
57e06114:	eb000ccc 	bl	57e0944c <printf>
		free(datbuf);
57e06118:	e1a00006 	mov	r0, r6
57e0611c:	eb000e1e 	bl	57e0999c <free>
		free(oobbuf);
57e06120:	e1a00005 	mov	r0, r5
57e06124:	eb000e1c 	bl	57e0999c <free>
		return 1;
57e06128:	e3a07001 	mov	r7, #1
57e0612c:	ea000049 	b	57e06258 <do_nand+0x680>
	}
	printf("Page %08lx dump:\n", off);
57e06130:	e1a01007 	mov	r1, r7
57e06134:	e59f0630 	ldr	r0, [pc, #1584]	; 57e0676c <do_nand+0xb94>
57e06138:	eb000cc3 	bl	57e0944c <printf>
	i = nand->writesize >> 4;
57e0613c:	e5947014 	ldr	r7, [r4, #20]
57e06140:	e1a04006 	mov	r4, r6
57e06144:	e1a07227 	lsr	r7, r7, #4
57e06148:	ea000022 	b	57e061d8 <do_nand+0x600>
	p = datbuf;

	while (i--) {
		if (!only_oob)
57e0614c:	e35b0000 	cmp	fp, #0
57e06150:	0a00001e 	beq	57e061d0 <do_nand+0x5f8>
			printf("\t%02x %02x %02x %02x %02x %02x %02x %02x"
57e06154:	e5d40003 	ldrb	r0, [r4, #3]
57e06158:	e5d41000 	ldrb	r1, [r4]
57e0615c:	e5d42001 	ldrb	r2, [r4, #1]
57e06160:	e5d43002 	ldrb	r3, [r4, #2]
57e06164:	e58d0000 	str	r0, [sp]
57e06168:	e5d40004 	ldrb	r0, [r4, #4]
57e0616c:	e58d0004 	str	r0, [sp, #4]
57e06170:	e5d40005 	ldrb	r0, [r4, #5]
57e06174:	e58d0008 	str	r0, [sp, #8]
57e06178:	e5d40006 	ldrb	r0, [r4, #6]
57e0617c:	e58d000c 	str	r0, [sp, #12]
57e06180:	e5d40007 	ldrb	r0, [r4, #7]
57e06184:	e58d0010 	str	r0, [sp, #16]
57e06188:	e5d40008 	ldrb	r0, [r4, #8]
57e0618c:	e58d0014 	str	r0, [sp, #20]
57e06190:	e5d40009 	ldrb	r0, [r4, #9]
57e06194:	e58d0018 	str	r0, [sp, #24]
57e06198:	e5d4000a 	ldrb	r0, [r4, #10]
57e0619c:	e58d001c 	str	r0, [sp, #28]
57e061a0:	e5d4000b 	ldrb	r0, [r4, #11]
57e061a4:	e58d0020 	str	r0, [sp, #32]
57e061a8:	e5d4000c 	ldrb	r0, [r4, #12]
57e061ac:	e58d0024 	str	r0, [sp, #36]	; 0x24
57e061b0:	e5d4000d 	ldrb	r0, [r4, #13]
57e061b4:	e58d0028 	str	r0, [sp, #40]	; 0x28
57e061b8:	e5d4000e 	ldrb	r0, [r4, #14]
57e061bc:	e58d002c 	str	r0, [sp, #44]	; 0x2c
57e061c0:	e5d4000f 	ldrb	r0, [r4, #15]
57e061c4:	e58d0030 	str	r0, [sp, #48]	; 0x30
57e061c8:	e59f05a0 	ldr	r0, [pc, #1440]	; 57e06770 <do_nand+0xb98>
57e061cc:	eb000c9e 	bl	57e0944c <printf>
			       "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
			       p[15]);
		p += 16;
57e061d0:	e2844010 	add	r4, r4, #16
57e061d4:	e2477001 	sub	r7, r7, #1
	}
	printf("Page %08lx dump:\n", off);
	i = nand->writesize >> 4;
	p = datbuf;

	while (i--) {
57e061d8:	e3570000 	cmp	r7, #0
57e061dc:	1affffda 	bne	57e0614c <do_nand+0x574>
			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
			       p[15]);
		p += 16;
	}
	puts("OOB:\n");
57e061e0:	e59f058c 	ldr	r0, [pc, #1420]	; 57e06774 <do_nand+0xb9c>
57e061e4:	eb000c8e 	bl	57e09424 <puts>
	i = nand->oobsize >> 3;
57e061e8:	e59f350c 	ldr	r3, [pc, #1292]	; 57e066fc <do_nand+0xb24>
57e061ec:	e1a04005 	mov	r4, r5
57e061f0:	e5937018 	ldr	r7, [r3, #24]
57e061f4:	e1a071a7 	lsr	r7, r7, #3
57e061f8:	ea00000f 	b	57e0623c <do_nand+0x664>
	p = oobbuf;
	while (i--) {
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
57e061fc:	e5540005 	ldrb	r0, [r4, #-5]
57e06200:	e5541008 	ldrb	r1, [r4, #-8]
57e06204:	e5542007 	ldrb	r2, [r4, #-7]
57e06208:	e5543006 	ldrb	r3, [r4, #-6]
57e0620c:	e58d0000 	str	r0, [sp]
57e06210:	e5540004 	ldrb	r0, [r4, #-4]
57e06214:	e2477001 	sub	r7, r7, #1
57e06218:	e58d0004 	str	r0, [sp, #4]
57e0621c:	e5540003 	ldrb	r0, [r4, #-3]
57e06220:	e58d0008 	str	r0, [sp, #8]
57e06224:	e5540002 	ldrb	r0, [r4, #-2]
57e06228:	e58d000c 	str	r0, [sp, #12]
57e0622c:	e5540001 	ldrb	r0, [r4, #-1]
57e06230:	e58d0010 	str	r0, [sp, #16]
57e06234:	e59f053c 	ldr	r0, [pc, #1340]	; 57e06778 <do_nand+0xba0>
57e06238:	eb000c83 	bl	57e0944c <printf>
		p += 16;
	}
	puts("OOB:\n");
	i = nand->oobsize >> 3;
	p = oobbuf;
	while (i--) {
57e0623c:	e3570000 	cmp	r7, #0
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
57e06240:	e2844008 	add	r4, r4, #8
		p += 16;
	}
	puts("OOB:\n");
	i = nand->oobsize >> 3;
	p = oobbuf;
	while (i--) {
57e06244:	1affffec 	bne	57e061fc <do_nand+0x624>
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
		       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
		p += 8;
	}
	free(datbuf);
57e06248:	e1a00006 	mov	r0, r6
57e0624c:	eb000dd2 	bl	57e0999c <free>
	free(oobbuf);
57e06250:	e1a00005 	mov	r0, r5
57e06254:	eb000dd0 	bl	57e0999c <free>
			goto usage;

		off = (int)simple_strtoul(argv[2], NULL, 16);
		ret = nand_dump(nand, off, !strcmp(&cmd[4], ".oob"), repeat);

		return ret == 0 ? 1 : 0;
57e06258:	e2274001 	eor	r4, r7, #1
57e0625c:	ea00011a 	b	57e066cc <do_nand+0xaf4>
	}

	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
57e06260:	e1a0000a 	mov	r0, sl
57e06264:	e59f1510 	ldr	r1, [pc, #1296]	; 57e0677c <do_nand+0xba4>
57e06268:	e3a02004 	mov	r2, #4
57e0626c:	eb007758 	bl	57e23fd4 <strncmp>
57e06270:	e3500000 	cmp	r0, #0
57e06274:	0a000005 	beq	57e06290 <do_nand+0x6b8>
57e06278:	e1a0000a 	mov	r0, sl
57e0627c:	e59f14fc 	ldr	r1, [pc, #1276]	; 57e06780 <do_nand+0xba8>
57e06280:	e3a02005 	mov	r2, #5
57e06284:	eb007752 	bl	57e23fd4 <strncmp>
57e06288:	e3500000 	cmp	r0, #0
57e0628c:	1a0000e0 	bne	57e06614 <do_nand+0xa3c>
		size_t rwsize;
		ulong pagecount = 1;
		int read;
		int raw;

		if (argc < 4)
57e06290:	e3550003 	cmp	r5, #3
57e06294:	da00010b 	ble	57e066c8 <do_nand+0xaf0>
			goto usage;

		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
57e06298:	e3a01000 	mov	r1, #0
57e0629c:	e3a02010 	mov	r2, #16
57e062a0:	e5940008 	ldr	r0, [r4, #8]
57e062a4:	eb007b7e 	bl	57e250a4 <simple_strtoul>

		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
57e062a8:	e3a02004 	mov	r2, #4
57e062ac:	e59f14c8 	ldr	r1, [pc, #1224]	; 57e0677c <do_nand+0xba4>
		int raw;

		if (argc < 4)
			goto usage;

		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
57e062b0:	e1a07000 	mov	r7, r0

		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
57e062b4:	e1a0000a 	mov	r0, sl
57e062b8:	eb007745 	bl	57e23fd4 <strncmp>
		printf("\nNAND %s: ", read ? "read" : "write");
57e062bc:	e59f34b8 	ldr	r3, [pc, #1208]	; 57e0677c <do_nand+0xba4>
		if (argc < 4)
			goto usage;

		addr = (ulong)simple_strtoul(argv[2], NULL, 16);

		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
57e062c0:	e270b001 	rsbs	fp, r0, #1
57e062c4:	33a0b000 	movcc	fp, #0
		printf("\nNAND %s: ", read ? "read" : "write");
57e062c8:	e35b0000 	cmp	fp, #0
57e062cc:	e59f14ac 	ldr	r1, [pc, #1196]	; 57e06780 <do_nand+0xba8>
57e062d0:	e59f0468 	ldr	r0, [pc, #1128]	; 57e06740 <do_nand+0xb68>
57e062d4:	11a01003 	movne	r1, r3
57e062d8:	eb000c5b 	bl	57e0944c <printf>

		nand = &nand_info[dev];
57e062dc:	e59d60ac 	ldr	r6, [sp, #172]	; 0xac
57e062e0:	e59f3414 	ldr	r3, [pc, #1044]	; 57e066fc <do_nand+0xb24>

		s = strchr(cmd, '.');
57e062e4:	e1a0000a 	mov	r0, sl
		addr = (ulong)simple_strtoul(argv[2], NULL, 16);

		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
		printf("\nNAND %s: ", read ? "read" : "write");

		nand = &nand_info[dev];
57e062e8:	e3a090a8 	mov	r9, #168	; 0xa8

		s = strchr(cmd, '.');
57e062ec:	e3a0102e 	mov	r1, #46	; 0x2e
		addr = (ulong)simple_strtoul(argv[2], NULL, 16);

		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
		printf("\nNAND %s: ", read ? "read" : "write");

		nand = &nand_info[dev];
57e062f0:	e0293996 	mla	r9, r6, r9, r3

		s = strchr(cmd, '.');
57e062f4:	eb007748 	bl	57e2401c <strchr>

		if (s && !strcmp(s, ".raw")) {
57e062f8:	e250a000 	subs	sl, r0, #0
57e062fc:	0a000033 	beq	57e063d0 <do_nand+0x7f8>
57e06300:	e59f147c 	ldr	r1, [pc, #1148]	; 57e06784 <do_nand+0xbac>
57e06304:	eb007726 	bl	57e23fa4 <strcmp>
57e06308:	e3500000 	cmp	r0, #0
57e0630c:	1a00002f 	bne	57e063d0 <do_nand+0x7f8>
			raw = 1;

			if (arg_off(argv[3], &dev, &off, &size))
57e06310:	e594000c 	ldr	r0, [r4, #12]
57e06314:	e28d10ac 	add	r1, sp, #172	; 0xac
57e06318:	e28d2098 	add	r2, sp, #152	; 0x98
57e0631c:	e28d3090 	add	r3, sp, #144	; 0x90
57e06320:	ebfffda6 	bl	57e059c0 <arg_off>
57e06324:	e3500000 	cmp	r0, #0
57e06328:	1a0000ed 	bne	57e066e4 <do_nand+0xb0c>
				return 1;

			if (argc > 4 && !str2long(argv[4], &pagecount)) {
57e0632c:	e3550004 	cmp	r5, #4
		return ret == 0 ? 1 : 0;
	}

	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
		size_t rwsize;
		ulong pagecount = 1;
57e06330:	03a05001 	moveq	r5, #1
			raw = 1;

			if (arg_off(argv[3], &dev, &off, &size))
				return 1;

			if (argc > 4 && !str2long(argv[4], &pagecount)) {
57e06334:	0a00000e 	beq	57e06374 <do_nand+0x79c>
57e06338:	e5943010 	ldr	r3, [r4, #16]

static inline int str2long(const char *p, ulong *num)
{
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
57e0633c:	e28d10a4 	add	r1, sp, #164	; 0xa4
57e06340:	e1a00003 	mov	r0, r3
57e06344:	e3a02010 	mov	r2, #16
57e06348:	e58d303c 	str	r3, [sp, #60]	; 0x3c
57e0634c:	eb007b54 	bl	57e250a4 <simple_strtoul>
	return *p != '\0' && *endptr == '\0';
57e06350:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c

static inline int str2long(const char *p, ulong *num)
{
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
57e06354:	e1a05000 	mov	r5, r0
	return *p != '\0' && *endptr == '\0';
57e06358:	e5d33000 	ldrb	r3, [r3]
57e0635c:	e3530000 	cmp	r3, #0
57e06360:	0a0000dc 	beq	57e066d8 <do_nand+0xb00>
57e06364:	e59d30a4 	ldr	r3, [sp, #164]	; 0xa4
57e06368:	e5d33000 	ldrb	r3, [r3]
57e0636c:	e3530000 	cmp	r3, #0
57e06370:	1a0000d8 	bne	57e066d8 <do_nand+0xb00>
			if (argc > 4 && !str2long(argv[4], &pagecount)) {
				printf("'%s' is not a number\n", argv[4]);
				return 1;
			}

			if (pagecount * nand->writesize > size) {
57e06374:	e59f3380 	ldr	r3, [pc, #896]	; 57e066fc <do_nand+0xb24>
57e06378:	e3a020a8 	mov	r2, #168	; 0xa8
57e0637c:	e0233692 	mla	r3, r2, r6, r3
57e06380:	e59d1094 	ldr	r1, [sp, #148]	; 0x94
57e06384:	e5933014 	ldr	r3, [r3, #20]
57e06388:	e3510000 	cmp	r1, #0
57e0638c:	e0020593 	mul	r2, r3, r5
57e06390:	ba000003 	blt	57e063a4 <do_nand+0x7cc>
57e06394:	1a000005 	bne	57e063b0 <do_nand+0x7d8>
57e06398:	e59d1090 	ldr	r1, [sp, #144]	; 0x90
57e0639c:	e1510002 	cmp	r1, r2
57e063a0:	2a000002 	bcs	57e063b0 <do_nand+0x7d8>
				puts("Size exceeds partition or device limit\n");
57e063a4:	e59f03dc 	ldr	r0, [pc, #988]	; 57e06788 <do_nand+0xbb0>
57e063a8:	eb000c1d 	bl	57e09424 <puts>
57e063ac:	ea0000c5 	b	57e066c8 <do_nand+0xaf0>
				return -1;
			}

			rwsize = pagecount * (nand->writesize + nand->oobsize);
57e063b0:	e59f2344 	ldr	r2, [pc, #836]	; 57e066fc <do_nand+0xb24>
57e063b4:	e3a010a8 	mov	r1, #168	; 0xa8
57e063b8:	e0222691 	mla	r2, r1, r6, r2
57e063bc:	e5922018 	ldr	r2, [r2, #24]
57e063c0:	e0833002 	add	r3, r3, r2
57e063c4:	e0030395 	mul	r3, r5, r3
57e063c8:	e58d30a8 	str	r3, [sp, #168]	; 0xa8
57e063cc:	ea00000d 	b	57e06408 <do_nand+0x830>
		} else {
			if (arg_off_size(argc - 3, argv + 3, &dev,
57e063d0:	e28d3090 	add	r3, sp, #144	; 0x90
57e063d4:	e58d3000 	str	r3, [sp]
57e063d8:	e2450003 	sub	r0, r5, #3
57e063dc:	e284100c 	add	r1, r4, #12
57e063e0:	e28d20ac 	add	r2, sp, #172	; 0xac
57e063e4:	e28d3098 	add	r3, sp, #152	; 0x98
57e063e8:	ebfffd9d 	bl	57e05a64 <arg_off_size>
57e063ec:	e3500000 	cmp	r0, #0
57e063f0:	1a0000bb 	bne	57e066e4 <do_nand+0xb0c>
						&off, &size) != 0)
				return 1;

			rwsize = size;
57e063f4:	e59d3090 	ldr	r3, [sp, #144]	; 0x90
		}

		if (!s || !strcmp(s, ".jffs2") ||
57e063f8:	e35a0000 	cmp	sl, #0
		} else {
			if (arg_off_size(argc - 3, argv + 3, &dev,
						&off, &size) != 0)
				return 1;

			rwsize = size;
57e063fc:	e58d30a8 	str	r3, [sp, #168]	; 0xa8
		}

		if (!s || !strcmp(s, ".jffs2") ||
57e06400:	0a00000f 	beq	57e06444 <do_nand+0x86c>
		return ret == 0 ? 1 : 0;
	}

	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
		size_t rwsize;
		ulong pagecount = 1;
57e06404:	e3a05001 	mov	r5, #1
				return 1;

			rwsize = size;
		}

		if (!s || !strcmp(s, ".jffs2") ||
57e06408:	e1a0000a 	mov	r0, sl
57e0640c:	e59f1378 	ldr	r1, [pc, #888]	; 57e0678c <do_nand+0xbb4>
57e06410:	eb0076e3 	bl	57e23fa4 <strcmp>
57e06414:	e3500000 	cmp	r0, #0
57e06418:	0a000009 	beq	57e06444 <do_nand+0x86c>
		    !strcmp(s, ".e") || !strcmp(s, ".i")) {
57e0641c:	e1a0000a 	mov	r0, sl
57e06420:	e59f1368 	ldr	r1, [pc, #872]	; 57e06790 <do_nand+0xbb8>
57e06424:	eb0076de 	bl	57e23fa4 <strcmp>
				return 1;

			rwsize = size;
		}

		if (!s || !strcmp(s, ".jffs2") ||
57e06428:	e3500000 	cmp	r0, #0
57e0642c:	0a000004 	beq	57e06444 <do_nand+0x86c>
		    !strcmp(s, ".e") || !strcmp(s, ".i")) {
57e06430:	e1a0000a 	mov	r0, sl
57e06434:	e59f1358 	ldr	r1, [pc, #856]	; 57e06794 <do_nand+0xbbc>
57e06438:	eb0076d9 	bl	57e23fa4 <strcmp>
57e0643c:	e3500000 	cmp	r0, #0
57e06440:	1a00000c 	bne	57e06478 <do_nand+0x8a0>
			if (read)
57e06444:	e35b0000 	cmp	fp, #0
57e06448:	e28d3098 	add	r3, sp, #152	; 0x98
57e0644c:	e893000c 	ldm	r3, {r2, r3}
57e06450:	e28d10a8 	add	r1, sp, #168	; 0xa8
57e06454:	0a000003 	beq	57e06468 <do_nand+0x890>
				ret = nand_read_skip_bad(nand, off, &rwsize,
57e06458:	e1a00009 	mov	r0, r9
57e0645c:	e88d0082 	stm	sp, {r1, r7}
57e06460:	eb004795 	bl	57e182bc <nand_read_skip_bad>
57e06464:	ea00001c 	b	57e064dc <do_nand+0x904>
							 (u_char *)addr);
			else
				ret = nand_write_skip_bad(nand, off, &rwsize,
57e06468:	e1a00009 	mov	r0, r9
57e0646c:	e88d0882 	stm	sp, {r1, r7, fp}
57e06470:	eb004708 	bl	57e18098 <nand_write_skip_bad>
57e06474:	ea000018 	b	57e064dc <do_nand+0x904>
			}
			ret = nand_write_skip_bad(nand, off, &rwsize,
						(u_char *)addr,
						WITH_INLINE_OOB);
#endif
		} else if (!strcmp(s, ".oob")) {
57e06478:	e59f12dc 	ldr	r1, [pc, #732]	; 57e0675c <do_nand+0xb84>
57e0647c:	e1a0000a 	mov	r0, sl
57e06480:	eb0076c7 	bl	57e23fa4 <strcmp>
57e06484:	e2501000 	subs	r1, r0, #0
57e06488:	1a00001a 	bne	57e064f8 <do_nand+0x920>
			/* out-of-band data */
			mtd_oob_ops_t ops = {
57e0648c:	e28d4050 	add	r4, sp, #80	; 0x50
57e06490:	e59d50a8 	ldr	r5, [sp, #168]	; 0xa8
57e06494:	e3a02020 	mov	r2, #32
57e06498:	e1a00004 	mov	r0, r4
57e0649c:	eb007776 	bl	57e2427c <memset>
57e064a0:	e3a03002 	mov	r3, #2
				.oobbuf = (u8 *)addr,
				.ooblen = rwsize,
				.mode = MTD_OOB_RAW
			};

			if (read)
57e064a4:	e35b0000 	cmp	fp, #0
						(u_char *)addr,
						WITH_INLINE_OOB);
#endif
		} else if (!strcmp(s, ".oob")) {
			/* out-of-band data */
			mtd_oob_ops_t ops = {
57e064a8:	e58d3050 	str	r3, [sp, #80]	; 0x50
57e064ac:	e58d505c 	str	r5, [sp, #92]	; 0x5c
57e064b0:	e58d706c 	str	r7, [sp, #108]	; 0x6c
57e064b4:	e59f1240 	ldr	r1, [pc, #576]	; 57e066fc <do_nand+0xb24>
57e064b8:	e28d3098 	add	r3, sp, #152	; 0x98
57e064bc:	e893000c 	ldm	r3, {r2, r3}
				.oobbuf = (u8 *)addr,
				.ooblen = rwsize,
				.mode = MTD_OOB_RAW
			};

			if (read)
57e064c0:	0a000007 	beq	57e064e4 <do_nand+0x90c>
				ret = nand->read_oob(nand, off, &ops);
57e064c4:	e3a000a8 	mov	r0, #168	; 0xa8
57e064c8:	e0261690 	mla	r6, r0, r6, r1
57e064cc:	e58d4000 	str	r4, [sp]
57e064d0:	e596104c 	ldr	r1, [r6, #76]	; 0x4c
57e064d4:	e1a00009 	mov	r0, r9
57e064d8:	e12fff31 	blx	r1
57e064dc:	e1a04000 	mov	r4, r0
57e064e0:	ea00003d 	b	57e065dc <do_nand+0xa04>
			else
				ret = nand->write_oob(nand, off, &ops);
57e064e4:	e3a000a8 	mov	r0, #168	; 0xa8
57e064e8:	e0261690 	mla	r6, r0, r6, r1
57e064ec:	e58d4000 	str	r4, [sp]
57e064f0:	e5961050 	ldr	r1, [r6, #80]	; 0x50
57e064f4:	eafffff6 	b	57e064d4 <do_nand+0x8fc>
		/* Raw access */
		mtd_oob_ops_t ops = {
			.datbuf = (u8 *)addr,
			.oobbuf = ((u8 *)addr) + nand->writesize,
			.len = nand->writesize,
			.ooblen = nand->oobsize,
57e064f8:	e59f31fc 	ldr	r3, [pc, #508]	; 57e066fc <do_nand+0xb24>
			if (read)
				ret = nand->read_oob(nand, off, &ops);
			else
				ret = nand->write_oob(nand, off, &ops);
		} else if (raw) {
			ret = raw_access(nand, addr, off, pagecount, read);
57e064fc:	e28d2098 	add	r2, sp, #152	; 0x98
57e06500:	e8920006 	ldm	r2, {r1, r2}
57e06504:	e58d1040 	str	r1, [sp, #64]	; 0x40
57e06508:	e58d2044 	str	r2, [sp, #68]	; 0x44
		/* Raw access */
		mtd_oob_ops_t ops = {
			.datbuf = (u8 *)addr,
			.oobbuf = ((u8 *)addr) + nand->writesize,
			.len = nand->writesize,
			.ooblen = nand->oobsize,
57e0650c:	e3a020a8 	mov	r2, #168	; 0xa8
57e06510:	e0263692 	mla	r6, r2, r6, r3
{
	int ret = 0;

	while (count--) {
		/* Raw access */
		mtd_oob_ops_t ops = {
57e06514:	e28da050 	add	sl, sp, #80	; 0x50
57e06518:	ea00002c 	b	57e065d0 <do_nand+0x9f8>
			.datbuf = (u8 *)addr,
			.oobbuf = ((u8 *)addr) + nand->writesize,
			.len = nand->writesize,
			.ooblen = nand->oobsize,
57e0651c:	e5963018 	ldr	r3, [r6, #24]

	while (count--) {
		/* Raw access */
		mtd_oob_ops_t ops = {
			.datbuf = (u8 *)addr,
			.oobbuf = ((u8 *)addr) + nand->writesize,
57e06520:	e5964014 	ldr	r4, [r6, #20]
{
	int ret = 0;

	while (count--) {
		/* Raw access */
		mtd_oob_ops_t ops = {
57e06524:	e3a01000 	mov	r1, #0
57e06528:	e3a02020 	mov	r2, #32
57e0652c:	e1a0000a 	mov	r0, sl
57e06530:	e58d303c 	str	r3, [sp, #60]	; 0x3c
57e06534:	eb007750 	bl	57e2427c <memset>
			.len = nand->writesize,
			.ooblen = nand->oobsize,
			.mode = MTD_OOB_RAW
		};

		if (read)
57e06538:	e35b0000 	cmp	fp, #0
{
	int ret = 0;

	while (count--) {
		/* Raw access */
		mtd_oob_ops_t ops = {
57e0653c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
			.ooblen = nand->oobsize,
			.mode = MTD_OOB_RAW
		};

		if (read)
			ret = nand->read_oob(nand, off, &ops);
57e06540:	158da000 	strne	sl, [sp]
		else
			ret = nand->write_oob(nand, off, &ops);
57e06544:	058da000 	streq	sl, [sp]
{
	int ret = 0;

	while (count--) {
		/* Raw access */
		mtd_oob_ops_t ops = {
57e06548:	e3a02002 	mov	r2, #2
57e0654c:	e58d4054 	str	r4, [sp, #84]	; 0x54
			.datbuf = (u8 *)addr,
			.oobbuf = ((u8 *)addr) + nand->writesize,
57e06550:	e0874004 	add	r4, r7, r4
{
	int ret = 0;

	while (count--) {
		/* Raw access */
		mtd_oob_ops_t ops = {
57e06554:	e58d2050 	str	r2, [sp, #80]	; 0x50
57e06558:	e58d305c 	str	r3, [sp, #92]	; 0x5c
			.ooblen = nand->oobsize,
			.mode = MTD_OOB_RAW
		};

		if (read)
			ret = nand->read_oob(nand, off, &ops);
57e0655c:	1596104c 	ldrne	r1, [r6, #76]	; 0x4c
		else
			ret = nand->write_oob(nand, off, &ops);
57e06560:	05961050 	ldreq	r1, [r6, #80]	; 0x50
{
	int ret = 0;

	while (count--) {
		/* Raw access */
		mtd_oob_ops_t ops = {
57e06564:	e58d7068 	str	r7, [sp, #104]	; 0x68
57e06568:	e58d406c 	str	r4, [sp, #108]	; 0x6c
		};

		if (read)
			ret = nand->read_oob(nand, off, &ops);
		else
			ret = nand->write_oob(nand, off, &ops);
57e0656c:	e1a00009 	mov	r0, r9
57e06570:	e28d3040 	add	r3, sp, #64	; 0x40
57e06574:	e893000c 	ldm	r3, {r2, r3}
57e06578:	e12fff31 	blx	r1

		if (ret) {
57e0657c:	e3500000 	cmp	r0, #0
		};

		if (read)
			ret = nand->read_oob(nand, off, &ops);
		else
			ret = nand->write_oob(nand, off, &ops);
57e06580:	e2455001 	sub	r5, r5, #1

		if (ret) {
57e06584:	0a000007 	beq	57e065a8 <do_nand+0x9d0>
57e06588:	e1a04000 	mov	r4, r0
			printf("%s: error at offset %llx, ret %d\n",
57e0658c:	e58d0000 	str	r0, [sp]
57e06590:	e59f1200 	ldr	r1, [pc, #512]	; 57e06798 <do_nand+0xbc0>
57e06594:	e28d3040 	add	r3, sp, #64	; 0x40
57e06598:	e893000c 	ldm	r3, {r2, r3}
57e0659c:	e59f01f8 	ldr	r0, [pc, #504]	; 57e0679c <do_nand+0xbc4>
57e065a0:	eb000ba9 	bl	57e0944c <printf>
57e065a4:	ea00000c 	b	57e065dc <do_nand+0xa04>
				__func__, (long long)off, ret);
			break;
		}

		addr += nand->writesize + nand->oobsize;
57e065a8:	e5963014 	ldr	r3, [r6, #20]
57e065ac:	e5962018 	ldr	r2, [r6, #24]
57e065b0:	e0832002 	add	r2, r3, r2
57e065b4:	e0877002 	add	r7, r7, r2
		off += nand->writesize;
57e065b8:	e28d2040 	add	r2, sp, #64	; 0x40
57e065bc:	e8920006 	ldm	r2, {r1, r2}
57e065c0:	e0911003 	adds	r1, r1, r3
57e065c4:	e2a22000 	adc	r2, r2, #0
57e065c8:	e58d1040 	str	r1, [sp, #64]	; 0x40
57e065cc:	e58d2044 	str	r2, [sp, #68]	; 0x44
static int raw_access(nand_info_t *nand, ulong addr, loff_t off, ulong count,
			int read)
{
	int ret = 0;

	while (count--) {
57e065d0:	e3550000 	cmp	r5, #0
57e065d4:	1affffd0 	bne	57e0651c <do_nand+0x944>
57e065d8:	e1a04005 	mov	r4, r5
		} else {
			printf("Unknown nand command suffix '%s'.\n", s);
			return 1;
		}

		printf(" %zu bytes %s: %s\n", rwsize,
57e065dc:	e59f3198 	ldr	r3, [pc, #408]	; 57e0677c <do_nand+0xba4>
57e065e0:	e35b0000 	cmp	fp, #0
57e065e4:	e59fc168 	ldr	ip, [pc, #360]	; 57e06754 <do_nand+0xb7c>
57e065e8:	e59f21b0 	ldr	r2, [pc, #432]	; 57e067a0 <do_nand+0xbc8>
57e065ec:	11a02003 	movne	r2, r3
57e065f0:	e3540000 	cmp	r4, #0
57e065f4:	e59f3154 	ldr	r3, [pc, #340]	; 57e06750 <do_nand+0xb78>
57e065f8:	e59f01a4 	ldr	r0, [pc, #420]	; 57e067a4 <do_nand+0xbcc>
57e065fc:	e59d10a8 	ldr	r1, [sp, #168]	; 0xa8
57e06600:	01a0300c 	moveq	r3, ip
57e06604:	eb000b90 	bl	57e0944c <printf>
		       read ? "read" : "written", ret ? "ERROR" : "OK");

		return ret == 0 ? 0 : 1;
57e06608:	e2544000 	subs	r4, r4, #0
57e0660c:	13a04001 	movne	r4, #1
57e06610:	ea00002d 	b	57e066cc <do_nand+0xaf4>

		return ret == 0 ? 0 : 1;
	}
#endif

	if (strcmp(cmd, "markbad") == 0) {
57e06614:	e1a0000a 	mov	r0, sl
57e06618:	e59f1188 	ldr	r1, [pc, #392]	; 57e067a8 <do_nand+0xbd0>
57e0661c:	eb007660 	bl	57e23fa4 <strcmp>
57e06620:	e2504000 	subs	r4, r0, #0
57e06624:	1a00001c 	bne	57e0669c <do_nand+0xac4>
		argc -= 2;
		argv += 2;

		if (argc <= 0)
57e06628:	e2555002 	subs	r5, r5, #2
57e0662c:	0a000025 	beq	57e066c8 <do_nand+0xaf0>
			goto usage;

		while (argc > 0) {
			addr = simple_strtoul(*argv, NULL, 16);

			if (nand->block_markbad(nand, addr)) {
57e06630:	e59fa0c4 	ldr	sl, [pc, #196]	; 57e066fc <do_nand+0xb24>

	if (strcmp(cmd, "markbad") == 0) {
		argc -= 2;
		argv += 2;

		if (argc <= 0)
57e06634:	e1a06009 	mov	r6, r9
			goto usage;

		while (argc > 0) {
			addr = simple_strtoul(*argv, NULL, 16);
57e06638:	e3a01000 	mov	r1, #0
57e0663c:	e3a02010 	mov	r2, #16
57e06640:	e5b60004 	ldr	r0, [r6, #4]!
57e06644:	eb007a96 	bl	57e250a4 <simple_strtoul>
57e06648:	e1a07000 	mov	r7, r0

			if (nand->block_markbad(nand, addr)) {
57e0664c:	e59a107c 	ldr	r1, [sl, #124]	; 0x7c
57e06650:	e59f00a4 	ldr	r0, [pc, #164]	; 57e066fc <do_nand+0xb24>
57e06654:	e1a02007 	mov	r2, r7
57e06658:	e3a03000 	mov	r3, #0
57e0665c:	e12fff31 	blx	r1
57e06660:	e3500000 	cmp	r0, #0
57e06664:	0a000005 	beq	57e06680 <do_nand+0xaa8>
				printf("block 0x%08lx NOT marked "
57e06668:	e1a02004 	mov	r2, r4
57e0666c:	e59f0138 	ldr	r0, [pc, #312]	; 57e067ac <do_nand+0xbd4>
57e06670:	e1a01007 	mov	r1, r7
57e06674:	eb000b74 	bl	57e0944c <printf>
					"as bad! ERROR %d\n",
					addr, ret);
				ret = 1;
57e06678:	e3a04001 	mov	r4, #1
57e0667c:	ea000002 	b	57e0668c <do_nand+0xab4>
			} else {
				printf("block 0x%08lx successfully "
57e06680:	e59f0128 	ldr	r0, [pc, #296]	; 57e067b0 <do_nand+0xbd8>
57e06684:	e1a01007 	mov	r1, r7
57e06688:	eb000b6f 	bl	57e0944c <printf>
					"marked as bad\n",
					addr);
			}
			--argc;
57e0668c:	e2455001 	sub	r5, r5, #1
		argv += 2;

		if (argc <= 0)
			goto usage;

		while (argc > 0) {
57e06690:	e3550000 	cmp	r5, #0
57e06694:	caffffe7 	bgt	57e06638 <do_nand+0xa60>
57e06698:	ea00000b 	b	57e066cc <do_nand+0xaf4>
			++argv;
		}
		return ret;
	}

	if (strcmp(cmd, "biterr") == 0) {
57e0669c:	e1a0000a 	mov	r0, sl
57e066a0:	e59f110c 	ldr	r1, [pc, #268]	; 57e067b4 <do_nand+0xbdc>
57e066a4:	eb00763e 	bl	57e23fa4 <strcmp>
		return 0;
	}
#endif

usage:
	return CMD_RET_USAGE;
57e066a8:	e3500000 	cmp	r0, #0
57e066ac:	03a04001 	moveq	r4, #1
57e066b0:	13e04000 	mvnne	r4, #0
57e066b4:	ea000004 	b	57e066cc <do_nand+0xaf4>

	cmd = argv[1];

	/* Only "dump" is repeatable. */
	if (repeat && strcmp(cmd, "dump"))
		return 0;
57e066b8:	e3a04000 	mov	r4, #0
57e066bc:	ea000002 	b	57e066cc <do_nand+0xaf4>
		}

		dev = (int)simple_strtoul(argv[2], NULL, 10);
		set_dev(dev);

		return 0;
57e066c0:	e1a04007 	mov	r4, r7
57e066c4:	ea000000 	b	57e066cc <do_nand+0xaf4>
		return 0;
	}
#endif

usage:
	return CMD_RET_USAGE;
57e066c8:	e3e04000 	mvn	r4, #0
}
57e066cc:	e1a00004 	mov	r0, r4
57e066d0:	e28dd0b0 	add	sp, sp, #176	; 0xb0
57e066d4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

			if (arg_off(argv[3], &dev, &off, &size))
				return 1;

			if (argc > 4 && !str2long(argv[4], &pagecount)) {
				printf("'%s' is not a number\n", argv[4]);
57e066d8:	e59f00d8 	ldr	r0, [pc, #216]	; 57e067b8 <do_nand+0xbe0>
57e066dc:	e5941010 	ldr	r1, [r4, #16]
57e066e0:	eb000b59 	bl	57e0944c <printf>
				return 1;
57e066e4:	e3a04001 	mov	r4, #1
57e066e8:	eafffff7 	b	57e066cc <do_nand+0xaf4>
57e066ec:	57e308cf 	.word	0x57e308cf
57e066f0:	57e36f3c 	.word	0x57e36f3c
57e066f4:	57e308d5 	.word	0x57e308d5
57e066f8:	57e2e4ad 	.word	0x57e2e4ad
57e066fc:	57e47798 	.word	0x57e47798
57e06700:	57e31b49 	.word	0x57e31b49
57e06704:	57e30914 	.word	0x57e30914
57e06708:	57e308da 	.word	0x57e308da
57e0670c:	57e308ea 	.word	0x57e308ea
57e06710:	57e308f8 	.word	0x57e308f8
57e06714:	57e30913 	.word	0x57e30913
57e06718:	57e30b95 	.word	0x57e30b95
57e0671c:	57e3092a 	.word	0x57e3092a
57e06720:	57e30942 	.word	0x57e30942
57e06724:	57e2f9cf 	.word	0x57e2f9cf
57e06728:	57e3094c 	.word	0x57e3094c
57e0672c:	57e30952 	.word	0x57e30952
57e06730:	57e30958 	.word	0x57e30958
57e06734:	57e3095b 	.word	0x57e3095b
57e06738:	57e30963 	.word	0x57e30963
57e0673c:	57e30969 	.word	0x57e30969
57e06740:	57e3096f 	.word	0x57e3096f
57e06744:	57e3097a 	.word	0x57e3097a
57e06748:	57e30959 	.word	0x57e30959
57e0674c:	57e30a74 	.word	0x57e30a74
57e06750:	57e308b8 	.word	0x57e308b8
57e06754:	57e308be 	.word	0x57e308be
57e06758:	57e31b63 	.word	0x57e31b63
57e0675c:	57e30a83 	.word	0x57e30a83
57e06760:	57e383e0 	.word	0x57e383e0
57e06764:	57e30a88 	.word	0x57e30a88
57e06768:	57e30aa3 	.word	0x57e30aa3
57e0676c:	57e30ac2 	.word	0x57e30ac2
57e06770:	57e30ad4 	.word	0x57e30ad4
57e06774:	57e30b27 	.word	0x57e30b27
57e06778:	57e30b2d 	.word	0x57e30b2d
57e0677c:	57e3095e 	.word	0x57e3095e
57e06780:	57e308c1 	.word	0x57e308c1
57e06784:	57e30b57 	.word	0x57e30b57
57e06788:	57e30847 	.word	0x57e30847
57e0678c:	57e30733 	.word	0x57e30733
57e06790:	57e3073a 	.word	0x57e3073a
57e06794:	57e3073d 	.word	0x57e3073d
57e06798:	57e2bd94 	.word	0x57e2bd94
57e0679c:	57e30b5c 	.word	0x57e30b5c
57e067a0:	57e308c7 	.word	0x57e308c7
57e067a4:	57e30b7e 	.word	0x57e30b7e
57e067a8:	57e30b91 	.word	0x57e30b91
57e067ac:	57e30b99 	.word	0x57e30b99
57e067b0:	57e30bc4 	.word	0x57e30bc4
57e067b4:	57e30bee 	.word	0x57e30bee
57e067b8:	57e308a2 	.word	0x57e308a2

57e067bc <do_ping>:
}

#if defined(CONFIG_CMD_PING)
static int do_ping(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc < 2)
57e067bc:	e3520001 	cmp	r2, #1
	return rcode;
}

#if defined(CONFIG_CMD_PING)
static int do_ping(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e067c0:	e92d4010 	push	{r4, lr}
	if (argc < 2)
		return -1;
57e067c4:	d3e00000 	mvnle	r0, #0
	return rcode;
}

#if defined(CONFIG_CMD_PING)
static int do_ping(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e067c8:	e1a04003 	mov	r4, r3
	if (argc < 2)
57e067cc:	d8bd8010 	pople	{r4, pc}
		return -1;

	NetPingIP = string_to_ip(argv[1]);
57e067d0:	e5930004 	ldr	r0, [r3, #4]
57e067d4:	eb007543 	bl	57e23ce8 <string_to_ip>
57e067d8:	e59f3048 	ldr	r3, [pc, #72]	; 57e06828 <do_ping+0x6c>
	if (NetPingIP == 0)
57e067dc:	e3500000 	cmp	r0, #0
static int do_ping(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc < 2)
		return -1;

	NetPingIP = string_to_ip(argv[1]);
57e067e0:	e5830000 	str	r0, [r3]
	if (NetPingIP == 0)
57e067e4:	0a00000d 	beq	57e06820 <do_ping+0x64>
		return CMD_RET_USAGE;

	if (NetLoop(PING) < 0) {
57e067e8:	e3a00005 	mov	r0, #5
57e067ec:	eb008c86 	bl	57e29a0c <NetLoop>
57e067f0:	e3500000 	cmp	r0, #0
57e067f4:	aa000004 	bge	57e0680c <do_ping+0x50>
		printf("ping failed; host %s is not alive\n", argv[1]);
57e067f8:	e59f002c 	ldr	r0, [pc, #44]	; 57e0682c <do_ping+0x70>
57e067fc:	e5941004 	ldr	r1, [r4, #4]
57e06800:	eb000b11 	bl	57e0944c <printf>
		return 1;
57e06804:	e3a00001 	mov	r0, #1
57e06808:	e8bd8010 	pop	{r4, pc}
	}

	printf("host %s is alive\n", argv[1]);
57e0680c:	e59f001c 	ldr	r0, [pc, #28]	; 57e06830 <do_ping+0x74>
57e06810:	e5941004 	ldr	r1, [r4, #4]
57e06814:	eb000b0c 	bl	57e0944c <printf>

	return 0;
57e06818:	e3a00000 	mov	r0, #0
57e0681c:	e8bd8010 	pop	{r4, pc}
	if (argc < 2)
		return -1;

	NetPingIP = string_to_ip(argv[1]);
	if (NetPingIP == 0)
		return CMD_RET_USAGE;
57e06820:	e3e00000 	mvn	r0, #0
	}

	printf("host %s is alive\n", argv[1]);

	return 0;
}
57e06824:	e8bd8010 	pop	{r4, pc}
57e06828:	57e7bfa4 	.word	0x57e7bfa4
57e0682c:	57e30c4e 	.word	0x57e30c4e
57e06830:	57e30c71 	.word	0x57e30c71

57e06834 <netboot_common>:
#endif
}

static int netboot_common(enum proto_t proto, cmd_tbl_t *cmdtp, int argc,
		char * const argv[])
{
57e06834:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
57e06838:	e1a06000 	mov	r6, r0
57e0683c:	e24dd024 	sub	sp, sp, #36	; 0x24
	int   rcode = 0;
	int   size;
	ulong addr;

	/* pre-set load_addr */
	if ((s = getenv("loadaddr")) != NULL) {
57e06840:	e59f0250 	ldr	r0, [pc, #592]	; 57e06a98 <netboot_common+0x264>
#endif
}

static int netboot_common(enum proto_t proto, cmd_tbl_t *cmdtp, int argc,
		char * const argv[])
{
57e06844:	e1a05001 	mov	r5, r1
57e06848:	e1a04002 	mov	r4, r2
57e0684c:	e1a07003 	mov	r7, r3
	int   rcode = 0;
	int   size;
	ulong addr;

	/* pre-set load_addr */
	if ((s = getenv("loadaddr")) != NULL) {
57e06850:	eb0003a4 	bl	57e076e8 <getenv>
57e06854:	e3500000 	cmp	r0, #0
57e06858:	0a000004 	beq	57e06870 <netboot_common+0x3c>
		load_addr = simple_strtoul(s, NULL, 16);
57e0685c:	e3a01000 	mov	r1, #0
57e06860:	e3a02010 	mov	r2, #16
57e06864:	eb007a0e 	bl	57e250a4 <simple_strtoul>
57e06868:	e59f322c 	ldr	r3, [pc, #556]	; 57e06a9c <netboot_common+0x268>
57e0686c:	e5830000 	str	r0, [r3]
	}

	switch (argc) {
57e06870:	e3540002 	cmp	r4, #2
57e06874:	0a000004 	beq	57e0688c <netboot_common+0x58>
57e06878:	e3540003 	cmp	r4, #3
57e0687c:	0a000013 	beq	57e068d0 <netboot_common+0x9c>
57e06880:	e3540001 	cmp	r4, #1
57e06884:	1a00001c 	bne	57e068fc <netboot_common+0xc8>
57e06888:	ea00001f 	b	57e0690c <netboot_common+0xd8>
		 * Only one arg - accept two forms:
		 * Just load address, or just boot file name. The latter
		 * form must be written in a format which can not be
		 * mis-interpreted as a valid number.
		 */
		addr = simple_strtoul(argv[1], &end, 16);
57e0688c:	e28d101c 	add	r1, sp, #28
57e06890:	e3a02010 	mov	r2, #16
57e06894:	e5970004 	ldr	r0, [r7, #4]
57e06898:	eb007a01 	bl	57e250a4 <simple_strtoul>
		if (end == (argv[1] + strlen(argv[1])))
57e0689c:	e5974004 	ldr	r4, [r7, #4]
		 * Only one arg - accept two forms:
		 * Just load address, or just boot file name. The latter
		 * form must be written in a format which can not be
		 * mis-interpreted as a valid number.
		 */
		addr = simple_strtoul(argv[1], &end, 16);
57e068a0:	e1a0a000 	mov	sl, r0
		if (end == (argv[1] + strlen(argv[1])))
57e068a4:	e1a00004 	mov	r0, r4
57e068a8:	e59d901c 	ldr	r9, [sp, #28]
57e068ac:	eb0075e7 	bl	57e24050 <strlen>
57e068b0:	e0840000 	add	r0, r4, r0
57e068b4:	e1590000 	cmp	r9, r0
			load_addr = addr;
57e068b8:	059f31dc 	ldreq	r3, [pc, #476]	; 57e06a9c <netboot_common+0x268>
		else
			copy_filename(BootFile, argv[1], sizeof(BootFile));
57e068bc:	159f01dc 	ldrne	r0, [pc, #476]	; 57e06aa0 <netboot_common+0x26c>
		 * form must be written in a format which can not be
		 * mis-interpreted as a valid number.
		 */
		addr = simple_strtoul(argv[1], &end, 16);
		if (end == (argv[1] + strlen(argv[1])))
			load_addr = addr;
57e068c0:	0583a000 	streq	sl, [r3]
		else
			copy_filename(BootFile, argv[1], sizeof(BootFile));
57e068c4:	15971004 	ldrne	r1, [r7, #4]
		 * Just load address, or just boot file name. The latter
		 * form must be written in a format which can not be
		 * mis-interpreted as a valid number.
		 */
		addr = simple_strtoul(argv[1], &end, 16);
		if (end == (argv[1] + strlen(argv[1])))
57e068c8:	1a000008 	bne	57e068f0 <netboot_common+0xbc>
57e068cc:	ea00000e 	b	57e0690c <netboot_common+0xd8>
			load_addr = addr;
		else
			copy_filename(BootFile, argv[1], sizeof(BootFile));
		break;

	case 3:	load_addr = simple_strtoul(argv[1], NULL, 16);
57e068d0:	e3a01000 	mov	r1, #0
57e068d4:	e5970004 	ldr	r0, [r7, #4]
57e068d8:	e3a02010 	mov	r2, #16
57e068dc:	eb0079f0 	bl	57e250a4 <simple_strtoul>
57e068e0:	e59f31b4 	ldr	r3, [pc, #436]	; 57e06a9c <netboot_common+0x268>
		copy_filename(BootFile, argv[2], sizeof(BootFile));
57e068e4:	e5971008 	ldr	r1, [r7, #8]
			load_addr = addr;
		else
			copy_filename(BootFile, argv[1], sizeof(BootFile));
		break;

	case 3:	load_addr = simple_strtoul(argv[1], NULL, 16);
57e068e8:	e5830000 	str	r0, [r3]
		copy_filename(BootFile, argv[2], sizeof(BootFile));
57e068ec:	e59f01ac 	ldr	r0, [pc, #428]	; 57e06aa0 <netboot_common+0x26c>
57e068f0:	e3a02080 	mov	r2, #128	; 0x80
57e068f4:	eb008b93 	bl	57e29748 <copy_filename>

		break;
57e068f8:	ea000003 	b	57e0690c <netboot_common+0xd8>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e068fc:	e3e0004f 	mvn	r0, #79	; 0x4f
57e06900:	eb002017 	bl	57e0e964 <__show_boot_progress>
		copy_filename(BootFile, argv[3], sizeof(BootFile));
		break;
#endif
	default:
		bootstage_error(BOOTSTAGE_ID_NET_START);
		return CMD_RET_USAGE;
57e06904:	e3e04000 	mvn	r4, #0
57e06908:	ea00005f 	b	57e06a8c <netboot_common+0x258>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e0690c:	e3a00050 	mov	r0, #80	; 0x50
57e06910:	eb002013 	bl	57e0e964 <__show_boot_progress>
	}
	bootstage_mark(BOOTSTAGE_ID_NET_START);

	if ((size = NetLoop(proto)) < 0) {
57e06914:	e1a00006 	mov	r0, r6
57e06918:	eb008c3b 	bl	57e29a0c <NetLoop>
57e0691c:	e2504000 	subs	r4, r0, #0
57e06920:	aa000003 	bge	57e06934 <netboot_common+0x100>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e06924:	e3e00050 	mvn	r0, #80	; 0x50
57e06928:	eb00200d 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_NET_NETLOOP_OK);
		return 1;
57e0692c:	e3a04001 	mov	r4, #1
57e06930:	ea000055 	b	57e06a8c <netboot_common+0x258>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e06934:	e3a00051 	mov	r0, #81	; 0x51
57e06938:	eb002009 	bl	57e0e964 <__show_boot_progress>

static void netboot_update_env(void)
{
	char tmp[22];

	if (NetOurGatewayIP) {
57e0693c:	e59f3160 	ldr	r3, [pc, #352]	; 57e06aa4 <netboot_common+0x270>
57e06940:	e5930000 	ldr	r0, [r3]
57e06944:	e3500000 	cmp	r0, #0
57e06948:	0a000005 	beq	57e06964 <netboot_common+0x130>
		ip_to_string(NetOurGatewayIP, tmp);
57e0694c:	e28d6004 	add	r6, sp, #4
57e06950:	e1a01006 	mov	r1, r6
57e06954:	eb008b9e 	bl	57e297d4 <ip_to_string>
		setenv("gatewayip", tmp);
57e06958:	e59f0148 	ldr	r0, [pc, #328]	; 57e06aa8 <netboot_common+0x274>
57e0695c:	e1a01006 	mov	r1, r6
57e06960:	eb000252 	bl	57e072b0 <setenv>
	}

	if (NetOurSubnetMask) {
57e06964:	e59f3140 	ldr	r3, [pc, #320]	; 57e06aac <netboot_common+0x278>
57e06968:	e5930000 	ldr	r0, [r3]
57e0696c:	e3500000 	cmp	r0, #0
57e06970:	0a000005 	beq	57e0698c <netboot_common+0x158>
		ip_to_string(NetOurSubnetMask, tmp);
57e06974:	e28d6004 	add	r6, sp, #4
57e06978:	e1a01006 	mov	r1, r6
57e0697c:	eb008b94 	bl	57e297d4 <ip_to_string>
		setenv("netmask", tmp);
57e06980:	e59f0128 	ldr	r0, [pc, #296]	; 57e06ab0 <netboot_common+0x27c>
57e06984:	e1a01006 	mov	r1, r6
57e06988:	eb000248 	bl	57e072b0 <setenv>
	}

	if (NetOurHostName[0])
57e0698c:	e59f1120 	ldr	r1, [pc, #288]	; 57e06ab4 <netboot_common+0x280>
57e06990:	e5d13000 	ldrb	r3, [r1]
57e06994:	e3530000 	cmp	r3, #0
57e06998:	0a000001 	beq	57e069a4 <netboot_common+0x170>
		setenv("hostname", NetOurHostName);
57e0699c:	e59f0114 	ldr	r0, [pc, #276]	; 57e06ab8 <netboot_common+0x284>
57e069a0:	eb000242 	bl	57e072b0 <setenv>

	if (NetOurRootPath[0])
57e069a4:	e59f1110 	ldr	r1, [pc, #272]	; 57e06abc <netboot_common+0x288>
57e069a8:	e5d13000 	ldrb	r3, [r1]
57e069ac:	e3530000 	cmp	r3, #0
57e069b0:	0a000001 	beq	57e069bc <netboot_common+0x188>
		setenv("rootpath", NetOurRootPath);
57e069b4:	e59f0104 	ldr	r0, [pc, #260]	; 57e06ac0 <netboot_common+0x28c>
57e069b8:	eb00023c 	bl	57e072b0 <setenv>

	if (NetOurIP) {
57e069bc:	e59f3100 	ldr	r3, [pc, #256]	; 57e06ac4 <netboot_common+0x290>
57e069c0:	e5930000 	ldr	r0, [r3]
57e069c4:	e3500000 	cmp	r0, #0
57e069c8:	0a000005 	beq	57e069e4 <netboot_common+0x1b0>
		ip_to_string(NetOurIP, tmp);
57e069cc:	e28d6004 	add	r6, sp, #4
57e069d0:	e1a01006 	mov	r1, r6
57e069d4:	eb008b7e 	bl	57e297d4 <ip_to_string>
		setenv("ipaddr", tmp);
57e069d8:	e59f00e8 	ldr	r0, [pc, #232]	; 57e06ac8 <netboot_common+0x294>
57e069dc:	e1a01006 	mov	r1, r6
57e069e0:	eb000232 	bl	57e072b0 <setenv>
#if !defined(CONFIG_BOOTP_SERVERIP)
	/*
	 * Only attempt to change serverip if net/bootp.c:BootpCopyNetParams()
	 * could have set it
	 */
	if (NetServerIP) {
57e069e4:	e59f30e0 	ldr	r3, [pc, #224]	; 57e06acc <netboot_common+0x298>
57e069e8:	e5930000 	ldr	r0, [r3]
57e069ec:	e3500000 	cmp	r0, #0
57e069f0:	0a000005 	beq	57e06a0c <netboot_common+0x1d8>
		ip_to_string(NetServerIP, tmp);
57e069f4:	e28d6004 	add	r6, sp, #4
57e069f8:	e1a01006 	mov	r1, r6
57e069fc:	eb008b74 	bl	57e297d4 <ip_to_string>
		setenv("serverip", tmp);
57e06a00:	e59f00c8 	ldr	r0, [pc, #200]	; 57e06ad0 <netboot_common+0x29c>
57e06a04:	e1a01006 	mov	r1, r6
57e06a08:	eb000228 	bl	57e072b0 <setenv>
	}
#endif
	if (NetOurDNSIP) {
57e06a0c:	e59f30c0 	ldr	r3, [pc, #192]	; 57e06ad4 <netboot_common+0x2a0>
57e06a10:	e5930000 	ldr	r0, [r3]
57e06a14:	e3500000 	cmp	r0, #0
57e06a18:	0a000005 	beq	57e06a34 <netboot_common+0x200>
		ip_to_string(NetOurDNSIP, tmp);
57e06a1c:	e28d6004 	add	r6, sp, #4
57e06a20:	e1a01006 	mov	r1, r6
57e06a24:	eb008b6a 	bl	57e297d4 <ip_to_string>
		setenv("dnsip", tmp);
57e06a28:	e59f00a8 	ldr	r0, [pc, #168]	; 57e06ad8 <netboot_common+0x2a4>
57e06a2c:	e1a01006 	mov	r1, r6
57e06a30:	eb00021e 	bl	57e072b0 <setenv>
	if (NetOurDNS2IP) {
		ip_to_string(NetOurDNS2IP, tmp);
		setenv("dnsip2", tmp);
	}
#endif
	if (NetOurNISDomain[0])
57e06a34:	e59f10a0 	ldr	r1, [pc, #160]	; 57e06adc <netboot_common+0x2a8>
57e06a38:	e5d13000 	ldrb	r3, [r1]
57e06a3c:	e3530000 	cmp	r3, #0
57e06a40:	0a000001 	beq	57e06a4c <netboot_common+0x218>
		setenv("domain", NetOurNISDomain);
57e06a44:	e59f0094 	ldr	r0, [pc, #148]	; 57e06ae0 <netboot_common+0x2ac>
57e06a48:	eb000218 	bl	57e072b0 <setenv>

	/* NetLoop ok, update environment */
	netboot_update_env();

	/* done if no file was loaded (no errors though) */
	if (size == 0) {
57e06a4c:	e3540000 	cmp	r4, #0
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e06a50:	03e00051 	mvneq	r0, #81	; 0x51
57e06a54:	0a00000b 	beq	57e06a88 <netboot_common+0x254>
		bootstage_error(BOOTSTAGE_ID_NET_LOADED);
		return 0;
	}

	/* flush cache */
	flush_cache(load_addr, size);
57e06a58:	e59f303c 	ldr	r3, [pc, #60]	; 57e06a9c <netboot_common+0x268>
57e06a5c:	e1a01004 	mov	r1, r4
57e06a60:	e5930000 	ldr	r0, [r3]
57e06a64:	ebffea4f 	bl	57e013a8 <__flush_cache>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e06a68:	e3a00052 	mov	r0, #82	; 0x52
57e06a6c:	eb001fbc 	bl	57e0e964 <__show_boot_progress>

	bootstage_mark(BOOTSTAGE_ID_NET_LOADED);

	rcode = bootm_maybe_autostart(cmdtp, argv[0]);
57e06a70:	e1a00005 	mov	r0, r5
57e06a74:	e5971000 	ldr	r1, [r7]
57e06a78:	ebffeeda 	bl	57e025e8 <bootm_maybe_autostart>

	if (rcode < 0)
57e06a7c:	e2504000 	subs	r4, r0, #0
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e06a80:	b3e00052 	mvnlt	r0, #82	; 0x52
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e06a84:	a3a00054 	movge	r0, #84	; 0x54
57e06a88:	eb001fb5 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_NET_DONE_ERR);
	else
		bootstage_mark(BOOTSTAGE_ID_NET_DONE);
	return rcode;
}
57e06a8c:	e1a00004 	mov	r0, r4
57e06a90:	e28dd024 	add	sp, sp, #36	; 0x24
57e06a94:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
57e06a98:	57e2e096 	.word	0x57e2e096
57e06a9c:	57e36e60 	.word	0x57e36e60
57e06aa0:	57e79780 	.word	0x57e79780
57e06aa4:	57e79804 	.word	0x57e79804
57e06aa8:	57e30c83 	.word	0x57e30c83
57e06aac:	57e79808 	.word	0x57e79808
57e06ab0:	57e30c8d 	.word	0x57e30c8d
57e06ab4:	57e7b684 	.word	0x57e7b684
57e06ab8:	57e2f033 	.word	0x57e2f033
57e06abc:	57e7b6a4 	.word	0x57e7b6a4
57e06ac0:	57e30c95 	.word	0x57e30c95
57e06ac4:	57e79764 	.word	0x57e79764
57e06ac8:	57e2e444 	.word	0x57e2e444
57e06acc:	57e7980c 	.word	0x57e7980c
57e06ad0:	57e2f024 	.word	0x57e2f024
57e06ad4:	57e7b6e4 	.word	0x57e7b6e4
57e06ad8:	57e30c9e 	.word	0x57e30c9e
57e06adc:	57e7b664 	.word	0x57e7b664
57e06ae0:	57e30ca4 	.word	0x57e30ca4

57e06ae4 <do_nfs>:
);
#endif

#if defined(CONFIG_CMD_NFS)
static int do_nfs(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e06ae4:	e1a01000 	mov	r1, r0
	return netboot_common(NFS, cmdtp, argc, argv);
57e06ae8:	e3a00007 	mov	r0, #7
57e06aec:	eaffff50 	b	57e06834 <netboot_common>

57e06af0 <do_bootp>:
#include <net.h>

static int netboot_common(enum proto_t, cmd_tbl_t *, int, char * const []);

static int do_bootp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e06af0:	e1a01000 	mov	r1, r0
	return netboot_common(BOOTP, cmdtp, argc, argv);
57e06af4:	e3a00000 	mov	r0, #0
57e06af8:	eaffff4d 	b	57e06834 <netboot_common>

57e06afc <do_tftpb>:
	"boot image via network using BOOTP/TFTP protocol",
	"[loadAddress] [[hostIPaddr:]bootfilename]"
);

int do_tftpb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e06afc:	e1a01000 	mov	r1, r0
	int ret;

	bootstage_mark_name(BOOTSTAGE_KERNELREAD_START, "tftp_start");
	ret = netboot_common(TFTPGET, cmdtp, argc, argv);
57e06b00:	e3a00003 	mov	r0, #3
57e06b04:	eaffff4a 	b	57e06834 <netboot_common>

57e06b08 <do_env_delete>:
	return cmd_usage(cmdtp);
}

static int do_env_delete(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
57e06b08:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e06b0c:	e1a04002 	mov	r4, r2
	int env_flag = H_INTERACTIVE;
57e06b10:	e3a06004 	mov	r6, #4
	int ret = 0;

	debug("Initial value for argc=%d\n", argc);
	while (argc > 1 && **(argv + 1) == '-') {
57e06b14:	ea000006 	b	57e06b34 <do_env_delete+0x2c>
		char *arg = *++argv;

		--argc;
		while (*++arg) {
			switch (*arg) {
57e06b18:	e3510066 	cmp	r1, #102	; 0x66
57e06b1c:	1a00001b 	bne	57e06b90 <do_env_delete+0x88>
			case 'f':		/* force */
				env_flag |= H_FORCE;
57e06b20:	e3866002 	orr	r6, r6, #2
	debug("Initial value for argc=%d\n", argc);
	while (argc > 1 && **(argv + 1) == '-') {
		char *arg = *++argv;

		--argc;
		while (*++arg) {
57e06b24:	e5f21001 	ldrb	r1, [r2, #1]!
57e06b28:	e3510000 	cmp	r1, #0
57e06b2c:	1afffff9 	bne	57e06b18 <do_env_delete+0x10>

	debug("Initial value for argc=%d\n", argc);
	while (argc > 1 && **(argv + 1) == '-') {
		char *arg = *++argv;

		--argc;
57e06b30:	e2444001 	sub	r4, r4, #1
{
	int env_flag = H_INTERACTIVE;
	int ret = 0;

	debug("Initial value for argc=%d\n", argc);
	while (argc > 1 && **(argv + 1) == '-') {
57e06b34:	e3540001 	cmp	r4, #1
		char *arg = *++argv;

		--argc;
57e06b38:	e1a07003 	mov	r7, r3
{
	int env_flag = H_INTERACTIVE;
	int ret = 0;

	debug("Initial value for argc=%d\n", argc);
	while (argc > 1 && **(argv + 1) == '-') {
57e06b3c:	da000003 	ble	57e06b50 <do_env_delete+0x48>
57e06b40:	e5b32004 	ldr	r2, [r3, #4]!
57e06b44:	e5d21000 	ldrb	r1, [r2]
57e06b48:	e351002d 	cmp	r1, #45	; 0x2d
57e06b4c:	0afffff4 	beq	57e06b24 <do_env_delete+0x1c>
			}
		}
	}
	debug("Final value for argc=%d\n", argc);

	env_id++;
57e06b50:	e59f3044 	ldr	r3, [pc, #68]	; 57e06b9c <do_env_delete+0x94>

static int do_env_delete(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	int env_flag = H_INTERACTIVE;
	int ret = 0;
57e06b54:	e3a05000 	mov	r5, #0
			}
		}
	}
	debug("Final value for argc=%d\n", argc);

	env_id++;
57e06b58:	e5932000 	ldr	r2, [r3]
57e06b5c:	e2822001 	add	r2, r2, #1
57e06b60:	e5832000 	str	r2, [r3]

	while (--argc > 0) {
57e06b64:	ea000005 	b	57e06b80 <do_env_delete+0x78>
		char *name = *++argv;

		if (!hdelete_r(name, &env_htab, env_flag))
57e06b68:	e5b70004 	ldr	r0, [r7, #4]!
57e06b6c:	e59f102c 	ldr	r1, [pc, #44]	; 57e06ba0 <do_env_delete+0x98>
57e06b70:	e1a02006 	mov	r2, r6
57e06b74:	eb007104 	bl	57e22f8c <hdelete_r>
			ret = 1;
57e06b78:	e3500000 	cmp	r0, #0
57e06b7c:	03a05001 	moveq	r5, #1
	}
	debug("Final value for argc=%d\n", argc);

	env_id++;

	while (--argc > 0) {
57e06b80:	e2444001 	sub	r4, r4, #1
57e06b84:	e3540000 	cmp	r4, #0
57e06b88:	cafffff6 	bgt	57e06b68 <do_env_delete+0x60>
57e06b8c:	ea000000 	b	57e06b94 <do_env_delete+0x8c>
			switch (*arg) {
			case 'f':		/* force */
				env_flag |= H_FORCE;
				break;
			default:
				return CMD_RET_USAGE;
57e06b90:	e3e05000 	mvn	r5, #0
		if (!hdelete_r(name, &env_htab, env_flag))
			ret = 1;
	}

	return ret;
}
57e06b94:	e1a00005 	mov	r0, r5
57e06b98:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e06b9c:	57e36610 	.word	0x57e36610
57e06ba0:	57e36dc4 	.word	0x57e36dc4

57e06ba4 <env_print>:
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name, int flag)
{
57e06ba4:	e92d4010 	push	{r4, lr}
	char *res = NULL;
57e06ba8:	e3a03000 	mov	r3, #0
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name, int flag)
{
57e06bac:	e24dd028 	sub	sp, sp, #40	; 0x28
	char *res = NULL;
	size_t len;

	if (name) {		/* print a single name */
57e06bb0:	e3500000 	cmp	r0, #0
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name, int flag)
{
57e06bb4:	e1a02001 	mov	r2, r1
	char *res = NULL;
57e06bb8:	e58d3024 	str	r3, [sp, #36]	; 0x24
	size_t len;

	if (name) {		/* print a single name */
57e06bbc:	0a000013 	beq	57e06c10 <env_print+0x6c>
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
57e06bc0:	e58d3014 	str	r3, [sp, #20]
		hsearch_r(e, FIND, &ep, &env_htab, flag);
57e06bc4:	e58d3000 	str	r3, [sp]
57e06bc8:	e28d3020 	add	r3, sp, #32
57e06bcc:	e58d3004 	str	r3, [sp, #4]
57e06bd0:	e59f3078 	ldr	r3, [pc, #120]	; 57e06c50 <env_print+0xac>
	size_t len;

	if (name) {		/* print a single name */
		ENTRY e, *ep;

		e.key = name;
57e06bd4:	e58d0010 	str	r0, [sp, #16]
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab, flag);
57e06bd8:	e58d3008 	str	r3, [sp, #8]
57e06bdc:	e58d100c 	str	r1, [sp, #12]
57e06be0:	e28d3010 	add	r3, sp, #16
57e06be4:	e893000f 	ldm	r3, {r0, r1, r2, r3}
57e06be8:	eb006fae 	bl	57e22aa8 <hsearch_r>
		if (ep == NULL)
57e06bec:	e59d3020 	ldr	r3, [sp, #32]
57e06bf0:	e3530000 	cmp	r3, #0
			return 0;
57e06bf4:	01a04003 	moveq	r4, r3
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab, flag);
		if (ep == NULL)
57e06bf8:	0a000011 	beq	57e06c44 <env_print+0xa0>
			return 0;
		len = printf("%s=%s\n", ep->key, ep->data);
57e06bfc:	e59f0050 	ldr	r0, [pc, #80]	; 57e06c54 <env_print+0xb0>
57e06c00:	e8930006 	ldm	r3, {r1, r2}
57e06c04:	eb000a10 	bl	57e0944c <printf>
57e06c08:	e1a04000 	mov	r4, r0
		return len;
57e06c0c:	ea00000c 	b	57e06c44 <env_print+0xa0>
	}

	/* print whole list */
	len = hexport_r(&env_htab, '\n', flag, &res, 0, 0, NULL);
57e06c10:	e58d0000 	str	r0, [sp]
57e06c14:	e58d0004 	str	r0, [sp, #4]
57e06c18:	e58d0008 	str	r0, [sp, #8]
57e06c1c:	e3a0100a 	mov	r1, #10
57e06c20:	e59f0028 	ldr	r0, [pc, #40]	; 57e06c50 <env_print+0xac>
57e06c24:	e28d3024 	add	r3, sp, #36	; 0x24
57e06c28:	eb00711e 	bl	57e230a8 <hexport_r>

	if (len > 0) {
57e06c2c:	e2504000 	subs	r4, r0, #0
57e06c30:	0a000003 	beq	57e06c44 <env_print+0xa0>
		puts(res);
57e06c34:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
57e06c38:	eb0009f9 	bl	57e09424 <puts>
		free(res);
57e06c3c:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
57e06c40:	eb000b55 	bl	57e0999c <free>
		return len;
	}

	/* should never happen */
	return 0;
}
57e06c44:	e1a00004 	mov	r0, r4
57e06c48:	e28dd028 	add	sp, sp, #40	; 0x28
57e06c4c:	e8bd8010 	pop	{r4, pc}
57e06c50:	57e36dc4 	.word	0x57e36dc4
57e06c54:	57e30da6 	.word	0x57e30da6

57e06c58 <do_env_print>:
{
	int i;
	int rcode = 0;
	int env_flag = H_HIDE_DOT;

	if (argc > 1 && argv[1][0] == '-' && argv[1][1] == 'a') {
57e06c58:	e3520001 	cmp	r2, #1
	return 0;
}

static int do_env_print(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
57e06c5c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e06c60:	e1a04002 	mov	r4, r2
	int i;
	int rcode = 0;
	int env_flag = H_HIDE_DOT;

	if (argc > 1 && argv[1][0] == '-' && argv[1][1] == 'a') {
57e06c64:	da00000b 	ble	57e06c98 <do_env_print+0x40>
57e06c68:	e5932004 	ldr	r2, [r3, #4]
57e06c6c:	e2831004 	add	r1, r3, #4
57e06c70:	e5d20000 	ldrb	r0, [r2]
57e06c74:	e350002d 	cmp	r0, #45	; 0x2d
57e06c78:	1a000013 	bne	57e06ccc <do_env_print+0x74>
57e06c7c:	e5d22001 	ldrb	r2, [r2, #1]
57e06c80:	e3520061 	cmp	r2, #97	; 0x61
57e06c84:	1a000010 	bne	57e06ccc <do_env_print+0x74>
		argc--;
57e06c88:	e1a03001 	mov	r3, r1
57e06c8c:	e2444001 	sub	r4, r4, #1
		argv++;
		env_flag &= ~H_HIDE_DOT;
57e06c90:	e3a01000 	mov	r1, #0
57e06c94:	ea000000 	b	57e06c9c <do_env_print+0x44>
static int do_env_print(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
	int i;
	int rcode = 0;
	int env_flag = H_HIDE_DOT;
57e06c98:	e3a01008 	mov	r1, #8
		argc--;
		argv++;
		env_flag &= ~H_HIDE_DOT;
	}

	if (argc == 1) {
57e06c9c:	e3540001 	cmp	r4, #1
57e06ca0:	1a00000a 	bne	57e06cd0 <do_env_print+0x78>
		/* print all env vars */
		rcode = env_print(NULL, env_flag);
57e06ca4:	e3a00000 	mov	r0, #0
57e06ca8:	ebffffbd 	bl	57e06ba4 <env_print>
		if (!rcode)
57e06cac:	e2501000 	subs	r1, r0, #0
			return 1;
57e06cb0:	01a05004 	moveq	r5, r4
	}

	if (argc == 1) {
		/* print all env vars */
		rcode = env_print(NULL, env_flag);
		if (!rcode)
57e06cb4:	0a000016 	beq	57e06d14 <do_env_print+0xbc>
			return 1;
		printf("\nEnvironment size: %d/%ld bytes\n",
57e06cb8:	e59f005c 	ldr	r0, [pc, #92]	; 57e06d1c <do_env_print+0xc4>
57e06cbc:	e59f205c 	ldr	r2, [pc, #92]	; 57e06d20 <do_env_print+0xc8>
57e06cc0:	eb0009e1 	bl	57e0944c <printf>
			rcode, (ulong)ENV_SIZE);
		return 0;
57e06cc4:	e3a05000 	mov	r5, #0
57e06cc8:	ea000011 	b	57e06d14 <do_env_print+0xbc>
{
	int i;
	int rcode = 0;
	int env_flag = H_HIDE_DOT;

	if (argc > 1 && argv[1][0] == '-' && argv[1][1] == 'a') {
57e06ccc:	e3a01008 	mov	r1, #8
			rcode, (ulong)ENV_SIZE);
		return 0;
	}

	/* print selected env vars */
	env_flag &= ~H_HIDE_DOT;
57e06cd0:	e3c1a008 	bic	sl, r1, #8
57e06cd4:	e1a07003 	mov	r7, r3

static int do_env_print(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
	int i;
	int rcode = 0;
57e06cd8:	e3a05000 	mov	r5, #0
		return 0;
	}

	/* print selected env vars */
	env_flag &= ~H_HIDE_DOT;
	for (i = 1; i < argc; ++i) {
57e06cdc:	e3a06001 	mov	r6, #1
57e06ce0:	ea000009 	b	57e06d0c <do_env_print+0xb4>
		int rc = env_print(argv[i], env_flag);
57e06ce4:	e5b70004 	ldr	r0, [r7, #4]!
57e06ce8:	e1a0100a 	mov	r1, sl
57e06cec:	ebffffac 	bl	57e06ba4 <env_print>
		if (!rc) {
57e06cf0:	e3500000 	cmp	r0, #0
57e06cf4:	1a000003 	bne	57e06d08 <do_env_print+0xb0>
			printf("## Error: \"%s\" not defined\n", argv[i]);
57e06cf8:	e59f0024 	ldr	r0, [pc, #36]	; 57e06d24 <do_env_print+0xcc>
57e06cfc:	e5971000 	ldr	r1, [r7]
57e06d00:	eb0009d1 	bl	57e0944c <printf>
			++rcode;
57e06d04:	e2855001 	add	r5, r5, #1
		return 0;
	}

	/* print selected env vars */
	env_flag &= ~H_HIDE_DOT;
	for (i = 1; i < argc; ++i) {
57e06d08:	e2866001 	add	r6, r6, #1
57e06d0c:	e1560004 	cmp	r6, r4
57e06d10:	bafffff3 	blt	57e06ce4 <do_env_print+0x8c>
			++rcode;
		}
	}

	return rcode;
}
57e06d14:	e1a00005 	mov	r0, r5
57e06d18:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e06d1c:	57e30dad 	.word	0x57e30dad
57e06d20:	00003ffc 	.word	0x00003ffc
57e06d24:	57e30dce 	.word	0x57e30dce

57e06d28 <do_env>:

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
57e06d28:	e3520001 	cmp	r2, #1
	fixup_cmdtable(cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
}
#endif

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e06d2c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e06d30:	e1a05000 	mov	r5, r0
57e06d34:	e1a06001 	mov	r6, r1
57e06d38:	e1a04002 	mov	r4, r2
	cmd_tbl_t *cp;

	if (argc < 2)
		return CMD_RET_USAGE;
57e06d3c:	d3e00000 	mvnle	r0, #0

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
57e06d40:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}

	/* drop initial "env" arg */
	argc--;
	argv++;

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
57e06d44:	e5930004 	ldr	r0, [r3, #4]
57e06d48:	e59f1034 	ldr	r1, [pc, #52]	; 57e06d84 <do_env+0x5c>
57e06d4c:	e3a02009 	mov	r2, #9
	if (argc < 2)
		return CMD_RET_USAGE;

	/* drop initial "env" arg */
	argc--;
	argv++;
57e06d50:	e2837004 	add	r7, r3, #4

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
57e06d54:	eb000834 	bl	57e08e2c <find_cmd_tbl>

	if (cp)
57e06d58:	e3500000 	cmp	r0, #0
57e06d5c:	0a000006 	beq	57e06d7c <do_env+0x54>
		return cp->cmd(cmdtp, flag, argc, argv);
57e06d60:	e590c00c 	ldr	ip, [r0, #12]
57e06d64:	e1a01006 	mov	r1, r6
57e06d68:	e1a00005 	mov	r0, r5
57e06d6c:	e2442001 	sub	r2, r4, #1
57e06d70:	e1a03007 	mov	r3, r7
57e06d74:	e12fff3c 	blx	ip
57e06d78:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

	return CMD_RET_USAGE;
57e06d7c:	e3e00000 	mvn	r0, #0
}
57e06d80:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e06d84:	57e36614 	.word	0x57e36614

57e06d88 <do_env_import>:
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
57e06d88:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
57e06d8c:	e3a0a000 	mov	sl, #0
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
57e06d90:	e1a04002 	mov	r4, r2
57e06d94:	e24dd01c 	sub	sp, sp, #28
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
	size_t	size;

	cmd = *argv;
57e06d98:	e4931004 	ldr	r1, [r3], #4
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
57e06d9c:	e1a0200a 	mov	r2, sl
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
57e06da0:	e1a0900a 	mov	r9, sl
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
57e06da4:	e3a0700a 	mov	r7, #10
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
57e06da8:	ea00001d 	b	57e06e24 <do_env_import+0x9c>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
57e06dac:	e3500063 	cmp	r0, #99	; 0x63
57e06db0:	0a00000c 	beq	57e06de8 <do_env_import+0x60>
57e06db4:	8a000002 	bhi	57e06dc4 <do_env_import+0x3c>
57e06db8:	e3500062 	cmp	r0, #98	; 0x62
57e06dbc:	1a000076 	bne	57e06f9c <do_env_import+0x214>
57e06dc0:	ea000004 	b	57e06dd8 <do_env_import+0x50>
57e06dc4:	e3500064 	cmp	r0, #100	; 0x64
57e06dc8:	0a000011 	beq	57e06e14 <do_env_import+0x8c>
57e06dcc:	e3500074 	cmp	r0, #116	; 0x74
57e06dd0:	1a000071 	bne	57e06f9c <do_env_import+0x214>
57e06dd4:	ea000009 	b	57e06e00 <do_env_import+0x78>
			case 'b':		/* raw binary format */
				if (fmt++)
57e06dd8:	e3520000 	cmp	r2, #0
57e06ddc:	1a00006a 	bne	57e06f8c <do_env_import+0x204>
57e06de0:	e2822001 	add	r2, r2, #1
57e06de4:	ea000003 	b	57e06df8 <do_env_import+0x70>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
57e06de8:	e3520000 	cmp	r2, #0
57e06dec:	1a000066 	bne	57e06f8c <do_env_import+0x204>
57e06df0:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\0';
				chk = 1;
57e06df4:	e1a09002 	mov	r9, r2
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
57e06df8:	e3a07000 	mov	r7, #0
57e06dfc:	ea000005 	b	57e06e18 <do_env_import+0x90>
				chk = 1;
				break;
			case 't':		/* text format */
				if (fmt++)
57e06e00:	e3520000 	cmp	r2, #0
57e06e04:	1a000060 	bne	57e06f8c <do_env_import+0x204>
57e06e08:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\n';
57e06e0c:	e3a0700a 	mov	r7, #10
57e06e10:	ea000000 	b	57e06e18 <do_env_import+0x90>
				break;
			case 'd':
				del = 1;
57e06e14:	e3a0a001 	mov	sl, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
57e06e18:	e5fc0001 	ldrb	r0, [ip, #1]!
57e06e1c:	e3500000 	cmp	r0, #0
57e06e20:	1affffe1 	bne	57e06dac <do_env_import+0x24>
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
57e06e24:	e2444001 	sub	r4, r4, #1
57e06e28:	e3540000 	cmp	r4, #0
57e06e2c:	da00005a 	ble	57e06f9c <do_env_import+0x214>
57e06e30:	e1a05003 	mov	r5, r3
57e06e34:	e493c004 	ldr	ip, [r3], #4
57e06e38:	e5dc0000 	ldrb	r0, [ip]
57e06e3c:	e350002d 	cmp	r0, #45	; 0x2d
57e06e40:	0afffff4 	beq	57e06e18 <do_env_import+0x90>
57e06e44:	ea000057 	b	57e06fa8 <do_env_import+0x220>

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");
57e06e48:	e59f0164 	ldr	r0, [pc, #356]	; 57e06fb4 <do_env_import+0x22c>
57e06e4c:	eb00097e 	bl	57e0944c <printf>

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
57e06e50:	e3a02010 	mov	r2, #16
57e06e54:	e5950000 	ldr	r0, [r5]
57e06e58:	e3a01000 	mov	r1, #0
57e06e5c:	eb007890 	bl	57e250a4 <simple_strtoul>

	if (argc == 2) {
57e06e60:	e3540002 	cmp	r4, #2
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
57e06e64:	e1a06000 	mov	r6, r0

	if (argc == 2) {
57e06e68:	11a02000 	movne	r2, r0
57e06e6c:	13a03000 	movne	r3, #0
57e06e70:	1a000006 	bne	57e06e90 <do_env_import+0x108>
		size = simple_strtoul(argv[1], NULL, 16);
57e06e74:	e5950004 	ldr	r0, [r5, #4]
57e06e78:	e3a01000 	mov	r1, #0
57e06e7c:	e3a02010 	mov	r2, #16
57e06e80:	eb007887 	bl	57e250a4 <simple_strtoul>
57e06e84:	e1a05000 	mov	r5, r0
57e06e88:	ea000013 	b	57e06edc <do_env_import+0x154>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
57e06e8c:	e1a03005 	mov	r3, r5
			if ((*s == sep) && (*(s+1) == '\0'))
57e06e90:	e4d21001 	ldrb	r1, [r2], #1
57e06e94:	e2835001 	add	r5, r3, #1
57e06e98:	e1510007 	cmp	r1, r7
57e06e9c:	1a000002 	bne	57e06eac <do_env_import+0x124>
57e06ea0:	e7d61005 	ldrb	r1, [r6, r5]
57e06ea4:	e3510000 	cmp	r1, #0
57e06ea8:	0a000005 	beq	57e06ec4 <do_env_import+0x13c>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
57e06eac:	e3550601 	cmp	r5, #1048576	; 0x100000
57e06eb0:	1afffff5 	bne	57e06e8c <do_env_import+0x104>
				break;
			++s;
			++size;
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
57e06eb4:	e1a01005 	mov	r1, r5
57e06eb8:	e59f00f8 	ldr	r0, [pc, #248]	; 57e06fb8 <do_env_import+0x230>
57e06ebc:	eb000962 	bl	57e0944c <printf>
57e06ec0:	ea000000 	b	57e06ec8 <do_env_import+0x140>
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
			if ((*s == sep) && (*(s+1) == '\0'))
57e06ec4:	e1a05003 	mov	r5, r3
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
				" - truncated\n", MAX_ENV_SIZE);
		}
		size += 2;
57e06ec8:	e2855002 	add	r5, r5, #2
		printf("## Info: input data size = %zu = 0x%zX\n", size, size);
57e06ecc:	e59f00e8 	ldr	r0, [pc, #232]	; 57e06fbc <do_env_import+0x234>
57e06ed0:	e1a01005 	mov	r1, r5
57e06ed4:	e1a02005 	mov	r2, r5
57e06ed8:	eb00095b 	bl	57e0944c <printf>
	}

	if (chk) {
57e06edc:	e3590000 	cmp	r9, #0
57e06ee0:	0a00000f 	beq	57e06f24 <do_env_import+0x19c>
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
57e06ee4:	e1a01006 	mov	r1, r6
57e06ee8:	e3a02004 	mov	r2, #4

	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
57e06eec:	e2455004 	sub	r5, r5, #4
		memcpy(&crc, &ep->crc, sizeof(crc));
57e06ef0:	e28d0014 	add	r0, sp, #20

		if (crc32(0, ep->data, size) != crc) {
57e06ef4:	e2866004 	add	r6, r6, #4
	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
57e06ef8:	eb007503 	bl	57e2430c <memcpy>

		if (crc32(0, ep->data, size) != crc) {
57e06efc:	e3a00000 	mov	r0, #0
57e06f00:	e1a01006 	mov	r1, r6
57e06f04:	e1a02005 	mov	r2, r5
57e06f08:	eb006cc0 	bl	57e22210 <crc32>
57e06f0c:	e59d3014 	ldr	r3, [sp, #20]
57e06f10:	e1500003 	cmp	r0, r3
57e06f14:	0a000002 	beq	57e06f24 <do_env_import+0x19c>
			puts("## Error: bad CRC, import failed\n");
57e06f18:	e59f00a0 	ldr	r0, [pc, #160]	; 57e06fc0 <do_env_import+0x238>
57e06f1c:	eb000940 	bl	57e09424 <puts>
57e06f20:	ea00001b 	b	57e06f94 <do_env_import+0x20c>
			return 1;
		}
		addr = (char *)ep->data;
	}

	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
57e06f24:	e3a04000 	mov	r4, #0
57e06f28:	e22aa001 	eor	sl, sl, #1
57e06f2c:	e59f0090 	ldr	r0, [pc, #144]	; 57e06fc4 <do_env_import+0x23c>
57e06f30:	e1a01006 	mov	r1, r6
57e06f34:	e1a02005 	mov	r2, r5
57e06f38:	e1a03007 	mov	r3, r7
57e06f3c:	e58da000 	str	sl, [sp]
57e06f40:	e58d4004 	str	r4, [sp, #4]
57e06f44:	e58d4008 	str	r4, [sp, #8]
57e06f48:	eb00710a 	bl	57e23378 <himport_r>
57e06f4c:	e1500004 	cmp	r0, r4
57e06f50:	1a000008 	bne	57e06f78 <do_env_import+0x1f0>
			0, NULL) == 0) {
		error("Environment import failed: errno = %d\n", errno);
57e06f54:	e59f306c 	ldr	r3, [pc, #108]	; 57e06fc8 <do_env_import+0x240>
57e06f58:	e59f206c 	ldr	r2, [pc, #108]	; 57e06fcc <do_env_import+0x244>
57e06f5c:	e58d3000 	str	r3, [sp]
57e06f60:	e59f3068 	ldr	r3, [pc, #104]	; 57e06fd0 <do_env_import+0x248>
57e06f64:	e59f0068 	ldr	r0, [pc, #104]	; 57e06fd4 <do_env_import+0x24c>
57e06f68:	e5931000 	ldr	r1, [r3]
57e06f6c:	e3a03ffb 	mov	r3, #1004	; 0x3ec
57e06f70:	eb000935 	bl	57e0944c <printf>
57e06f74:	ea000006 	b	57e06f94 <do_env_import+0x20c>
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
57e06f78:	e5982004 	ldr	r2, [r8, #4]

	return 0;
57e06f7c:	e1a00004 	mov	r0, r4
	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
			0, NULL) == 0) {
		error("Environment import failed: errno = %d\n", errno);
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
57e06f80:	e3822080 	orr	r2, r2, #128	; 0x80
57e06f84:	e5882004 	str	r2, [r8, #4]

	return 0;
57e06f88:	ea000004 	b	57e06fa0 <do_env_import+0x218>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
57e06f8c:	e59f0044 	ldr	r0, [pc, #68]	; 57e06fd8 <do_env_import+0x250>
57e06f90:	eb00092d 	bl	57e0944c <printf>
		cmd);
	return 1;
57e06f94:	e3a00001 	mov	r0, #1
57e06f98:	ea000000 	b	57e06fa0 <do_env_import+0x218>
			}
		}
	}

	if (argc < 1)
		return CMD_RET_USAGE;
57e06f9c:	e3e00000 	mvn	r0, #0

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
		cmd);
	return 1;
}
57e06fa0:	e28dd01c 	add	sp, sp, #28
57e06fa4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
57e06fa8:	e3520000 	cmp	r2, #0
57e06fac:	1affffa7 	bne	57e06e50 <do_env_import+0xc8>
57e06fb0:	eaffffa4 	b	57e06e48 <do_env_import+0xc0>
57e06fb4:	57e30dea 	.word	0x57e30dea
57e06fb8:	57e30e11 	.word	0x57e30e11
57e06fbc:	57e30e46 	.word	0x57e30e46
57e06fc0:	57e30e6e 	.word	0x57e30e6e
57e06fc4:	57e36dc4 	.word	0x57e36dc4
57e06fc8:	57e2bda0 	.word	0x57e2bda0
57e06fcc:	57e30ecd 	.word	0x57e30ecd
57e06fd0:	57e79098 	.word	0x57e79098
57e06fd4:	57e30e90 	.word	0x57e30e90
57e06fd8:	57e30eda 	.word	0x57e30eda

57e06fdc <do_env_default>:
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
			  int argc, char * const argv[])
{
57e06fdc:	e92d4070 	push	{r4, r5, r6, lr}
	int all = 0, flag = 0;
57e06fe0:	e3a0c000 	mov	ip, #0

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
57e06fe4:	ea000009 	b	57e07010 <do_env_default+0x34>
		char *arg = *argv;

		while (*++arg) {
			switch (*arg) {
57e06fe8:	e3530061 	cmp	r3, #97	; 0x61
57e06fec:	0a000002 	beq	57e06ffc <do_env_default+0x20>
57e06ff0:	e3530066 	cmp	r3, #102	; 0x66
57e06ff4:	1a000021 	bne	57e07080 <do_env_default+0xa4>
57e06ff8:	ea000000 	b	57e07000 <do_env_default+0x24>
			case 'a':		/* default all */
				all = 1;
57e06ffc:	e3a0c001 	mov	ip, #1

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;

		while (*++arg) {
57e07000:	e5f13001 	ldrb	r3, [r1, #1]!
57e07004:	e3530000 	cmp	r3, #0
57e07008:	1afffff6 	bne	57e06fe8 <do_env_default+0xc>
57e0700c:	e1a03004 	mov	r3, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
57e07010:	e2422001 	sub	r2, r2, #1
57e07014:	e3520000 	cmp	r2, #0
		char *arg = *argv;

		while (*++arg) {
57e07018:	e1a01003 	mov	r1, r3
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
57e0701c:	da000006 	ble	57e0703c <do_env_default+0x60>

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
57e07020:	e2834004 	add	r4, r3, #4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
57e07024:	e5933004 	ldr	r3, [r3, #4]

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
57e07028:	e1a01004 	mov	r1, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
57e0702c:	e5d35000 	ldrb	r5, [r3]
57e07030:	e355002d 	cmp	r5, #45	; 0x2d
57e07034:	01a01003 	moveq	r1, r3
57e07038:	0afffff0 	beq	57e07000 <do_env_default+0x24>
				return cmd_usage(cmdtp);
			}
		}
	}
	debug("Final value for argc=%d\n", argc);
	if (all && (argc == 0)) {
57e0703c:	e3520000 	cmp	r2, #0
57e07040:	13a03000 	movne	r3, #0
57e07044:	020c3001 	andeq	r3, ip, #1
57e07048:	e3530000 	cmp	r3, #0
57e0704c:	0a000002 	beq	57e0705c <do_env_default+0x80>
		/* Reset the whole environment */
		set_default_env("## Resetting to default environment\n");
57e07050:	e59f0038 	ldr	r0, [pc, #56]	; 57e07090 <do_env_default+0xb4>
57e07054:	eb000f6e 	bl	57e0ae14 <set_default_env>
		return 0;
57e07058:	ea00000a 	b	57e07088 <do_env_default+0xac>
	}
	if (!all && (argc > 0)) {
57e0705c:	e22cc001 	eor	ip, ip, #1
57e07060:	e3520000 	cmp	r2, #0
57e07064:	d3a0c000 	movle	ip, #0
57e07068:	c20cc001 	andgt	ip, ip, #1
57e0706c:	e35c0000 	cmp	ip, #0
57e07070:	0a000002 	beq	57e07080 <do_env_default+0xa4>
		/* Reset individual variables */
		set_default_vars(argc, argv);
57e07074:	e1a00002 	mov	r0, r2
57e07078:	eb000f93 	bl	57e0aecc <set_default_vars>
		return 0;
57e0707c:	ea000001 	b	57e07088 <do_env_default+0xac>
	}

	return cmd_usage(cmdtp);
}
57e07080:	e8bd4070 	pop	{r4, r5, r6, lr}
		/* Reset individual variables */
		set_default_vars(argc, argv);
		return 0;
	}

	return cmd_usage(cmdtp);
57e07084:	ea000799 	b	57e08ef0 <cmd_usage>
}
57e07088:	e3a00000 	mov	r0, #0
57e0708c:	e8bd8070 	pop	{r4, r5, r6, pc}
57e07090:	57e30f09 	.word	0x57e30f09

57e07094 <do_env_save>:

#ifndef CONFIG_SPL_BUILD
#if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
static int do_env_save(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
57e07094:	e92d4008 	push	{r3, lr}
	printf("Saving Environment to %s...\n", env_name_spec);
57e07098:	e59f3018 	ldr	r3, [pc, #24]	; 57e070b8 <do_env_save+0x24>
57e0709c:	e59f0018 	ldr	r0, [pc, #24]	; 57e070bc <do_env_save+0x28>
57e070a0:	e5931000 	ldr	r1, [r3]
57e070a4:	eb0008e8 	bl	57e0944c <printf>

	return saveenv() ? 1 : 0;
57e070a8:	eb0011ae 	bl	57e0b768 <saveenv>
}
57e070ac:	e2500000 	subs	r0, r0, #0
57e070b0:	13a00001 	movne	r0, #1
57e070b4:	e8bd8008 	pop	{r3, pc}
57e070b8:	57e36dd8 	.word	0x57e36dd8
57e070bc:	57e30f2e 	.word	0x57e30f2e

57e070c0 <_do_env_set.clone.0>:

/*
 * Set a new environment variable,
 * or replace or delete an existing one.
 */
static int _do_env_set(int flag, int argc, char * const argv[])
57e070c0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e070c4:	e1a06000 	mov	r6, r0
57e070c8:	e24dd028 	sub	sp, sp, #40	; 0x28
{
	int   i, len;
	char  *name, *value, *s;
	ENTRY e, *ep;
	int env_flag = H_INTERACTIVE;
57e070cc:	e3a07004 	mov	r7, #4
57e070d0:	ea000006 	b	57e070f0 <_do_env_set.clone.0+0x30>
	while (argc > 1 && **(argv + 1) == '-') {
		char *arg = *++argv;

		--argc;
		while (*++arg) {
			switch (*arg) {
57e070d4:	e3520066 	cmp	r2, #102	; 0x66
57e070d8:	1a000060 	bne	57e07260 <_do_env_set.clone.0+0x1a0>
			case 'f':		/* force */
				env_flag |= H_FORCE;
57e070dc:	e3877002 	orr	r7, r7, #2
	debug("Initial value for argc=%d\n", argc);
	while (argc > 1 && **(argv + 1) == '-') {
		char *arg = *++argv;

		--argc;
		while (*++arg) {
57e070e0:	e5f32001 	ldrb	r2, [r3, #1]!
57e070e4:	e3520000 	cmp	r2, #0
57e070e8:	1afffff9 	bne	57e070d4 <_do_env_set.clone.0+0x14>

	debug("Initial value for argc=%d\n", argc);
	while (argc > 1 && **(argv + 1) == '-') {
		char *arg = *++argv;

		--argc;
57e070ec:	e2466001 	sub	r6, r6, #1
	char  *name, *value, *s;
	ENTRY e, *ep;
	int env_flag = H_INTERACTIVE;

	debug("Initial value for argc=%d\n", argc);
	while (argc > 1 && **(argv + 1) == '-') {
57e070f0:	e3560001 	cmp	r6, #1
		char *arg = *++argv;

		--argc;
57e070f4:	e1a05001 	mov	r5, r1
	char  *name, *value, *s;
	ENTRY e, *ep;
	int env_flag = H_INTERACTIVE;

	debug("Initial value for argc=%d\n", argc);
	while (argc > 1 && **(argv + 1) == '-') {
57e070f8:	da000003 	ble	57e0710c <_do_env_set.clone.0+0x4c>
57e070fc:	e5b13004 	ldr	r3, [r1, #4]!
57e07100:	e5d32000 	ldrb	r2, [r3]
57e07104:	e352002d 	cmp	r2, #45	; 0x2d
57e07108:	0afffff4 	beq	57e070e0 <_do_env_set.clone.0+0x20>
				return CMD_RET_USAGE;
			}
		}
	}
	debug("Final value for argc=%d\n", argc);
	name = argv[1];
57e0710c:	e5954004 	ldr	r4, [r5, #4]
	value = argv[2];

	if (strchr(name, '=')) {
57e07110:	e3a0103d 	mov	r1, #61	; 0x3d
57e07114:	e1a00004 	mov	r0, r4
57e07118:	eb0073bf 	bl	57e2401c <strchr>
57e0711c:	e2509000 	subs	r9, r0, #0
				return CMD_RET_USAGE;
			}
		}
	}
	debug("Final value for argc=%d\n", argc);
	name = argv[1];
57e07120:	e285a004 	add	sl, r5, #4
	value = argv[2];

	if (strchr(name, '=')) {
		printf("## Error: illegal character '='"
57e07124:	159f0140 	ldrne	r0, [pc, #320]	; 57e0726c <_do_env_set.clone.0+0x1ac>
57e07128:	11a01004 	movne	r1, r4
	}
	debug("Final value for argc=%d\n", argc);
	name = argv[1];
	value = argv[2];

	if (strchr(name, '=')) {
57e0712c:	1a000021 	bne	57e071b8 <_do_env_set.clone.0+0xf8>
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
57e07130:	e59f3138 	ldr	r3, [pc, #312]	; 57e07270 <_do_env_set.clone.0+0x1b0>

	/* Delete only ? */
	if (argc < 3 || argv[2] == NULL) {
57e07134:	e3560002 	cmp	r6, #2
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
57e07138:	e5932000 	ldr	r2, [r3]
57e0713c:	e2822001 	add	r2, r2, #1
57e07140:	e5832000 	str	r2, [r3]

	/* Delete only ? */
	if (argc < 3 || argv[2] == NULL) {
57e07144:	da000004 	ble	57e0715c <_do_env_set.clone.0+0x9c>
57e07148:	e5953008 	ldr	r3, [r5, #8]
57e0714c:	e3530000 	cmp	r3, #0
57e07150:	11a0b00a 	movne	fp, sl
57e07154:	13a05002 	movne	r5, #2
57e07158:	1a000006 	bne	57e07178 <_do_env_set.clone.0+0xb8>
		int rc = hdelete_r(name, &env_htab, env_flag);
57e0715c:	e1a00004 	mov	r0, r4
57e07160:	e59f110c 	ldr	r1, [pc, #268]	; 57e07274 <_do_env_set.clone.0+0x1b4>
57e07164:	e1a02007 	mov	r2, r7
57e07168:	eb006f87 	bl	57e22f8c <hdelete_r>
		return !rc;
57e0716c:	e2700001 	rsbs	r0, r0, #1
57e07170:	33a00000 	movcc	r0, #0
57e07174:	ea00003a 	b	57e07264 <_do_env_set.clone.0+0x1a4>

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;
57e07178:	e5bb0004 	ldr	r0, [fp, #4]!
57e0717c:	eb0073b3 	bl	57e24050 <strlen>
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
57e07180:	e2855001 	add	r5, r5, #1
		len += strlen(argv[i]) + 1;
57e07184:	e2800001 	add	r0, r0, #1
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
57e07188:	e1550006 	cmp	r5, r6
		len += strlen(argv[i]) + 1;
57e0718c:	e0809009 	add	r9, r0, r9
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
57e07190:	bafffff8 	blt	57e07178 <_do_env_set.clone.0+0xb8>
		len += strlen(argv[i]) + 1;

	value = malloc(len);
57e07194:	e1a00009 	mov	r0, r9
57e07198:	eb000a89 	bl	57e09bc4 <malloc>
	if (value == NULL) {
57e0719c:	e2505000 	subs	r5, r0, #0
57e071a0:	11a0c005 	movne	ip, r5
57e071a4:	13a01002 	movne	r1, #2
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
57e071a8:	13a09020 	movne	r9, #32
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;

	value = malloc(len);
	if (value == NULL) {
57e071ac:	1a000004 	bne	57e071c4 <_do_env_set.clone.0+0x104>
		printf("## Can't malloc %d bytes\n", len);
57e071b0:	e59f00c0 	ldr	r0, [pc, #192]	; 57e07278 <_do_env_set.clone.0+0x1b8>
57e071b4:	e1a01009 	mov	r1, r9
57e071b8:	eb0008a3 	bl	57e0944c <printf>
		return 1;
57e071bc:	e3a00001 	mov	r0, #1
57e071c0:	ea000027 	b	57e07264 <_do_env_set.clone.0+0x1a4>
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;

	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
57e071c4:	e5bae004 	ldr	lr, [sl, #4]!
57e071c8:	e1a0300c 	mov	r3, ip
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
57e071cc:	e4de2001 	ldrb	r2, [lr], #1
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;

	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
57e071d0:	e1a00003 	mov	r0, r3
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
57e071d4:	e3520000 	cmp	r2, #0
57e071d8:	e4c32001 	strb	r2, [r3], #1
57e071dc:	e1a0c003 	mov	ip, r3
57e071e0:	1afffff9 	bne	57e071cc <_do_env_set.clone.0+0x10c>
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
57e071e4:	e2811001 	add	r1, r1, #1
57e071e8:	e1510006 	cmp	r1, r6
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
57e071ec:	e5c09000 	strb	r9, [r0]
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
57e071f0:	1afffff3 	bne	57e071c4 <_do_env_set.clone.0+0x104>

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
57e071f4:	e1530005 	cmp	r3, r5
		*--s = '\0';

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab, env_flag);
57e071f8:	e28d3024 	add	r3, sp, #36	; 0x24
		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
		*--s = '\0';
57e071fc:	15c02000 	strbne	r2, [r0]

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab, env_flag);
57e07200:	e58d3004 	str	r3, [sp, #4]
57e07204:	e59f3068 	ldr	r3, [pc, #104]	; 57e07274 <_do_env_set.clone.0+0x1b4>
57e07208:	e3a06001 	mov	r6, #1
57e0720c:	e58d3008 	str	r3, [sp, #8]
		*(s - 1) = ' ';
	}
	if (s != value)
		*--s = '\0';

	e.key	= name;
57e07210:	e58d4014 	str	r4, [sp, #20]
	e.data	= value;
57e07214:	e58d5018 	str	r5, [sp, #24]
	hsearch_r(e, ENTER, &ep, &env_htab, env_flag);
57e07218:	e58d6000 	str	r6, [sp]
57e0721c:	e58d700c 	str	r7, [sp, #12]
57e07220:	e28d3014 	add	r3, sp, #20
57e07224:	e893000f 	ldm	r3, {r0, r1, r2, r3}
57e07228:	eb006e1e 	bl	57e22aa8 <hsearch_r>
	free(value);
57e0722c:	e1a00005 	mov	r0, r5
57e07230:	eb0009d9 	bl	57e0999c <free>
	if (!ep) {
57e07234:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e07238:	e3530000 	cmp	r3, #0
		printf("## Error inserting \"%s\" variable, errno=%d\n",
			name, errno);
		return 1;
	}

	return 0;
57e0723c:	13a00000 	movne	r0, #0

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab, env_flag);
	free(value);
	if (!ep) {
57e07240:	1a000007 	bne	57e07264 <_do_env_set.clone.0+0x1a4>
		printf("## Error inserting \"%s\" variable, errno=%d\n",
57e07244:	e59f3030 	ldr	r3, [pc, #48]	; 57e0727c <_do_env_set.clone.0+0x1bc>
57e07248:	e59f0030 	ldr	r0, [pc, #48]	; 57e07280 <_do_env_set.clone.0+0x1c0>
57e0724c:	e1a01004 	mov	r1, r4
57e07250:	e5932000 	ldr	r2, [r3]
57e07254:	eb00087c 	bl	57e0944c <printf>
			name, errno);
		return 1;
57e07258:	e1a00006 	mov	r0, r6
57e0725c:	ea000000 	b	57e07264 <_do_env_set.clone.0+0x1a4>
			switch (*arg) {
			case 'f':		/* force */
				env_flag |= H_FORCE;
				break;
			default:
				return CMD_RET_USAGE;
57e07260:	e3e00000 	mvn	r0, #0
			name, errno);
		return 1;
	}

	return 0;
}
57e07264:	e28dd028 	add	sp, sp, #40	; 0x28
57e07268:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0726c:	57e30f4b 	.word	0x57e30f4b
57e07270:	57e36610 	.word	0x57e36610
57e07274:	57e36dc4 	.word	0x57e36dc4
57e07278:	57e30f81 	.word	0x57e30f81
57e0727c:	57e79098 	.word	0x57e79098
57e07280:	57e30f9b 	.word	0x57e30f9b

57e07284 <do_env_set>:
}

#ifndef CONFIG_SPL_BUILD
static int do_env_set(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc < 2)
57e07284:	e3520001 	cmp	r2, #1
57e07288:	da000002 	ble	57e07298 <do_env_set+0x14>
		return CMD_RET_USAGE;

	return _do_env_set(flag, argc, argv);
57e0728c:	e1a00002 	mov	r0, r2
57e07290:	e1a01003 	mov	r1, r3
57e07294:	eaffff89 	b	57e070c0 <_do_env_set.clone.0>
}
57e07298:	e3e00000 	mvn	r0, #0
57e0729c:	e12fff1e 	bx	lr

57e072a0 <get_env_id>:
static int env_id = 1;

int get_env_id(void)
{
	return env_id;
}
57e072a0:	e59f3004 	ldr	r3, [pc, #4]	; 57e072ac <get_env_id+0xc>
57e072a4:	e5930000 	ldr	r0, [r3]
57e072a8:	e12fff1e 	bx	lr
57e072ac:	57e36610 	.word	0x57e36610

57e072b0 <setenv>:

	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
57e072b0:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
57e072b4:	e59f303c 	ldr	r3, [pc, #60]	; 57e072f8 <setenv+0x48>
57e072b8:	e58d0004 	str	r0, [sp, #4]
57e072bc:	e58d3000 	str	r3, [sp]
57e072c0:	e3a03000 	mov	r3, #0

	if (varvalue == NULL || varvalue[0] == '\0')
57e072c4:	e1510003 	cmp	r1, r3
	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
57e072c8:	e58d1008 	str	r1, [sp, #8]
57e072cc:	e58d300c 	str	r3, [sp, #12]

	if (varvalue == NULL || varvalue[0] == '\0')
57e072d0:	0a000003 	beq	57e072e4 <setenv+0x34>
57e072d4:	e5d13000 	ldrb	r3, [r1]
57e072d8:	e3530000 	cmp	r3, #0
		return _do_env_set(0, 2, (char * const *)argv);
	else
		return _do_env_set(0, 3, (char * const *)argv);
57e072dc:	13a00003 	movne	r0, #3

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };

	if (varvalue == NULL || varvalue[0] == '\0')
57e072e0:	1a000000 	bne	57e072e8 <setenv+0x38>
		return _do_env_set(0, 2, (char * const *)argv);
57e072e4:	e3a00002 	mov	r0, #2
	else
		return _do_env_set(0, 3, (char * const *)argv);
57e072e8:	e1a0100d 	mov	r1, sp
57e072ec:	ebffff73 	bl	57e070c0 <_do_env_set.clone.0>
}
57e072f0:	e28dd014 	add	sp, sp, #20
57e072f4:	e8bd8000 	pop	{pc}
57e072f8:	57e30fc7 	.word	0x57e30fc7

57e072fc <do_env_export>:
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
57e072fc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
57e07300:	e3a0a000 	mov	sl, #0
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
57e07304:	e24dd040 	sub	sp, sp, #64	; 0x40
57e07308:	e1a0c000 	mov	ip, r0
57e0730c:	e1a04002 	mov	r4, r2
57e07310:	e1a05003 	mov	r5, r3
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;
57e07314:	e593b000 	ldr	fp, [r3]
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
57e07318:	e1a0900a 	mov	r9, sl
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
57e0731c:	e3a0600a 	mov	r6, #10
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
57e07320:	e1a0700a 	mov	r7, sl
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
57e07324:	ea000027 	b	57e073c8 <do_env_export+0xcc>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
57e07328:	e3520063 	cmp	r2, #99	; 0x63
57e0732c:	0a00000b 	beq	57e07360 <do_env_export+0x64>
57e07330:	8a000002 	bhi	57e07340 <do_env_export+0x44>
57e07334:	e3520062 	cmp	r2, #98	; 0x62
57e07338:	1a000076 	bne	57e07518 <do_env_export+0x21c>
57e0733c:	ea000004 	b	57e07354 <do_env_export+0x58>
57e07340:	e3520073 	cmp	r2, #115	; 0x73
57e07344:	0a00000a 	beq	57e07374 <do_env_export+0x78>
57e07348:	e3520074 	cmp	r2, #116	; 0x74
57e0734c:	1a000071 	bne	57e07518 <do_env_export+0x21c>
57e07350:	ea000014 	b	57e073a8 <do_env_export+0xac>
			case 'b':		/* raw binary format */
				if (fmt++)
57e07354:	e3530000 	cmp	r3, #0
57e07358:	0a000003 	beq	57e0736c <do_env_export+0x70>
57e0735c:	ea000068 	b	57e07504 <do_env_export+0x208>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
57e07360:	e3530000 	cmp	r3, #0
57e07364:	1a000066 	bne	57e07504 <do_env_export+0x208>
					goto sep_err;
				sep = '\0';
				chk = 1;
57e07368:	e3a09001 	mov	r9, #1
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
57e0736c:	e1a06003 	mov	r6, r3
57e07370:	ea00000f 	b	57e073b4 <do_env_export+0xb8>
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
57e07374:	e2544001 	subs	r4, r4, #1
57e07378:	1a000002 	bne	57e07388 <do_env_export+0x8c>
					return cmd_usage(cmdtp);
57e0737c:	e1a0000c 	mov	r0, ip
57e07380:	eb0006da 	bl	57e08ef0 <cmd_usage>
57e07384:	ea000064 	b	57e0751c <do_env_export+0x220>
				size = simple_strtoul(*++argv, NULL, 16);
57e07388:	e5b50004 	ldr	r0, [r5, #4]!
57e0738c:	e3a01000 	mov	r1, #0
57e07390:	e3a02010 	mov	r2, #16
57e07394:	e58dc014 	str	ip, [sp, #20]
57e07398:	eb007741 	bl	57e250a4 <simple_strtoul>
				goto NXTARG;
57e0739c:	e59dc014 	ldr	ip, [sp, #20]
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
57e073a0:	e1a07000 	mov	r7, r0
				goto NXTARG;
57e073a4:	ea000007 	b	57e073c8 <do_env_export+0xcc>
			case 't':		/* text format */
				if (fmt++)
57e073a8:	e3530000 	cmp	r3, #0
57e073ac:	1a000054 	bne	57e07504 <do_env_export+0x208>
					goto sep_err;
				sep = '\n';
57e073b0:	e3a0600a 	mov	r6, #10
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
57e073b4:	e3a03001 	mov	r3, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
57e073b8:	e5f02001 	ldrb	r2, [r0, #1]!
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
57e073bc:	e1a0a003 	mov	sl, r3

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
57e073c0:	e3520000 	cmp	r2, #0
57e073c4:	1affffd7 	bne	57e07328 <do_env_export+0x2c>
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
57e073c8:	e2444001 	sub	r4, r4, #1
57e073cc:	e3540000 	cmp	r4, #0
57e073d0:	da000050 	ble	57e07518 <do_env_export+0x21c>
57e073d4:	e5b50004 	ldr	r0, [r5, #4]!
57e073d8:	e5d03000 	ldrb	r3, [r0]
57e073dc:	e353002d 	cmp	r3, #45	; 0x2d
57e073e0:	1a00004f 	bne	57e07524 <do_env_export+0x228>
57e073e4:	e1a0300a 	mov	r3, sl
57e073e8:	eafffff2 	b	57e073b8 <do_env_export+0xbc>
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);
57e073ec:	e3a01000 	mov	r1, #0
57e073f0:	e1a02007 	mov	r2, r7
57e073f4:	eb0073a0 	bl	57e2427c <memset>

	argc--;
	argv++;

	if (sep) {		/* export as text file */
57e073f8:	e3560000 	cmp	r6, #0
	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);

	argc--;
57e073fc:	e2444001 	sub	r4, r4, #1
	argv++;
57e07400:	e2855004 	add	r5, r5, #4

	if (sep) {		/* export as text file */
57e07404:	0a000014 	beq	57e0745c <do_env_export+0x160>
		len = hexport_r(&env_htab, sep, 0, &addr, size, argc, argv);
57e07408:	e3a02000 	mov	r2, #0
57e0740c:	e59f012c 	ldr	r0, [pc, #300]	; 57e07540 <do_env_export+0x244>
57e07410:	e1a01006 	mov	r1, r6
57e07414:	e28d303c 	add	r3, sp, #60	; 0x3c
57e07418:	e58d7000 	str	r7, [sp]
57e0741c:	e98d0030 	stmib	sp, {r4, r5}
57e07420:	eb006f20 	bl	57e230a8 <hexport_r>
		if (len < 0) {
57e07424:	e2502000 	subs	r2, r0, #0
57e07428:	aa000007 	bge	57e0744c <do_env_export+0x150>
			error("Cannot export environment: errno = %d\n", errno);
57e0742c:	e59f3110 	ldr	r3, [pc, #272]	; 57e07544 <do_env_export+0x248>
57e07430:	e59f0110 	ldr	r0, [pc, #272]	; 57e07548 <do_env_export+0x24c>
57e07434:	e58d3000 	str	r3, [sp]
57e07438:	e59f310c 	ldr	r3, [pc, #268]	; 57e0754c <do_env_export+0x250>
57e0743c:	e59f210c 	ldr	r2, [pc, #268]	; 57e07550 <do_env_export+0x254>
57e07440:	e5931000 	ldr	r1, [r3]
57e07444:	e59f3108 	ldr	r3, [pc, #264]	; 57e07554 <do_env_export+0x258>
57e07448:	ea00001a 	b	57e074b8 <do_env_export+0x1bc>
			return 1;
		}
		sprintf(buf, "%zX", (size_t)len);
57e0744c:	e28d4018 	add	r4, sp, #24
57e07450:	e1a00004 	mov	r0, r4
57e07454:	e59f10fc 	ldr	r1, [pc, #252]	; 57e07558 <do_env_export+0x25c>
57e07458:	ea000023 	b	57e074ec <do_env_export+0x1f0>
		setenv("filesize", buf);

		return 0;
	}

	envp = (env_t *)addr;
57e0745c:	e59d603c 	ldr	r6, [sp, #60]	; 0x3c

	if (chk)		/* export as checksum protected block */
57e07460:	e3590000 	cmp	r9, #0
		res = (char *)envp->data;
57e07464:	12863004 	addne	r3, r6, #4
	else			/* export as raw binary data */
		res = addr;

	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, argc, argv);
57e07468:	e3a01000 	mov	r1, #0
57e0746c:	e59f70e8 	ldr	r7, [pc, #232]	; 57e0755c <do_env_export+0x260>
	}

	envp = (env_t *)addr;

	if (chk)		/* export as checksum protected block */
		res = (char *)envp->data;
57e07470:	158d3038 	strne	r3, [sp, #56]	; 0x38
	else			/* export as raw binary data */
		res = addr;

	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, argc, argv);
57e07474:	e59f00c4 	ldr	r0, [pc, #196]	; 57e07540 <do_env_export+0x244>
57e07478:	e1a02001 	mov	r2, r1
57e0747c:	e28d3038 	add	r3, sp, #56	; 0x38
	envp = (env_t *)addr;

	if (chk)		/* export as checksum protected block */
		res = (char *)envp->data;
	else			/* export as raw binary data */
		res = addr;
57e07480:	058d6038 	streq	r6, [sp, #56]	; 0x38

	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, argc, argv);
57e07484:	e58d5008 	str	r5, [sp, #8]
57e07488:	e58d7000 	str	r7, [sp]
57e0748c:	e58d4004 	str	r4, [sp, #4]
57e07490:	eb006f04 	bl	57e230a8 <hexport_r>
	if (len < 0) {
57e07494:	e2505000 	subs	r5, r0, #0
57e07498:	aa000008 	bge	57e074c0 <do_env_export+0x1c4>
		error("Cannot export environment: errno = %d\n", errno);
57e0749c:	e59f30a0 	ldr	r3, [pc, #160]	; 57e07544 <do_env_export+0x248>
57e074a0:	e59f00a0 	ldr	r0, [pc, #160]	; 57e07548 <do_env_export+0x24c>
57e074a4:	e58d3000 	str	r3, [sp]
57e074a8:	e59f309c 	ldr	r3, [pc, #156]	; 57e0754c <do_env_export+0x250>
57e074ac:	e59f209c 	ldr	r2, [pc, #156]	; 57e07550 <do_env_export+0x254>
57e074b0:	e5931000 	ldr	r1, [r3]
57e074b4:	e3a03fdd 	mov	r3, #884	; 0x374
57e074b8:	eb0007e3 	bl	57e0944c <printf>
57e074bc:	ea000013 	b	57e07510 <do_env_export+0x214>
		return 1;
	}

	if (chk) {
57e074c0:	e3590000 	cmp	r9, #0
57e074c4:	0a000004 	beq	57e074dc <do_env_export+0x1e0>
		envp->crc = crc32(0, envp->data, ENV_SIZE);
57e074c8:	e3a00000 	mov	r0, #0
57e074cc:	e2861004 	add	r1, r6, #4
57e074d0:	e1a02007 	mov	r2, r7
57e074d4:	eb006b4d 	bl	57e22210 <crc32>
57e074d8:	e5860000 	str	r0, [r6]
#ifdef CONFIG_ENV_ADDR_REDUND
		envp->flags = ACTIVE_FLAG;
#endif
	}
	sprintf(buf, "%zX", (size_t)(len + offsetof(env_t, data)));
57e074dc:	e28d4018 	add	r4, sp, #24
57e074e0:	e59f1070 	ldr	r1, [pc, #112]	; 57e07558 <do_env_export+0x25c>
57e074e4:	e1a00004 	mov	r0, r4
57e074e8:	e2852004 	add	r2, r5, #4
57e074ec:	eb007795 	bl	57e25348 <sprintf>
	setenv("filesize", buf);
57e074f0:	e59f0068 	ldr	r0, [pc, #104]	; 57e07560 <do_env_export+0x264>
57e074f4:	e1a01004 	mov	r1, r4
57e074f8:	ebffff6c 	bl	57e072b0 <setenv>

	return 0;
57e074fc:	e3a00000 	mov	r0, #0
57e07500:	ea000005 	b	57e0751c <do_env_export+0x220>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
57e07504:	e59f0058 	ldr	r0, [pc, #88]	; 57e07564 <do_env_export+0x268>
57e07508:	e1a0100b 	mov	r1, fp
57e0750c:	eb0007ce 	bl	57e0944c <printf>
	return 1;
57e07510:	e3a00001 	mov	r0, #1
57e07514:	ea000000 	b	57e0751c <do_env_export+0x220>
		}
NXTARG:		;
	}

	if (argc < 1)
		return CMD_RET_USAGE;
57e07518:	e3e00000 	mvn	r0, #0
	return 0;

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
	return 1;
}
57e0751c:	e28dd040 	add	sp, sp, #64	; 0x40
57e07520:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
57e07524:	e3a01000 	mov	r1, #0
57e07528:	e3a02010 	mov	r2, #16
57e0752c:	eb0076dc 	bl	57e250a4 <simple_strtoul>

	if (size)
57e07530:	e3570000 	cmp	r7, #0
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
57e07534:	e58d003c 	str	r0, [sp, #60]	; 0x3c

	if (size)
57e07538:	0affffae 	beq	57e073f8 <do_env_export+0xfc>
57e0753c:	eaffffaa 	b	57e073ec <do_env_export+0xf0>
57e07540:	57e36dc4 	.word	0x57e36dc4
57e07544:	57e2bdb0 	.word	0x57e2bdb0
57e07548:	57e30fce 	.word	0x57e30fce
57e0754c:	57e79098 	.word	0x57e79098
57e07550:	57e30ecd 	.word	0x57e30ecd
57e07554:	00000362 	.word	0x00000362
57e07558:	57e3100b 	.word	0x57e3100b
57e0755c:	00003ffc 	.word	0x00003ffc
57e07560:	57e2ea14 	.word	0x57e2ea14
57e07564:	57e30eda 	.word	0x57e30eda

57e07568 <setenv_ulong>:
 * @param varname	Environmet variable to set
 * @param value		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_ulong(const char *varname, ulong value)
{
57e07568:	e92d4010 	push	{r4, lr}
57e0756c:	e1a04000 	mov	r4, r0
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);
57e07570:	e1a00001 	mov	r0, r1
57e07574:	eb007792 	bl	57e253c4 <simple_itoa>
57e07578:	e1a01000 	mov	r1, r0

	return setenv(varname, str);
57e0757c:	e1a00004 	mov	r0, r4
}
57e07580:	e8bd4010 	pop	{r4, lr}
int setenv_ulong(const char *varname, ulong value)
{
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);

	return setenv(varname, str);
57e07584:	eaffff49 	b	57e072b0 <setenv>

57e07588 <setenv_addr>:
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
57e07588:	e92d4030 	push	{r4, r5, lr}
57e0758c:	e24dd01c 	sub	sp, sp, #28
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
57e07590:	e28d4004 	add	r4, sp, #4
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
57e07594:	e1a05000 	mov	r5, r0
57e07598:	e1a02001 	mov	r2, r1
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
57e0759c:	e1a00004 	mov	r0, r4
57e075a0:	e59f1014 	ldr	r1, [pc, #20]	; 57e075bc <setenv_addr+0x34>
57e075a4:	eb007767 	bl	57e25348 <sprintf>
	return setenv(varname, str);
57e075a8:	e1a00005 	mov	r0, r5
57e075ac:	e1a01004 	mov	r1, r4
57e075b0:	ebffff3e 	bl	57e072b0 <setenv>
}
57e075b4:	e28dd01c 	add	sp, sp, #28
57e075b8:	e8bd8030 	pop	{r4, r5, pc}
57e075bc:	57e2e684 	.word	0x57e2e684

57e075c0 <envmatch>:
 * s1 is either a simple 'name', or a 'name=value' pair.
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
57e075c0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	if (s1 == NULL)
57e075c4:	e2506000 	subs	r6, r0, #0
 * s1 is either a simple 'name', or a 'name=value' pair.
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
57e075c8:	e1a05001 	mov	r5, r1
	if (s1 == NULL)
57e075cc:	1a000004 	bne	57e075e4 <envmatch+0x24>
57e075d0:	ea000012 	b	57e07620 <envmatch+0x60>
		return -1;

	while (*s1 == env_get_char(i2++))
		if (*s1++ == '=')
57e075d4:	e5563001 	ldrb	r3, [r6, #-1]
57e075d8:	e353003d 	cmp	r3, #61	; 0x3d
57e075dc:	0a000010 	beq	57e07624 <envmatch+0x64>
int envmatch(uchar *s1, int i2)
{
	if (s1 == NULL)
		return -1;

	while (*s1 == env_get_char(i2++))
57e075e0:	e1a05004 	mov	r5, r4
57e075e4:	e1a00005 	mov	r0, r5
		if (*s1++ == '=')
57e075e8:	e1a07006 	mov	r7, r6
int envmatch(uchar *s1, int i2)
{
	if (s1 == NULL)
		return -1;

	while (*s1 == env_get_char(i2++))
57e075ec:	e4d6a001 	ldrb	sl, [r6], #1
57e075f0:	eb000dd9 	bl	57e0ad5c <env_get_char>
57e075f4:	e15a0000 	cmp	sl, r0
57e075f8:	e2854001 	add	r4, r5, #1
57e075fc:	0afffff4 	beq	57e075d4 <envmatch+0x14>
		if (*s1++ == '=')
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
57e07600:	e5d73000 	ldrb	r3, [r7]
57e07604:	e3530000 	cmp	r3, #0
57e07608:	1a000004 	bne	57e07620 <envmatch+0x60>
57e0760c:	e1a00005 	mov	r0, r5
57e07610:	eb000dd1 	bl	57e0ad5c <env_get_char>
		return i2;

	return -1;
57e07614:	e350003d 	cmp	r0, #61	; 0x3d
57e07618:	13e04000 	mvnne	r4, #0
57e0761c:	ea000000 	b	57e07624 <envmatch+0x64>
57e07620:	e3e04000 	mvn	r4, #0
}
57e07624:	e1a00004 	mov	r0, r4
57e07628:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

57e0762c <getenv_f>:

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
57e0762c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e07630:	e1a05000 	mov	r5, r0
57e07634:	e1a06001 	mov	r6, r1
57e07638:	e1a0a002 	mov	sl, r2
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
57e0763c:	e3a0b000 	mov	fp, #0
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
57e07640:	e59f9098 	ldr	r9, [pc, #152]	; 57e076e0 <getenv_f+0xb4>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
57e07644:	ea00001d 	b	57e076c0 <getenv_f+0x94>
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
57e07648:	e1570009 	cmp	r7, r9
57e0764c:	ca000020 	bgt	57e076d4 <getenv_f+0xa8>
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
57e07650:	e2877001 	add	r7, r7, #1
57e07654:	e1a00007 	mov	r0, r7
57e07658:	eb000dbf 	bl	57e0ad5c <env_get_char>
57e0765c:	e2504000 	subs	r4, r0, #0
57e07660:	1afffff8 	bne	57e07648 <getenv_f+0x1c>
			if (nxt >= CONFIG_ENV_SIZE)
				return -1;
		}

		val = envmatch((uchar *)name, i);
57e07664:	e1a0100b 	mov	r1, fp
57e07668:	e1a00005 	mov	r0, r5
57e0766c:	ebffffd3 	bl	57e075c0 <envmatch>
		if (val < 0)
57e07670:	e250b000 	subs	fp, r0, #0
57e07674:	aa000006 	bge	57e07694 <getenv_f+0x68>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
57e07678:	e287b001 	add	fp, r7, #1
57e0767c:	ea00000f 	b	57e076c0 <getenv_f+0x94>
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
57e07680:	eb000db5 	bl	57e0ad5c <env_get_char>
			if (*buf == '\0')
57e07684:	e3500000 	cmp	r0, #0
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
57e07688:	e4c60001 	strb	r0, [r6], #1
			if (*buf == '\0')
57e0768c:	0a000011 	beq	57e076d8 <getenv_f+0xac>
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
57e07690:	e2844001 	add	r4, r4, #1
57e07694:	e154000a 	cmp	r4, sl
}

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
57e07698:	e084000b 	add	r0, r4, fp
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
57e0769c:	3afffff7 	bcc	57e07680 <getenv_f+0x54>
			*buf = env_get_char(val++);
			if (*buf == '\0')
				return n;
		}

		if (n)
57e076a0:	e3540000 	cmp	r4, #0
			*--buf = '\0';
57e076a4:	13a03000 	movne	r3, #0
57e076a8:	15463001 	strbne	r3, [r6, #-1]

		printf("env_buf [%d bytes] too small for value of \"%s\"\n",
57e076ac:	e1a0100a 	mov	r1, sl
57e076b0:	e1a02005 	mov	r2, r5
57e076b4:	e59f0028 	ldr	r0, [pc, #40]	; 57e076e4 <getenv_f+0xb8>
57e076b8:	eb000763 	bl	57e0944c <printf>
			len, name);

		return n;
57e076bc:	ea000005 	b	57e076d8 <getenv_f+0xac>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
57e076c0:	e1a0000b 	mov	r0, fp
57e076c4:	eb000da4 	bl	57e0ad5c <env_get_char>
57e076c8:	e3500000 	cmp	r0, #0
57e076cc:	11a0700b 	movne	r7, fp
57e076d0:	1affffdf 	bne	57e07654 <getenv_f+0x28>
			len, name);

		return n;
	}

	return -1;
57e076d4:	e3e04000 	mvn	r4, #0
}
57e076d8:	e1a00004 	mov	r0, r4
57e076dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e076e0:	00003fff 	.word	0x00003fff
57e076e4:	57e3100f 	.word	0x57e3100f

57e076e8 <getenv>:
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
57e076e8:	e92d4010 	push	{r4, lr}
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
57e076ec:	e5984004 	ldr	r4, [r8, #4]
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
57e076f0:	e24dd028 	sub	sp, sp, #40	; 0x28
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
57e076f4:	e2144080 	ands	r4, r4, #128	; 0x80
57e076f8:	0a00000f 	beq	57e0773c <getenv+0x54>

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
		hsearch_r(e, FIND, &ep, &env_htab, 0);
57e076fc:	e28d2024 	add	r2, sp, #36	; 0x24
57e07700:	e58d2004 	str	r2, [sp, #4]
57e07704:	e59f2050 	ldr	r2, [pc, #80]	; 57e0775c <getenv+0x74>
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
57e07708:	e3a03000 	mov	r3, #0
57e0770c:	e58d3018 	str	r3, [sp, #24]
		hsearch_r(e, FIND, &ep, &env_htab, 0);
57e07710:	e58d3000 	str	r3, [sp]
57e07714:	e58d300c 	str	r3, [sp, #12]
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
57e07718:	e58d0014 	str	r0, [sp, #20]
		e.data	= NULL;
		hsearch_r(e, FIND, &ep, &env_htab, 0);
57e0771c:	e58d2008 	str	r2, [sp, #8]
57e07720:	e28d3014 	add	r3, sp, #20
57e07724:	e893000f 	ldm	r3, {r0, r1, r2, r3}
57e07728:	eb006cde 	bl	57e22aa8 <hsearch_r>

		return ep ? ep->data : NULL;
57e0772c:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
57e07730:	e3500000 	cmp	r0, #0
57e07734:	15900004 	ldrne	r0, [r0, #4]
57e07738:	ea000005 	b	57e07754 <getenv+0x6c>
	}

	/* restricted capabilities before import */
	if (getenv_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)
57e0773c:	e2881058 	add	r1, r8, #88	; 0x58
57e07740:	e3a02020 	mov	r2, #32
57e07744:	ebffffb8 	bl	57e0762c <getenv_f>
57e07748:	e3500000 	cmp	r0, #0
		return (char *)(gd->env_buf);
57e0774c:	c2880058 	addgt	r0, r8, #88	; 0x58

	return NULL;
57e07750:	d1a00004 	movle	r0, r4
}
57e07754:	e28dd028 	add	sp, sp, #40	; 0x28
57e07758:	e8bd8010 	pop	{r4, pc}
57e0775c:	57e36dc4 	.word	0x57e36dc4

57e07760 <do_env_edit>:
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
static int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
57e07760:	e92d4030 	push	{r4, r5, lr}
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
57e07764:	e3520001 	cmp	r2, #1
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
static int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc,
		       char * const argv[])
{
57e07768:	e24ddf41 	sub	sp, sp, #260	; 0x104
57e0776c:	e1a05003 	mov	r5, r3
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
		return CMD_RET_USAGE;
57e07770:	d3e00000 	mvnle	r0, #0
		       char * const argv[])
{
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
57e07774:	da00000f 	ble	57e077b8 <do_env_edit+0x58>
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
57e07778:	e5930004 	ldr	r0, [r3, #4]
57e0777c:	ebffffd9 	bl	57e076e8 <getenv>
	if (init_val)
57e07780:	e2502000 	subs	r2, r0, #0
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';
57e07784:	05cd2000 	strbeq	r2, [sp]
	if (argc < 2)
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
	if (init_val)
57e07788:	0a000002 	beq	57e07798 <do_env_edit+0x38>
		sprintf(buffer, "%s", init_val);
57e0778c:	e1a0000d 	mov	r0, sp
57e07790:	e59f1028 	ldr	r1, [pc, #40]	; 57e077c0 <do_env_edit+0x60>
57e07794:	eb0076eb 	bl	57e25348 <sprintf>
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
57e07798:	e1a0100d 	mov	r1, sp
57e0779c:	e59f0020 	ldr	r0, [pc, #32]	; 57e077c4 <do_env_edit+0x64>
57e077a0:	e3a02000 	mov	r2, #0
57e077a4:	eb001c6f 	bl	57e0e968 <readline_into_buffer>

	return setenv(argv[1], buffer);
57e077a8:	e5950004 	ldr	r0, [r5, #4]
57e077ac:	e1a0100d 	mov	r1, sp
	if (init_val)
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
57e077b0:	e1a0400d 	mov	r4, sp

	return setenv(argv[1], buffer);
57e077b4:	ebfffebd 	bl	57e072b0 <setenv>
}
57e077b8:	e28ddf41 	add	sp, sp, #260	; 0x104
57e077bc:	e8bd8030 	pop	{r4, r5, pc}
57e077c0:	57e308f5 	.word	0x57e308f5
57e077c4:	57e3103f 	.word	0x57e3103f

57e077c8 <getenv_ulong>:
 * @param default_val	Default value to return if the variable is not
 *			found
 * @return the decoded value, or default_val if not found
 */
ulong getenv_ulong(const char *name, int base, ulong default_val)
{
57e077c8:	e92d4070 	push	{r4, r5, r6, lr}
57e077cc:	e1a04001 	mov	r4, r1
57e077d0:	e1a05002 	mov	r5, r2
	/*
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);
57e077d4:	ebffffc3 	bl	57e076e8 <getenv>

	return str ? simple_strtoul(str, NULL, base) : default_val;
57e077d8:	e3500000 	cmp	r0, #0
57e077dc:	0a000003 	beq	57e077f0 <getenv_ulong+0x28>
57e077e0:	e3a01000 	mov	r1, #0
57e077e4:	e1a02004 	mov	r2, r4
}
57e077e8:	e8bd4070 	pop	{r4, r5, r6, lr}
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);

	return str ? simple_strtoul(str, NULL, base) : default_val;
57e077ec:	ea00762c 	b	57e250a4 <simple_strtoul>
}
57e077f0:	e1a00005 	mov	r0, r5
57e077f4:	e8bd8070 	pop	{r4, r5, r6, pc}

57e077f8 <do_reginfo>:
# endif

#endif /* CONFIG_BLACKFIN */

	return 0;
}
57e077f8:	e3a00000 	mov	r0, #0
57e077fc:	e12fff1e 	bx	lr

57e07800 <source>:
#include <mpc8xx.h>
#endif

int
source (ulong addr, const char *fit_uname)
{
57e07800:	e92d4070 	push	{r4, r5, r6, lr}
57e07804:	e1a04000 	mov	r4, r0
	int		noffset;
	const void	*fit_data;
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");
57e07808:	e59f00d0 	ldr	r0, [pc, #208]	; 57e078e0 <source+0xe0>
57e0780c:	eb000d5f 	bl	57e0ad90 <getenv_yesno>
57e07810:	e1a05000 	mov	r5, r0

	switch (genimg_get_format ((void *)addr)) {
57e07814:	e1a00004 	mov	r0, r4
57e07818:	eb001aed 	bl	57e0e3d4 <genimg_get_format>
57e0781c:	e3500001 	cmp	r0, #1
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
57e07820:	159f00bc 	ldrne	r0, [pc, #188]	; 57e078e4 <source+0xe4>
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");

	switch (genimg_get_format ((void *)addr)) {
57e07824:	1a000028 	bne	57e078cc <source+0xcc>
	"unit name in the form of addr:<subimg_uname>"
#endif
	"";
#endif

U_BOOT_CMD(
57e07828:	e5943000 	ldr	r3, [r4]
57e0782c:	e1a02c03 	lsl	r2, r3, #24
57e07830:	e1822c23 	orr	r2, r2, r3, lsr #24
57e07834:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e07838:	e1822401 	orr	r2, r2, r1, lsl #8
57e0783c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e07840:	e1823423 	orr	r3, r2, r3, lsr #8

	switch (genimg_get_format ((void *)addr)) {
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
57e07844:	e59f209c 	ldr	r2, [pc, #156]	; 57e078e8 <source+0xe8>
57e07848:	e1530002 	cmp	r3, r2
			puts ("Bad magic number\n");
57e0784c:	159f0098 	ldrne	r0, [pc, #152]	; 57e078ec <source+0xec>

	switch (genimg_get_format ((void *)addr)) {
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
57e07850:	1a00001d 	bne	57e078cc <source+0xcc>
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
57e07854:	e1a00004 	mov	r0, r4
57e07858:	eb001984 	bl	57e0de70 <image_check_hcrc>
57e0785c:	e3500000 	cmp	r0, #0
			puts ("Bad header crc\n");
57e07860:	059f0088 	ldreq	r0, [pc, #136]	; 57e078f0 <source+0xf0>
		if (!image_check_magic (hdr)) {
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
57e07864:	0a000018 	beq	57e078cc <source+0xcc>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
57e07868:	e3550000 	cmp	r5, #0
57e0786c:	0a000004 	beq	57e07884 <source+0x84>
			if (!image_check_dcrc (hdr)) {
57e07870:	e1a00004 	mov	r0, r4
57e07874:	eb001996 	bl	57e0ded4 <image_check_dcrc>
57e07878:	e3500000 	cmp	r0, #0
				puts ("Bad data crc\n");
57e0787c:	059f0070 	ldreq	r0, [pc, #112]	; 57e078f4 <source+0xf4>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
			if (!image_check_dcrc (hdr)) {
57e07880:	0a000011 	beq	57e078cc <source+0xcc>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
57e07884:	e5d4301e 	ldrb	r3, [r4, #30]
57e07888:	e3530006 	cmp	r3, #6
			puts ("Bad image type\n");
57e0788c:	159f0064 	ldrne	r0, [pc, #100]	; 57e078f8 <source+0xf8>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
57e07890:	1a00000d 	bne	57e078cc <source+0xcc>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
57e07894:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
57e07898:	e2840040 	add	r0, r4, #64	; 0x40
57e0789c:	e1a01c03 	lsl	r1, r3, #24
57e078a0:	e1811c23 	orr	r1, r1, r3, lsr #24
57e078a4:	e2032cff 	and	r2, r3, #65280	; 0xff00
57e078a8:	e1811402 	orr	r1, r1, r2, lsl #8
57e078ac:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e078b0:	e1911423 	orrs	r1, r1, r3, lsr #8
			puts ("Empty Script\n");
57e078b4:	059f0040 	ldreq	r0, [pc, #64]	; 57e078fc <source+0xfc>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
57e078b8:	0a000003 	beq	57e078cc <source+0xcc>
		/*
		 * scripts are just multi-image files with one component, seek
		 * past the zero-terminated sequence of image lengths to get
		 * to the actual image data
		 */
		while (*data++);
57e078bc:	e4902004 	ldr	r2, [r0], #4
57e078c0:	e3520000 	cmp	r2, #0
57e078c4:	1afffffc 	bne	57e078bc <source+0xbc>
57e078c8:	ea000002 	b	57e078d8 <source+0xd8>
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
57e078cc:	eb0006d4 	bl	57e09424 <puts>
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
}
57e078d0:	e3a00001 	mov	r0, #1
57e078d4:	e8bd8070 	pop	{r4, r5, r6, pc}
57e078d8:	e8bd4070 	pop	{r4, r5, r6, lr}
		puts ("Wrong image format for \"source\" command\n");
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
57e078dc:	ea001e97 	b	57e0f340 <run_command_list>
57e078e0:	57e2e7b9 	.word	0x57e2e7b9
57e078e4:	57e31351 	.word	0x57e31351
57e078e8:	27051956 	.word	0x27051956
57e078ec:	57e31303 	.word	0x57e31303
57e078f0:	57e31315 	.word	0x57e31315
57e078f4:	57e31325 	.word	0x57e31325
57e078f8:	57e31333 	.word	0x57e31333
57e078fc:	57e31343 	.word	0x57e31343

57e07900 <do_source>:
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
57e07900:	e3520001 	cmp	r2, #1

/**************************************************/
#if defined(CONFIG_CMD_SOURCE)
int
do_source (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e07904:	e92d4010 	push	{r4, lr}
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
		addr = CONFIG_SYS_LOAD_ADDR;
57e07908:	d3a04205 	movle	r4, #1342177280	; 0x50000000
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
57e0790c:	da000004 	ble	57e07924 <do_source+0x24>
	} else if (fit_parse_subimage (argv[1], load_addr, &addr, &fit_uname)) {
		debug ("*  source: subimage '%s' from FIT image at 0x%08lx\n",
				fit_uname, addr);
#endif
	} else {
		addr = simple_strtoul(argv[1], NULL, 16);
57e07910:	e5930004 	ldr	r0, [r3, #4]
57e07914:	e3a01000 	mov	r1, #0
57e07918:	e3a02010 	mov	r2, #16
57e0791c:	eb0075e0 	bl	57e250a4 <simple_strtoul>
57e07920:	e1a04000 	mov	r4, r0
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
57e07924:	e1a01004 	mov	r1, r4
57e07928:	e59f0010 	ldr	r0, [pc, #16]	; 57e07940 <do_source+0x40>
57e0792c:	eb0006c6 	bl	57e0944c <printf>
	rcode = source (addr, fit_uname);
57e07930:	e1a00004 	mov	r0, r4
57e07934:	e3a01000 	mov	r1, #0
	return rcode;
}
57e07938:	e8bd4010 	pop	{r4, lr}
		addr = simple_strtoul(argv[1], NULL, 16);
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
	rcode = source (addr, fit_uname);
57e0793c:	eaffffaf 	b	57e07800 <source>
57e07940:	57e3137a 	.word	0x57e3137a

57e07944 <do_false>:
);

static int do_false(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 1;
}
57e07944:	e3a00001 	mov	r0, #1
57e07948:	e12fff1e 	bx	lr

57e0794c <do_true>:
);

static int do_true(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 0;
}
57e0794c:	e3a00000 	mov	r0, #0
57e07950:	e12fff1e 	bx	lr

57e07954 <do_test>:
{
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
57e07954:	e3520002 	cmp	r2, #2

#include <common.h>
#include <command.h>

static int do_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e07958:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
57e0795c:	da0000fd 	ble	57e07d58 <do_test+0x404>
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
57e07960:	e5930004 	ldr	r0, [r3, #4]
57e07964:	e59f141c 	ldr	r1, [pc, #1052]	; 57e07d88 <do_test+0x434>
			debug(" '%s'", argv[left++]);
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
57e07968:	e2426001 	sub	r6, r2, #1
57e0796c:	e2834004 	add	r4, r3, #4
	if (left > 0 && strcmp(ap[0], "!") == 0) {
57e07970:	eb00718b 	bl	57e23fa4 <strcmp>
		left--;
	} else
		neg = 0;

	expr = -1;
	last_cmp = -1;
57e07974:	e3e05000 	mvn	r5, #0
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
57e07978:	e3500000 	cmp	r0, #0
		neg = 1;
		ap++;
57e0797c:	02844004 	addeq	r4, r4, #4
		left--;
57e07980:	02466001 	subeq	r6, r6, #1
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
		neg = 1;
57e07984:	03a0b001 	moveq	fp, #1
		ap++;
		left--;
	} else
		neg = 0;
57e07988:	13a0b000 	movne	fp, #0

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
57e0798c:	e1a07005 	mov	r7, r5
		ap++;
		left--;
	} else
		neg = 0;

	expr = -1;
57e07990:	e1a0a005 	mov	sl, r5
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
57e07994:	e5940000 	ldr	r0, [r4]
57e07998:	e59f13ec 	ldr	r1, [pc, #1004]	; 57e07d8c <do_test+0x438>
57e0799c:	eb007180 	bl	57e23fa4 <strcmp>
57e079a0:	e3500000 	cmp	r0, #0
57e079a4:	0a0000ed 	beq	57e07d60 <do_test+0x40c>
57e079a8:	e5940000 	ldr	r0, [r4]
57e079ac:	e59f13dc 	ldr	r1, [pc, #988]	; 57e07d90 <do_test+0x43c>
57e079b0:	eb00717b 	bl	57e23fa4 <strcmp>
57e079b4:	e3500000 	cmp	r0, #0
57e079b8:	0a0000e8 	beq	57e07d60 <do_test+0x40c>
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
57e079bc:	e5940000 	ldr	r0, [r4]
57e079c0:	e59f13cc 	ldr	r1, [pc, #972]	; 57e07d94 <do_test+0x440>
57e079c4:	eb007176 	bl	57e23fa4 <strcmp>
57e079c8:	e3500000 	cmp	r0, #0
			adv = 2;
57e079cc:	03a09002 	moveq	r9, #2
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
57e079d0:	0a000005 	beq	57e079ec <do_test+0x98>
57e079d4:	e5940000 	ldr	r0, [r4]
57e079d8:	e59f13b8 	ldr	r1, [pc, #952]	; 57e07d98 <do_test+0x444>
57e079dc:	eb007170 	bl	57e23fa4 <strcmp>
			adv = 2;
		else
			adv = 3;
57e079e0:	e3500000 	cmp	r0, #0
57e079e4:	03a09002 	moveq	r9, #2
57e079e8:	13a09003 	movne	r9, #3

		if (left < adv) {
57e079ec:	e1560009 	cmp	r6, r9
57e079f0:	aa000006 	bge	57e07a10 <do_test+0xbc>
57e079f4:	ea0000cf 	b	57e07d38 <do_test+0x3e4>

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
57e079f8:	e5940000 	ldr	r0, [r4]
57e079fc:	e59f138c 	ldr	r1, [pc, #908]	; 57e07d90 <do_test+0x43c>
57e07a00:	eb007167 	bl	57e23fa4 <strcmp>
57e07a04:	e3500000 	cmp	r0, #0
57e07a08:	0a0000da 	beq	57e07d78 <do_test+0x424>
57e07a0c:	ea0000c9 	b	57e07d38 <do_test+0x3e4>
				expr = 1;
				break;
			}
		}

		if (adv == 2) {
57e07a10:	e3590002 	cmp	r9, #2
57e07a14:	1a00001e 	bne	57e07a94 <do_test+0x140>
			if (strcmp(ap[0], "-z") == 0)
57e07a18:	e5940000 	ldr	r0, [r4]
57e07a1c:	e59f1370 	ldr	r1, [pc, #880]	; 57e07d94 <do_test+0x440>
57e07a20:	eb00715f 	bl	57e23fa4 <strcmp>
57e07a24:	e3500000 	cmp	r0, #0
57e07a28:	1a000004 	bne	57e07a40 <do_test+0xec>
				expr = strlen(ap[1]) == 0 ? 1 : 0;
57e07a2c:	e5940004 	ldr	r0, [r4, #4]
57e07a30:	eb007186 	bl	57e24050 <strlen>
57e07a34:	e270a001 	rsbs	sl, r0, #1
57e07a38:	33a0a000 	movcc	sl, #0
57e07a3c:	ea000008 	b	57e07a64 <do_test+0x110>
			else if (strcmp(ap[0], "-n") == 0)
57e07a40:	e5940000 	ldr	r0, [r4]
57e07a44:	e59f134c 	ldr	r1, [pc, #844]	; 57e07d98 <do_test+0x444>
57e07a48:	eb007155 	bl	57e23fa4 <strcmp>
57e07a4c:	e3500000 	cmp	r0, #0
57e07a50:	1a0000b8 	bne	57e07d38 <do_test+0x3e4>
				expr = strlen(ap[1]) == 0 ? 0 : 1;
57e07a54:	e5940004 	ldr	r0, [r4, #4]
57e07a58:	eb00717c 	bl	57e24050 <strlen>
57e07a5c:	e250a000 	subs	sl, r0, #0
57e07a60:	13a0a001 	movne	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
57e07a64:	e3550000 	cmp	r5, #0
57e07a68:	1a000003 	bne	57e07a7c <do_test+0x128>
				expr = last_expr || expr;
57e07a6c:	e19aa007 	orrs	sl, sl, r7
57e07a70:	03a0a000 	moveq	sl, #0
57e07a74:	13a0a001 	movne	sl, #1
57e07a78:	ea0000a8 	b	57e07d20 <do_test+0x3cc>
			else if (last_cmp == 1)
57e07a7c:	e3550001 	cmp	r5, #1
57e07a80:	1a0000a6 	bne	57e07d20 <do_test+0x3cc>
				expr = last_expr && expr;
57e07a84:	e3570000 	cmp	r7, #0
57e07a88:	03a0a000 	moveq	sl, #0
57e07a8c:	120aa001 	andne	sl, sl, #1
57e07a90:	ea0000a2 	b	57e07d20 <do_test+0x3cc>
			last_cmp = -1;
		}

		if (adv == 3) {
			if (strcmp(ap[1], "=") == 0)
57e07a94:	e5940004 	ldr	r0, [r4, #4]
57e07a98:	e59f12fc 	ldr	r1, [pc, #764]	; 57e07d9c <do_test+0x448>
57e07a9c:	eb007140 	bl	57e23fa4 <strcmp>
57e07aa0:	e3500000 	cmp	r0, #0
57e07aa4:	e284a004 	add	sl, r4, #4
57e07aa8:	1a000005 	bne	57e07ac4 <do_test+0x170>
				expr = strcmp(ap[0], ap[2]) == 0;
57e07aac:	e5940000 	ldr	r0, [r4]
57e07ab0:	e5941008 	ldr	r1, [r4, #8]
57e07ab4:	eb00713a 	bl	57e23fa4 <strcmp>
57e07ab8:	e270a001 	rsbs	sl, r0, #1
57e07abc:	33a0a000 	movcc	sl, #0
57e07ac0:	ea00008a 	b	57e07cf0 <do_test+0x39c>
			else if (strcmp(ap[1], "!=") == 0)
57e07ac4:	e5940004 	ldr	r0, [r4, #4]
57e07ac8:	e59f12d0 	ldr	r1, [pc, #720]	; 57e07da0 <do_test+0x44c>
57e07acc:	eb007134 	bl	57e23fa4 <strcmp>
57e07ad0:	e3500000 	cmp	r0, #0
57e07ad4:	1a000005 	bne	57e07af0 <do_test+0x19c>
				expr = strcmp(ap[0], ap[2]) != 0;
57e07ad8:	e5940000 	ldr	r0, [r4]
57e07adc:	e5941008 	ldr	r1, [r4, #8]
57e07ae0:	eb00712f 	bl	57e23fa4 <strcmp>
57e07ae4:	e250a000 	subs	sl, r0, #0
57e07ae8:	13a0a001 	movne	sl, #1
57e07aec:	ea00007f 	b	57e07cf0 <do_test+0x39c>
			else if (strcmp(ap[1], ">") == 0)
57e07af0:	e59a0000 	ldr	r0, [sl]
57e07af4:	e59f12a8 	ldr	r1, [pc, #680]	; 57e07da4 <do_test+0x450>
57e07af8:	eb007129 	bl	57e23fa4 <strcmp>
57e07afc:	e3500000 	cmp	r0, #0
57e07b00:	1a000006 	bne	57e07b20 <do_test+0x1cc>
				expr = strcmp(ap[0], ap[2]) > 0;
57e07b04:	e5940000 	ldr	r0, [r4]
57e07b08:	e5941008 	ldr	r1, [r4, #8]
57e07b0c:	eb007124 	bl	57e23fa4 <strcmp>
57e07b10:	e3500000 	cmp	r0, #0
57e07b14:	d3a0a000 	movle	sl, #0
57e07b18:	c3a0a001 	movgt	sl, #1
57e07b1c:	ea000073 	b	57e07cf0 <do_test+0x39c>
			else if (strcmp(ap[1], "<") == 0)
57e07b20:	e59a0000 	ldr	r0, [sl]
57e07b24:	e59f127c 	ldr	r1, [pc, #636]	; 57e07da8 <do_test+0x454>
57e07b28:	eb00711d 	bl	57e23fa4 <strcmp>
57e07b2c:	e3500000 	cmp	r0, #0
57e07b30:	1a000004 	bne	57e07b48 <do_test+0x1f4>
				expr = strcmp(ap[0], ap[2]) < 0;
57e07b34:	e5940000 	ldr	r0, [r4]
57e07b38:	e5941008 	ldr	r1, [r4, #8]
57e07b3c:	eb007118 	bl	57e23fa4 <strcmp>
57e07b40:	e1a0afa0 	lsr	sl, r0, #31
57e07b44:	ea000069 	b	57e07cf0 <do_test+0x39c>
			else if (strcmp(ap[1], "-eq") == 0)
57e07b48:	e59a0000 	ldr	r0, [sl]
57e07b4c:	e59f1258 	ldr	r1, [pc, #600]	; 57e07dac <do_test+0x458>
57e07b50:	eb007113 	bl	57e23fa4 <strcmp>
57e07b54:	e2509000 	subs	r9, r0, #0
57e07b58:	1a00000c 	bne	57e07b90 <do_test+0x23c>
				expr = simple_strtol(ap[0], NULL, 10) == simple_strtol(ap[2], NULL, 10);
57e07b5c:	e1a01009 	mov	r1, r9
57e07b60:	e3a0200a 	mov	r2, #10
57e07b64:	e5940000 	ldr	r0, [r4]
57e07b68:	eb007596 	bl	57e251c8 <simple_strtol>
57e07b6c:	e1a01009 	mov	r1, r9
57e07b70:	e1a0a000 	mov	sl, r0
57e07b74:	e3a0200a 	mov	r2, #10
57e07b78:	e5940008 	ldr	r0, [r4, #8]
57e07b7c:	eb007591 	bl	57e251c8 <simple_strtol>
57e07b80:	e15a0000 	cmp	sl, r0
57e07b84:	13a0a000 	movne	sl, #0
57e07b88:	03a0a001 	moveq	sl, #1
57e07b8c:	ea000057 	b	57e07cf0 <do_test+0x39c>
			else if (strcmp(ap[1], "-ne") == 0)
57e07b90:	e59a0000 	ldr	r0, [sl]
57e07b94:	e59f1214 	ldr	r1, [pc, #532]	; 57e07db0 <do_test+0x45c>
57e07b98:	eb007101 	bl	57e23fa4 <strcmp>
57e07b9c:	e2509000 	subs	r9, r0, #0
57e07ba0:	1a00000b 	bne	57e07bd4 <do_test+0x280>
				expr = simple_strtol(ap[0], NULL, 10) != simple_strtol(ap[2], NULL, 10);
57e07ba4:	e1a01009 	mov	r1, r9
57e07ba8:	e3a0200a 	mov	r2, #10
57e07bac:	e5940000 	ldr	r0, [r4]
57e07bb0:	eb007584 	bl	57e251c8 <simple_strtol>
57e07bb4:	e1a01009 	mov	r1, r9
57e07bb8:	e1a0a000 	mov	sl, r0
57e07bbc:	e3a0200a 	mov	r2, #10
57e07bc0:	e5940008 	ldr	r0, [r4, #8]
57e07bc4:	eb00757f 	bl	57e251c8 <simple_strtol>
57e07bc8:	e05aa000 	subs	sl, sl, r0
57e07bcc:	13a0a001 	movne	sl, #1
57e07bd0:	ea000046 	b	57e07cf0 <do_test+0x39c>
			else if (strcmp(ap[1], "-lt") == 0)
57e07bd4:	e59a0000 	ldr	r0, [sl]
57e07bd8:	e59f11d4 	ldr	r1, [pc, #468]	; 57e07db4 <do_test+0x460>
57e07bdc:	eb0070f0 	bl	57e23fa4 <strcmp>
57e07be0:	e2509000 	subs	r9, r0, #0
57e07be4:	1a00000c 	bne	57e07c1c <do_test+0x2c8>
				expr = simple_strtol(ap[0], NULL, 10) < simple_strtol(ap[2], NULL, 10);
57e07be8:	e1a01009 	mov	r1, r9
57e07bec:	e3a0200a 	mov	r2, #10
57e07bf0:	e5940000 	ldr	r0, [r4]
57e07bf4:	eb007573 	bl	57e251c8 <simple_strtol>
57e07bf8:	e1a01009 	mov	r1, r9
57e07bfc:	e1a0a000 	mov	sl, r0
57e07c00:	e3a0200a 	mov	r2, #10
57e07c04:	e5940008 	ldr	r0, [r4, #8]
57e07c08:	eb00756e 	bl	57e251c8 <simple_strtol>
57e07c0c:	e15a0000 	cmp	sl, r0
57e07c10:	a3a0a000 	movge	sl, #0
57e07c14:	b3a0a001 	movlt	sl, #1
57e07c18:	ea000034 	b	57e07cf0 <do_test+0x39c>
			else if (strcmp(ap[1], "-le") == 0)
57e07c1c:	e59a0000 	ldr	r0, [sl]
57e07c20:	e59f1190 	ldr	r1, [pc, #400]	; 57e07db8 <do_test+0x464>
57e07c24:	eb0070de 	bl	57e23fa4 <strcmp>
57e07c28:	e3500000 	cmp	r0, #0
57e07c2c:	1a00000c 	bne	57e07c64 <do_test+0x310>
				expr = simple_strtol(ap[0], NULL, 10) <= simple_strtol(ap[2], NULL, 10);
57e07c30:	e3a01000 	mov	r1, #0
57e07c34:	e3a0200a 	mov	r2, #10
57e07c38:	e5940000 	ldr	r0, [r4]
57e07c3c:	eb007561 	bl	57e251c8 <simple_strtol>
57e07c40:	e3a01000 	mov	r1, #0
57e07c44:	e1a0a000 	mov	sl, r0
57e07c48:	e3a0200a 	mov	r2, #10
57e07c4c:	e5940008 	ldr	r0, [r4, #8]
57e07c50:	eb00755c 	bl	57e251c8 <simple_strtol>
57e07c54:	e15a0000 	cmp	sl, r0
57e07c58:	c3a0a000 	movgt	sl, #0
57e07c5c:	d3a0a001 	movle	sl, #1
57e07c60:	ea000022 	b	57e07cf0 <do_test+0x39c>
			else if (strcmp(ap[1], "-gt") == 0)
57e07c64:	e59a0000 	ldr	r0, [sl]
57e07c68:	e59f114c 	ldr	r1, [pc, #332]	; 57e07dbc <do_test+0x468>
57e07c6c:	eb0070cc 	bl	57e23fa4 <strcmp>
57e07c70:	e2509000 	subs	r9, r0, #0
57e07c74:	1a00000c 	bne	57e07cac <do_test+0x358>
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
57e07c78:	e1a01009 	mov	r1, r9
57e07c7c:	e3a0200a 	mov	r2, #10
57e07c80:	e5940000 	ldr	r0, [r4]
57e07c84:	eb00754f 	bl	57e251c8 <simple_strtol>
57e07c88:	e1a01009 	mov	r1, r9
57e07c8c:	e1a0a000 	mov	sl, r0
57e07c90:	e3a0200a 	mov	r2, #10
57e07c94:	e5940008 	ldr	r0, [r4, #8]
57e07c98:	eb00754a 	bl	57e251c8 <simple_strtol>
57e07c9c:	e15a0000 	cmp	sl, r0
57e07ca0:	d3a0a000 	movle	sl, #0
57e07ca4:	c3a0a001 	movgt	sl, #1
57e07ca8:	ea000010 	b	57e07cf0 <do_test+0x39c>
			else if (strcmp(ap[1], "-ge") == 0)
57e07cac:	e59a0000 	ldr	r0, [sl]
57e07cb0:	e59f1108 	ldr	r1, [pc, #264]	; 57e07dc0 <do_test+0x46c>
57e07cb4:	eb0070ba 	bl	57e23fa4 <strcmp>
57e07cb8:	e2509000 	subs	r9, r0, #0
57e07cbc:	1a00001d 	bne	57e07d38 <do_test+0x3e4>
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
57e07cc0:	e1a01009 	mov	r1, r9
57e07cc4:	e3a0200a 	mov	r2, #10
57e07cc8:	e5940000 	ldr	r0, [r4]
57e07ccc:	eb00753d 	bl	57e251c8 <simple_strtol>
57e07cd0:	e1a01009 	mov	r1, r9
57e07cd4:	e1a0a000 	mov	sl, r0
57e07cd8:	e3a0200a 	mov	r2, #10
57e07cdc:	e5940008 	ldr	r0, [r4, #8]
57e07ce0:	eb007538 	bl	57e251c8 <simple_strtol>
57e07ce4:	e15a0000 	cmp	sl, r0
57e07ce8:	b3a0a000 	movlt	sl, #0
57e07cec:	a3a0a001 	movge	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
57e07cf0:	e3550000 	cmp	r5, #0
57e07cf4:	1a000003 	bne	57e07d08 <do_test+0x3b4>
				expr = last_expr || expr;
57e07cf8:	e19aa007 	orrs	sl, sl, r7
57e07cfc:	03a0a000 	moveq	sl, #0
57e07d00:	13a0a001 	movne	sl, #1
57e07d04:	ea000004 	b	57e07d1c <do_test+0x3c8>
			else if (last_cmp == 1)
57e07d08:	e3550001 	cmp	r5, #1
57e07d0c:	1a000002 	bne	57e07d1c <do_test+0x3c8>
				expr = last_expr && expr;
57e07d10:	e3570000 	cmp	r7, #0
57e07d14:	03a0a000 	moveq	sl, #0
57e07d18:	120aa001 	andne	sl, sl, #1
				break;
			}

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
57e07d1c:	e3a09003 	mov	r9, #3
				expr = last_expr && expr;
			last_cmp = -1;
57e07d20:	e3e05000 	mvn	r5, #0
		}

		ap += adv; left -= adv;
57e07d24:	e0696006 	rsb	r6, r9, r6
		neg = 0;

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {
57e07d28:	e3560000 	cmp	r6, #0
57e07d2c:	da000002 	ble	57e07d3c <do_test+0x3e8>
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
		}

		ap += adv; left -= adv;
57e07d30:	e0844109 	add	r4, r4, r9, lsl #2
57e07d34:	eaffff16 	b	57e07994 <do_test+0x40>
			else if (strcmp(ap[1], "-gt") == 0)
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-ge") == 0)
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
			else {
				expr = 1;
57e07d38:	e3a0a001 	mov	sl, #1
		}

		ap += adv; left -= adv;
	}

	if (neg)
57e07d3c:	e35b0000 	cmp	fp, #0
57e07d40:	0a000001 	beq	57e07d4c <do_test+0x3f8>
		expr = !expr;
57e07d44:	e27aa001 	rsbs	sl, sl, #1
57e07d48:	33a0a000 	movcc	sl, #0

	expr = !expr;
57e07d4c:	e27a0001 	rsbs	r0, sl, #1
57e07d50:	33a00000 	movcc	r0, #0

	debug (": returns %d\n", expr);

	return expr;
57e07d54:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
		return 1;
57e07d58:	e3a00001 	mov	r0, #1
	expr = !expr;

	debug (": returns %d\n", expr);

	return expr;
}
57e07d5c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			expr = 1;
			break;
		}

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
57e07d60:	e5940000 	ldr	r0, [r4]
57e07d64:	e59f1020 	ldr	r1, [pc, #32]	; 57e07d8c <do_test+0x438>
57e07d68:	eb00708d 	bl	57e23fa4 <strcmp>
57e07d6c:	e2505000 	subs	r5, r0, #0
57e07d70:	0a000001 	beq	57e07d7c <do_test+0x428>
57e07d74:	eaffff1f 	b	57e079f8 <do_test+0xa4>
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
				last_expr = expr;
				last_cmp = 1;
57e07d78:	e3a05001 	mov	r5, #1

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
57e07d7c:	e1a0700a 	mov	r7, sl
57e07d80:	e3a09001 	mov	r9, #1
57e07d84:	eaffffe6 	b	57e07d24 <do_test+0x3d0>
57e07d88:	57e33a53 	.word	0x57e33a53
57e07d8c:	57e313b6 	.word	0x57e313b6
57e07d90:	57e313b9 	.word	0x57e313b9
57e07d94:	57e313bc 	.word	0x57e313bc
57e07d98:	57e313bf 	.word	0x57e313bf
57e07d9c:	57e2ff2a 	.word	0x57e2ff2a
57e07da0:	57e2ff29 	.word	0x57e2ff29
57e07da4:	57e2ff2d 	.word	0x57e2ff2d
57e07da8:	57e2ff18 	.word	0x57e2ff18
57e07dac:	57e2ff1e 	.word	0x57e2ff1e
57e07db0:	57e2ff25 	.word	0x57e2ff25
57e07db4:	57e2ff14 	.word	0x57e2ff14
57e07db8:	57e2ff36 	.word	0x57e2ff36
57e07dbc:	57e2ff1a 	.word	0x57e2ff1a
57e07dc0:	57e2ff2f 	.word	0x57e2ff2f

57e07dc4 <usb_get_class_desc>:
#endif

/* some display routines (info command) */
static char *usb_get_class_desc(unsigned char dclass)
{
	switch (dclass) {
57e07dc4:	e3500007 	cmp	r0, #7
	case USB_CLASS_COMM:
		return "Communication";
	case USB_CLASS_HID:
		return "Human Interface";
	case USB_CLASS_PRINTER:
		return "Printer";
57e07dc8:	059f0078 	ldreq	r0, [pc, #120]	; 57e07e48 <usb_get_class_desc+0x84>
#endif

/* some display routines (info command) */
static char *usb_get_class_desc(unsigned char dclass)
{
	switch (dclass) {
57e07dcc:	012fff1e 	bxeq	lr
57e07dd0:	8a000009 	bhi	57e07dfc <usb_get_class_desc+0x38>
57e07dd4:	e3500001 	cmp	r0, #1
57e07dd8:	0a000018 	beq	57e07e40 <usb_get_class_desc+0x7c>
	case USB_CLASS_PER_INTERFACE:
		return "See Interface";
57e07ddc:	359f0068 	ldrcc	r0, [pc, #104]	; 57e07e4c <usb_get_class_desc+0x88>
#endif

/* some display routines (info command) */
static char *usb_get_class_desc(unsigned char dclass)
{
	switch (dclass) {
57e07de0:	312fff1e 	bxcc	lr
57e07de4:	e3500002 	cmp	r0, #2
	case USB_CLASS_PER_INTERFACE:
		return "See Interface";
	case USB_CLASS_AUDIO:
		return "Audio";
	case USB_CLASS_COMM:
		return "Communication";
57e07de8:	059f0060 	ldreq	r0, [pc, #96]	; 57e07e50 <usb_get_class_desc+0x8c>
#endif

/* some display routines (info command) */
static char *usb_get_class_desc(unsigned char dclass)
{
	switch (dclass) {
57e07dec:	012fff1e 	bxeq	lr
57e07df0:	e3500003 	cmp	r0, #3
57e07df4:	1a00000f 	bne	57e07e38 <usb_get_class_desc+0x74>
57e07df8:	ea00000a 	b	57e07e28 <usb_get_class_desc+0x64>
57e07dfc:	e3500009 	cmp	r0, #9
	case USB_CLASS_PRINTER:
		return "Printer";
	case USB_CLASS_MASS_STORAGE:
		return "Mass Storage";
	case USB_CLASS_HUB:
		return "Hub";
57e07e00:	059f004c 	ldreq	r0, [pc, #76]	; 57e07e54 <usb_get_class_desc+0x90>
#endif

/* some display routines (info command) */
static char *usb_get_class_desc(unsigned char dclass)
{
	switch (dclass) {
57e07e04:	012fff1e 	bxeq	lr
	case USB_CLASS_HID:
		return "Human Interface";
	case USB_CLASS_PRINTER:
		return "Printer";
	case USB_CLASS_MASS_STORAGE:
		return "Mass Storage";
57e07e08:	359f0048 	ldrcc	r0, [pc, #72]	; 57e07e58 <usb_get_class_desc+0x94>
#endif

/* some display routines (info command) */
static char *usb_get_class_desc(unsigned char dclass)
{
	switch (dclass) {
57e07e0c:	312fff1e 	bxcc	lr
57e07e10:	e350000a 	cmp	r0, #10
	case USB_CLASS_MASS_STORAGE:
		return "Mass Storage";
	case USB_CLASS_HUB:
		return "Hub";
	case USB_CLASS_DATA:
		return "CDC Data";
57e07e14:	059f0040 	ldreq	r0, [pc, #64]	; 57e07e5c <usb_get_class_desc+0x98>
#endif

/* some display routines (info command) */
static char *usb_get_class_desc(unsigned char dclass)
{
	switch (dclass) {
57e07e18:	012fff1e 	bxeq	lr
57e07e1c:	e35000ff 	cmp	r0, #255	; 0xff
57e07e20:	1a000004 	bne	57e07e38 <usb_get_class_desc+0x74>
57e07e24:	ea000001 	b	57e07e30 <usb_get_class_desc+0x6c>
	case USB_CLASS_AUDIO:
		return "Audio";
	case USB_CLASS_COMM:
		return "Communication";
	case USB_CLASS_HID:
		return "Human Interface";
57e07e28:	e59f0030 	ldr	r0, [pc, #48]	; 57e07e60 <usb_get_class_desc+0x9c>
57e07e2c:	e12fff1e 	bx	lr
	case USB_CLASS_HUB:
		return "Hub";
	case USB_CLASS_DATA:
		return "CDC Data";
	case USB_CLASS_VENDOR_SPEC:
		return "Vendor specific";
57e07e30:	e59f002c 	ldr	r0, [pc, #44]	; 57e07e64 <usb_get_class_desc+0xa0>
57e07e34:	e12fff1e 	bx	lr
	default:
		return "";
57e07e38:	e59f0028 	ldr	r0, [pc, #40]	; 57e07e68 <usb_get_class_desc+0xa4>
57e07e3c:	e12fff1e 	bx	lr
{
	switch (dclass) {
	case USB_CLASS_PER_INTERFACE:
		return "See Interface";
	case USB_CLASS_AUDIO:
		return "Audio";
57e07e40:	e59f0024 	ldr	r0, [pc, #36]	; 57e07e6c <usb_get_class_desc+0xa8>
	case USB_CLASS_VENDOR_SPEC:
		return "Vendor specific";
	default:
		return "";
	}
}
57e07e44:	e12fff1e 	bx	lr
57e07e48:	57e31456 	.word	0x57e31456
57e07e4c:	57e31424 	.word	0x57e31424
57e07e50:	57e31438 	.word	0x57e31438
57e07e54:	57e3146b 	.word	0x57e3146b
57e07e58:	57e3145e 	.word	0x57e3145e
57e07e5c:	57e3146f 	.word	0x57e3146f
57e07e60:	57e31446 	.word	0x57e31446
57e07e64:	57e31478 	.word	0x57e31478
57e07e68:	57e302de 	.word	0x57e302de
57e07e6c:	57e31432 	.word	0x57e31432

57e07e70 <do_usbboot>:
 * usb boot command intepreter. Derived from diskboot
 */
#ifdef CONFIG_USB_STORAGE
static int do_usbboot(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return common_diskboot(cmdtp, "usb", argc, argv);
57e07e70:	e59f1000 	ldr	r1, [pc, #0]	; 57e07e78 <do_usbboot+0x8>
57e07e74:	eaffea8b 	b	57e028a8 <common_diskboot>
57e07e78:	57e31488 	.word	0x57e31488

57e07e7c <usb_display_class_sub>:
}

static void usb_display_class_sub(unsigned char dclass, unsigned char subclass,
				  unsigned char proto)
{
	switch (dclass) {
57e07e7c:	e3500003 	cmp	r0, #3
	}
}

static void usb_display_class_sub(unsigned char dclass, unsigned char subclass,
				  unsigned char proto)
{
57e07e80:	e92d4070 	push	{r4, r5, r6, lr}
57e07e84:	e1a04001 	mov	r4, r1
57e07e88:	e1a05002 	mov	r5, r2
	switch (dclass) {
57e07e8c:	0a000005 	beq	57e07ea8 <usb_display_class_sub+0x2c>
57e07e90:	e3500008 	cmp	r0, #8
57e07e94:	0a000017 	beq	57e07ef8 <usb_display_class_sub+0x7c>
57e07e98:	e3500000 	cmp	r0, #0
	case USB_CLASS_PER_INTERFACE:
		printf("See Interface");
57e07e9c:	059f0100 	ldreq	r0, [pc, #256]	; 57e07fa4 <usb_display_class_sub+0x128>
}

static void usb_display_class_sub(unsigned char dclass, unsigned char subclass,
				  unsigned char proto)
{
	switch (dclass) {
57e07ea0:	0a000008 	beq	57e07ec8 <usb_display_class_sub+0x4c>
57e07ea4:	ea000039 	b	57e07f90 <usb_display_class_sub+0x114>
	case USB_CLASS_PER_INTERFACE:
		printf("See Interface");
		break;
	case USB_CLASS_HID:
		printf("Human Interface, Subclass: ");
57e07ea8:	e59f00f8 	ldr	r0, [pc, #248]	; 57e07fa8 <usb_display_class_sub+0x12c>
57e07eac:	eb000566 	bl	57e0944c <printf>
		switch (subclass) {
57e07eb0:	e3540000 	cmp	r4, #0
57e07eb4:	0a000002 	beq	57e07ec4 <usb_display_class_sub+0x48>
57e07eb8:	e3540001 	cmp	r4, #1
57e07ebc:	1a000031 	bne	57e07f88 <usb_display_class_sub+0x10c>
57e07ec0:	ea000002 	b	57e07ed0 <usb_display_class_sub+0x54>
		case USB_SUB_HID_NONE:
			printf("None");
57e07ec4:	e59f00e0 	ldr	r0, [pc, #224]	; 57e07fac <usb_display_class_sub+0x130>
		break;
	default:
		printf("%s", usb_get_class_desc(dclass));
		break;
	}
}
57e07ec8:	e8bd4070 	pop	{r4, r5, r6, lr}
		break;
	case USB_CLASS_HID:
		printf("Human Interface, Subclass: ");
		switch (subclass) {
		case USB_SUB_HID_NONE:
			printf("None");
57e07ecc:	ea00055e 	b	57e0944c <printf>
			break;
		case USB_SUB_HID_BOOT:
			printf("Boot ");
57e07ed0:	e59f00d8 	ldr	r0, [pc, #216]	; 57e07fb0 <usb_display_class_sub+0x134>
57e07ed4:	eb00055c 	bl	57e0944c <printf>
			switch (proto) {
57e07ed8:	e3550001 	cmp	r5, #1
			case USB_PROT_HID_NONE:
				printf("None");
				break;
			case USB_PROT_HID_KEYBOARD:
				printf("Keyboard");
57e07edc:	059f00d0 	ldreq	r0, [pc, #208]	; 57e07fb4 <usb_display_class_sub+0x138>
		case USB_SUB_HID_NONE:
			printf("None");
			break;
		case USB_SUB_HID_BOOT:
			printf("Boot ");
			switch (proto) {
57e07ee0:	0afffff8 	beq	57e07ec8 <usb_display_class_sub+0x4c>
57e07ee4:	3afffff6 	bcc	57e07ec4 <usb_display_class_sub+0x48>
57e07ee8:	e3550002 	cmp	r5, #2
57e07eec:	1a000025 	bne	57e07f88 <usb_display_class_sub+0x10c>
				break;
			case USB_PROT_HID_KEYBOARD:
				printf("Keyboard");
				break;
			case USB_PROT_HID_MOUSE:
				printf("Mouse");
57e07ef0:	e59f00c0 	ldr	r0, [pc, #192]	; 57e07fb8 <usb_display_class_sub+0x13c>
57e07ef4:	eafffff3 	b	57e07ec8 <usb_display_class_sub+0x4c>
			printf("reserved");
			break;
		}
		break;
	case USB_CLASS_MASS_STORAGE:
		printf("Mass Storage, ");
57e07ef8:	e59f00bc 	ldr	r0, [pc, #188]	; 57e07fbc <usb_display_class_sub+0x140>
		switch (subclass) {
57e07efc:	e2444001 	sub	r4, r4, #1
			printf("reserved");
			break;
		}
		break;
	case USB_CLASS_MASS_STORAGE:
		printf("Mass Storage, ");
57e07f00:	eb000551 	bl	57e0944c <printf>
		switch (subclass) {
57e07f04:	e3540005 	cmp	r4, #5
57e07f08:	979ff104 	ldrls	pc, [pc, r4, lsl #2]
57e07f0c:	ea000011 	b	57e07f58 <usb_display_class_sub+0xdc>
57e07f10:	57e07f28 	.word	0x57e07f28
57e07f14:	57e07f30 	.word	0x57e07f30
57e07f18:	57e07f38 	.word	0x57e07f38
57e07f1c:	57e07f40 	.word	0x57e07f40
57e07f20:	57e07f48 	.word	0x57e07f48
57e07f24:	57e07f50 	.word	0x57e07f50
		case US_SC_RBC:
			printf("RBC ");
57e07f28:	e59f0090 	ldr	r0, [pc, #144]	; 57e07fc0 <usb_display_class_sub+0x144>
57e07f2c:	ea00000a 	b	57e07f5c <usb_display_class_sub+0xe0>
			break;
		case US_SC_8020:
			printf("SFF-8020i (ATAPI)");
57e07f30:	e59f008c 	ldr	r0, [pc, #140]	; 57e07fc4 <usb_display_class_sub+0x148>
57e07f34:	ea000008 	b	57e07f5c <usb_display_class_sub+0xe0>
			break;
		case US_SC_QIC:
			printf("QIC-157 (Tape)");
57e07f38:	e59f0088 	ldr	r0, [pc, #136]	; 57e07fc8 <usb_display_class_sub+0x14c>
57e07f3c:	ea000006 	b	57e07f5c <usb_display_class_sub+0xe0>
			break;
		case US_SC_UFI:
			printf("UFI");
57e07f40:	e59f0084 	ldr	r0, [pc, #132]	; 57e07fcc <usb_display_class_sub+0x150>
57e07f44:	ea000004 	b	57e07f5c <usb_display_class_sub+0xe0>
			break;
		case US_SC_8070:
			printf("SFF-8070");
57e07f48:	e59f0080 	ldr	r0, [pc, #128]	; 57e07fd0 <usb_display_class_sub+0x154>
57e07f4c:	ea000002 	b	57e07f5c <usb_display_class_sub+0xe0>
			break;
		case US_SC_SCSI:
			printf("Transp. SCSI");
57e07f50:	e59f007c 	ldr	r0, [pc, #124]	; 57e07fd4 <usb_display_class_sub+0x158>
57e07f54:	ea000000 	b	57e07f5c <usb_display_class_sub+0xe0>
			break;
		default:
			printf("reserved");
57e07f58:	e59f0078 	ldr	r0, [pc, #120]	; 57e07fd8 <usb_display_class_sub+0x15c>
57e07f5c:	eb00053a 	bl	57e0944c <printf>
			break;
		}
		printf(", ");
57e07f60:	e59f0074 	ldr	r0, [pc, #116]	; 57e07fdc <usb_display_class_sub+0x160>
57e07f64:	eb000538 	bl	57e0944c <printf>
		switch (proto) {
57e07f68:	e3550001 	cmp	r5, #1
		case US_PR_CB:
			printf("Command/Bulk");
57e07f6c:	059f006c 	ldreq	r0, [pc, #108]	; 57e07fe0 <usb_display_class_sub+0x164>
		default:
			printf("reserved");
			break;
		}
		printf(", ");
		switch (proto) {
57e07f70:	0affffd4 	beq	57e07ec8 <usb_display_class_sub+0x4c>
		case US_PR_CB:
			printf("Command/Bulk");
			break;
		case US_PR_CBI:
			printf("Command/Bulk/Int");
57e07f74:	359f0068 	ldrcc	r0, [pc, #104]	; 57e07fe4 <usb_display_class_sub+0x168>
		default:
			printf("reserved");
			break;
		}
		printf(", ");
		switch (proto) {
57e07f78:	3affffd2 	bcc	57e07ec8 <usb_display_class_sub+0x4c>
57e07f7c:	e3550050 	cmp	r5, #80	; 0x50
			break;
		case US_PR_CBI:
			printf("Command/Bulk/Int");
			break;
		case US_PR_BULK:
			printf("Bulk only");
57e07f80:	059f0060 	ldreq	r0, [pc, #96]	; 57e07fe8 <usb_display_class_sub+0x16c>
57e07f84:	0affffcf 	beq	57e07ec8 <usb_display_class_sub+0x4c>
			break;
		default:
			printf("reserved");
57e07f88:	e59f0048 	ldr	r0, [pc, #72]	; 57e07fd8 <usb_display_class_sub+0x15c>
57e07f8c:	eaffffcd 	b	57e07ec8 <usb_display_class_sub+0x4c>
			break;
		}
		break;
	default:
		printf("%s", usb_get_class_desc(dclass));
57e07f90:	ebffff8b 	bl	57e07dc4 <usb_get_class_desc>
57e07f94:	e1a01000 	mov	r1, r0
57e07f98:	e59f004c 	ldr	r0, [pc, #76]	; 57e07fec <usb_display_class_sub+0x170>
		break;
	}
}
57e07f9c:	e8bd4070 	pop	{r4, r5, r6, lr}
			printf("reserved");
			break;
		}
		break;
	default:
		printf("%s", usb_get_class_desc(dclass));
57e07fa0:	ea000529 	b	57e0944c <printf>
57e07fa4:	57e31424 	.word	0x57e31424
57e07fa8:	57e3148c 	.word	0x57e3148c
57e07fac:	57e314a8 	.word	0x57e314a8
57e07fb0:	57e314ad 	.word	0x57e314ad
57e07fb4:	57e314b3 	.word	0x57e314b3
57e07fb8:	57e314bc 	.word	0x57e314bc
57e07fbc:	57e314cb 	.word	0x57e314cb
57e07fc0:	57e314da 	.word	0x57e314da
57e07fc4:	57e314df 	.word	0x57e314df
57e07fc8:	57e314f1 	.word	0x57e314f1
57e07fcc:	57e31500 	.word	0x57e31500
57e07fd0:	57e31504 	.word	0x57e31504
57e07fd4:	57e3150d 	.word	0x57e3150d
57e07fd8:	57e314c2 	.word	0x57e314c2
57e07fdc:	57e314d7 	.word	0x57e314d7
57e07fe0:	57e3151a 	.word	0x57e3151a
57e07fe4:	57e31527 	.word	0x57e31527
57e07fe8:	57e31538 	.word	0x57e31538
57e07fec:	57e308f5 	.word	0x57e308f5

57e07ff0 <usb_show_tree_graph>:
		return "12 Mb/s";
}

/* shows the device tree recursively */
static void usb_show_tree_graph(struct usb_device *dev, char *pre)
{
57e07ff0:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
57e07ff4:	e1a04000 	mov	r4, r0
	int i, index;
	int has_child, last_child;

	index = strlen(pre);
57e07ff8:	e1a00001 	mov	r0, r1
		return "12 Mb/s";
}

/* shows the device tree recursively */
static void usb_show_tree_graph(struct usb_device *dev, char *pre)
{
57e07ffc:	e1a05001 	mov	r5, r1
	int i, index;
	int has_child, last_child;

	index = strlen(pre);
57e08000:	eb007012 	bl	57e24050 <strlen>
	else
		return "12 Mb/s";
}

/* shows the device tree recursively */
static void usb_show_tree_graph(struct usb_device *dev, char *pre)
57e08004:	e2846e62 	add	r6, r4, #1568	; 0x620
{
	int i, index;
	int has_child, last_child;

	index = strlen(pre);
	printf(" %s", pre);
57e08008:	e1a01005 	mov	r1, r5
static void usb_show_tree_graph(struct usb_device *dev, char *pre)
{
	int i, index;
	int has_child, last_child;

	index = strlen(pre);
57e0800c:	e1a0a000 	mov	sl, r0
	else
		return "12 Mb/s";
}

/* shows the device tree recursively */
static void usb_show_tree_graph(struct usb_device *dev, char *pre)
57e08010:	e2866004 	add	r6, r6, #4
{
	int i, index;
	int has_child, last_child;

	index = strlen(pre);
	printf(" %s", pre);
57e08014:	e59f01cc 	ldr	r0, [pc, #460]	; 57e081e8 <usb_show_tree_graph+0x1f8>
	/* check if the device has connected children */
	has_child = 0;
57e08018:	e3a07000 	mov	r7, #0
{
	int i, index;
	int has_child, last_child;

	index = strlen(pre);
	printf(" %s", pre);
57e0801c:	eb00050a 	bl	57e0944c <printf>
	/* check if the device has connected children */
	has_child = 0;
	for (i = 0; i < dev->maxchild; i++) {
57e08020:	e594161c 	ldr	r1, [r4, #1564]	; 0x61c
57e08024:	e1a02006 	mov	r2, r6
57e08028:	e1a03007 	mov	r3, r7
57e0802c:	ea000003 	b	57e08040 <usb_show_tree_graph+0x50>
		if (dev->children[i] != NULL)
57e08030:	e5b20004 	ldr	r0, [r2, #4]!

	index = strlen(pre);
	printf(" %s", pre);
	/* check if the device has connected children */
	has_child = 0;
	for (i = 0; i < dev->maxchild; i++) {
57e08034:	e2833001 	add	r3, r3, #1
		if (dev->children[i] != NULL)
			has_child = 1;
57e08038:	e3500000 	cmp	r0, #0
57e0803c:	13a07001 	movne	r7, #1

	index = strlen(pre);
	printf(" %s", pre);
	/* check if the device has connected children */
	has_child = 0;
	for (i = 0; i < dev->maxchild; i++) {
57e08040:	e1530001 	cmp	r3, r1
57e08044:	bafffff9 	blt	57e08030 <usb_show_tree_graph+0x40>
		if (dev->children[i] != NULL)
			has_child = 1;
	}
	/* check if we are the last one */
	last_child = 1;
	if (dev->parent != NULL) {
57e08048:	e5942624 	ldr	r2, [r4, #1572]	; 0x624
57e0804c:	e3520000 	cmp	r2, #0
		for (i = 0; i < dev->parent->maxchild; i++) {
57e08050:	1592161c 	ldrne	r1, [r2, #1564]	; 0x61c
57e08054:	13a09001 	movne	r9, #1
57e08058:	13a03000 	movne	r3, #0
		if (dev->children[i] != NULL)
			has_child = 1;
	}
	/* check if we are the last one */
	last_child = 1;
	if (dev->parent != NULL) {
57e0805c:	1a000011 	bne	57e080a8 <usb_show_tree_graph+0xb8>
57e08060:	ea000019 	b	57e080cc <usb_show_tree_graph+0xdc>
		for (i = 0; i < dev->parent->maxchild; i++) {
			/* search for children */
			if (dev->parent->children[i] == dev) {
57e08064:	e2830f62 	add	r0, r3, #392	; 0x188
57e08068:	e2800002 	add	r0, r0, #2
57e0806c:	e792c100 	ldr	ip, [r2, r0, lsl #2]
57e08070:	e15c0004 	cmp	ip, r4
	else
		return "12 Mb/s";
}

/* shows the device tree recursively */
static void usb_show_tree_graph(struct usb_device *dev, char *pre)
57e08074:	00820100 	addeq	r0, r2, r0, lsl #2
	/* check if we are the last one */
	last_child = 1;
	if (dev->parent != NULL) {
		for (i = 0; i < dev->parent->maxchild; i++) {
			/* search for children */
			if (dev->parent->children[i] == dev) {
57e08078:	1a000009 	bne	57e080a4 <usb_show_tree_graph+0xb4>
57e0807c:	ea000002 	b	57e0808c <usb_show_tree_graph+0x9c>
				/* found our pointer, see if we have a
				 * little sister
				 */
				while (i++ < dev->parent->maxchild) {
					if (dev->parent->children[i] != NULL) {
57e08080:	e5b0c004 	ldr	ip, [r0, #4]!
57e08084:	e35c0000 	cmp	ip, #0
57e08088:	1a000004 	bne	57e080a0 <usb_show_tree_graph+0xb0>
			/* search for children */
			if (dev->parent->children[i] == dev) {
				/* found our pointer, see if we have a
				 * little sister
				 */
				while (i++ < dev->parent->maxchild) {
57e0808c:	e2833001 	add	r3, r3, #1
	else
		return "12 Mb/s";
}

/* shows the device tree recursively */
static void usb_show_tree_graph(struct usb_device *dev, char *pre)
57e08090:	e243c001 	sub	ip, r3, #1
			/* search for children */
			if (dev->parent->children[i] == dev) {
				/* found our pointer, see if we have a
				 * little sister
				 */
				while (i++ < dev->parent->maxchild) {
57e08094:	e15c0001 	cmp	ip, r1
57e08098:	bafffff8 	blt	57e08080 <usb_show_tree_graph+0x90>
57e0809c:	ea000000 	b	57e080a4 <usb_show_tree_graph+0xb4>
					if (dev->parent->children[i] != NULL) {
						/* found a sister */
						last_child = 0;
57e080a0:	e3a09000 	mov	r9, #0
			has_child = 1;
	}
	/* check if we are the last one */
	last_child = 1;
	if (dev->parent != NULL) {
		for (i = 0; i < dev->parent->maxchild; i++) {
57e080a4:	e2833001 	add	r3, r3, #1
57e080a8:	e1530001 	cmp	r3, r1
57e080ac:	baffffec 	blt	57e08064 <usb_show_tree_graph+0x74>
						break;
					} /* if */
				} /* while */
			} /* device found */
		} /* for all children of the parent */
		printf("\b+-");
57e080b0:	e59f0134 	ldr	r0, [pc, #308]	; 57e081ec <usb_show_tree_graph+0x1fc>
57e080b4:	eb0004e4 	bl	57e0944c <printf>
		/* correct last child */
		if (last_child)
57e080b8:	e3590000 	cmp	r9, #0
			pre[index-1] = ' ';
57e080bc:	1085300a 	addne	r3, r5, sl
57e080c0:	13a02020 	movne	r2, #32
57e080c4:	15432001 	strbne	r2, [r3, #-1]
57e080c8:	ea000001 	b	57e080d4 <usb_show_tree_graph+0xe4>
	} /* if not root hub */
	else
		printf(" ");
57e080cc:	e59f011c 	ldr	r0, [pc, #284]	; 57e081f0 <usb_show_tree_graph+0x200>
57e080d0:	eb0004dd 	bl	57e0944c <printf>
	printf("%d ", dev->devnum);
57e080d4:	e5941000 	ldr	r1, [r4]
57e080d8:	e59f0114 	ldr	r0, [pc, #276]	; 57e081f4 <usb_show_tree_graph+0x204>
57e080dc:	eb0004da 	bl	57e0944c <printf>
	pre[index++] = ' ';
	pre[index++] = has_child ? '|' : ' ';
57e080e0:	e3570000 	cmp	r7, #0
			pre[index-1] = ' ';
	} /* if not root hub */
	else
		printf(" ");
	printf("%d ", dev->devnum);
	pre[index++] = ' ';
57e080e4:	e3a03020 	mov	r3, #32
57e080e8:	e7c5300a 	strb	r3, [r5, sl]
	pre[index++] = has_child ? '|' : ' ';
57e080ec:	01a07003 	moveq	r7, r3
57e080f0:	13a0707c 	movne	r7, #124	; 0x7c
			pre[index-1] = ' ';
	} /* if not root hub */
	else
		printf(" ");
	printf("%d ", dev->devnum);
	pre[index++] = ' ';
57e080f4:	e28aa001 	add	sl, sl, #1
	pre[index++] = has_child ? '|' : ' ';
57e080f8:	e7c5700a 	strb	r7, [r5, sl]
	pre[index] = 0;
57e080fc:	e3a03000 	mov	r3, #0
	} /* if not root hub */
	else
		printf(" ");
	printf("%d ", dev->devnum);
	pre[index++] = ' ';
	pre[index++] = has_child ? '|' : ' ';
57e08100:	e28aa001 	add	sl, sl, #1
	pre[index] = 0;
57e08104:	e7c5300a 	strb	r3, [r5, sl]
	printf(" %s (%s, %dmA)\n", usb_get_class_desc(
57e08108:	e5d40121 	ldrb	r0, [r4, #289]	; 0x121
57e0810c:	ebffff2c 	bl	57e07dc4 <usb_get_class_desc>
57e08110:	e5943004 	ldr	r3, [r4, #4]
	else
		printf(" ");
	printf("%d ", dev->devnum);
	pre[index++] = ' ';
	pre[index++] = has_child ? '|' : ' ';
	pre[index] = 0;
57e08114:	e085700a 	add	r7, r5, sl
	printf("\n");
}

static inline char *portspeed(int speed)
{
	if (speed == USB_SPEED_HIGH)
57e08118:	e3530003 	cmp	r3, #3
		printf(" ");
	printf("%d ", dev->devnum);
	pre[index++] = ' ';
	pre[index++] = has_child ? '|' : ' ';
	pre[index] = 0;
	printf(" %s (%s, %dmA)\n", usb_get_class_desc(
57e0811c:	e1a01000 	mov	r1, r0
}

static inline char *portspeed(int speed)
{
	if (speed == USB_SPEED_HIGH)
		return "480 Mb/s";
57e08120:	059f20d0 	ldreq	r2, [pc, #208]	; 57e081f8 <usb_show_tree_graph+0x208>
	printf("\n");
}

static inline char *portspeed(int speed)
{
	if (speed == USB_SPEED_HIGH)
57e08124:	0a000003 	beq	57e08138 <usb_show_tree_graph+0x148>
		return "480 Mb/s";
	else if (speed == USB_SPEED_LOW)
		return "1.5 Mb/s";
57e08128:	e59f00cc 	ldr	r0, [pc, #204]	; 57e081fc <usb_show_tree_graph+0x20c>
57e0812c:	e3530001 	cmp	r3, #1
57e08130:	e59f20c8 	ldr	r2, [pc, #200]	; 57e08200 <usb_show_tree_graph+0x210>
57e08134:	11a02000 	movne	r2, r0
		printf(" ");
	printf("%d ", dev->devnum);
	pre[index++] = ' ';
	pre[index++] = has_child ? '|' : ' ';
	pre[index] = 0;
	printf(" %s (%s, %dmA)\n", usb_get_class_desc(
57e08138:	e5d4311a 	ldrb	r3, [r4, #282]	; 0x11a
57e0813c:	e59f00c0 	ldr	r0, [pc, #192]	; 57e08204 <usb_show_tree_graph+0x214>
57e08140:	e1a03083 	lsl	r3, r3, #1
					dev->config.if_desc[0].desc.bInterfaceClass),
					portspeed(dev->speed),
					dev->config.desc.bMaxPower * 2);
	if (strlen(dev->mf) || strlen(dev->prod) || strlen(dev->serial))
57e08144:	e284a008 	add	sl, r4, #8
		printf(" ");
	printf("%d ", dev->devnum);
	pre[index++] = ' ';
	pre[index++] = has_child ? '|' : ' ';
	pre[index] = 0;
	printf(" %s (%s, %dmA)\n", usb_get_class_desc(
57e08148:	eb0004bf 	bl	57e0944c <printf>
					dev->config.if_desc[0].desc.bInterfaceClass),
					portspeed(dev->speed),
					dev->config.desc.bMaxPower * 2);
	if (strlen(dev->mf) || strlen(dev->prod) || strlen(dev->serial))
57e0814c:	e1a0000a 	mov	r0, sl
57e08150:	eb006fbe 	bl	57e24050 <strlen>
57e08154:	e3500000 	cmp	r0, #0
57e08158:	1a000007 	bne	57e0817c <usb_show_tree_graph+0x18c>
57e0815c:	e2840028 	add	r0, r4, #40	; 0x28
57e08160:	eb006fba 	bl	57e24050 <strlen>
57e08164:	e3500000 	cmp	r0, #0
57e08168:	1a000003 	bne	57e0817c <usb_show_tree_graph+0x18c>
57e0816c:	e2840048 	add	r0, r4, #72	; 0x48
57e08170:	eb006fb6 	bl	57e24050 <strlen>
57e08174:	e3500000 	cmp	r0, #0
57e08178:	0a000006 	beq	57e08198 <usb_show_tree_graph+0x1a8>
		printf(" %s  %s %s %s\n", pre, dev->mf, dev->prod, dev->serial);
57e0817c:	e2843048 	add	r3, r4, #72	; 0x48
57e08180:	e58d3000 	str	r3, [sp]
57e08184:	e59f007c 	ldr	r0, [pc, #124]	; 57e08208 <usb_show_tree_graph+0x218>
57e08188:	e1a01005 	mov	r1, r5
57e0818c:	e1a0200a 	mov	r2, sl
57e08190:	e2843028 	add	r3, r4, #40	; 0x28
57e08194:	eb0004ac 	bl	57e0944c <printf>
	printf(" %s\n", pre);
57e08198:	e59f006c 	ldr	r0, [pc, #108]	; 57e0820c <usb_show_tree_graph+0x21c>
57e0819c:	e1a01005 	mov	r1, r5
57e081a0:	eb0004a9 	bl	57e0944c <printf>
	if (dev->maxchild > 0) {
57e081a4:	e594361c 	ldr	r3, [r4, #1564]	; 0x61c
57e081a8:	e3530000 	cmp	r3, #0
57e081ac:	c3a0a000 	movgt	sl, #0
		for (i = 0; i < dev->maxchild; i++) {
			if (dev->children[i] != NULL) {
				usb_show_tree_graph(dev->children[i], pre);
				pre[index] = 0;
57e081b0:	c1a0900a 	movgt	r9, sl
					portspeed(dev->speed),
					dev->config.desc.bMaxPower * 2);
	if (strlen(dev->mf) || strlen(dev->prod) || strlen(dev->serial))
		printf(" %s  %s %s %s\n", pre, dev->mf, dev->prod, dev->serial);
	printf(" %s\n", pre);
	if (dev->maxchild > 0) {
57e081b4:	ca000007 	bgt	57e081d8 <usb_show_tree_graph+0x1e8>
57e081b8:	ea000009 	b	57e081e4 <usb_show_tree_graph+0x1f4>
		for (i = 0; i < dev->maxchild; i++) {
			if (dev->children[i] != NULL) {
57e081bc:	e5b60004 	ldr	r0, [r6, #4]!
57e081c0:	e3500000 	cmp	r0, #0
57e081c4:	0a000002 	beq	57e081d4 <usb_show_tree_graph+0x1e4>
				usb_show_tree_graph(dev->children[i], pre);
57e081c8:	e1a01005 	mov	r1, r5
57e081cc:	ebffff87 	bl	57e07ff0 <usb_show_tree_graph>
				pre[index] = 0;
57e081d0:	e5c79000 	strb	r9, [r7]
					dev->config.desc.bMaxPower * 2);
	if (strlen(dev->mf) || strlen(dev->prod) || strlen(dev->serial))
		printf(" %s  %s %s %s\n", pre, dev->mf, dev->prod, dev->serial);
	printf(" %s\n", pre);
	if (dev->maxchild > 0) {
		for (i = 0; i < dev->maxchild; i++) {
57e081d4:	e28aa001 	add	sl, sl, #1
57e081d8:	e594361c 	ldr	r3, [r4, #1564]	; 0x61c
57e081dc:	e15a0003 	cmp	sl, r3
57e081e0:	bafffff5 	blt	57e081bc <usb_show_tree_graph+0x1cc>
				usb_show_tree_graph(dev->children[i], pre);
				pre[index] = 0;
			}
		}
	}
}
57e081e4:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
57e081e8:	57e308f4 	.word	0x57e308f4
57e081ec:	57e3155c 	.word	0x57e3155c
57e081f0:	57e35c4a 	.word	0x57e35c4a
57e081f4:	57e30876 	.word	0x57e30876
57e081f8:	57e31542 	.word	0x57e31542
57e081fc:	57e31554 	.word	0x57e31554
57e08200:	57e3154b 	.word	0x57e3154b
57e08204:	57e31560 	.word	0x57e31560
57e08208:	57e31570 	.word	0x57e31570
57e0820c:	57e3541d 	.word	0x57e3541d

57e08210 <usb_display_desc>:
			printf("String: \"%s\"", buffer);
	}
}

static void usb_display_desc(struct usb_device *dev)
{
57e08210:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	if (dev->descriptor.bDescriptorType == USB_DT_DEVICE) {
57e08214:	e5d03101 	ldrb	r3, [r0, #257]	; 0x101
			printf("String: \"%s\"", buffer);
	}
}

static void usb_display_desc(struct usb_device *dev)
{
57e08218:	e1a04000 	mov	r4, r0
	if (dev->descriptor.bDescriptorType == USB_DT_DEVICE) {
57e0821c:	e3530001 	cmp	r3, #1
57e08220:	1a00003c 	bne	57e08318 <usb_display_desc+0x108>
		printf("%d: %s,  USB Revision %x.%x\n", dev->devnum,
57e08224:	e5d00121 	ldrb	r0, [r0, #289]	; 0x121
57e08228:	ebfffee5 	bl	57e07dc4 <usb_get_class_desc>
		usb_get_class_desc(dev->config.if_desc[0].desc.bInterfaceClass),
				   (dev->descriptor.bcdUSB>>8) & 0xff,
57e0822c:	e59f30e8 	ldr	r3, [pc, #232]	; 57e0831c <usb_display_desc+0x10c>
}

static void usb_display_desc(struct usb_device *dev)
{
	if (dev->descriptor.bDescriptorType == USB_DT_DEVICE) {
		printf("%d: %s,  USB Revision %x.%x\n", dev->devnum,
57e08230:	e1a05004 	mov	r5, r4
		usb_get_class_desc(dev->config.if_desc[0].desc.bInterfaceClass),
				   (dev->descriptor.bcdUSB>>8) & 0xff,
57e08234:	e19430b3 	ldrh	r3, [r4, r3]
}

static void usb_display_desc(struct usb_device *dev)
{
	if (dev->descriptor.bDescriptorType == USB_DT_DEVICE) {
		printf("%d: %s,  USB Revision %x.%x\n", dev->devnum,
57e08238:	e1a02000 	mov	r2, r0
57e0823c:	e20310ff 	and	r1, r3, #255	; 0xff
57e08240:	e58d1000 	str	r1, [sp]
57e08244:	e4951008 	ldr	r1, [r5], #8
57e08248:	e1a03423 	lsr	r3, r3, #8
57e0824c:	e59f00cc 	ldr	r0, [pc, #204]	; 57e08320 <usb_display_desc+0x110>
57e08250:	eb00047d 	bl	57e0944c <printf>
		usb_get_class_desc(dev->config.if_desc[0].desc.bInterfaceClass),
				   (dev->descriptor.bcdUSB>>8) & 0xff,
				   dev->descriptor.bcdUSB & 0xff);

		if (strlen(dev->mf) || strlen(dev->prod) ||
57e08254:	e1a00005 	mov	r0, r5
57e08258:	eb006f7c 	bl	57e24050 <strlen>
57e0825c:	e3500000 	cmp	r0, #0
57e08260:	1a000007 	bne	57e08284 <usb_display_desc+0x74>
57e08264:	e2840028 	add	r0, r4, #40	; 0x28
57e08268:	eb006f78 	bl	57e24050 <strlen>
57e0826c:	e3500000 	cmp	r0, #0
57e08270:	1a000003 	bne	57e08284 <usb_display_desc+0x74>
		    strlen(dev->serial))
57e08274:	e2840048 	add	r0, r4, #72	; 0x48
57e08278:	eb006f74 	bl	57e24050 <strlen>
		printf("%d: %s,  USB Revision %x.%x\n", dev->devnum,
		usb_get_class_desc(dev->config.if_desc[0].desc.bInterfaceClass),
				   (dev->descriptor.bcdUSB>>8) & 0xff,
				   dev->descriptor.bcdUSB & 0xff);

		if (strlen(dev->mf) || strlen(dev->prod) ||
57e0827c:	e3500000 	cmp	r0, #0
57e08280:	0a000004 	beq	57e08298 <usb_display_desc+0x88>
		    strlen(dev->serial))
			printf(" - %s %s %s\n", dev->mf, dev->prod,
57e08284:	e59f0098 	ldr	r0, [pc, #152]	; 57e08324 <usb_display_desc+0x114>
57e08288:	e1a01005 	mov	r1, r5
57e0828c:	e2842028 	add	r2, r4, #40	; 0x28
57e08290:	e2843048 	add	r3, r4, #72	; 0x48
57e08294:	eb00046c 	bl	57e0944c <printf>
				dev->serial);
		if (dev->descriptor.bDeviceClass) {
57e08298:	e5d43104 	ldrb	r3, [r4, #260]	; 0x104
57e0829c:	e3530000 	cmp	r3, #0
57e082a0:	0a000008 	beq	57e082c8 <usb_display_desc+0xb8>
			printf(" - Class: ");
57e082a4:	e59f007c 	ldr	r0, [pc, #124]	; 57e08328 <usb_display_desc+0x118>
57e082a8:	eb000467 	bl	57e0944c <printf>
			usb_display_class_sub(dev->descriptor.bDeviceClass,
57e082ac:	e5d40104 	ldrb	r0, [r4, #260]	; 0x104
57e082b0:	e5d41105 	ldrb	r1, [r4, #261]	; 0x105
57e082b4:	e5d42106 	ldrb	r2, [r4, #262]	; 0x106
57e082b8:	ebfffeef 	bl	57e07e7c <usb_display_class_sub>
					      dev->descriptor.bDeviceSubClass,
					      dev->descriptor.bDeviceProtocol);
			printf("\n");
57e082bc:	e59f0068 	ldr	r0, [pc, #104]	; 57e0832c <usb_display_desc+0x11c>
57e082c0:	eb000461 	bl	57e0944c <printf>
57e082c4:	ea000004 	b	57e082dc <usb_display_desc+0xcc>
		} else {
			printf(" - Class: (from Interface) %s\n",
57e082c8:	e5d40121 	ldrb	r0, [r4, #289]	; 0x121
57e082cc:	ebfffebc 	bl	57e07dc4 <usb_get_class_desc>
57e082d0:	e1a01000 	mov	r1, r0
57e082d4:	e59f0054 	ldr	r0, [pc, #84]	; 57e08330 <usb_display_desc+0x120>
57e082d8:	eb00045b 	bl	57e0944c <printf>
			       usb_get_class_desc(
				dev->config.if_desc[0].desc.bInterfaceClass));
		}
		printf(" - PacketSize: %d  Configurations: %d\n",
57e082dc:	e5d41107 	ldrb	r1, [r4, #263]	; 0x107
57e082e0:	e5d42111 	ldrb	r2, [r4, #273]	; 0x111
57e082e4:	e59f0048 	ldr	r0, [pc, #72]	; 57e08334 <usb_display_desc+0x124>
57e082e8:	eb000457 	bl	57e0944c <printf>
			dev->descriptor.bMaxPacketSize0,
			dev->descriptor.bNumConfigurations);
		printf(" - Vendor: 0x%04x  Product 0x%04x Version %d.%d\n",
			dev->descriptor.idVendor, dev->descriptor.idProduct,
			(dev->descriptor.bcdDevice>>8) & 0xff,
57e082ec:	e3a03f43 	mov	r3, #268	; 0x10c
57e082f0:	e19430b3 	ldrh	r3, [r4, r3]
		}
		printf(" - PacketSize: %d  Configurations: %d\n",
			dev->descriptor.bMaxPacketSize0,
			dev->descriptor.bNumConfigurations);
		printf(" - Vendor: 0x%04x  Product 0x%04x Version %d.%d\n",
			dev->descriptor.idVendor, dev->descriptor.idProduct,
57e082f4:	e3a02f42 	mov	r2, #264	; 0x108
				dev->config.if_desc[0].desc.bInterfaceClass));
		}
		printf(" - PacketSize: %d  Configurations: %d\n",
			dev->descriptor.bMaxPacketSize0,
			dev->descriptor.bNumConfigurations);
		printf(" - Vendor: 0x%04x  Product 0x%04x Version %d.%d\n",
57e082f8:	e20300ff 	and	r0, r3, #255	; 0xff
57e082fc:	e19410b2 	ldrh	r1, [r4, r2]
			dev->descriptor.idVendor, dev->descriptor.idProduct,
57e08300:	e2822002 	add	r2, r2, #2
				dev->config.if_desc[0].desc.bInterfaceClass));
		}
		printf(" - PacketSize: %d  Configurations: %d\n",
			dev->descriptor.bMaxPacketSize0,
			dev->descriptor.bNumConfigurations);
		printf(" - Vendor: 0x%04x  Product 0x%04x Version %d.%d\n",
57e08304:	e58d0000 	str	r0, [sp]
57e08308:	e19420b2 	ldrh	r2, [r4, r2]
57e0830c:	e59f0024 	ldr	r0, [pc, #36]	; 57e08338 <usb_display_desc+0x128>
57e08310:	e1a03423 	lsr	r3, r3, #8
57e08314:	eb00044c 	bl	57e0944c <printf>
			dev->descriptor.idVendor, dev->descriptor.idProduct,
			(dev->descriptor.bcdDevice>>8) & 0xff,
			dev->descriptor.bcdDevice & 0xff);
	}

}
57e08318:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
57e0831c:	00000102 	.word	0x00000102
57e08320:	57e3157f 	.word	0x57e3157f
57e08324:	57e3159c 	.word	0x57e3159c
57e08328:	57e315a9 	.word	0x57e315a9
57e0832c:	57e32390 	.word	0x57e32390
57e08330:	57e315b4 	.word	0x57e315b4
57e08334:	57e315d3 	.word	0x57e315d3
57e08338:	57e315fa 	.word	0x57e315fa

57e0833c <usb_display_string>:
		break;
	}
}

static void usb_display_string(struct usb_device *dev, int index)
{
57e0833c:	e92d4010 	push	{r4, lr}
	ALLOC_CACHE_ALIGN_BUFFER(char, buffer, 256);

	if (index != 0) {
57e08340:	e3510000 	cmp	r1, #0
		break;
	}
}

static void usb_display_string(struct usb_device *dev, int index)
{
57e08344:	e24ddd05 	sub	sp, sp, #320	; 0x140
	ALLOC_CACHE_ALIGN_BUFFER(char, buffer, 256);

	if (index != 0) {
57e08348:	0a000009 	beq	57e08374 <usb_display_string+0x38>
	}
}

static void usb_display_string(struct usb_device *dev, int index)
{
	ALLOC_CACHE_ALIGN_BUFFER(char, buffer, 256);
57e0834c:	e28d403f 	add	r4, sp, #63	; 0x3f
57e08350:	e3c4403f 	bic	r4, r4, #63	; 0x3f

	if (index != 0) {
		if (usb_string(dev, index, &buffer[0], 256) > 0)
57e08354:	e1a02004 	mov	r2, r4
57e08358:	e3a03c01 	mov	r3, #256	; 0x100
57e0835c:	eb001fae 	bl	57e1021c <usb_string>
57e08360:	e3500000 	cmp	r0, #0
57e08364:	da000002 	ble	57e08374 <usb_display_string+0x38>
			printf("String: \"%s\"", buffer);
57e08368:	e59f000c 	ldr	r0, [pc, #12]	; 57e0837c <usb_display_string+0x40>
57e0836c:	e1a01004 	mov	r1, r4
57e08370:	eb000435 	bl	57e0944c <printf>
	}
}
57e08374:	e28ddd05 	add	sp, sp, #320	; 0x140
57e08378:	e8bd8010 	pop	{r4, pc}
57e0837c:	57e3162b 	.word	0x57e3162b

57e08380 <usb_display_config>:
	printf("\n");
}

/* main routine to diasplay the configs, interfaces and endpoints */
static void usb_display_config(struct usb_device *dev)
{
57e08380:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e08384:	e1a04000 	mov	r4, r0
}

static void usb_display_conf_desc(struct usb_config_descriptor *config,
				  struct usb_device *dev)
{
	printf("   Configuration: %d\n", config->bConfigurationValue);
57e08388:	e5d41117 	ldrb	r1, [r4, #279]	; 0x117
57e0838c:	e59f01bc 	ldr	r0, [pc, #444]	; 57e08550 <usb_display_config+0x1d0>
57e08390:	eb00042d 	bl	57e0944c <printf>
	printf("   - Interfaces: %d %s%s%dmA\n", config->bNumInterfaces,
	       (config->bmAttributes & 0x40) ? "Self Powered " : "Bus Powered ",
57e08394:	e5d43119 	ldrb	r3, [r4, #281]	; 0x119

static void usb_display_conf_desc(struct usb_config_descriptor *config,
				  struct usb_device *dev)
{
	printf("   Configuration: %d\n", config->bConfigurationValue);
	printf("   - Interfaces: %d %s%s%dmA\n", config->bNumInterfaces,
57e08398:	e59f01b4 	ldr	r0, [pc, #436]	; 57e08554 <usb_display_config+0x1d4>
57e0839c:	e59f21b4 	ldr	r2, [pc, #436]	; 57e08558 <usb_display_config+0x1d8>
57e083a0:	e3130040 	tst	r3, #64	; 0x40
57e083a4:	01a02000 	moveq	r2, r0
57e083a8:	e3130020 	tst	r3, #32
57e083ac:	e5d4311a 	ldrb	r3, [r4, #282]	; 0x11a
57e083b0:	e59fc1a4 	ldr	ip, [pc, #420]	; 57e0855c <usb_display_config+0x1dc>
57e083b4:	e1a03083 	lsl	r3, r3, #1
57e083b8:	e58d3000 	str	r3, [sp]
57e083bc:	e59f319c 	ldr	r3, [pc, #412]	; 57e08560 <usb_display_config+0x1e0>
57e083c0:	e5d41116 	ldrb	r1, [r4, #278]	; 0x116
57e083c4:	01a0300c 	moveq	r3, ip
57e083c8:	e59f0194 	ldr	r0, [pc, #404]	; 57e08564 <usb_display_config+0x1e4>
57e083cc:	eb00041e 	bl	57e0944c <printf>
	       (config->bmAttributes & 0x40) ? "Self Powered " : "Bus Powered ",
	       (config->bmAttributes & 0x20) ? "Remote Wakeup " : "",
		config->bMaxPower*2);
	if (config->iConfiguration) {
57e083d0:	e5d43118 	ldrb	r3, [r4, #280]	; 0x118
57e083d4:	e3530000 	cmp	r3, #0
57e083d8:	0a000006 	beq	57e083f8 <usb_display_config+0x78>
		printf("   - ");
57e083dc:	e59f0184 	ldr	r0, [pc, #388]	; 57e08568 <usb_display_config+0x1e8>
57e083e0:	eb000419 	bl	57e0944c <printf>
		usb_display_string(dev, config->iConfiguration);
57e083e4:	e1a00004 	mov	r0, r4
57e083e8:	e5d41118 	ldrb	r1, [r4, #280]	; 0x118
57e083ec:	ebffffd2 	bl	57e0833c <usb_display_string>
		printf("\n");
57e083f0:	e59f0174 	ldr	r0, [pc, #372]	; 57e0856c <usb_display_config+0x1ec>
57e083f4:	eb000414 	bl	57e0944c <printf>
57e083f8:	e1a05004 	mov	r5, r4
		printf(" Interval %dms", epdesc->bInterval);
	printf("\n");
}

/* main routine to diasplay the configs, interfaces and endpoints */
static void usb_display_config(struct usb_device *dev)
57e083fc:	e3a0a000 	mov	sl, #0
57e08400:	e3a0b09c 	mov	fp, #156	; 0x9c
57e08404:	ea00004a 	b	57e08534 <usb_display_config+0x1b4>
}

static void usb_display_if_desc(struct usb_interface_descriptor *ifdesc,
				struct usb_device *dev)
{
	printf("     Interface: %d\n", ifdesc->bInterfaceNumber);
57e08408:	e5d5111e 	ldrb	r1, [r5, #286]	; 0x11e
57e0840c:	e59f015c 	ldr	r0, [pc, #348]	; 57e08570 <usb_display_config+0x1f0>
57e08410:	eb00040d 	bl	57e0944c <printf>
	printf("     - Alternate Setting %d, Endpoints: %d\n",
57e08414:	e5d5111f 	ldrb	r1, [r5, #287]	; 0x11f
57e08418:	e5d52120 	ldrb	r2, [r5, #288]	; 0x120
57e0841c:	e59f0150 	ldr	r0, [pc, #336]	; 57e08574 <usb_display_config+0x1f4>
57e08420:	eb000409 	bl	57e0944c <printf>
		ifdesc->bAlternateSetting, ifdesc->bNumEndpoints);
	printf("     - Class ");
57e08424:	e59f014c 	ldr	r0, [pc, #332]	; 57e08578 <usb_display_config+0x1f8>
57e08428:	eb000407 	bl	57e0944c <printf>
	usb_display_class_sub(ifdesc->bInterfaceClass,
57e0842c:	e5d50121 	ldrb	r0, [r5, #289]	; 0x121
57e08430:	e5d51122 	ldrb	r1, [r5, #290]	; 0x122
57e08434:	e5d52123 	ldrb	r2, [r5, #291]	; 0x123
57e08438:	ebfffe8f 	bl	57e07e7c <usb_display_class_sub>
		ifdesc->bInterfaceSubClass, ifdesc->bInterfaceProtocol);
	printf("\n");
57e0843c:	e59f0128 	ldr	r0, [pc, #296]	; 57e0856c <usb_display_config+0x1ec>
57e08440:	eb000401 	bl	57e0944c <printf>
	if (ifdesc->iInterface) {
57e08444:	e5d53124 	ldrb	r3, [r5, #292]	; 0x124
57e08448:	e3530000 	cmp	r3, #0
57e0844c:	0a000006 	beq	57e0846c <usb_display_config+0xec>
		printf("     - ");
57e08450:	e59f0124 	ldr	r0, [pc, #292]	; 57e0857c <usb_display_config+0x1fc>
57e08454:	eb0003fc 	bl	57e0944c <printf>
		usb_display_string(dev, ifdesc->iInterface);
57e08458:	e1a00004 	mov	r0, r4
57e0845c:	e5d51124 	ldrb	r1, [r5, #292]	; 0x124
57e08460:	ebffffb5 	bl	57e0833c <usb_display_string>
		printf("\n");
57e08464:	e59f0100 	ldr	r0, [pc, #256]	; 57e0856c <usb_display_config+0x1ec>
57e08468:	eb0003f7 	bl	57e0944c <printf>
		printf(" Interval %dms", epdesc->bInterval);
	printf("\n");
}

/* main routine to diasplay the configs, interfaces and endpoints */
static void usb_display_config(struct usb_device *dev)
57e0846c:	e0090a9b 	mul	r9, fp, sl
57e08470:	e0846009 	add	r6, r4, r9
57e08474:	e2866f47 	add	r6, r6, #284	; 0x11c
57e08478:	e3a07000 	mov	r7, #0
57e0847c:	ea000027 	b	57e08520 <usb_display_config+0x1a0>
	}
}

static void usb_display_ep_desc(struct usb_endpoint_descriptor *epdesc)
{
	printf("     - Endpoint %d %s ", epdesc->bEndpointAddress & 0xf,
57e08480:	e5d6100e 	ldrb	r1, [r6, #14]
57e08484:	e59f30f4 	ldr	r3, [pc, #244]	; 57e08580 <usb_display_config+0x200>
57e08488:	e59f20f4 	ldr	r2, [pc, #244]	; 57e08584 <usb_display_config+0x204>
57e0848c:	e3110080 	tst	r1, #128	; 0x80
57e08490:	11a02003 	movne	r2, r3
57e08494:	e59f00ec 	ldr	r0, [pc, #236]	; 57e08588 <usb_display_config+0x208>
57e08498:	e201100f 	and	r1, r1, #15
57e0849c:	eb0003ea 	bl	57e0944c <printf>
		(epdesc->bEndpointAddress & 0x80) ? "In" : "Out");
	switch ((epdesc->bmAttributes & 0x03)) {
57e084a0:	e5d6300f 	ldrb	r3, [r6, #15]
57e084a4:	e2033003 	and	r3, r3, #3
57e084a8:	e3530002 	cmp	r3, #2
		break;
	case 1:
		printf("Isochronous");
		break;
	case 2:
		printf("Bulk");
57e084ac:	059f00d8 	ldreq	r0, [pc, #216]	; 57e0858c <usb_display_config+0x20c>

static void usb_display_ep_desc(struct usb_endpoint_descriptor *epdesc)
{
	printf("     - Endpoint %d %s ", epdesc->bEndpointAddress & 0xf,
		(epdesc->bEndpointAddress & 0x80) ? "In" : "Out");
	switch ((epdesc->bmAttributes & 0x03)) {
57e084b0:	0a000005 	beq	57e084cc <usb_display_config+0x14c>
57e084b4:	e3530003 	cmp	r3, #3
		break;
	case 2:
		printf("Bulk");
		break;
	case 3:
		printf("Interrupt");
57e084b8:	059f00d0 	ldreq	r0, [pc, #208]	; 57e08590 <usb_display_config+0x210>

static void usb_display_ep_desc(struct usb_endpoint_descriptor *epdesc)
{
	printf("     - Endpoint %d %s ", epdesc->bEndpointAddress & 0xf,
		(epdesc->bEndpointAddress & 0x80) ? "In" : "Out");
	switch ((epdesc->bmAttributes & 0x03)) {
57e084bc:	0a000002 	beq	57e084cc <usb_display_config+0x14c>
57e084c0:	e3530001 	cmp	r3, #1
	case 0:
		printf("Control");
57e084c4:	159f00c8 	ldrne	r0, [pc, #200]	; 57e08594 <usb_display_config+0x214>
		break;
	case 1:
		printf("Isochronous");
57e084c8:	059f00c8 	ldreq	r0, [pc, #200]	; 57e08598 <usb_display_config+0x218>
		break;
	case 2:
		printf("Bulk");
		break;
	case 3:
		printf("Interrupt");
57e084cc:	eb0003de 	bl	57e0944c <printf>
		break;
	}
	printf(" MaxPacket %d", get_unaligned(&epdesc->wMaxPacketSize));
57e084d0:	e0873187 	add	r3, r7, r7, lsl #3
57e084d4:	e0833009 	add	r3, r3, r9
57e084d8:	e2833e12 	add	r3, r3, #288	; 0x120
57e084dc:	e0843003 	add	r3, r4, r3

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
57e084e0:	e5d3100d 	ldrb	r1, [r3, #13]
57e084e4:	e5d3300c 	ldrb	r3, [r3, #12]
57e084e8:	e59f00ac 	ldr	r0, [pc, #172]	; 57e0859c <usb_display_config+0x21c>
57e084ec:	e1831401 	orr	r1, r3, r1, lsl #8
57e084f0:	eb0003d5 	bl	57e0944c <printf>
	if ((epdesc->bmAttributes & 0x03) == 0x3)
57e084f4:	e5d6300f 	ldrb	r3, [r6, #15]
57e084f8:	e2033003 	and	r3, r3, #3
57e084fc:	e3530003 	cmp	r3, #3
57e08500:	1a000002 	bne	57e08510 <usb_display_config+0x190>
		printf(" Interval %dms", epdesc->bInterval);
57e08504:	e59f0094 	ldr	r0, [pc, #148]	; 57e085a0 <usb_display_config+0x220>
57e08508:	e5d61012 	ldrb	r1, [r6, #18]
57e0850c:	eb0003ce 	bl	57e0944c <printf>
	printf("\n");
57e08510:	e59f0054 	ldr	r0, [pc, #84]	; 57e0856c <usb_display_config+0x1ec>
57e08514:	eb0003cc 	bl	57e0944c <printf>
	config = &dev->config;
	usb_display_conf_desc(&config->desc, dev);
	for (i = 0; i < config->no_of_if; i++) {
		ifdesc = &config->if_desc[i];
		usb_display_if_desc(&ifdesc->desc, dev);
		for (ii = 0; ii < ifdesc->no_of_ep; ii++) {
57e08518:	e2877001 	add	r7, r7, #1
57e0851c:	e2866009 	add	r6, r6, #9
57e08520:	e5d53125 	ldrb	r3, [r5, #293]	; 0x125
57e08524:	e1570003 	cmp	r7, r3
57e08528:	baffffd4 	blt	57e08480 <usb_display_config+0x100>
	struct usb_endpoint_descriptor *epdesc;
	int i, ii;

	config = &dev->config;
	usb_display_conf_desc(&config->desc, dev);
	for (i = 0; i < config->no_of_if; i++) {
57e0852c:	e28aa001 	add	sl, sl, #1
57e08530:	e285509c 	add	r5, r5, #156	; 0x9c
57e08534:	e5d4311b 	ldrb	r3, [r4, #283]	; 0x11b
57e08538:	e15a0003 	cmp	sl, r3
57e0853c:	baffffb1 	blt	57e08408 <usb_display_config+0x88>
		for (ii = 0; ii < ifdesc->no_of_ep; ii++) {
			epdesc = &ifdesc->ep_desc[ii];
			usb_display_ep_desc(epdesc);
		}
	}
	printf("\n");
57e08540:	e59f0024 	ldr	r0, [pc, #36]	; 57e0856c <usb_display_config+0x1ec>
}
57e08544:	e28dd008 	add	sp, sp, #8
57e08548:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
		for (ii = 0; ii < ifdesc->no_of_ep; ii++) {
			epdesc = &ifdesc->ep_desc[ii];
			usb_display_ep_desc(epdesc);
		}
	}
	printf("\n");
57e0854c:	ea0003be 	b	57e0944c <printf>
57e08550:	57e31669 	.word	0x57e31669
57e08554:	57e31646 	.word	0x57e31646
57e08558:	57e31638 	.word	0x57e31638
57e0855c:	57e302de 	.word	0x57e302de
57e08560:	57e31653 	.word	0x57e31653
57e08564:	57e3167f 	.word	0x57e3167f
57e08568:	57e316ed 	.word	0x57e316ed
57e0856c:	57e32390 	.word	0x57e32390
57e08570:	57e3169d 	.word	0x57e3169d
57e08574:	57e316b1 	.word	0x57e316b1
57e08578:	57e316dd 	.word	0x57e316dd
57e0857c:	57e316eb 	.word	0x57e316eb
57e08580:	57e31662 	.word	0x57e31662
57e08584:	57e31665 	.word	0x57e31665
57e08588:	57e316f3 	.word	0x57e316f3
57e0858c:	57e31522 	.word	0x57e31522
57e08590:	57e3171e 	.word	0x57e3171e
57e08594:	57e3170a 	.word	0x57e3170a
57e08598:	57e31712 	.word	0x57e31712
57e0859c:	57e31728 	.word	0x57e31728
57e085a0:	57e31736 	.word	0x57e31736

57e085a4 <do_usb>:

/******************************************************************************
 * usb command intepreter
 */
static int do_usb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e085a4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	extern char usb_started;
#ifdef CONFIG_USB_STORAGE
	block_dev_desc_t *stor_dev;
#endif

	if (argc < 2)
57e085a8:	e3520001 	cmp	r2, #1

/******************************************************************************
 * usb command intepreter
 */
static int do_usb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e085ac:	e24dd020 	sub	sp, sp, #32
57e085b0:	e1a06002 	mov	r6, r2
57e085b4:	e1a07003 	mov	r7, r3
	extern char usb_started;
#ifdef CONFIG_USB_STORAGE
	block_dev_desc_t *stor_dev;
#endif

	if (argc < 2)
57e085b8:	da00012c 	ble	57e08a70 <do_usb+0x4cc>
		return CMD_RET_USAGE;

	if ((strncmp(argv[1], "reset", 5) == 0) ||
57e085bc:	e5930004 	ldr	r0, [r3, #4]
57e085c0:	e59f14d8 	ldr	r1, [pc, #1240]	; 57e08aa0 <do_usb+0x4fc>
57e085c4:	e3a02005 	mov	r2, #5
57e085c8:	eb006e81 	bl	57e23fd4 <strncmp>
57e085cc:	e3500000 	cmp	r0, #0
57e085d0:	0a000005 	beq	57e085ec <do_usb+0x48>
		 (strncmp(argv[1], "start", 5) == 0)) {
57e085d4:	e5970004 	ldr	r0, [r7, #4]
57e085d8:	e59f14c4 	ldr	r1, [pc, #1220]	; 57e08aa4 <do_usb+0x500>
57e085dc:	e3a02005 	mov	r2, #5
57e085e0:	eb006e7b 	bl	57e23fd4 <strncmp>
#endif

	if (argc < 2)
		return CMD_RET_USAGE;

	if ((strncmp(argv[1], "reset", 5) == 0) ||
57e085e4:	e3500000 	cmp	r0, #0
57e085e8:	1a00000a 	bne	57e08618 <do_usb+0x74>
		 (strncmp(argv[1], "start", 5) == 0)) {
		bootstage_mark_name(BOOTSTAGE_ID_USB_START, "usb_start");
		usb_stop();
57e085ec:	eb001d3c 	bl	57e0fae4 <usb_stop>
		printf("(Re)start USB...\n");
57e085f0:	e59f04b0 	ldr	r0, [pc, #1200]	; 57e08aa8 <do_usb+0x504>
57e085f4:	eb000394 	bl	57e0944c <printf>
		if (usb_init() >= 0) {
57e085f8:	eb0020c2 	bl	57e10908 <usb_init>
57e085fc:	e3500000 	cmp	r0, #0
57e08600:	ba000124 	blt	57e08a98 <do_usb+0x4f4>
#ifdef CONFIG_USB_STORAGE
			/* try to recognize storage devices immediately */
			usb_stor_curr_dev = usb_stor_scan(1);
57e08604:	e3a00001 	mov	r0, #1
57e08608:	eb0027a1 	bl	57e12494 <usb_stor_scan>
57e0860c:	e59f3498 	ldr	r3, [pc, #1176]	; 57e08aac <do_usb+0x508>
57e08610:	e5830000 	str	r0, [r3]
57e08614:	ea00011f 	b	57e08a98 <do_usb+0x4f4>
			drv_usb_kbd_init();
#endif
		}
		return 0;
	}
	if (strncmp(argv[1], "stop", 4) == 0) {
57e08618:	e5970004 	ldr	r0, [r7, #4]
57e0861c:	e59f148c 	ldr	r1, [pc, #1164]	; 57e08ab0 <do_usb+0x50c>
57e08620:	e3a02004 	mov	r2, #4
57e08624:	eb006e6a 	bl	57e23fd4 <strncmp>
57e08628:	e2504000 	subs	r4, r0, #0
57e0862c:	1a000003 	bne	57e08640 <do_usb+0x9c>
			/* forced stop, switch console in to serial */
			console_assign(stdin, "serial");
			usb_kbd_deregister();
		}
#endif
		printf("stopping USB..\n");
57e08630:	e59f047c 	ldr	r0, [pc, #1148]	; 57e08ab4 <do_usb+0x510>
57e08634:	eb000384 	bl	57e0944c <printf>
		usb_stop();
57e08638:	eb001d29 	bl	57e0fae4 <usb_stop>
		return 0;
57e0863c:	ea00010e 	b	57e08a7c <do_usb+0x4d8>
	}
	if (!usb_started) {
57e08640:	e59f3470 	ldr	r3, [pc, #1136]	; 57e08ab8 <do_usb+0x514>
57e08644:	e5d33000 	ldrb	r3, [r3]
57e08648:	e3530000 	cmp	r3, #0
		printf("USB is stopped. Please issue 'usb start' first.\n");
57e0864c:	059f0468 	ldreq	r0, [pc, #1128]	; 57e08abc <do_usb+0x518>
#endif
		printf("stopping USB..\n");
		usb_stop();
		return 0;
	}
	if (!usb_started) {
57e08650:	0a0000ea 	beq	57e08a00 <do_usb+0x45c>
		printf("USB is stopped. Please issue 'usb start' first.\n");
		return 1;
	}
	if (strncmp(argv[1], "tree", 4) == 0) {
57e08654:	e5970004 	ldr	r0, [r7, #4]
57e08658:	e59f1460 	ldr	r1, [pc, #1120]	; 57e08ac0 <do_usb+0x51c>
57e0865c:	e3a02004 	mov	r2, #4
57e08660:	eb006e5b 	bl	57e23fd4 <strncmp>
57e08664:	e2505000 	subs	r5, r0, #0
57e08668:	1a000013 	bne	57e086bc <do_usb+0x118>
		puts("USB device tree:\n");
57e0866c:	e59f0450 	ldr	r0, [pc, #1104]	; 57e08ac4 <do_usb+0x520>
57e08670:	eb00036b 	bl	57e09424 <puts>
/* main routine for the tree command */
static void usb_show_tree(struct usb_device *dev)
{
	char preamble[32];

	memset(preamble, 0, 32);
57e08674:	e1a0600d 	mov	r6, sp
		return 1;
	}
	if (strncmp(argv[1], "tree", 4) == 0) {
		puts("USB device tree:\n");
		for (i = 0; i < USB_MAX_DEVICE; i++) {
			dev = usb_get_dev_index(i);
57e08678:	e1a00005 	mov	r0, r5
57e0867c:	eb001f26 	bl	57e1031c <usb_get_dev_index>
			if (dev == NULL)
57e08680:	e2504000 	subs	r4, r0, #0
57e08684:	0a0000fc 	beq	57e08a7c <do_usb+0x4d8>
				break;
			if (dev->parent == NULL)
57e08688:	e5941624 	ldr	r1, [r4, #1572]	; 0x624
57e0868c:	e3510000 	cmp	r1, #0
57e08690:	1a000005 	bne	57e086ac <do_usb+0x108>
/* main routine for the tree command */
static void usb_show_tree(struct usb_device *dev)
{
	char preamble[32];

	memset(preamble, 0, 32);
57e08694:	e1a0000d 	mov	r0, sp
57e08698:	e3a02020 	mov	r2, #32
57e0869c:	eb006ef6 	bl	57e2427c <memset>
	usb_show_tree_graph(dev, &preamble[0]);
57e086a0:	e1a00004 	mov	r0, r4
57e086a4:	e1a0100d 	mov	r1, sp
57e086a8:	ebfffe50 	bl	57e07ff0 <usb_show_tree_graph>
		printf("USB is stopped. Please issue 'usb start' first.\n");
		return 1;
	}
	if (strncmp(argv[1], "tree", 4) == 0) {
		puts("USB device tree:\n");
		for (i = 0; i < USB_MAX_DEVICE; i++) {
57e086ac:	e2855001 	add	r5, r5, #1
57e086b0:	e3550020 	cmp	r5, #32
57e086b4:	1affffef 	bne	57e08678 <do_usb+0xd4>
57e086b8:	ea0000f6 	b	57e08a98 <do_usb+0x4f4>
			if (dev->parent == NULL)
				usb_show_tree(dev);
		}
		return 0;
	}
	if (strncmp(argv[1], "inf", 3) == 0) {
57e086bc:	e5970004 	ldr	r0, [r7, #4]
57e086c0:	e59f1400 	ldr	r1, [pc, #1024]	; 57e08ac8 <do_usb+0x524>
57e086c4:	e3a02003 	mov	r2, #3
57e086c8:	eb006e41 	bl	57e23fd4 <strncmp>
57e086cc:	e2504000 	subs	r4, r0, #0
57e086d0:	1a000024 	bne	57e08768 <do_usb+0x1c4>
		int d;
		if (argc == 2) {
57e086d4:	e3560002 	cmp	r6, #2
57e086d8:	1a00000b 	bne	57e0870c <do_usb+0x168>
57e086dc:	e1a06004 	mov	r6, r4
			for (d = 0; d < USB_MAX_DEVICE; d++) {
				dev = usb_get_dev_index(d);
57e086e0:	e1a00006 	mov	r0, r6
57e086e4:	eb001f0c 	bl	57e1031c <usb_get_dev_index>
				if (dev == NULL)
57e086e8:	e2504000 	subs	r4, r0, #0
57e086ec:	0a0000e2 	beq	57e08a7c <do_usb+0x4d8>
					break;
				usb_display_desc(dev);
57e086f0:	ebfffec6 	bl	57e08210 <usb_display_desc>
		return 0;
	}
	if (strncmp(argv[1], "inf", 3) == 0) {
		int d;
		if (argc == 2) {
			for (d = 0; d < USB_MAX_DEVICE; d++) {
57e086f4:	e2866001 	add	r6, r6, #1
				dev = usb_get_dev_index(d);
				if (dev == NULL)
					break;
				usb_display_desc(dev);
				usb_display_config(dev);
57e086f8:	e1a00004 	mov	r0, r4
57e086fc:	ebffff1f 	bl	57e08380 <usb_display_config>
		return 0;
	}
	if (strncmp(argv[1], "inf", 3) == 0) {
		int d;
		if (argc == 2) {
			for (d = 0; d < USB_MAX_DEVICE; d++) {
57e08700:	e3560020 	cmp	r6, #32
57e08704:	1afffff5 	bne	57e086e0 <do_usb+0x13c>
57e08708:	ea0000e2 	b	57e08a98 <do_usb+0x4f4>
			}
			return 0;
		} else {
			int d;

			i = simple_strtoul(argv[2], NULL, 16);
57e0870c:	e1a01004 	mov	r1, r4
57e08710:	e5970008 	ldr	r0, [r7, #8]
57e08714:	e3a02010 	mov	r2, #16
57e08718:	eb007261 	bl	57e250a4 <simple_strtoul>
57e0871c:	e1a06000 	mov	r6, r0
			printf("config for device %d\n", i);
57e08720:	e1a01006 	mov	r1, r6
57e08724:	e59f03a0 	ldr	r0, [pc, #928]	; 57e08acc <do_usb+0x528>
57e08728:	eb000347 	bl	57e0944c <printf>
			for (d = 0; d < USB_MAX_DEVICE; d++) {
				dev = usb_get_dev_index(d);
57e0872c:	e1a00004 	mov	r0, r4
57e08730:	eb001ef9 	bl	57e1031c <usb_get_dev_index>
				if (dev == NULL)
57e08734:	e2505000 	subs	r5, r0, #0
57e08738:	0a000006 	beq	57e08758 <do_usb+0x1b4>
					break;
				if (dev->devnum == i)
57e0873c:	e5953000 	ldr	r3, [r5]
57e08740:	e1530006 	cmp	r3, r6
57e08744:	0a0000cf 	beq	57e08a88 <do_usb+0x4e4>
		} else {
			int d;

			i = simple_strtoul(argv[2], NULL, 16);
			printf("config for device %d\n", i);
			for (d = 0; d < USB_MAX_DEVICE; d++) {
57e08748:	e2844001 	add	r4, r4, #1
57e0874c:	e3540020 	cmp	r4, #32
57e08750:	1afffff5 	bne	57e0872c <do_usb+0x188>
57e08754:	ea0000cb 	b	57e08a88 <do_usb+0x4e4>
					break;
				if (dev->devnum == i)
					break;
			}
			if (dev == NULL) {
				printf("*** No device available ***\n");
57e08758:	e59f0370 	ldr	r0, [pc, #880]	; 57e08ad0 <do_usb+0x52c>
57e0875c:	eb00033a 	bl	57e0944c <printf>
				return 0;
57e08760:	e1a04005 	mov	r4, r5
57e08764:	ea0000c4 	b	57e08a7c <do_usb+0x4d8>
			}
		}
		return 0;
	}
#ifdef CONFIG_USB_STORAGE
	if (strncmp(argv[1], "stor", 4) == 0)
57e08768:	e5970004 	ldr	r0, [r7, #4]
57e0876c:	e59f1360 	ldr	r1, [pc, #864]	; 57e08ad4 <do_usb+0x530>
57e08770:	e3a02004 	mov	r2, #4
57e08774:	eb006e16 	bl	57e23fd4 <strncmp>
57e08778:	e3500000 	cmp	r0, #0
57e0877c:	1a000002 	bne	57e0878c <do_usb+0x1e8>
		return usb_stor_info();
57e08780:	eb0025cb 	bl	57e11eb4 <usb_stor_info>
57e08784:	e1a04000 	mov	r4, r0
57e08788:	ea0000bb 	b	57e08a7c <do_usb+0x4d8>

	if (strncmp(argv[1], "part", 4) == 0) {
57e0878c:	e5970004 	ldr	r0, [r7, #4]
57e08790:	e59f1340 	ldr	r1, [pc, #832]	; 57e08ad8 <do_usb+0x534>
57e08794:	e3a02004 	mov	r2, #4
57e08798:	eb006e0d 	bl	57e23fd4 <strncmp>
57e0879c:	e3500000 	cmp	r0, #0
57e087a0:	1a000023 	bne	57e08834 <do_usb+0x290>
		int devno, ok = 0;
		if (argc == 2) {
57e087a4:	e3560002 	cmp	r6, #2
57e087a8:	1a000011 	bne	57e087f4 <do_usb+0x250>
57e087ac:	e3a06000 	mov	r6, #0
57e087b0:	e1a07006 	mov	r7, r6
			for (devno = 0; ; ++devno) {
				stor_dev = usb_stor_get_dev(devno);
57e087b4:	e1a00007 	mov	r0, r7
57e087b8:	eb0025b5 	bl	57e11e94 <usb_stor_get_dev>
				if (stor_dev == NULL)
57e087bc:	e2504000 	subs	r4, r0, #0
57e087c0:	0a000017 	beq	57e08824 <do_usb+0x280>
					break;
				if (stor_dev->type != DEV_TYPE_UNKNOWN) {
57e087c4:	e5d4300b 	ldrb	r3, [r4, #11]
57e087c8:	e35300ff 	cmp	r3, #255	; 0xff
57e087cc:	0a000006 	beq	57e087ec <do_usb+0x248>
					ok++;
					if (devno)
57e087d0:	e3570000 	cmp	r7, #0
			for (devno = 0; ; ++devno) {
				stor_dev = usb_stor_get_dev(devno);
				if (stor_dev == NULL)
					break;
				if (stor_dev->type != DEV_TYPE_UNKNOWN) {
					ok++;
57e087d4:	e2866001 	add	r6, r6, #1
					if (devno)
57e087d8:	0a000001 	beq	57e087e4 <do_usb+0x240>
						printf("\n");
57e087dc:	e59f02f8 	ldr	r0, [pc, #760]	; 57e08adc <do_usb+0x538>
57e087e0:	eb000319 	bl	57e0944c <printf>
					debug("print_part of %x\n", devno);
					print_part(stor_dev);
57e087e4:	e1a00004 	mov	r0, r4
57e087e8:	eb002a64 	bl	57e13180 <print_part>
		return usb_stor_info();

	if (strncmp(argv[1], "part", 4) == 0) {
		int devno, ok = 0;
		if (argc == 2) {
			for (devno = 0; ; ++devno) {
57e087ec:	e2877001 	add	r7, r7, #1
					if (devno)
						printf("\n");
					debug("print_part of %x\n", devno);
					print_part(stor_dev);
				}
			}
57e087f0:	eaffffef 	b	57e087b4 <do_usb+0x210>
		} else {
			devno = simple_strtoul(argv[2], NULL, 16);
57e087f4:	e3a01000 	mov	r1, #0
57e087f8:	e3a02010 	mov	r2, #16
57e087fc:	e5970008 	ldr	r0, [r7, #8]
57e08800:	eb007227 	bl	57e250a4 <simple_strtoul>
			stor_dev = usb_stor_get_dev(devno);
57e08804:	eb0025a2 	bl	57e11e94 <usb_stor_get_dev>
			if (stor_dev != NULL &&
57e08808:	e2503000 	subs	r3, r0, #0
57e0880c:	0a000006 	beq	57e0882c <do_usb+0x288>
57e08810:	e5d3300b 	ldrb	r3, [r3, #11]
57e08814:	e35300ff 	cmp	r3, #255	; 0xff
57e08818:	0a000003 	beq	57e0882c <do_usb+0x288>
			    stor_dev->type != DEV_TYPE_UNKNOWN) {
				ok++;
				debug("print_part of %x\n", devno);
				print_part(stor_dev);
57e0881c:	eb002a57 	bl	57e13180 <print_part>
57e08820:	ea00009c 	b	57e08a98 <do_usb+0x4f4>
			}
		}
		if (!ok) {
57e08824:	e3560000 	cmp	r6, #0
57e08828:	1a000093 	bne	57e08a7c <do_usb+0x4d8>
			printf("\nno USB devices available\n");
57e0882c:	e59f02ac 	ldr	r0, [pc, #684]	; 57e08ae0 <do_usb+0x53c>
57e08830:	ea000072 	b	57e08a00 <do_usb+0x45c>
			return 1;
		}
		return 0;
	}
	if (strcmp(argv[1], "read") == 0) {
57e08834:	e5970004 	ldr	r0, [r7, #4]
57e08838:	e59f12a4 	ldr	r1, [pc, #676]	; 57e08ae4 <do_usb+0x540>
57e0883c:	eb006dd8 	bl	57e23fa4 <strcmp>
57e08840:	e3500000 	cmp	r0, #0
57e08844:	1a000024 	bne	57e088dc <do_usb+0x338>
		if (usb_stor_curr_dev < 0) {
57e08848:	e59f525c 	ldr	r5, [pc, #604]	; 57e08aac <do_usb+0x508>
57e0884c:	e5953000 	ldr	r3, [r5]
57e08850:	e3530000 	cmp	r3, #0
57e08854:	ba000029 	blt	57e08900 <do_usb+0x35c>
			printf("no current device selected\n");
			return 1;
		}
		if (argc == 5) {
57e08858:	e3560005 	cmp	r6, #5
57e0885c:	1a00001e 	bne	57e088dc <do_usb+0x338>
			unsigned long addr = simple_strtoul(argv[2], NULL, 16);
57e08860:	e3a01000 	mov	r1, #0
57e08864:	e3a02010 	mov	r2, #16
57e08868:	e5970008 	ldr	r0, [r7, #8]
57e0886c:	eb00720c 	bl	57e250a4 <simple_strtoul>
			unsigned long blk  = simple_strtoul(argv[3], NULL, 16);
57e08870:	e3a01000 	mov	r1, #0
		if (usb_stor_curr_dev < 0) {
			printf("no current device selected\n");
			return 1;
		}
		if (argc == 5) {
			unsigned long addr = simple_strtoul(argv[2], NULL, 16);
57e08874:	e1a0a000 	mov	sl, r0
			unsigned long blk  = simple_strtoul(argv[3], NULL, 16);
57e08878:	e3a02010 	mov	r2, #16
57e0887c:	e597000c 	ldr	r0, [r7, #12]
57e08880:	eb007207 	bl	57e250a4 <simple_strtoul>
			unsigned long cnt  = simple_strtoul(argv[4], NULL, 16);
57e08884:	e3a01000 	mov	r1, #0
			printf("no current device selected\n");
			return 1;
		}
		if (argc == 5) {
			unsigned long addr = simple_strtoul(argv[2], NULL, 16);
			unsigned long blk  = simple_strtoul(argv[3], NULL, 16);
57e08888:	e1a06000 	mov	r6, r0
			unsigned long cnt  = simple_strtoul(argv[4], NULL, 16);
57e0888c:	e3a02010 	mov	r2, #16
57e08890:	e5970010 	ldr	r0, [r7, #16]
57e08894:	eb007202 	bl	57e250a4 <simple_strtoul>
57e08898:	e1a04000 	mov	r4, r0
			unsigned long n;
			printf("\nUSB read: device %d block # %ld, count %ld"
57e0889c:	e5951000 	ldr	r1, [r5]
57e088a0:	e1a02006 	mov	r2, r6
57e088a4:	e1a03004 	mov	r3, r4
57e088a8:	e59f0238 	ldr	r0, [pc, #568]	; 57e08ae8 <do_usb+0x544>
57e088ac:	eb0002e6 	bl	57e0944c <printf>
				" ... ", usb_stor_curr_dev, blk, cnt);
			stor_dev = usb_stor_get_dev(usb_stor_curr_dev);
57e088b0:	e5950000 	ldr	r0, [r5]
57e088b4:	eb002576 	bl	57e11e94 <usb_stor_get_dev>
			n = stor_dev->block_read(usb_stor_curr_dev, blk, cnt,
57e088b8:	e1a01006 	mov	r1, r6
57e088bc:	e590c060 	ldr	ip, [r0, #96]	; 0x60
57e088c0:	e1a02004 	mov	r2, r4
57e088c4:	e5950000 	ldr	r0, [r5]
57e088c8:	e1a0300a 	mov	r3, sl
57e088cc:	e12fff3c 	blx	ip
57e088d0:	e1a05000 	mov	r5, r0
						 (ulong *)addr);
			printf("%ld blocks read: %s\n", n,
57e088d4:	e59f0210 	ldr	r0, [pc, #528]	; 57e08aec <do_usb+0x548>
57e088d8:	ea00002a 	b	57e08988 <do_usb+0x3e4>
			if (n == cnt)
				return 0;
			return 1;
		}
	}
	if (strcmp(argv[1], "write") == 0) {
57e088dc:	e5970004 	ldr	r0, [r7, #4]
57e088e0:	e59f1208 	ldr	r1, [pc, #520]	; 57e08af0 <do_usb+0x54c>
57e088e4:	eb006dae 	bl	57e23fa4 <strcmp>
57e088e8:	e2504000 	subs	r4, r0, #0
57e088ec:	1a00002e 	bne	57e089ac <do_usb+0x408>
		if (usb_stor_curr_dev < 0) {
57e088f0:	e59f51b4 	ldr	r5, [pc, #436]	; 57e08aac <do_usb+0x508>
57e088f4:	e5953000 	ldr	r3, [r5]
57e088f8:	e3530000 	cmp	r3, #0
57e088fc:	aa000001 	bge	57e08908 <do_usb+0x364>
			printf("no current device selected\n");
57e08900:	e59f01ec 	ldr	r0, [pc, #492]	; 57e08af4 <do_usb+0x550>
57e08904:	ea00003d 	b	57e08a00 <do_usb+0x45c>
			return 1;
		}
		if (argc == 5) {
57e08908:	e3560005 	cmp	r6, #5
57e0890c:	1a000026 	bne	57e089ac <do_usb+0x408>
			unsigned long addr = simple_strtoul(argv[2], NULL, 16);
57e08910:	e1a01004 	mov	r1, r4
57e08914:	e3a02010 	mov	r2, #16
57e08918:	e5970008 	ldr	r0, [r7, #8]
57e0891c:	eb0071e0 	bl	57e250a4 <simple_strtoul>
			unsigned long blk  = simple_strtoul(argv[3], NULL, 16);
57e08920:	e1a01004 	mov	r1, r4
		if (usb_stor_curr_dev < 0) {
			printf("no current device selected\n");
			return 1;
		}
		if (argc == 5) {
			unsigned long addr = simple_strtoul(argv[2], NULL, 16);
57e08924:	e1a0a000 	mov	sl, r0
			unsigned long blk  = simple_strtoul(argv[3], NULL, 16);
57e08928:	e3a02010 	mov	r2, #16
57e0892c:	e597000c 	ldr	r0, [r7, #12]
57e08930:	eb0071db 	bl	57e250a4 <simple_strtoul>
			unsigned long cnt  = simple_strtoul(argv[4], NULL, 16);
57e08934:	e1a01004 	mov	r1, r4
			printf("no current device selected\n");
			return 1;
		}
		if (argc == 5) {
			unsigned long addr = simple_strtoul(argv[2], NULL, 16);
			unsigned long blk  = simple_strtoul(argv[3], NULL, 16);
57e08938:	e1a06000 	mov	r6, r0
			unsigned long cnt  = simple_strtoul(argv[4], NULL, 16);
57e0893c:	e3a02010 	mov	r2, #16
57e08940:	e5970010 	ldr	r0, [r7, #16]
57e08944:	eb0071d6 	bl	57e250a4 <simple_strtoul>
57e08948:	e1a04000 	mov	r4, r0
			unsigned long n;
			printf("\nUSB write: device %d block # %ld, count %ld"
57e0894c:	e5951000 	ldr	r1, [r5]
57e08950:	e1a02006 	mov	r2, r6
57e08954:	e1a03004 	mov	r3, r4
57e08958:	e59f0198 	ldr	r0, [pc, #408]	; 57e08af8 <do_usb+0x554>
57e0895c:	eb0002ba 	bl	57e0944c <printf>
				" ... ", usb_stor_curr_dev, blk, cnt);
			stor_dev = usb_stor_get_dev(usb_stor_curr_dev);
57e08960:	e5950000 	ldr	r0, [r5]
57e08964:	eb00254a 	bl	57e11e94 <usb_stor_get_dev>
			n = stor_dev->block_write(usb_stor_curr_dev, blk, cnt,
57e08968:	e1a01006 	mov	r1, r6
57e0896c:	e590c064 	ldr	ip, [r0, #100]	; 0x64
57e08970:	e1a02004 	mov	r2, r4
57e08974:	e5950000 	ldr	r0, [r5]
57e08978:	e1a0300a 	mov	r3, sl
57e0897c:	e12fff3c 	blx	ip
57e08980:	e1a05000 	mov	r5, r0
						(ulong *)addr);
			printf("%ld blocks write: %s\n", n,
57e08984:	e59f0170 	ldr	r0, [pc, #368]	; 57e08afc <do_usb+0x558>
57e08988:	e59f3170 	ldr	r3, [pc, #368]	; 57e08b00 <do_usb+0x55c>
57e0898c:	e1550004 	cmp	r5, r4
57e08990:	e59f216c 	ldr	r2, [pc, #364]	; 57e08b04 <do_usb+0x560>
57e08994:	e1a01005 	mov	r1, r5
57e08998:	01a02003 	moveq	r2, r3
57e0899c:	eb0002aa 	bl	57e0944c <printf>
#ifdef CONFIG_USB_STORAGE
	block_dev_desc_t *stor_dev;
#endif

	if (argc < 2)
		return CMD_RET_USAGE;
57e089a0:	e0554004 	subs	r4, r5, r4
57e089a4:	13a04001 	movne	r4, #1
57e089a8:	ea000033 	b	57e08a7c <do_usb+0x4d8>
			if (n == cnt)
				return 0;
			return 1;
		}
	}
	if (strncmp(argv[1], "dev", 3) == 0) {
57e089ac:	e5970004 	ldr	r0, [r7, #4]
57e089b0:	e59f1150 	ldr	r1, [pc, #336]	; 57e08b08 <do_usb+0x564>
57e089b4:	e3a02003 	mov	r2, #3
57e089b8:	eb006d85 	bl	57e23fd4 <strncmp>
57e089bc:	e2504000 	subs	r4, r0, #0
57e089c0:	1a00002a 	bne	57e08a70 <do_usb+0x4cc>
		if (argc == 3) {
57e089c4:	e3560003 	cmp	r6, #3
57e089c8:	1a00001b 	bne	57e08a3c <do_usb+0x498>
			int dev = (int)simple_strtoul(argv[2], NULL, 10);
57e089cc:	e3a0200a 	mov	r2, #10
57e089d0:	e1a01004 	mov	r1, r4
57e089d4:	e5970008 	ldr	r0, [r7, #8]
57e089d8:	eb0071b1 	bl	57e250a4 <simple_strtoul>
57e089dc:	e1a05000 	mov	r5, r0
			printf("\nUSB device %d: ", dev);
57e089e0:	e1a01005 	mov	r1, r5
57e089e4:	e59f0120 	ldr	r0, [pc, #288]	; 57e08b0c <do_usb+0x568>
57e089e8:	eb000297 	bl	57e0944c <printf>
			stor_dev = usb_stor_get_dev(dev);
57e089ec:	e1a00005 	mov	r0, r5
57e089f0:	eb002527 	bl	57e11e94 <usb_stor_get_dev>
			if (stor_dev == NULL) {
57e089f4:	e2506000 	subs	r6, r0, #0
57e089f8:	1a000002 	bne	57e08a08 <do_usb+0x464>
				printf("unknown device\n");
57e089fc:	e59f010c 	ldr	r0, [pc, #268]	; 57e08b10 <do_usb+0x56c>
57e08a00:	eb000291 	bl	57e0944c <printf>
57e08a04:	ea00001b 	b	57e08a78 <do_usb+0x4d4>
				return 1;
			}
			printf("\n    Device %d: ", dev);
57e08a08:	e1a01005 	mov	r1, r5
57e08a0c:	e59f0100 	ldr	r0, [pc, #256]	; 57e08b14 <do_usb+0x570>
57e08a10:	eb00028d 	bl	57e0944c <printf>
			dev_print(stor_dev);
57e08a14:	e1a00006 	mov	r0, r6
57e08a18:	eb002948 	bl	57e12f40 <dev_print>
			if (stor_dev->type == DEV_TYPE_UNKNOWN)
57e08a1c:	e5d6300b 	ldrb	r3, [r6, #11]
57e08a20:	e35300ff 	cmp	r3, #255	; 0xff
57e08a24:	0a000013 	beq	57e08a78 <do_usb+0x4d4>
				return 1;
			usb_stor_curr_dev = dev;
57e08a28:	e59f307c 	ldr	r3, [pc, #124]	; 57e08aac <do_usb+0x508>
			printf("... is now current device\n");
57e08a2c:	e59f00e4 	ldr	r0, [pc, #228]	; 57e08b18 <do_usb+0x574>
			}
			printf("\n    Device %d: ", dev);
			dev_print(stor_dev);
			if (stor_dev->type == DEV_TYPE_UNKNOWN)
				return 1;
			usb_stor_curr_dev = dev;
57e08a30:	e5835000 	str	r5, [r3]
			printf("... is now current device\n");
57e08a34:	eb000284 	bl	57e0944c <printf>
			return 0;
57e08a38:	ea00000f 	b	57e08a7c <do_usb+0x4d8>
		} else {
			printf("\nUSB device %d: ", usb_stor_curr_dev);
57e08a3c:	e59f4068 	ldr	r4, [pc, #104]	; 57e08aac <do_usb+0x508>
57e08a40:	e59f00c4 	ldr	r0, [pc, #196]	; 57e08b0c <do_usb+0x568>
57e08a44:	e5941000 	ldr	r1, [r4]
57e08a48:	eb00027f 	bl	57e0944c <printf>
			stor_dev = usb_stor_get_dev(usb_stor_curr_dev);
57e08a4c:	e5940000 	ldr	r0, [r4]
57e08a50:	eb00250f 	bl	57e11e94 <usb_stor_get_dev>
57e08a54:	e1a04000 	mov	r4, r0
			dev_print(stor_dev);
57e08a58:	eb002938 	bl	57e12f40 <dev_print>
#ifdef CONFIG_USB_STORAGE
	block_dev_desc_t *stor_dev;
#endif

	if (argc < 2)
		return CMD_RET_USAGE;
57e08a5c:	e5d4400b 	ldrb	r4, [r4, #11]
57e08a60:	e35400ff 	cmp	r4, #255	; 0xff
57e08a64:	13a04000 	movne	r4, #0
57e08a68:	03a04001 	moveq	r4, #1
57e08a6c:	ea000002 	b	57e08a7c <do_usb+0x4d8>
			return 0;
		}
		return 0;
	}
#endif /* CONFIG_USB_STORAGE */
	return CMD_RET_USAGE;
57e08a70:	e3e04000 	mvn	r4, #0
57e08a74:	ea000000 	b	57e08a7c <do_usb+0x4d8>
				return 1;
			}
			printf("\n    Device %d: ", dev);
			dev_print(stor_dev);
			if (stor_dev->type == DEV_TYPE_UNKNOWN)
				return 1;
57e08a78:	e3a04001 	mov	r4, #1
		}
		return 0;
	}
#endif /* CONFIG_USB_STORAGE */
	return CMD_RET_USAGE;
}
57e08a7c:	e1a00004 	mov	r0, r4
57e08a80:	e28dd020 	add	sp, sp, #32
57e08a84:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
			}
			if (dev == NULL) {
				printf("*** No device available ***\n");
				return 0;
			} else {
				usb_display_desc(dev);
57e08a88:	e1a00005 	mov	r0, r5
57e08a8c:	ebfffddf 	bl	57e08210 <usb_display_desc>
				usb_display_config(dev);
57e08a90:	e1a00005 	mov	r0, r5
57e08a94:	ebfffe39 	bl	57e08380 <usb_display_config>
			}
		}
		return 0;
57e08a98:	e3a04000 	mov	r4, #0
57e08a9c:	eafffff6 	b	57e08a7c <do_usb+0x4d8>
57e08aa0:	57e2e59d 	.word	0x57e2e59d
57e08aa4:	57e2e423 	.word	0x57e2e423
57e08aa8:	57e31745 	.word	0x57e31745
57e08aac:	57e36954 	.word	0x57e36954
57e08ab0:	57e31757 	.word	0x57e31757
57e08ab4:	57e3175c 	.word	0x57e3175c
57e08ab8:	57e39c40 	.word	0x57e39c40
57e08abc:	57e3176c 	.word	0x57e3176c
57e08ac0:	57e3179d 	.word	0x57e3179d
57e08ac4:	57e317a2 	.word	0x57e317a2
57e08ac8:	57e317b4 	.word	0x57e317b4
57e08acc:	57e317b8 	.word	0x57e317b8
57e08ad0:	57e317ce 	.word	0x57e317ce
57e08ad4:	57e317eb 	.word	0x57e317eb
57e08ad8:	57e30964 	.word	0x57e30964
57e08adc:	57e32390 	.word	0x57e32390
57e08ae0:	57e317f0 	.word	0x57e317f0
57e08ae4:	57e3095e 	.word	0x57e3095e
57e08ae8:	57e31827 	.word	0x57e31827
57e08aec:	57e31858 	.word	0x57e31858
57e08af0:	57e308c1 	.word	0x57e308c1
57e08af4:	57e3180b 	.word	0x57e3180b
57e08af8:	57e3186d 	.word	0x57e3186d
57e08afc:	57e3189f 	.word	0x57e3189f
57e08b00:	57e308be 	.word	0x57e308be
57e08b04:	57e308b8 	.word	0x57e308b8
57e08b08:	57e318b5 	.word	0x57e318b5
57e08b0c:	57e318b9 	.word	0x57e318b9
57e08b10:	57e318ca 	.word	0x57e318ca
57e08b14:	57e318da 	.word	0x57e318da
57e08b18:	57e308f8 	.word	0x57e308f8

57e08b1c <do_version>:
#endif

const char __weak version_string[] = U_BOOT_VERSION_STRING;

static int do_version(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
57e08b1c:	e92d4008 	push	{r3, lr}
	printf("\n%s\n", version_string);
57e08b20:	e59f101c 	ldr	r1, [pc, #28]	; 57e08b44 <do_version+0x28>
57e08b24:	e59f001c 	ldr	r0, [pc, #28]	; 57e08b48 <do_version+0x2c>
57e08b28:	eb000247 	bl	57e0944c <printf>
#ifdef CC_VERSION_STRING
	puts(CC_VERSION_STRING "\n");
57e08b2c:	e59f0018 	ldr	r0, [pc, #24]	; 57e08b4c <do_version+0x30>
57e08b30:	eb00023b 	bl	57e09424 <puts>
#endif
#ifdef LD_VERSION_STRING
	puts(LD_VERSION_STRING "\n");
57e08b34:	e59f0014 	ldr	r0, [pc, #20]	; 57e08b50 <do_version+0x34>
57e08b38:	eb000239 	bl	57e09424 <puts>
#endif
#ifdef CONFIG_SYS_COREBOOT
	printf("coreboot-%s (%s)\n", lib_sysinfo.version, lib_sysinfo.build);
#endif
	return 0;
}
57e08b3c:	e3a00000 	mov	r0, #0
57e08b40:	e8bd8008 	pop	{r3, pc}
57e08b44:	57e2bdc0 	.word	0x57e2bdc0
57e08b48:	57e31b62 	.word	0x57e31b62
57e08b4c:	57e31b67 	.word	0x57e31b67
57e08b50:	57e31b8c 	.word	0x57e31b8c

57e08b54 <do_imgextract>:
#define CONFIG_SYS_XIMG_LEN	0x800000
#endif

static int
do_imgextract(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
57e08b54:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e08b58:	e1a05003 	mov	r5, r3
	ulong		addr = load_addr;
57e08b5c:	e59f3278 	ldr	r3, [pc, #632]	; 57e08ddc <do_imgextract+0x288>
#define CONFIG_SYS_XIMG_LEN	0x800000
#endif

static int
do_imgextract(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
57e08b60:	e24dd020 	sub	sp, sp, #32
57e08b64:	e1a0b000 	mov	fp, r0
	size_t		fit_len;
#endif
	uint		unc_len = CONFIG_SYS_XIMG_LEN;
	uint8_t		comp;

	verify = getenv_yesno("verify");
57e08b68:	e59f0270 	ldr	r0, [pc, #624]	; 57e08de0 <do_imgextract+0x28c>
#define CONFIG_SYS_XIMG_LEN	0x800000
#endif

static int
do_imgextract(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
57e08b6c:	e1a07002 	mov	r7, r2
	ulong		addr = load_addr;
57e08b70:	e593a000 	ldr	sl, [r3]
	size_t		fit_len;
#endif
	uint		unc_len = CONFIG_SYS_XIMG_LEN;
	uint8_t		comp;

	verify = getenv_yesno("verify");
57e08b74:	eb000885 	bl	57e0ad90 <getenv_yesno>

	if (argc > 1) {
57e08b78:	e3570001 	cmp	r7, #1
	size_t		fit_len;
#endif
	uint		unc_len = CONFIG_SYS_XIMG_LEN;
	uint8_t		comp;

	verify = getenv_yesno("verify");
57e08b7c:	e58d0004 	str	r0, [sp, #4]

	if (argc > 1) {
57e08b80:	da000092 	ble	57e08dd0 <do_imgextract+0x27c>
		addr = simple_strtoul(argv[1], NULL, 16);
57e08b84:	e5950004 	ldr	r0, [r5, #4]
57e08b88:	e3a01000 	mov	r1, #0
57e08b8c:	e3a02010 	mov	r2, #16
57e08b90:	eb007143 	bl	57e250a4 <simple_strtoul>
	}
	if (argc > 2) {
57e08b94:	e3570002 	cmp	r7, #2
	uint8_t		comp;

	verify = getenv_yesno("verify");

	if (argc > 1) {
		addr = simple_strtoul(argv[1], NULL, 16);
57e08b98:	e1a0a000 	mov	sl, r0
	}
	if (argc > 2) {
57e08b9c:	0a00008b 	beq	57e08dd0 <do_imgextract+0x27c>
		part = simple_strtoul(argv[2], NULL, 16);
57e08ba0:	e5950008 	ldr	r0, [r5, #8]
57e08ba4:	e3a01000 	mov	r1, #0
57e08ba8:	e3a02010 	mov	r2, #16
57e08bac:	eb00713c 	bl	57e250a4 <simple_strtoul>
#if defined(CONFIG_FIT)
		uname = argv[2];
#endif
	}
	if (argc > 3) {
57e08bb0:	e3570003 	cmp	r7, #3

	if (argc > 1) {
		addr = simple_strtoul(argv[1], NULL, 16);
	}
	if (argc > 2) {
		part = simple_strtoul(argv[2], NULL, 16);
57e08bb4:	e1a04000 	mov	r4, r0

static int
do_imgextract(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	ulong		addr = load_addr;
	ulong		dest = 0;
57e08bb8:	03a09000 	moveq	r9, #0
		part = simple_strtoul(argv[2], NULL, 16);
#if defined(CONFIG_FIT)
		uname = argv[2];
#endif
	}
	if (argc > 3) {
57e08bbc:	0a000004 	beq	57e08bd4 <do_imgextract+0x80>
		dest = simple_strtoul(argv[3], NULL, 16);
57e08bc0:	e595000c 	ldr	r0, [r5, #12]
57e08bc4:	e3a01000 	mov	r1, #0
57e08bc8:	e3a02010 	mov	r2, #16
57e08bcc:	eb007134 	bl	57e250a4 <simple_strtoul>
57e08bd0:	e1a09000 	mov	r9, r0
	}

	switch (genimg_get_format((void *)addr)) {
57e08bd4:	e1a0000a 	mov	r0, sl
57e08bd8:	eb0015fd 	bl	57e0e3d4 <genimg_get_format>
57e08bdc:	e3500001 	cmp	r0, #1
57e08be0:	e1a06000 	mov	r6, r0
57e08be4:	1a000041 	bne	57e08cf0 <do_imgextract+0x19c>
	case IMAGE_FORMAT_LEGACY:

		printf("## Copying part %d from legacy image "
57e08be8:	e1a01004 	mov	r1, r4
57e08bec:	e1a0200a 	mov	r2, sl
57e08bf0:	e59f01ec 	ldr	r0, [pc, #492]	; 57e08de4 <do_imgextract+0x290>
57e08bf4:	eb000214 	bl	57e0944c <printf>
	"    - extract <uname> subimage from FIT image at <addr> and copy to <dest>"
#endif
	"";
#endif

U_BOOT_CMD(
57e08bf8:	e59a3000 	ldr	r3, [sl]
57e08bfc:	e1a02c03 	lsl	r2, r3, #24
57e08c00:	e1822c23 	orr	r2, r2, r3, lsr #24
57e08c04:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e08c08:	e1822401 	orr	r2, r2, r1, lsl #8
57e08c0c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e08c10:	e1823423 	orr	r3, r2, r3, lsr #8

		printf("## Copying part %d from legacy image "
			"at %08lx ...\n", part, addr);

		hdr = (image_header_t *)addr;
		if (!image_check_magic(hdr)) {
57e08c14:	e59f21cc 	ldr	r2, [pc, #460]	; 57e08de8 <do_imgextract+0x294>
57e08c18:	e1530002 	cmp	r3, r2
			printf("Bad Magic Number\n");
57e08c1c:	159f01c8 	ldrne	r0, [pc, #456]	; 57e08dec <do_imgextract+0x298>

		printf("## Copying part %d from legacy image "
			"at %08lx ...\n", part, addr);

		hdr = (image_header_t *)addr;
		if (!image_check_magic(hdr)) {
57e08c20:	1a000004 	bne	57e08c38 <do_imgextract+0xe4>
			printf("Bad Magic Number\n");
			return 1;
		}

		if (!image_check_hcrc(hdr)) {
57e08c24:	e1a0000a 	mov	r0, sl
57e08c28:	eb001490 	bl	57e0de70 <image_check_hcrc>
57e08c2c:	e3500000 	cmp	r0, #0
57e08c30:	1a000002 	bne	57e08c40 <do_imgextract+0xec>
			printf("Bad Header Checksum\n");
57e08c34:	e59f01b4 	ldr	r0, [pc, #436]	; 57e08df0 <do_imgextract+0x29c>
57e08c38:	eb000203 	bl	57e0944c <printf>
			return 1;
57e08c3c:	ea000060 	b	57e08dc4 <do_imgextract+0x270>
		}
#ifdef DEBUG
		image_print_contents(hdr);
#endif

		if (!image_check_type(hdr, IH_TYPE_MULTI)) {
57e08c40:	e5da301e 	ldrb	r3, [sl, #30]
57e08c44:	e3530004 	cmp	r3, #4
			printf("Wrong Image Type for %s command\n",
57e08c48:	159f01a4 	ldrne	r0, [pc, #420]	; 57e08df4 <do_imgextract+0x2a0>
		}
#ifdef DEBUG
		image_print_contents(hdr);
#endif

		if (!image_check_type(hdr, IH_TYPE_MULTI)) {
57e08c4c:	1a000008 	bne	57e08c74 <do_imgextract+0x120>
	"    - extract <uname> subimage from FIT image at <addr> and copy to <dest>"
#endif
	"";
#endif

U_BOOT_CMD(
57e08c50:	e5da501f 	ldrb	r5, [sl, #31]
					cmdtp->name);
			return 1;
		}

		comp = image_get_comp(hdr);
		if ((comp != IH_COMP_NONE) && (argc < 4)) {
57e08c54:	e3570003 	cmp	r7, #3
57e08c58:	c3a03000 	movgt	r3, #0
57e08c5c:	d3a03001 	movle	r3, #1
57e08c60:	e3550000 	cmp	r5, #0
57e08c64:	03a03000 	moveq	r3, #0
57e08c68:	e3530000 	cmp	r3, #0
57e08c6c:	0a000003 	beq	57e08c80 <do_imgextract+0x12c>
			printf("Must specify load address for %s command "
57e08c70:	e59f0180 	ldr	r0, [pc, #384]	; 57e08df8 <do_imgextract+0x2a4>
57e08c74:	e59b1000 	ldr	r1, [fp]
57e08c78:	eb0001f3 	bl	57e0944c <printf>
					"with compressed image\n",
					cmdtp->name);
			return 1;
57e08c7c:	ea000050 	b	57e08dc4 <do_imgextract+0x270>
		}

		if (verify) {
57e08c80:	e59d3004 	ldr	r3, [sp, #4]
57e08c84:	e3530000 	cmp	r3, #0
57e08c88:	0a000008 	beq	57e08cb0 <do_imgextract+0x15c>
			printf("   Verifying Checksum ... ");
57e08c8c:	e59f0168 	ldr	r0, [pc, #360]	; 57e08dfc <do_imgextract+0x2a8>
57e08c90:	eb0001ed 	bl	57e0944c <printf>
			if (!image_check_dcrc(hdr)) {
57e08c94:	e1a0000a 	mov	r0, sl
57e08c98:	eb00148d 	bl	57e0ded4 <image_check_dcrc>
57e08c9c:	e3500000 	cmp	r0, #0
				printf("Bad Data CRC\n");
57e08ca0:	059f0158 	ldreq	r0, [pc, #344]	; 57e08e00 <do_imgextract+0x2ac>
			return 1;
		}

		if (verify) {
			printf("   Verifying Checksum ... ");
			if (!image_check_dcrc(hdr)) {
57e08ca4:	0affffe3 	beq	57e08c38 <do_imgextract+0xe4>
				printf("Bad Data CRC\n");
				return 1;
			}
			printf("OK\n");
57e08ca8:	e59f0154 	ldr	r0, [pc, #340]	; 57e08e04 <do_imgextract+0x2b0>
57e08cac:	eb0001e6 	bl	57e0944c <printf>
		}

		count = image_multi_count(hdr);
57e08cb0:	e1a0000a 	mov	r0, sl
57e08cb4:	eb00149e 	bl	57e0df34 <image_multi_count>
		if (part >= count) {
57e08cb8:	e1540000 	cmp	r4, r0
57e08cbc:	3a000002 	bcc	57e08ccc <do_imgextract+0x178>
			printf("Bad Image Part\n");
57e08cc0:	e59f0140 	ldr	r0, [pc, #320]	; 57e08e08 <do_imgextract+0x2b4>
57e08cc4:	eb0001e0 	bl	57e0944c <printf>
57e08cc8:	ea000029 	b	57e08d74 <do_imgextract+0x220>
			return 1;
		}

		image_multi_getimg(hdr, part, &data, &len);
57e08ccc:	e28d6018 	add	r6, sp, #24
57e08cd0:	e1a0000a 	mov	r0, sl
57e08cd4:	e1a01004 	mov	r1, r4
57e08cd8:	e28d201c 	add	r2, sp, #28
57e08cdc:	e1a03006 	mov	r3, r6
57e08ce0:	eb00149b 	bl	57e0df54 <image_multi_getimg>
	default:
		puts("Invalid image type for imxtract\n");
		return 1;
	}

	if (argc > 3) {
57e08ce4:	e3570003 	cmp	r7, #3
57e08ce8:	ca000003 	bgt	57e08cfc <do_imgextract+0x1a8>
57e08cec:	ea000024 	b	57e08d84 <do_imgextract+0x230>
		data = (ulong)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts("Invalid image type for imxtract\n");
57e08cf0:	e59f0114 	ldr	r0, [pc, #276]	; 57e08e0c <do_imgextract+0x2b8>
57e08cf4:	eb0001ca 	bl	57e09424 <puts>
57e08cf8:	ea00001d 	b	57e08d74 <do_imgextract+0x220>
		return 1;
	}

	if (argc > 3) {
		switch (comp) {
57e08cfc:	e3550000 	cmp	r5, #0
57e08d00:	0a000002 	beq	57e08d10 <do_imgextract+0x1bc>
57e08d04:	e3550001 	cmp	r5, #1
57e08d08:	1a000016 	bne	57e08d68 <do_imgextract+0x214>
57e08d0c:	ea000007 	b	57e08d30 <do_imgextract+0x1dc>
					from += tail;
					l -= tail;
				}
			}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
			printf("   Loading part %d ... ", part);
57e08d10:	e1a01004 	mov	r1, r4
57e08d14:	e59f00f4 	ldr	r0, [pc, #244]	; 57e08e10 <do_imgextract+0x2bc>
57e08d18:	eb0001cb 	bl	57e0944c <printf>
			memmove((char *) dest, (char *)data, len);
57e08d1c:	e1a00009 	mov	r0, r9
57e08d20:	e59d101c 	ldr	r1, [sp, #28]
57e08d24:	e59d2018 	ldr	r2, [sp, #24]
57e08d28:	eb006d94 	bl	57e24380 <memmove>
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
			break;
57e08d2c:	ea000012 	b	57e08d7c <do_imgextract+0x228>
#ifdef CONFIG_GZIP
		case IH_COMP_GZIP:
			printf("   Uncompressing part %d ... ", part);
57e08d30:	e1a01004 	mov	r1, r4
57e08d34:	e59f00d8 	ldr	r0, [pc, #216]	; 57e08e14 <do_imgextract+0x2c0>
57e08d38:	eb0001c3 	bl	57e0944c <printf>
			if (gunzip((void *) dest, unc_len,
57e08d3c:	e1a00009 	mov	r0, r9
57e08d40:	e3a01502 	mov	r1, #8388608	; 0x800000
57e08d44:	e59d201c 	ldr	r2, [sp, #28]
57e08d48:	e1a03006 	mov	r3, r6
57e08d4c:	eb006673 	bl	57e22720 <gunzip>
57e08d50:	e3500000 	cmp	r0, #0
57e08d54:	0a000008 	beq	57e08d7c <do_imgextract+0x228>
				   (uchar *) data, &len) != 0) {
				puts("GUNZIP ERROR - image not loaded\n");
57e08d58:	e59f00b8 	ldr	r0, [pc, #184]	; 57e08e18 <do_imgextract+0x2c4>
57e08d5c:	eb0001b0 	bl	57e09424 <puts>
				return 1;
57e08d60:	e1a06005 	mov	r6, r5
57e08d64:	ea000016 	b	57e08dc4 <do_imgextract+0x270>
				}
			}
			break;
#endif /* CONFIG_BZIP2 */
		default:
			printf("Unimplemented compression type %d\n", comp);
57e08d68:	e59f00ac 	ldr	r0, [pc, #172]	; 57e08e1c <do_imgextract+0x2c8>
57e08d6c:	e1a01005 	mov	r1, r5
57e08d70:	eb0001b5 	bl	57e0944c <printf>
			return 1;
57e08d74:	e3a06001 	mov	r6, #1
57e08d78:	ea000011 	b	57e08dc4 <do_imgextract+0x270>
		}
		puts("OK\n");
57e08d7c:	e59f0080 	ldr	r0, [pc, #128]	; 57e08e04 <do_imgextract+0x2b0>
57e08d80:	eb0001a7 	bl	57e09424 <puts>
	}

	sprintf(pbuf, "%8lx", data);
57e08d84:	e28d400c 	add	r4, sp, #12
57e08d88:	e59d201c 	ldr	r2, [sp, #28]
57e08d8c:	e59f108c 	ldr	r1, [pc, #140]	; 57e08e20 <do_imgextract+0x2cc>
57e08d90:	e1a00004 	mov	r0, r4
57e08d94:	eb00716b 	bl	57e25348 <sprintf>
	setenv("fileaddr", pbuf);
57e08d98:	e1a01004 	mov	r1, r4
57e08d9c:	e59f0080 	ldr	r0, [pc, #128]	; 57e08e24 <do_imgextract+0x2d0>
57e08da0:	ebfff942 	bl	57e072b0 <setenv>
	sprintf(pbuf, "%8lx", len);
57e08da4:	e59f1074 	ldr	r1, [pc, #116]	; 57e08e20 <do_imgextract+0x2cc>
57e08da8:	e59d2018 	ldr	r2, [sp, #24]
57e08dac:	e1a00004 	mov	r0, r4
57e08db0:	eb007164 	bl	57e25348 <sprintf>
	setenv("filesize", pbuf);
57e08db4:	e59f006c 	ldr	r0, [pc, #108]	; 57e08e28 <do_imgextract+0x2d4>
57e08db8:	e1a01004 	mov	r1, r4
57e08dbc:	ebfff93b 	bl	57e072b0 <setenv>

	return 0;
57e08dc0:	e3a06000 	mov	r6, #0
}
57e08dc4:	e1a00006 	mov	r0, r6
57e08dc8:	e28dd020 	add	sp, sp, #32
57e08dcc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
#define CONFIG_SYS_XIMG_LEN	0x800000
#endif

static int
do_imgextract(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
57e08dd0:	e3a04000 	mov	r4, #0
	ulong		addr = load_addr;
	ulong		dest = 0;
57e08dd4:	e1a09004 	mov	r9, r4
57e08dd8:	eaffff7d 	b	57e08bd4 <do_imgextract+0x80>
57e08ddc:	57e36e60 	.word	0x57e36e60
57e08de0:	57e2e7b9 	.word	0x57e2e7b9
57e08de4:	57e31bde 	.word	0x57e31bde
57e08de8:	27051956 	.word	0x27051956
57e08dec:	57e2e62a 	.word	0x57e2e62a
57e08df0:	57e2e63f 	.word	0x57e2e63f
57e08df4:	57e2e811 	.word	0x57e2e811
57e08df8:	57e31c11 	.word	0x57e31c11
57e08dfc:	57e2e5d4 	.word	0x57e2e5d4
57e08e00:	57e2e657 	.word	0x57e2e657
57e08e04:	57e3455d 	.word	0x57e3455d
57e08e08:	57e31c51 	.word	0x57e31c51
57e08e0c:	57e31c61 	.word	0x57e31c61
57e08e10:	57e31c82 	.word	0x57e31c82
57e08e14:	57e31c9a 	.word	0x57e31c9a
57e08e18:	57e31cb8 	.word	0x57e31cb8
57e08e1c:	57e2e796 	.word	0x57e2e796
57e08e20:	57e31cd9 	.word	0x57e31cd9
57e08e24:	57e31cde 	.word	0x57e31cde
57e08e28:	57e2ea14 	.word	0x57e2ea14

57e08e2c <find_cmd_tbl>:

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
57e08e2c:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
57e08e30:	e2505000 	subs	r5, r0, #0

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
57e08e34:	e1a04002 	mov	r4, r2
57e08e38:	e1a06001 	mov	r6, r1
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
		return NULL;
57e08e3c:	01a04005 	moveq	r4, r5
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
57e08e40:	0a00001e 	beq	57e08ec0 <find_cmd_tbl+0x94>
		return NULL;
	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
57e08e44:	e3a0102e 	mov	r1, #46	; 0x2e
57e08e48:	eb006c73 	bl	57e2401c <strchr>
57e08e4c:	e3500000 	cmp	r0, #0
57e08e50:	1065a000 	rsbne	sl, r5, r0
57e08e54:	1a000002 	bne	57e08e64 <find_cmd_tbl+0x38>
57e08e58:	e1a00005 	mov	r0, r5
57e08e5c:	eb006c7b 	bl	57e24050 <strlen>
57e08e60:	e1a0a000 	mov	sl, r0

	for (cmdtp = table;
	     cmdtp != table + table_len;
57e08e64:	e3a09018 	mov	r9, #24
57e08e68:	e0296994 	mla	r9, r4, r9, r6
{
	cmd_tbl_t *cmdtp;
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;
57e08e6c:	e3a07000 	mov	r7, #0
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
57e08e70:	e1a04006 	mov	r4, r6
57e08e74:	ea00000c 	b	57e08eac <find_cmd_tbl+0x80>
	     cmdtp != table + table_len;
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
57e08e78:	e1a00005 	mov	r0, r5
57e08e7c:	e5941000 	ldr	r1, [r4]
57e08e80:	e1a0200a 	mov	r2, sl
57e08e84:	eb006c52 	bl	57e23fd4 <strncmp>
57e08e88:	e3500000 	cmp	r0, #0
57e08e8c:	1a000005 	bne	57e08ea8 <find_cmd_tbl+0x7c>
			if (len == strlen (cmdtp->name))
57e08e90:	e5940000 	ldr	r0, [r4]
57e08e94:	eb006c6d 	bl	57e24050 <strlen>
57e08e98:	e15a0000 	cmp	sl, r0
57e08e9c:	0a000007 	beq	57e08ec0 <find_cmd_tbl+0x94>
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
57e08ea0:	e2877001 	add	r7, r7, #1
57e08ea4:	e1a06004 	mov	r6, r4
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
	     cmdtp != table + table_len;
	     cmdtp++) {
57e08ea8:	e2844018 	add	r4, r4, #24
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
57e08eac:	e1540009 	cmp	r4, r9
57e08eb0:	1afffff0 	bne	57e08e78 <find_cmd_tbl+0x4c>
	}
	if (n_found == 1) {			/* exactly one match */
		return cmdtp_temp;
	}

	return NULL;	/* not found or ambiguous command */
57e08eb4:	e3570001 	cmp	r7, #1
57e08eb8:	01a04006 	moveq	r4, r6
57e08ebc:	13a04000 	movne	r4, #0
}
57e08ec0:	e1a00004 	mov	r0, r4
57e08ec4:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

57e08ec8 <find_cmd>:

cmd_tbl_t *find_cmd (const char *cmd)
{
	cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
	const int len = ll_entry_count(cmd_tbl_t, cmd);
	return find_cmd_tbl(cmd, start, len);
57e08ec8:	e59f1014 	ldr	r1, [pc, #20]	; 57e08ee4 <find_cmd+0x1c>
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
	const int len = ll_entry_count(cmd_tbl_t, cmd);
57e08ecc:	e59f3014 	ldr	r3, [pc, #20]	; 57e08ee8 <find_cmd+0x20>
	return find_cmd_tbl(cmd, start, len);
57e08ed0:	e59f2014 	ldr	r2, [pc, #20]	; 57e08eec <find_cmd+0x24>
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
	const int len = ll_entry_count(cmd_tbl_t, cmd);
57e08ed4:	e0613003 	rsb	r3, r1, r3
57e08ed8:	e1a031c3 	asr	r3, r3, #3
	return find_cmd_tbl(cmd, start, len);
57e08edc:	e0020293 	mul	r2, r3, r2
57e08ee0:	eaffffd1 	b	57e08e2c <find_cmd_tbl>
	...
57e08eec:	aaaaaaab 	.word	0xaaaaaaab

57e08ef0 <cmd_usage>:
}

int cmd_usage(const cmd_tbl_t *cmdtp)
{
57e08ef0:	e92d4010 	push	{r4, lr}
57e08ef4:	e1a04000 	mov	r4, r0
	printf("%s - %s\n\n", cmdtp->name, cmdtp->usage);
57e08ef8:	e5941000 	ldr	r1, [r4]
57e08efc:	e5942010 	ldr	r2, [r4, #16]
57e08f00:	e59f0038 	ldr	r0, [pc, #56]	; 57e08f40 <cmd_usage+0x50>
57e08f04:	eb000150 	bl	57e0944c <printf>

#ifdef	CONFIG_SYS_LONGHELP
	printf("Usage:\n%s ", cmdtp->name);
57e08f08:	e59f0034 	ldr	r0, [pc, #52]	; 57e08f44 <cmd_usage+0x54>
57e08f0c:	e5941000 	ldr	r1, [r4]
57e08f10:	eb00014d 	bl	57e0944c <printf>

	if (!cmdtp->help) {
57e08f14:	e5940014 	ldr	r0, [r4, #20]
57e08f18:	e3500000 	cmp	r0, #0
57e08f1c:	1a000002 	bne	57e08f2c <cmd_usage+0x3c>
		puts ("- No additional help available.\n");
57e08f20:	e59f0020 	ldr	r0, [pc, #32]	; 57e08f48 <cmd_usage+0x58>
57e08f24:	eb00013e 	bl	57e09424 <puts>
		return 1;
57e08f28:	ea000002 	b	57e08f38 <cmd_usage+0x48>
	}

	puts (cmdtp->help);
57e08f2c:	eb00013c 	bl	57e09424 <puts>
	putc ('\n');
57e08f30:	e3a0000a 	mov	r0, #10
57e08f34:	eb000130 	bl	57e093fc <putc>
#endif	/* CONFIG_SYS_LONGHELP */
	return 1;
}
57e08f38:	e3a00001 	mov	r0, #1
57e08f3c:	e8bd8010 	pop	{r4, pc}
57e08f40:	57e31d10 	.word	0x57e31d10
57e08f44:	57e31d1a 	.word	0x57e31d1a
57e08f48:	57e31d25 	.word	0x57e31d25

57e08f4c <_do_help>:
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
57e08f4c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e08f50:	e28db01c 	add	fp, sp, #28
57e08f54:	e24dd010 	sub	sp, sp, #16
57e08f58:	e59b9004 	ldr	r9, [fp, #4]
57e08f5c:	e1a0a000 	mov	sl, r0
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
57e08f60:	e3590001 	cmp	r9, #1
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
57e08f64:	e1a04001 	mov	r4, r1
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
57e08f68:	159b7008 	ldrne	r7, [fp, #8]
57e08f6c:	13a05000 	movne	r5, #0
57e08f70:	13a06001 	movne	r6, #1
57e08f74:	1a00004f 	bne	57e090b8 <_do_help+0x16c>
		cmd_tbl_t *cmd_array[cmd_items];
57e08f78:	e1a03101 	lsl	r3, r1, #2
57e08f7c:	e283300e 	add	r3, r3, #14
57e08f80:	e3c33007 	bic	r3, r3, #7
	      flag, int argc, char * const argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
57e08f84:	e50bd024 	str	sp, [fp, #-36]	; 0x24
		cmd_tbl_t *cmd_array[cmd_items];
57e08f88:	e04dd003 	sub	sp, sp, r3
57e08f8c:	e1a0300d 	mov	r3, sp
57e08f90:	e50bd020 	str	sp, [fp, #-32]
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
57e08f94:	e1a0100d 	mov	r1, sp
57e08f98:	e3a02000 	mov	r2, #0
57e08f9c:	ea000002 	b	57e08fac <_do_help+0x60>
			cmd_array[i] = cmdtp++;
57e08fa0:	e481a004 	str	sl, [r1], #4
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
57e08fa4:	e2822001 	add	r2, r2, #1
			cmd_array[i] = cmdtp++;
57e08fa8:	e28aa018 	add	sl, sl, #24
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
57e08fac:	e1520004 	cmp	r2, r4
57e08fb0:	bafffffa 	blt	57e08fa0 <_do_help+0x54>
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
57e08fb4:	e2446001 	sub	r6, r4, #1
57e08fb8:	ea000017 	b	57e0901c <_do_help+0xd0>
57e08fbc:	e3a07000 	mov	r7, #0
57e08fc0:	e1a05003 	mov	r5, r3
57e08fc4:	e1a0a007 	mov	sl, r7
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
57e08fc8:	e5952000 	ldr	r2, [r5]
					    cmd_array[j + 1]->name) > 0) {
57e08fcc:	e5b59004 	ldr	r9, [r5, #4]!

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
57e08fd0:	e5920000 	ldr	r0, [r2]
57e08fd4:	e5991000 	ldr	r1, [r9]
57e08fd8:	e50b2028 	str	r2, [fp, #-40]	; 0x28
57e08fdc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
57e08fe0:	eb006bef 	bl	57e23fa4 <strcmp>
57e08fe4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
57e08fe8:	e3500000 	cmp	r0, #0
					    cmd_array[j + 1]->name) > 0) {
57e08fec:	e28aa001 	add	sl, sl, #1

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
57e08ff0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
57e08ff4:	c2877001 	addgt	r7, r7, #1
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
57e08ff8:	c5059004 	strgt	r9, [r5, #-4]
					cmd_array[j + 1] = tmp;
57e08ffc:	c5852000 	strgt	r2, [r5]
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
57e09000:	e15a0006 	cmp	sl, r6
57e09004:	baffffef 	blt	57e08fc8 <_do_help+0x7c>
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
				}
			}
			if (!swaps)
57e09008:	e3570000 	cmp	r7, #0
57e0900c:	1a000001 	bne	57e09018 <_do_help+0xcc>
		for (i = 0; i < cmd_items; i++) {
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
57e09010:	e3a05000 	mov	r5, #0
57e09014:	ea000012 	b	57e09064 <_do_help+0x118>
57e09018:	e2466001 	sub	r6, r6, #1
57e0901c:	e3560000 	cmp	r6, #0
57e09020:	caffffe5 	bgt	57e08fbc <_do_help+0x70>
57e09024:	eafffff9 	b	57e09010 <_do_help+0xc4>
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;
57e09028:	e51b3020 	ldr	r3, [fp, #-32]
57e0902c:	e4937004 	ldr	r7, [r3], #4
57e09030:	e50b3020 	str	r3, [fp, #-32]
57e09034:	e5976010 	ldr	r6, [r7, #16]

			/* allow user abort */
			if (ctrlc ())
57e09038:	eb000128 	bl	57e094e0 <ctrlc>
57e0903c:	e3500000 	cmp	r0, #0
57e09040:	1a00000b 	bne	57e09074 <_do_help+0x128>
				return 1;
			if (usage == NULL)
57e09044:	e3560000 	cmp	r6, #0
57e09048:	0a000004 	beq	57e09060 <_do_help+0x114>
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
57e0904c:	e59f0078 	ldr	r0, [pc, #120]	; 57e090cc <_do_help+0x180>
57e09050:	e3a01008 	mov	r1, #8
57e09054:	e5972000 	ldr	r2, [r7]
57e09058:	e1a03006 	mov	r3, r6
57e0905c:	eb0000fa 	bl	57e0944c <printf>
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
57e09060:	e2855001 	add	r5, r5, #1
57e09064:	e1550004 	cmp	r5, r4
57e09068:	baffffee 	blt	57e09028 <_do_help+0xdc>
			if (usage == NULL)
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
			       cmd_array[i]->name, usage);
		}
		return 0;
57e0906c:	e3a05000 	mov	r5, #0
57e09070:	ea000000 	b	57e09078 <_do_help+0x12c>
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;

			/* allow user abort */
			if (ctrlc ())
				return 1;
57e09074:	e3a05001 	mov	r5, #1
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
57e09078:	e51bd024 	ldr	sp, [fp, #-36]	; 0x24
57e0907c:	ea00000f 	b	57e090c0 <_do_help+0x174>
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
		if ((cmdtp = find_cmd_tbl (argv[i], cmd_start, cmd_items )) != NULL) {
57e09080:	e5b70004 	ldr	r0, [r7, #4]!
57e09084:	e1a0100a 	mov	r1, sl
57e09088:	e1a02004 	mov	r2, r4
57e0908c:	ebffff66 	bl	57e08e2c <find_cmd_tbl>
57e09090:	e3500000 	cmp	r0, #0
57e09094:	0a000002 	beq	57e090a4 <_do_help+0x158>
			rcode |= cmd_usage(cmdtp);
57e09098:	ebffff94 	bl	57e08ef0 <cmd_usage>
57e0909c:	e1855000 	orr	r5, r5, r0
57e090a0:	ea000003 	b	57e090b4 <_do_help+0x168>
		} else {
			printf ("Unknown command '%s' - try 'help'"
57e090a4:	e59f0024 	ldr	r0, [pc, #36]	; 57e090d0 <_do_help+0x184>
57e090a8:	e5971000 	ldr	r1, [r7]
57e090ac:	eb0000e6 	bl	57e0944c <printf>
				" without arguments for list of all"
				" known commands\n\n", argv[i]
					);
			rcode = 1;
57e090b0:	e3a05001 	mov	r5, #1
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
57e090b4:	e2866001 	add	r6, r6, #1
57e090b8:	e1560009 	cmp	r6, r9
57e090bc:	baffffef 	blt	57e09080 <_do_help+0x134>
					);
			rcode = 1;
		}
	}
	return rcode;
}
57e090c0:	e1a00005 	mov	r0, r5
57e090c4:	e24bd01c 	sub	sp, fp, #28
57e090c8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e090cc:	57e31d46 	.word	0x57e31d46
57e090d0:	57e31d50 	.word	0x57e31d50

57e090d4 <cmd_get_data_size>:

#endif

#ifdef CMD_DATA_SIZE
int cmd_get_data_size(char* arg, int default_size)
{
57e090d4:	e92d4038 	push	{r3, r4, r5, lr}
57e090d8:	e1a04000 	mov	r4, r0
57e090dc:	e1a05001 	mov	r5, r1
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
57e090e0:	eb006bda 	bl	57e24050 <strlen>
	if (len > 2 && arg[len-2] == '.') {
57e090e4:	e3500002 	cmp	r0, #2
57e090e8:	da00000a 	ble	57e09118 <cmd_get_data_size+0x44>
57e090ec:	e0844000 	add	r4, r4, r0
57e090f0:	e5543002 	ldrb	r3, [r4, #-2]
57e090f4:	e353002e 	cmp	r3, #46	; 0x2e
57e090f8:	1a000006 	bne	57e09118 <cmd_get_data_size+0x44>
		switch(arg[len-1]) {
57e090fc:	e5543001 	ldrb	r3, [r4, #-1]
57e09100:	e2433062 	sub	r3, r3, #98	; 0x62
57e09104:	e20330ff 	and	r3, r3, #255	; 0xff
57e09108:	e3530015 	cmp	r3, #21
57e0910c:	959f200c 	ldrls	r2, [pc, #12]	; 57e09120 <cmd_get_data_size+0x4c>
57e09110:	83e05000 	mvnhi	r5, #0
57e09114:	97925103 	ldrls	r5, [r2, r3, lsl #2]
		default:
			return -1;
		}
	}
	return default_size;
}
57e09118:	e1a00005 	mov	r0, r5
57e0911c:	e8bd8038 	pop	{r3, r4, r5, pc}
57e09120:	57e2bdfc 	.word	0x57e2bdfc

57e09124 <cmd_process>:
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
57e09124:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e09128:	e1a05000 	mov	r5, r0
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
57e0912c:	e5920000 	ldr	r0, [r2]
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
57e09130:	e1a0a001 	mov	sl, r1
57e09134:	e1a06002 	mov	r6, r2
57e09138:	e1a07003 	mov	r7, r3
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
57e0913c:	ebffff61 	bl	57e08ec8 <find_cmd>
	if (cmdtp == NULL) {
57e09140:	e2504000 	subs	r4, r0, #0
57e09144:	1a000003 	bne	57e09158 <cmd_process+0x34>
		printf("Unknown command '%s' - try 'help'\n", argv[0]);
57e09148:	e5961000 	ldr	r1, [r6]
57e0914c:	e59f0078 	ldr	r0, [pc, #120]	; 57e091cc <cmd_process+0xa8>
57e09150:	eb0000bd 	bl	57e0944c <printf>
57e09154:	ea00000b 	b	57e09188 <cmd_process+0x64>
		return 1;
	}

	/* found - check max args */
	if (argc > cmdtp->maxargs)
57e09158:	e5943004 	ldr	r3, [r4, #4]
57e0915c:	e15a0003 	cmp	sl, r3
57e09160:	ca00000a 	bgt	57e09190 <cmd_process+0x6c>
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
57e09164:	e594c00c 	ldr	ip, [r4, #12]
57e09168:	e59f3060 	ldr	r3, [pc, #96]	; 57e091d0 <cmd_process+0xac>
57e0916c:	e15c0003 	cmp	ip, r3
57e09170:	1a000009 	bne	57e0919c <cmd_process+0x78>
		if (flag & CMD_FLAG_BOOTD) {
57e09174:	e3150002 	tst	r5, #2
			puts("'bootd' recursion detected\n");
			rc = CMD_RET_FAILURE;
		} else {
			flag |= CMD_FLAG_BOOTD;
57e09178:	03855002 	orreq	r5, r5, #2
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
		if (flag & CMD_FLAG_BOOTD) {
57e0917c:	0a000006 	beq	57e0919c <cmd_process+0x78>
			puts("'bootd' recursion detected\n");
57e09180:	e59f004c 	ldr	r0, [pc, #76]	; 57e091d4 <cmd_process+0xb0>
57e09184:	eb0000a6 	bl	57e09424 <puts>
			rc = CMD_RET_FAILURE;
57e09188:	e3a00001 	mov	r0, #1
57e0918c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
57e09190:	e1a00004 	mov	r0, r4
	return rc;
}
57e09194:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
57e09198:	eaffff54 	b	57e08ef0 <cmd_usage>
 */
static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int result;

	result = (cmdtp->cmd)(cmdtp, flag, argc, argv);
57e0919c:	e1a0200a 	mov	r2, sl
57e091a0:	e1a03006 	mov	r3, r6
57e091a4:	e1a00004 	mov	r0, r4
57e091a8:	e1a01005 	mov	r1, r5
57e091ac:	e12fff3c 	blx	ip
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
57e091b0:	e5972000 	ldr	r2, [r7]
57e091b4:	e5943008 	ldr	r3, [r4, #8]
	}
	if (rc == CMD_RET_USAGE)
57e091b8:	e3700001 	cmn	r0, #1
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
57e091bc:	e0023003 	and	r3, r2, r3
57e091c0:	e5873000 	str	r3, [r7]
	}
	if (rc == CMD_RET_USAGE)
57e091c4:	18bd84f0 	popne	{r4, r5, r6, r7, sl, pc}
57e091c8:	eafffff0 	b	57e09190 <cmd_process+0x6c>
57e091cc:	57e31da5 	.word	0x57e31da5
57e091d0:	57e01958 	.word	0x57e01958
57e091d4:	57e31dc8 	.word	0x57e31dc8

57e091d8 <console_setfile>:
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
57e091d8:	e92d4038 	push	{r3, r4, r5, lr}
	int error = 0;

	if (dev == NULL)
57e091dc:	e2515000 	subs	r5, r1, #0
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
57e091e0:	e1a04000 	mov	r4, r0
	int error = 0;

	if (dev == NULL)
		return -1;
57e091e4:	03e00000 	mvneq	r0, #0

static int console_setfile(int file, struct stdio_dev * dev)
{
	int error = 0;

	if (dev == NULL)
57e091e8:	08bd8038 	popeq	{r3, r4, r5, pc}
		return -1;

	switch (file) {
57e091ec:	e3540002 	cmp	r4, #2
57e091f0:	8a00001d 	bhi	57e0926c <console_setfile+0x94>
	case stdin:
	case stdout:
	case stderr:
		/* Start new device */
		if (dev->start) {
57e091f4:	e5950018 	ldr	r0, [r5, #24]
57e091f8:	e3500000 	cmp	r0, #0
57e091fc:	0a000002 	beq	57e0920c <console_setfile+0x34>
			error = dev->start();
57e09200:	e12fff30 	blx	r0
			/* If it's not started dont use it */
			if (error < 0)
57e09204:	e3500000 	cmp	r0, #0
57e09208:	b8bd8038 	poplt	{r3, r4, r5, pc}
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
57e0920c:	e59f3060 	ldr	r3, [pc, #96]	; 57e09274 <console_setfile+0x9c>

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
57e09210:	e3540000 	cmp	r4, #0
			if (error < 0)
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
57e09214:	e7835104 	str	r5, [r3, r4, lsl #2]

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
57e09218:	0a000002 	beq	57e09228 <console_setfile+0x50>
57e0921c:	e3540001 	cmp	r4, #1
57e09220:	18bd8038 	popne	{r3, r4, r5, pc}
57e09224:	ea000006 	b	57e09244 <console_setfile+0x6c>
		case stdin:
			gd->jt[XF_getc] = dev->getc;
57e09228:	e5982054 	ldr	r2, [r8, #84]	; 0x54
57e0922c:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
			gd->jt[XF_tstc] = dev->tstc;
57e09230:	e5983054 	ldr	r3, [r8, #84]	; 0x54
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
		case stdin:
			gd->jt[XF_getc] = dev->getc;
57e09234:	e5821004 	str	r1, [r2, #4]
			gd->jt[XF_tstc] = dev->tstc;
57e09238:	e5952028 	ldr	r2, [r5, #40]	; 0x28
57e0923c:	e5832008 	str	r2, [r3, #8]
			break;
57e09240:	e8bd8038 	pop	{r3, r4, r5, pc}
		case stdout:
			gd->jt[XF_putc] = dev->putc;
57e09244:	e5982054 	ldr	r2, [r8, #84]	; 0x54
57e09248:	e5951020 	ldr	r1, [r5, #32]
57e0924c:	e582100c 	str	r1, [r2, #12]
			gd->jt[XF_puts] = dev->puts;
57e09250:	e5982054 	ldr	r2, [r8, #84]	; 0x54
57e09254:	e5951024 	ldr	r1, [r5, #36]	; 0x24
			gd->jt[XF_printf] = printf;
57e09258:	e5983054 	ldr	r3, [r8, #84]	; 0x54
			gd->jt[XF_getc] = dev->getc;
			gd->jt[XF_tstc] = dev->tstc;
			break;
		case stdout:
			gd->jt[XF_putc] = dev->putc;
			gd->jt[XF_puts] = dev->puts;
57e0925c:	e5821010 	str	r1, [r2, #16]
			gd->jt[XF_printf] = printf;
57e09260:	e59f2010 	ldr	r2, [pc, #16]	; 57e09278 <console_setfile+0xa0>
57e09264:	e5832014 	str	r2, [r3, #20]
			break;
57e09268:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
		break;

	default:		/* Invalid file ID */
		error = -1;
57e0926c:	e3e00000 	mvn	r0, #0
	}
	return error;
}
57e09270:	e8bd8038 	pop	{r3, r4, r5, pc}
57e09274:	57e39c2c 	.word	0x57e39c2c
57e09278:	57e0944c 	.word	0x57e0944c

57e0927c <serial_printf>:
#endif /* defined(CONFIG_CONSOLE_MUX) */

/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/

int serial_printf(const char *fmt, ...)
{
57e0927c:	e92d000f 	push	{r0, r1, r2, r3}
57e09280:	e92d4030 	push	{r4, r5, lr}
57e09284:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e09288:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
57e0928c:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e09290:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
57e09294:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
57e09298:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e0929c:	eb007028 	bl	57e25344 <vsprintf>
57e092a0:	e1a05000 	mov	r5, r0
	va_end(args);

	serial_puts(printbuffer);
57e092a4:	e1a00004 	mov	r0, r4
57e092a8:	eb004fd8 	bl	57e1d210 <serial_puts>
	return i;
}
57e092ac:	e1a00005 	mov	r0, r5
57e092b0:	e28ddf63 	add	sp, sp, #396	; 0x18c
57e092b4:	e8bd4030 	pop	{r4, r5, lr}
57e092b8:	e28dd010 	add	sp, sp, #16
57e092bc:	e12fff1e 	bx	lr

57e092c0 <fgetc>:

int fgetc(int file)
{
	if (file < MAX_FILES) {
57e092c0:	e3500002 	cmp	r0, #2
	serial_puts(printbuffer);
	return i;
}

int fgetc(int file)
{
57e092c4:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES) {
57e092c8:	ca000004 	bgt	57e092e0 <fgetc+0x20>
	iomux_doenv(file, dev->name);
}
#else
static inline int console_getc(int file)
{
	return stdio_devices[file]->getc();
57e092cc:	e59f3014 	ldr	r3, [pc, #20]	; 57e092e8 <fgetc+0x28>
57e092d0:	e7933100 	ldr	r3, [r3, r0, lsl #2]
57e092d4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
57e092d8:	e12fff33 	blx	r3
			 */
			 udelay(1);
#endif
		}
#else
		return console_getc(file);
57e092dc:	e8bd8008 	pop	{r3, pc}
#endif
	}

	return -1;
57e092e0:	e3e00000 	mvn	r0, #0
}
57e092e4:	e8bd8008 	pop	{r3, pc}
57e092e8:	57e39c2c 	.word	0x57e39c2c

57e092ec <ftstc>:

int ftstc(int file)
{
	if (file < MAX_FILES)
57e092ec:	e3500002 	cmp	r0, #2

	return -1;
}

int ftstc(int file)
{
57e092f0:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
57e092f4:	ca000004 	bgt	57e0930c <ftstc+0x20>
	return stdio_devices[file]->getc();
}

static inline int console_tstc(int file)
{
	return stdio_devices[file]->tstc();
57e092f8:	e59f3014 	ldr	r3, [pc, #20]	; 57e09314 <ftstc+0x28>
57e092fc:	e7933100 	ldr	r3, [r3, r0, lsl #2]
57e09300:	e5933028 	ldr	r3, [r3, #40]	; 0x28
57e09304:	e12fff33 	blx	r3
}

int ftstc(int file)
{
	if (file < MAX_FILES)
		return console_tstc(file);
57e09308:	e8bd8008 	pop	{r3, pc}

	return -1;
57e0930c:	e3e00000 	mvn	r0, #0
}
57e09310:	e8bd8008 	pop	{r3, pc}
57e09314:	57e39c2c 	.word	0x57e39c2c

57e09318 <fputc>:

void fputc(int file, const char c)
{
	if (file < MAX_FILES)
57e09318:	e3500002 	cmp	r0, #2

	return -1;
}

void fputc(int file, const char c)
{
57e0931c:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
57e09320:	c8bd8008 	popgt	{r3, pc}
	return stdio_devices[file]->tstc();
}

static inline void console_putc(int file, const char c)
{
	stdio_devices[file]->putc(c);
57e09324:	e59f2010 	ldr	r2, [pc, #16]	; 57e0933c <fputc+0x24>
57e09328:	e7923100 	ldr	r3, [r2, r0, lsl #2]
57e0932c:	e1a00001 	mov	r0, r1
57e09330:	e5933020 	ldr	r3, [r3, #32]
57e09334:	e12fff33 	blx	r3
57e09338:	e8bd8008 	pop	{r3, pc}
57e0933c:	57e39c2c 	.word	0x57e39c2c

57e09340 <fputs>:
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
	if (file < MAX_FILES)
57e09340:	e3500002 	cmp	r0, #2
	if (file < MAX_FILES)
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
57e09344:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
57e09348:	c8bd8008 	popgt	{r3, pc}
	stdio_devices[file]->putc(c);
}

static inline void console_puts(int file, const char *s)
{
	stdio_devices[file]->puts(s);
57e0934c:	e59f2010 	ldr	r2, [pc, #16]	; 57e09364 <fputs+0x24>
57e09350:	e7923100 	ldr	r3, [r2, r0, lsl #2]
57e09354:	e1a00001 	mov	r0, r1
57e09358:	e5933024 	ldr	r3, [r3, #36]	; 0x24
57e0935c:	e12fff33 	blx	r3
57e09360:	e8bd8008 	pop	{r3, pc}
57e09364:	57e39c2c 	.word	0x57e39c2c

57e09368 <fprintf>:
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
57e09368:	e92d000e 	push	{r1, r2, r3}
57e0936c:	e92d4070 	push	{r4, r5, r6, lr}
57e09370:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e09374:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
57e09378:	e28d2e1a 	add	r2, sp, #416	; 0x1a0
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
57e0937c:	e1a05000 	mov	r5, r0
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e09380:	e59d119c 	ldr	r1, [sp, #412]	; 0x19c
57e09384:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
57e09388:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e0938c:	eb006fec 	bl	57e25344 <vsprintf>
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
57e09390:	e1a01004 	mov	r1, r4
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e09394:	e1a06000 	mov	r6, r0
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
57e09398:	e1a00005 	mov	r0, r5
57e0939c:	ebffffe7 	bl	57e09340 <fputs>
	return i;
}
57e093a0:	e1a00006 	mov	r0, r6
57e093a4:	e28ddf63 	add	sp, sp, #396	; 0x18c
57e093a8:	e8bd4070 	pop	{r4, r5, r6, lr}
57e093ac:	e28dd00c 	add	sp, sp, #12
57e093b0:	e12fff1e 	bx	lr

57e093b4 <getc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
57e093b4:	e598000c 	ldr	r0, [r8, #12]
57e093b8:	e3500000 	cmp	r0, #0
57e093bc:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
57e093c0:	e5983004 	ldr	r3, [r8, #4]
57e093c4:	e3130002 	tst	r3, #2
57e093c8:	0a000001 	beq	57e093d4 <getc+0x20>
		/* Get from the standard input */
		return fgetc(stdin);
57e093cc:	e3a00000 	mov	r0, #0
57e093d0:	eaffffba 	b	57e092c0 <fgetc>
	}

	/* Send directly to the handler */
	return serial_getc();
57e093d4:	ea004f7c 	b	57e1d1cc <serial_getc>

57e093d8 <tstc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
57e093d8:	e598000c 	ldr	r0, [r8, #12]
57e093dc:	e3500000 	cmp	r0, #0
57e093e0:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
57e093e4:	e5983004 	ldr	r3, [r8, #4]
57e093e8:	e3130002 	tst	r3, #2
57e093ec:	0a000001 	beq	57e093f8 <tstc+0x20>
		/* Test the standard input */
		return ftstc(stdin);
57e093f0:	e3a00000 	mov	r0, #0
57e093f4:	eaffffbc 	b	57e092ec <ftstc>
	}

	/* Send directly to the handler */
	return serial_tstc();
57e093f8:	ea004f78 	b	57e1d1e0 <serial_tstc>

57e093fc <putc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
57e093fc:	e598200c 	ldr	r2, [r8, #12]
static inline void pre_console_puts(const char *s) {}
static inline void print_pre_console_buffer(void) {}
#endif

void putc(const char c)
{
57e09400:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
57e09404:	e3520000 	cmp	r2, #0
57e09408:	012fff1e 	bxeq	lr
		return pre_console_putc(c);

	if (gd->flags & GD_FLG_DEVINIT) {
57e0940c:	e5983004 	ldr	r3, [r8, #4]
57e09410:	e3130002 	tst	r3, #2
57e09414:	0a000001 	beq	57e09420 <putc+0x24>
		/* Send to the standard output */
		fputc(stdout, c);
57e09418:	e3a00001 	mov	r0, #1
57e0941c:	eaffffbd 	b	57e09318 <fputc>
	} else {
		/* Send directly to the handler */
		serial_putc(c);
57e09420:	ea004f73 	b	57e1d1f4 <serial_putc>

57e09424 <puts>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
57e09424:	e598200c 	ldr	r2, [r8, #12]
		serial_putc(c);
	}
}

void puts(const char *s)
{
57e09428:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
57e0942c:	e3520000 	cmp	r2, #0
57e09430:	012fff1e 	bxeq	lr
		return pre_console_puts(s);

	if (gd->flags & GD_FLG_DEVINIT) {
57e09434:	e5983004 	ldr	r3, [r8, #4]
57e09438:	e3130002 	tst	r3, #2
57e0943c:	0a000001 	beq	57e09448 <puts+0x24>
		/* Send to the standard output */
		fputs(stdout, s);
57e09440:	e3a00001 	mov	r0, #1
57e09444:	eaffffbd 	b	57e09340 <fputs>
	} else {
		/* Send directly to the handler */
		serial_puts(s);
57e09448:	ea004f70 	b	57e1d210 <serial_puts>

57e0944c <printf>:
	}
}

int printf(const char *fmt, ...)
{
57e0944c:	e92d000f 	push	{r0, r1, r2, r3}
57e09450:	e92d4030 	push	{r4, r5, lr}
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
57e09454:	e598500c 	ldr	r5, [r8, #12]
		serial_puts(s);
	}
}

int printf(const char *fmt, ...)
{
57e09458:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
57e0945c:	e3550000 	cmp	r5, #0
57e09460:	0a000008 	beq	57e09488 <printf+0x3c>
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e09464:	e28d4004 	add	r4, sp, #4
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
57e09468:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e0946c:	e1a00004 	mov	r0, r4
57e09470:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
57e09474:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e09478:	eb006fb1 	bl	57e25344 <vsprintf>
57e0947c:	e1a05000 	mov	r5, r0
	va_end(args);

	/* Print the string */
	puts(printbuffer);
57e09480:	e1a00004 	mov	r0, r4
57e09484:	ebffffe6 	bl	57e09424 <puts>
	return i;
}
57e09488:	e1a00005 	mov	r0, r5
57e0948c:	e28ddf63 	add	sp, sp, #396	; 0x18c
57e09490:	e8bd4030 	pop	{r4, r5, lr}
57e09494:	e28dd010 	add	sp, sp, #16
57e09498:	e12fff1e 	bx	lr

57e0949c <vprintf>:

int vprintf(const char *fmt, va_list args)
{
57e0949c:	e92d4030 	push	{r4, r5, lr}
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
57e094a0:	e598500c 	ldr	r5, [r8, #12]
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
57e094a4:	e24ddf61 	sub	sp, sp, #388	; 0x184
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
57e094a8:	e3550000 	cmp	r5, #0
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
57e094ac:	e1a03000 	mov	r3, r0
57e094b0:	e1a02001 	mov	r2, r1
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
57e094b4:	0a000006 	beq	57e094d4 <vprintf+0x38>
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e094b8:	e1a0000d 	mov	r0, sp
57e094bc:	e1a01003 	mov	r1, r3
57e094c0:	eb006f9f 	bl	57e25344 <vsprintf>
57e094c4:	e1a05000 	mov	r5, r0

	/* Print the string */
	puts(printbuffer);
57e094c8:	e1a0000d 	mov	r0, sp
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
57e094cc:	e1a0400d 	mov	r4, sp

	/* Print the string */
	puts(printbuffer);
57e094d0:	ebffffd3 	bl	57e09424 <puts>
	return i;
}
57e094d4:	e1a00005 	mov	r0, r5
57e094d8:	e28ddf61 	add	sp, sp, #388	; 0x184
57e094dc:	e8bd8030 	pop	{r4, r5, pc}

57e094e0 <ctrlc>:

/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
57e094e0:	e92d4038 	push	{r3, r4, r5, lr}
	if (!ctrlc_disabled && gd->have_console) {
57e094e4:	e59f503c 	ldr	r5, [pc, #60]	; 57e09528 <ctrlc+0x48>
57e094e8:	e5954000 	ldr	r4, [r5]
57e094ec:	e3540000 	cmp	r4, #0
			default:
				break;
			}
		}
	}
	return 0;
57e094f0:	13a00000 	movne	r0, #0
/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
	if (!ctrlc_disabled && gd->have_console) {
57e094f4:	18bd8038 	popne	{r3, r4, r5, pc}
57e094f8:	e598000c 	ldr	r0, [r8, #12]
57e094fc:	e3500000 	cmp	r0, #0
57e09500:	08bd8038 	popeq	{r3, r4, r5, pc}
		if (tstc()) {
57e09504:	ebffffb3 	bl	57e093d8 <tstc>
57e09508:	e3500000 	cmp	r0, #0
57e0950c:	08bd8038 	popeq	{r3, r4, r5, pc}
			switch (getc()) {
57e09510:	ebffffa7 	bl	57e093b4 <getc>
57e09514:	e3500003 	cmp	r0, #3
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
57e09518:	03a00001 	moveq	r0, #1
57e0951c:	05850004 	streq	r0, [r5, #4]
			default:
				break;
			}
		}
	}
	return 0;
57e09520:	11a00004 	movne	r0, r4
}
57e09524:	e8bd8038 	pop	{r3, r4, r5, pc}
57e09528:	57e383e8 	.word	0x57e383e8

57e0952c <disable_ctrlc>:
/* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 */
int disable_ctrlc(int disable)
{
	int prev = ctrlc_disabled;	/* save previous state */
57e0952c:	e59f300c 	ldr	r3, [pc, #12]	; 57e09540 <disable_ctrlc+0x14>
57e09530:	e5932000 	ldr	r2, [r3]

	ctrlc_disabled = disable;
57e09534:	e5830000 	str	r0, [r3]
	return prev;
}
57e09538:	e1a00002 	mov	r0, r2
57e0953c:	e12fff1e 	bx	lr
57e09540:	57e383e8 	.word	0x57e383e8

57e09544 <had_ctrlc>:

int had_ctrlc (void)
{
	return ctrlc_was_pressed;
}
57e09544:	e59f3004 	ldr	r3, [pc, #4]	; 57e09550 <had_ctrlc+0xc>
57e09548:	e5930004 	ldr	r0, [r3, #4]
57e0954c:	e12fff1e 	bx	lr
57e09550:	57e383e8 	.word	0x57e383e8

57e09554 <clear_ctrlc>:

void clear_ctrlc(void)
{
	ctrlc_was_pressed = 0;
57e09554:	e59f3008 	ldr	r3, [pc, #8]	; 57e09564 <clear_ctrlc+0x10>
57e09558:	e3a02000 	mov	r2, #0
57e0955c:	e5832004 	str	r2, [r3, #4]
}
57e09560:	e12fff1e 	bx	lr
57e09564:	57e383e8 	.word	0x57e383e8

57e09568 <dbg>:
	cursor += strlen(printbuffer);

}
#else
inline void dbg(const char *fmt, ...)
{
57e09568:	e92d000f 	push	{r0, r1, r2, r3}
}
57e0956c:	e28dd010 	add	sp, sp, #16
57e09570:	e12fff1e 	bx	lr

57e09574 <search_device>:
#endif

/** U-Boot INIT FUNCTIONS *************************************************/

struct stdio_dev *search_device(int flags, const char *name)
{
57e09574:	e92d4010 	push	{r4, lr}
57e09578:	e1a04000 	mov	r4, r0
	struct stdio_dev *dev;

	dev = stdio_get_by_name(name);
57e0957c:	e1a00001 	mov	r0, r1
57e09580:	eb0018e4 	bl	57e0f918 <stdio_get_by_name>

	if (dev && (dev->flags & flags))
57e09584:	e3500000 	cmp	r0, #0
57e09588:	08bd8010 	popeq	{r4, pc}
57e0958c:	e5903000 	ldr	r3, [r0]
57e09590:	e0144003 	ands	r4, r4, r3
		return dev;

	return NULL;
57e09594:	01a00004 	moveq	r0, r4
}
57e09598:	e8bd8010 	pop	{r4, pc}

57e0959c <console_assign>:

int console_assign(int file, const char *devname)
{
57e0959c:	e92d4010 	push	{r4, lr}
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
57e095a0:	e2504000 	subs	r4, r0, #0
	case stdin:
		flag = DEV_FLAGS_INPUT;
57e095a4:	03a00001 	moveq	r0, #1
{
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
57e095a8:	0a000003 	beq	57e095bc <console_assign+0x20>
57e095ac:	ba000008 	blt	57e095d4 <console_assign+0x38>
57e095b0:	e3540002 	cmp	r4, #2
57e095b4:	ca000006 	bgt	57e095d4 <console_assign+0x38>
	case stdin:
		flag = DEV_FLAGS_INPUT;
		break;
	case stdout:
	case stderr:
		flag = DEV_FLAGS_OUTPUT;
57e095b8:	e3a00002 	mov	r0, #2
		return -1;
	}

	/* Check for valid device name */

	dev = search_device(flag, devname);
57e095bc:	ebffffec 	bl	57e09574 <search_device>

	if (dev)
57e095c0:	e2501000 	subs	r1, r0, #0
57e095c4:	0a000002 	beq	57e095d4 <console_assign+0x38>
		return console_setfile(file, dev);
57e095c8:	e1a00004 	mov	r0, r4

	return -1;
}
57e095cc:	e8bd4010 	pop	{r4, lr}
	/* Check for valid device name */

	dev = search_device(flag, devname);

	if (dev)
		return console_setfile(file, dev);
57e095d0:	eaffff00 	b	57e091d8 <console_setfile>

	return -1;
}
57e095d4:	e3e00000 	mvn	r0, #0
57e095d8:	e8bd8010 	pop	{r4, pc}

57e095dc <on_console>:

DECLARE_GLOBAL_DATA_PTR;

static int on_console(const char *name, const char *value, enum env_op op,
	int flags)
{
57e095dc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e095e0:	e1a05001 	mov	r5, r1
	int console = -1;

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
57e095e4:	e59f10a4 	ldr	r1, [pc, #164]	; 57e09690 <on_console+0xb4>

DECLARE_GLOBAL_DATA_PTR;

static int on_console(const char *name, const char *value, enum env_op op,
	int flags)
{
57e095e8:	e1a04000 	mov	r4, r0
57e095ec:	e1a06002 	mov	r6, r2
57e095f0:	e1a07003 	mov	r7, r3
	int console = -1;

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
57e095f4:	eb006a6a 	bl	57e23fa4 <strcmp>
57e095f8:	e3500000 	cmp	r0, #0
57e095fc:	0a00000b 	beq	57e09630 <on_console+0x54>
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
57e09600:	e1a00004 	mov	r0, r4
57e09604:	e59f1088 	ldr	r1, [pc, #136]	; 57e09694 <on_console+0xb8>
57e09608:	eb006a65 	bl	57e23fa4 <strcmp>
57e0960c:	e3500000 	cmp	r0, #0
		console = stdout;
57e09610:	03a00001 	moveq	r0, #1
	int console = -1;

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
57e09614:	0a000005 	beq	57e09630 <on_console+0x54>
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
57e09618:	e1a00004 	mov	r0, r4
57e0961c:	e59f1074 	ldr	r1, [pc, #116]	; 57e09698 <on_console+0xbc>
57e09620:	eb006a5f 	bl	57e23fa4 <strcmp>
57e09624:	e3500000 	cmp	r0, #0
		console = stderr;
57e09628:	02800002 	addeq	r0, r0, #2
	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
57e0962c:	1a000013 	bne	57e09680 <on_console+0xa4>
		console = stderr;

	/* if not actually setting a console variable, we don't care */
	if (console == -1 || (gd->flags & GD_FLG_DEVINIT) == 0)
57e09630:	e5983004 	ldr	r3, [r8, #4]
57e09634:	e2133002 	ands	r3, r3, #2
		return 0;
57e09638:	01a00003 	moveq	r0, r3
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
		console = stderr;

	/* if not actually setting a console variable, we don't care */
	if (console == -1 || (gd->flags & GD_FLG_DEVINIT) == 0)
57e0963c:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return 0;

	switch (op) {
57e09640:	e3560001 	cmp	r6, #1
57e09644:	0a000006 	beq	57e09664 <on_console+0x88>
57e09648:	3a000001 	bcc	57e09654 <on_console+0x78>
57e0964c:	e3560002 	cmp	r6, #2
57e09650:	1a00000a 	bne	57e09680 <on_console+0xa4>
#ifdef CONFIG_CONSOLE_MUX
		if (iomux_doenv(console, value))
			return 1;
#else
		/* Try assigning specified device */
		if (console_assign(console, value) < 0)
57e09654:	e1a01005 	mov	r1, r5
57e09658:	ebffffcf 	bl	57e0959c <console_assign>
	else if (strcmp(name, "stderr") == 0)
		console = stderr;

	/* if not actually setting a console variable, we don't care */
	if (console == -1 || (gd->flags & GD_FLG_DEVINIT) == 0)
		return 0;
57e0965c:	e1a00fa0 	lsr	r0, r0, #31
57e09660:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			return 1;
#endif /* CONFIG_CONSOLE_MUX */
		return 0;

	case env_op_delete:
		if ((flags & H_FORCE) == 0)
57e09664:	e3170002 	tst	r7, #2
57e09668:	1a000006 	bne	57e09688 <on_console+0xac>
			printf("Can't delete \"%s\"\n", name);
57e0966c:	e59f0028 	ldr	r0, [pc, #40]	; 57e0969c <on_console+0xc0>
57e09670:	e1a01004 	mov	r1, r4
57e09674:	ebffff74 	bl	57e0944c <printf>
		return 1;
57e09678:	e1a00006 	mov	r0, r6
57e0967c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

	default:
		return 0;
57e09680:	e3a00000 	mov	r0, #0
57e09684:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		return 0;

	case env_op_delete:
		if ((flags & H_FORCE) == 0)
			printf("Can't delete \"%s\"\n", name);
		return 1;
57e09688:	e1a00006 	mov	r0, r6

	default:
		return 0;
	}
}
57e0968c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e09690:	57e31de4 	.word	0x57e31de4
57e09694:	57e31dea 	.word	0x57e31dea
57e09698:	57e31df1 	.word	0x57e31df1
57e0969c:	57e3209e 	.word	0x57e3209e

57e096a0 <console_init_f>:
}

/* Called before relocation - use serial functions */
int console_init_f(void)
{
	gd->have_console = 1;
57e096a0:	e3a02001 	mov	r2, #1
57e096a4:	e588200c 	str	r2, [r8, #12]
#endif

	print_pre_console_buffer();

	return 0;
}
57e096a8:	e3a00000 	mov	r0, #0
57e096ac:	e12fff1e 	bx	lr

57e096b0 <stdio_print_current_devices>:

void stdio_print_current_devices(void)
{
57e096b0:	e92d4010 	push	{r4, lr}
	/* Print information */
	puts("In:    ");
57e096b4:	e59f008c 	ldr	r0, [pc, #140]	; 57e09748 <stdio_print_current_devices+0x98>
57e096b8:	ebffff59 	bl	57e09424 <puts>
	if (stdio_devices[stdin] == NULL) {
57e096bc:	e59f3088 	ldr	r3, [pc, #136]	; 57e0974c <stdio_print_current_devices+0x9c>
57e096c0:	e5931000 	ldr	r1, [r3]
57e096c4:	e3510000 	cmp	r1, #0
57e096c8:	1a000002 	bne	57e096d8 <stdio_print_current_devices+0x28>
		puts("No input devices available!\n");
57e096cc:	e59f007c 	ldr	r0, [pc, #124]	; 57e09750 <stdio_print_current_devices+0xa0>
57e096d0:	ebffff53 	bl	57e09424 <puts>
57e096d4:	ea000002 	b	57e096e4 <stdio_print_current_devices+0x34>
	} else {
		printf ("%s\n", stdio_devices[stdin]->name);
57e096d8:	e59f0074 	ldr	r0, [pc, #116]	; 57e09754 <stdio_print_current_devices+0xa4>
57e096dc:	e2811008 	add	r1, r1, #8
57e096e0:	ebffff59 	bl	57e0944c <printf>
	}

	puts("Out:   ");
57e096e4:	e59f006c 	ldr	r0, [pc, #108]	; 57e09758 <stdio_print_current_devices+0xa8>
57e096e8:	ebffff4d 	bl	57e09424 <puts>
	if (stdio_devices[stdout] == NULL) {
57e096ec:	e59f3058 	ldr	r3, [pc, #88]	; 57e0974c <stdio_print_current_devices+0x9c>
57e096f0:	e5931004 	ldr	r1, [r3, #4]
57e096f4:	e3510000 	cmp	r1, #0
57e096f8:	1a000002 	bne	57e09708 <stdio_print_current_devices+0x58>
		puts("No output devices available!\n");
57e096fc:	e59f0058 	ldr	r0, [pc, #88]	; 57e0975c <stdio_print_current_devices+0xac>
57e09700:	ebffff47 	bl	57e09424 <puts>
57e09704:	ea000002 	b	57e09714 <stdio_print_current_devices+0x64>
	} else {
		printf ("%s\n", stdio_devices[stdout]->name);
57e09708:	e59f0044 	ldr	r0, [pc, #68]	; 57e09754 <stdio_print_current_devices+0xa4>
57e0970c:	e2811008 	add	r1, r1, #8
57e09710:	ebffff4d 	bl	57e0944c <printf>
	}

	puts("Err:   ");
57e09714:	e59f0044 	ldr	r0, [pc, #68]	; 57e09760 <stdio_print_current_devices+0xb0>
57e09718:	ebffff41 	bl	57e09424 <puts>
	if (stdio_devices[stderr] == NULL) {
57e0971c:	e59f3028 	ldr	r3, [pc, #40]	; 57e0974c <stdio_print_current_devices+0x9c>
57e09720:	e5931008 	ldr	r1, [r3, #8]
57e09724:	e3510000 	cmp	r1, #0
57e09728:	1a000002 	bne	57e09738 <stdio_print_current_devices+0x88>
		puts("No error devices available!\n");
57e0972c:	e59f0030 	ldr	r0, [pc, #48]	; 57e09764 <stdio_print_current_devices+0xb4>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
	}
}
57e09730:	e8bd4010 	pop	{r4, lr}
		printf ("%s\n", stdio_devices[stdout]->name);
	}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
57e09734:	eaffff3a 	b	57e09424 <puts>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
57e09738:	e59f0014 	ldr	r0, [pc, #20]	; 57e09754 <stdio_print_current_devices+0xa4>
57e0973c:	e2811008 	add	r1, r1, #8
	}
}
57e09740:	e8bd4010 	pop	{r4, lr}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
57e09744:	eaffff40 	b	57e0944c <printf>
57e09748:	57e31df8 	.word	0x57e31df8
57e0974c:	57e39c2c 	.word	0x57e39c2c
57e09750:	57e31e00 	.word	0x57e31e00
57e09754:	57e31b63 	.word	0x57e31b63
57e09758:	57e31e1d 	.word	0x57e31e1d
57e0975c:	57e31e25 	.word	0x57e31e25
57e09760:	57e31e43 	.word	0x57e31e43
57e09764:	57e31e4b 	.word	0x57e31e4b

57e09768 <console_init_r>:

#else /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

/* Called after the relocation - use desired console functions */
int console_init_r(void)
{
57e09768:	e92d4070 	push	{r4, r5, r6, lr}
	struct stdio_dev *inputdev = NULL, *outputdev = NULL;
	int i;
	struct list_head *list = stdio_get_list();
57e0976c:	eb001866 	bl	57e0f90c <stdio_get_list>
#else /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

/* Called after the relocation - use desired console functions */
int console_init_r(void)
{
	struct stdio_dev *inputdev = NULL, *outputdev = NULL;
57e09770:	e3a04000 	mov	r4, #0
			outputdev = search_device (DEV_FLAGS_OUTPUT, "serial");
	}
#endif

	/* Scan devices looking for input and output devices */
	list_for_each(pos, list) {
57e09774:	e5903000 	ldr	r3, [r0]
#else /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

/* Called after the relocation - use desired console functions */
int console_init_r(void)
{
	struct stdio_dev *inputdev = NULL, *outputdev = NULL;
57e09778:	e1a05004 	mov	r5, r4
			outputdev = search_device (DEV_FLAGS_OUTPUT, "serial");
	}
#endif

	/* Scan devices looking for input and output devices */
	list_for_each(pos, list) {
57e0977c:	ea000012 	b	57e097cc <console_init_r+0x64>
		dev = list_entry(pos, struct stdio_dev, list);

		if ((dev->flags & DEV_FLAGS_INPUT) && (inputdev == NULL)) {
57e09780:	e5131034 	ldr	r1, [r3, #-52]	; 0x34
	}
#endif

	/* Scan devices looking for input and output devices */
	list_for_each(pos, list) {
		dev = list_entry(pos, struct stdio_dev, list);
57e09784:	e2432034 	sub	r2, r3, #52	; 0x34

		if ((dev->flags & DEV_FLAGS_INPUT) && (inputdev == NULL)) {
57e09788:	e3550000 	cmp	r5, #0
57e0978c:	13a0c000 	movne	ip, #0
57e09790:	0201c001 	andeq	ip, r1, #1
57e09794:	e35c0000 	cmp	ip, #0
57e09798:	11a05002 	movne	r5, r2
			inputdev = dev;
		}
		if ((dev->flags & DEV_FLAGS_OUTPUT) && (outputdev == NULL)) {
57e0979c:	e3110002 	tst	r1, #2
57e097a0:	03a01000 	moveq	r1, #0
57e097a4:	13a01001 	movne	r1, #1
57e097a8:	e3540000 	cmp	r4, #0
57e097ac:	13a01000 	movne	r1, #0
57e097b0:	02011001 	andeq	r1, r1, #1
57e097b4:	e3510000 	cmp	r1, #0
57e097b8:	11a04002 	movne	r4, r2
			outputdev = dev;
		}
		if(inputdev && outputdev)
57e097bc:	e3540000 	cmp	r4, #0
57e097c0:	13550000 	cmpne	r5, #0
57e097c4:	1a000002 	bne	57e097d4 <console_init_r+0x6c>
			outputdev = search_device (DEV_FLAGS_OUTPUT, "serial");
	}
#endif

	/* Scan devices looking for input and output devices */
	list_for_each(pos, list) {
57e097c8:	e5933000 	ldr	r3, [r3]
57e097cc:	e1530000 	cmp	r3, r0
57e097d0:	1affffea 	bne	57e09780 <console_init_r+0x18>
		if(inputdev && outputdev)
			break;
	}

	/* Initializes output console first */
	if (outputdev != NULL) {
57e097d4:	e3540000 	cmp	r4, #0
57e097d8:	0a000005 	beq	57e097f4 <console_init_r+0x8c>
		console_setfile(stdout, outputdev);
57e097dc:	e1a01004 	mov	r1, r4
57e097e0:	e3a00001 	mov	r0, #1
57e097e4:	ebfffe7b 	bl	57e091d8 <console_setfile>
		console_setfile(stderr, outputdev);
57e097e8:	e3a00002 	mov	r0, #2
57e097ec:	e1a01004 	mov	r1, r4
57e097f0:	ebfffe78 	bl	57e091d8 <console_setfile>
		console_devices[stderr][0] = outputdev;
#endif
	}

	/* Initializes input console */
	if (inputdev != NULL) {
57e097f4:	e3550000 	cmp	r5, #0
57e097f8:	0a000002 	beq	57e09808 <console_init_r+0xa0>
		console_setfile(stdin, inputdev);
57e097fc:	e3a00000 	mov	r0, #0
57e09800:	e1a01005 	mov	r1, r5
57e09804:	ebfffe73 	bl	57e091d8 <console_setfile>
		console_devices[stdin][0] = inputdev;
#endif
	}

#ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
	stdio_print_current_devices();
57e09808:	ebffffa8 	bl	57e096b0 <stdio_print_current_devices>
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */

	/* Setting environment variables */
	for (i = 0; i < 3; i++) {
		setenv(stdio_names[i], stdio_devices[i]->name);
57e0980c:	e59f6034 	ldr	r6, [pc, #52]	; 57e09848 <console_init_r+0xe0>
57e09810:	e59f5034 	ldr	r5, [pc, #52]	; 57e0984c <console_init_r+0xe4>
		console_devices[stdin][0] = inputdev;
#endif
	}

#ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
	stdio_print_current_devices();
57e09814:	e3a04000 	mov	r4, #0
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */

	/* Setting environment variables */
	for (i = 0; i < 3; i++) {
		setenv(stdio_names[i], stdio_devices[i]->name);
57e09818:	e7941005 	ldr	r1, [r4, r5]
57e0981c:	e7940006 	ldr	r0, [r4, r6]
57e09820:	e2811008 	add	r1, r1, #8
57e09824:	e2844004 	add	r4, r4, #4
57e09828:	ebfff6a0 	bl	57e072b0 <setenv>
#ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
	stdio_print_current_devices();
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */

	/* Setting environment variables */
	for (i = 0; i < 3; i++) {
57e0982c:	e354000c 	cmp	r4, #12
57e09830:	1afffff8 	bne	57e09818 <console_init_r+0xb0>
		setenv(stdio_names[i], stdio_devices[i]->name);
	}

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
57e09834:	e5982004 	ldr	r2, [r8, #4]
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return 0;
#endif

	return 0;
}
57e09838:	e3a00000 	mov	r0, #0
	/* Setting environment variables */
	for (i = 0; i < 3; i++) {
		setenv(stdio_names[i], stdio_devices[i]->name);
	}

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
57e0983c:	e3822002 	orr	r2, r2, #2
57e09840:	e5882004 	str	r2, [r8, #4]
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return 0;
#endif

	return 0;
}
57e09844:	e8bd8070 	pop	{r4, r5, r6, pc}
57e09848:	57e36e68 	.word	0x57e36e68
57e0984c:	57e39c2c 	.word	0x57e39c2c

57e09850 <sbrk>:
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
57e09850:	e92d4038 	push	{r3, r4, r5, lr}
	ulong old = mem_malloc_brk;
57e09854:	e59f304c 	ldr	r3, [pc, #76]	; 57e098a8 <sbrk+0x58>

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
57e09858:	e3500000 	cmp	r0, #0
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
57e0985c:	e5935000 	ldr	r5, [r3]
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
57e09860:	e1a02000 	mov	r2, r0
	ulong old = mem_malloc_brk;
	ulong new = old + increment;
57e09864:	e0804005 	add	r4, r0, r5

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
57e09868:	aa000003 	bge	57e0987c <sbrk+0x2c>
		memset((void *)new, 0, -increment);
57e0986c:	e1a00004 	mov	r0, r4
57e09870:	e3a01000 	mov	r1, #0
57e09874:	e2622000 	rsb	r2, r2, #0
57e09878:	eb006a7f 	bl	57e2427c <memset>

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
57e0987c:	e59f3024 	ldr	r3, [pc, #36]	; 57e098a8 <sbrk+0x58>
57e09880:	e5932004 	ldr	r2, [r3, #4]
57e09884:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;
57e09888:	33e00000 	mvncc	r0, #0
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
57e0988c:	38bd8038 	popcc	{r3, r4, r5, pc}
57e09890:	e5932008 	ldr	r2, [r3, #8]
57e09894:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;

	mem_malloc_brk = new;
57e09898:	95834000 	strls	r4, [r3]

	return (void *)old;
57e0989c:	91a00005 	movls	r0, r5
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
		return (void *)MORECORE_FAILURE;
57e098a0:	83e00000 	mvnhi	r0, #0

	mem_malloc_brk = new;

	return (void *)old;
}
57e098a4:	e8bd8038 	pop	{r3, r4, r5, pc}
57e098a8:	57e383f0 	.word	0x57e383f0

57e098ac <mem_malloc_init>:

void mem_malloc_init(ulong start, ulong size)
{
57e098ac:	e1a02001 	mov	r2, r1
	mem_malloc_start = start;
57e098b0:	e59f1010 	ldr	r1, [pc, #16]	; 57e098c8 <mem_malloc_init+0x1c>
	mem_malloc_end = start + size;
57e098b4:	e082c000 	add	ip, r2, r0
	return (void *)old;
}

void mem_malloc_init(ulong start, ulong size)
{
	mem_malloc_start = start;
57e098b8:	e9811001 	stmib	r1, {r0, ip}
	mem_malloc_end = start + size;
	mem_malloc_brk = start;
57e098bc:	e5810000 	str	r0, [r1]

	memset((void *)mem_malloc_start, 0, size);
57e098c0:	e3a01000 	mov	r1, #0
57e098c4:	ea006a6c 	b	57e2427c <memset>
57e098c8:	57e383f0 	.word	0x57e383f0

57e098cc <malloc_trim>:
#if __STD_C
int malloc_trim(size_t pad)
#else
int malloc_trim(pad) size_t pad;
#endif
{
57e098cc:	e92d4070 	push	{r4, r5, r6, lr}
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  top_size = chunksize(top);
57e098d0:	e59f40bc 	ldr	r4, [pc, #188]	; 57e09994 <malloc_trim+0xc8>
57e098d4:	e5943008 	ldr	r3, [r4, #8]
57e098d8:	e5936004 	ldr	r6, [r3, #4]
57e098dc:	e3c66003 	bic	r6, r6, #3
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
57e098e0:	e0605006 	rsb	r5, r0, r6
57e098e4:	e2855efe 	add	r5, r5, #4064	; 0xfe0
57e098e8:	e285500f 	add	r5, r5, #15
57e098ec:	e3c55eff 	bic	r5, r5, #4080	; 0xff0
57e098f0:	e3c5500f 	bic	r5, r5, #15
57e098f4:	e2455a01 	sub	r5, r5, #4096	; 0x1000

  if (extra < (long)pagesz)  /* Not enough memory to release */
57e098f8:	e3550a01 	cmp	r5, #4096	; 0x1000
57e098fc:	ba000020 	blt	57e09984 <malloc_trim+0xb8>
    return 0;

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
57e09900:	e3a00000 	mov	r0, #0
57e09904:	ebffffd1 	bl	57e09850 <sbrk>
    if (current_brk != (char*)(top) + top_size)
57e09908:	e5943008 	ldr	r3, [r4, #8]
57e0990c:	e0833006 	add	r3, r3, r6
57e09910:	e1500003 	cmp	r0, r3
57e09914:	1a00001a 	bne	57e09984 <malloc_trim+0xb8>
      return 0;     /* Apparently we don't own memory; must fail */

    else
    {
      new_brk = (char*)(MORECORE (-extra));
57e09918:	e2650000 	rsb	r0, r5, #0
57e0991c:	ebffffcb 	bl	57e09850 <sbrk>

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
57e09920:	e3700001 	cmn	r0, #1
57e09924:	1a00000c 	bne	57e0995c <malloc_trim+0x90>
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
57e09928:	e2800001 	add	r0, r0, #1
57e0992c:	ebffffc7 	bl	57e09850 <sbrk>
	top_size = current_brk - (char*)top;
57e09930:	e5943008 	ldr	r3, [r4, #8]
57e09934:	e0632000 	rsb	r2, r3, r0
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
57e09938:	e352000f 	cmp	r2, #15
57e0993c:	da000012 	ble	57e0998c <malloc_trim+0xc0>
	{
	  sbrked_mem = current_brk - sbrk_base;
57e09940:	e5941408 	ldr	r1, [r4, #1032]	; 0x408
	  set_head(top, top_size | PREV_INUSE);
57e09944:	e3822001 	orr	r2, r2, #1
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
57e09948:	e0610000 	rsb	r0, r1, r0
57e0994c:	e59f1044 	ldr	r1, [pc, #68]	; 57e09998 <malloc_trim+0xcc>
	  set_head(top, top_size | PREV_INUSE);
57e09950:	e5832004 	str	r2, [r3, #4]
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
57e09954:	e581000c 	str	r0, [r1, #12]
57e09958:	ea000009 	b	57e09984 <malloc_trim+0xb8>
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
57e0995c:	e5943008 	ldr	r3, [r4, #8]
57e09960:	e0656006 	rsb	r6, r5, r6
57e09964:	e3866001 	orr	r6, r6, #1
57e09968:	e5836004 	str	r6, [r3, #4]
	sbrked_mem -= extra;
57e0996c:	e59f3024 	ldr	r3, [pc, #36]	; 57e09998 <malloc_trim+0xcc>
	check_chunk(top);
	return 1;
57e09970:	e3a00001 	mov	r0, #1

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
	sbrked_mem -= extra;
57e09974:	e593200c 	ldr	r2, [r3, #12]
57e09978:	e0655002 	rsb	r5, r5, r2
57e0997c:	e583500c 	str	r5, [r3, #12]
	check_chunk(top);
	return 1;
57e09980:	e8bd8070 	pop	{r4, r5, r6, pc}
  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
    if (current_brk != (char*)(top) + top_size)
      return 0;     /* Apparently we don't own memory; must fail */
57e09984:	e3a00000 	mov	r0, #0
57e09988:	e8bd8070 	pop	{r4, r5, r6, pc}
	{
	  sbrked_mem = current_brk - sbrk_base;
	  set_head(top, top_size | PREV_INUSE);
	}
	check_chunk(top);
	return 0;
57e0998c:	e3a00000 	mov	r0, #0
	check_chunk(top);
	return 1;
      }
    }
  }
}
57e09990:	e8bd8070 	pop	{r4, r5, r6, pc}
57e09994:	57e369b0 	.word	0x57e369b0
57e09998:	57e383f0 	.word	0x57e383f0

57e0999c <free>:
#if __STD_C
void fREe(Void_t* mem)
#else
void fREe(mem) Void_t* mem;
#endif
{
57e0999c:	e92d4070 	push	{r4, r5, r6, lr}
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == NULL)                              /* free(0) has no effect */
57e099a0:	e2504000 	subs	r4, r0, #0
57e099a4:	08bd8070 	popeq	{r4, r5, r6, pc}
    return;

  p = mem2chunk(mem);
  hd = p->size;
57e099a8:	e5140004 	ldr	r0, [r4, #-4]

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
57e099ac:	e59f51fc 	ldr	r5, [pc, #508]	; 57e09bb0 <free+0x214>
  }
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
57e099b0:	e3c02001 	bic	r2, r0, #1
  int       islr;      /* track whether merging with last_remainder */

  if (mem == NULL)                              /* free(0) has no effect */
    return;

  p = mem2chunk(mem);
57e099b4:	e2443008 	sub	r3, r4, #8
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
57e099b8:	e0831002 	add	r1, r3, r2
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
57e099bc:	e5956008 	ldr	r6, [r5, #8]

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
57e099c0:	e591c004 	ldr	ip, [r1, #4]

  if (next == top)                            /* merge with top */
57e099c4:	e1510006 	cmp	r1, r6

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
57e099c8:	e3ccc003 	bic	ip, ip, #3
57e099cc:	e2000001 	and	r0, r0, #1

  if (next == top)                            /* merge with top */
57e099d0:	1a000014 	bne	57e09a28 <free+0x8c>
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
57e099d4:	e3500000 	cmp	r0, #0
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
57e099d8:	e08c2002 	add	r2, ip, r2

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
57e099dc:	1a000006 	bne	57e099fc <free+0x60>
    {
      prevsz = p->prev_size;
57e099e0:	e5141008 	ldr	r1, [r4, #-8]
      p = chunk_at_offset(p, -((long) prevsz));
57e099e4:	e0613003 	rsb	r3, r1, r3
      sz += prevsz;
      unlink(p, bck, fwd);
57e099e8:	e5930008 	ldr	r0, [r3, #8]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -((long) prevsz));
      sz += prevsz;
57e099ec:	e0822001 	add	r2, r2, r1
      unlink(p, bck, fwd);
57e099f0:	e593100c 	ldr	r1, [r3, #12]
57e099f4:	e580100c 	str	r1, [r0, #12]
57e099f8:	e5810008 	str	r0, [r1, #8]
    }

    set_head(p, sz | PREV_INUSE);
57e099fc:	e3821001 	orr	r1, r2, #1
57e09a00:	e5831004 	str	r1, [r3, #4]
    top = p;
57e09a04:	e59f11a4 	ldr	r1, [pc, #420]	; 57e09bb0 <free+0x214>
57e09a08:	e5813008 	str	r3, [r1, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
57e09a0c:	e591340c 	ldr	r3, [r1, #1036]	; 0x40c
57e09a10:	e1520003 	cmp	r2, r3
57e09a14:	38bd8070 	popcc	{r4, r5, r6, pc}
      malloc_trim(top_pad);
57e09a18:	e59f3194 	ldr	r3, [pc, #404]	; 57e09bb4 <free+0x218>
57e09a1c:	e5930034 	ldr	r0, [r3, #52]	; 0x34

  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);
}
57e09a20:	e8bd4070 	pop	{r4, r5, r6, lr}
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
57e09a24:	eaffffa8 	b	57e098cc <malloc_trim>

  set_head(next, nextsz);                    /* clear inuse bit */

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
57e09a28:	e3500000 	cmp	r0, #0
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
57e09a2c:	e581c004 	str	ip, [r1, #4]

  islr = 0;
57e09a30:	13a00000 	movne	r0, #0

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
57e09a34:	1a000009 	bne	57e09a60 <free+0xc4>
  {
    prevsz = p->prev_size;
57e09a38:	e5144008 	ldr	r4, [r4, #-8]
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
57e09a3c:	e2855008 	add	r5, r5, #8
  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
57e09a40:	e0643003 	rsb	r3, r4, r3
    sz += prevsz;
57e09a44:	e0822004 	add	r2, r2, r4

    if (p->fd == last_remainder)             /* keep as last_remainder */
57e09a48:	e5934008 	ldr	r4, [r3, #8]
57e09a4c:	e1540005 	cmp	r4, r5
      islr = 1;
    else
      unlink(p, bck, fwd);
57e09a50:	1593500c 	ldrne	r5, [r3, #12]
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
      islr = 1;
57e09a54:	03a00001 	moveq	r0, #1
    else
      unlink(p, bck, fwd);
57e09a58:	1584500c 	strne	r5, [r4, #12]
57e09a5c:	15854008 	strne	r4, [r5, #8]
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
57e09a60:	e081400c 	add	r4, r1, ip
57e09a64:	e5944004 	ldr	r4, [r4, #4]
57e09a68:	e3140001 	tst	r4, #1
57e09a6c:	1a000010 	bne	57e09ab4 <free+0x118>
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
57e09a70:	e3500000 	cmp	r0, #0
      unlink(p, bck, fwd);
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
57e09a74:	e082200c 	add	r2, r2, ip

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
57e09a78:	1a000009 	bne	57e09aa4 <free+0x108>
57e09a7c:	e591c008 	ldr	ip, [r1, #8]
57e09a80:	e59f4130 	ldr	r4, [pc, #304]	; 57e09bb8 <free+0x21c>
57e09a84:	e15c0004 	cmp	ip, r4
57e09a88:	1a000005 	bne	57e09aa4 <free+0x108>
    {
      islr = 1;
      link_last_remainder(p);
57e09a8c:	e58c300c 	str	r3, [ip, #12]
57e09a90:	e58c3008 	str	r3, [ip, #8]
57e09a94:	e583c00c 	str	ip, [r3, #12]
57e09a98:	e583c008 	str	ip, [r3, #8]
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
57e09a9c:	e2800001 	add	r0, r0, #1
      link_last_remainder(p);
57e09aa0:	ea000003 	b	57e09ab4 <free+0x118>
    }
    else
      unlink(next, bck, fwd);
57e09aa4:	e591c00c 	ldr	ip, [r1, #12]
57e09aa8:	e5911008 	ldr	r1, [r1, #8]
57e09aac:	e581c00c 	str	ip, [r1, #12]
57e09ab0:	e58c1008 	str	r1, [ip, #8]
  }


  set_head(p, sz | PREV_INUSE);
57e09ab4:	e3821001 	orr	r1, r2, #1
  set_foot(p, sz);
  if (!islr)
57e09ab8:	e3500000 	cmp	r0, #0
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
57e09abc:	e5831004 	str	r1, [r3, #4]
  set_foot(p, sz);
57e09ac0:	e7832002 	str	r2, [r3, r2]
  if (!islr)
57e09ac4:	18bd8070 	popne	{r4, r5, r6, pc}
    frontlink(p, sz, idx, bck, fwd);
57e09ac8:	e3520c02 	cmp	r2, #512	; 0x200
57e09acc:	2a000009 	bcs	57e09af8 <free+0x15c>
57e09ad0:	e59f10d8 	ldr	r1, [pc, #216]	; 57e09bb0 <free+0x214>
57e09ad4:	e1a021a2 	lsr	r2, r2, #3
57e09ad8:	e591c004 	ldr	ip, [r1, #4]
57e09adc:	e1a00142 	asr	r0, r2, #2
57e09ae0:	e3a04001 	mov	r4, #1
57e09ae4:	e18c0014 	orr	r0, ip, r4, lsl r0
57e09ae8:	e0812182 	add	r2, r1, r2, lsl #3
57e09aec:	e5810004 	str	r0, [r1, #4]
57e09af0:	e5921008 	ldr	r1, [r2, #8]
57e09af4:	ea000028 	b	57e09b9c <free+0x200>
57e09af8:	e1a004a2 	lsr	r0, r2, #9
57e09afc:	e3500004 	cmp	r0, #4
57e09b00:	91a00322 	lsrls	r0, r2, #6
57e09b04:	92800038 	addls	r0, r0, #56	; 0x38
57e09b08:	9a00000f 	bls	57e09b4c <free+0x1b0>
57e09b0c:	e3500014 	cmp	r0, #20
57e09b10:	9280005b 	addls	r0, r0, #91	; 0x5b
57e09b14:	9a00000c 	bls	57e09b4c <free+0x1b0>
57e09b18:	e3500054 	cmp	r0, #84	; 0x54
57e09b1c:	91a00622 	lsrls	r0, r2, #12
57e09b20:	9280006e 	addls	r0, r0, #110	; 0x6e
57e09b24:	9a000008 	bls	57e09b4c <free+0x1b0>
57e09b28:	e3500f55 	cmp	r0, #340	; 0x154
57e09b2c:	91a007a2 	lsrls	r0, r2, #15
57e09b30:	92800077 	addls	r0, r0, #119	; 0x77
57e09b34:	9a000004 	bls	57e09b4c <free+0x1b0>
57e09b38:	e59f107c 	ldr	r1, [pc, #124]	; 57e09bbc <free+0x220>
57e09b3c:	e1500001 	cmp	r0, r1
57e09b40:	91a00922 	lsrls	r0, r2, #18
57e09b44:	9280007c 	addls	r0, r0, #124	; 0x7c
57e09b48:	83a0007e 	movhi	r0, #126	; 0x7e
57e09b4c:	e59fc05c 	ldr	ip, [pc, #92]	; 57e09bb0 <free+0x214>
57e09b50:	e08c4180 	add	r4, ip, r0, lsl #3
57e09b54:	e5941008 	ldr	r1, [r4, #8]
57e09b58:	e1510004 	cmp	r1, r4
57e09b5c:	1a000009 	bne	57e09b88 <free+0x1ec>
57e09b60:	e59c2004 	ldr	r2, [ip, #4]
57e09b64:	e1a00140 	asr	r0, r0, #2
57e09b68:	e3a04001 	mov	r4, #1
57e09b6c:	e1820014 	orr	r0, r2, r4, lsl r0
57e09b70:	e1a02001 	mov	r2, r1
57e09b74:	e58c0004 	str	r0, [ip, #4]
57e09b78:	ea000007 	b	57e09b9c <free+0x200>
57e09b7c:	e5911008 	ldr	r1, [r1, #8]
57e09b80:	e1510004 	cmp	r1, r4
57e09b84:	0a000003 	beq	57e09b98 <free+0x1fc>
57e09b88:	e5910004 	ldr	r0, [r1, #4]
57e09b8c:	e3c00003 	bic	r0, r0, #3
57e09b90:	e1520000 	cmp	r2, r0
57e09b94:	3afffff8 	bcc	57e09b7c <free+0x1e0>
57e09b98:	e591200c 	ldr	r2, [r1, #12]
57e09b9c:	e583200c 	str	r2, [r3, #12]
57e09ba0:	e5831008 	str	r1, [r3, #8]
57e09ba4:	e5823008 	str	r3, [r2, #8]
57e09ba8:	e581300c 	str	r3, [r1, #12]
57e09bac:	e8bd8070 	pop	{r4, r5, r6, pc}
57e09bb0:	57e369b0 	.word	0x57e369b0
57e09bb4:	57e383f0 	.word	0x57e383f0
57e09bb8:	57e369b8 	.word	0x57e369b8
57e09bbc:	00000554 	.word	0x00000554

57e09bc0 <cfree>:
void cfree(Void_t *mem)
#else
void cfree(mem) Void_t *mem;
#endif
{
  fREe(mem);
57e09bc0:	eaffff75 	b	57e0999c <free>

57e09bc4 <malloc>:
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
57e09bc4:	e59f35a0 	ldr	r3, [pc, #1440]	; 57e0a16c <malloc+0x5a8>
#if __STD_C
Void_t* mALLOc(size_t bytes)
#else
Void_t* mALLOc(bytes) size_t bytes;
#endif
{
57e09bc8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
57e09bcc:	e5932004 	ldr	r2, [r3, #4]
57e09bd0:	e3520000 	cmp	r2, #0
57e09bd4:	1a000003 	bne	57e09be8 <malloc+0x24>
57e09bd8:	e5933008 	ldr	r3, [r3, #8]
57e09bdc:	e3530000 	cmp	r3, #0
    /* not initialized yet */
    return NULL;
57e09be0:	01a00003 	moveq	r0, r3
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
57e09be4:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
    /* not initialized yet */
    return NULL;
  }

  if ((long)bytes < 0) return NULL;
57e09be8:	e3500000 	cmp	r0, #0
57e09bec:	b3a00000 	movlt	r0, #0
57e09bf0:	b8bd8ef0 	poplt	{r4, r5, r6, r7, r9, sl, fp, pc}

  nb = request2size(bytes);  /* padded request size; */
57e09bf4:	e280400b 	add	r4, r0, #11
57e09bf8:	e3540016 	cmp	r4, #22
57e09bfc:	d3a04010 	movle	r4, #16
57e09c00:	da000002 	ble	57e09c10 <malloc+0x4c>
57e09c04:	e3c44007 	bic	r4, r4, #7

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
57e09c08:	e3540f7e 	cmp	r4, #504	; 0x1f8
57e09c0c:	2a00000d 	bcs	57e09c48 <malloc+0x84>
  {
    idx = smallbin_index(nb);

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
57e09c10:	e59f3558 	ldr	r3, [pc, #1368]	; 57e0a170 <malloc+0x5ac>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
  {
    idx = smallbin_index(nb);
57e09c14:	e1a011a4 	lsr	r1, r4, #3

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
57e09c18:	e0833181 	add	r3, r3, r1, lsl #3
    victim = last(q);
57e09c1c:	e593000c 	ldr	r0, [r3, #12]

    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
57e09c20:	e1500003 	cmp	r0, r3
57e09c24:	1a000004 	bne	57e09c3c <malloc+0x78>
    {
      q = next_bin(q);
57e09c28:	e2803008 	add	r3, r0, #8
      victim = last(q);
57e09c2c:	e593000c 	ldr	r0, [r3, #12]
    }
    if (victim != q)
57e09c30:	e1500003 	cmp	r0, r3
      set_inuse_bit_at_offset(victim, victim_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
57e09c34:	02811002 	addeq	r1, r1, #2
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
    }
    if (victim != q)
57e09c38:	0a00002e 	beq	57e09cf8 <malloc+0x134>
    {
      victim_size = chunksize(victim);
57e09c3c:	e5903004 	ldr	r3, [r0, #4]
57e09c40:	e3c33003 	bic	r3, r3, #3
57e09c44:	ea000022 	b	57e09cd4 <malloc+0x110>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
57e09c48:	e1b014a4 	lsrs	r1, r4, #9
57e09c4c:	01a011a4 	lsreq	r1, r4, #3
57e09c50:	0a000013 	beq	57e09ca4 <malloc+0xe0>
57e09c54:	e3510004 	cmp	r1, #4
57e09c58:	91a01324 	lsrls	r1, r4, #6
57e09c5c:	92811038 	addls	r1, r1, #56	; 0x38
57e09c60:	9a00000f 	bls	57e09ca4 <malloc+0xe0>
57e09c64:	e3510014 	cmp	r1, #20
57e09c68:	9281105b 	addls	r1, r1, #91	; 0x5b
57e09c6c:	9a00000c 	bls	57e09ca4 <malloc+0xe0>
57e09c70:	e3510054 	cmp	r1, #84	; 0x54
57e09c74:	91a01624 	lsrls	r1, r4, #12
57e09c78:	9281106e 	addls	r1, r1, #110	; 0x6e
57e09c7c:	9a000008 	bls	57e09ca4 <malloc+0xe0>
57e09c80:	e3510f55 	cmp	r1, #340	; 0x154
57e09c84:	91a017a4 	lsrls	r1, r4, #15
57e09c88:	92811077 	addls	r1, r1, #119	; 0x77
57e09c8c:	9a000004 	bls	57e09ca4 <malloc+0xe0>
57e09c90:	e59f34dc 	ldr	r3, [pc, #1244]	; 57e0a174 <malloc+0x5b0>
57e09c94:	e1510003 	cmp	r1, r3
57e09c98:	91a01924 	lsrls	r1, r4, #18
57e09c9c:	9281107c 	addls	r1, r1, #124	; 0x7c
57e09ca0:	83a0107e 	movhi	r1, #126	; 0x7e
    bin = bin_at(idx);
57e09ca4:	e59f24c4 	ldr	r2, [pc, #1220]	; 57e0a170 <malloc+0x5ac>
57e09ca8:	e0822181 	add	r2, r2, r1, lsl #3

    for (victim = last(bin); victim != bin; victim = victim->bk)
57e09cac:	e592000c 	ldr	r0, [r2, #12]
57e09cb0:	ea00000d 	b	57e09cec <malloc+0x128>
    {
      victim_size = chunksize(victim);
57e09cb4:	e5903004 	ldr	r3, [r0, #4]
57e09cb8:	e3c33003 	bic	r3, r3, #3
      remainder_size = victim_size - nb;
57e09cbc:	e064c003 	rsb	ip, r4, r3

      if (remainder_size >= (long)MINSIZE) /* too big */
57e09cc0:	e35c000f 	cmp	ip, #15
      {
	--idx; /* adjust to rescan below after checking last remainder */
57e09cc4:	c2411001 	subgt	r1, r1, #1
	break;
57e09cc8:	ca000009 	bgt	57e09cf4 <malloc+0x130>
      }

      else if (remainder_size >= 0) /* exact fit */
57e09ccc:	e35c0000 	cmp	ip, #0
57e09cd0:	ba000004 	blt	57e09ce8 <malloc+0x124>
      {
	unlink(victim, bck, fwd);
57e09cd4:	e590200c 	ldr	r2, [r0, #12]
57e09cd8:	e5901008 	ldr	r1, [r0, #8]
57e09cdc:	e581200c 	str	r2, [r1, #12]
57e09ce0:	e5821008 	str	r1, [r2, #8]
57e09ce4:	ea00001c 	b	57e09d5c <malloc+0x198>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
57e09ce8:	e590000c 	ldr	r0, [r0, #12]
57e09cec:	e1500002 	cmp	r0, r2
57e09cf0:	1affffef 	bne	57e09cb4 <malloc+0xf0>
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
      }
    }

    ++idx;
57e09cf4:	e2811001 	add	r1, r1, #1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
57e09cf8:	e59f5470 	ldr	r5, [pc, #1136]	; 57e0a170 <malloc+0x5ac>
57e09cfc:	e2852008 	add	r2, r5, #8
57e09d00:	e5920008 	ldr	r0, [r2, #8]
57e09d04:	e1500002 	cmp	r0, r2
57e09d08:	0a000050 	beq	57e09e50 <malloc+0x28c>
  {
    victim_size = chunksize(victim);
57e09d0c:	e5903004 	ldr	r3, [r0, #4]
57e09d10:	e3c33003 	bic	r3, r3, #3
    remainder_size = victim_size - nb;
57e09d14:	e064c003 	rsb	ip, r4, r3

    if (remainder_size >= (long)MINSIZE) /* re-split */
57e09d18:	e35c000f 	cmp	ip, #15
57e09d1c:	da00000a 	ble	57e09d4c <malloc+0x188>
    {
      remainder = chunk_at_offset(victim, nb);
57e09d20:	e0803004 	add	r3, r0, r4
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
57e09d24:	e582300c 	str	r3, [r2, #12]
57e09d28:	e5823008 	str	r3, [r2, #8]
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
57e09d2c:	e3844001 	orr	r4, r4, #1
      link_last_remainder(remainder);
57e09d30:	e583200c 	str	r2, [r3, #12]
57e09d34:	e5832008 	str	r2, [r3, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
57e09d38:	e38c2001 	orr	r2, ip, #1
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
57e09d3c:	e5804004 	str	r4, [r0, #4]
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
57e09d40:	e783c00c 	str	ip, [r3, ip]
    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
57e09d44:	e5832004 	str	r2, [r3, #4]
57e09d48:	ea000103 	b	57e0a15c <malloc+0x598>
      return chunk2mem(victim);
    }

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
57e09d4c:	e35c0000 	cmp	ip, #0
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    clear_last_remainder;
57e09d50:	e582200c 	str	r2, [r2, #12]
57e09d54:	e5822008 	str	r2, [r2, #8]

    if (remainder_size >= 0)  /* exhaust */
57e09d58:	ba000004 	blt	57e09d70 <malloc+0x1ac>
    {
      set_inuse_bit_at_offset(victim, victim_size);
57e09d5c:	e0803003 	add	r3, r0, r3
57e09d60:	e5932004 	ldr	r2, [r3, #4]
57e09d64:	e3822001 	orr	r2, r2, #1
57e09d68:	e5832004 	str	r2, [r3, #4]
57e09d6c:	ea0000fa 	b	57e0a15c <malloc+0x598>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
57e09d70:	e3530c02 	cmp	r3, #512	; 0x200
57e09d74:	2a000008 	bcs	57e09d9c <malloc+0x1d8>
57e09d78:	e1a031a3 	lsr	r3, r3, #3
57e09d7c:	e5956004 	ldr	r6, [r5, #4]
57e09d80:	e1a0c143 	asr	ip, r3, #2
57e09d84:	e3a07001 	mov	r7, #1
57e09d88:	e186cc17 	orr	ip, r6, r7, lsl ip
57e09d8c:	e0853183 	add	r3, r5, r3, lsl #3
57e09d90:	e585c004 	str	ip, [r5, #4]
57e09d94:	e593c008 	ldr	ip, [r3, #8]
57e09d98:	ea000028 	b	57e09e40 <malloc+0x27c>
57e09d9c:	e1a064a3 	lsr	r6, r3, #9
57e09da0:	e3560004 	cmp	r6, #4
57e09da4:	91a06323 	lsrls	r6, r3, #6
57e09da8:	92866038 	addls	r6, r6, #56	; 0x38
57e09dac:	9a00000f 	bls	57e09df0 <malloc+0x22c>
57e09db0:	e3560014 	cmp	r6, #20
57e09db4:	9286605b 	addls	r6, r6, #91	; 0x5b
57e09db8:	9a00000c 	bls	57e09df0 <malloc+0x22c>
57e09dbc:	e3560054 	cmp	r6, #84	; 0x54
57e09dc0:	91a06623 	lsrls	r6, r3, #12
57e09dc4:	9286606e 	addls	r6, r6, #110	; 0x6e
57e09dc8:	9a000008 	bls	57e09df0 <malloc+0x22c>
57e09dcc:	e3560f55 	cmp	r6, #340	; 0x154
57e09dd0:	91a067a3 	lsrls	r6, r3, #15
57e09dd4:	92866077 	addls	r6, r6, #119	; 0x77
57e09dd8:	9a000004 	bls	57e09df0 <malloc+0x22c>
57e09ddc:	e59fc390 	ldr	ip, [pc, #912]	; 57e0a174 <malloc+0x5b0>
57e09de0:	e156000c 	cmp	r6, ip
57e09de4:	91a06923 	lsrls	r6, r3, #18
57e09de8:	9286607c 	addls	r6, r6, #124	; 0x7c
57e09dec:	83a0607e 	movhi	r6, #126	; 0x7e
57e09df0:	e0857186 	add	r7, r5, r6, lsl #3
57e09df4:	e597c008 	ldr	ip, [r7, #8]
57e09df8:	e15c0007 	cmp	ip, r7
57e09dfc:	1a00000a 	bne	57e09e2c <malloc+0x268>
57e09e00:	e59f3368 	ldr	r3, [pc, #872]	; 57e0a170 <malloc+0x5ac>
57e09e04:	e1a06146 	asr	r6, r6, #2
57e09e08:	e5937004 	ldr	r7, [r3, #4]
57e09e0c:	e3a0a001 	mov	sl, #1
57e09e10:	e187661a 	orr	r6, r7, sl, lsl r6
57e09e14:	e5836004 	str	r6, [r3, #4]
57e09e18:	e1a0300c 	mov	r3, ip
57e09e1c:	ea000007 	b	57e09e40 <malloc+0x27c>
57e09e20:	e59cc008 	ldr	ip, [ip, #8]
57e09e24:	e15c0007 	cmp	ip, r7
57e09e28:	0a000003 	beq	57e09e3c <malloc+0x278>
57e09e2c:	e59c6004 	ldr	r6, [ip, #4]
57e09e30:	e3c66003 	bic	r6, r6, #3
57e09e34:	e1530006 	cmp	r3, r6
57e09e38:	3afffff8 	bcc	57e09e20 <malloc+0x25c>
57e09e3c:	e59c300c 	ldr	r3, [ip, #12]
57e09e40:	e580300c 	str	r3, [r0, #12]
57e09e44:	e580c008 	str	ip, [r0, #8]
57e09e48:	e5830008 	str	r0, [r3, #8]
57e09e4c:	e58c000c 	str	r0, [ip, #12]
  /*
     If there are any possibly nonempty big-enough blocks,
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks_r)
57e09e50:	e3a00001 	mov	r0, #1
57e09e54:	e1a03141 	asr	r3, r1, #2
57e09e58:	e1a03310 	lsl	r3, r0, r3
57e09e5c:	e59f030c 	ldr	r0, [pc, #780]	; 57e0a170 <malloc+0x5ac>
57e09e60:	e5900004 	ldr	r0, [r0, #4]
57e09e64:	e1530000 	cmp	r3, r0
57e09e68:	8a00004a 	bhi	57e09f98 <malloc+0x3d4>
  {

    /* Get to the first marked block */

    if ( (block & binblocks_r) == 0)
57e09e6c:	e1130000 	tst	r3, r0
57e09e70:	1a000004 	bne	57e09e88 <malloc+0x2c4>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
57e09e74:	e3c11003 	bic	r1, r1, #3
      block <<= 1;
      while ((block & binblocks_r) == 0)
      {
	idx += BINBLOCKWIDTH;
	block <<= 1;
57e09e78:	e1a03083 	lsl	r3, r3, #1
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
57e09e7c:	e1130000 	tst	r3, r0
      {
	idx += BINBLOCKWIDTH;
57e09e80:	e2811004 	add	r1, r1, #4
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
57e09e84:	0afffffb 	beq	57e09e78 <malloc+0x2b4>

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
57e09e88:	e59fa2e0 	ldr	sl, [pc, #736]	; 57e0a170 <malloc+0x5ac>

    /* For each possibly nonempty block ... */
    for (;;)
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
57e09e8c:	e0859181 	add	r9, r5, r1, lsl #3
57e09e90:	e1a07009 	mov	r7, r9
57e09e94:	e1a06001 	mov	r6, r1
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
57e09e98:	e597000c 	ldr	r0, [r7, #12]
57e09e9c:	ea000020 	b	57e09f24 <malloc+0x360>
	{
	  victim_size = chunksize(victim);
57e09ea0:	e590b004 	ldr	fp, [r0, #4]
57e09ea4:	e3cbb003 	bic	fp, fp, #3
	  remainder_size = victim_size - nb;
57e09ea8:	e064c00b 	rsb	ip, r4, fp

	  if (remainder_size >= (long)MINSIZE) /* split */
57e09eac:	e35c000f 	cmp	ip, #15
57e09eb0:	da00000f 	ble	57e09ef4 <malloc+0x330>
	  {
	    remainder = chunk_at_offset(victim, nb);
57e09eb4:	e0803004 	add	r3, r0, r4
	    set_head(victim, nb | PREV_INUSE);
57e09eb8:	e3844001 	orr	r4, r4, #1
	    unlink(victim, bck, fwd);
57e09ebc:	e590100c 	ldr	r1, [r0, #12]
	  remainder_size = victim_size - nb;

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
57e09ec0:	e5804004 	str	r4, [r0, #4]
	    unlink(victim, bck, fwd);
57e09ec4:	e5b04008 	ldr	r4, [r0, #8]!
	    link_last_remainder(remainder);
	    set_head(remainder, remainder_size | PREV_INUSE);
	    set_foot(remainder, remainder_size);
57e09ec8:	e783c00c 	str	ip, [r3, ip]

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
57e09ecc:	e584100c 	str	r1, [r4, #12]
57e09ed0:	e5814008 	str	r4, [r1, #8]
	    link_last_remainder(remainder);
57e09ed4:	e582300c 	str	r3, [r2, #12]
57e09ed8:	e5823008 	str	r3, [r2, #8]
57e09edc:	e59f2294 	ldr	r2, [pc, #660]	; 57e0a178 <malloc+0x5b4>
57e09ee0:	e583200c 	str	r2, [r3, #12]
57e09ee4:	e5832008 	str	r2, [r3, #8]
	    set_head(remainder, remainder_size | PREV_INUSE);
57e09ee8:	e38c2001 	orr	r2, ip, #1
57e09eec:	e5832004 	str	r2, [r3, #4]
	    set_foot(remainder, remainder_size);
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
57e09ef0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	  }

	  else if (remainder_size >= 0)  /* take */
57e09ef4:	e35c0000 	cmp	ip, #0
57e09ef8:	ba000008 	blt	57e09f20 <malloc+0x35c>
	  {
	    set_inuse_bit_at_offset(victim, victim_size);
57e09efc:	e080b00b 	add	fp, r0, fp
57e09f00:	e59b3004 	ldr	r3, [fp, #4]
57e09f04:	e3833001 	orr	r3, r3, #1
57e09f08:	e58b3004 	str	r3, [fp, #4]
	    unlink(victim, bck, fwd);
57e09f0c:	e590300c 	ldr	r3, [r0, #12]
57e09f10:	e5b02008 	ldr	r2, [r0, #8]!
57e09f14:	e582300c 	str	r3, [r2, #12]
57e09f18:	e5832008 	str	r2, [r3, #8]
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
57e09f1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
57e09f20:	e590000c 	ldr	r0, [r0, #12]
57e09f24:	e1500007 	cmp	r0, r7
57e09f28:	1affffdc 	bne	57e09ea0 <malloc+0x2dc>

	}

       bin = next_bin(bin);

      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
57e09f2c:	e2866001 	add	r6, r6, #1
57e09f30:	e3160003 	tst	r6, #3
	    return chunk2mem(victim);
	  }

	}

       bin = next_bin(bin);
57e09f34:	12877008 	addne	r7, r7, #8
57e09f38:	1affffd6 	bne	57e09e98 <malloc+0x2d4>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
57e09f3c:	e3110003 	tst	r1, #3
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
57e09f40:	059a1004 	ldreq	r1, [sl, #4]
57e09f44:	01c11003 	biceq	r1, r1, r3
57e09f48:	058a1004 	streq	r1, [sl, #4]
	  break;
57e09f4c:	0a000004 	beq	57e09f64 <malloc+0x3a0>
	}
	--startidx;
       q = prev_bin(q);
57e09f50:	e1a00009 	mov	r0, r9
      } while (first(q) == q);
57e09f54:	e4109008 	ldr	r9, [r0], #-8
57e09f58:	e1590000 	cmp	r9, r0
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
	  break;
	}
	--startidx;
57e09f5c:	02411001 	subeq	r1, r1, #1
57e09f60:	0afffff5 	beq	57e09f3c <malloc+0x378>
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
57e09f64:	e59a0004 	ldr	r0, [sl, #4]
57e09f68:	e1a03083 	lsl	r3, r3, #1
57e09f6c:	e1530000 	cmp	r3, r0
57e09f70:	8a000008 	bhi	57e09f98 <malloc+0x3d4>
57e09f74:	e3530000 	cmp	r3, #0
57e09f78:	0a000006 	beq	57e09f98 <malloc+0x3d4>
57e09f7c:	e1a01006 	mov	r1, r6
57e09f80:	ea000001 	b	57e09f8c <malloc+0x3c8>
      {
	while ((block & binblocks_r) == 0)
	{
	  idx += BINBLOCKWIDTH;
57e09f84:	e2811004 	add	r1, r1, #4
	  block <<= 1;
57e09f88:	e1a03083 	lsl	r3, r3, #1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
      {
	while ((block & binblocks_r) == 0)
57e09f8c:	e1130000 	tst	r3, r0
57e09f90:	1affffbd 	bne	57e09e8c <malloc+0x2c8>
57e09f94:	eafffffa 	b	57e09f84 <malloc+0x3c0>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
57e09f98:	e59f21d0 	ldr	r2, [pc, #464]	; 57e0a170 <malloc+0x5ac>
57e09f9c:	e5927008 	ldr	r7, [r2, #8]
57e09fa0:	e5979004 	ldr	r9, [r7, #4]
57e09fa4:	e3c99003 	bic	r9, r9, #3
57e09fa8:	e0643009 	rsb	r3, r4, r9
57e09fac:	e353000f 	cmp	r3, #15
57e09fb0:	ca000061 	bgt	57e0a13c <malloc+0x578>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
57e09fb4:	e59f31b0 	ldr	r3, [pc, #432]	; 57e0a16c <malloc+0x5a8>
57e09fb8:	e593a034 	ldr	sl, [r3, #52]	; 0x34

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
57e09fbc:	e5923408 	ldr	r3, [r2, #1032]	; 0x408
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
57e09fc0:	e28aa010 	add	sl, sl, #16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
57e09fc4:	e3730001 	cmn	r3, #1
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
57e09fc8:	e08aa004 	add	sl, sl, r4
  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
57e09fcc:	128aaeff 	addne	sl, sl, #4080	; 0xff0
57e09fd0:	128aa00f 	addne	sl, sl, #15
57e09fd4:	13caaeff 	bicne	sl, sl, #4080	; 0xff0
57e09fd8:	13caa00f 	bicne	sl, sl, #15

  brk = (char*)(MORECORE (sbrk_size));
57e09fdc:	e1a0000a 	mov	r0, sl
57e09fe0:	ebfffe1a 	bl	57e09850 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
57e09fe4:	e3700001 	cmn	r0, #1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
57e09fe8:	e1a06000 	mov	r6, r0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
57e09fec:	0a00004b 	beq	57e0a120 <malloc+0x55c>
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
57e09ff0:	e0872009 	add	r2, r7, r9
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
57e09ff4:	e1500002 	cmp	r0, r2
57e09ff8:	2a000001 	bcs	57e0a004 <malloc+0x440>
      (brk < old_end && old_top != initial_top))
57e09ffc:	e1570005 	cmp	r7, r5
57e0a000:	1a000046 	bne	57e0a120 <malloc+0x55c>
    return;

  sbrked_mem += sbrk_size;
57e0a004:	e59f3160 	ldr	r3, [pc, #352]	; 57e0a16c <malloc+0x5a8>

  if (brk == old_end) /* can just add bytes to current top */
57e0a008:	e1560002 	cmp	r6, r2
  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
57e0a00c:	e593000c 	ldr	r0, [r3, #12]
57e0a010:	e59f1158 	ldr	r1, [pc, #344]	; 57e0a170 <malloc+0x5ac>
57e0a014:	e08a0000 	add	r0, sl, r0
57e0a018:	e583000c 	str	r0, [r3, #12]

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
57e0a01c:	05913008 	ldreq	r3, [r1, #8]

  sbrked_mem += sbrk_size;

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
57e0a020:	008aa009 	addeq	sl, sl, r9
    set_head(top, top_size | PREV_INUSE);
57e0a024:	038aa001 	orreq	sl, sl, #1
57e0a028:	0583a004 	streq	sl, [r3, #4]
57e0a02c:	0a000032 	beq	57e0a0fc <malloc+0x538>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
57e0a030:	e591c408 	ldr	ip, [r1, #1032]	; 0x408
57e0a034:	e37c0001 	cmn	ip, #1
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
57e0a038:	10860000 	addne	r0, r6, r0
57e0a03c:	10622000 	rsbne	r2, r2, r0
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
57e0a040:	05816408 	streq	r6, [r1, #1032]	; 0x408
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
57e0a044:	1583200c 	strne	r2, [r3, #12]

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK;
    if (front_misalign > 0)
57e0a048:	e2163007 	ands	r3, r6, #7
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
57e0a04c:	12633008 	rsbne	r3, r3, #8
      brk += correction;
57e0a050:	10866003 	addne	r6, r6, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
57e0a054:	e086a00a 	add	sl, r6, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));
57e0a058:	e06a3003 	rsb	r3, sl, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
57e0a05c:	e28aaeff 	add	sl, sl, #4080	; 0xff0
57e0a060:	e28aa00f 	add	sl, sl, #15
57e0a064:	e3caaeff 	bic	sl, sl, #4080	; 0xff0
57e0a068:	e3caa00f 	bic	sl, sl, #15
57e0a06c:	e083a00a 	add	sl, r3, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
57e0a070:	e1a0000a 	mov	r0, sl
57e0a074:	ebfffdf5 	bl	57e09850 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE)) return;
57e0a078:	e3700001 	cmn	r0, #1
57e0a07c:	0a000027 	beq	57e0a120 <malloc+0x55c>

    sbrked_mem += correction;
57e0a080:	e59f30e4 	ldr	r3, [pc, #228]	; 57e0a16c <malloc+0x5a8>

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
57e0a084:	e0660000 	rsb	r0, r6, r0

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
57e0a088:	e593200c 	ldr	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
57e0a08c:	e1570005 	cmp	r7, r5

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
57e0a090:	e08a2002 	add	r2, sl, r2
57e0a094:	e583200c 	str	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
57e0a098:	e08aa000 	add	sl, sl, r0
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
57e0a09c:	e59f30cc 	ldr	r3, [pc, #204]	; 57e0a170 <malloc+0x5ac>
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
57e0a0a0:	e38aa001 	orr	sl, sl, #1
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
57e0a0a4:	e5836008 	str	r6, [r3, #8]
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
57e0a0a8:	e586a004 	str	sl, [r6, #4]

    if (old_top != initial_top)
57e0a0ac:	0a000012 	beq	57e0a0fc <malloc+0x538>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
57e0a0b0:	e359000f 	cmp	r9, #15
      {
	set_head(top, PREV_INUSE); /* will force null return from malloc */
57e0a0b4:	95933008 	ldrls	r3, [r3, #8]
57e0a0b8:	93a02001 	movls	r2, #1
57e0a0bc:	95832004 	strls	r2, [r3, #4]

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
57e0a0c0:	9a000016 	bls	57e0a120 <malloc+0x55c>
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
57e0a0c4:	e5973004 	ldr	r3, [r7, #4]
	set_head(top, PREV_INUSE); /* will force null return from malloc */
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
57e0a0c8:	e249900c 	sub	r9, r9, #12
57e0a0cc:	e3c99007 	bic	r9, r9, #7
      set_head_size(old_top, old_top_size);
57e0a0d0:	e2033001 	and	r3, r3, #1
57e0a0d4:	e1893003 	orr	r3, r9, r3
57e0a0d8:	e5873004 	str	r3, [r7, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
57e0a0dc:	e3a02005 	mov	r2, #5
57e0a0e0:	e0873009 	add	r3, r7, r9
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
57e0a0e4:	e359000f 	cmp	r9, #15
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
      chunk_at_offset(old_top, old_top_size          )->size =
57e0a0e8:	e5832004 	str	r2, [r3, #4]
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
57e0a0ec:	e5832008 	str	r2, [r3, #8]
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
57e0a0f0:	9a000001 	bls	57e0a0fc <malloc+0x538>
	fREe(chunk2mem(old_top));
57e0a0f4:	e2870008 	add	r0, r7, #8
57e0a0f8:	ebfffe27 	bl	57e0999c <free>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem)
57e0a0fc:	e59f2068 	ldr	r2, [pc, #104]	; 57e0a16c <malloc+0x5a8>
57e0a100:	e592300c 	ldr	r3, [r2, #12]
57e0a104:	e5921038 	ldr	r1, [r2, #56]	; 0x38
57e0a108:	e1530001 	cmp	r3, r1
    max_sbrked_mem = sbrked_mem;
57e0a10c:	85823038 	strhi	r3, [r2, #56]	; 0x38
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
57e0a110:	e59f2054 	ldr	r2, [pc, #84]	; 57e0a16c <malloc+0x5a8>
57e0a114:	e592103c 	ldr	r1, [r2, #60]	; 0x3c
57e0a118:	e1530001 	cmp	r3, r1
    max_total_mem = mmapped_mem + sbrked_mem;
57e0a11c:	8582303c 	strhi	r3, [r2, #60]	; 0x3c
      return chunk2mem(victim);
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
57e0a120:	e59f3048 	ldr	r3, [pc, #72]	; 57e0a170 <malloc+0x5ac>
57e0a124:	e5933008 	ldr	r3, [r3, #8]
57e0a128:	e5933004 	ldr	r3, [r3, #4]
57e0a12c:	e3c33003 	bic	r3, r3, #3
57e0a130:	e0643003 	rsb	r3, r4, r3
57e0a134:	e353000f 	cmp	r3, #15
57e0a138:	da000009 	ble	57e0a164 <malloc+0x5a0>
      return NULL; /* propagate failure */
  }

  victim = top;
57e0a13c:	e59f202c 	ldr	r2, [pc, #44]	; 57e0a170 <malloc+0x5ac>
  set_head(victim, nb | PREV_INUSE);
57e0a140:	e3841001 	orr	r1, r4, #1
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return NULL; /* propagate failure */
  }

  victim = top;
57e0a144:	e5920008 	ldr	r0, [r2, #8]
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
57e0a148:	e3833001 	orr	r3, r3, #1
      return NULL; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
57e0a14c:	e0804004 	add	r4, r0, r4
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return NULL; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
57e0a150:	e5801004 	str	r1, [r0, #4]
  top = chunk_at_offset(victim, nb);
57e0a154:	e5824008 	str	r4, [r2, #8]
  set_head(top, remainder_size | PREV_INUSE);
57e0a158:	e5843004 	str	r3, [r4, #4]
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);
57e0a15c:	e2800008 	add	r0, r0, #8
57e0a160:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return NULL; /* propagate failure */
57e0a164:	e3a00000 	mov	r0, #0
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);

}
57e0a168:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0a16c:	57e383f0 	.word	0x57e383f0
57e0a170:	57e369b0 	.word	0x57e369b0
57e0a174:	00000554 	.word	0x00000554
57e0a178:	57e369b8 	.word	0x57e369b8

57e0a17c <calloc>:
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
57e0a17c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
57e0a180:	e59f30d0 	ldr	r3, [pc, #208]	; 57e0a258 <calloc+0xdc>
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
57e0a184:	e1a06000 	mov	r6, r0
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
57e0a188:	e5935008 	ldr	r5, [r3, #8]
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
57e0a18c:	e0000196 	mul	r0, r6, r1


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
57e0a190:	e5957004 	ldr	r7, [r5, #4]
#endif
  Void_t* mem = mALLOc (sz);
57e0a194:	ebfffe8a 	bl	57e09bc4 <malloc>

  if ((long)n < 0) return NULL;
57e0a198:	e3560000 	cmp	r6, #0
  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
57e0a19c:	e1a04000 	mov	r4, r0

  if ((long)n < 0) return NULL;
57e0a1a0:	b3a04000 	movlt	r4, #0
57e0a1a4:	ba000029 	blt	57e0a250 <calloc+0xd4>

  if (mem == NULL)
57e0a1a8:	e3540000 	cmp	r4, #0
57e0a1ac:	0a000027 	beq	57e0a250 <calloc+0xd4>

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
57e0a1b0:	e5142004 	ldr	r2, [r4, #-4]


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
57e0a1b4:	e3c77003 	bic	r7, r7, #3

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
57e0a1b8:	e3c22003 	bic	r2, r2, #3

  if (mem == NULL)
    return NULL;
  else
  {
    p = mem2chunk(mem);
57e0a1bc:	e2443008 	sub	r3, r4, #8
#endif

    csz = chunksize(p);

#if MORECORE_CLEARS
    if (p == oldtop && csz > oldtopsize)
57e0a1c0:	e1530005 	cmp	r3, r5
57e0a1c4:	13a05000 	movne	r5, #0
57e0a1c8:	03a05001 	moveq	r5, #1
57e0a1cc:	e1520007 	cmp	r2, r7
57e0a1d0:	93a05000 	movls	r5, #0
57e0a1d4:	e3550000 	cmp	r5, #0
57e0a1d8:	11a02007 	movne	r2, r7
      /* clear only the bytes from non-freshly-sbrked memory */
      csz = oldtopsize;
    }
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
57e0a1dc:	e2422004 	sub	r2, r2, #4
57e0a1e0:	e3520024 	cmp	r2, #36	; 0x24
57e0a1e4:	8a000017 	bhi	57e0a248 <calloc+0xcc>
57e0a1e8:	e3520013 	cmp	r2, #19
57e0a1ec:	e1a03004 	mov	r3, r4
57e0a1f0:	9a00000e 	bls	57e0a230 <calloc+0xb4>
57e0a1f4:	e3a01000 	mov	r1, #0
57e0a1f8:	e1a00004 	mov	r0, r4
57e0a1fc:	e4801004 	str	r1, [r0], #4
57e0a200:	e352001b 	cmp	r2, #27
57e0a204:	e5841004 	str	r1, [r4, #4]
57e0a208:	e2803004 	add	r3, r0, #4
57e0a20c:	9a000007 	bls	57e0a230 <calloc+0xb4>
57e0a210:	e5801004 	str	r1, [r0, #4]
57e0a214:	e2830004 	add	r0, r3, #4
57e0a218:	e5831004 	str	r1, [r3, #4]
57e0a21c:	e3520024 	cmp	r2, #36	; 0x24
57e0a220:	e2803004 	add	r3, r0, #4
57e0a224:	05801004 	streq	r1, [r0, #4]
57e0a228:	05831004 	streq	r1, [r3, #4]
57e0a22c:	02833008 	addeq	r3, r3, #8
57e0a230:	e3a01000 	mov	r1, #0
57e0a234:	e1a02003 	mov	r2, r3
57e0a238:	e4821004 	str	r1, [r2], #4
57e0a23c:	e5831004 	str	r1, [r3, #4]
57e0a240:	e5821004 	str	r1, [r2, #4]
57e0a244:	ea000001 	b	57e0a250 <calloc+0xd4>
57e0a248:	e3a01000 	mov	r1, #0
57e0a24c:	eb00680a 	bl	57e2427c <memset>
    return mem;
  }
}
57e0a250:	e1a00004 	mov	r0, r4
57e0a254:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e0a258:	57e369b0 	.word	0x57e369b0

57e0a25c <memalign>:
#if __STD_C
Void_t* mEMALIGn(size_t alignment, size_t bytes)
#else
Void_t* mEMALIGn(alignment, bytes) size_t alignment; size_t bytes;
#endif
{
57e0a25c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e0a260:	e1a04000 	mov	r4, r0
  INTERNAL_SIZE_T  newsize;   /* its size */
  INTERNAL_SIZE_T  leadsize;  /* leading space befor alignment point */
  mchunkptr remainder;        /* spare room at end to split off */
  long      remainder_size;   /* its size */

  if ((long)bytes < 0) return NULL;
57e0a264:	e2510000 	subs	r0, r1, #0
57e0a268:	b3a00000 	movlt	r0, #0
57e0a26c:	b8bd84f0 	poplt	{r4, r5, r6, r7, sl, pc}

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
57e0a270:	e3540008 	cmp	r4, #8
57e0a274:	8a000001 	bhi	57e0a280 <memalign+0x24>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
57e0a278:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}

  if ((long)bytes < 0) return NULL;

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
57e0a27c:	eafffe50 	b	57e09bc4 <malloc>

  if (alignment <  MINSIZE) alignment = MINSIZE;

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
57e0a280:	e280700b 	add	r7, r0, #11

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);

  /* Otherwise, ensure that it is at least a minimum chunk size */

  if (alignment <  MINSIZE) alignment = MINSIZE;
57e0a284:	e354000f 	cmp	r4, #15
57e0a288:	93a04010 	movls	r4, #16

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
57e0a28c:	e3570016 	cmp	r7, #22
57e0a290:	c3c77007 	bicgt	r7, r7, #7
57e0a294:	d3a07010 	movle	r7, #16
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));
57e0a298:	e2840010 	add	r0, r4, #16
57e0a29c:	e0800007 	add	r0, r0, r7
57e0a2a0:	ebfffe47 	bl	57e09bc4 <malloc>

  if (m == NULL) return NULL; /* propagate failure */
57e0a2a4:	e2506000 	subs	r6, r0, #0
57e0a2a8:	0a00002d 	beq	57e0a364 <memalign+0x108>

  p = mem2chunk(m);

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
57e0a2ac:	e1a01004 	mov	r1, r4
57e0a2b0:	eb0085b9 	bl	57e2b99c <__aeabi_uidivmod>
57e0a2b4:	e3510000 	cmp	r1, #0
  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == NULL) return NULL; /* propagate failure */

  p = mem2chunk(m);
57e0a2b8:	e2465008 	sub	r5, r6, #8

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
57e0a2bc:	0a000018 	beq	57e0a324 <memalign+0xc8>
      a spot with less than MINSIZE leader, we can move to the
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
57e0a2c0:	e244a001 	sub	sl, r4, #1
57e0a2c4:	e2643000 	rsb	r3, r4, #0
57e0a2c8:	e086a00a 	add	sl, r6, sl
57e0a2cc:	e00aa003 	and	sl, sl, r3
57e0a2d0:	e24aa008 	sub	sl, sl, #8
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
57e0a2d4:	e065300a 	rsb	r3, r5, sl
57e0a2d8:	e353000f 	cmp	r3, #15

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
    newsize = chunksize(p) - leadsize;
57e0a2dc:	e5163004 	ldr	r3, [r6, #-4]
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
57e0a2e0:	908aa004 	addls	sl, sl, r4

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
57e0a2e4:	e065500a 	rsb	r5, r5, sl
    newsize = chunksize(p) - leadsize;
57e0a2e8:	e3c33003 	bic	r3, r3, #3
57e0a2ec:	e0653003 	rsb	r3, r5, r3
    }
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
57e0a2f0:	e3832001 	orr	r2, r3, #1
57e0a2f4:	e58a2004 	str	r2, [sl, #4]
    set_inuse_bit_at_offset(newp, newsize);
57e0a2f8:	e08a3003 	add	r3, sl, r3
57e0a2fc:	e5932004 	ldr	r2, [r3, #4]
    set_head_size(p, leadsize);
    fREe(chunk2mem(p));
57e0a300:	e1a00006 	mov	r0, r6
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
    set_inuse_bit_at_offset(newp, newsize);
57e0a304:	e3822001 	orr	r2, r2, #1
57e0a308:	e5832004 	str	r2, [r3, #4]
    set_head_size(p, leadsize);
57e0a30c:	e5163004 	ldr	r3, [r6, #-4]
57e0a310:	e2033001 	and	r3, r3, #1
57e0a314:	e1855003 	orr	r5, r5, r3
57e0a318:	e5065004 	str	r5, [r6, #-4]
    fREe(chunk2mem(p));
57e0a31c:	ebfffd9e 	bl	57e0999c <free>
57e0a320:	e1a0500a 	mov	r5, sl
    assert (newsize >= nb && (((unsigned long)(chunk2mem(p))) % alignment) == 0);
  }

  /* Also give back spare room at the end */

  remainder_size = chunksize(p) - nb;
57e0a324:	e5953004 	ldr	r3, [r5, #4]
57e0a328:	e3c33003 	bic	r3, r3, #3
57e0a32c:	e0673003 	rsb	r3, r7, r3

  if (remainder_size >= (long)MINSIZE)
57e0a330:	e353000f 	cmp	r3, #15
57e0a334:	da000008 	ble	57e0a35c <memalign+0x100>
  {
    remainder = chunk_at_offset(p, nb);
57e0a338:	e0850007 	add	r0, r5, r7
    set_head(remainder, remainder_size | PREV_INUSE);
57e0a33c:	e3833001 	orr	r3, r3, #1
57e0a340:	e5803004 	str	r3, [r0, #4]
    set_head_size(p, nb);
57e0a344:	e5953004 	ldr	r3, [r5, #4]
    fREe(chunk2mem(remainder));
57e0a348:	e2800008 	add	r0, r0, #8

  if (remainder_size >= (long)MINSIZE)
  {
    remainder = chunk_at_offset(p, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_head_size(p, nb);
57e0a34c:	e2033001 	and	r3, r3, #1
57e0a350:	e1877003 	orr	r7, r7, r3
57e0a354:	e5857004 	str	r7, [r5, #4]
    fREe(chunk2mem(remainder));
57e0a358:	ebfffd8f 	bl	57e0999c <free>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);
57e0a35c:	e2850008 	add	r0, r5, #8
57e0a360:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == NULL) return NULL; /* propagate failure */
57e0a364:	e1a00006 	mov	r0, r6
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
57e0a368:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

57e0a36c <pvalloc>:
#else
Void_t* pvALLOc(bytes) size_t bytes;
#endif
{
  size_t pagesize = malloc_getpagesize;
  return mEMALIGn (pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
57e0a36c:	e2801eff 	add	r1, r0, #4080	; 0xff0
57e0a370:	e281100f 	add	r1, r1, #15
57e0a374:	e3c11eff 	bic	r1, r1, #4080	; 0xff0
57e0a378:	e3a00a01 	mov	r0, #4096	; 0x1000
57e0a37c:	e3c1100f 	bic	r1, r1, #15
57e0a380:	eaffffb5 	b	57e0a25c <memalign>

57e0a384 <valloc>:
#if __STD_C
Void_t* vALLOc(size_t bytes)
#else
Void_t* vALLOc(bytes) size_t bytes;
#endif
{
57e0a384:	e1a01000 	mov	r1, r0
  return mEMALIGn (malloc_getpagesize, bytes);
57e0a388:	e3a00a01 	mov	r0, #4096	; 0x1000
57e0a38c:	eaffffb2 	b	57e0a25c <memalign>

57e0a390 <realloc>:
#if __STD_C
Void_t* rEALLOc(Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
#endif
{
57e0a390:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e0a394:	e1a05000 	mov	r5, r0

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return NULL;
57e0a398:	e2510000 	subs	r0, r1, #0
57e0a39c:	ba00010b 	blt	57e0a7d0 <realloc+0x440>

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == NULL) return mALLOc(bytes);
57e0a3a0:	e3550000 	cmp	r5, #0
57e0a3a4:	1a000001 	bne	57e0a3b0 <realloc+0x20>
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
57e0a3a8:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
#endif

  if ((long)bytes < 0) return NULL;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == NULL) return mALLOc(bytes);
57e0a3ac:	eafffe04 	b	57e09bc4 <malloc>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
57e0a3b0:	e280600b 	add	r6, r0, #11

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == NULL) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
57e0a3b4:	e5151004 	ldr	r1, [r5, #-4]


  nb = request2size(bytes);
57e0a3b8:	e3560016 	cmp	r6, #22

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == NULL) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
57e0a3bc:	e3c19003 	bic	r9, r1, #3


  nb = request2size(bytes);
57e0a3c0:	c3c66007 	bicgt	r6, r6, #7
57e0a3c4:	d3a06010 	movle	r6, #16
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
57e0a3c8:	e1590006 	cmp	r9, r6
  if ((long)bytes < 0) return NULL;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == NULL) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
57e0a3cc:	e245b008 	sub	fp, r5, #8
  newsize = oldsize = chunksize(oldp);
57e0a3d0:	a1a0a009 	movge	sl, r9
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
57e0a3d4:	aa0000e2 	bge	57e0a764 <realloc+0x3d4>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
57e0a3d8:	e59f23fc 	ldr	r2, [pc, #1020]	; 57e0a7dc <realloc+0x44c>
  if ((long)(oldsize) < (long)(nb))
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
57e0a3dc:	e08b3009 	add	r3, fp, r9
    if (next == top || !inuse(next))
57e0a3e0:	e592c008 	ldr	ip, [r2, #8]
57e0a3e4:	e153000c 	cmp	r3, ip
57e0a3e8:	0a000007 	beq	57e0a40c <realloc+0x7c>
57e0a3ec:	e5932004 	ldr	r2, [r3, #4]
57e0a3f0:	e3c22001 	bic	r2, r2, #1
57e0a3f4:	e0832002 	add	r2, r3, r2
57e0a3f8:	e5922004 	ldr	r2, [r2, #4]
57e0a3fc:	e3120001 	tst	r2, #1
      }
    }
    else
    {
      next = NULL;
      nextsize = 0;
57e0a400:	13a02000 	movne	r2, #0
	goto split;
      }
    }
    else
    {
      next = NULL;
57e0a404:	11a03002 	movne	r3, r2
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
57e0a408:	1a000019 	bne	57e0a474 <realloc+0xe4>
    {
      nextsize = chunksize(next);
57e0a40c:	e5932004 	ldr	r2, [r3, #4]

      /* Forward into top only if a remainder */
      if (next == top)
57e0a410:	e153000c 	cmp	r3, ip
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
    {
      nextsize = chunksize(next);
57e0a414:	e3c22003 	bic	r2, r2, #3
57e0a418:	e082a009 	add	sl, r2, r9

      /* Forward into top only if a remainder */
      if (next == top)
57e0a41c:	1a00000e 	bne	57e0a45c <realloc+0xcc>
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
57e0a420:	e2864010 	add	r4, r6, #16
57e0a424:	e15a0004 	cmp	sl, r4
57e0a428:	ba000011 	blt	57e0a474 <realloc+0xe4>
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
57e0a42c:	e59f33a8 	ldr	r3, [pc, #936]	; 57e0a7dc <realloc+0x44c>
	  set_head(top, (newsize - nb) | PREV_INUSE);
57e0a430:	e066a00a 	rsb	sl, r6, sl
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
57e0a434:	e08bb006 	add	fp, fp, r6
	  set_head(top, (newsize - nb) | PREV_INUSE);
57e0a438:	e38aa001 	orr	sl, sl, #1
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
57e0a43c:	e583b008 	str	fp, [r3, #8]
	  set_head(top, (newsize - nb) | PREV_INUSE);
57e0a440:	e58ba004 	str	sl, [fp, #4]
	  set_head_size(oldp, nb);
57e0a444:	e5153004 	ldr	r3, [r5, #-4]
	  return chunk2mem(oldp);
57e0a448:	e1a07005 	mov	r7, r5
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
	  set_head(top, (newsize - nb) | PREV_INUSE);
	  set_head_size(oldp, nb);
57e0a44c:	e2033001 	and	r3, r3, #1
57e0a450:	e1866003 	orr	r6, r6, r3
57e0a454:	e5056004 	str	r6, [r5, #-4]
	  return chunk2mem(oldp);
57e0a458:	ea0000dd 	b	57e0a7d4 <realloc+0x444>
	}
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
57e0a45c:	e15a0006 	cmp	sl, r6
      {
	unlink(next, bck, fwd);
57e0a460:	a593200c 	ldrge	r2, [r3, #12]
57e0a464:	a5933008 	ldrge	r3, [r3, #8]
57e0a468:	a583200c 	strge	r2, [r3, #12]
57e0a46c:	a5823008 	strge	r3, [r2, #8]
57e0a470:	aa0000bb 	bge	57e0a764 <realloc+0x3d4>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
57e0a474:	e3110001 	tst	r1, #1
57e0a478:	1a00007e 	bne	57e0a678 <realloc+0x2e8>
    {
      prev = prev_chunk(oldp);
57e0a47c:	e5154008 	ldr	r4, [r5, #-8]
      prevsize = chunksize(prev);

      /* try forward + backward first to save a later consolidation */

      if (next != NULL)
57e0a480:	e3530000 	cmp	r3, #0

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
57e0a484:	e064400b 	rsb	r4, r4, fp
      prevsize = chunksize(prev);
57e0a488:	e5941004 	ldr	r1, [r4, #4]
57e0a48c:	e3c11003 	bic	r1, r1, #3

      /* try forward + backward first to save a later consolidation */

      if (next != NULL)
57e0a490:	0a000047 	beq	57e0a5b4 <realloc+0x224>
      {
	/* into top */
	if (next == top)
57e0a494:	e153000c 	cmp	r3, ip
57e0a498:	e081a009 	add	sl, r1, r9
57e0a49c:	1a00003d 	bne	57e0a598 <realloc+0x208>
	{
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
57e0a4a0:	e08aa002 	add	sl, sl, r2
57e0a4a4:	e2863010 	add	r3, r6, #16
57e0a4a8:	e15a0003 	cmp	sl, r3
57e0a4ac:	ba000040 	blt	57e0a5b4 <realloc+0x224>
	  {
	    unlink(prev, bck, fwd);
57e0a4b0:	e1a07004 	mov	r7, r4
57e0a4b4:	e5b72008 	ldr	r2, [r7, #8]!
57e0a4b8:	e594300c 	ldr	r3, [r4, #12]
57e0a4bc:	e582300c 	str	r3, [r2, #12]
57e0a4c0:	e5832008 	str	r2, [r3, #8]
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
57e0a4c4:	e2492004 	sub	r2, r9, #4
57e0a4c8:	e3520024 	cmp	r2, #36	; 0x24
57e0a4cc:	8a000023 	bhi	57e0a560 <realloc+0x1d0>
57e0a4d0:	e3520013 	cmp	r2, #19
57e0a4d4:	e1a03007 	mov	r3, r7
57e0a4d8:	9a000017 	bls	57e0a53c <realloc+0x1ac>
57e0a4dc:	e1a01005 	mov	r1, r5
57e0a4e0:	e4913004 	ldr	r3, [r1], #4
57e0a4e4:	e352001b 	cmp	r2, #27
57e0a4e8:	e5843008 	str	r3, [r4, #8]
57e0a4ec:	e5953004 	ldr	r3, [r5, #4]
57e0a4f0:	e2815004 	add	r5, r1, #4
57e0a4f4:	e584300c 	str	r3, [r4, #12]
57e0a4f8:	e2843010 	add	r3, r4, #16
57e0a4fc:	9a00000e 	bls	57e0a53c <realloc+0x1ac>
57e0a500:	e5913004 	ldr	r3, [r1, #4]
57e0a504:	e3520024 	cmp	r2, #36	; 0x24
57e0a508:	e5843010 	str	r3, [r4, #16]
57e0a50c:	e5953004 	ldr	r3, [r5, #4]
57e0a510:	e2851004 	add	r1, r5, #4
57e0a514:	e5843014 	str	r3, [r4, #20]
57e0a518:	e2815004 	add	r5, r1, #4
57e0a51c:	e2843018 	add	r3, r4, #24
57e0a520:	1a000005 	bne	57e0a53c <realloc+0x1ac>
57e0a524:	e5913004 	ldr	r3, [r1, #4]
57e0a528:	e5843018 	str	r3, [r4, #24]
57e0a52c:	e5953004 	ldr	r3, [r5, #4]
57e0a530:	e2855008 	add	r5, r5, #8
57e0a534:	e584301c 	str	r3, [r4, #28]
57e0a538:	e2843020 	add	r3, r4, #32
57e0a53c:	e1a01005 	mov	r1, r5
57e0a540:	e4910004 	ldr	r0, [r1], #4
57e0a544:	e1a02003 	mov	r2, r3
57e0a548:	e4820004 	str	r0, [r2], #4
57e0a54c:	e5950004 	ldr	r0, [r5, #4]
57e0a550:	e5830004 	str	r0, [r3, #4]
57e0a554:	e5913004 	ldr	r3, [r1, #4]
57e0a558:	e5823004 	str	r3, [r2, #4]
57e0a55c:	ea000002 	b	57e0a56c <realloc+0x1dc>
57e0a560:	e1a00007 	mov	r0, r7
57e0a564:	e1a01005 	mov	r1, r5
57e0a568:	eb006767 	bl	57e2430c <memcpy>
	    top = chunk_at_offset(newp, nb);
	    set_head(top, (newsize - nb) | PREV_INUSE);
57e0a56c:	e066a00a 	rsb	sl, r6, sl
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
57e0a570:	e59f2264 	ldr	r2, [pc, #612]	; 57e0a7dc <realloc+0x44c>
57e0a574:	e0843006 	add	r3, r4, r6
	    set_head(top, (newsize - nb) | PREV_INUSE);
57e0a578:	e38aa001 	orr	sl, sl, #1
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
57e0a57c:	e5823008 	str	r3, [r2, #8]
	    set_head(top, (newsize - nb) | PREV_INUSE);
57e0a580:	e583a004 	str	sl, [r3, #4]
	    set_head_size(newp, nb);
57e0a584:	e5943004 	ldr	r3, [r4, #4]
57e0a588:	e2033001 	and	r3, r3, #1
57e0a58c:	e1866003 	orr	r6, r6, r3
57e0a590:	e5846004 	str	r6, [r4, #4]
	    return newmem;
57e0a594:	ea00008e 	b	57e0a7d4 <realloc+0x444>
	  }
	}

	/* into next chunk */
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
57e0a598:	e08aa002 	add	sl, sl, r2
57e0a59c:	e15a0006 	cmp	sl, r6
	{
	  unlink(next, bck, fwd);
57e0a5a0:	a593200c 	ldrge	r2, [r3, #12]
57e0a5a4:	a5933008 	ldrge	r3, [r3, #8]
57e0a5a8:	a583200c 	strge	r2, [r3, #12]
57e0a5ac:	a5823008 	strge	r3, [r2, #8]
57e0a5b0:	aa000002 	bge	57e0a5c0 <realloc+0x230>
	  goto split;
	}
      }

      /* backward only */
      if (prev != NULL && (long)(prevsize + newsize) >= (long)nb)
57e0a5b4:	e081a009 	add	sl, r1, r9
57e0a5b8:	e15a0006 	cmp	sl, r6
57e0a5bc:	ba00002d 	blt	57e0a678 <realloc+0x2e8>
      {
	unlink(prev, bck, fwd);
57e0a5c0:	e1a00004 	mov	r0, r4
57e0a5c4:	e5b02008 	ldr	r2, [r0, #8]!
57e0a5c8:	e594300c 	ldr	r3, [r4, #12]
57e0a5cc:	e582300c 	str	r3, [r2, #12]
57e0a5d0:	e5832008 	str	r2, [r3, #8]
	newp = prev;
	newsize += prevsize;
	newmem = chunk2mem(newp);
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
57e0a5d4:	e2492004 	sub	r2, r9, #4
57e0a5d8:	e3520024 	cmp	r2, #36	; 0x24
57e0a5dc:	8a000022 	bhi	57e0a66c <realloc+0x2dc>
57e0a5e0:	e3520013 	cmp	r2, #19
57e0a5e4:	9a000017 	bls	57e0a648 <realloc+0x2b8>
57e0a5e8:	e1a03005 	mov	r3, r5
57e0a5ec:	e4931004 	ldr	r1, [r3], #4
57e0a5f0:	e352001b 	cmp	r2, #27
57e0a5f4:	e5841008 	str	r1, [r4, #8]
57e0a5f8:	e5951004 	ldr	r1, [r5, #4]
57e0a5fc:	e2840010 	add	r0, r4, #16
57e0a600:	e584100c 	str	r1, [r4, #12]
57e0a604:	e2835004 	add	r5, r3, #4
57e0a608:	9a00000e 	bls	57e0a648 <realloc+0x2b8>
57e0a60c:	e5933004 	ldr	r3, [r3, #4]
57e0a610:	e3520024 	cmp	r2, #36	; 0x24
57e0a614:	e5843010 	str	r3, [r4, #16]
57e0a618:	e5951004 	ldr	r1, [r5, #4]
57e0a61c:	e2853004 	add	r3, r5, #4
57e0a620:	e5841014 	str	r1, [r4, #20]
57e0a624:	e2840018 	add	r0, r4, #24
57e0a628:	e2835004 	add	r5, r3, #4
57e0a62c:	1a000005 	bne	57e0a648 <realloc+0x2b8>
57e0a630:	e5933004 	ldr	r3, [r3, #4]
57e0a634:	e2840020 	add	r0, r4, #32
57e0a638:	e5843018 	str	r3, [r4, #24]
57e0a63c:	e5953004 	ldr	r3, [r5, #4]
57e0a640:	e2855008 	add	r5, r5, #8
57e0a644:	e584301c 	str	r3, [r4, #28]
57e0a648:	e1a02005 	mov	r2, r5
57e0a64c:	e4921004 	ldr	r1, [r2], #4
57e0a650:	e1a03000 	mov	r3, r0
57e0a654:	e4831004 	str	r1, [r3], #4
57e0a658:	e5951004 	ldr	r1, [r5, #4]
57e0a65c:	e5801004 	str	r1, [r0, #4]
57e0a660:	e5922004 	ldr	r2, [r2, #4]
57e0a664:	e5832004 	str	r2, [r3, #4]
57e0a668:	ea00003e 	b	57e0a768 <realloc+0x3d8>
57e0a66c:	e1a01005 	mov	r1, r5
57e0a670:	eb006725 	bl	57e2430c <memcpy>
57e0a674:	ea00003b 	b	57e0a768 <realloc+0x3d8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (bytes);
57e0a678:	ebfffd51 	bl	57e09bc4 <malloc>

    if (newmem == NULL)  /* propagate failure */
57e0a67c:	e2507000 	subs	r7, r0, #0
57e0a680:	0a000053 	beq	57e0a7d4 <realloc+0x444>
      return NULL;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
57e0a684:	e5153004 	ldr	r3, [r5, #-4]
57e0a688:	e2472008 	sub	r2, r7, #8
57e0a68c:	e3c33001 	bic	r3, r3, #1
57e0a690:	e08b3003 	add	r3, fp, r3
57e0a694:	e1520003 	cmp	r2, r3
    {
      newsize += chunksize(newp);
57e0a698:	0517a004 	ldreq	sl, [r7, #-4]
57e0a69c:	03caa003 	biceq	sl, sl, #3
57e0a6a0:	008aa009 	addeq	sl, sl, r9
      return NULL;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
57e0a6a4:	0a00002e 	beq	57e0a764 <realloc+0x3d4>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
57e0a6a8:	e2492004 	sub	r2, r9, #4
57e0a6ac:	e3520024 	cmp	r2, #36	; 0x24
57e0a6b0:	8a000026 	bhi	57e0a750 <realloc+0x3c0>
57e0a6b4:	e3520013 	cmp	r2, #19
57e0a6b8:	e1a01005 	mov	r1, r5
57e0a6bc:	e1a03007 	mov	r3, r7
57e0a6c0:	9a000019 	bls	57e0a72c <realloc+0x39c>
57e0a6c4:	e1a0c005 	mov	ip, r5
57e0a6c8:	e49c3004 	ldr	r3, [ip], #4
57e0a6cc:	e1a00007 	mov	r0, r7
57e0a6d0:	e4803004 	str	r3, [r0], #4
57e0a6d4:	e5953004 	ldr	r3, [r5, #4]
57e0a6d8:	e352001b 	cmp	r2, #27
57e0a6dc:	e5873004 	str	r3, [r7, #4]
57e0a6e0:	e28c1004 	add	r1, ip, #4
57e0a6e4:	e2803004 	add	r3, r0, #4
57e0a6e8:	9a00000f 	bls	57e0a72c <realloc+0x39c>
57e0a6ec:	e59cc004 	ldr	ip, [ip, #4]
57e0a6f0:	e3520024 	cmp	r2, #36	; 0x24
57e0a6f4:	e580c004 	str	ip, [r0, #4]
57e0a6f8:	e281c004 	add	ip, r1, #4
57e0a6fc:	e5911004 	ldr	r1, [r1, #4]
57e0a700:	e2830004 	add	r0, r3, #4
57e0a704:	e5831004 	str	r1, [r3, #4]
57e0a708:	e2803004 	add	r3, r0, #4
57e0a70c:	e28c1004 	add	r1, ip, #4
57e0a710:	1a000005 	bne	57e0a72c <realloc+0x39c>
57e0a714:	e59c2004 	ldr	r2, [ip, #4]
57e0a718:	e5802004 	str	r2, [r0, #4]
57e0a71c:	e5912004 	ldr	r2, [r1, #4]
57e0a720:	e2811008 	add	r1, r1, #8
57e0a724:	e5832004 	str	r2, [r3, #4]
57e0a728:	e2833008 	add	r3, r3, #8
57e0a72c:	e1a00001 	mov	r0, r1
57e0a730:	e490c004 	ldr	ip, [r0], #4
57e0a734:	e1a02003 	mov	r2, r3
57e0a738:	e482c004 	str	ip, [r2], #4
57e0a73c:	e5911004 	ldr	r1, [r1, #4]
57e0a740:	e5831004 	str	r1, [r3, #4]
57e0a744:	e5903004 	ldr	r3, [r0, #4]
57e0a748:	e5823004 	str	r3, [r2, #4]
57e0a74c:	ea000001 	b	57e0a758 <realloc+0x3c8>
57e0a750:	e1a01005 	mov	r1, r5
57e0a754:	eb0066ec 	bl	57e2430c <memcpy>
    fREe(oldmem);
57e0a758:	e1a00005 	mov	r0, r5
57e0a75c:	ebfffc8e 	bl	57e0999c <free>
    return newmem;
57e0a760:	ea00001b 	b	57e0a7d4 <realloc+0x444>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
57e0a764:	e1a0400b 	mov	r4, fp
  }


 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
57e0a768:	e066300a 	rsb	r3, r6, sl
57e0a76c:	e353000f 	cmp	r3, #15
57e0a770:	e5942004 	ldr	r2, [r4, #4]
57e0a774:	9a00000c 	bls	57e0a7ac <realloc+0x41c>
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
57e0a778:	e2022001 	and	r2, r2, #1

 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
57e0a77c:	e0840006 	add	r0, r4, r6
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
57e0a780:	e1866002 	orr	r6, r6, r2
    set_head(remainder, remainder_size | PREV_INUSE);
57e0a784:	e3832001 	orr	r2, r3, #1

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
57e0a788:	e5846004 	str	r6, [r4, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
57e0a78c:	e0803003 	add	r3, r0, r3
  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
57e0a790:	e5802004 	str	r2, [r0, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
57e0a794:	e5932004 	ldr	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
57e0a798:	e2800008 	add	r0, r0, #8
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
57e0a79c:	e3822001 	orr	r2, r2, #1
57e0a7a0:	e5832004 	str	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
57e0a7a4:	ebfffc7c 	bl	57e0999c <free>
57e0a7a8:	ea000006 	b	57e0a7c8 <realloc+0x438>
  }
  else
  {
    set_head_size(newp, newsize);
57e0a7ac:	e2022001 	and	r2, r2, #1
57e0a7b0:	e18a2002 	orr	r2, sl, r2
57e0a7b4:	e5842004 	str	r2, [r4, #4]
    set_inuse_bit_at_offset(newp, newsize);
57e0a7b8:	e084a00a 	add	sl, r4, sl
57e0a7bc:	e59a3004 	ldr	r3, [sl, #4]
57e0a7c0:	e3833001 	orr	r3, r3, #1
57e0a7c4:	e58a3004 	str	r3, [sl, #4]
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
57e0a7c8:	e2847008 	add	r7, r4, #8
57e0a7cc:	ea000000 	b	57e0a7d4 <realloc+0x444>

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return NULL;
57e0a7d0:	e3a07000 	mov	r7, #0
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
57e0a7d4:	e1a00007 	mov	r0, r7
57e0a7d8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0a7dc:	57e369b0 	.word	0x57e369b0

57e0a7e0 <malloc_usable_size>:
#else
size_t malloc_usable_size(mem) Void_t* mem;
#endif
{
  mchunkptr p;
  if (mem == NULL)
57e0a7e0:	e3500000 	cmp	r0, #0
57e0a7e4:	012fff1e 	bxeq	lr
    return 0;
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
57e0a7e8:	e5103004 	ldr	r3, [r0, #-4]
  mchunkptr p;
  if (mem == NULL)
    return 0;
  else
  {
    p = mem2chunk(mem);
57e0a7ec:	e2401008 	sub	r1, r0, #8
    if(!chunk_is_mmapped(p))
57e0a7f0:	e3130002 	tst	r3, #2
57e0a7f4:	1a000006 	bne	57e0a814 <malloc_usable_size+0x34>
    {
      if (!inuse(p)) return 0;
57e0a7f8:	e3c32001 	bic	r2, r3, #1
57e0a7fc:	e0812002 	add	r2, r1, r2
57e0a800:	e5920004 	ldr	r0, [r2, #4]
57e0a804:	e2100001 	ands	r0, r0, #1
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
57e0a808:	13c30003 	bicne	r0, r3, #3
57e0a80c:	12400004 	subne	r0, r0, #4
57e0a810:	e12fff1e 	bx	lr
    }
    return chunksize(p) - 2*SIZE_SZ;
57e0a814:	e3c30003 	bic	r0, r3, #3
57e0a818:	e2400008 	sub	r0, r0, #8
  }
}
57e0a81c:	e12fff1e 	bx	lr

57e0a820 <mallopt>:
int mALLOPt(int param_number, int value)
#else
int mALLOPt(param_number, value) int param_number; int value;
#endif
{
  switch(param_number)
57e0a820:	e2800004 	add	r0, r0, #4
57e0a824:	e3500003 	cmp	r0, #3
57e0a828:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
57e0a82c:	ea000012 	b	57e0a87c <mallopt+0x5c>
57e0a830:	57e0a864 	.word	0x57e0a864
57e0a834:	57e0a858 	.word	0x57e0a858
57e0a838:	57e0a84c 	.word	0x57e0a84c
57e0a83c:	57e0a840 	.word	0x57e0a840
  {
    case M_TRIM_THRESHOLD:
      trim_threshold = value; return 1;
57e0a840:	e59f3044 	ldr	r3, [pc, #68]	; 57e0a88c <mallopt+0x6c>
57e0a844:	e583140c 	str	r1, [r3, #1036]	; 0x40c
57e0a848:	ea000009 	b	57e0a874 <mallopt+0x54>
    case M_TOP_PAD:
      top_pad = value; return 1;
57e0a84c:	e59f303c 	ldr	r3, [pc, #60]	; 57e0a890 <mallopt+0x70>
57e0a850:	e5831034 	str	r1, [r3, #52]	; 0x34
57e0a854:	ea000006 	b	57e0a874 <mallopt+0x54>
    case M_MMAP_THRESHOLD:
      mmap_threshold = value; return 1;
57e0a858:	e59f302c 	ldr	r3, [pc, #44]	; 57e0a88c <mallopt+0x6c>
57e0a85c:	e5831410 	str	r1, [r3, #1040]	; 0x410
57e0a860:	ea000003 	b	57e0a874 <mallopt+0x54>
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
57e0a864:	e3510000 	cmp	r1, #0
57e0a868:	1a000005 	bne	57e0a884 <mallopt+0x64>
57e0a86c:	e59f301c 	ldr	r3, [pc, #28]	; 57e0a890 <mallopt+0x70>
57e0a870:	e5831040 	str	r1, [r3, #64]	; 0x40
57e0a874:	e3a00001 	mov	r0, #1
57e0a878:	e12fff1e 	bx	lr
#endif

    default:
      return 0;
57e0a87c:	e3a00000 	mov	r0, #0
57e0a880:	e12fff1e 	bx	lr
      mmap_threshold = value; return 1;
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
57e0a884:	e3a00000 	mov	r0, #0
#endif

    default:
      return 0;
  }
}
57e0a888:	e12fff1e 	bx	lr
57e0a88c:	57e369b0 	.word	0x57e369b0
57e0a890:	57e383f0 	.word	0x57e383f0

57e0a894 <reverse_strstr>:
 * Search for the last matching string in another string with the option to
 * start looking at a certain point (i.e. ignore anything beyond that point).
 */
static char *reverse_strstr(const char *searched, const char *search_for,
	const char *searched_start)
{
57e0a894:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	char *result = NULL;

	if (*search_for == '\0')
57e0a898:	e5d13000 	ldrb	r3, [r1]
 * Search for the last matching string in another string with the option to
 * start looking at a certain point (i.e. ignore anything beyond that point).
 */
static char *reverse_strstr(const char *searched, const char *search_for,
	const char *searched_start)
{
57e0a89c:	e1a04001 	mov	r4, r1
	char *result = NULL;

	if (*search_for == '\0')
57e0a8a0:	e3530000 	cmp	r3, #0
 * Search for the last matching string in another string with the option to
 * start looking at a certain point (i.e. ignore anything beyond that point).
 */
static char *reverse_strstr(const char *searched, const char *search_for,
	const char *searched_start)
{
57e0a8a4:	e1a06002 	mov	r6, r2
	char *result = NULL;

	if (*search_for == '\0')
57e0a8a8:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
57e0a8ac:	e3a05000 	mov	r5, #0
		return (char *)searched;

	for (;;) {
		char *match = strstr(searched, search_for);
57e0a8b0:	e1a01004 	mov	r1, r4
57e0a8b4:	eb0066df 	bl	57e24438 <strstr>

		/*
		 * Stop looking if no new match is found or looking past the
		 * searched_start pointer
		 */
		if (match == NULL || (searched_start != NULL &&
57e0a8b8:	e2507000 	subs	r7, r0, #0
57e0a8bc:	0a000009 	beq	57e0a8e8 <reverse_strstr+0x54>
57e0a8c0:	e3560000 	cmp	r6, #0
57e0a8c4:	0a000004 	beq	57e0a8dc <reverse_strstr+0x48>
		    match + strlen(search_for) > searched_start))
57e0a8c8:	e1a00004 	mov	r0, r4
57e0a8cc:	eb0065df 	bl	57e24050 <strlen>
57e0a8d0:	e0870000 	add	r0, r7, r0

		/*
		 * Stop looking if no new match is found or looking past the
		 * searched_start pointer
		 */
		if (match == NULL || (searched_start != NULL &&
57e0a8d4:	e1560000 	cmp	r6, r0
57e0a8d8:	3a000004 	bcc	57e0a8f0 <reverse_strstr+0x5c>
		    match + strlen(search_for) > searched_start))
			break;

		result = match;
		searched = match + 1;
57e0a8dc:	e2870001 	add	r0, r7, #1
57e0a8e0:	e1a05007 	mov	r5, r7
	}
57e0a8e4:	eafffff1 	b	57e0a8b0 <reverse_strstr+0x1c>

		/*
		 * Stop looking if no new match is found or looking past the
		 * searched_start pointer
		 */
		if (match == NULL || (searched_start != NULL &&
57e0a8e8:	e1a00005 	mov	r0, r5
57e0a8ec:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e0a8f0:	e1a00005 	mov	r0, r5
		result = match;
		searched = match + 1;
	}

	return result;
}
57e0a8f4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e0a8f8 <env_attr_walk>:
 *	entry = name[:attributes]
 *	list = entry[,list]
 */
int env_attr_walk(const char *attr_list,
	int (*callback)(const char *name, const char *attributes))
{
57e0a8f8:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	const char *entry, *entry_end;
	char *name, *attributes;

	if (!attr_list)
57e0a8fc:	e2509000 	subs	r9, r0, #0
 *	entry = name[:attributes]
 *	list = entry[,list]
 */
int env_attr_walk(const char *attr_list,
	int (*callback)(const char *name, const char *attributes))
{
57e0a900:	e1a0a001 	mov	sl, r1
	const char *entry, *entry_end;
	char *name, *attributes;

	if (!attr_list)
		/* list not found */
		return 1;
57e0a904:	03a06001 	moveq	r6, #1
	int (*callback)(const char *name, const char *attributes))
{
	const char *entry, *entry_end;
	char *name, *attributes;

	if (!attr_list)
57e0a908:	0a00003a 	beq	57e0a9f8 <env_attr_walk+0x100>
57e0a90c:	e3a07000 	mov	r7, #0

	entry = attr_list;
	do {
		char *entry_cpy = NULL;

		entry_end = strchr(entry, ENV_ATTR_LIST_DELIM);
57e0a910:	e1a00009 	mov	r0, r9
57e0a914:	e3a0102c 	mov	r1, #44	; 0x2c
57e0a918:	eb0065bf 	bl	57e2401c <strchr>
		/* check if this is the last entry in the list */
		if (entry_end == NULL) {
57e0a91c:	e2505000 	subs	r5, r0, #0
57e0a920:	1a00000a 	bne	57e0a950 <env_attr_walk+0x58>
			int entry_len = strlen(entry);
57e0a924:	e1a00009 	mov	r0, r9
57e0a928:	eb0065c8 	bl	57e24050 <strlen>

			if (entry_len) {
57e0a92c:	e3500000 	cmp	r0, #0
57e0a930:	0a000032 	beq	57e0aa00 <env_attr_walk+0x108>
				/*
				 * allocate memory to copy the entry into since
				 * we will need to inject '\0' chars and squash
				 * white-space before calling the callback
				 */
				entry_cpy = malloc(entry_len + 1);
57e0a934:	e2800001 	add	r0, r0, #1
57e0a938:	ebfffca1 	bl	57e09bc4 <malloc>
				if (entry_cpy)
57e0a93c:	e2504000 	subs	r4, r0, #0
57e0a940:	0a000029 	beq	57e0a9ec <env_attr_walk+0xf4>
					/* copy the rest of the list */
					strcpy(entry_cpy, entry);
57e0a944:	e1a01009 	mov	r1, r9
57e0a948:	eb006564 	bl	57e23ee0 <strcpy>
57e0a94c:	ea000009 	b	57e0a978 <env_attr_walk+0x80>
					return -ENOMEM;
			}
		} else {
			int entry_len = entry_end - entry;

			if (entry_len) {
57e0a950:	e0556009 	subs	r6, r5, r9
57e0a954:	0a000029 	beq	57e0aa00 <env_attr_walk+0x108>
				/*
				 * allocate memory to copy the entry into since
				 * we will need to inject '\0' chars and squash
				 * white-space before calling the callback
				 */
				entry_cpy = malloc(entry_len + 1);
57e0a958:	e2860001 	add	r0, r6, #1
57e0a95c:	ebfffc98 	bl	57e09bc4 <malloc>
				if (entry_cpy) {
57e0a960:	e2504000 	subs	r4, r0, #0
57e0a964:	0a000020 	beq	57e0a9ec <env_attr_walk+0xf4>
					/* copy just this entry and null term */
					strncpy(entry_cpy, entry, entry_len);
57e0a968:	e1a01009 	mov	r1, r9
57e0a96c:	e1a02006 	mov	r2, r6
57e0a970:	eb006561 	bl	57e23efc <strncpy>
					entry_cpy[entry_len] = '\0';
57e0a974:	e7c47006 	strb	r7, [r4, r6]
			}
		}

		/* check if there is anything to process (e.g. not ",,,") */
		if (entry_cpy != NULL) {
			attributes = strchr(entry_cpy, ENV_ATTR_SEP);
57e0a978:	e1a00004 	mov	r0, r4
57e0a97c:	e3a0103a 	mov	r1, #58	; 0x3a
57e0a980:	eb0065a5 	bl	57e2401c <strchr>
			/* check if there is a ':' */
			if (attributes != NULL) {
57e0a984:	e2506000 	subs	r6, r0, #0
57e0a988:	0a000003 	beq	57e0a99c <env_attr_walk+0xa4>
				/* replace the ':' with '\0' to term name */
				*attributes++ = '\0';
57e0a98c:	e1a00006 	mov	r0, r6
57e0a990:	e4c07001 	strb	r7, [r0], #1
				/* remove white-space from attributes */
				attributes = strim(attributes);
57e0a994:	eb00636e 	bl	57e23754 <strim>
57e0a998:	e1a06000 	mov	r6, r0
			}
			/* remove white-space from name */
			name = strim(entry_cpy);
57e0a99c:	e1a00004 	mov	r0, r4
57e0a9a0:	eb00636b 	bl	57e23754 <strim>
57e0a9a4:	e1a09000 	mov	r9, r0

			/* only call the callback if there is a name */
			if (strlen(name) != 0) {
57e0a9a8:	eb0065a8 	bl	57e24050 <strlen>
57e0a9ac:	e3500000 	cmp	r0, #0
57e0a9b0:	0a000007 	beq	57e0a9d4 <env_attr_walk+0xdc>
				int retval = 0;

				retval = callback(name, attributes);
57e0a9b4:	e1a01006 	mov	r1, r6
57e0a9b8:	e1a00009 	mov	r0, r9
57e0a9bc:	e12fff3a 	blx	sl
				if (retval) {
57e0a9c0:	e2506000 	subs	r6, r0, #0
57e0a9c4:	0a000002 	beq	57e0a9d4 <env_attr_walk+0xdc>
					free(entry_cpy);
57e0a9c8:	e1a00004 	mov	r0, r4
57e0a9cc:	ebfffbf2 	bl	57e0999c <free>
					return retval;
57e0a9d0:	ea000008 	b	57e0a9f8 <env_attr_walk+0x100>
				}
			}
		}

		free(entry_cpy);
57e0a9d4:	e1a00004 	mov	r0, r4
57e0a9d8:	ebfffbef 	bl	57e0999c <free>
		entry = entry_end + 1;
	} while (entry_end != NULL);
57e0a9dc:	e3550000 	cmp	r5, #0
57e0a9e0:	0a000003 	beq	57e0a9f4 <env_attr_walk+0xfc>
				}
			}
		}

		free(entry_cpy);
		entry = entry_end + 1;
57e0a9e4:	e2859001 	add	r9, r5, #1
57e0a9e8:	eaffffc8 	b	57e0a910 <env_attr_walk+0x18>
				if (entry_cpy) {
					/* copy just this entry and null term */
					strncpy(entry_cpy, entry, entry_len);
					entry_cpy[entry_len] = '\0';
				} else
					return -ENOMEM;
57e0a9ec:	e3e0600b 	mvn	r6, #11
57e0a9f0:	ea000000 	b	57e0a9f8 <env_attr_walk+0x100>

		free(entry_cpy);
		entry = entry_end + 1;
	} while (entry_end != NULL);

	return 0;
57e0a9f4:	e1a06005 	mov	r6, r5
}
57e0a9f8:	e1a00006 	mov	r0, r6
57e0a9fc:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	int (*callback)(const char *name, const char *attributes))
{
	const char *entry, *entry_end;
	char *name, *attributes;

	if (!attr_list)
57e0aa00:	e3a04000 	mov	r4, #0
57e0aa04:	eafffff2 	b	57e0a9d4 <env_attr_walk+0xdc>

57e0aa08 <env_attr_lookup>:
/*
 * Retrieve the attributes string associated with a single name in the list
 * There is no protection on attributes being too small for the value
 */
int env_attr_lookup(const char *attr_list, const char *name, char *attributes)
{
57e0aa08:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	const char *entry = NULL;

	if (!attributes)
57e0aa0c:	e2526000 	subs	r6, r2, #0
/*
 * Retrieve the attributes string associated with a single name in the list
 * There is no protection on attributes being too small for the value
 */
int env_attr_lookup(const char *attr_list, const char *name, char *attributes)
{
57e0aa10:	e1a05000 	mov	r5, r0
57e0aa14:	e1a04001 	mov	r4, r1
	const char *entry = NULL;

	if (!attributes)
		/* bad parameter */
		return -1;
57e0aa18:	03e00000 	mvneq	r0, #0
 */
int env_attr_lookup(const char *attr_list, const char *name, char *attributes)
{
	const char *entry = NULL;

	if (!attributes)
57e0aa1c:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		/* bad parameter */
		return -1;
	if (!attr_list)
57e0aa20:	e3550000 	cmp	r5, #0
		/* list not found */
		return 1;

	entry = reverse_strstr(attr_list, name, NULL);
57e0aa24:	13a02000 	movne	r2, #0
	const char *entry = NULL;

	if (!attributes)
		/* bad parameter */
		return -1;
	if (!attr_list)
57e0aa28:	1a000016 	bne	57e0aa88 <env_attr_lookup+0x80>
57e0aa2c:	ea00003b 	b	57e0ab20 <env_attr_lookup+0x118>
		return 1;

	entry = reverse_strstr(attr_list, name, NULL);
	while (entry != NULL) {
		const char *prevch = entry - 1;
		const char *nextch = entry + strlen(name);
57e0aa30:	e1a00004 	mov	r0, r4
57e0aa34:	eb006585 	bl	57e24050 <strlen>
57e0aa38:	e1a03007 	mov	r3, r7
57e0aa3c:	e0870000 	add	r0, r7, r0

		/* Skip spaces */
		while (*prevch == ' ')
57e0aa40:	e5732001 	ldrb	r2, [r3, #-1]!
57e0aa44:	e3520020 	cmp	r2, #32
57e0aa48:	0afffffc 	beq	57e0aa40 <env_attr_lookup+0x38>
			prevch--;
		while (*nextch == ' ')
57e0aa4c:	e4d03001 	ldrb	r3, [r0], #1
57e0aa50:	e3530020 	cmp	r3, #32
57e0aa54:	0afffffc 	beq	57e0aa4c <env_attr_lookup+0x44>
			nextch++;

		/* check for an exact match */
		if ((entry == attr_list ||
57e0aa58:	e1570005 	cmp	r7, r5
57e0aa5c:	0a000001 	beq	57e0aa68 <env_attr_lookup+0x60>
57e0aa60:	e352002c 	cmp	r2, #44	; 0x2c
57e0aa64:	1a000004 	bne	57e0aa7c <env_attr_lookup+0x74>
		     *prevch == ENV_ATTR_LIST_DELIM) &&
57e0aa68:	e353003a 	cmp	r3, #58	; 0x3a
57e0aa6c:	1353002c 	cmpne	r3, #44	; 0x2c
57e0aa70:	0a00000a 	beq	57e0aaa0 <env_attr_lookup+0x98>
		    (*nextch == ENV_ATTR_SEP ||
		     *nextch == ENV_ATTR_LIST_DELIM ||
57e0aa74:	e3530000 	cmp	r3, #0
57e0aa78:	0a000008 	beq	57e0aaa0 <env_attr_lookup+0x98>
		     *nextch == '\0'))
			break;

		entry = reverse_strstr(attr_list, name, entry);
57e0aa7c:	e1a00005 	mov	r0, r5
57e0aa80:	e1a01004 	mov	r1, r4
57e0aa84:	e1a02007 	mov	r2, r7
57e0aa88:	ebffff81 	bl	57e0a894 <reverse_strstr>
	if (!attr_list)
		/* list not found */
		return 1;

	entry = reverse_strstr(attr_list, name, NULL);
	while (entry != NULL) {
57e0aa8c:	e3500000 	cmp	r0, #0
		    (*nextch == ENV_ATTR_SEP ||
		     *nextch == ENV_ATTR_LIST_DELIM ||
		     *nextch == '\0'))
			break;

		entry = reverse_strstr(attr_list, name, entry);
57e0aa90:	e1a07000 	mov	r7, r0
	if (!attr_list)
		/* list not found */
		return 1;

	entry = reverse_strstr(attr_list, name, NULL);
	while (entry != NULL) {
57e0aa94:	1affffe5 	bne	57e0aa30 <env_attr_lookup+0x28>
		/* success */
		return 0;
	}

	/* not found in list */
	return 2;
57e0aa98:	e3a00002 	mov	r0, #2
57e0aa9c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}
	if (entry != NULL) {
		int len;

		/* skip the name */
		entry += strlen(name);
57e0aaa0:	e1a00004 	mov	r0, r4
57e0aaa4:	eb006569 	bl	57e24050 <strlen>
57e0aaa8:	e0870000 	add	r0, r7, r0
		/* skip spaces */
		while (*entry == ' ')
57e0aaac:	e1a02000 	mov	r2, r0
57e0aab0:	e4d03001 	ldrb	r3, [r0], #1
57e0aab4:	e3530020 	cmp	r3, #32
57e0aab8:	0afffffb 	beq	57e0aaac <env_attr_lookup+0xa4>
			entry++;
		if (*entry != ENV_ATTR_SEP)
57e0aabc:	e353003a 	cmp	r3, #58	; 0x3a
			len = 0;
57e0aac0:	13a04000 	movne	r4, #0
		/* skip the name */
		entry += strlen(name);
		/* skip spaces */
		while (*entry == ' ')
			entry++;
		if (*entry != ENV_ATTR_SEP)
57e0aac4:	1a000012 	bne	57e0ab14 <env_attr_lookup+0x10c>
			const char *delim;
			static const char delims[] = {
				ENV_ATTR_LIST_DELIM, ' ', '\0'};

			/* skip the attr sep */
			entry += 1;
57e0aac8:	e2822001 	add	r2, r2, #1
			/* skip spaces */
			while (*entry == ' ')
57e0aacc:	e5d23000 	ldrb	r3, [r2]
57e0aad0:	e1a05002 	mov	r5, r2
57e0aad4:	e3530020 	cmp	r3, #32
57e0aad8:	e2822001 	add	r2, r2, #1
57e0aadc:	0afffffa 	beq	57e0aacc <env_attr_lookup+0xc4>
				entry++;

			delim = strpbrk(entry, delims);
57e0aae0:	e1a00005 	mov	r0, r5
57e0aae4:	e59f103c 	ldr	r1, [pc, #60]	; 57e0ab28 <env_attr_lookup+0x120>
57e0aae8:	eb006595 	bl	57e24144 <strpbrk>
			if (delim == NULL)
57e0aaec:	e3500000 	cmp	r0, #0
				len = strlen(entry);
			else
				len = delim - entry;
57e0aaf0:	10654000 	rsbne	r4, r5, r0
			/* skip spaces */
			while (*entry == ' ')
				entry++;

			delim = strpbrk(entry, delims);
			if (delim == NULL)
57e0aaf4:	1a000002 	bne	57e0ab04 <env_attr_lookup+0xfc>
				len = strlen(entry);
57e0aaf8:	e1a00005 	mov	r0, r5
57e0aafc:	eb006553 	bl	57e24050 <strlen>
57e0ab00:	e1a04000 	mov	r4, r0
			else
				len = delim - entry;
			memcpy(attributes, entry, len);
57e0ab04:	e1a00006 	mov	r0, r6
57e0ab08:	e1a01005 	mov	r1, r5
57e0ab0c:	e1a02004 	mov	r2, r4
57e0ab10:	eb0065fd 	bl	57e2430c <memcpy>
		}
		attributes[len] = '\0';
57e0ab14:	e3a00000 	mov	r0, #0
57e0ab18:	e7c60004 	strb	r0, [r6, r4]

		/* success */
		return 0;
57e0ab1c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	if (!attributes)
		/* bad parameter */
		return -1;
	if (!attr_list)
		/* list not found */
		return 1;
57e0ab20:	e3a00001 	mov	r0, #1
		return 0;
	}

	/* not found in list */
	return 2;
}
57e0ab24:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e0ab28:	57e2be54 	.word	0x57e2be54

57e0ab2c <clear_callback>:
 * Called on each existing env var prior to the blanket update since removing
 * a callback association should remove its callback.
 */
static int clear_callback(ENTRY *entry)
{
	entry->callback = NULL;
57e0ab2c:	e3a03000 	mov	r3, #0
57e0ab30:	e5803008 	str	r3, [r0, #8]

	return 0;
}
57e0ab34:	e1a00003 	mov	r0, r3
57e0ab38:	e12fff1e 	bx	lr

57e0ab3c <on_callbacks>:
	return 0;
}

static int on_callbacks(const char *name, const char *value, enum env_op op,
	int flags)
{
57e0ab3c:	e92d4038 	push	{r3, r4, r5, lr}
	/* remove all callbacks */
	hwalk_r(&env_htab, clear_callback);

	/* configure any static callback bindings */
	env_attr_walk(ENV_CALLBACK_LIST_STATIC, set_callback);
57e0ab40:	e59f402c 	ldr	r4, [pc, #44]	; 57e0ab74 <on_callbacks+0x38>
	return 0;
}

static int on_callbacks(const char *name, const char *value, enum env_op op,
	int flags)
{
57e0ab44:	e1a05001 	mov	r5, r1
	/* remove all callbacks */
	hwalk_r(&env_htab, clear_callback);
57e0ab48:	e59f0028 	ldr	r0, [pc, #40]	; 57e0ab78 <on_callbacks+0x3c>
57e0ab4c:	e59f1028 	ldr	r1, [pc, #40]	; 57e0ab7c <on_callbacks+0x40>
57e0ab50:	eb0062cc 	bl	57e23688 <hwalk_r>

	/* configure any static callback bindings */
	env_attr_walk(ENV_CALLBACK_LIST_STATIC, set_callback);
57e0ab54:	e1a01004 	mov	r1, r4
57e0ab58:	e59f0020 	ldr	r0, [pc, #32]	; 57e0ab80 <on_callbacks+0x44>
57e0ab5c:	ebffff65 	bl	57e0a8f8 <env_attr_walk>
	/* configure any dynamic callback bindings */
	env_attr_walk(value, set_callback);
57e0ab60:	e1a00005 	mov	r0, r5
57e0ab64:	e1a01004 	mov	r1, r4
57e0ab68:	ebffff62 	bl	57e0a8f8 <env_attr_walk>

	return 0;
}
57e0ab6c:	e3a00000 	mov	r0, #0
57e0ab70:	e8bd8038 	pop	{r3, r4, r5, pc}
57e0ab74:	57e0abe8 	.word	0x57e0abe8
57e0ab78:	57e36dc4 	.word	0x57e36dc4
57e0ab7c:	57e0ab2c 	.word	0x57e0ab2c
57e0ab80:	57e31e68 	.word	0x57e31e68

57e0ab84 <find_env_callback>:

/*
 * Look up a callback function pointer by name
 */
struct env_clbk_tbl *find_env_callback(const char *name)
{
57e0ab84:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct env_clbk_tbl *clbkp;
	int i;
	int num_callbacks = ll_entry_count(struct env_clbk_tbl, env_clbk);
57e0ab88:	e59f4050 	ldr	r4, [pc, #80]	; 57e0abe0 <find_env_callback+0x5c>
57e0ab8c:	e59f7050 	ldr	r7, [pc, #80]	; 57e0abe4 <find_env_callback+0x60>

	if (name == NULL)
57e0ab90:	e2506000 	subs	r6, r0, #0
 */
struct env_clbk_tbl *find_env_callback(const char *name)
{
	struct env_clbk_tbl *clbkp;
	int i;
	int num_callbacks = ll_entry_count(struct env_clbk_tbl, env_clbk);
57e0ab94:	e0647007 	rsb	r7, r4, r7
57e0ab98:	e1a071c7 	asr	r7, r7, #3

	if (name == NULL)
57e0ab9c:	13a05000 	movne	r5, #0
57e0aba0:	0a00000b 	beq	57e0abd4 <find_env_callback+0x50>
57e0aba4:	ea000006 	b	57e0abc4 <find_env_callback+0x40>

	/* look up the callback in the linker-list */
	for (i = 0, clbkp = ll_entry_start(struct env_clbk_tbl, env_clbk);
	     i < num_callbacks;
	     i++, clbkp++) {
		if (strcmp(name, clbkp->name) == 0)
57e0aba8:	e1a00006 	mov	r0, r6
57e0abac:	e5941000 	ldr	r1, [r4]
57e0abb0:	eb0064fb 	bl	57e23fa4 <strcmp>
57e0abb4:	e3500000 	cmp	r0, #0
57e0abb8:	0a000006 	beq	57e0abd8 <find_env_callback+0x54>
		return NULL;

	/* look up the callback in the linker-list */
	for (i = 0, clbkp = ll_entry_start(struct env_clbk_tbl, env_clbk);
	     i < num_callbacks;
	     i++, clbkp++) {
57e0abbc:	e2855001 	add	r5, r5, #1
57e0abc0:	e2844008 	add	r4, r4, #8

	if (name == NULL)
		return NULL;

	/* look up the callback in the linker-list */
	for (i = 0, clbkp = ll_entry_start(struct env_clbk_tbl, env_clbk);
57e0abc4:	e1550007 	cmp	r5, r7
57e0abc8:	bafffff6 	blt	57e0aba8 <find_env_callback+0x24>
	     i++, clbkp++) {
		if (strcmp(name, clbkp->name) == 0)
			return clbkp;
	}

	return NULL;
57e0abcc:	e3a04000 	mov	r4, #0
57e0abd0:	ea000000 	b	57e0abd8 <find_env_callback+0x54>
	struct env_clbk_tbl *clbkp;
	int i;
	int num_callbacks = ll_entry_count(struct env_clbk_tbl, env_clbk);

	if (name == NULL)
		return NULL;
57e0abd4:	e1a04006 	mov	r4, r6
		if (strcmp(name, clbkp->name) == 0)
			return clbkp;
	}

	return NULL;
}
57e0abd8:	e1a00004 	mov	r0, r4
57e0abdc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	...

57e0abe8 <set_callback>:

/*
 * Call for each element in the list that associates variables to callbacks
 */
static int set_callback(const char *name, const char *value)
{
57e0abe8:	e92d4010 	push	{r4, lr}
57e0abec:	e24dd028 	sub	sp, sp, #40	; 0x28
	ENTRY e, *ep;
	struct env_clbk_tbl *clbkp;

	e.key	= name;
	e.data	= NULL;
	hsearch_r(e, FIND, &ep, &env_htab, 0);
57e0abf0:	e28d2024 	add	r2, sp, #36	; 0x24
57e0abf4:	e58d2004 	str	r2, [sp, #4]
57e0abf8:	e59f2078 	ldr	r2, [pc, #120]	; 57e0ac78 <set_callback+0x90>
{
	ENTRY e, *ep;
	struct env_clbk_tbl *clbkp;

	e.key	= name;
	e.data	= NULL;
57e0abfc:	e3a03000 	mov	r3, #0
57e0ac00:	e58d3018 	str	r3, [sp, #24]
	hsearch_r(e, FIND, &ep, &env_htab, 0);
57e0ac04:	e58d3000 	str	r3, [sp]
57e0ac08:	e58d300c 	str	r3, [sp, #12]
static int set_callback(const char *name, const char *value)
{
	ENTRY e, *ep;
	struct env_clbk_tbl *clbkp;

	e.key	= name;
57e0ac0c:	e58d0014 	str	r0, [sp, #20]
	e.data	= NULL;
	hsearch_r(e, FIND, &ep, &env_htab, 0);
57e0ac10:	e58d2008 	str	r2, [sp, #8]
57e0ac14:	e28d3014 	add	r3, sp, #20

/*
 * Call for each element in the list that associates variables to callbacks
 */
static int set_callback(const char *name, const char *value)
{
57e0ac18:	e1a04001 	mov	r4, r1
	ENTRY e, *ep;
	struct env_clbk_tbl *clbkp;

	e.key	= name;
	e.data	= NULL;
	hsearch_r(e, FIND, &ep, &env_htab, 0);
57e0ac1c:	e893000f 	ldm	r3, {r0, r1, r2, r3}
57e0ac20:	eb005fa0 	bl	57e22aa8 <hsearch_r>

	/* does the env variable actually exist? */
	if (ep != NULL) {
57e0ac24:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e0ac28:	e3530000 	cmp	r3, #0
57e0ac2c:	0a00000e 	beq	57e0ac6c <set_callback+0x84>
		/* the assocaition delares no callback, so remove the pointer */
		if (value == NULL || strlen(value) == 0)
57e0ac30:	e3540000 	cmp	r4, #0
57e0ac34:	0a000003 	beq	57e0ac48 <set_callback+0x60>
57e0ac38:	e1a00004 	mov	r0, r4
57e0ac3c:	eb006503 	bl	57e24050 <strlen>
57e0ac40:	e3500000 	cmp	r0, #0
57e0ac44:	1a000001 	bne	57e0ac50 <set_callback+0x68>
			ep->callback = NULL;
57e0ac48:	e3a02000 	mov	r2, #0
57e0ac4c:	ea000004 	b	57e0ac64 <set_callback+0x7c>
		else {
			/* assign the requested callback */
			clbkp = find_env_callback(value);
57e0ac50:	e1a00004 	mov	r0, r4
57e0ac54:	ebffffca 	bl	57e0ab84 <find_env_callback>
			if (clbkp != NULL)
57e0ac58:	e3500000 	cmp	r0, #0
57e0ac5c:	0a000002 	beq	57e0ac6c <set_callback+0x84>
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
				ep->callback = clbkp->callback + gd->reloc_off;
#else
				ep->callback = clbkp->callback;
57e0ac60:	e5902004 	ldr	r2, [r0, #4]
57e0ac64:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e0ac68:	e5832008 	str	r2, [r3, #8]
#endif
		}
	}

	return 0;
}
57e0ac6c:	e3a00000 	mov	r0, #0
57e0ac70:	e28dd028 	add	sp, sp, #40	; 0x28
57e0ac74:	e8bd8010 	pop	{r4, pc}
57e0ac78:	57e36dc4 	.word	0x57e36dc4

57e0ac7c <env_callback_init>:
 * Look for a possible callback for a newly added variable
 * This is called specifically when the variable did not exist in the hash
 * previously, so the blanket update did not find this variable.
 */
void env_callback_init(ENTRY *var_entry)
{
57e0ac7c:	e92d4070 	push	{r4, r5, r6, lr}
	const char *var_name = var_entry->key;
57e0ac80:	e5905000 	ldr	r5, [r0]
 * Look for a possible callback for a newly added variable
 * This is called specifically when the variable did not exist in the hash
 * previously, so the blanket update did not find this variable.
 */
void env_callback_init(ENTRY *var_entry)
{
57e0ac84:	e24ddc01 	sub	sp, sp, #256	; 0x100
57e0ac88:	e1a04000 	mov	r4, r0
	const char *var_name = var_entry->key;
	const char *callback_list = getenv(ENV_CALLBACK_VAR);
57e0ac8c:	e59f0080 	ldr	r0, [pc, #128]	; 57e0ad14 <env_callback_init+0x98>
57e0ac90:	ebfff294 	bl	57e076e8 <getenv>
	char callback_name[256] = "";
57e0ac94:	e3a01000 	mov	r1, #0
 * previously, so the blanket update did not find this variable.
 */
void env_callback_init(ENTRY *var_entry)
{
	const char *var_name = var_entry->key;
	const char *callback_list = getenv(ENV_CALLBACK_VAR);
57e0ac98:	e1a06000 	mov	r6, r0
	char callback_name[256] = "";
57e0ac9c:	e3a020fc 	mov	r2, #252	; 0xfc
57e0aca0:	e28d0004 	add	r0, sp, #4
57e0aca4:	e58d1000 	str	r1, [sp]
57e0aca8:	eb006573 	bl	57e2427c <memset>
	struct env_clbk_tbl *clbkp;
	int ret = 1;

	/* look in the ".callbacks" var for a reference to this variable */
	if (callback_list != NULL)
57e0acac:	e3560000 	cmp	r6, #0
57e0acb0:	0a000005 	beq	57e0accc <env_callback_init+0x50>
		ret = env_attr_lookup(callback_list, var_name, callback_name);
57e0acb4:	e1a00006 	mov	r0, r6
57e0acb8:	e1a01005 	mov	r1, r5
57e0acbc:	e1a0200d 	mov	r2, sp
57e0acc0:	ebffff50 	bl	57e0aa08 <env_attr_lookup>

	/* only if not found there, look in the static list */
	if (ret)
57e0acc4:	e3500000 	cmp	r0, #0
57e0acc8:	0a000005 	beq	57e0ace4 <env_callback_init+0x68>
		ret = env_attr_lookup(ENV_CALLBACK_LIST_STATIC, var_name,
57e0accc:	e59f0044 	ldr	r0, [pc, #68]	; 57e0ad18 <env_callback_init+0x9c>
57e0acd0:	e1a01005 	mov	r1, r5
57e0acd4:	e1a0200d 	mov	r2, sp
57e0acd8:	ebffff4a 	bl	57e0aa08 <env_attr_lookup>
			callback_name);

	/* if an association was found, set the callback pointer */
	if (!ret && strlen(callback_name)) {
57e0acdc:	e3500000 	cmp	r0, #0
57e0ace0:	1a000009 	bne	57e0ad0c <env_callback_init+0x90>
57e0ace4:	e1a0000d 	mov	r0, sp
57e0ace8:	eb0064d8 	bl	57e24050 <strlen>
57e0acec:	e3500000 	cmp	r0, #0
57e0acf0:	e1a0500d 	mov	r5, sp
57e0acf4:	0a000004 	beq	57e0ad0c <env_callback_init+0x90>
		clbkp = find_env_callback(callback_name);
57e0acf8:	e1a0000d 	mov	r0, sp
57e0acfc:	ebffffa0 	bl	57e0ab84 <find_env_callback>
		if (clbkp != NULL)
57e0ad00:	e3500000 	cmp	r0, #0
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
			var_entry->callback = clbkp->callback + gd->reloc_off;
#else
			var_entry->callback = clbkp->callback;
57e0ad04:	15903004 	ldrne	r3, [r0, #4]
57e0ad08:	15843008 	strne	r3, [r4, #8]
#endif
	}
}
57e0ad0c:	e28ddc01 	add	sp, sp, #256	; 0x100
57e0ad10:	e8bd8070 	pop	{r4, r5, r6, pc}
57e0ad14:	57e31eed 	.word	0x57e31eed
57e0ad18:	57e31e68 	.word	0x57e31e68

57e0ad1c <env_get_char_spec>:
	.change_ok = env_flags_validate,
};

static uchar __env_get_char_spec(int index)
{
	return *((uchar *)(gd->env_addr + index));
57e0ad1c:	e5983010 	ldr	r3, [r8, #16]
}
57e0ad20:	e7d00003 	ldrb	r0, [r0, r3]
57e0ad24:	e12fff1e 	bx	lr

57e0ad28 <env_get_addr>:
		return env_get_char_init(index);
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
57e0ad28:	e5982014 	ldr	r2, [r8, #20]
57e0ad2c:	e1a03008 	mov	r3, r8
57e0ad30:	e3520000 	cmp	r2, #0
		return (uchar *)(gd->env_addr + index);
57e0ad34:	15983010 	ldrne	r3, [r8, #16]
	else
		return &default_environment[index];
57e0ad38:	059f3008 	ldreq	r3, [pc, #8]	; 57e0ad48 <env_get_addr+0x20>
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
		return (uchar *)(gd->env_addr + index);
57e0ad3c:	10800003 	addne	r0, r0, r3
	else
		return &default_environment[index];
57e0ad40:	00830000 	addeq	r0, r3, r0
}
57e0ad44:	e12fff1e 	bx	lr
57e0ad48:	57e2be58 	.word	0x57e2be58

57e0ad4c <env_get_char_memory>:
	else
		return default_environment[index];
}

uchar env_get_char_memory(int index)
{
57e0ad4c:	e92d4008 	push	{r3, lr}
	return *env_get_addr(index);
57e0ad50:	ebfffff4 	bl	57e0ad28 <env_get_addr>
}
57e0ad54:	e5d00000 	ldrb	r0, [r0]
57e0ad58:	e8bd8008 	pop	{r3, pc}

57e0ad5c <env_get_char>:

uchar env_get_char(int index)
{
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
57e0ad5c:	e5981004 	ldr	r1, [r8, #4]
57e0ad60:	e3110001 	tst	r1, #1
57e0ad64:	0a000000 	beq	57e0ad6c <env_get_char+0x10>
		return env_get_char_memory(index);
57e0ad68:	eafffff7 	b	57e0ad4c <env_get_char_memory>
	__attribute__((weak, alias("__env_get_char_spec")));

static uchar env_get_char_init(int index)
{
	/* if crc was bad, use the default environment */
	if (gd->env_valid)
57e0ad6c:	e5983014 	ldr	r3, [r8, #20]
57e0ad70:	e3530000 	cmp	r3, #0
57e0ad74:	0a000000 	beq	57e0ad7c <env_get_char+0x20>
		return env_get_char_spec(index);
57e0ad78:	eaffffe7 	b	57e0ad1c <env_get_char_spec>
	else
		return default_environment[index];
57e0ad7c:	e59f3008 	ldr	r3, [pc, #8]	; 57e0ad8c <env_get_char+0x30>
57e0ad80:	e0832000 	add	r2, r3, r0
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
		return env_get_char_memory(index);
	else
		return env_get_char_init(index);
}
57e0ad84:	e5d2007c 	ldrb	r0, [r2, #124]	; 0x7c
57e0ad88:	e12fff1e 	bx	lr
57e0ad8c:	57e2be58 	.word	0x57e2be58

57e0ad90 <getenv_yesno>:
/*
 * Read an environment variable as a boolean
 * Return -1 if variable does not exist (default to true)
 */
int getenv_yesno(const char *var)
{
57e0ad90:	e92d4008 	push	{r3, lr}
	char *s = getenv(var);
57e0ad94:	ebfff253 	bl	57e076e8 <getenv>

	if (s == NULL)
57e0ad98:	e3500000 	cmp	r0, #0
		return -1;
57e0ad9c:	03e00000 	mvneq	r0, #0
 */
int getenv_yesno(const char *var)
{
	char *s = getenv(var);

	if (s == NULL)
57e0ada0:	08bd8008 	popeq	{r3, pc}
		return -1;
	return (*s == '1' || *s == 'y' || *s == 'Y' || *s == 't' || *s == 'T') ?
57e0ada4:	e5d00000 	ldrb	r0, [r0]
57e0ada8:	e3500031 	cmp	r0, #49	; 0x31
57e0adac:	13500079 	cmpne	r0, #121	; 0x79
57e0adb0:	0a000007 	beq	57e0add4 <getenv_yesno+0x44>
57e0adb4:	e3500059 	cmp	r0, #89	; 0x59
57e0adb8:	0a000005 	beq	57e0add4 <getenv_yesno+0x44>
57e0adbc:	e3500074 	cmp	r0, #116	; 0x74
57e0adc0:	0a000005 	beq	57e0addc <getenv_yesno+0x4c>
int getenv_yesno(const char *var)
{
	char *s = getenv(var);

	if (s == NULL)
		return -1;
57e0adc4:	e3500054 	cmp	r0, #84	; 0x54
57e0adc8:	13a00000 	movne	r0, #0
57e0adcc:	03a00001 	moveq	r0, #1
57e0add0:	e8bd8008 	pop	{r3, pc}
	return (*s == '1' || *s == 'y' || *s == 'Y' || *s == 't' || *s == 'T') ?
57e0add4:	e3a00001 	mov	r0, #1
57e0add8:	e8bd8008 	pop	{r3, pc}
57e0addc:	e3a00001 	mov	r0, #1
		1 : 0;
}
57e0ade0:	e8bd8008 	pop	{r3, pc}

57e0ade4 <getenv_default>:

/*
 * Look up the variable from the default environment
 */
char *getenv_default(const char *name)
{
57e0ade4:	e92d4038 	push	{r3, r4, r5, lr}
	char *ret_val;
	unsigned long really_valid = gd->env_valid;
57e0ade8:	e5985014 	ldr	r5, [r8, #20]
	unsigned long real_gd_flags = gd->flags;
57e0adec:	e5984004 	ldr	r4, [r8, #4]

	/* Pretend that the image is bad. */
	gd->flags &= ~GD_FLG_ENV_READY;
57e0adf0:	e5982004 	ldr	r2, [r8, #4]
57e0adf4:	e3c22080 	bic	r2, r2, #128	; 0x80
57e0adf8:	e5882004 	str	r2, [r8, #4]
	gd->env_valid = 0;
57e0adfc:	e3a02000 	mov	r2, #0
57e0ae00:	e5882014 	str	r2, [r8, #20]
	ret_val = getenv(name);
57e0ae04:	ebfff237 	bl	57e076e8 <getenv>
	gd->env_valid = really_valid;
57e0ae08:	e5885014 	str	r5, [r8, #20]
	gd->flags = real_gd_flags;
57e0ae0c:	e5884004 	str	r4, [r8, #4]
	return ret_val;
}
57e0ae10:	e8bd8038 	pop	{r3, r4, r5, pc}

57e0ae14 <set_default_env>:

void set_default_env(const char *s)
{
57e0ae14:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	if (sizeof(default_environment) > ENV_SIZE) {
		puts("*** Error - default environment is too large\n\n");
		return;
	}

	if (s) {
57e0ae18:	e2504000 	subs	r4, r0, #0
57e0ae1c:	0a00000a 	beq	57e0ae4c <set_default_env+0x38>
		if (*s == '!') {
57e0ae20:	e5d43000 	ldrb	r3, [r4]
57e0ae24:	e3530021 	cmp	r3, #33	; 0x21
57e0ae28:	1a000004 	bne	57e0ae40 <set_default_env+0x2c>
			printf("*** Warning - %s, "
57e0ae2c:	e2841001 	add	r1, r4, #1
57e0ae30:	e59f0074 	ldr	r0, [pc, #116]	; 57e0aeac <set_default_env+0x98>
57e0ae34:	ebfff984 	bl	57e0944c <printf>
	return ret_val;
}

void set_default_env(const char *s)
{
	int flags = 0;
57e0ae38:	e3a04000 	mov	r4, #0
57e0ae3c:	ea000004 	b	57e0ae54 <set_default_env+0x40>
			printf("*** Warning - %s, "
				"using default environment\n\n",
				s + 1);
		} else {
			flags = H_INTERACTIVE;
			puts(s);
57e0ae40:	ebfff977 	bl	57e09424 <puts>
		if (*s == '!') {
			printf("*** Warning - %s, "
				"using default environment\n\n",
				s + 1);
		} else {
			flags = H_INTERACTIVE;
57e0ae44:	e3a04004 	mov	r4, #4
57e0ae48:	ea000001 	b	57e0ae54 <set_default_env+0x40>
			puts(s);
		}
	} else {
		puts("Using default environment\n\n");
57e0ae4c:	e59f005c 	ldr	r0, [pc, #92]	; 57e0aeb0 <set_default_env+0x9c>
57e0ae50:	ebfff973 	bl	57e09424 <puts>
	}

	if (himport_r(&env_htab, (char *)default_environment,
57e0ae54:	e3a03000 	mov	r3, #0
57e0ae58:	e59f0054 	ldr	r0, [pc, #84]	; 57e0aeb4 <set_default_env+0xa0>
57e0ae5c:	e59f1054 	ldr	r1, [pc, #84]	; 57e0aeb8 <set_default_env+0xa4>
57e0ae60:	e3a0207c 	mov	r2, #124	; 0x7c
57e0ae64:	e58d4000 	str	r4, [sp]
57e0ae68:	e58d3004 	str	r3, [sp, #4]
57e0ae6c:	e58d3008 	str	r3, [sp, #8]
57e0ae70:	eb006140 	bl	57e23378 <himport_r>
57e0ae74:	e3500000 	cmp	r0, #0
57e0ae78:	1a000007 	bne	57e0ae9c <set_default_env+0x88>
			sizeof(default_environment), '\0', flags,
			0, NULL) == 0)
		error("Environment import failed: errno = %d\n", errno);
57e0ae7c:	e59f3038 	ldr	r3, [pc, #56]	; 57e0aebc <set_default_env+0xa8>
57e0ae80:	e59f0038 	ldr	r0, [pc, #56]	; 57e0aec0 <set_default_env+0xac>
57e0ae84:	e58d3000 	str	r3, [sp]
57e0ae88:	e59f3034 	ldr	r3, [pc, #52]	; 57e0aec4 <set_default_env+0xb0>
57e0ae8c:	e59f2034 	ldr	r2, [pc, #52]	; 57e0aec8 <set_default_env+0xb4>
57e0ae90:	e5931000 	ldr	r1, [r3]
57e0ae94:	e3a0308d 	mov	r3, #141	; 0x8d
57e0ae98:	ebfff96b 	bl	57e0944c <printf>

	gd->flags |= GD_FLG_ENV_READY;
57e0ae9c:	e5982004 	ldr	r2, [r8, #4]
57e0aea0:	e3822080 	orr	r2, r2, #128	; 0x80
57e0aea4:	e5882004 	str	r2, [r8, #4]
}
57e0aea8:	e8bd801f 	pop	{r0, r1, r2, r3, r4, pc}
57e0aeac:	57e31ef8 	.word	0x57e31ef8
57e0aeb0:	57e31f26 	.word	0x57e31f26
57e0aeb4:	57e36dc4 	.word	0x57e36dc4
57e0aeb8:	57e2be58 	.word	0x57e2be58
57e0aebc:	57e2bf50 	.word	0x57e2bf50
57e0aec0:	57e30e90 	.word	0x57e30e90
57e0aec4:	57e79098 	.word	0x57e79098
57e0aec8:	57e31f42 	.word	0x57e31f42

57e0aecc <set_default_vars>:


/* [re]set individual variables to their value in the default environment */
int set_default_vars(int nvars, char * const vars[])
{
57e0aecc:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	/*
	 * Special use-case: import from default environment
	 * (and use \0 as a separator)
	 */
	return himport_r(&env_htab, (const char *)default_environment,
57e0aed0:	e3a03005 	mov	r3, #5
57e0aed4:	e58d3000 	str	r3, [sp]
57e0aed8:	e98d0003 	stmib	sp, {r0, r1}
57e0aedc:	e3a0207c 	mov	r2, #124	; 0x7c
57e0aee0:	e59f1010 	ldr	r1, [pc, #16]	; 57e0aef8 <set_default_vars+0x2c>
57e0aee4:	e3a03000 	mov	r3, #0
57e0aee8:	e59f000c 	ldr	r0, [pc, #12]	; 57e0aefc <set_default_vars+0x30>
57e0aeec:	eb006121 	bl	57e23378 <himport_r>
				sizeof(default_environment), '\0',
				H_NOCLEAR | H_INTERACTIVE, nvars, vars);
}
57e0aef0:	e28dd014 	add	sp, sp, #20
57e0aef4:	e8bd8000 	pop	{pc}
57e0aef8:	57e2be58 	.word	0x57e2be58
57e0aefc:	57e36dc4 	.word	0x57e36dc4

57e0af00 <env_import>:
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
57e0af00:	e92d4010 	push	{r4, lr}
	env_t *ep = (env_t *)buf;

	if (check) {
57e0af04:	e3510000 	cmp	r1, #0
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
57e0af08:	e24dd018 	sub	sp, sp, #24
57e0af0c:	e1a04000 	mov	r4, r0
	env_t *ep = (env_t *)buf;

	if (check) {
57e0af10:	0a00000e 	beq	57e0af50 <env_import+0x50>
		uint32_t crc;

		memcpy(&crc, &ep->crc, sizeof(crc));
57e0af14:	e1a01004 	mov	r1, r4
57e0af18:	e3a02004 	mov	r2, #4
57e0af1c:	e28d0014 	add	r0, sp, #20
57e0af20:	eb0064f9 	bl	57e2430c <memcpy>

		if (crc32(0, ep->data, ENV_SIZE) != crc) {
57e0af24:	e3a00000 	mov	r0, #0
57e0af28:	e2841004 	add	r1, r4, #4
57e0af2c:	e59f2088 	ldr	r2, [pc, #136]	; 57e0afbc <env_import+0xbc>
57e0af30:	eb005cb6 	bl	57e22210 <crc32>
57e0af34:	e59d3014 	ldr	r3, [sp, #20]
57e0af38:	e1500003 	cmp	r0, r3
57e0af3c:	0a000003 	beq	57e0af50 <env_import+0x50>
			set_default_env("!bad CRC");
57e0af40:	e59f0078 	ldr	r0, [pc, #120]	; 57e0afc0 <env_import+0xc0>
57e0af44:	ebffffb2 	bl	57e0ae14 <set_default_env>
			return 0;
57e0af48:	e3a00000 	mov	r0, #0
57e0af4c:	ea000018 	b	57e0afb4 <env_import+0xb4>
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
57e0af50:	e3a03000 	mov	r3, #0
57e0af54:	e2841004 	add	r1, r4, #4
57e0af58:	e59f0064 	ldr	r0, [pc, #100]	; 57e0afc4 <env_import+0xc4>
57e0af5c:	e59f2058 	ldr	r2, [pc, #88]	; 57e0afbc <env_import+0xbc>
57e0af60:	e58d3000 	str	r3, [sp]
57e0af64:	e58d3004 	str	r3, [sp, #4]
57e0af68:	e58d3008 	str	r3, [sp, #8]
57e0af6c:	eb006101 	bl	57e23378 <himport_r>
57e0af70:	e2504000 	subs	r4, r0, #0
			0, NULL)) {
		gd->flags |= GD_FLG_ENV_READY;
57e0af74:	15982004 	ldrne	r2, [r8, #4]
		return 1;
57e0af78:	13a00001 	movne	r0, #1
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
			0, NULL)) {
		gd->flags |= GD_FLG_ENV_READY;
57e0af7c:	13822080 	orrne	r2, r2, #128	; 0x80
57e0af80:	15882004 	strne	r2, [r8, #4]
		return 1;
57e0af84:	1a00000a 	bne	57e0afb4 <env_import+0xb4>
	}

	error("Cannot import environment: errno = %d\n", errno);
57e0af88:	e59f3038 	ldr	r3, [pc, #56]	; 57e0afc8 <env_import+0xc8>
57e0af8c:	e59f2038 	ldr	r2, [pc, #56]	; 57e0afcc <env_import+0xcc>
57e0af90:	e58d3000 	str	r3, [sp]
57e0af94:	e59f3034 	ldr	r3, [pc, #52]	; 57e0afd0 <env_import+0xd0>
57e0af98:	e59f0034 	ldr	r0, [pc, #52]	; 57e0afd4 <env_import+0xd4>
57e0af9c:	e5931000 	ldr	r1, [r3]
57e0afa0:	e3a030b9 	mov	r3, #185	; 0xb9
57e0afa4:	ebfff928 	bl	57e0944c <printf>

	set_default_env("!import failed");
57e0afa8:	e59f0028 	ldr	r0, [pc, #40]	; 57e0afd8 <env_import+0xd8>
57e0afac:	ebffff98 	bl	57e0ae14 <set_default_env>

	return 0;
57e0afb0:	e1a00004 	mov	r0, r4
}
57e0afb4:	e28dd018 	add	sp, sp, #24
57e0afb8:	e8bd8010 	pop	{r4, pc}
57e0afbc:	00003ffc 	.word	0x00003ffc
57e0afc0:	57e31f4f 	.word	0x57e31f4f
57e0afc4:	57e36dc4 	.word	0x57e36dc4
57e0afc8:	57e2bf60 	.word	0x57e2bf60
57e0afcc:	57e31f42 	.word	0x57e31f42
57e0afd0:	57e79098 	.word	0x57e79098
57e0afd4:	57e31f58 	.word	0x57e31f58
57e0afd8:	57e31f95 	.word	0x57e31f95

57e0afdc <env_relocate>:
{
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
	env_reloc();
	env_htab.change_ok += gd->reloc_off;
#endif
	if (gd->env_valid == 0) {
57e0afdc:	e5983014 	ldr	r3, [r8, #20]
	return 0;
}
#endif

void env_relocate(void)
{
57e0afe0:	e92d4010 	push	{r4, lr}
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
	env_reloc();
	env_htab.change_ok += gd->reloc_off;
#endif
	if (gd->env_valid == 0) {
57e0afe4:	e3530000 	cmp	r3, #0
57e0afe8:	1a000004 	bne	57e0b000 <env_relocate+0x24>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e0afec:	e3e0003b 	mvn	r0, #59	; 0x3b
57e0aff0:	eb000e5b 	bl	57e0e964 <__show_boot_progress>
#if defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)
		/* Environment not changable */
		set_default_env(NULL);
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
57e0aff4:	e59f000c 	ldr	r0, [pc, #12]	; 57e0b008 <env_relocate+0x2c>
#endif
	} else {
		env_relocate_spec();
	}
}
57e0aff8:	e8bd4010 	pop	{r4, lr}
#if defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)
		/* Environment not changable */
		set_default_env(NULL);
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
57e0affc:	eaffff84 	b	57e0ae14 <set_default_env>
#endif
	} else {
		env_relocate_spec();
	}
}
57e0b000:	e8bd4010 	pop	{r4, lr}
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
#endif
	} else {
		env_relocate_spec();
57e0b004:	ea00025a 	b	57e0b974 <env_relocate_spec>
57e0b008:	57e31f4f 	.word	0x57e31f4f

57e0b00c <skip_num>:
static void skip_num(int hex, const char *value, const char **end,
	int max_digits)
{
	int i;

	if (hex && is_hex_prefix(value))
57e0b00c:	e3500000 	cmp	r0, #0
	return value[0] == '0' && (value[1] == 'x' || value[1] == 'X');
}

static void skip_num(int hex, const char *value, const char **end,
	int max_digits)
{
57e0b010:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	if (hex && is_hex_prefix(value))
57e0b014:	0a000006 	beq	57e0b034 <skip_num+0x28>
	return env_flags_varaccess_any;
}

static inline int is_hex_prefix(const char *value)
{
	return value[0] == '0' && (value[1] == 'x' || value[1] == 'X');
57e0b018:	e5d1c000 	ldrb	ip, [r1]
57e0b01c:	e35c0030 	cmp	ip, #48	; 0x30
57e0b020:	1a000003 	bne	57e0b034 <skip_num+0x28>
57e0b024:	e5d1c001 	ldrb	ip, [r1, #1]
57e0b028:	e35c0078 	cmp	ip, #120	; 0x78
57e0b02c:	135c0058 	cmpne	ip, #88	; 0x58
	int max_digits)
{
	int i;

	if (hex && is_hex_prefix(value))
		value += 2;
57e0b030:	02811002 	addeq	r1, r1, #2
	return value[0] == '0' && (value[1] == 'x' || value[1] == 'X');
}

static void skip_num(int hex, const char *value, const char **end,
	int max_digits)
{
57e0b034:	e3a0c000 	mov	ip, #0
57e0b038:	e59f4040 	ldr	r4, [pc, #64]	; 57e0b080 <skip_num+0x74>
57e0b03c:	ea000009 	b	57e0b068 <skip_num+0x5c>

	if (hex && is_hex_prefix(value))
		value += 2;

	for (i = max_digits; i != 0; i--) {
		if (hex && !isxdigit(*value))
57e0b040:	e3500000 	cmp	r0, #0
57e0b044:	e7d1500c 	ldrb	r5, [r1, ip]
57e0b048:	0a000002 	beq	57e0b058 <skip_num+0x4c>
57e0b04c:	e7d45005 	ldrb	r5, [r4, r5]
57e0b050:	e3150044 	tst	r5, #68	; 0x44
57e0b054:	ea000001 	b	57e0b060 <skip_num+0x54>
			break;
		if (!hex && !isdigit(*value))
57e0b058:	e7d45005 	ldrb	r5, [r4, r5]
57e0b05c:	e3150004 	tst	r5, #4
57e0b060:	0a000003 	beq	57e0b074 <skip_num+0x68>
57e0b064:	e28cc001 	add	ip, ip, #1
	int i;

	if (hex && is_hex_prefix(value))
		value += 2;

	for (i = max_digits; i != 0; i--) {
57e0b068:	e153000c 	cmp	r3, ip
static inline int is_hex_prefix(const char *value)
{
	return value[0] == '0' && (value[1] == 'x' || value[1] == 'X');
}

static void skip_num(int hex, const char *value, const char **end,
57e0b06c:	e081600c 	add	r6, r1, ip
	int i;

	if (hex && is_hex_prefix(value))
		value += 2;

	for (i = max_digits; i != 0; i--) {
57e0b070:	1afffff2 	bne	57e0b040 <skip_num+0x34>
			break;
		if (!hex && !isdigit(*value))
			break;
		value++;
	}
	if (end != NULL)
57e0b074:	e3520000 	cmp	r2, #0
		*end = value;
57e0b078:	15826000 	strne	r6, [r2]
57e0b07c:	e8bd8070 	pop	{r4, r5, r6, pc}
57e0b080:	57e2d4d0 	.word	0x57e2d4d0

57e0b084 <clear_flags>:
 * Called on each existing env var prior to the blanket update since removing
 * a flag in the flag list should remove its flags.
 */
static int clear_flags(ENTRY *entry)
{
	entry->flags = 0;
57e0b084:	e3a03000 	mov	r3, #0
57e0b088:	e580300c 	str	r3, [r0, #12]

	return 0;
}
57e0b08c:	e1a00003 	mov	r0, r3
57e0b090:	e12fff1e 	bx	lr

57e0b094 <on_flags>:
	return 0;
}

static int on_flags(const char *name, const char *value, enum env_op op,
	int flags)
{
57e0b094:	e92d4038 	push	{r3, r4, r5, lr}
	/* remove all flags */
	hwalk_r(&env_htab, clear_flags);

	/* configure any static flags */
	env_attr_walk(ENV_FLAGS_LIST_STATIC, set_flags);
57e0b098:	e59f402c 	ldr	r4, [pc, #44]	; 57e0b0cc <on_flags+0x38>
	return 0;
}

static int on_flags(const char *name, const char *value, enum env_op op,
	int flags)
{
57e0b09c:	e1a05001 	mov	r5, r1
	/* remove all flags */
	hwalk_r(&env_htab, clear_flags);
57e0b0a0:	e59f0028 	ldr	r0, [pc, #40]	; 57e0b0d0 <on_flags+0x3c>
57e0b0a4:	e59f1028 	ldr	r1, [pc, #40]	; 57e0b0d4 <on_flags+0x40>
57e0b0a8:	eb006176 	bl	57e23688 <hwalk_r>

	/* configure any static flags */
	env_attr_walk(ENV_FLAGS_LIST_STATIC, set_flags);
57e0b0ac:	e1a01004 	mov	r1, r4
57e0b0b0:	e59f0020 	ldr	r0, [pc, #32]	; 57e0b0d8 <on_flags+0x44>
57e0b0b4:	ebfffe0f 	bl	57e0a8f8 <env_attr_walk>
	/* configure any dynamic flags */
	env_attr_walk(value, set_flags);
57e0b0b8:	e1a00005 	mov	r0, r5
57e0b0bc:	e1a01004 	mov	r1, r4
57e0b0c0:	ebfffe0c 	bl	57e0a8f8 <env_attr_walk>

	return 0;
}
57e0b0c4:	e3a00000 	mov	r0, #0
57e0b0c8:	e8bd8038 	pop	{r3, r4, r5, pc}
57e0b0cc:	57e0b1ac 	.word	0x57e0b1ac
57e0b0d0:	57e36dc4 	.word	0x57e36dc4
57e0b0d4:	57e0b084 	.word	0x57e0b084
57e0b0d8:	57e31fa4 	.word	0x57e31fa4

57e0b0dc <env_flags_parse_vartype>:

/*
 * Parse the flags string from a .flags attribute list into the vartype enum.
 */
enum env_flags_vartype env_flags_parse_vartype(const char *flags)
{
57e0b0dc:	e92d4070 	push	{r4, r5, r6, lr}
57e0b0e0:	e1a05000 	mov	r5, r0
	char *type;

	if (strlen(flags) <= ENV_FLAGS_VARTYPE_LOC)
57e0b0e4:	eb0063d9 	bl	57e24050 <strlen>
57e0b0e8:	e3500000 	cmp	r0, #0
57e0b0ec:	08bd8070 	popeq	{r4, r5, r6, pc}
		return env_flags_vartype_string;

	type = strchr(env_flags_vartype_rep,
57e0b0f0:	e59f6028 	ldr	r6, [pc, #40]	; 57e0b120 <env_flags_parse_vartype+0x44>
57e0b0f4:	e5d51000 	ldrb	r1, [r5]
57e0b0f8:	e1a00006 	mov	r0, r6
57e0b0fc:	eb0063c6 	bl	57e2401c <strchr>
		flags[ENV_FLAGS_VARTYPE_LOC]);

	if (type != NULL)
57e0b100:	e2504000 	subs	r4, r0, #0
		return (enum env_flags_vartype)
			(type - &env_flags_vartype_rep[0]);
57e0b104:	10660004 	rsbne	r0, r6, r4
		return env_flags_vartype_string;

	type = strchr(env_flags_vartype_rep,
		flags[ENV_FLAGS_VARTYPE_LOC]);

	if (type != NULL)
57e0b108:	18bd8070 	popne	{r4, r5, r6, pc}
		return (enum env_flags_vartype)
			(type - &env_flags_vartype_rep[0]);

	printf("## Warning: Unknown environment variable type '%c'\n",
57e0b10c:	e5d51000 	ldrb	r1, [r5]
57e0b110:	e59f000c 	ldr	r0, [pc, #12]	; 57e0b124 <env_flags_parse_vartype+0x48>
57e0b114:	ebfff8cc 	bl	57e0944c <printf>
		flags[ENV_FLAGS_VARTYPE_LOC]);
	return env_flags_vartype_string;
57e0b118:	e1a00004 	mov	r0, r4
}
57e0b11c:	e8bd8070 	pop	{r4, r5, r6, pc}
57e0b120:	57e2bf6c 	.word	0x57e2bf6c
57e0b124:	57e31fb0 	.word	0x57e31fb0

57e0b128 <env_flags_parse_varaccess>:

/*
 * Parse the flags string from a .flags attribute list into the varaccess enum.
 */
enum env_flags_varaccess env_flags_parse_varaccess(const char *flags)
{
57e0b128:	e92d4070 	push	{r4, r5, r6, lr}
57e0b12c:	e1a05000 	mov	r5, r0
	char *access;

	if (strlen(flags) <= ENV_FLAGS_VARACCESS_LOC)
57e0b130:	eb0063c6 	bl	57e24050 <strlen>
57e0b134:	e3500001 	cmp	r0, #1
57e0b138:	9a00000b 	bls	57e0b16c <env_flags_parse_varaccess+0x44>
		return env_flags_varaccess_any;

	access = strchr(env_flags_varaccess_rep,
57e0b13c:	e59f6030 	ldr	r6, [pc, #48]	; 57e0b174 <env_flags_parse_varaccess+0x4c>
57e0b140:	e5d51001 	ldrb	r1, [r5, #1]
57e0b144:	e1a00006 	mov	r0, r6
57e0b148:	eb0063b3 	bl	57e2401c <strchr>
		flags[ENV_FLAGS_VARACCESS_LOC]);

	if (access != NULL)
57e0b14c:	e2504000 	subs	r4, r0, #0
		return (enum env_flags_varaccess)
			(access - &env_flags_varaccess_rep[0]);
57e0b150:	10660004 	rsbne	r0, r6, r4
		return env_flags_varaccess_any;

	access = strchr(env_flags_varaccess_rep,
		flags[ENV_FLAGS_VARACCESS_LOC]);

	if (access != NULL)
57e0b154:	18bd8070 	popne	{r4, r5, r6, pc}
		return (enum env_flags_varaccess)
			(access - &env_flags_varaccess_rep[0]);

	printf("## Warning: Unknown environment variable access method '%c'\n",
57e0b158:	e59f0018 	ldr	r0, [pc, #24]	; 57e0b178 <env_flags_parse_varaccess+0x50>
57e0b15c:	e5d51001 	ldrb	r1, [r5, #1]
57e0b160:	ebfff8b9 	bl	57e0944c <printf>
		flags[ENV_FLAGS_VARACCESS_LOC]);
	return env_flags_varaccess_any;
57e0b164:	e1a00004 	mov	r0, r4
57e0b168:	e8bd8070 	pop	{r4, r5, r6, pc}
enum env_flags_varaccess env_flags_parse_varaccess(const char *flags)
{
	char *access;

	if (strlen(flags) <= ENV_FLAGS_VARACCESS_LOC)
		return env_flags_varaccess_any;
57e0b16c:	e3a00000 	mov	r0, #0
			(access - &env_flags_varaccess_rep[0]);

	printf("## Warning: Unknown environment variable access method '%c'\n",
		flags[ENV_FLAGS_VARACCESS_LOC]);
	return env_flags_varaccess_any;
}
57e0b170:	e8bd8070 	pop	{r4, r5, r6, pc}
57e0b174:	57e2bf74 	.word	0x57e2bf74
57e0b178:	57e31fe4 	.word	0x57e31fe4

57e0b17c <env_parse_flags_to_bin>:
/*
 * Parse the flag charachters from the .flags attribute list into the binary
 * form to be stored in the environment entry->flags field.
 */
static int env_parse_flags_to_bin(const char *flags)
{
57e0b17c:	e92d4038 	push	{r3, r4, r5, lr}
57e0b180:	e1a05000 	mov	r5, r0
	int binflags;

	binflags = env_flags_parse_vartype(flags) & ENV_FLAGS_VARTYPE_BIN_MASK;
57e0b184:	ebffffd4 	bl	57e0b0dc <env_flags_parse_vartype>
57e0b188:	e2004007 	and	r4, r0, #7
	binflags |= env_flags_varaccess_mask[env_flags_parse_varaccess(flags)];
57e0b18c:	e1a00005 	mov	r0, r5
57e0b190:	ebffffe4 	bl	57e0b128 <env_flags_parse_varaccess>
57e0b194:	e59f300c 	ldr	r3, [pc, #12]	; 57e0b1a8 <env_parse_flags_to_bin+0x2c>
57e0b198:	e0833100 	add	r3, r3, r0, lsl #2
57e0b19c:	e5930010 	ldr	r0, [r3, #16]

	return binflags;
}
57e0b1a0:	e1840000 	orr	r0, r4, r0
57e0b1a4:	e8bd8038 	pop	{r3, r4, r5, pc}
57e0b1a8:	57e2bf6c 	.word	0x57e2bf6c

57e0b1ac <set_flags>:

/*
 * Call for each element in the list that defines flags for a variable
 */
static int set_flags(const char *name, const char *value)
{
57e0b1ac:	e92d4030 	push	{r4, r5, lr}
57e0b1b0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	ENTRY e, *ep;

	e.key	= name;
	e.data	= NULL;
	hsearch_r(e, FIND, &ep, &env_htab, 0);
57e0b1b4:	e28d2024 	add	r2, sp, #36	; 0x24
57e0b1b8:	e58d2004 	str	r2, [sp, #4]
57e0b1bc:	e59f2074 	ldr	r2, [pc, #116]	; 57e0b238 <set_flags+0x8c>
static int set_flags(const char *name, const char *value)
{
	ENTRY e, *ep;

	e.key	= name;
	e.data	= NULL;
57e0b1c0:	e3a03000 	mov	r3, #0
57e0b1c4:	e58d3018 	str	r3, [sp, #24]
	hsearch_r(e, FIND, &ep, &env_htab, 0);
57e0b1c8:	e58d3000 	str	r3, [sp]
57e0b1cc:	e58d300c 	str	r3, [sp, #12]
 */
static int set_flags(const char *name, const char *value)
{
	ENTRY e, *ep;

	e.key	= name;
57e0b1d0:	e58d0014 	str	r0, [sp, #20]
	e.data	= NULL;
	hsearch_r(e, FIND, &ep, &env_htab, 0);
57e0b1d4:	e58d2008 	str	r2, [sp, #8]
57e0b1d8:	e28d3014 	add	r3, sp, #20

/*
 * Call for each element in the list that defines flags for a variable
 */
static int set_flags(const char *name, const char *value)
{
57e0b1dc:	e1a04001 	mov	r4, r1
	ENTRY e, *ep;

	e.key	= name;
	e.data	= NULL;
	hsearch_r(e, FIND, &ep, &env_htab, 0);
57e0b1e0:	e893000f 	ldm	r3, {r0, r1, r2, r3}
57e0b1e4:	eb005e2f 	bl	57e22aa8 <hsearch_r>

	/* does the env variable actually exist? */
	if (ep != NULL) {
57e0b1e8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e0b1ec:	e3530000 	cmp	r3, #0
57e0b1f0:	0a00000d 	beq	57e0b22c <set_flags+0x80>
		/* the flag list is empty, so clear the flags */
		if (value == NULL || strlen(value) == 0)
57e0b1f4:	e3540000 	cmp	r4, #0
57e0b1f8:	0a000003 	beq	57e0b20c <set_flags+0x60>
57e0b1fc:	e1a00004 	mov	r0, r4
57e0b200:	eb006392 	bl	57e24050 <strlen>
57e0b204:	e3500000 	cmp	r0, #0
57e0b208:	1a000003 	bne	57e0b21c <set_flags+0x70>
			ep->flags = 0;
57e0b20c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e0b210:	e3a02000 	mov	r2, #0
57e0b214:	e583200c 	str	r2, [r3, #12]
57e0b218:	ea000003 	b	57e0b22c <set_flags+0x80>
		else
			/* assign the requested flags */
			ep->flags = env_parse_flags_to_bin(value);
57e0b21c:	e1a00004 	mov	r0, r4
57e0b220:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
57e0b224:	ebffffd4 	bl	57e0b17c <env_parse_flags_to_bin>
57e0b228:	e585000c 	str	r0, [r5, #12]
	}

	return 0;
}
57e0b22c:	e3a00000 	mov	r0, #0
57e0b230:	e28dd02c 	add	sp, sp, #44	; 0x2c
57e0b234:	e8bd8030 	pop	{r4, r5, pc}
57e0b238:	57e36dc4 	.word	0x57e36dc4

57e0b23c <env_flags_parse_varaccess_from_binflags>:

/*
 * Parse the binary flags from a hash table entry into the varaccess enum.
 */
enum env_flags_varaccess env_flags_parse_varaccess_from_binflags(int binflags)
{
57e0b23c:	e92d4008 	push	{r3, lr}
			return (enum env_flags_varaccess)i;

	printf("Warning: Non-standard access flags. (0x%x)\n",
		binflags & ENV_FLAGS_VARACCESS_BIN_MASK);

	return env_flags_varaccess_any;
57e0b240:	e59f2034 	ldr	r2, [pc, #52]	; 57e0b27c <env_flags_parse_varaccess_from_binflags+0x40>
 */
enum env_flags_varaccess env_flags_parse_varaccess_from_binflags(int binflags)
{
	int i;

	for (i = 0; i < sizeof(env_flags_varaccess_mask); i++)
57e0b244:	e3a03000 	mov	r3, #0
57e0b248:	e2001078 	and	r1, r0, #120	; 0x78
57e0b24c:	ea000003 	b	57e0b260 <env_flags_parse_varaccess_from_binflags+0x24>
		if (env_flags_varaccess_mask[i] ==
57e0b250:	e5b2c004 	ldr	ip, [r2, #4]!
57e0b254:	e15c0001 	cmp	ip, r1
57e0b258:	08bd8008 	popeq	{r3, pc}
 */
enum env_flags_varaccess env_flags_parse_varaccess_from_binflags(int binflags)
{
	int i;

	for (i = 0; i < sizeof(env_flags_varaccess_mask); i++)
57e0b25c:	e2833001 	add	r3, r3, #1
57e0b260:	e3530010 	cmp	r3, #16
57e0b264:	e1a00003 	mov	r0, r3
57e0b268:	1afffff8 	bne	57e0b250 <env_flags_parse_varaccess_from_binflags+0x14>
		if (env_flags_varaccess_mask[i] ==
		    (binflags & ENV_FLAGS_VARACCESS_BIN_MASK))
			return (enum env_flags_varaccess)i;

	printf("Warning: Non-standard access flags. (0x%x)\n",
57e0b26c:	e59f000c 	ldr	r0, [pc, #12]	; 57e0b280 <env_flags_parse_varaccess_from_binflags+0x44>
57e0b270:	ebfff875 	bl	57e0944c <printf>
		binflags & ENV_FLAGS_VARACCESS_BIN_MASK);

	return env_flags_varaccess_any;
57e0b274:	e3a00000 	mov	r0, #0
}
57e0b278:	e8bd8008 	pop	{r3, pc}
57e0b27c:	57e2bf78 	.word	0x57e2bf78
57e0b280:	57e32021 	.word	0x57e32021

57e0b284 <env_flags_init>:
 * Look for possible flags for a newly added variable
 * This is called specifically when the variable did not exist in the hash
 * previously, so the blanket update did not find this variable.
 */
void env_flags_init(ENTRY *var_entry)
{
57e0b284:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	const char *var_name = var_entry->key;
57e0b288:	e5905000 	ldr	r5, [r0]
 * Look for possible flags for a newly added variable
 * This is called specifically when the variable did not exist in the hash
 * previously, so the blanket update did not find this variable.
 */
void env_flags_init(ENTRY *var_entry)
{
57e0b28c:	e1a04000 	mov	r4, r0
	const char *var_name = var_entry->key;
	const char *flags_list = getenv(ENV_FLAGS_VAR);
57e0b290:	e59f0070 	ldr	r0, [pc, #112]	; 57e0b308 <env_flags_init+0x84>
57e0b294:	ebfff113 	bl	57e076e8 <getenv>
	char flags[ENV_FLAGS_ATTR_MAX_LEN + 1] = "";
57e0b298:	e59f306c 	ldr	r3, [pc, #108]	; 57e0b30c <env_flags_init+0x88>
57e0b29c:	e5d33020 	ldrb	r3, [r3, #32]
57e0b2a0:	e5cd3004 	strb	r3, [sp, #4]
57e0b2a4:	e3a03000 	mov	r3, #0
	if (!flags)
		/* bad parameter */
		return -1;

	/* try the env first */
	if (flags_list)
57e0b2a8:	e1500003 	cmp	r0, r3
 */
void env_flags_init(ENTRY *var_entry)
{
	const char *var_name = var_entry->key;
	const char *flags_list = getenv(ENV_FLAGS_VAR);
	char flags[ENV_FLAGS_ATTR_MAX_LEN + 1] = "";
57e0b2ac:	e5cd3005 	strb	r3, [sp, #5]
57e0b2b0:	e5cd3006 	strb	r3, [sp, #6]
	if (!flags)
		/* bad parameter */
		return -1;

	/* try the env first */
	if (flags_list)
57e0b2b4:	0a000004 	beq	57e0b2cc <env_flags_init+0x48>
		ret = env_attr_lookup(flags_list, name, flags);
57e0b2b8:	e1a01005 	mov	r1, r5
57e0b2bc:	e28d2004 	add	r2, sp, #4
57e0b2c0:	ebfffdd0 	bl	57e0aa08 <env_attr_lookup>

	if (ret != 0)
57e0b2c4:	e3500000 	cmp	r0, #0
57e0b2c8:	0a000005 	beq	57e0b2e4 <env_flags_init+0x60>
		/* if not found in the env, look in the static list */
		ret = env_attr_lookup(ENV_FLAGS_LIST_STATIC, name, flags);
57e0b2cc:	e59f003c 	ldr	r0, [pc, #60]	; 57e0b310 <env_flags_init+0x8c>
57e0b2d0:	e1a01005 	mov	r1, r5
57e0b2d4:	e28d2004 	add	r2, sp, #4
57e0b2d8:	ebfffdca 	bl	57e0aa08 <env_attr_lookup>

	/* look in the ".flags" and static for a reference to this variable */
	ret = env_flags_lookup(flags_list, var_name, flags);

	/* if any flags were found, set the binary form to the entry */
	if (!ret && strlen(flags))
57e0b2dc:	e3500000 	cmp	r0, #0
57e0b2e0:	1a000007 	bne	57e0b304 <env_flags_init+0x80>
57e0b2e4:	e28d5004 	add	r5, sp, #4
57e0b2e8:	e1a00005 	mov	r0, r5
57e0b2ec:	eb006357 	bl	57e24050 <strlen>
57e0b2f0:	e3500000 	cmp	r0, #0
57e0b2f4:	0a000002 	beq	57e0b304 <env_flags_init+0x80>
		var_entry->flags = env_parse_flags_to_bin(flags);
57e0b2f8:	e1a00005 	mov	r0, r5
57e0b2fc:	ebffff9e 	bl	57e0b17c <env_parse_flags_to_bin>
57e0b300:	e584000c 	str	r0, [r4, #12]
}
57e0b304:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
57e0b308:	57e3204d 	.word	0x57e3204d
57e0b30c:	57e2bf6c 	.word	0x57e2bf6c
57e0b310:	57e31fa4 	.word	0x57e31fa4

57e0b314 <env_flags_validate>:
 * overwriting of write-once variables.
 */

int env_flags_validate(const ENTRY *item, const char *newval, enum env_op op,
	int flag)
{
57e0b314:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e0b318:	e24dd018 	sub	sp, sp, #24
	const char *name;
	const char *oldval = NULL;

	if (op != env_op_create)
57e0b31c:	e252a000 	subs	sl, r2, #0
 * overwriting of write-once variables.
 */

int env_flags_validate(const ENTRY *item, const char *newval, enum env_op op,
	int flag)
{
57e0b320:	e58d300c 	str	r3, [sp, #12]
		oldval = item->data;

	name = item->key;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
57e0b324:	e59f3300 	ldr	r3, [pc, #768]	; 57e0b62c <env_flags_validate+0x318>
{
	const char *name;
	const char *oldval = NULL;

	if (op != env_op_create)
		oldval = item->data;
57e0b328:	1590b004 	ldrne	fp, [r0, #4]

int env_flags_validate(const ENTRY *item, const char *newval, enum env_op op,
	int flag)
{
	const char *name;
	const char *oldval = NULL;
57e0b32c:	01a0b00a 	moveq	fp, sl
		oldval = item->data;

	name = item->key;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
57e0b330:	e3510000 	cmp	r1, #0
 * overwriting of write-once variables.
 */

int env_flags_validate(const ENTRY *item, const char *newval, enum env_op op,
	int flag)
{
57e0b334:	e1a04001 	mov	r4, r1
		oldval = item->data;

	name = item->key;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
57e0b338:	01a04003 	moveq	r4, r3

	/* validate the value to match the variable type */
	if (op != env_op_delete) {
57e0b33c:	e35a0001 	cmp	sl, #1
 * overwriting of write-once variables.
 */

int env_flags_validate(const ENTRY *item, const char *newval, enum env_op op,
	int flag)
{
57e0b340:	e1a05000 	mov	r5, r0
	const char *oldval = NULL;

	if (op != env_op_create)
		oldval = item->data;

	name = item->key;
57e0b344:	e5907000 	ldr	r7, [r0]

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";

	/* validate the value to match the variable type */
	if (op != env_op_delete) {
57e0b348:	0a000087 	beq	57e0b56c <env_flags_validate+0x258>
		enum env_flags_vartype type = (enum env_flags_vartype)
			(ENV_FLAGS_VARTYPE_BIN_MASK & item->flags);
57e0b34c:	e590300c 	ldr	r3, [r0, #12]
57e0b350:	e2033007 	and	r3, r3, #7
57e0b354:	e58d3008 	str	r3, [sp, #8]
#ifdef CONFIG_CMD_NET
	const char *cur;
	int i;
#endif

	switch (type) {
57e0b358:	e2433001 	sub	r3, r3, #1
57e0b35c:	e3530005 	cmp	r3, #5
57e0b360:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e0b364:	ea000080 	b	57e0b56c <env_flags_validate+0x258>
57e0b368:	57e0b3a0 	.word	0x57e0b3a0
57e0b36c:	57e0b3c0 	.word	0x57e0b3c0
57e0b370:	57e0b410 	.word	0x57e0b410
57e0b374:	57e0b390 	.word	0x57e0b390
57e0b378:	57e0b380 	.word	0x57e0b380
57e0b37c:	57e0b548 	.word	0x57e0b548
57e0b380:	e1a06004 	mov	r6, r4
57e0b384:	e3a09000 	mov	r9, #0
		}
		break;
	case env_flags_vartype_macaddr:
		cur = value;
		for (i = 0; i < 6; i++) {
			skip_num(1, cur, &end, 2);
57e0b388:	e28dc014 	add	ip, sp, #20
57e0b38c:	ea00004d 	b	57e0b4c8 <env_flags_validate+0x1b4>
#ifdef CONFIG_CMD_NET
	const char *cur;
	int i;
#endif

	switch (type) {
57e0b390:	e1a09004 	mov	r9, r4
57e0b394:	e3a06000 	mov	r6, #0
		break;
#ifdef CONFIG_CMD_NET
	case env_flags_vartype_ipaddr:
		cur = value;
		for (i = 0; i < 4; i++) {
			skip_num(0, cur, &end, 3);
57e0b398:	e28dc014 	add	ip, sp, #20
57e0b39c:	ea000033 	b	57e0b470 <env_flags_validate+0x15c>

	switch (type) {
	case env_flags_vartype_string:
		break;
	case env_flags_vartype_decimal:
		skip_num(0, value, &end, -1);
57e0b3a0:	e3e03000 	mvn	r3, #0
57e0b3a4:	e3a00000 	mov	r0, #0
57e0b3a8:	e1a01004 	mov	r1, r4
57e0b3ac:	e28d2014 	add	r2, sp, #20
57e0b3b0:	ebffff15 	bl	57e0b00c <skip_num>
		if (*end != '\0')
57e0b3b4:	e59d3014 	ldr	r3, [sp, #20]
57e0b3b8:	e5d33000 	ldrb	r3, [r3]
57e0b3bc:	ea000028 	b	57e0b464 <env_flags_validate+0x150>
			return -1;
		break;
	case env_flags_vartype_hex:
		skip_num(1, value, &end, -1);
57e0b3c0:	e28d2014 	add	r2, sp, #20
57e0b3c4:	e3e03000 	mvn	r3, #0
57e0b3c8:	e3a00001 	mov	r0, #1
57e0b3cc:	e1a01004 	mov	r1, r4
57e0b3d0:	ebffff0d 	bl	57e0b00c <skip_num>
		if (*end != '\0')
57e0b3d4:	e59d3014 	ldr	r3, [sp, #20]
57e0b3d8:	e5d32000 	ldrb	r2, [r3]
57e0b3dc:	e3520000 	cmp	r2, #0
57e0b3e0:	1a000058 	bne	57e0b548 <env_flags_validate+0x234>
			return -1;
		if (value + 2 == end && is_hex_prefix(value))
57e0b3e4:	e2842002 	add	r2, r4, #2
57e0b3e8:	e1530002 	cmp	r3, r2
57e0b3ec:	1a00005e 	bne	57e0b56c <env_flags_validate+0x258>
	return env_flags_varaccess_any;
}

static inline int is_hex_prefix(const char *value)
{
	return value[0] == '0' && (value[1] == 'x' || value[1] == 'X');
57e0b3f0:	e5d43000 	ldrb	r3, [r4]
57e0b3f4:	e3530030 	cmp	r3, #48	; 0x30
57e0b3f8:	1a00005b 	bne	57e0b56c <env_flags_validate+0x258>
57e0b3fc:	e5d43001 	ldrb	r3, [r4, #1]
57e0b400:	e3530078 	cmp	r3, #120	; 0x78
57e0b404:	13530058 	cmpne	r3, #88	; 0x58
57e0b408:	0a00004e 	beq	57e0b548 <env_flags_validate+0x234>
57e0b40c:	ea000056 	b	57e0b56c <env_flags_validate+0x258>
			return -1;
		if (value + 2 == end && is_hex_prefix(value))
			return -1;
		break;
	case env_flags_vartype_bool:
		if (value[0] != '1' && value[0] != 'y' && value[0] != 't' &&
57e0b410:	e5d43000 	ldrb	r3, [r4]
57e0b414:	e3530079 	cmp	r3, #121	; 0x79
57e0b418:	13530031 	cmpne	r3, #49	; 0x31
57e0b41c:	0a00000f 	beq	57e0b460 <env_flags_validate+0x14c>
57e0b420:	e3530074 	cmp	r3, #116	; 0x74
57e0b424:	0a00000d 	beq	57e0b460 <env_flags_validate+0x14c>
57e0b428:	e3530059 	cmp	r3, #89	; 0x59
57e0b42c:	0a00000b 	beq	57e0b460 <env_flags_validate+0x14c>
		    value[0] != 'Y' && value[0] != 'T' &&
57e0b430:	e3530054 	cmp	r3, #84	; 0x54
57e0b434:	0a000009 	beq	57e0b460 <env_flags_validate+0x14c>
57e0b438:	e3530030 	cmp	r3, #48	; 0x30
57e0b43c:	0a000007 	beq	57e0b460 <env_flags_validate+0x14c>
		    value[0] != '0' && value[0] != 'n' && value[0] != 'f' &&
57e0b440:	e353006e 	cmp	r3, #110	; 0x6e
57e0b444:	0a000005 	beq	57e0b460 <env_flags_validate+0x14c>
57e0b448:	e3530066 	cmp	r3, #102	; 0x66
57e0b44c:	0a000003 	beq	57e0b460 <env_flags_validate+0x14c>
57e0b450:	e353004e 	cmp	r3, #78	; 0x4e
57e0b454:	0a000001 	beq	57e0b460 <env_flags_validate+0x14c>
		    value[0] != 'N' && value[0] != 'F')
57e0b458:	e3530046 	cmp	r3, #70	; 0x46
57e0b45c:	1a000039 	bne	57e0b548 <env_flags_validate+0x234>
			return -1;
		if (value[1] != '\0')
57e0b460:	e5d43001 	ldrb	r3, [r4, #1]
57e0b464:	e3530000 	cmp	r3, #0
57e0b468:	0a00003f 	beq	57e0b56c <env_flags_validate+0x258>
57e0b46c:	ea000035 	b	57e0b548 <env_flags_validate+0x234>
		break;
#ifdef CONFIG_CMD_NET
	case env_flags_vartype_ipaddr:
		cur = value;
		for (i = 0; i < 4; i++) {
			skip_num(0, cur, &end, 3);
57e0b470:	e1a0200c 	mov	r2, ip
57e0b474:	e3a03003 	mov	r3, #3
57e0b478:	e3a00000 	mov	r0, #0
57e0b47c:	e1a01009 	mov	r1, r9
57e0b480:	e58dc004 	str	ip, [sp, #4]
57e0b484:	ebfffee0 	bl	57e0b00c <skip_num>
			if (cur == end)
57e0b488:	e59d3014 	ldr	r3, [sp, #20]
57e0b48c:	e59dc004 	ldr	ip, [sp, #4]
57e0b490:	e1590003 	cmp	r9, r3
57e0b494:	0a00002b 	beq	57e0b548 <env_flags_validate+0x234>
				return -1;
			if (i != 3 && *end != '.')
57e0b498:	e3560003 	cmp	r6, #3
57e0b49c:	e5d32000 	ldrb	r2, [r3]
57e0b4a0:	0a000001 	beq	57e0b4ac <env_flags_validate+0x198>
57e0b4a4:	e352002e 	cmp	r2, #46	; 0x2e
57e0b4a8:	ea000000 	b	57e0b4b0 <env_flags_validate+0x19c>
				return -1;
			if (i == 3 && *end != '\0')
57e0b4ac:	e3520000 	cmp	r2, #0
57e0b4b0:	1a000024 	bne	57e0b548 <env_flags_validate+0x234>
			return -1;
		break;
#ifdef CONFIG_CMD_NET
	case env_flags_vartype_ipaddr:
		cur = value;
		for (i = 0; i < 4; i++) {
57e0b4b4:	e2866001 	add	r6, r6, #1
57e0b4b8:	e3560004 	cmp	r6, #4
57e0b4bc:	0a00002a 	beq	57e0b56c <env_flags_validate+0x258>
				return -1;
			if (i != 3 && *end != '.')
				return -1;
			if (i == 3 && *end != '\0')
				return -1;
			cur = end + 1;
57e0b4c0:	e2839001 	add	r9, r3, #1
57e0b4c4:	eaffffe9 	b	57e0b470 <env_flags_validate+0x15c>
		}
		break;
	case env_flags_vartype_macaddr:
		cur = value;
		for (i = 0; i < 6; i++) {
			skip_num(1, cur, &end, 2);
57e0b4c8:	e1a0200c 	mov	r2, ip
57e0b4cc:	e3a03002 	mov	r3, #2
57e0b4d0:	e3a00001 	mov	r0, #1
57e0b4d4:	e1a01006 	mov	r1, r6
57e0b4d8:	e58dc004 	str	ip, [sp, #4]
57e0b4dc:	ebfffeca 	bl	57e0b00c <skip_num>
			if (cur == end)
57e0b4e0:	e59d3014 	ldr	r3, [sp, #20]
57e0b4e4:	e59dc004 	ldr	ip, [sp, #4]
57e0b4e8:	e1560003 	cmp	r6, r3
57e0b4ec:	0a000015 	beq	57e0b548 <env_flags_validate+0x234>
				return -1;
			if (cur + 2 == end && is_hex_prefix(cur))
57e0b4f0:	e2862002 	add	r2, r6, #2
57e0b4f4:	e1530002 	cmp	r3, r2
57e0b4f8:	1a000006 	bne	57e0b518 <env_flags_validate+0x204>
	return env_flags_varaccess_any;
}

static inline int is_hex_prefix(const char *value)
{
	return value[0] == '0' && (value[1] == 'x' || value[1] == 'X');
57e0b4fc:	e5d62000 	ldrb	r2, [r6]
57e0b500:	e3520030 	cmp	r2, #48	; 0x30
57e0b504:	1a000003 	bne	57e0b518 <env_flags_validate+0x204>
57e0b508:	e5d62001 	ldrb	r2, [r6, #1]
57e0b50c:	e3520078 	cmp	r2, #120	; 0x78
57e0b510:	13520058 	cmpne	r2, #88	; 0x58
57e0b514:	0a00000b 	beq	57e0b548 <env_flags_validate+0x234>
			skip_num(1, cur, &end, 2);
			if (cur == end)
				return -1;
			if (cur + 2 == end && is_hex_prefix(cur))
				return -1;
			if (i != 5 && *end != ':')
57e0b518:	e3590005 	cmp	r9, #5
57e0b51c:	e5d32000 	ldrb	r2, [r3]
57e0b520:	0a000001 	beq	57e0b52c <env_flags_validate+0x218>
57e0b524:	e352003a 	cmp	r2, #58	; 0x3a
57e0b528:	ea000000 	b	57e0b530 <env_flags_validate+0x21c>
				return -1;
			if (i == 5 && *end != '\0')
57e0b52c:	e3520000 	cmp	r2, #0
57e0b530:	1a000004 	bne	57e0b548 <env_flags_validate+0x234>
			cur = end + 1;
		}
		break;
	case env_flags_vartype_macaddr:
		cur = value;
		for (i = 0; i < 6; i++) {
57e0b534:	e2899001 	add	r9, r9, #1
57e0b538:	e3590006 	cmp	r9, #6
57e0b53c:	0a00000a 	beq	57e0b56c <env_flags_validate+0x258>
				return -1;
			if (i != 5 && *end != ':')
				return -1;
			if (i == 5 && *end != '\0')
				return -1;
			cur = end + 1;
57e0b540:	e2836001 	add	r6, r3, #1
57e0b544:	eaffffdf 	b	57e0b4c8 <env_flags_validate+0x1b4>
	if (op != env_op_delete) {
		enum env_flags_vartype type = (enum env_flags_vartype)
			(ENV_FLAGS_VARTYPE_BIN_MASK & item->flags);

		if (_env_flags_validate_type(newval, type) < 0) {
			printf("## Error: flags type check failure for "
57e0b548:	e59dc008 	ldr	ip, [sp, #8]
57e0b54c:	e59f30dc 	ldr	r3, [pc, #220]	; 57e0b630 <env_flags_validate+0x31c>
57e0b550:	e59f00dc 	ldr	r0, [pc, #220]	; 57e0b634 <env_flags_validate+0x320>
57e0b554:	e1a01007 	mov	r1, r7
57e0b558:	e1a02004 	mov	r2, r4
57e0b55c:	e7d3300c 	ldrb	r3, [r3, ip]
57e0b560:	ebfff7b9 	bl	57e0944c <printf>
				"\"%s\" <= \"%s\" (type: %c)\n",
				name, newval, env_flags_vartype_rep[type]);
			return -1;
57e0b564:	e3e00000 	mvn	r0, #0
57e0b568:	ea00002d 	b	57e0b624 <env_flags_validate+0x310>
		}
	}

	/* check for access permission */
#ifndef CONFIG_ENV_ACCESS_IGNORE_FORCE
	if (flag & H_FORCE)
57e0b56c:	e59d200c 	ldr	r2, [sp, #12]
57e0b570:	e2120002 	ands	r0, r2, #2
		return 0;
57e0b574:	13a00000 	movne	r0, #0
		}
	}

	/* check for access permission */
#ifndef CONFIG_ENV_ACCESS_IGNORE_FORCE
	if (flag & H_FORCE)
57e0b578:	1a000029 	bne	57e0b624 <env_flags_validate+0x310>
		return 0;
#endif
	switch (op) {
57e0b57c:	e35a0001 	cmp	sl, #1
57e0b580:	0a000003 	beq	57e0b594 <env_flags_validate+0x280>
57e0b584:	3a00001f 	bcc	57e0b608 <env_flags_validate+0x2f4>
57e0b588:	e35a0002 	cmp	sl, #2
57e0b58c:	1a000024 	bne	57e0b624 <env_flags_validate+0x310>
57e0b590:	ea000007 	b	57e0b5b4 <env_flags_validate+0x2a0>
	case env_op_delete:
		if (item->flags & ENV_FLAGS_VARACCESS_PREVENT_DELETE) {
57e0b594:	e595000c 	ldr	r0, [r5, #12]
57e0b598:	e2100008 	ands	r0, r0, #8
57e0b59c:	0a000020 	beq	57e0b624 <env_flags_validate+0x310>
			printf("## Error: Can't delete \"%s\"\n", name);
57e0b5a0:	e59f0090 	ldr	r0, [pc, #144]	; 57e0b638 <env_flags_validate+0x324>
57e0b5a4:	e1a01007 	mov	r1, r7
57e0b5a8:	ebfff7a7 	bl	57e0944c <printf>
			return 1;
57e0b5ac:	e1a0000a 	mov	r0, sl
57e0b5b0:	ea00001b 	b	57e0b624 <env_flags_validate+0x310>
		}
		break;
	case env_op_overwrite:
		if (item->flags & ENV_FLAGS_VARACCESS_PREVENT_OVERWR) {
57e0b5b4:	e595000c 	ldr	r0, [r5, #12]
57e0b5b8:	e3100020 	tst	r0, #32
57e0b5bc:	1a00000f 	bne	57e0b600 <env_flags_validate+0x2ec>
			printf("## Error: Can't overwrite \"%s\"\n", name);
			return 1;
		} else if (item->flags &
57e0b5c0:	e2100040 	ands	r0, r0, #64	; 0x40
57e0b5c4:	0a000016 	beq	57e0b624 <env_flags_validate+0x310>
		    ENV_FLAGS_VARACCESS_PREVENT_NONDEF_OVERWR) {
			const char *defval = getenv_default(name);
57e0b5c8:	e1a00007 	mov	r0, r7
57e0b5cc:	ebfffe04 	bl	57e0ade4 <getenv_default>

			if (defval == NULL)
				defval = "";
57e0b5d0:	e59f4054 	ldr	r4, [pc, #84]	; 57e0b62c <env_flags_validate+0x318>
57e0b5d4:	e3500000 	cmp	r0, #0
57e0b5d8:	11a04000 	movne	r4, r0
			printf("oldval: %s  defval: %s\n", oldval, defval);
57e0b5dc:	e1a0100b 	mov	r1, fp
57e0b5e0:	e1a02004 	mov	r2, r4
57e0b5e4:	e59f0050 	ldr	r0, [pc, #80]	; 57e0b63c <env_flags_validate+0x328>
57e0b5e8:	ebfff797 	bl	57e0944c <printf>
			if (strcmp(oldval, defval) != 0) {
57e0b5ec:	e1a0000b 	mov	r0, fp
57e0b5f0:	e1a01004 	mov	r1, r4
57e0b5f4:	eb00626a 	bl	57e23fa4 <strcmp>
57e0b5f8:	e3500000 	cmp	r0, #0
57e0b5fc:	0a000008 	beq	57e0b624 <env_flags_validate+0x310>
				printf("## Error: Can't overwrite \"%s\"\n",
57e0b600:	e59f0038 	ldr	r0, [pc, #56]	; 57e0b640 <env_flags_validate+0x32c>
57e0b604:	ea000003 	b	57e0b618 <env_flags_validate+0x304>
				return 1;
			}
		}
		break;
	case env_op_create:
		if (item->flags & ENV_FLAGS_VARACCESS_PREVENT_CREATE) {
57e0b608:	e595000c 	ldr	r0, [r5, #12]
57e0b60c:	e2100010 	ands	r0, r0, #16
57e0b610:	0a000003 	beq	57e0b624 <env_flags_validate+0x310>
			printf("## Error: Can't create \"%s\"\n", name);
57e0b614:	e59f0028 	ldr	r0, [pc, #40]	; 57e0b644 <env_flags_validate+0x330>
57e0b618:	e1a01007 	mov	r1, r7
57e0b61c:	ebfff78a 	bl	57e0944c <printf>
			return 1;
57e0b620:	e3a00001 	mov	r0, #1
		}
		break;
	}

	return 0;
}
57e0b624:	e28dd018 	add	sp, sp, #24
57e0b628:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0b62c:	57e302de 	.word	0x57e302de
57e0b630:	57e2bf6c 	.word	0x57e2bf6c
57e0b634:	57e32054 	.word	0x57e32054
57e0b638:	57e32094 	.word	0x57e32094
57e0b63c:	57e320d1 	.word	0x57e320d1
57e0b640:	57e320b1 	.word	0x57e320b1
57e0b644:	57e320e9 	.word	0x57e320e9

57e0b648 <env_init>:
 * can be embedded or attached to the U-Boot image in NAND flash.
 * This way the SPL loads not only the U-Boot image from NAND but
 * also the environment.
 */
int env_init(void)
{
57e0b648:	e92d4038 	push	{r3, r4, r5, lr}
	env_t *tmp_env2;

	tmp_env2 = (env_t *)((ulong)env_ptr + CONFIG_ENV_SIZE);
	crc2_ok = crc32(0, tmp_env2->data, ENV_SIZE) == tmp_env2->crc;
#endif
	tmp_env1 = env_ptr;
57e0b64c:	e59f5054 	ldr	r5, [pc, #84]	; 57e0b6a8 <env_init+0x60>
	crc1_ok = crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc;
57e0b650:	e3a00000 	mov	r0, #0
	env_t *tmp_env2;

	tmp_env2 = (env_t *)((ulong)env_ptr + CONFIG_ENV_SIZE);
	crc2_ok = crc32(0, tmp_env2->data, ENV_SIZE) == tmp_env2->crc;
#endif
	tmp_env1 = env_ptr;
57e0b654:	e5954000 	ldr	r4, [r5]
	crc1_ok = crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc;
57e0b658:	e59f204c 	ldr	r2, [pc, #76]	; 57e0b6ac <env_init+0x64>
57e0b65c:	e2841004 	add	r1, r4, #4
57e0b660:	eb005aea 	bl	57e22210 <crc32>

	if (!crc1_ok && !crc2_ok) {
57e0b664:	e5943000 	ldr	r3, [r4]
57e0b668:	e1500003 	cmp	r0, r3
		gd->env_addr	= 0;
57e0b66c:	13a02000 	movne	r2, #0
57e0b670:	15882010 	strne	r2, [r8, #16]
		gd->env_valid	= 0;
57e0b674:	15882014 	strne	r2, [r8, #20]

		return 0;
57e0b678:	1a000008 	bne	57e0b6a0 <env_init+0x58>
	} else if (crc1_ok && !crc2_ok) {
		gd->env_valid = 1;
57e0b67c:	e3a02001 	mov	r2, #1
57e0b680:	e5882014 	str	r2, [r8, #20]

	if (gd->env_valid == 2)
		env_ptr = tmp_env2;
	else
#endif
	if (gd->env_valid == 1)
57e0b684:	e5982014 	ldr	r2, [r8, #20]
57e0b688:	e3520001 	cmp	r2, #1
		env_ptr = tmp_env1;

	gd->env_addr = (ulong)env_ptr->data;
57e0b68c:	e59f2014 	ldr	r2, [pc, #20]	; 57e0b6a8 <env_init+0x60>
	if (gd->env_valid == 2)
		env_ptr = tmp_env2;
	else
#endif
	if (gd->env_valid == 1)
		env_ptr = tmp_env1;
57e0b690:	05854000 	streq	r4, [r5]

	gd->env_addr = (ulong)env_ptr->data;
57e0b694:	e5922000 	ldr	r2, [r2]
57e0b698:	e2822004 	add	r2, r2, #4
57e0b69c:	e5882010 	str	r2, [r8, #16]
	gd->env_addr	= (ulong)&default_environment[0];
	gd->env_valid	= 1;
#endif /* ENV_IS_EMBEDDED || CONFIG_NAND_ENV_DST */

	return 0;
}
57e0b6a0:	e3a00000 	mov	r0, #0
57e0b6a4:	e8bd8038 	pop	{r3, r4, r5, pc}
57e0b6a8:	57e36dd4 	.word	0x57e36dd4
57e0b6ac:	00003ffc 	.word	0x00003ffc

57e0b6b0 <writeenv>:
/*
 * The legacy NAND code saved the environment in the first NAND device i.e.,
 * nand_dev_desc + 0. This is also the behaviour using the new NAND code.
 */
int writeenv(size_t offset, u_char *buf)
{
57e0b6b0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	size_t end = offset + CONFIG_ENV_RANGE;
	size_t amount_saved = 0;
	size_t blocksize, len;
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
57e0b6b4:	e59f70a4 	ldr	r7, [pc, #164]	; 57e0b760 <writeenv+0xb0>
/*
 * The legacy NAND code saved the environment in the first NAND device i.e.,
 * nand_dev_desc + 0. This is also the behaviour using the new NAND code.
 */
int writeenv(size_t offset, u_char *buf)
{
57e0b6b8:	e24dd018 	sub	sp, sp, #24
	size_t end = offset + CONFIG_ENV_RANGE;
	size_t amount_saved = 0;
	size_t blocksize, len;
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
57e0b6bc:	e597a010 	ldr	sl, [r7, #16]
	len = min(blocksize, CONFIG_ENV_SIZE);
57e0b6c0:	e28d6018 	add	r6, sp, #24
57e0b6c4:	e35a0901 	cmp	sl, #16384	; 0x4000
57e0b6c8:	31a0300a 	movcc	r3, sl
57e0b6cc:	23a03901 	movcs	r3, #16384	; 0x4000
/*
 * The legacy NAND code saved the environment in the first NAND device i.e.,
 * nand_dev_desc + 0. This is also the behaviour using the new NAND code.
 */
int writeenv(size_t offset, u_char *buf)
{
57e0b6d0:	e1a04000 	mov	r4, r0
57e0b6d4:	e1a09001 	mov	r9, r1
	size_t end = offset + CONFIG_ENV_RANGE;
57e0b6d8:	e280b901 	add	fp, r0, #16384	; 0x4000
	size_t amount_saved = 0;
	size_t blocksize, len;
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
	len = min(blocksize, CONFIG_ENV_SIZE);
57e0b6dc:	e5263004 	str	r3, [r6, #-4]!
 * nand_dev_desc + 0. This is also the behaviour using the new NAND code.
 */
int writeenv(size_t offset, u_char *buf)
{
	size_t end = offset + CONFIG_ENV_RANGE;
	size_t amount_saved = 0;
57e0b6e0:	e3a05000 	mov	r5, #0
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
	len = min(blocksize, CONFIG_ENV_SIZE);

	while (amount_saved < CONFIG_ENV_SIZE && offset < end) {
57e0b6e4:	ea000013 	b	57e0b738 <writeenv+0x88>
57e0b6e8:	e3a03000 	mov	r3, #0
57e0b6ec:	e5971078 	ldr	r1, [r7, #120]	; 0x78
57e0b6f0:	e59f0068 	ldr	r0, [pc, #104]	; 57e0b760 <writeenv+0xb0>
57e0b6f4:	e1a02004 	mov	r2, r4
57e0b6f8:	e12fff31 	blx	r1
		if (nand_block_isbad(&nand_info[0], offset)) {
57e0b6fc:	e2503000 	subs	r3, r0, #0
57e0b700:	1a00000b 	bne	57e0b734 <writeenv+0x84>
	return info->read(info, ofs, *len, (size_t *)len, buf);
}

static inline int nand_write(nand_info_t *info, loff_t ofs, size_t *len, u_char *buf)
{
	return info->write(info, ofs, *len, (size_t *)len, buf);
57e0b704:	e59d2014 	ldr	r2, [sp, #20]
57e0b708:	e88d0044 	stm	sp, {r2, r6}
			offset += blocksize;
		} else {
			char_ptr = &buf[amount_saved];
57e0b70c:	e0892005 	add	r2, r9, r5
57e0b710:	e58d2008 	str	r2, [sp, #8]
57e0b714:	e5971044 	ldr	r1, [r7, #68]	; 0x44
57e0b718:	e59f0040 	ldr	r0, [pc, #64]	; 57e0b760 <writeenv+0xb0>
57e0b71c:	e1a02004 	mov	r2, r4
57e0b720:	e12fff31 	blx	r1
			if (nand_write(&nand_info[0], offset, &len, char_ptr))
57e0b724:	e3500000 	cmp	r0, #0
57e0b728:	1a000009 	bne	57e0b754 <writeenv+0xa4>
				return 1;

			offset += blocksize;
			amount_saved += len;
57e0b72c:	e59d3014 	ldr	r3, [sp, #20]
57e0b730:	e0855003 	add	r5, r5, r3
57e0b734:	e084400a 	add	r4, r4, sl
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
	len = min(blocksize, CONFIG_ENV_SIZE);

	while (amount_saved < CONFIG_ENV_SIZE && offset < end) {
57e0b738:	e59f3024 	ldr	r3, [pc, #36]	; 57e0b764 <writeenv+0xb4>
57e0b73c:	e1550003 	cmp	r5, r3
57e0b740:	9154000b 	cmpls	r4, fp
57e0b744:	3affffe7 	bcc	57e0b6e8 <writeenv+0x38>
		if (nand_block_isbad(&nand_info[0], offset)) {
			offset += blocksize;
		} else {
			char_ptr = &buf[amount_saved];
			if (nand_write(&nand_info[0], offset, &len, char_ptr))
				return 1;
57e0b748:	e2550901 	subs	r0, r5, #16384	; 0x4000
57e0b74c:	13a00001 	movne	r0, #1
57e0b750:	ea000000 	b	57e0b758 <writeenv+0xa8>
57e0b754:	e3a00001 	mov	r0, #1
	}
	if (amount_saved != CONFIG_ENV_SIZE)
		return 1;

	return 0;
}
57e0b758:	e28dd018 	add	sp, sp, #24
57e0b75c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0b760:	57e47798 	.word	0x57e47798
57e0b764:	00003fff 	.word	0x00003fff

57e0b768 <saveenv>:

	return ret;
}
#else /* ! CONFIG_ENV_OFFSET_REDUND */
int saveenv(void)
{
57e0b768:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e0b76c:	e24dd901 	sub	sp, sp, #16384	; 0x4000
57e0b770:	e24dd078 	sub	sp, sp, #120	; 0x78
	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
	ssize_t	len;
	char	*res;
	nand_erase_options_t nand_erase_options;

	memset(&nand_erase_options, 0, sizeof(nand_erase_options));
57e0b774:	e28da901 	add	sl, sp, #16384	; 0x4000
57e0b778:	e28aa050 	add	sl, sl, #80	; 0x50
57e0b77c:	e3a01000 	mov	r1, #0
57e0b780:	e3a02020 	mov	r2, #32
57e0b784:	e1a0000a 	mov	r0, sl
57e0b788:	eb0062bb 	bl	57e2427c <memset>
	nand_erase_options.length = CONFIG_ENV_RANGE;
57e0b78c:	e28d2901 	add	r2, sp, #16384	; 0x4000
57e0b790:	e3a03901 	mov	r3, #16384	; 0x4000
57e0b794:	e3a04000 	mov	r4, #0
57e0b798:	e2822050 	add	r2, r2, #80	; 0x50
57e0b79c:	e8820018 	stm	r2, {r3, r4}
	nand_erase_options.offset = CONFIG_ENV_OFFSET;
57e0b7a0:	e28d2901 	add	r2, sp, #16384	; 0x4000
57e0b7a4:	e3a03701 	mov	r3, #262144	; 0x40000
57e0b7a8:	e3a04000 	mov	r4, #0
57e0b7ac:	e2822060 	add	r2, r2, #96	; 0x60
}
#else /* ! CONFIG_ENV_OFFSET_REDUND */
int saveenv(void)
{
	int	ret = 0;
	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
57e0b7b0:	e28d504f 	add	r5, sp, #79	; 0x4f
	char	*res;
	nand_erase_options_t nand_erase_options;

	memset(&nand_erase_options, 0, sizeof(nand_erase_options));
	nand_erase_options.length = CONFIG_ENV_RANGE;
	nand_erase_options.offset = CONFIG_ENV_OFFSET;
57e0b7b4:	e9020018 	stmdb	r2, {r3, r4}
}
#else /* ! CONFIG_ENV_OFFSET_REDUND */
int saveenv(void)
{
	int	ret = 0;
	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
57e0b7b8:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	nand_erase_options.offset = CONFIG_ENV_OFFSET;

	if (CONFIG_ENV_RANGE < CONFIG_ENV_SIZE)
		return 1;

	res = (char *)&env_new->data;
57e0b7bc:	e28d3901 	add	r3, sp, #16384	; 0x4000
	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
57e0b7c0:	e3a04000 	mov	r4, #0
	nand_erase_options.offset = CONFIG_ENV_OFFSET;

	if (CONFIG_ENV_RANGE < CONFIG_ENV_SIZE)
		return 1;

	res = (char *)&env_new->data;
57e0b7c4:	e2833078 	add	r3, r3, #120	; 0x78
57e0b7c8:	e2856004 	add	r6, r5, #4
	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
57e0b7cc:	e59f70c0 	ldr	r7, [pc, #192]	; 57e0b894 <saveenv+0x12c>
	nand_erase_options.offset = CONFIG_ENV_OFFSET;

	if (CONFIG_ENV_RANGE < CONFIG_ENV_SIZE)
		return 1;

	res = (char *)&env_new->data;
57e0b7d0:	e5236004 	str	r6, [r3, #-4]!
	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
57e0b7d4:	e59f00bc 	ldr	r0, [pc, #188]	; 57e0b898 <saveenv+0x130>
57e0b7d8:	e1a01004 	mov	r1, r4
57e0b7dc:	e1a02004 	mov	r2, r4
57e0b7e0:	e58d7000 	str	r7, [sp]
57e0b7e4:	e58d4004 	str	r4, [sp, #4]
57e0b7e8:	e58d4008 	str	r4, [sp, #8]
57e0b7ec:	eb005e2d 	bl	57e230a8 <hexport_r>
	if (len < 0) {
57e0b7f0:	e1500004 	cmp	r0, r4
57e0b7f4:	aa000008 	bge	57e0b81c <saveenv+0xb4>
		error("Cannot export environment: errno = %d\n", errno);
57e0b7f8:	e59f309c 	ldr	r3, [pc, #156]	; 57e0b89c <saveenv+0x134>
57e0b7fc:	e59f209c 	ldr	r2, [pc, #156]	; 57e0b8a0 <saveenv+0x138>
57e0b800:	e58d3000 	str	r3, [sp]
57e0b804:	e59f3098 	ldr	r3, [pc, #152]	; 57e0b8a4 <saveenv+0x13c>
57e0b808:	e59f0098 	ldr	r0, [pc, #152]	; 57e0b8a8 <saveenv+0x140>
57e0b80c:	e5931000 	ldr	r1, [r3]
57e0b810:	e3a030f4 	mov	r3, #244	; 0xf4
57e0b814:	ebfff70c 	bl	57e0944c <printf>
57e0b818:	ea000019 	b	57e0b884 <saveenv+0x11c>
		return 1;
	}
	env_new->crc = crc32(0, env_new->data, ENV_SIZE);
57e0b81c:	e1a01006 	mov	r1, r6
57e0b820:	e1a02007 	mov	r2, r7
57e0b824:	e1a00004 	mov	r0, r4
57e0b828:	eb005a78 	bl	57e22210 <crc32>
57e0b82c:	e5850000 	str	r0, [r5]

	puts("Erasing Nand...\n");
57e0b830:	e59f0074 	ldr	r0, [pc, #116]	; 57e0b8ac <saveenv+0x144>
57e0b834:	ebfff6fa 	bl	57e09424 <puts>
	if (nand_erase_opts(&nand_info[0], &nand_erase_options))
57e0b838:	e59f0070 	ldr	r0, [pc, #112]	; 57e0b8b0 <saveenv+0x148>
57e0b83c:	e1a0100a 	mov	r1, sl
57e0b840:	eb003146 	bl	57e17d60 <nand_erase_opts>
57e0b844:	e3500000 	cmp	r0, #0
57e0b848:	1a00000d 	bne	57e0b884 <saveenv+0x11c>
		return 1;

	puts("Writing to Nand... ");
57e0b84c:	e59f0060 	ldr	r0, [pc, #96]	; 57e0b8b4 <saveenv+0x14c>
57e0b850:	ebfff6f3 	bl	57e09424 <puts>
	if (writeenv(CONFIG_ENV_OFFSET, (u_char *)env_new)) {
57e0b854:	e3a00701 	mov	r0, #262144	; 0x40000
57e0b858:	e1a01005 	mov	r1, r5
57e0b85c:	ebffff93 	bl	57e0b6b0 <writeenv>
57e0b860:	e2504000 	subs	r4, r0, #0
57e0b864:	0a000002 	beq	57e0b874 <saveenv+0x10c>
		puts("FAILED!\n");
57e0b868:	e59f0048 	ldr	r0, [pc, #72]	; 57e0b8b8 <saveenv+0x150>
57e0b86c:	ebfff6ec 	bl	57e09424 <puts>
57e0b870:	ea000003 	b	57e0b884 <saveenv+0x11c>
		return 1;
	}

	puts("done\n");
57e0b874:	e59f0040 	ldr	r0, [pc, #64]	; 57e0b8bc <saveenv+0x154>
57e0b878:	ebfff6e9 	bl	57e09424 <puts>
	return ret;
57e0b87c:	e1a00004 	mov	r0, r4
57e0b880:	ea000000 	b	57e0b888 <saveenv+0x120>
	}
	env_new->crc = crc32(0, env_new->data, ENV_SIZE);

	puts("Erasing Nand...\n");
	if (nand_erase_opts(&nand_info[0], &nand_erase_options))
		return 1;
57e0b884:	e3a00001 	mov	r0, #1
		return 1;
	}

	puts("done\n");
	return ret;
}
57e0b888:	e28dd078 	add	sp, sp, #120	; 0x78
57e0b88c:	e28dd901 	add	sp, sp, #16384	; 0x4000
57e0b890:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e0b894:	00003ffc 	.word	0x00003ffc
57e0b898:	57e36dc4 	.word	0x57e36dc4
57e0b89c:	57e2bf90 	.word	0x57e2bf90
57e0b8a0:	57e32106 	.word	0x57e32106
57e0b8a4:	57e79098 	.word	0x57e79098
57e0b8a8:	57e30fce 	.word	0x57e30fce
57e0b8ac:	57e32111 	.word	0x57e32111
57e0b8b0:	57e47798 	.word	0x57e47798
57e0b8b4:	57e32122 	.word	0x57e32122
57e0b8b8:	57e32136 	.word	0x57e32136
57e0b8bc:	57e35bf2 	.word	0x57e35bf2

57e0b8c0 <readenv>:
#endif /* CONFIG_ENV_OFFSET_REDUND */
#endif /* CMD_SAVEENV */

int readenv(size_t offset, u_char *buf)
{
57e0b8c0:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	size_t end = offset + CONFIG_ENV_RANGE;
	size_t amount_loaded = 0;
	size_t blocksize, len;
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
57e0b8c4:	e59fa0a0 	ldr	sl, [pc, #160]	; 57e0b96c <readenv+0xac>
}
#endif /* CONFIG_ENV_OFFSET_REDUND */
#endif /* CMD_SAVEENV */

int readenv(size_t offset, u_char *buf)
{
57e0b8c8:	e1a04000 	mov	r4, r0
	size_t end = offset + CONFIG_ENV_RANGE;
	size_t amount_loaded = 0;
	size_t blocksize, len;
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
57e0b8cc:	e59a7010 	ldr	r7, [sl, #16]
}
#endif /* CONFIG_ENV_OFFSET_REDUND */
#endif /* CMD_SAVEENV */

int readenv(size_t offset, u_char *buf)
{
57e0b8d0:	e1a09001 	mov	r9, r1
	size_t amount_loaded = 0;
	size_t blocksize, len;
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
	if (!blocksize)
57e0b8d4:	e3570000 	cmp	r7, #0
#endif /* CONFIG_ENV_OFFSET_REDUND */
#endif /* CMD_SAVEENV */

int readenv(size_t offset, u_char *buf)
{
	size_t end = offset + CONFIG_ENV_RANGE;
57e0b8d8:	e280b901 	add	fp, r0, #16384	; 0x4000
	size_t amount_loaded = 0;
	size_t blocksize, len;
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
	if (!blocksize)
57e0b8dc:	0a00001f 	beq	57e0b960 <readenv+0xa0>
		return 1;

	len = min(blocksize, CONFIG_ENV_SIZE);
57e0b8e0:	e3570901 	cmp	r7, #16384	; 0x4000
57e0b8e4:	31a03007 	movcc	r3, r7
57e0b8e8:	23a03901 	movcs	r3, #16384	; 0x4000
57e0b8ec:	e28d6010 	add	r6, sp, #16
57e0b8f0:	e5263004 	str	r3, [r6, #-4]!
#endif /* CMD_SAVEENV */

int readenv(size_t offset, u_char *buf)
{
	size_t end = offset + CONFIG_ENV_RANGE;
	size_t amount_loaded = 0;
57e0b8f4:	e3a05000 	mov	r5, #0
	if (!blocksize)
		return 1;

	len = min(blocksize, CONFIG_ENV_SIZE);

	while (amount_loaded < CONFIG_ENV_SIZE && offset < end) {
57e0b8f8:	ea000011 	b	57e0b944 <readenv+0x84>
}

static inline int nand_block_isbad(nand_info_t *info, loff_t ofs)
{
	return info->block_isbad(info, ofs);
57e0b8fc:	e3a03000 	mov	r3, #0
57e0b900:	e59a1078 	ldr	r1, [sl, #120]	; 0x78
57e0b904:	e59f0060 	ldr	r0, [pc, #96]	; 57e0b96c <readenv+0xac>
57e0b908:	e1a02004 	mov	r2, r4
57e0b90c:	e12fff31 	blx	r1
		if (nand_block_isbad(&nand_info[0], offset)) {
57e0b910:	e2503000 	subs	r3, r0, #0
57e0b914:	1a000009 	bne	57e0b940 <readenv+0x80>
			offset += blocksize;
		} else {
			char_ptr = &buf[amount_loaded];
57e0b918:	e0892005 	add	r2, r9, r5
			if (nand_read_skip_bad(&nand_info[0], offset,
57e0b91c:	e58d2004 	str	r2, [sp, #4]
57e0b920:	e59f0044 	ldr	r0, [pc, #68]	; 57e0b96c <readenv+0xac>
57e0b924:	e1a02004 	mov	r2, r4
57e0b928:	e58d6000 	str	r6, [sp]
57e0b92c:	eb003262 	bl	57e182bc <nand_read_skip_bad>
57e0b930:	e3500000 	cmp	r0, #0
57e0b934:	1a000009 	bne	57e0b960 <readenv+0xa0>
					       &len, char_ptr))
				return 1;

			offset += blocksize;
			amount_loaded += len;
57e0b938:	e59d300c 	ldr	r3, [sp, #12]
57e0b93c:	e0855003 	add	r5, r5, r3
57e0b940:	e0844007 	add	r4, r4, r7
	if (!blocksize)
		return 1;

	len = min(blocksize, CONFIG_ENV_SIZE);

	while (amount_loaded < CONFIG_ENV_SIZE && offset < end) {
57e0b944:	e59f3024 	ldr	r3, [pc, #36]	; 57e0b970 <readenv+0xb0>
57e0b948:	e1550003 	cmp	r5, r3
57e0b94c:	9154000b 	cmpls	r4, fp
57e0b950:	3affffe9 	bcc	57e0b8fc <readenv+0x3c>
	size_t blocksize, len;
	u_char *char_ptr;

	blocksize = nand_info[0].erasesize;
	if (!blocksize)
		return 1;
57e0b954:	e2550901 	subs	r0, r5, #16384	; 0x4000
57e0b958:	13a00001 	movne	r0, #1
57e0b95c:	ea000000 	b	57e0b964 <readenv+0xa4>
			offset += blocksize;
		} else {
			char_ptr = &buf[amount_loaded];
			if (nand_read_skip_bad(&nand_info[0], offset,
					       &len, char_ptr))
				return 1;
57e0b960:	e3a00001 	mov	r0, #1

	if (amount_loaded != CONFIG_ENV_SIZE)
		return 1;

	return 0;
}
57e0b964:	e28dd010 	add	sp, sp, #16
57e0b968:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0b96c:	57e47798 	.word	0x57e47798
57e0b970:	00003fff 	.word	0x00003fff

57e0b974 <env_relocate_spec>:
 * The legacy NAND code saved the environment in the first NAND
 * device i.e., nand_dev_desc + 0. This is also the behaviour using
 * the new NAND code.
 */
void env_relocate_spec(void)
{
57e0b974:	e92d4010 	push	{r4, lr}
57e0b978:	e24dd901 	sub	sp, sp, #16384	; 0x4000
57e0b97c:	e24dd040 	sub	sp, sp, #64	; 0x40
#if !defined(ENV_IS_EMBEDDED)
	int ret;
	ALLOC_CACHE_ALIGN_BUFFER(char, buf, CONFIG_ENV_SIZE);
57e0b980:	e28d403f 	add	r4, sp, #63	; 0x3f
57e0b984:	e3c4403f 	bic	r4, r4, #63	; 0x3f
		set_default_env("!no env offset in OOB");
		return;
	}
#endif

	ret = readenv(CONFIG_ENV_OFFSET, (u_char *)buf);
57e0b988:	e3a00701 	mov	r0, #262144	; 0x40000
57e0b98c:	e1a01004 	mov	r1, r4
57e0b990:	ebffffca 	bl	57e0b8c0 <readenv>
	if (ret) {
57e0b994:	e3500000 	cmp	r0, #0
57e0b998:	0a000002 	beq	57e0b9a8 <env_relocate_spec+0x34>
		set_default_env("!readenv() failed");
57e0b99c:	e59f001c 	ldr	r0, [pc, #28]	; 57e0b9c0 <env_relocate_spec+0x4c>
57e0b9a0:	ebfffd1b 	bl	57e0ae14 <set_default_env>
		return;
57e0b9a4:	ea000002 	b	57e0b9b4 <env_relocate_spec+0x40>
	}

	env_import(buf, 1);
57e0b9a8:	e1a00004 	mov	r0, r4
57e0b9ac:	e3a01001 	mov	r1, #1
57e0b9b0:	ebfffd52 	bl	57e0af00 <env_import>
#endif /* ! ENV_IS_EMBEDDED */
}
57e0b9b4:	e28dd040 	add	sp, sp, #64	; 0x40
57e0b9b8:	e28dd901 	add	sp, sp, #16384	; 0x4000
57e0b9bc:	e8bd8010 	pop	{r4, pc}
57e0b9c0:	57e3213f 	.word	0x57e3213f

57e0b9c4 <dummy>:

DECLARE_GLOBAL_DATA_PTR;

__attribute__((unused)) static void dummy(void)
{
}
57e0b9c4:	e12fff1e 	bx	lr

57e0b9c8 <get_version>:

unsigned long get_version(void)
{
	return XF_VERSION;
}
57e0b9c8:	e3a00006 	mov	r0, #6
57e0b9cc:	e12fff1e 	bx	lr

57e0b9d0 <jumptable_init>:
# define spi_release_bus   dummy
# define spi_xfer          dummy
#endif

void jumptable_init(void)
{
57e0b9d0:	e92d4010 	push	{r4, lr}
	gd->jt = malloc(XF_MAX * sizeof(void *));
57e0b9d4:	e3a00070 	mov	r0, #112	; 0x70
57e0b9d8:	e1a04008 	mov	r4, r8
57e0b9dc:	ebfff878 	bl	57e09bc4 <malloc>
57e0b9e0:	e5840054 	str	r0, [r4, #84]	; 0x54
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
57e0b9e4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
57e0b9e8:	e59f1124 	ldr	r1, [pc, #292]	; 57e0bb14 <jumptable_init+0x144>
EXPORT_FUNC(putc)
EXPORT_FUNC(puts)
EXPORT_FUNC(printf)
EXPORT_FUNC(install_hdlr)
EXPORT_FUNC(free_hdlr)
EXPORT_FUNC(malloc)
57e0b9ec:	e59f0124 	ldr	r0, [pc, #292]	; 57e0bb18 <jumptable_init+0x148>
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
57e0b9f0:	e5821000 	str	r1, [r2]
EXPORT_FUNC(getc)
57e0b9f4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
57e0b9f8:	e59f111c 	ldr	r1, [pc, #284]	; 57e0bb1c <jumptable_init+0x14c>
57e0b9fc:	e5821004 	str	r1, [r2, #4]
EXPORT_FUNC(tstc)
57e0ba00:	e5982054 	ldr	r2, [r8, #84]	; 0x54
57e0ba04:	e59f1114 	ldr	r1, [pc, #276]	; 57e0bb20 <jumptable_init+0x150>
57e0ba08:	e5821008 	str	r1, [r2, #8]
EXPORT_FUNC(putc)
57e0ba0c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
57e0ba10:	e59f110c 	ldr	r1, [pc, #268]	; 57e0bb24 <jumptable_init+0x154>
57e0ba14:	e582100c 	str	r1, [r2, #12]
EXPORT_FUNC(puts)
57e0ba18:	e5982054 	ldr	r2, [r8, #84]	; 0x54
57e0ba1c:	e59f1104 	ldr	r1, [pc, #260]	; 57e0bb28 <jumptable_init+0x158>
57e0ba20:	e5821010 	str	r1, [r2, #16]
EXPORT_FUNC(printf)
57e0ba24:	e5982054 	ldr	r2, [r8, #84]	; 0x54
57e0ba28:	e59f10fc 	ldr	r1, [pc, #252]	; 57e0bb2c <jumptable_init+0x15c>
57e0ba2c:	e5821014 	str	r1, [r2, #20]
EXPORT_FUNC(install_hdlr)
57e0ba30:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba34:	e59f20f4 	ldr	r2, [pc, #244]	; 57e0bb30 <jumptable_init+0x160>
57e0ba38:	e5812018 	str	r2, [r1, #24]
EXPORT_FUNC(free_hdlr)
57e0ba3c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba40:	e581201c 	str	r2, [r1, #28]
EXPORT_FUNC(malloc)
57e0ba44:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba48:	e5810020 	str	r0, [r1, #32]
EXPORT_FUNC(free)
57e0ba4c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba50:	e59f00dc 	ldr	r0, [pc, #220]	; 57e0bb34 <jumptable_init+0x164>
57e0ba54:	e5810024 	str	r0, [r1, #36]	; 0x24
EXPORT_FUNC(udelay)
57e0ba58:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba5c:	e59f00d4 	ldr	r0, [pc, #212]	; 57e0bb38 <jumptable_init+0x168>
57e0ba60:	e5810028 	str	r0, [r1, #40]	; 0x28
EXPORT_FUNC(get_timer)
57e0ba64:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba68:	e59f00cc 	ldr	r0, [pc, #204]	; 57e0bb3c <jumptable_init+0x16c>
57e0ba6c:	e581002c 	str	r0, [r1, #44]	; 0x2c
EXPORT_FUNC(vprintf)
57e0ba70:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba74:	e59f00c4 	ldr	r0, [pc, #196]	; 57e0bb40 <jumptable_init+0x170>
57e0ba78:	e5810030 	str	r0, [r1, #48]	; 0x30
EXPORT_FUNC(do_reset)
57e0ba7c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba80:	e59f00bc 	ldr	r0, [pc, #188]	; 57e0bb44 <jumptable_init+0x174>
57e0ba84:	e5810034 	str	r0, [r1, #52]	; 0x34
EXPORT_FUNC(getenv)
57e0ba88:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba8c:	e59f00b4 	ldr	r0, [pc, #180]	; 57e0bb48 <jumptable_init+0x178>
57e0ba90:	e5810038 	str	r0, [r1, #56]	; 0x38
EXPORT_FUNC(setenv)
57e0ba94:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0ba98:	e59f00ac 	ldr	r0, [pc, #172]	; 57e0bb4c <jumptable_init+0x17c>
57e0ba9c:	e581003c 	str	r0, [r1, #60]	; 0x3c
EXPORT_FUNC(simple_strtoul)
57e0baa0:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0baa4:	e59f00a4 	ldr	r0, [pc, #164]	; 57e0bb50 <jumptable_init+0x180>
57e0baa8:	e5810040 	str	r0, [r1, #64]	; 0x40
EXPORT_FUNC(strict_strtoul)
57e0baac:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0bab0:	e59f009c 	ldr	r0, [pc, #156]	; 57e0bb54 <jumptable_init+0x184>
57e0bab4:	e5810044 	str	r0, [r1, #68]	; 0x44
EXPORT_FUNC(simple_strtol)
57e0bab8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0babc:	e59f0094 	ldr	r0, [pc, #148]	; 57e0bb58 <jumptable_init+0x188>
57e0bac0:	e5810048 	str	r0, [r1, #72]	; 0x48
EXPORT_FUNC(strcmp)
57e0bac4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0bac8:	e59f008c 	ldr	r0, [pc, #140]	; 57e0bb5c <jumptable_init+0x18c>
57e0bacc:	e581004c 	str	r0, [r1, #76]	; 0x4c
EXPORT_FUNC(i2c_write)
57e0bad0:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0bad4:	e5812050 	str	r2, [r1, #80]	; 0x50
EXPORT_FUNC(i2c_read)
57e0bad8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0badc:	e5812054 	str	r2, [r1, #84]	; 0x54
EXPORT_FUNC(spi_init)
57e0bae0:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0bae4:	e5812058 	str	r2, [r1, #88]	; 0x58
EXPORT_FUNC(spi_setup_slave)
57e0bae8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0baec:	e581205c 	str	r2, [r1, #92]	; 0x5c
EXPORT_FUNC(spi_free_slave)
57e0baf0:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0baf4:	e5812060 	str	r2, [r1, #96]	; 0x60
EXPORT_FUNC(spi_claim_bus)
57e0baf8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
57e0bafc:	e5812064 	str	r2, [r1, #100]	; 0x64
EXPORT_FUNC(spi_release_bus)
57e0bb00:	e5981054 	ldr	r1, [r8, #84]	; 0x54
EXPORT_FUNC(spi_xfer)
57e0bb04:	e5983054 	ldr	r3, [r8, #84]	; 0x54
EXPORT_FUNC(i2c_read)
EXPORT_FUNC(spi_init)
EXPORT_FUNC(spi_setup_slave)
EXPORT_FUNC(spi_free_slave)
EXPORT_FUNC(spi_claim_bus)
EXPORT_FUNC(spi_release_bus)
57e0bb08:	e5812068 	str	r2, [r1, #104]	; 0x68
EXPORT_FUNC(spi_xfer)
57e0bb0c:	e583206c 	str	r2, [r3, #108]	; 0x6c
#include <_exports.h>
}
57e0bb10:	e8bd8010 	pop	{r4, pc}
57e0bb14:	57e0b9c8 	.word	0x57e0b9c8
57e0bb18:	57e09bc4 	.word	0x57e09bc4
57e0bb1c:	57e093b4 	.word	0x57e093b4
57e0bb20:	57e093d8 	.word	0x57e093d8
57e0bb24:	57e093fc 	.word	0x57e093fc
57e0bb28:	57e09424 	.word	0x57e09424
57e0bb2c:	57e0944c 	.word	0x57e0944c
57e0bb30:	57e0b9c4 	.word	0x57e0b9c4
57e0bb34:	57e0999c 	.word	0x57e0999c
57e0bb38:	57e24538 	.word	0x57e24538
57e0bb3c:	57e00b0c 	.word	0x57e00b0c
57e0bb40:	57e0949c 	.word	0x57e0949c
57e0bb44:	57e01378 	.word	0x57e01378
57e0bb48:	57e076e8 	.word	0x57e076e8
57e0bb4c:	57e072b0 	.word	0x57e072b0
57e0bb50:	57e250a4 	.word	0x57e250a4
57e0bb54:	57e25150 	.word	0x57e25150
57e0bb58:	57e251c8 	.word	0x57e251c8
57e0bb5c:	57e23fa4 	.word	0x57e23fa4

57e0bb60 <flash_protect>:
	ulong b_end;
	short s_end;
	int i;

	/* Do nothing if input data is bad. */
	if (!info || info->sector_count == 0 || info->size == 0 || to < from) {
57e0bb60:	e3530000 	cmp	r3, #0
 * The monitor is always located in the _first_ Flash bank.
 * If necessary you have to map the second bank at lower addresses.
 */
void
flash_protect (int flag, ulong from, ulong to, flash_info_t *info)
{
57e0bb64:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	ulong b_end;
	short s_end;
	int i;

	/* Do nothing if input data is bad. */
	if (!info || info->sector_count == 0 || info->size == 0 || to < from) {
57e0bb68:	0a000039 	beq	57e0bc54 <flash_protect+0xf4>
57e0bb6c:	e1d350b4 	ldrh	r5, [r3, #4]
57e0bb70:	e3550000 	cmp	r5, #0
57e0bb74:	0a000036 	beq	57e0bc54 <flash_protect+0xf4>
57e0bb78:	e5936000 	ldr	r6, [r3]
57e0bb7c:	e276c001 	rsbs	ip, r6, #1
57e0bb80:	33a0c000 	movcc	ip, #0
57e0bb84:	e1520001 	cmp	r2, r1
57e0bb88:	338cc001 	orrcc	ip, ip, #1
57e0bb8c:	e35c0000 	cmp	ip, #0
57e0bb90:	1a00002f 	bne	57e0bc54 <flash_protect+0xf4>
		from, to);

	/* There is nothing to do if we have no data about the flash
	 * or the protect range and flash range don't overlap.
	 */
	if (info->flash_id == FLASH_UNKNOWN ||
57e0bb94:	e5937008 	ldr	r7, [r3, #8]
57e0bb98:	e59f40b8 	ldr	r4, [pc, #184]	; 57e0bc58 <flash_protect+0xf8>
	/* Do nothing if input data is bad. */
	if (!info || info->sector_count == 0 || info->size == 0 || to < from) {
		return;
	}

	s_end = info->sector_count - 1;	/* index of last sector */
57e0bb9c:	e245b001 	sub	fp, r5, #1
57e0bba0:	e1a0b80b 	lsl	fp, fp, #16
		from, to);

	/* There is nothing to do if we have no data about the flash
	 * or the protect range and flash range don't overlap.
	 */
	if (info->flash_id == FLASH_UNKNOWN ||
57e0bba4:	e1570004 	cmp	r7, r4
	/* Do nothing if input data is bad. */
	if (!info || info->sector_count == 0 || info->size == 0 || to < from) {
		return;
	}

	s_end = info->sector_count - 1;	/* index of last sector */
57e0bba8:	e1a0b82b 	lsr	fp, fp, #16
	b_end = info->start[0] + info->size - 1;	/* bank end address */
57e0bbac:	e593c00c 	ldr	ip, [r3, #12]
		from, to);

	/* There is nothing to do if we have no data about the flash
	 * or the protect range and flash range don't overlap.
	 */
	if (info->flash_id == FLASH_UNKNOWN ||
57e0bbb0:	0a000027 	beq	57e0bc54 <flash_protect+0xf4>
	if (!info || info->sector_count == 0 || info->size == 0 || to < from) {
		return;
	}

	s_end = info->sector_count - 1;	/* index of last sector */
	b_end = info->start[0] + info->size - 1;	/* bank end address */
57e0bbb4:	e086600c 	add	r6, r6, ip
57e0bbb8:	e2466001 	sub	r6, r6, #1

	/* There is nothing to do if we have no data about the flash
	 * or the protect range and flash range don't overlap.
	 */
	if (info->flash_id == FLASH_UNKNOWN ||
	    to < info->start[0] || from > b_end) {
57e0bbbc:	e1510006 	cmp	r1, r6
57e0bbc0:	93a04000 	movls	r4, #0
57e0bbc4:	83a04001 	movhi	r4, #1
57e0bbc8:	e152000c 	cmp	r2, ip
57e0bbcc:	21a0c004 	movcs	ip, r4
57e0bbd0:	3384c001 	orrcc	ip, r4, #1
57e0bbd4:	e35c0000 	cmp	ip, #0
57e0bbd8:	1a00001d 	bne	57e0bc54 <flash_protect+0xf4>

		/* Update protection if any part of the sector
		 * is in the specified range.
		 */
		if (from <= end && to >= info->start[i]) {
			if (flag & FLAG_PROTECT_CLEAR) {
57e0bbdc:	e2007002 	and	r7, r0, #2
	}

	for (i=0; i<info->sector_count; ++i) {
		ulong end;		/* last address in current sect	*/

		end = (i == s_end) ? b_end : info->start[i + 1] - 1;
57e0bbe0:	e1a0b80b 	lsl	fp, fp, #16

		/* Update protection if any part of the sector
		 * is in the specified range.
		 */
		if (from <= end && to >= info->start[i]) {
			if (flag & FLAG_PROTECT_CLEAR) {
57e0bbe4:	e58d7004 	str	r7, [sp, #4]
	if (info->flash_id == FLASH_UNKNOWN ||
	    to < info->start[0] || from > b_end) {
		return;
	}

	for (i=0; i<info->sector_count; ++i) {
57e0bbe8:	e1a04003 	mov	r4, r3
		ulong end;		/* last address in current sect	*/

		end = (i == s_end) ? b_end : info->start[i + 1] - 1;
57e0bbec:	e1a0b84b 	asr	fp, fp, #16
#else
				info->protect[i] = 0;
#endif	/* CONFIG_SYS_FLASH_PROTECTION */
				debug ("protect off %d\n", i);
			}
			else if (flag & FLAG_PROTECT_SET) {
57e0bbf0:	e2000001 	and	r0, r0, #1
#if defined(CONFIG_SYS_FLASH_PROTECTION)
				flash_real_protect(info, i, 1);
#else
				info->protect[i] = 1;
57e0bbf4:	e3a09001 	mov	r9, #1
		if (from <= end && to >= info->start[i]) {
			if (flag & FLAG_PROTECT_CLEAR) {
#if defined(CONFIG_SYS_FLASH_PROTECTION)
				flash_real_protect(info, i, 0);
#else
				info->protect[i] = 0;
57e0bbf8:	e1a0a00c 	mov	sl, ip
57e0bbfc:	e1a07005 	mov	r7, r5
57e0bc00:	ea000011 	b	57e0bc4c <flash_protect+0xec>
	}

	for (i=0; i<info->sector_count; ++i) {
		ulong end;		/* last address in current sect	*/

		end = (i == s_end) ? b_end : info->start[i + 1] - 1;
57e0bc04:	e15c000b 	cmp	ip, fp
57e0bc08:	15935010 	ldrne	r5, [r3, #16]
57e0bc0c:	01a05006 	moveq	r5, r6
57e0bc10:	12455001 	subne	r5, r5, #1

		/* Update protection if any part of the sector
		 * is in the specified range.
		 */
		if (from <= end && to >= info->start[i]) {
57e0bc14:	e1510005 	cmp	r1, r5
57e0bc18:	8a000008 	bhi	57e0bc40 <flash_protect+0xe0>
57e0bc1c:	e593500c 	ldr	r5, [r3, #12]
57e0bc20:	e1520005 	cmp	r2, r5
57e0bc24:	3a000005 	bcc	57e0bc40 <flash_protect+0xe0>
			if (flag & FLAG_PROTECT_CLEAR) {
57e0bc28:	e59d5004 	ldr	r5, [sp, #4]
57e0bc2c:	e3550000 	cmp	r5, #0
#if defined(CONFIG_SYS_FLASH_PROTECTION)
				flash_real_protect(info, i, 0);
#else
				info->protect[i] = 0;
57e0bc30:	15c4a0ac 	strbne	sl, [r4, #172]	; 0xac

		/* Update protection if any part of the sector
		 * is in the specified range.
		 */
		if (from <= end && to >= info->start[i]) {
			if (flag & FLAG_PROTECT_CLEAR) {
57e0bc34:	1a000001 	bne	57e0bc40 <flash_protect+0xe0>
#else
				info->protect[i] = 0;
#endif	/* CONFIG_SYS_FLASH_PROTECTION */
				debug ("protect off %d\n", i);
			}
			else if (flag & FLAG_PROTECT_SET) {
57e0bc38:	e3500000 	cmp	r0, #0
#if defined(CONFIG_SYS_FLASH_PROTECTION)
				flash_real_protect(info, i, 1);
#else
				info->protect[i] = 1;
57e0bc3c:	15c490ac 	strbne	r9, [r4, #172]	; 0xac
	if (info->flash_id == FLASH_UNKNOWN ||
	    to < info->start[0] || from > b_end) {
		return;
	}

	for (i=0; i<info->sector_count; ++i) {
57e0bc40:	e28cc001 	add	ip, ip, #1
57e0bc44:	e2833004 	add	r3, r3, #4
57e0bc48:	e2844001 	add	r4, r4, #1
57e0bc4c:	e15c0007 	cmp	ip, r7
57e0bc50:	baffffeb 	blt	57e0bc04 <flash_protect+0xa4>
#endif	/* CONFIG_SYS_FLASH_PROTECTION */
				debug ("protect on %d\n", i);
			}
		}
	}
}
57e0bc54:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e0bc58:	0000ffff 	.word	0x0000ffff

57e0bc5c <addr2info>:
#ifndef CONFIG_SPD823TS
	flash_info_t *info;
	int i;

	for (i=0, info = &flash_info[0]; i<CONFIG_SYS_MAX_FLASH_BANKS; ++i, ++info) {
		if (info->flash_id != FLASH_UNKNOWN &&
57e0bc5c:	e59f3040 	ldr	r3, [pc, #64]	; 57e0bca4 <addr2info+0x48>
57e0bc60:	e59f2040 	ldr	r2, [pc, #64]	; 57e0bca8 <addr2info+0x4c>
57e0bc64:	e5931008 	ldr	r1, [r3, #8]
57e0bc68:	e1510002 	cmp	r1, r2
			return (info);
		}
	}
#endif /* CONFIG_SPD823TS */

	return (NULL);
57e0bc6c:	03a00000 	moveq	r0, #0
#ifndef CONFIG_SPD823TS
	flash_info_t *info;
	int i;

	for (i=0, info = &flash_info[0]; i<CONFIG_SYS_MAX_FLASH_BANKS; ++i, ++info) {
		if (info->flash_id != FLASH_UNKNOWN &&
57e0bc70:	012fff1e 	bxeq	lr
		    addr >= info->start[0] &&
57e0bc74:	e593200c 	ldr	r2, [r3, #12]
#ifndef CONFIG_SPD823TS
	flash_info_t *info;
	int i;

	for (i=0, info = &flash_info[0]; i<CONFIG_SYS_MAX_FLASH_BANKS; ++i, ++info) {
		if (info->flash_id != FLASH_UNKNOWN &&
57e0bc78:	e1500002 	cmp	r0, r2
57e0bc7c:	3a000006 	bcc	57e0bc9c <addr2info+0x40>
		    /* WARNING - The '- 1' is needed if the flash
		     * is at the end of the address space, since
		     * info->start[0] + info->size wraps back to 0.
		     * Please don't change this unless you understand this.
		     */
		    addr <= info->start[0] + info->size - 1) {
57e0bc80:	e5931000 	ldr	r1, [r3]
57e0bc84:	e0822001 	add	r2, r2, r1
57e0bc88:	e2422001 	sub	r2, r2, #1
			return (info);
		}
	}
#endif /* CONFIG_SPD823TS */

	return (NULL);
57e0bc8c:	e1500002 	cmp	r0, r2
57e0bc90:	91a00003 	movls	r0, r3
57e0bc94:	83a00000 	movhi	r0, #0
57e0bc98:	e12fff1e 	bx	lr
57e0bc9c:	e3a00000 	mov	r0, #0
}
57e0bca0:	e12fff1e 	bx	lr
57e0bca4:	57e47684 	.word	0x57e47684
57e0bca8:	0000ffff 	.word	0x0000ffff

57e0bcac <flash_write>:
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
{
57e0bcac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
#ifdef CONFIG_SPD823TS
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
57e0bcb0:	e241b001 	sub	fp, r1, #1
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
{
57e0bcb4:	e24dd018 	sub	sp, sp, #24
57e0bcb8:	e1a0a000 	mov	sl, r0
#ifdef CONFIG_SPD823TS
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
	flash_info_t *info_first = addr2info (addr);
57e0bcbc:	e1a00001 	mov	r0, r1
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
{
57e0bcc0:	e1a04002 	mov	r4, r2
#ifdef CONFIG_SPD823TS
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
57e0bcc4:	e08bb002 	add	fp, fp, r2
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
{
57e0bcc8:	e1a05001 	mov	r5, r1
#ifdef CONFIG_SPD823TS
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
	flash_info_t *info_first = addr2info (addr);
57e0bccc:	ebffffe2 	bl	57e0bc5c <addr2info>
57e0bcd0:	e1a06000 	mov	r6, r0
	flash_info_t *info_last  = addr2info (end );
57e0bcd4:	e1a0000b 	mov	r0, fp
57e0bcd8:	ebffffdf 	bl	57e0bc5c <addr2info>
	flash_info_t *info;

	if (cnt == 0) {
57e0bcdc:	e3540000 	cmp	r4, #0
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
	flash_info_t *info_first = addr2info (addr);
	flash_info_t *info_last  = addr2info (end );
57e0bce0:	e1a09000 	mov	r9, r0
	flash_info_t *info;

	if (cnt == 0) {
		return (ERR_OK);
57e0bce4:	01a00004 	moveq	r0, r4
	ulong         end        = addr + cnt - 1;
	flash_info_t *info_first = addr2info (addr);
	flash_info_t *info_last  = addr2info (end );
	flash_info_t *info;

	if (cnt == 0) {
57e0bce8:	0a000045 	beq	57e0be04 <flash_write+0x158>
		return (ERR_OK);
	}

	if (!info_first || !info_last) {
57e0bcec:	e3560000 	cmp	r6, #0
57e0bcf0:	13590000 	cmpne	r9, #0
57e0bcf4:	11a03006 	movne	r3, r6
57e0bcf8:	1a000023 	bne	57e0bd8c <flash_write+0xe0>
57e0bcfc:	ea00003d 	b	57e0bdf8 <flash_write+0x14c>
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
		short s_end = info->sector_count - 1;
57e0bd00:	e1d370b4 	ldrh	r7, [r3, #4]
	if (!info_first || !info_last) {
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
57e0bd04:	e5931000 	ldr	r1, [r3]
57e0bd08:	e593200c 	ldr	r2, [r3, #12]
		short s_end = info->sector_count - 1;
57e0bd0c:	e247c001 	sub	ip, r7, #1
		for (i=0; i<info->sector_count; ++i) {
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];
57e0bd10:	e1a0c80c 	lsl	ip, ip, #16
	if (!info_first || !info_last) {
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
57e0bd14:	e0812002 	add	r2, r1, r2
		short s_end = info->sector_count - 1;
		for (i=0; i<info->sector_count; ++i) {
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];
57e0bd18:	e1a0c84c 	asr	ip, ip, #16
	if (!info_first || !info_last) {
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
57e0bd1c:	e58d200c 	str	r2, [sp, #12]
 * ERR_INVAL       8 - target address not in Flash memory
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
57e0bd20:	e2830008 	add	r0, r3, #8
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
		short s_end = info->sector_count - 1;
57e0bd24:	e1a01003 	mov	r1, r3
		for (i=0; i<info->sector_count; ++i) {
57e0bd28:	e3a02000 	mov	r2, #0
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];
57e0bd2c:	e58dc014 	str	ip, [sp, #20]
57e0bd30:	e58d3004 	str	r3, [sp, #4]
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
		short s_end = info->sector_count - 1;
		for (i=0; i<info->sector_count; ++i) {
57e0bd34:	ea000010 	b	57e0bd7c <flash_write+0xd0>
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];
57e0bd38:	e59d3014 	ldr	r3, [sp, #20]
57e0bd3c:	e1520003 	cmp	r2, r3
57e0bd40:	15903008 	ldrne	r3, [r0, #8]
57e0bd44:	059d300c 	ldreq	r3, [sp, #12]

			if ((end >= info->start[i]) && (addr < e_addr) &&
57e0bd48:	e5b0c004 	ldr	ip, [r0, #4]!
57e0bd4c:	e1550003 	cmp	r5, r3
57e0bd50:	23a03000 	movcs	r3, #0
57e0bd54:	33a03001 	movcc	r3, #1
57e0bd58:	e15b000c 	cmp	fp, ip
57e0bd5c:	33a03000 	movcc	r3, #0
57e0bd60:	e3530000 	cmp	r3, #0
57e0bd64:	0a000002 	beq	57e0bd74 <flash_write+0xc8>
57e0bd68:	e5d130ac 	ldrb	r3, [r1, #172]	; 0xac
57e0bd6c:	e3530000 	cmp	r3, #0
57e0bd70:	1a000022 	bne	57e0be00 <flash_write+0x154>
	}

	for (info = info_first; info <= info_last; ++info) {
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
		short s_end = info->sector_count - 1;
		for (i=0; i<info->sector_count; ++i) {
57e0bd74:	e2822001 	add	r2, r2, #1
57e0bd78:	e2811001 	add	r1, r1, #1
57e0bd7c:	e1520007 	cmp	r2, r7
57e0bd80:	baffffec 	blt	57e0bd38 <flash_write+0x8c>
57e0bd84:	e59d3004 	ldr	r3, [sp, #4]

	if (!info_first || !info_last) {
		return (ERR_INVAL);
	}

	for (info = info_first; info <= info_last; ++info) {
57e0bd88:	e2833f42 	add	r3, r3, #264	; 0x108
57e0bd8c:	e1530009 	cmp	r3, r9
57e0bd90:	9affffda 	bls	57e0bd00 <flash_write+0x54>
57e0bd94:	ea000010 	b	57e0bddc <flash_write+0x130>

	/* finally write data to flash */
	for (info = info_first; info <= info_last && cnt>0; ++info) {
		ulong len;

		len = info->start[0] + info->size - addr;
57e0bd98:	e596300c 	ldr	r3, [r6, #12]
57e0bd9c:	e5967000 	ldr	r7, [r6]
		if (len > cnt)
			len = cnt;
		if ((i = write_buff(info, (uchar *)src, addr, len)) != 0) {
57e0bda0:	e1a00006 	mov	r0, r6

	/* finally write data to flash */
	for (info = info_first; info <= info_last && cnt>0; ++info) {
		ulong len;

		len = info->start[0] + info->size - addr;
57e0bda4:	e0877003 	add	r7, r7, r3
57e0bda8:	e0657007 	rsb	r7, r5, r7
57e0bdac:	e1570004 	cmp	r7, r4
57e0bdb0:	21a07004 	movcs	r7, r4
		if (len > cnt)
			len = cnt;
		if ((i = write_buff(info, (uchar *)src, addr, len)) != 0) {
57e0bdb4:	e1a0100a 	mov	r1, sl
57e0bdb8:	e1a02005 	mov	r2, r5
57e0bdbc:	e1a03007 	mov	r3, r7
57e0bdc0:	eb00250c 	bl	57e151f8 <write_buff>
57e0bdc4:	e3500000 	cmp	r0, #0
57e0bdc8:	1a00000d 	bne	57e0be04 <flash_write+0x158>
			return (i);
		}
		cnt  -= len;
57e0bdcc:	e0674004 	rsb	r4, r7, r4
		addr += len;
57e0bdd0:	e0855007 	add	r5, r5, r7
		src  += len;
57e0bdd4:	e08aa007 	add	sl, sl, r7
			}
		}
	}

	/* finally write data to flash */
	for (info = info_first; info <= info_last && cnt>0; ++info) {
57e0bdd8:	e2866f42 	add	r6, r6, #264	; 0x108
57e0bddc:	e2540000 	subs	r0, r4, #0
57e0bde0:	13a00001 	movne	r0, #1
57e0bde4:	e1560009 	cmp	r6, r9
57e0bde8:	83a00000 	movhi	r0, #0
57e0bdec:	e3500000 	cmp	r0, #0
57e0bdf0:	1affffe8 	bne	57e0bd98 <flash_write+0xec>
57e0bdf4:	ea000002 	b	57e0be04 <flash_write+0x158>
	if (cnt == 0) {
		return (ERR_OK);
	}

	if (!info_first || !info_last) {
		return (ERR_INVAL);
57e0bdf8:	e3a00008 	mov	r0, #8
57e0bdfc:	ea000000 	b	57e0be04 <flash_write+0x158>
		for (i=0; i<info->sector_count; ++i) {
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];

			if ((end >= info->start[i]) && (addr < e_addr) &&
			    (info->protect[i] != 0) ) {
				return (ERR_PROTECTED);
57e0be00:	e3a00004 	mov	r0, #4
		addr += len;
		src  += len;
	}
	return (ERR_OK);
#endif /* CONFIG_SPD823TS */
}
57e0be04:	e28dd018 	add	sp, sp, #24
57e0be08:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e0be0c <flash_perror>:
/*-----------------------------------------------------------------------
 */

void flash_perror (int err)
{
	switch (err) {
57e0be0c:	e3500008 	cmp	r0, #8

/*-----------------------------------------------------------------------
 */

void flash_perror (int err)
{
57e0be10:	e1a03000 	mov	r3, r0
	switch (err) {
57e0be14:	0a00001e 	beq	57e0be94 <flash_perror+0x88>
57e0be18:	ca00000a 	bgt	57e0be48 <flash_perror+0x3c>
57e0be1c:	e3500001 	cmp	r0, #1
57e0be20:	0a000015 	beq	57e0be7c <flash_perror+0x70>
57e0be24:	ca000002 	bgt	57e0be34 <flash_perror+0x28>
57e0be28:	e3500000 	cmp	r0, #0
57e0be2c:	012fff1e 	bxeq	lr
57e0be30:	ea000023 	b	57e0bec4 <flash_perror+0xb8>
57e0be34:	e3500002 	cmp	r0, #2
57e0be38:	0a000011 	beq	57e0be84 <flash_perror+0x78>
57e0be3c:	e3500004 	cmp	r0, #4
57e0be40:	1a00001f 	bne	57e0bec4 <flash_perror+0xb8>
57e0be44:	ea000010 	b	57e0be8c <flash_perror+0x80>
57e0be48:	e3500040 	cmp	r0, #64	; 0x40
57e0be4c:	0a000016 	beq	57e0beac <flash_perror+0xa0>
57e0be50:	ca000004 	bgt	57e0be68 <flash_perror+0x5c>
57e0be54:	e3500010 	cmp	r0, #16
57e0be58:	0a00000f 	beq	57e0be9c <flash_perror+0x90>
57e0be5c:	e3500020 	cmp	r0, #32
57e0be60:	1a000017 	bne	57e0bec4 <flash_perror+0xb8>
57e0be64:	ea00000e 	b	57e0bea4 <flash_perror+0x98>
57e0be68:	e3500080 	cmp	r0, #128	; 0x80
57e0be6c:	0a000010 	beq	57e0beb4 <flash_perror+0xa8>
57e0be70:	e3500c01 	cmp	r0, #256	; 0x100
57e0be74:	1a000012 	bne	57e0bec4 <flash_perror+0xb8>
57e0be78:	ea00000f 	b	57e0bebc <flash_perror+0xb0>
	case ERR_OK:
		break;
	case ERR_TIMOUT:
		puts ("Timeout writing to Flash\n");
57e0be7c:	e59f0050 	ldr	r0, [pc, #80]	; 57e0bed4 <flash_perror+0xc8>
57e0be80:	ea000000 	b	57e0be88 <flash_perror+0x7c>
		break;
	case ERR_NOT_ERASED:
		puts ("Flash not Erased\n");
57e0be84:	e59f004c 	ldr	r0, [pc, #76]	; 57e0bed8 <flash_perror+0xcc>
57e0be88:	eafff565 	b	57e09424 <puts>
		break;
	case ERR_PROTECTED:
		puts ("Can't write to protected Flash sectors\n");
57e0be8c:	e59f0048 	ldr	r0, [pc, #72]	; 57e0bedc <flash_perror+0xd0>
57e0be90:	eafffffc 	b	57e0be88 <flash_perror+0x7c>
		break;
	case ERR_INVAL:
		puts ("Outside available Flash\n");
57e0be94:	e59f0044 	ldr	r0, [pc, #68]	; 57e0bee0 <flash_perror+0xd4>
57e0be98:	eafffffa 	b	57e0be88 <flash_perror+0x7c>
		break;
	case ERR_ALIGN:
		puts ("Start and/or end address not on sector boundary\n");
57e0be9c:	e59f0040 	ldr	r0, [pc, #64]	; 57e0bee4 <flash_perror+0xd8>
57e0bea0:	eafffff8 	b	57e0be88 <flash_perror+0x7c>
		break;
	case ERR_UNKNOWN_FLASH_VENDOR:
		puts ("Unknown Vendor of Flash\n");
57e0bea4:	e59f003c 	ldr	r0, [pc, #60]	; 57e0bee8 <flash_perror+0xdc>
57e0bea8:	eafffff6 	b	57e0be88 <flash_perror+0x7c>
		break;
	case ERR_UNKNOWN_FLASH_TYPE:
		puts ("Unknown Type of Flash\n");
57e0beac:	e59f0038 	ldr	r0, [pc, #56]	; 57e0beec <flash_perror+0xe0>
57e0beb0:	eafffff4 	b	57e0be88 <flash_perror+0x7c>
		break;
	case ERR_PROG_ERROR:
		puts ("General Flash Programming Error\n");
57e0beb4:	e59f0034 	ldr	r0, [pc, #52]	; 57e0bef0 <flash_perror+0xe4>
57e0beb8:	eafffff2 	b	57e0be88 <flash_perror+0x7c>
		break;
	case ERR_ABORTED:
		puts("Flash Programming Aborted\n");
57e0bebc:	e59f0030 	ldr	r0, [pc, #48]	; 57e0bef4 <flash_perror+0xe8>
57e0bec0:	eafffff0 	b	57e0be88 <flash_perror+0x7c>
		break;
	default:
		printf ("%s[%d] FIXME: rc=%d\n", __FILE__, __LINE__, err);
57e0bec4:	e59f002c 	ldr	r0, [pc, #44]	; 57e0bef8 <flash_perror+0xec>
57e0bec8:	e59f102c 	ldr	r1, [pc, #44]	; 57e0befc <flash_perror+0xf0>
57e0becc:	e3a020e4 	mov	r2, #228	; 0xe4
57e0bed0:	eafff55d 	b	57e0944c <printf>
57e0bed4:	57e32156 	.word	0x57e32156
57e0bed8:	57e32170 	.word	0x57e32170
57e0bedc:	57e32182 	.word	0x57e32182
57e0bee0:	57e321aa 	.word	0x57e321aa
57e0bee4:	57e321c3 	.word	0x57e321c3
57e0bee8:	57e321f4 	.word	0x57e321f4
57e0beec:	57e3220d 	.word	0x57e3220d
57e0bef0:	57e32224 	.word	0x57e32224
57e0bef4:	57e32245 	.word	0x57e32245
57e0bef8:	57e32260 	.word	0x57e32260
57e0befc:	57e32275 	.word	0x57e32275

57e0bf00 <hash_command>:
		printf("%02x", output[i]);
}

int hash_command(const char *algo_name, int verify, cmd_tbl_t *cmdtp, int flag,
		 int argc, char * const argv[])
{
57e0bf00:	e92d4008 	push	{r3, lr}
	struct hash_algo *algo;
	ulong addr, len;
	u8 output[HASH_MAX_DIGEST_SIZE];
	u8 vsum[HASH_MAX_DIGEST_SIZE];

	if (argc < 2)
57e0bf04:	e59d3008 	ldr	r3, [sp, #8]
		printf("%02x", output[i]);
}

int hash_command(const char *algo_name, int verify, cmd_tbl_t *cmdtp, int flag,
		 int argc, char * const argv[])
{
57e0bf08:	e1a01000 	mov	r1, r0
	struct hash_algo *algo;
	ulong addr, len;
	u8 output[HASH_MAX_DIGEST_SIZE];
	u8 vsum[HASH_MAX_DIGEST_SIZE];

	if (argc < 2)
57e0bf0c:	e3530001 	cmp	r3, #1
57e0bf10:	da000001 	ble	57e0bf1c <hash_command+0x1c>
		return CMD_RET_USAGE;

	algo = find_hash_algo(algo_name);
	if (!algo) {
		printf("Unknown hash algorithm '%s'\n", algo_name);
57e0bf14:	e59f0008 	ldr	r0, [pc, #8]	; 57e0bf24 <hash_command+0x24>
57e0bf18:	ebfff54b 	bl	57e0944c <printf>
		if (argc)
			store_result(algo, output, *argv);
	}

	return 0;
}
57e0bf1c:	e3e00000 	mvn	r0, #0
57e0bf20:	e8bd8008 	pop	{r3, pc}
57e0bf24:	57e3227d 	.word	0x57e3227d

57e0bf28 <static_get>:
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
57e0bf28:	e5903000 	ldr	r3, [r0]
57e0bf2c:	e4d32001 	ldrb	r2, [r3], #1
	if (ch=='\0') return EOF;
57e0bf30:	e3520000 	cmp	r2, #0
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
57e0bf34:	e5803000 	str	r3, [r0]
	if (ch=='\0') return EOF;
	return ch;
}
57e0bf38:	11a00002 	movne	r0, r2
57e0bf3c:	03e00000 	mvneq	r0, #0
57e0bf40:	e12fff1e 	bx	lr

57e0bf44 <static_peek>:

static int static_peek(struct in_str *i)
{
	return *i->p;
57e0bf44:	e5903000 	ldr	r3, [r0]
}
57e0bf48:	e5d30000 	ldrb	r0, [r3]
57e0bf4c:	e12fff1e 	bx	lr

57e0bf50 <file_peek>:
static int file_peek(struct in_str *i)
{
#ifndef __U_BOOT__
	if (i->p && *i->p) {
#endif
		return *i->p;
57e0bf50:	e5903000 	ldr	r3, [r0]
		i->p = i->peek_buf;
		debug_printf("b_peek: got a %d\n", *i->p);
		return *i->p;
	}
#endif
}
57e0bf54:	e5d30000 	ldrb	r0, [r3]
57e0bf58:	e12fff1e 	bx	lr

57e0bf5c <is_assignment>:
	}
}

static int is_assignment(const char *s)
{
	if (s == NULL)
57e0bf5c:	e3500000 	cmp	r0, #0
57e0bf60:	012fff1e 	bxeq	lr
		return 0;

	if (!isalpha(*s)) return 0;
57e0bf64:	e59f3040 	ldr	r3, [pc, #64]	; 57e0bfac <is_assignment+0x50>
57e0bf68:	e5d02000 	ldrb	r2, [r0]
57e0bf6c:	e7d32002 	ldrb	r2, [r3, r2]
57e0bf70:	e2122003 	ands	r2, r2, #3
57e0bf74:	0a00000a 	beq	57e0bfa4 <is_assignment+0x48>
	++s;
	while(isalnum(*s) || *s=='_') ++s;
57e0bf78:	e1a02003 	mov	r2, r3
57e0bf7c:	e5f03001 	ldrb	r3, [r0, #1]!
57e0bf80:	e7d21003 	ldrb	r1, [r2, r3]
57e0bf84:	e3110007 	tst	r1, #7
57e0bf88:	1afffffb 	bne	57e0bf7c <is_assignment+0x20>
57e0bf8c:	e353005f 	cmp	r3, #95	; 0x5f
57e0bf90:	0afffff9 	beq	57e0bf7c <is_assignment+0x20>
	return *s=='=';
57e0bf94:	e353003d 	cmp	r3, #61	; 0x3d
57e0bf98:	13a00000 	movne	r0, #0
57e0bf9c:	03a00001 	moveq	r0, #1
57e0bfa0:	e12fff1e 	bx	lr
static int is_assignment(const char *s)
{
	if (s == NULL)
		return 0;

	if (!isalpha(*s)) return 0;
57e0bfa4:	e1a00002 	mov	r0, r2
	++s;
	while(isalnum(*s) || *s=='_') ++s;
	return *s=='=';
}
57e0bfa8:	e12fff1e 	bx	lr
57e0bfac:	57e2d4d0 	.word	0x57e2d4d0

57e0bfb0 <mapset>:
}

static void mapset(const unsigned char *set, int code)
{
	const unsigned char *s;
	for (s=set; *s; s++) map[*s] = code;
57e0bfb0:	e59f2014 	ldr	r2, [pc, #20]	; 57e0bfcc <mapset+0x1c>
57e0bfb4:	ea000000 	b	57e0bfbc <mapset+0xc>
57e0bfb8:	e7c21003 	strb	r1, [r2, r3]
57e0bfbc:	e4d03001 	ldrb	r3, [r0], #1
57e0bfc0:	e3530000 	cmp	r3, #0
57e0bfc4:	1afffffb 	bne	57e0bfb8 <mapset+0x8>
}
57e0bfc8:	e12fff1e 	bx	lr
57e0bfcc:	57e38434 	.word	0x57e38434

57e0bfd0 <syntax_err>:
#endif
#define final_printf debug_printf

#ifdef __U_BOOT__
static void syntax_err(void) {
	 printf("syntax error\n");
57e0bfd0:	e59f0000 	ldr	r0, [pc, #0]	; 57e0bfd8 <syntax_err+0x8>
57e0bfd4:	eafff51c 	b	57e0944c <printf>
57e0bfd8:	57e3229a 	.word	0x57e3229a

57e0bfdc <do_showvar>:
}

#ifdef __U_BOOT__
static int do_showvar(cmd_tbl_t *cmdtp, int flag, int argc,
		      char * const argv[])
{
57e0bfdc:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
57e0bfe0:	e3520001 	cmp	r2, #1
		for (cur = top_vars; cur; cur = cur->next) {
57e0bfe4:	059f30d0 	ldreq	r3, [pc, #208]	; 57e0c0bc <do_showvar+0xe0>
}

#ifdef __U_BOOT__
static int do_showvar(cmd_tbl_t *cmdtp, int flag, int argc,
		      char * const argv[])
{
57e0bfe8:	e58d2004 	str	r2, [sp, #4]
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
57e0bfec:	11a09003 	movne	r9, r3
57e0bff0:	13a04000 	movne	r4, #0
57e0bff4:	13a06001 	movne	r6, #1
		for (cur = top_vars; cur; cur = cur->next) {
57e0bff8:	05934100 	ldreq	r4, [r3, #256]	; 0x100
{
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
57e0bffc:	1a000029 	bne	57e0c0a8 <do_showvar+0xcc>
57e0c000:	ea000006 	b	57e0c020 <do_showvar+0x44>
		for (cur = top_vars; cur; cur = cur->next) {
			printf ("%s=%s\n", cur->name, cur->value);
57e0c004:	e8940006 	ldm	r4, {r1, r2}
57e0c008:	e59f00b0 	ldr	r0, [pc, #176]	; 57e0c0c0 <do_showvar+0xe4>
57e0c00c:	ebfff50e 	bl	57e0944c <printf>
			if (ctrlc ()) {
57e0c010:	ebfff532 	bl	57e094e0 <ctrlc>
57e0c014:	e3500000 	cmp	r0, #0
57e0c018:	1a000014 	bne	57e0c070 <do_showvar+0x94>
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
		for (cur = top_vars; cur; cur = cur->next) {
57e0c01c:	e5944010 	ldr	r4, [r4, #16]
57e0c020:	e3540000 	cmp	r4, #0
57e0c024:	1afffff6 	bne	57e0c004 <do_showvar+0x28>
57e0c028:	ea000021 	b	57e0c0b4 <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
57e0c02c:	e59f2088 	ldr	r2, [pc, #136]	; 57e0c0bc <do_showvar+0xe0>
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];
57e0c030:	e5b97004 	ldr	r7, [r9, #4]!

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
57e0c034:	e5925100 	ldr	r5, [r2, #256]	; 0x100
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
57e0c038:	e3e0b000 	mvn	fp, #0
		for (cur = top_vars; cur; cur = cur->next) {
57e0c03c:	ea000010 	b	57e0c084 <do_showvar+0xa8>
			if(strcmp (cur->name, name) == 0) {
57e0c040:	e5950000 	ldr	r0, [r5]
57e0c044:	e1a01007 	mov	r1, r7
57e0c048:	eb005fd5 	bl	57e23fa4 <strcmp>
57e0c04c:	e250a000 	subs	sl, r0, #0
57e0c050:	1a000003 	bne	57e0c064 <do_showvar+0x88>
				k = 0;
				printf ("%s=%s\n", cur->name, cur->value);
57e0c054:	e59f0064 	ldr	r0, [pc, #100]	; 57e0c0c0 <do_showvar+0xe4>
57e0c058:	e8950006 	ldm	r5, {r1, r2}
57e0c05c:	ebfff4fa 	bl	57e0944c <printf>
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
			if(strcmp (cur->name, name) == 0) {
				k = 0;
57e0c060:	e1a0b00a 	mov	fp, sl
				printf ("%s=%s\n", cur->name, cur->value);
			}
			if (ctrlc ()) {
57e0c064:	ebfff51d 	bl	57e094e0 <ctrlc>
57e0c068:	e3500000 	cmp	r0, #0
57e0c06c:	0a000003 	beq	57e0c080 <do_showvar+0xa4>
				puts ("\n ** Abort\n");
57e0c070:	e59f004c 	ldr	r0, [pc, #76]	; 57e0c0c4 <do_showvar+0xe8>
57e0c074:	ebfff4ea 	bl	57e09424 <puts>
				return 1;
57e0c078:	e3a04001 	mov	r4, #1
57e0c07c:	ea00000c 	b	57e0c0b4 <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
57e0c080:	e5955010 	ldr	r5, [r5, #16]
57e0c084:	e3550000 	cmp	r5, #0
57e0c088:	1affffec 	bne	57e0c040 <do_showvar+0x64>
			if (ctrlc ()) {
				puts ("\n ** Abort\n");
				return 1;
			}
		}
		if (k < 0) {
57e0c08c:	e37b0001 	cmn	fp, #1
57e0c090:	1a000003 	bne	57e0c0a4 <do_showvar+0xc8>
			printf ("## Error: \"%s\" not defined\n", name);
57e0c094:	e59f002c 	ldr	r0, [pc, #44]	; 57e0c0c8 <do_showvar+0xec>
57e0c098:	e1a01007 	mov	r1, r7
57e0c09c:	ebfff4ea 	bl	57e0944c <printf>
			rcode ++;
57e0c0a0:	e2844001 	add	r4, r4, #1
				return 1;
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
57e0c0a4:	e2866001 	add	r6, r6, #1
57e0c0a8:	e59d3004 	ldr	r3, [sp, #4]
57e0c0ac:	e1560003 	cmp	r6, r3
57e0c0b0:	baffffdd 	blt	57e0c02c <do_showvar+0x50>
			printf ("## Error: \"%s\" not defined\n", name);
			rcode ++;
		}
	}
	return rcode;
}
57e0c0b4:	e1a00004 	mov	r0, r4
57e0c0b8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e0c0bc:	57e38434 	.word	0x57e38434
57e0c0c0:	57e30da6 	.word	0x57e30da6
57e0c0c4:	57e322a8 	.word	0x57e322a8
57e0c0c8:	57e30dce 	.word	0x57e30dce

57e0c0cc <xmalloc>:
	}
	return 0;
}

static void *xmalloc(size_t size)
{
57e0c0cc:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = malloc(size))) {
57e0c0d0:	ebfff6bb 	bl	57e09bc4 <malloc>
57e0c0d4:	e3500000 	cmp	r0, #0
57e0c0d8:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
57e0c0dc:	e59f0004 	ldr	r0, [pc, #4]	; 57e0c0e8 <xmalloc+0x1c>
57e0c0e0:	ebfff4d9 	bl	57e0944c <printf>
57e0c0e4:	eafffffe 	b	57e0c0e4 <xmalloc+0x18>
57e0c0e8:	57e322b4 	.word	0x57e322b4

57e0c0ec <new_pipe>:
	return 0;
}
#endif

static struct pipe *new_pipe(void)
{
57e0c0ec:	e92d4008 	push	{r3, lr}
	struct pipe *pi;
	pi = xmalloc(sizeof(struct pipe));
57e0c0f0:	e3a00014 	mov	r0, #20
57e0c0f4:	ebfffff4 	bl	57e0c0cc <xmalloc>
	pi->num_progs = 0;
57e0c0f8:	e3a02000 	mov	r2, #0
57e0c0fc:	e5802000 	str	r2, [r0]
	pi->progs = NULL;
57e0c100:	e5802004 	str	r2, [r0, #4]
	pi->next = NULL;
57e0c104:	e5802008 	str	r2, [r0, #8]
	pi->followup = 0;  /* invalid */
57e0c108:	e580200c 	str	r2, [r0, #12]
	pi->r_mode = RES_NONE;
57e0c10c:	e5802010 	str	r2, [r0, #16]
	return pi;
}
57e0c110:	e8bd8008 	pop	{r3, pc}

57e0c114 <file_get>:
{
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
57e0c114:	e5903000 	ldr	r3, [r0]
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
57e0c118:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
57e0c11c:	e3530000 	cmp	r3, #0
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
57e0c120:	e1a04000 	mov	r4, r0
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
57e0c124:	0a000047 	beq	57e0c248 <file_get+0x134>
57e0c128:	e5d30000 	ldrb	r0, [r3]
57e0c12c:	e3500000 	cmp	r0, #0
57e0c130:	0a000044 	beq	57e0c248 <file_get+0x134>
57e0c134:	ea000056 	b	57e0c294 <file_get+0x180>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
	if (i->promptmode == 1) {
57e0c138:	e5943008 	ldr	r3, [r4, #8]
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
57e0c13c:	e3a02001 	mov	r2, #1
	if (i->promptmode == 1) {
57e0c140:	e1530002 	cmp	r3, r2
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
57e0c144:	e5842004 	str	r2, [r4, #4]
	if (i->promptmode == 1) {
		n = readline(CONFIG_SYS_PROMPT);
57e0c148:	059f0158 	ldreq	r0, [pc, #344]	; 57e0c2a8 <file_get+0x194>
	} else {
		n = readline(CONFIG_SYS_PROMPT_HUSH_PS2);
57e0c14c:	159f0158 	ldrne	r0, [pc, #344]	; 57e0c2ac <file_get+0x198>
57e0c150:	eb000c50 	bl	57e0f298 <readline>
#  else
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
57e0c154:	e3700001 	cmn	r0, #1
		flag_repeat = 0;
		i->__promptme = 0;
57e0c158:	05846004 	streq	r6, [r4, #4]
	}
	n = strlen(console_buffer);
57e0c15c:	e59f014c 	ldr	r0, [pc, #332]	; 57e0c2b0 <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
57e0c160:	05856104 	streq	r6, [r5, #260]	; 0x104
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
57e0c164:	eb005fb9 	bl	57e24050 <strlen>
	console_buffer[n] = '\n';
57e0c168:	e1a03007 	mov	r3, r7
57e0c16c:	e7e3a000 	strb	sl, [r3, r0]!
	console_buffer[n+1]= '\0';
57e0c170:	e5c36001 	strb	r6, [r3, #1]
	if (had_ctrlc()) flag_repeat = 0;
57e0c174:	ebfff4f2 	bl	57e09544 <had_ctrlc>
57e0c178:	e3500000 	cmp	r0, #0
57e0c17c:	15856104 	strne	r6, [r5, #260]	; 0x104
	clear_ctrlc();
57e0c180:	ebfff4f3 	bl	57e09554 <clear_ctrlc>
	do_repeat = 0;
	if (i->promptmode == 1) {
57e0c184:	e5949008 	ldr	r9, [r4, #8]
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
57e0c188:	e5856108 	str	r6, [r5, #264]	; 0x108
	if (i->promptmode == 1) {
57e0c18c:	e3590001 	cmp	r9, #1
57e0c190:	1a000010 	bne	57e0c1d8 <file_get+0xc4>
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
57e0c194:	e5d73000 	ldrb	r3, [r7]
57e0c198:	e353000a 	cmp	r3, #10
57e0c19c:	1a000007 	bne	57e0c1c0 <file_get+0xac>
57e0c1a0:	e5953104 	ldr	r3, [r5, #260]	; 0x104
57e0c1a4:	e3530000 	cmp	r3, #0
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
				flag_repeat = 1;
			}
			else {
				do_repeat = 1;
57e0c1a8:	15859108 	strne	r9, [r5, #264]	; 0x108
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
	if (i->promptmode == 1) {
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
57e0c1ac:	1a000007 	bne	57e0c1d0 <file_get+0xbc>
			strcpy(the_command,console_buffer);
57e0c1b0:	e59f10f8 	ldr	r1, [pc, #248]	; 57e0c2b0 <file_get+0x19c>
57e0c1b4:	e59f00f8 	ldr	r0, [pc, #248]	; 57e0c2b4 <file_get+0x1a0>
57e0c1b8:	eb005f48 	bl	57e23ee0 <strcpy>
57e0c1bc:	ea000003 	b	57e0c1d0 <file_get+0xbc>
		}
		else {
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
57e0c1c0:	e59f00ec 	ldr	r0, [pc, #236]	; 57e0c2b4 <file_get+0x1a0>
57e0c1c4:	e59f10e4 	ldr	r1, [pc, #228]	; 57e0c2b0 <file_get+0x19c>
57e0c1c8:	eb005f44 	bl	57e23ee0 <strcpy>
				flag_repeat = 1;
57e0c1cc:	e5859104 	str	r9, [r5, #260]	; 0x104
			}
			else {
				do_repeat = 1;
			}
		}
		i->p = the_command;
57e0c1d0:	e584b000 	str	fp, [r4]
57e0c1d4:	ea000020 	b	57e0c25c <file_get+0x148>
	}
	else {
		if (console_buffer[0] != '\n') {
57e0c1d8:	e5d73000 	ldrb	r3, [r7]
57e0c1dc:	e353000a 	cmp	r3, #10
57e0c1e0:	0a000012 	beq	57e0c230 <file_get+0x11c>
			if (strlen(the_command) + strlen(console_buffer)
57e0c1e4:	e59f00c8 	ldr	r0, [pc, #200]	; 57e0c2b4 <file_get+0x1a0>
57e0c1e8:	eb005f98 	bl	57e24050 <strlen>
57e0c1ec:	e1a09000 	mov	r9, r0
57e0c1f0:	e59f00b8 	ldr	r0, [pc, #184]	; 57e0c2b0 <file_get+0x19c>
57e0c1f4:	eb005f95 	bl	57e24050 <strlen>
57e0c1f8:	e0800009 	add	r0, r0, r9
57e0c1fc:	e35000ff 	cmp	r0, #255	; 0xff
				n = strlen(the_command);
				the_command[n-1] = ' ';
				strcpy(&the_command[n],console_buffer);
			}
			else {
				the_command[0] = '\n';
57e0c200:	85c5a10c 	strbhi	sl, [r5, #268]	; 0x10c
				the_command[1] = '\0';
57e0c204:	85c5610d 	strbhi	r6, [r5, #269]	; 0x10d
				flag_repeat = 0;
57e0c208:	85856104 	strhi	r6, [r5, #260]	; 0x104
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
57e0c20c:	8a000007 	bhi	57e0c230 <file_get+0x11c>
			    < CONFIG_SYS_CBSIZE) {
				n = strlen(the_command);
57e0c210:	e59f009c 	ldr	r0, [pc, #156]	; 57e0c2b4 <file_get+0x1a0>
57e0c214:	eb005f8d 	bl	57e24050 <strlen>
				the_command[n-1] = ' ';
57e0c218:	e3a02020 	mov	r2, #32
57e0c21c:	e0853000 	add	r3, r5, r0
57e0c220:	e5c3210b 	strb	r2, [r3, #267]	; 0x10b
				strcpy(&the_command[n],console_buffer);
57e0c224:	e08b0000 	add	r0, fp, r0
57e0c228:	e59f1080 	ldr	r1, [pc, #128]	; 57e0c2b0 <file_get+0x19c>
57e0c22c:	eb005f2b 	bl	57e23ee0 <strcpy>
				the_command[0] = '\n';
				the_command[1] = '\0';
				flag_repeat = 0;
			}
		}
		if (i->__promptme == 0) {
57e0c230:	e5943004 	ldr	r3, [r4, #4]
57e0c234:	e3530000 	cmp	r3, #0
			the_command[0] = '\n';
57e0c238:	05c5a10c 	strbeq	sl, [r5, #268]	; 0x10c
			the_command[1] = '\0';
57e0c23c:	05c5310d 	strbeq	r3, [r5, #269]	; 0x10d
		}
		i->p = console_buffer;
57e0c240:	e5847000 	str	r7, [r4]
57e0c244:	ea000004 	b	57e0c25c <file_get+0x148>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
57e0c248:	e59f5068 	ldr	r5, [pc, #104]	; 57e0c2b8 <file_get+0x1a4>
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
57e0c24c:	e59f705c 	ldr	r7, [pc, #92]	; 57e0c2b0 <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
57e0c250:	e3a06000 	mov	r6, #0
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
57e0c254:	e3a0a00a 	mov	sl, #10
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
57e0c258:	e285bf43 	add	fp, r5, #268	; 0x10c
		 * more complicated by now, like sourcing or substituting. */
#ifndef __U_BOOT__
		if (i->__promptme && interactive && i->file == stdin) {
			while(! i->p || (interactive && strlen(i->p)==0) ) {
#else
			while(! i->p  || strlen(i->p)==0 ) {
57e0c25c:	e5940000 	ldr	r0, [r4]
57e0c260:	e3500000 	cmp	r0, #0
57e0c264:	0affffb3 	beq	57e0c138 <file_get+0x24>
57e0c268:	eb005f78 	bl	57e24050 <strlen>
57e0c26c:	e3500000 	cmp	r0, #0
57e0c270:	0affffb0 	beq	57e0c138 <file_get+0x24>
#endif
				get_user_input(i);
			}
			i->promptmode=2;
57e0c274:	e3a03002 	mov	r3, #2
57e0c278:	e5843008 	str	r3, [r4, #8]
#ifndef __U_BOOT__
			i->__promptme = 0;
#endif
			if (i->p && *i->p) {
57e0c27c:	e5943000 	ldr	r3, [r4]
57e0c280:	e3530000 	cmp	r3, #0
57e0c284:	0a000005 	beq	57e0c2a0 <file_get+0x18c>
57e0c288:	e5d30000 	ldrb	r0, [r3]
57e0c28c:	e3500000 	cmp	r0, #0
57e0c290:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
				ch = *i->p++;
57e0c294:	e2833001 	add	r3, r3, #1
57e0c298:	e5843000 	str	r3, [r4]
57e0c29c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
	int ch;

	ch = 0;
57e0c2a0:	e1a00003 	mov	r0, r3
	}
#ifndef __U_BOOT__
	if (ch == '\n') i->__promptme=1;
#endif
	return ch;
}
57e0c2a4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0c2a8:	57e322d2 	.word	0x57e322d2
57e0c2ac:	57e350a1 	.word	0x57e350a1
57e0c2b0:	57e39aec 	.word	0x57e39aec
57e0c2b4:	57e38540 	.word	0x57e38540
57e0c2b8:	57e38434 	.word	0x57e38434

57e0c2bc <free_pipe_list>:
	pi->progs=NULL;
	return ret_code;
}

static int free_pipe_list(struct pipe *head, int indent)
{
57e0c2bc:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rcode=0;   /* if list has no members */
57e0c2c0:	e3a05000 	mov	r5, #0
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
57e0c2c4:	e1a04000 	mov	r4, r0
57e0c2c8:	e1a06005 	mov	r6, r5
			child->argv=NULL;
		} else if (child->group) {
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
57e0c2cc:	e2819003 	add	r9, r1, #3
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
57e0c2d0:	ea000029 	b	57e0c37c <free_pipe_list+0xc0>
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
57e0c2d4:	e5943004 	ldr	r3, [r4, #4]
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
57e0c2d8:	e7932007 	ldr	r2, [r3, r7]
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
57e0c2dc:	e083b007 	add	fp, r3, r7
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
57e0c2e0:	e3520000 	cmp	r2, #0
57e0c2e4:	0a000011 	beq	57e0c330 <free_pipe_list+0x74>
			for (a=0,p=child->argv; *p; a++,p++) {
57e0c2e8:	e4923004 	ldr	r3, [r2], #4
57e0c2ec:	e3530000 	cmp	r3, #0
57e0c2f0:	1afffffc 	bne	57e0c2e8 <free_pipe_list+0x2c>
57e0c2f4:	ea000005 	b	57e0c310 <free_pipe_list+0x54>
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
				free(child->argv[a]);
57e0c2f8:	e59b2000 	ldr	r2, [fp]
57e0c2fc:	e7920103 	ldr	r0, [r2, r3, lsl #2]
57e0c300:	e58d3004 	str	r3, [sp, #4]
57e0c304:	ebfff5a4 	bl	57e0999c <free>
				final_printf("%s   argv[%d] = %s\n",ind,a,*p);
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
57e0c308:	e59d3004 	ldr	r3, [sp, #4]
57e0c30c:	e2833001 	add	r3, r3, #1
57e0c310:	e59b2004 	ldr	r2, [fp, #4]
57e0c314:	e1530002 	cmp	r3, r2
57e0c318:	bafffff6 	blt	57e0c2f8 <free_pipe_list+0x3c>
				free(child->argv[a]);
			}
					free(child->argv);
57e0c31c:	e59b0000 	ldr	r0, [fp]
57e0c320:	ebfff59d 	bl	57e0999c <free>
			child->argc = 0;
57e0c324:	e58b6004 	str	r6, [fp, #4]
#endif
			child->argv=NULL;
57e0c328:	e58b6000 	str	r6, [fp]
57e0c32c:	ea000005 	b	57e0c348 <free_pipe_list+0x8c>
		} else if (child->group) {
57e0c330:	e59b0008 	ldr	r0, [fp, #8]
57e0c334:	e3500000 	cmp	r0, #0
57e0c338:	0a000002 	beq	57e0c348 <free_pipe_list+0x8c>
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
57e0c33c:	e1a01009 	mov	r1, r9
57e0c340:	ebffffdd 	bl	57e0c2bc <free_pipe_list>
57e0c344:	e1a05000 	mov	r5, r0
#ifndef __U_BOOT__
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
57e0c348:	e28aa001 	add	sl, sl, #1
57e0c34c:	e2877014 	add	r7, r7, #20
57e0c350:	e5943000 	ldr	r3, [r4]
57e0c354:	e15a0003 	cmp	sl, r3
57e0c358:	baffffdd 	blt	57e0c2d4 <free_pipe_list+0x18>
			free(r);
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
57e0c35c:	e5940004 	ldr	r0, [r4, #4]
57e0c360:	ebfff58d 	bl	57e0999c <free>
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
57e0c364:	e5947008 	ldr	r7, [r4, #8]
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
	pi->progs=NULL;
57e0c368:	e5846004 	str	r6, [r4, #4]
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
		pi->next=NULL;
57e0c36c:	e5846008 	str	r6, [r4, #8]
		free(pi);
57e0c370:	e1a00004 	mov	r0, r4
57e0c374:	ebfff588 	bl	57e0999c <free>
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
57e0c378:	e1a04007 	mov	r4, r7
57e0c37c:	e3540000 	cmp	r4, #0
57e0c380:	13a05000 	movne	r5, #0
57e0c384:	11a07005 	movne	r7, r5
57e0c388:	11a0a005 	movne	sl, r5
57e0c38c:	1affffef 	bne	57e0c350 <free_pipe_list+0x94>
		next=pi->next;
		pi->next=NULL;
		free(pi);
	}
	return rcode;
}
57e0c390:	e1a00005 	mov	r0, r5
57e0c394:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

57e0c398 <xrealloc>:
	}
	return p;
}

static void *xrealloc(void *ptr, size_t size)
{
57e0c398:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = realloc(ptr, size))) {
57e0c39c:	ebfff7fb 	bl	57e0a390 <realloc>
57e0c3a0:	e3500000 	cmp	r0, #0
57e0c3a4:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
57e0c3a8:	e59f0004 	ldr	r0, [pc, #4]	; 57e0c3b4 <xrealloc+0x1c>
57e0c3ac:	ebfff426 	bl	57e0944c <printf>
57e0c3b0:	eafffffe 	b	57e0c3b0 <xrealloc+0x18>
57e0c3b4:	57e322b4 	.word	0x57e322b4

57e0c3b8 <done_command>:
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;
57e0c3b8:	e5903000 	ldr	r3, [r0]
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
57e0c3bc:	e92d4070 	push	{r4, r5, r6, lr}
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
57e0c3c0:	e3530000 	cmp	r3, #0
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
57e0c3c4:	e1a05000 	mov	r5, r0
	/* The child is really already in the pipe structure, so
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
57e0c3c8:	e5904008 	ldr	r4, [r0, #8]
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
57e0c3cc:	0a000008 	beq	57e0c3f4 <done_command+0x3c>
57e0c3d0:	e5932008 	ldr	r2, [r3, #8]
57e0c3d4:	e3520000 	cmp	r2, #0
57e0c3d8:	1a000002 	bne	57e0c3e8 <done_command+0x30>
		 && prog->argv == NULL
57e0c3dc:	e5933000 	ldr	r3, [r3]
57e0c3e0:	e3530000 	cmp	r3, #0
57e0c3e4:	0a000013 	beq	57e0c438 <done_command+0x80>
										) {
#endif
		debug_printf("done_command: skipping null command\n");
		return 0;
	} else if (prog) {
		pi->num_progs++;
57e0c3e8:	e5943000 	ldr	r3, [r4]
57e0c3ec:	e2833001 	add	r3, r3, #1
57e0c3f0:	e5843000 	str	r3, [r4]
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
57e0c3f4:	e5941000 	ldr	r1, [r4]
57e0c3f8:	e3a06014 	mov	r6, #20
57e0c3fc:	e2811001 	add	r1, r1, #1
57e0c400:	e0010196 	mul	r1, r6, r1
57e0c404:	e5940004 	ldr	r0, [r4, #4]
57e0c408:	ebffffe2 	bl	57e0c398 <xrealloc>

	prog = pi->progs + pi->num_progs;
57e0c40c:	e5943000 	ldr	r3, [r4]
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
57e0c410:	e3a02000 	mov	r2, #0
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));

	prog = pi->progs + pi->num_progs;
57e0c414:	e0060693 	mul	r6, r3, r6
57e0c418:	e0803006 	add	r3, r0, r6
		pi->num_progs++;
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
57e0c41c:	e5840004 	str	r0, [r4, #4]

	prog = pi->progs + pi->num_progs;
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
57e0c420:	e7802006 	str	r2, [r0, r6]
#ifndef __U_BOOT__
	prog->is_stopped = 0;
#endif
	prog->group = NULL;
57e0c424:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
57e0c428:	e583200c 	str	r2, [r3, #12]
	ctx->child = prog;
	prog->type = ctx->type;
57e0c42c:	e5952018 	ldr	r2, [r5, #24]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
	ctx->child = prog;
57e0c430:	e5853000 	str	r3, [r5]
	prog->type = ctx->type;
57e0c434:	e5832010 	str	r2, [r3, #16]

	/* but ctx->pipe and ctx->list_head remain unchanged */
	return 0;
}
57e0c438:	e3a00000 	mov	r0, #0
57e0c43c:	e8bd8070 	pop	{r4, r5, r6, pc}

57e0c440 <done_pipe>:

static int done_pipe(struct p_context *ctx, pipe_style type)
{
57e0c440:	e92d4038 	push	{r3, r4, r5, lr}
57e0c444:	e1a04000 	mov	r4, r0
57e0c448:	e1a05001 	mov	r5, r1
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
57e0c44c:	ebffffd9 	bl	57e0c3b8 <done_command>
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
57e0c450:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe->r_mode = ctx->w;
57e0c454:	e594200c 	ldr	r2, [r4, #12]
static int done_pipe(struct p_context *ctx, pipe_style type)
{
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
57e0c458:	e583500c 	str	r5, [r3, #12]
	ctx->pipe->r_mode = ctx->w;
57e0c45c:	e5832010 	str	r2, [r3, #16]
	new_p=new_pipe();
57e0c460:	ebffff21 	bl	57e0c0ec <new_pipe>
	ctx->pipe->next = new_p;
57e0c464:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe = new_p;
	ctx->child = NULL;
57e0c468:	e3a05000 	mov	r5, #0
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
	ctx->pipe->r_mode = ctx->w;
	new_p=new_pipe();
	ctx->pipe->next = new_p;
57e0c46c:	e5830008 	str	r0, [r3, #8]
	ctx->pipe = new_p;
57e0c470:	e5840008 	str	r0, [r4, #8]
	ctx->child = NULL;
57e0c474:	e5845000 	str	r5, [r4]
	done_command(ctx);  /* set up new pipe to accept commands */
57e0c478:	e1a00004 	mov	r0, r4
57e0c47c:	ebffffcd 	bl	57e0c3b8 <done_command>
	return 0;
}
57e0c480:	e1a00005 	mov	r0, r5
57e0c484:	e8bd8038 	pop	{r3, r4, r5, pc}

57e0c488 <b_addchr>:
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
57e0c488:	e92d4070 	push	{r4, r5, r6, lr}

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
57e0c48c:	e5903004 	ldr	r3, [r0, #4]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
57e0c490:	e1a06001 	mov	r6, r1

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
57e0c494:	e5901008 	ldr	r1, [r0, #8]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
57e0c498:	e1a04000 	mov	r4, r0

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
57e0c49c:	e1530001 	cmp	r3, r1
57e0c4a0:	ba00000a 	blt	57e0c4d0 <b_addchr+0x48>
		char *old_data = o->data;
57e0c4a4:	e5905000 	ldr	r5, [r0]
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
57e0c4a8:	e2813064 	add	r3, r1, #100	; 0x64
57e0c4ac:	e5803008 	str	r3, [r0, #8]
		o->data = realloc(o->data, 1 + o->maxlen);
57e0c4b0:	e2811065 	add	r1, r1, #101	; 0x65
57e0c4b4:	e1a00005 	mov	r0, r5
57e0c4b8:	ebfff7b4 	bl	57e0a390 <realloc>
		if (o->data == NULL) {
57e0c4bc:	e3500000 	cmp	r0, #0
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
		char *old_data = o->data;
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
		o->data = realloc(o->data, 1 + o->maxlen);
57e0c4c0:	e5840000 	str	r0, [r4]
		if (o->data == NULL) {
57e0c4c4:	1a000001 	bne	57e0c4d0 <b_addchr+0x48>
			free(old_data);
57e0c4c8:	e1a00005 	mov	r0, r5
57e0c4cc:	ebfff532 	bl	57e0999c <free>
		}
	}
	return o->data == NULL;
57e0c4d0:	e5943000 	ldr	r3, [r4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
57e0c4d4:	e3530000 	cmp	r3, #0
	o->data[o->length] = ch;
57e0c4d8:	15942004 	ldrne	r2, [r4, #4]
	o->length++;
	o->data[o->length] = '\0';
57e0c4dc:	13a00000 	movne	r0, #0

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
57e0c4e0:	17c36002 	strbne	r6, [r3, r2]
	o->length++;
57e0c4e4:	15943004 	ldrne	r3, [r4, #4]
	o->data[o->length] = '\0';
57e0c4e8:	15942000 	ldrne	r2, [r4]
static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
	o->length++;
57e0c4ec:	12833001 	addne	r3, r3, #1
57e0c4f0:	15843004 	strne	r3, [r4, #4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
57e0c4f4:	03a00001 	moveq	r0, #1
	o->data[o->length] = ch;
	o->length++;
	o->data[o->length] = '\0';
57e0c4f8:	17c20003 	strbne	r0, [r2, r3]
	return 0;
}
57e0c4fc:	e8bd8070 	pop	{r4, r5, r6, pc}

57e0c500 <done_word>:
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
57e0c500:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
57e0c504:	e5903004 	ldr	r3, [r0, #4]
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
57e0c508:	e1a05000 	mov	r5, r0
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
57e0c50c:	e3530000 	cmp	r3, #0
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
57e0c510:	e1a04001 	mov	r4, r1
	struct child_prog *child=ctx->child;
57e0c514:	e5917000 	ldr	r7, [r1]
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
57e0c518:	1a000002 	bne	57e0c528 <done_word+0x28>
57e0c51c:	e5900010 	ldr	r0, [r0, #16]
57e0c520:	e3500000 	cmp	r0, #0
57e0c524:	08bd86f8 	popeq	{r3, r4, r5, r6, r7, r9, sl, pc}
#ifndef __U_BOOT__
	if (ctx->pending_redirect) {
		glob_target = &ctx->pending_redirect->word;
	} else {
#endif
		if (child->group) {
57e0c528:	e5973008 	ldr	r3, [r7, #8]
57e0c52c:	e3530000 	cmp	r3, #0
57e0c530:	0a000001 	beq	57e0c53c <done_word+0x3c>
			syntax();
57e0c534:	ebfffea5 	bl	57e0bfd0 <syntax_err>
57e0c538:	ea0000a1 	b	57e0c7c4 <done_word+0x2c4>
			return 1;  /* syntax error, groups and arglists don't mix */
		}
		if (!child->argv && (ctx->type & FLAG_PARSE_SEMICOLON)) {
57e0c53c:	e5973000 	ldr	r3, [r7]
57e0c540:	e3530000 	cmp	r3, #0
57e0c544:	1a000063 	bne	57e0c6d8 <done_word+0x1d8>
57e0c548:	e5943018 	ldr	r3, [r4, #24]
57e0c54c:	e3130002 	tst	r3, #2
57e0c550:	0a000060 	beq	57e0c6d8 <done_word+0x1d8>
	return 0;
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
57e0c554:	e59fa278 	ldr	sl, [pc, #632]	; 57e0c7d4 <done_word+0x2d4>
57e0c558:	e59f6278 	ldr	r6, [pc, #632]	; 57e0c7d8 <done_word+0x2d8>
static int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
57e0c55c:	e5950000 	ldr	r0, [r5]
57e0c560:	e5961000 	ldr	r1, [r6]
57e0c564:	eb005e8e 	bl	57e23fa4 <strcmp>
57e0c568:	e2509000 	subs	r9, r0, #0
57e0c56c:	1a000050 	bne	57e0c6b4 <done_word+0x1b4>
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
57e0c570:	e5963008 	ldr	r3, [r6, #8]
57e0c574:	e3130b02 	tst	r3, #2048	; 0x800
57e0c578:	0a000025 	beq	57e0c614 <done_word+0x114>
				struct p_context *new = xmalloc(sizeof(struct p_context));
57e0c57c:	e280001c 	add	r0, r0, #28
57e0c580:	ebfffed1 	bl	57e0c0cc <xmalloc>
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
57e0c584:	e594700c 	ldr	r7, [r4, #12]
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
				struct p_context *new = xmalloc(sizeof(struct p_context));
57e0c588:	e1a0a000 	mov	sl, r0
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
57e0c58c:	e357000c 	cmp	r7, #12
57e0c590:	13570006 	cmpne	r7, #6
57e0c594:	13a07000 	movne	r7, #0
57e0c598:	03a07001 	moveq	r7, #1
57e0c59c:	1a00000a 	bne	57e0c5cc <done_word+0xcc>
					syntax();
57e0c5a0:	ebfffe8a 	bl	57e0bfd0 <syntax_err>
					free(new);
57e0c5a4:	e1a0000a 	mov	r0, sl
57e0c5a8:	ebfff4fb 	bl	57e0999c <free>
					ctx->w = RES_SNTX;
57e0c5ac:	e3a0300d 	mov	r3, #13
57e0c5b0:	e584300c 	str	r3, [r4, #12]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0c5b4:	e5953000 	ldr	r3, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
57e0c5b8:	e5859004 	str	r9, [r5, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0c5bc:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
57e0c5c0:	e5859010 	str	r9, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
57e0c5c4:	15c39000 	strbne	r9, [r3]
57e0c5c8:	ea00003d 	b	57e0c6c4 <done_word+0x1c4>
					free(new);
					ctx->w = RES_SNTX;
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
57e0c5cc:	e1a0c004 	mov	ip, r4
57e0c5d0:	e1a0e00a 	mov	lr, sl
57e0c5d4:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
57e0c5d8:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
57e0c5dc:	e89c0007 	ldm	ip, {r0, r1, r2}
57e0c5e0:	e88e0007 	stm	lr, {r0, r1, r2}
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
57e0c5e4:	e5847008 	str	r7, [r4, #8]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
57e0c5e8:	e5847000 	str	r7, [r4]
	ctx->list_head=new_pipe();
57e0c5ec:	ebfffebe 	bl	57e0c0ec <new_pipe>
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
57e0c5f0:	e584700c 	str	r7, [r4, #12]
	ctx->pipe=NULL;
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
57e0c5f4:	e5840004 	str	r0, [r4, #4]
	ctx->pipe=ctx->list_head;
57e0c5f8:	e5840008 	str	r0, [r4, #8]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
57e0c5fc:	e5847014 	str	r7, [r4, #20]
#ifdef __U_BOOT__
	ctx->old_flag=0;
57e0c600:	e5847010 	str	r7, [r4, #16]
#endif
	done_command(ctx);   /* creates the memory for working child */
57e0c604:	e1a00004 	mov	r0, r4
57e0c608:	ebffff6a 	bl	57e0c3b8 <done_command>
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
				initialize_context(ctx);
				ctx->stack=new;
57e0c60c:	e584a014 	str	sl, [r4, #20]
57e0c610:	ea00000b 	b	57e0c644 <done_word+0x144>
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
57e0c614:	e594300c 	ldr	r3, [r4, #12]
57e0c618:	e3530000 	cmp	r3, #0
57e0c61c:	0a000004 	beq	57e0c634 <done_word+0x134>
57e0c620:	e5942010 	ldr	r2, [r4, #16]
57e0c624:	e5963004 	ldr	r3, [r6, #4]
57e0c628:	e1a03352 	asr	r3, r2, r3
57e0c62c:	e3130001 	tst	r3, #1
57e0c630:	1a000003 	bne	57e0c644 <done_word+0x144>
				syntax();
57e0c634:	ebfffe65 	bl	57e0bfd0 <syntax_err>
				ctx->w = RES_SNTX;
57e0c638:	e3a0300d 	mov	r3, #13
57e0c63c:	e584300c 	str	r3, [r4, #12]
57e0c640:	ea000014 	b	57e0c698 <done_word+0x198>
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
57e0c644:	e5963004 	ldr	r3, [r6, #4]
57e0c648:	e584300c 	str	r3, [r4, #12]
			ctx->old_flag = r->flag;
57e0c64c:	e5963008 	ldr	r3, [r6, #8]
			if (ctx->old_flag & FLAG_END) {
57e0c650:	e3130001 	tst	r3, #1
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
			ctx->old_flag = r->flag;
57e0c654:	e5843010 	str	r3, [r4, #16]
			if (ctx->old_flag & FLAG_END) {
57e0c658:	0a00000e 	beq	57e0c698 <done_word+0x198>
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
57e0c65c:	e3a01001 	mov	r1, #1
57e0c660:	e1a00004 	mov	r0, r4
57e0c664:	ebffff75 	bl	57e0c440 <done_pipe>
				old = ctx->stack;
57e0c668:	e594c014 	ldr	ip, [r4, #20]
				old->child->group = ctx->list_head;
57e0c66c:	e5942004 	ldr	r2, [r4, #4]
57e0c670:	e59c3000 	ldr	r3, [ip]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
57e0c674:	e1a0e00c 	mov	lr, ip
			if (ctx->old_flag & FLAG_END) {
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
				old = ctx->stack;
				old->child->group = ctx->list_head;
57e0c678:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
57e0c67c:	e1a06004 	mov	r6, r4
57e0c680:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
57e0c684:	e8a6000f 	stmia	r6!, {r0, r1, r2, r3}
57e0c688:	e89e0007 	ldm	lr, {r0, r1, r2}
57e0c68c:	e8860007 	stm	r6, {r0, r1, r2}
				free(old);
57e0c690:	e1a0000c 	mov	r0, ip
57e0c694:	ebfff4c0 	bl	57e0999c <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0c698:	e5952000 	ldr	r2, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
57e0c69c:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0c6a0:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
57e0c6a4:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
57e0c6a8:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
57e0c6ac:	15c23000 	strbne	r3, [r2]
57e0c6b0:	ea000003 	b	57e0c6c4 <done_word+0x1c4>

static int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
57e0c6b4:	e286600c 	add	r6, r6, #12
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

static int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
57e0c6b8:	e156000a 	cmp	r6, sl
57e0c6bc:	1affffa6 	bne	57e0c55c <done_word+0x5c>
57e0c6c0:	ea000004 	b	57e0c6d8 <done_word+0x1d8>
			syntax();
			return 1;  /* syntax error, groups and arglists don't mix */
		}
		if (!child->argv && (ctx->type & FLAG_PARSE_SEMICOLON)) {
			debug_printf("checking %s for reserved-ness\n",dest->data);
			if (reserved_word(dest,ctx)) return ctx->w==RES_SNTX;
57e0c6c4:	e594000c 	ldr	r0, [r4, #12]
57e0c6c8:	e350000d 	cmp	r0, #13
57e0c6cc:	13a00000 	movne	r0, #0
57e0c6d0:	03a00001 	moveq	r0, #1
57e0c6d4:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
57e0c6d8:	e5953000 	ldr	r3, [r5]
57e0c6dc:	e3a00001 	mov	r0, #1
57e0c6e0:	ea000003 	b	57e0c6f4 <done_word+0x1f4>
			if (*s == '\\') s++;
57e0c6e4:	e352005c 	cmp	r2, #92	; 0x5c
57e0c6e8:	02833001 	addeq	r3, r3, #1
			cnt++;
57e0c6ec:	e2800001 	add	r0, r0, #1
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
57e0c6f0:	e2833001 	add	r3, r3, #1
57e0c6f4:	e3530000 	cmp	r3, #0
57e0c6f8:	0a000002 	beq	57e0c708 <done_word+0x208>
57e0c6fc:	e5d32000 	ldrb	r2, [r3]
57e0c700:	e3520000 	cmp	r2, #0
57e0c704:	1afffff6 	bne	57e0c6e4 <done_word+0x1e4>
			if (*s == '\\') s++;
			cnt++;
		}
		str = malloc(cnt);
57e0c708:	ebfff52d 	bl	57e09bc4 <malloc>
		if (!str) return 1;
57e0c70c:	e2506000 	subs	r6, r0, #0
57e0c710:	0a00002b 	beq	57e0c7c4 <done_word+0x2c4>
		if ( child->argv == NULL) {
57e0c714:	e5970000 	ldr	r0, [r7]
57e0c718:	e3500000 	cmp	r0, #0
			child->argc=0;
57e0c71c:	05870004 	streq	r0, [r7, #4]
		}
		argc = ++child->argc;
57e0c720:	e5979004 	ldr	r9, [r7, #4]
57e0c724:	e289a001 	add	sl, r9, #1
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
57e0c728:	e28a1001 	add	r1, sl, #1
		str = malloc(cnt);
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
57e0c72c:	e587a004 	str	sl, [r7, #4]
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
57e0c730:	e1a01101 	lsl	r1, r1, #2
57e0c734:	ebfff715 	bl	57e0a390 <realloc>
		if (child->argv == NULL) return 1;
57e0c738:	e3500000 	cmp	r0, #0
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
57e0c73c:	e5870000 	str	r0, [r7]
		if (child->argv == NULL) return 1;
57e0c740:	0a00001f 	beq	57e0c7c4 <done_word+0x2c4>
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
57e0c744:	e3a03000 	mov	r3, #0
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
57e0c748:	e7806109 	str	r6, [r0, r9, lsl #2]
		child->argv[argc]=NULL;
57e0c74c:	e780310a 	str	r3, [r0, sl, lsl #2]
		for (s = dest->data; s && *s; s++,str++) {
57e0c750:	e5953000 	ldr	r3, [r5]
57e0c754:	ea000003 	b	57e0c768 <done_word+0x268>
			if (*s == '\\') s++;
57e0c758:	e352005c 	cmp	r2, #92	; 0x5c
57e0c75c:	02833001 	addeq	r3, r3, #1
			*str = *s;
57e0c760:	e4d32001 	ldrb	r2, [r3], #1
57e0c764:	e4c62001 	strb	r2, [r6], #1
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
		for (s = dest->data; s && *s; s++,str++) {
57e0c768:	e3530000 	cmp	r3, #0
57e0c76c:	0a000002 	beq	57e0c77c <done_word+0x27c>
57e0c770:	e5d32000 	ldrb	r2, [r3]
57e0c774:	e3520000 	cmp	r2, #0
57e0c778:	1afffff6 	bne	57e0c758 <done_word+0x258>
			if (*s == '\\') s++;
			*str = *s;
		}
		*str = '\0';
57e0c77c:	e3a03000 	mov	r3, #0
57e0c780:	e5c63000 	strb	r3, [r6]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0c784:	e5952000 	ldr	r2, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
57e0c788:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0c78c:	e1520003 	cmp	r2, r3
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
57e0c790:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
57e0c794:	15c23000 	strbne	r3, [r2]
		}
	} else {
		child->argv = glob_target->gl_pathv;
	}
#endif
	if (ctx->w == RES_FOR) {
57e0c798:	e594300c 	ldr	r3, [r4, #12]
57e0c79c:	e3530006 	cmp	r3, #6
57e0c7a0:	1a000009 	bne	57e0c7cc <done_word+0x2cc>
		done_word(dest,ctx);
57e0c7a4:	e1a01004 	mov	r1, r4
57e0c7a8:	e1a00005 	mov	r0, r5
57e0c7ac:	ebffff53 	bl	57e0c500 <done_word>
		done_pipe(ctx,PIPE_SEQ);
57e0c7b0:	e1a00004 	mov	r0, r4
57e0c7b4:	e3a01001 	mov	r1, #1
57e0c7b8:	ebffff20 	bl	57e0c440 <done_pipe>
	}
	return 0;
57e0c7bc:	e3a00000 	mov	r0, #0
57e0c7c0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
57e0c7c4:	e3a00001 	mov	r0, #1
57e0c7c8:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
#endif
	if (ctx->w == RES_FOR) {
		done_word(dest,ctx);
		done_pipe(ctx,PIPE_SEQ);
	}
	return 0;
57e0c7cc:	e3a00000 	mov	r0, #0
}
57e0c7d0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
57e0c7d4:	57e36e60 	.word	0x57e36e60
57e0c7d8:	57e36ddc 	.word	0x57e36ddc

57e0c7dc <b_addqchr>:
/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
	if (quote && strchr("*?[\\",ch)) {
57e0c7dc:	e3520000 	cmp	r2, #0

/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
57e0c7e0:	e92d4070 	push	{r4, r5, r6, lr}
57e0c7e4:	e1a04000 	mov	r4, r0
57e0c7e8:	e1a05001 	mov	r5, r1
	if (quote && strchr("*?[\\",ch)) {
57e0c7ec:	0a000008 	beq	57e0c814 <b_addqchr+0x38>
57e0c7f0:	e59f002c 	ldr	r0, [pc, #44]	; 57e0c824 <b_addqchr+0x48>
57e0c7f4:	eb005e08 	bl	57e2401c <strchr>
57e0c7f8:	e3500000 	cmp	r0, #0
57e0c7fc:	0a000004 	beq	57e0c814 <b_addqchr+0x38>
		int rc;
		rc = b_addchr(o, '\\');
57e0c800:	e1a00004 	mov	r0, r4
57e0c804:	e3a0105c 	mov	r1, #92	; 0x5c
57e0c808:	ebffff1e 	bl	57e0c488 <b_addchr>
		if (rc) return rc;
57e0c80c:	e3500000 	cmp	r0, #0
57e0c810:	18bd8070 	popne	{r4, r5, r6, pc}
	}
	return b_addchr(o, ch);
57e0c814:	e1a00004 	mov	r0, r4
57e0c818:	e1a01005 	mov	r1, r5
}
57e0c81c:	e8bd4070 	pop	{r4, r5, r6, lr}
	if (quote && strchr("*?[\\",ch)) {
		int rc;
		rc = b_addchr(o, '\\');
		if (rc) return rc;
	}
	return b_addchr(o, ch);
57e0c820:	eaffff18 	b	57e0c488 <b_addchr>
57e0c824:	57e322de 	.word	0x57e322de

57e0c828 <get_local_var>:
static char *get_dollar_var(char ch);
#endif

/* This is used to get/check local shell variables */
char *get_local_var(const char *s)
{
57e0c828:	e92d4038 	push	{r3, r4, r5, lr}
	struct variables *cur;

	if (!s)
57e0c82c:	e2505000 	subs	r5, r0, #0
57e0c830:	0a00001c 	beq	57e0c8a8 <get_local_var+0x80>
		return NULL;

#ifdef __U_BOOT__
	if (*s == '$')
57e0c834:	e5d53000 	ldrb	r3, [r5]
57e0c838:	e59f4070 	ldr	r4, [pc, #112]	; 57e0c8b0 <get_local_var+0x88>
57e0c83c:	e3530024 	cmp	r3, #36	; 0x24
57e0c840:	1a00000a 	bne	57e0c870 <get_local_var+0x48>
		return get_dollar_var(s[1]);
57e0c844:	e5d53001 	ldrb	r3, [r5, #1]
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
57e0c848:	e3a00000 	mov	r0, #0
	switch (ch) {
57e0c84c:	e353003f 	cmp	r3, #63	; 0x3f
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
57e0c850:	e5c4020c 	strb	r0, [r4, #524]	; 0x20c
	switch (ch) {
57e0c854:	18bd8038 	popne	{r3, r4, r5, pc}
		case '?':
			sprintf(buf, "%u", (unsigned int)last_return_code);
57e0c858:	e2840f83 	add	r0, r4, #524	; 0x20c
57e0c85c:	e59f1050 	ldr	r1, [pc, #80]	; 57e0c8b4 <get_local_var+0x8c>
57e0c860:	e5942234 	ldr	r2, [r4, #564]	; 0x234
57e0c864:	eb0062b7 	bl	57e25348 <sprintf>
			break;
		default:
			return NULL;
	}
	return buf;
57e0c868:	e2840f83 	add	r0, r4, #524	; 0x20c
57e0c86c:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
57e0c870:	e5944100 	ldr	r4, [r4, #256]	; 0x100
57e0c874:	ea000007 	b	57e0c898 <get_local_var+0x70>
		if(strcmp(cur->name, s)==0)
57e0c878:	e5940000 	ldr	r0, [r4]
57e0c87c:	e1a01005 	mov	r1, r5
57e0c880:	eb005dc7 	bl	57e23fa4 <strcmp>
57e0c884:	e3500000 	cmp	r0, #0
57e0c888:	1a000001 	bne	57e0c894 <get_local_var+0x6c>
			return cur->value;
57e0c88c:	e5940004 	ldr	r0, [r4, #4]
57e0c890:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
57e0c894:	e5944010 	ldr	r4, [r4, #16]
57e0c898:	e3540000 	cmp	r4, #0
57e0c89c:	1afffff5 	bne	57e0c878 <get_local_var+0x50>
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
57e0c8a0:	e1a00004 	mov	r0, r4
57e0c8a4:	e8bd8038 	pop	{r3, r4, r5, pc}
char *get_local_var(const char *s)
{
	struct variables *cur;

	if (!s)
		return NULL;
57e0c8a8:	e1a00005 	mov	r0, r5

	for (cur = top_vars; cur; cur=cur->next)
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
}
57e0c8ac:	e8bd8038 	pop	{r3, r4, r5, pc}
57e0c8b0:	57e38434 	.word	0x57e38434
57e0c8b4:	57e322e3 	.word	0x57e322e3

57e0c8b8 <set_local_var>:
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
57e0c8b8:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
57e0c8bc:	e59f219c 	ldr	r2, [pc, #412]	; 57e0ca60 <set_local_var+0x1a8>
57e0c8c0:	e5d03000 	ldrb	r3, [r0]
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
57e0c8c4:	e1a07001 	mov	r7, r1
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
57e0c8c8:	e7d23003 	ldrb	r3, [r2, r3]
57e0c8cc:	e3130003 	tst	r3, #3
57e0c8d0:	0a00005a 	beq	57e0ca40 <set_local_var+0x188>
		return -1;
#endif

	name=strdup(s);
57e0c8d4:	eb005dfd 	bl	57e240d0 <strdup>
57e0c8d8:	e1a05000 	mov	r5, r0

#ifdef __U_BOOT__
	if (getenv(name) != NULL) {
57e0c8dc:	ebffeb81 	bl	57e076e8 <getenv>
57e0c8e0:	e2504000 	subs	r4, r0, #0
57e0c8e4:	0a000004 	beq	57e0c8fc <set_local_var+0x44>
		printf ("ERROR: "
57e0c8e8:	e59f0174 	ldr	r0, [pc, #372]	; 57e0ca64 <set_local_var+0x1ac>
57e0c8ec:	ebfff2d6 	bl	57e0944c <printf>
				"There is a global environment variable with the same name.\n");
		free(name);
57e0c8f0:	e1a00005 	mov	r0, r5
57e0c8f4:	ebfff428 	bl	57e0999c <free>
57e0c8f8:	ea000050 	b	57e0ca40 <set_local_var+0x188>
	}
#endif
	/* Assume when we enter this function that we are already in
	 * NAME=VALUE format.  So the first order of business is to
	 * split 's' on the '=' into 'name' and 'value' */
	value = strchr(name, '=');
57e0c8fc:	e1a00005 	mov	r0, r5
57e0c900:	e3a0103d 	mov	r1, #61	; 0x3d
57e0c904:	eb005dc4 	bl	57e2401c <strchr>
	if (value == NULL && ++value == NULL) {
		free(name);
		return -1;
	}
	*value++ = 0;
57e0c908:	e3500000 	cmp	r0, #0
57e0c90c:	11a06000 	movne	r6, r0
57e0c910:	03a06001 	moveq	r6, #1

	for(cur = top_vars; cur; cur = cur->next) {
57e0c914:	e59f314c 	ldr	r3, [pc, #332]	; 57e0ca68 <set_local_var+0x1b0>
	value = strchr(name, '=');
	if (value == NULL && ++value == NULL) {
		free(name);
		return -1;
	}
	*value++ = 0;
57e0c918:	e4c64001 	strb	r4, [r6], #1

	for(cur = top_vars; cur; cur = cur->next) {
57e0c91c:	e5934100 	ldr	r4, [r3, #256]	; 0x100
57e0c920:	ea000005 	b	57e0c93c <set_local_var+0x84>
		if(strcmp(cur->name, name)==0)
57e0c924:	e5940000 	ldr	r0, [r4]
57e0c928:	e1a01005 	mov	r1, r5
57e0c92c:	eb005d9c 	bl	57e23fa4 <strcmp>
57e0c930:	e3500000 	cmp	r0, #0
57e0c934:	0a000003 	beq	57e0c948 <set_local_var+0x90>
		free(name);
		return -1;
	}
	*value++ = 0;

	for(cur = top_vars; cur; cur = cur->next) {
57e0c938:	e5944010 	ldr	r4, [r4, #16]
57e0c93c:	e3540000 	cmp	r4, #0
57e0c940:	1afffff7 	bne	57e0c924 <set_local_var+0x6c>
57e0c944:	ea000040 	b	57e0ca4c <set_local_var+0x194>
		if(strcmp(cur->name, name)==0)
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
57e0c948:	e5940004 	ldr	r0, [r4, #4]
57e0c94c:	e1a01006 	mov	r1, r6
57e0c950:	eb005d93 	bl	57e23fa4 <strcmp>
57e0c954:	e3500000 	cmp	r0, #0
57e0c958:	1a000007 	bne	57e0c97c <set_local_var+0xc4>
			if(flg_export>0 && cur->flg_export==0)
57e0c95c:	e3570000 	cmp	r7, #0
57e0c960:	da000030 	ble	57e0ca28 <set_local_var+0x170>
57e0c964:	e5943008 	ldr	r3, [r4, #8]
57e0c968:	e3530000 	cmp	r3, #0
				cur->flg_export=flg_export;
57e0c96c:	05847008 	streq	r7, [r4, #8]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
57e0c970:	01a04003 	moveq	r4, r3
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
57e0c974:	0a00002e 	beq	57e0ca34 <set_local_var+0x17c>
57e0c978:	ea00002a 	b	57e0ca28 <set_local_var+0x170>
				cur->flg_export=flg_export;
			else
				result++;
		} else {
			if(cur->flg_read_only) {
57e0c97c:	e594300c 	ldr	r3, [r4, #12]
57e0c980:	e3530000 	cmp	r3, #0
57e0c984:	0a000003 	beq	57e0c998 <set_local_var+0xe0>
				error_msg("%s: readonly variable", name);
57e0c988:	e1a01005 	mov	r1, r5
57e0c98c:	e59f00d8 	ldr	r0, [pc, #216]	; 57e0ca6c <set_local_var+0x1b4>
57e0c990:	ebfff2ad 	bl	57e0944c <printf>
57e0c994:	ea000025 	b	57e0ca30 <set_local_var+0x178>
				result = -1;
			} else {
				if(flg_export>0 || cur->flg_export>1)
57e0c998:	e3570000 	cmp	r7, #0
57e0c99c:	ca000002 	bgt	57e0c9ac <set_local_var+0xf4>
57e0c9a0:	e5943008 	ldr	r3, [r4, #8]
57e0c9a4:	e3530001 	cmp	r3, #1
57e0c9a8:	da000001 	ble	57e0c9b4 <set_local_var+0xfc>
					cur->flg_export=1;
57e0c9ac:	e3a03001 	mov	r3, #1
57e0c9b0:	e5843008 	str	r3, [r4, #8]
				free(cur->value);
57e0c9b4:	e5940004 	ldr	r0, [r4, #4]
57e0c9b8:	ebfff3f7 	bl	57e0999c <free>

				cur->value = strdup(value);
57e0c9bc:	e1a00006 	mov	r0, r6
57e0c9c0:	eb005dc2 	bl	57e240d0 <strdup>
57e0c9c4:	e5840004 	str	r0, [r4, #4]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
57e0c9c8:	e3a04000 	mov	r4, #0
57e0c9cc:	ea000018 	b	57e0ca34 <set_local_var+0x17c>
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
57e0c9d0:	e1a00005 	mov	r0, r5
57e0c9d4:	eb005dbd 	bl	57e240d0 <strdup>
			if (cur->name == NULL) {
57e0c9d8:	e3500000 	cmp	r0, #0
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
57e0c9dc:	e58a0000 	str	r0, [sl]
			if (cur->name == NULL) {
57e0c9e0:	1a000002 	bne	57e0c9f0 <set_local_var+0x138>
				free(cur);
57e0c9e4:	e1a0000a 	mov	r0, sl
57e0c9e8:	ebfff3eb 	bl	57e0999c <free>
57e0c9ec:	ea00000f 	b	57e0ca30 <set_local_var+0x178>
				result = -1;
			} else {
				struct variables *bottom = top_vars;
57e0c9f0:	e59f3070 	ldr	r3, [pc, #112]	; 57e0ca68 <set_local_var+0x1b0>
				cur->value = strdup(value);
57e0c9f4:	e1a00006 	mov	r0, r6
			cur->name = strdup(name);
			if (cur->name == NULL) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
57e0c9f8:	e5939100 	ldr	r9, [r3, #256]	; 0x100
				cur->value = strdup(value);
57e0c9fc:	eb005db3 	bl	57e240d0 <strdup>
				cur->next = NULL;
57e0ca00:	e58a4010 	str	r4, [sl, #16]
			if (cur->name == NULL) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
				cur->value = strdup(value);
57e0ca04:	e98a0081 	stmib	sl, {r0, r7}
				cur->next = NULL;
				cur->flg_export = flg_export;
				cur->flg_read_only = 0;
57e0ca08:	e58a400c 	str	r4, [sl, #12]
				while(bottom->next) bottom=bottom->next;
57e0ca0c:	ea000000 	b	57e0ca14 <set_local_var+0x15c>
57e0ca10:	e1a09004 	mov	r9, r4
57e0ca14:	e5994010 	ldr	r4, [r9, #16]
57e0ca18:	e3540000 	cmp	r4, #0
57e0ca1c:	1afffffb 	bne	57e0ca10 <set_local_var+0x158>
				bottom->next = cur;
57e0ca20:	e589a010 	str	sl, [r9, #16]
57e0ca24:	ea000002 	b	57e0ca34 <set_local_var+0x17c>
	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
				cur->flg_export=flg_export;
			else
				result++;
57e0ca28:	e3a04001 	mov	r4, #1
57e0ca2c:	ea000000 	b	57e0ca34 <set_local_var+0x17c>
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
57e0ca30:	e3e04000 	mvn	r4, #0
	if(result==0 && cur->flg_export==1) {
		*(value-1) = '=';
		result = putenv(name);
	} else {
#endif
		free(name);
57e0ca34:	e1a00005 	mov	r0, r5
57e0ca38:	ebfff3d7 	bl	57e0999c <free>
#ifndef __U_BOOT__
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
57e0ca3c:	ea000000 	b	57e0ca44 <set_local_var+0x18c>
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
		return -1;
57e0ca40:	e3e04000 	mvn	r4, #0
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
}
57e0ca44:	e1a00004 	mov	r0, r4
57e0ca48:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

				cur->value = strdup(value);
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
57e0ca4c:	e3a00014 	mov	r0, #20
57e0ca50:	ebfff45b 	bl	57e09bc4 <malloc>
		if(!cur) {
57e0ca54:	e250a000 	subs	sl, r0, #0
57e0ca58:	1affffdc 	bne	57e0c9d0 <set_local_var+0x118>
57e0ca5c:	eafffff3 	b	57e0ca30 <set_local_var+0x178>
57e0ca60:	57e2d4d0 	.word	0x57e2d4d0
57e0ca64:	57e322e6 	.word	0x57e322e6
57e0ca68:	57e38434 	.word	0x57e38434
57e0ca6c:	57e32329 	.word	0x57e32329

57e0ca70 <insert_var_value_sub>:
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
57e0ca70:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;
57e0ca74:	e3a04000 	mov	r4, #0
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
57e0ca78:	e1a09000 	mov	r9, r0
57e0ca7c:	e58d100c 	str	r1, [sp, #12]
	int res_str_len = 0;
	int len;
	int done = 0;
57e0ca80:	e1a05004 	mov	r5, r4
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
	int res_str_len = 0;
57e0ca84:	e1a07004 	mov	r7, r4
57e0ca88:	e1a06004 	mov	r6, r4
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
57e0ca8c:	ea00008a 	b	57e0ccbc <insert_var_value_sub+0x24c>
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
57e0ca90:	e15b0009 	cmp	fp, r9
57e0ca94:	0a00000a 	beq	57e0cac4 <insert_var_value_sub+0x54>
			/* copy any charachters to the result string */
			len = p - inp;
57e0ca98:	e069500b 	rsb	r5, r9, fp
			res_str = xrealloc(res_str, (res_str_len + len));
57e0ca9c:	e0854007 	add	r4, r5, r7
57e0caa0:	e1a00006 	mov	r0, r6
57e0caa4:	e1a01004 	mov	r1, r4
57e0caa8:	ebfffe3a 	bl	57e0c398 <xrealloc>
			strncpy((res_str + res_str_len), inp, len);
57e0caac:	e1a01009 	mov	r1, r9
	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
			/* copy any charachters to the result string */
			len = p - inp;
			res_str = xrealloc(res_str, (res_str_len + len));
57e0cab0:	e1a06000 	mov	r6, r0
			strncpy((res_str + res_str_len), inp, len);
57e0cab4:	e1a02005 	mov	r2, r5
57e0cab8:	e0800007 	add	r0, r0, r7
57e0cabc:	eb005d0e 	bl	57e23efc <strncpy>
			res_str_len += len;
57e0cac0:	e1a07004 	mov	r7, r4
		}
		inp = ++p;
57e0cac4:	e28bb001 	add	fp, fp, #1
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
57e0cac8:	e1a0000b 	mov	r0, fp
57e0cacc:	e3a01003 	mov	r1, #3
57e0cad0:	eb005d51 	bl	57e2401c <strchr>
		*p = '\0';
57e0cad4:	e3a03000 	mov	r3, #0
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
57e0cad8:	e35b0000 	cmp	fp, #0
			strncpy((res_str + res_str_len), inp, len);
			res_str_len += len;
		}
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
57e0cadc:	e1a09000 	mov	r9, r0
		*p = '\0';
57e0cae0:	e5c03000 	strb	r3, [r0]
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
57e0cae4:	0a000071 	beq	57e0ccb0 <insert_var_value_sub+0x240>
		return NULL;

	sep = strchr(src, ':');
57e0cae8:	e1a0000b 	mov	r0, fp
57e0caec:	e3a0103a 	mov	r1, #58	; 0x3a
57e0caf0:	eb005d49 	bl	57e2401c <strchr>

	if (sep) {
57e0caf4:	e250a000 	subs	sl, r0, #0
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
57e0caf8:	01a0500a 	moveq	r5, sl
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
57e0cafc:	01a0200a 	moveq	r2, sl
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
57e0cb00:	01a0400a 	moveq	r4, sl
	if (!src)
		return NULL;

	sep = strchr(src, ':');

	if (sep) {
57e0cb04:	0a000013 	beq	57e0cb58 <insert_var_value_sub+0xe8>
		*sep = '\0';
57e0cb08:	e3a03000 	mov	r3, #0
57e0cb0c:	e5ca3000 	strb	r3, [sl]
		if (*(sep + 1) == '-')
57e0cb10:	e5da3001 	ldrb	r3, [sl, #1]
57e0cb14:	e353002d 	cmp	r3, #45	; 0x2d
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
57e0cb18:	03a05000 	moveq	r5, #0
	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
57e0cb1c:	028a4002 	addeq	r4, sl, #2
57e0cb20:	01a02005 	moveq	r2, r5

	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
57e0cb24:	0a00000b 	beq	57e0cb58 <insert_var_value_sub+0xe8>
			default_val = sep+2;
		if (*(sep + 1) == '=') {
57e0cb28:	e353003d 	cmp	r3, #61	; 0x3d
			default_val = sep+2;
57e0cb2c:	028a4002 	addeq	r4, sl, #2
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
57e0cb30:	03a05000 	moveq	r5, #0
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
57e0cb34:	03a02001 	moveq	r2, #1

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
57e0cb38:	0a000006 	beq	57e0cb58 <insert_var_value_sub+0xe8>
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
57e0cb3c:	e353002b 	cmp	r3, #43	; 0x2b
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
57e0cb40:	13a05000 	movne	r5, #0
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
57e0cb44:	028a4002 	addeq	r4, sl, #2
			expand_empty = 1;
57e0cb48:	03a05001 	moveq	r5, #1
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
57e0cb4c:	03a02000 	moveq	r2, #0
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
57e0cb50:	11a02005 	movne	r2, r5
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
57e0cb54:	11a04005 	movne	r4, r5
			default_val = sep+2;
			expand_empty = 1;
		}
	}

	p = getenv(src);
57e0cb58:	e1a0000b 	mov	r0, fp
57e0cb5c:	e58d2004 	str	r2, [sp, #4]
57e0cb60:	ebffeae0 	bl	57e076e8 <getenv>
	if (!p)
57e0cb64:	e2503000 	subs	r3, r0, #0
57e0cb68:	e59d2004 	ldr	r2, [sp, #4]
57e0cb6c:	1a000004 	bne	57e0cb84 <insert_var_value_sub+0x114>
		p = get_local_var(src);
57e0cb70:	e1a0000b 	mov	r0, fp
57e0cb74:	ebffff2b 	bl	57e0c828 <get_local_var>

	if (!p || strlen(p) == 0) {
57e0cb78:	e2503000 	subs	r3, r0, #0
57e0cb7c:	e59d2004 	ldr	r2, [sp, #4]
57e0cb80:	0a000005 	beq	57e0cb9c <insert_var_value_sub+0x12c>
57e0cb84:	e1a00003 	mov	r0, r3
57e0cb88:	e98d000c 	stmib	sp, {r2, r3}
57e0cb8c:	eb005d2f 	bl	57e24050 <strlen>
57e0cb90:	e3500000 	cmp	r0, #0
57e0cb94:	e99d000c 	ldmib	sp, {r2, r3}
57e0cb98:	1a000015 	bne	57e0cbf4 <insert_var_value_sub+0x184>
		p = default_val;
		if (assign) {
57e0cb9c:	e3520000 	cmp	r2, #0
57e0cba0:	0a00001b 	beq	57e0cc14 <insert_var_value_sub+0x1a4>
			char *var = malloc(strlen(src)+strlen(default_val)+2);
57e0cba4:	e1a0000b 	mov	r0, fp
57e0cba8:	eb005d28 	bl	57e24050 <strlen>
57e0cbac:	e1a05000 	mov	r5, r0
57e0cbb0:	e1a00004 	mov	r0, r4
57e0cbb4:	eb005d25 	bl	57e24050 <strlen>
57e0cbb8:	e0850000 	add	r0, r5, r0
57e0cbbc:	e2800002 	add	r0, r0, #2
57e0cbc0:	ebfff3ff 	bl	57e09bc4 <malloc>
			if (var) {
57e0cbc4:	e2505000 	subs	r5, r0, #0
57e0cbc8:	0a000006 	beq	57e0cbe8 <insert_var_value_sub+0x178>
				sprintf(var, "%s=%s", src, default_val);
57e0cbcc:	e59f1164 	ldr	r1, [pc, #356]	; 57e0cd38 <insert_var_value_sub+0x2c8>
57e0cbd0:	e1a0200b 	mov	r2, fp
57e0cbd4:	e1a03004 	mov	r3, r4
57e0cbd8:	eb0061da 	bl	57e25348 <sprintf>
				set_local_var(var, 0);
57e0cbdc:	e1a00005 	mov	r0, r5
57e0cbe0:	e3a01000 	mov	r1, #0
57e0cbe4:	ebffff33 	bl	57e0c8b8 <set_local_var>
			}
			free(var);
57e0cbe8:	e1a00005 	mov	r0, r5
57e0cbec:	ebfff36a 	bl	57e0999c <free>
57e0cbf0:	ea000007 	b	57e0cc14 <insert_var_value_sub+0x1a4>
		}
	} else if (expand_empty) {
57e0cbf4:	e3550000 	cmp	r5, #0
57e0cbf8:	01a04003 	moveq	r4, r3
57e0cbfc:	0a000004 	beq	57e0cc14 <insert_var_value_sub+0x1a4>
		p += strlen(p);
57e0cc00:	e1a00003 	mov	r0, r3
57e0cc04:	e58d3008 	str	r3, [sp, #8]
57e0cc08:	eb005d10 	bl	57e24050 <strlen>
57e0cc0c:	e59d3008 	ldr	r3, [sp, #8]
57e0cc10:	e0834000 	add	r4, r3, r0
	}

	if (sep)
57e0cc14:	e35a0000 	cmp	sl, #0
		*sep = ':';
57e0cc18:	13a0303a 	movne	r3, #58	; 0x3a
57e0cc1c:	15ca3000 	strbne	r3, [sl]
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
		*p = '\0';
		/* look up the value to substitute */
		if ((p1 = lookup_param(inp))) {
57e0cc20:	e3540000 	cmp	r4, #0
57e0cc24:	0a000021 	beq	57e0ccb0 <insert_var_value_sub+0x240>
			if (tag_subst)
57e0cc28:	e59d300c 	ldr	r3, [sp, #12]
57e0cc2c:	e3530000 	cmp	r3, #0
57e0cc30:	0a000004 	beq	57e0cc48 <insert_var_value_sub+0x1d8>
				len = res_str_len + strlen(p1) + 2;
57e0cc34:	e1a00004 	mov	r0, r4
57e0cc38:	eb005d04 	bl	57e24050 <strlen>
57e0cc3c:	e2875002 	add	r5, r7, #2
57e0cc40:	e0855000 	add	r5, r5, r0
57e0cc44:	ea000002 	b	57e0cc54 <insert_var_value_sub+0x1e4>
			else
				len = res_str_len + strlen(p1);
57e0cc48:	e1a00004 	mov	r0, r4
57e0cc4c:	eb005cff 	bl	57e24050 <strlen>
57e0cc50:	e0805007 	add	r5, r0, r7
			res_str = xrealloc(res_str, (1 + len));
57e0cc54:	e1a00006 	mov	r0, r6
57e0cc58:	e2851001 	add	r1, r5, #1
57e0cc5c:	ebfffdcd 	bl	57e0c398 <xrealloc>
			if (tag_subst) {
57e0cc60:	e59d300c 	ldr	r3, [sp, #12]
		if ((p1 = lookup_param(inp))) {
			if (tag_subst)
				len = res_str_len + strlen(p1) + 2;
			else
				len = res_str_len + strlen(p1);
			res_str = xrealloc(res_str, (1 + len));
57e0cc64:	e1a06000 	mov	r6, r0
			if (tag_subst) {
57e0cc68:	e3530000 	cmp	r3, #0
57e0cc6c:	0a00000b 	beq	57e0cca0 <insert_var_value_sub+0x230>
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len + 1), p1);
57e0cc70:	e287a001 	add	sl, r7, #1
57e0cc74:	e080a00a 	add	sl, r0, sl
57e0cc78:	e1a01004 	mov	r1, r4
57e0cc7c:	e1a0000a 	mov	r0, sl
57e0cc80:	eb005c96 	bl	57e23ee0 <strcpy>

				/*
				 * mark the replaced text to be accepted as
				 * is
				 */
				res_str[res_str_len] = SUBSTED_VAR_SYMBOL;
57e0cc84:	e3a03004 	mov	r3, #4
57e0cc88:	e7c63007 	strb	r3, [r6, r7]
				res_str[res_str_len + 1 + strlen(p1)] =
57e0cc8c:	e1a00004 	mov	r0, r4
57e0cc90:	eb005cee 	bl	57e24050 <strlen>
57e0cc94:	e3a03004 	mov	r3, #4
57e0cc98:	e7ca3000 	strb	r3, [sl, r0]
57e0cc9c:	ea000002 	b	57e0ccac <insert_var_value_sub+0x23c>
			} else
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len), p1);
57e0cca0:	e0800007 	add	r0, r0, r7
57e0cca4:	e1a01004 	mov	r1, r4
57e0cca8:	eb005c8c 	bl	57e23ee0 <strcpy>

			res_str_len = len;
57e0ccac:	e1a07005 	mov	r7, r5
		}
		*p = SPECIAL_VAR_SYMBOL;
57e0ccb0:	e3a03003 	mov	r3, #3
57e0ccb4:	e4c93001 	strb	r3, [r9], #1
		inp = ++p;
		done = 1;
57e0ccb8:	e3a05001 	mov	r5, #1
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
57e0ccbc:	e1a00009 	mov	r0, r9
57e0ccc0:	e3a01003 	mov	r1, #3
57e0ccc4:	eb005cd4 	bl	57e2401c <strchr>
57e0ccc8:	e250b000 	subs	fp, r0, #0
57e0cccc:	1affff6f 	bne	57e0ca90 <insert_var_value_sub+0x20>
		}
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
57e0ccd0:	e3550000 	cmp	r5, #0
57e0ccd4:	e1a04006 	mov	r4, r6
57e0ccd8:	0a000011 	beq	57e0cd24 <insert_var_value_sub+0x2b4>
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
57e0ccdc:	e1a00009 	mov	r0, r9
57e0cce0:	eb005cda 	bl	57e24050 <strlen>
57e0cce4:	e2871001 	add	r1, r7, #1
57e0cce8:	e0811000 	add	r1, r1, r0
57e0ccec:	e1a00006 	mov	r0, r6
57e0ccf0:	ebfffda8 	bl	57e0c398 <xrealloc>
		strcpy((res_str + res_str_len), inp);
57e0ccf4:	e1a01009 	mov	r1, r9
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
57e0ccf8:	e1a04000 	mov	r4, r0
		strcpy((res_str + res_str_len), inp);
57e0ccfc:	e0800007 	add	r0, r0, r7
57e0cd00:	eb005c76 	bl	57e23ee0 <strcpy>
		while ((p = strchr(res_str, '\n'))) {
			*p = ' ';
57e0cd04:	e3a05020 	mov	r5, #32
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
57e0cd08:	ea000000 	b	57e0cd10 <insert_var_value_sub+0x2a0>
			*p = ' ';
57e0cd0c:	e5c05000 	strb	r5, [r0]
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
57e0cd10:	e1a00004 	mov	r0, r4
57e0cd14:	e3a0100a 	mov	r1, #10
57e0cd18:	eb005cbf 	bl	57e2401c <strchr>
57e0cd1c:	e3500000 	cmp	r0, #0
57e0cd20:	1afffff9 	bne	57e0cd0c <insert_var_value_sub+0x29c>
			*p = ' ';
		}
	}
	return (res_str == NULL) ? inp : res_str;
}
57e0cd24:	e3540000 	cmp	r4, #0
57e0cd28:	11a00004 	movne	r0, r4
57e0cd2c:	01a00009 	moveq	r0, r9
57e0cd30:	e28dd010 	add	sp, sp, #16
57e0cd34:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0cd38:	57e3233f 	.word	0x57e3233f

57e0cd3c <unset_local_var>:
#endif
	return result;
}

void unset_local_var(const char *name)
{
57e0cd3c:	e92d4070 	push	{r4, r5, r6, lr}
	struct variables *cur;

	if (name) {
57e0cd40:	e2505000 	subs	r5, r0, #0
		for (cur = top_vars; cur; cur=cur->next) {
57e0cd44:	159f3088 	ldrne	r3, [pc, #136]	; 57e0cdd4 <unset_local_var+0x98>
57e0cd48:	15934100 	ldrne	r4, [r3, #256]	; 0x100

void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
57e0cd4c:	1a000006 	bne	57e0cd6c <unset_local_var+0x30>
57e0cd50:	e8bd8070 	pop	{r4, r5, r6, pc}
		for (cur = top_vars; cur; cur=cur->next) {
			if(strcmp(cur->name, name)==0)
57e0cd54:	e5940000 	ldr	r0, [r4]
57e0cd58:	e1a01005 	mov	r1, r5
57e0cd5c:	eb005c90 	bl	57e23fa4 <strcmp>
57e0cd60:	e3500000 	cmp	r0, #0
57e0cd64:	0a000003 	beq	57e0cd78 <unset_local_var+0x3c>
void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
		for (cur = top_vars; cur; cur=cur->next) {
57e0cd68:	e5944010 	ldr	r4, [r4, #16]
57e0cd6c:	e3540000 	cmp	r4, #0
57e0cd70:	1afffff7 	bne	57e0cd54 <unset_local_var+0x18>
57e0cd74:	e8bd8070 	pop	{r4, r5, r6, pc}
			if(strcmp(cur->name, name)==0)
				break;
		}
		if (cur != NULL) {
			struct variables *next = top_vars;
57e0cd78:	e59f3054 	ldr	r3, [pc, #84]	; 57e0cdd4 <unset_local_var+0x98>
57e0cd7c:	e5936100 	ldr	r6, [r3, #256]	; 0x100
			if(cur->flg_read_only) {
57e0cd80:	e594300c 	ldr	r3, [r4, #12]
57e0cd84:	e3530000 	cmp	r3, #0
57e0cd88:	0a000003 	beq	57e0cd9c <unset_local_var+0x60>
				error_msg("%s: readonly variable", name);
57e0cd8c:	e59f0044 	ldr	r0, [pc, #68]	; 57e0cdd8 <unset_local_var+0x9c>
57e0cd90:	e1a01005 	mov	r1, r5
				next->next = cur->next;
			}
			free(cur);
		}
	}
}
57e0cd94:	e8bd4070 	pop	{r4, r5, r6, lr}
				break;
		}
		if (cur != NULL) {
			struct variables *next = top_vars;
			if(cur->flg_read_only) {
				error_msg("%s: readonly variable", name);
57e0cd98:	eafff1ab 	b	57e0944c <printf>
			} else {
#ifndef __U_BOOT__
				if(cur->flg_export)
					unsetenv(cur->name);
#endif
				free(cur->name);
57e0cd9c:	e5940000 	ldr	r0, [r4]
57e0cda0:	ebfff2fd 	bl	57e0999c <free>
				free(cur->value);
57e0cda4:	e5940004 	ldr	r0, [r4, #4]
57e0cda8:	ebfff2fb 	bl	57e0999c <free>
				while (next->next != cur)
57e0cdac:	ea000000 	b	57e0cdb4 <unset_local_var+0x78>
57e0cdb0:	e1a06003 	mov	r6, r3
57e0cdb4:	e5963010 	ldr	r3, [r6, #16]
57e0cdb8:	e1530004 	cmp	r3, r4
57e0cdbc:	1afffffb 	bne	57e0cdb0 <unset_local_var+0x74>
					next = next->next;
				next->next = cur->next;
57e0cdc0:	e5943010 	ldr	r3, [r4, #16]
			}
			free(cur);
57e0cdc4:	e1a00004 	mov	r0, r4
#endif
				free(cur->name);
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
57e0cdc8:	e5863010 	str	r3, [r6, #16]
			}
			free(cur);
		}
	}
}
57e0cdcc:	e8bd4070 	pop	{r4, r5, r6, lr}
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
			}
			free(cur);
57e0cdd0:	eafff2f1 	b	57e0999c <free>
57e0cdd4:	57e38434 	.word	0x57e38434
57e0cdd8:	57e32329 	.word	0x57e32329

57e0cddc <parse_string_outer>:
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
57e0cddc:	e92d4070 	push	{r4, r5, r6, lr}
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
57e0cde0:	e2504000 	subs	r4, r0, #0
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
57e0cde4:	e24dd018 	sub	sp, sp, #24
57e0cde8:	e1a06001 	mov	r6, r1
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
57e0cdec:	0a00002f 	beq	57e0ceb0 <parse_string_outer+0xd4>
57e0cdf0:	e5d43000 	ldrb	r3, [r4]
57e0cdf4:	e3530000 	cmp	r3, #0
57e0cdf8:	0a00002c 	beq	57e0ceb0 <parse_string_outer+0xd4>
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
57e0cdfc:	e3a0100a 	mov	r1, #10
57e0ce00:	eb005c85 	bl	57e2401c <strchr>
57e0ce04:	e3500000 	cmp	r0, #0
57e0ce08:	0a000002 	beq	57e0ce18 <parse_string_outer+0x3c>
57e0ce0c:	e5d03001 	ldrb	r3, [r0, #1]
57e0ce10:	e3530000 	cmp	r3, #0
57e0ce14:	0a000018 	beq	57e0ce7c <parse_string_outer+0xa0>
		p = xmalloc(strlen(s) + 2);
57e0ce18:	e1a00004 	mov	r0, r4
57e0ce1c:	eb005c8b 	bl	57e24050 <strlen>
57e0ce20:	e2800002 	add	r0, r0, #2
57e0ce24:	ebfffca8 	bl	57e0c0cc <xmalloc>
		strcpy(p, s);
57e0ce28:	e1a01004 	mov	r1, r4
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
57e0ce2c:	e1a05000 	mov	r5, r0
		strcpy(p, s);
57e0ce30:	eb005c2a 	bl	57e23ee0 <strcpy>
		strcat(p, "\n");
57e0ce34:	e1a00005 	mov	r0, r5
57e0ce38:	e59f1080 	ldr	r1, [pc, #128]	; 57e0cec0 <parse_string_outer+0xe4>
57e0ce3c:	eb005c38 	bl	57e23f24 <strcat>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
57e0ce40:	e59f307c 	ldr	r3, [pc, #124]	; 57e0cec4 <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
57e0ce44:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
57e0ce48:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
57e0ce4c:	e59f3074 	ldr	r3, [pc, #116]	; 57e0cec8 <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
57e0ce50:	e5205014 	str	r5, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
57e0ce54:	e58d3010 	str	r3, [sp, #16]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
57e0ce58:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
57e0ce5c:	e3a03001 	mov	r3, #1
57e0ce60:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
57e0ce64:	e58d300c 	str	r3, [sp, #12]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
57e0ce68:	eb000210 	bl	57e0d6b0 <parse_stream_outer>
57e0ce6c:	e1a04000 	mov	r4, r0
		free(p);
57e0ce70:	e1a00005 	mov	r0, r5
57e0ce74:	ebfff2c8 	bl	57e0999c <free>
		return rcode;
57e0ce78:	ea00000d 	b	57e0ceb4 <parse_string_outer+0xd8>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
57e0ce7c:	e59f3040 	ldr	r3, [pc, #64]	; 57e0cec4 <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
57e0ce80:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
57e0ce84:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
57e0ce88:	e59f3038 	ldr	r3, [pc, #56]	; 57e0cec8 <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
57e0ce8c:	e5204014 	str	r4, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
57e0ce90:	e58d3010 	str	r3, [sp, #16]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
57e0ce94:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
57e0ce98:	e3a03001 	mov	r3, #1
57e0ce9c:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
57e0cea0:	e58d300c 	str	r3, [sp, #12]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
57e0cea4:	eb000201 	bl	57e0d6b0 <parse_stream_outer>
57e0cea8:	e1a04000 	mov	r4, r0
57e0ceac:	ea000000 	b	57e0ceb4 <parse_string_outer+0xd8>
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
57e0ceb0:	e3a04001 	mov	r4, #1
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
#ifdef __U_BOOT__
	}
#endif
}
57e0ceb4:	e1a00004 	mov	r0, r4
57e0ceb8:	e28dd018 	add	sp, sp, #24
57e0cebc:	e8bd8070 	pop	{r4, r5, r6, pc}
57e0cec0:	57e32390 	.word	0x57e32390
57e0cec4:	57e0bf44 	.word	0x57e0bf44
57e0cec8:	57e0bf28 	.word	0x57e0bf28

57e0cecc <run_list_real>:
#endif
	return -1;
}

static int run_list_real(struct pipe *pi)
{
57e0cecc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e0ced0:	e1a04000 	mov	r4, r0
57e0ced4:	e24dd038 	sub	sp, sp, #56	; 0x38
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
57e0ced8:	e1a05000 	mov	r5, r0
57e0cedc:	ea000023 	b	57e0cf70 <run_list_real+0xa4>
		if ((rpipe->r_mode == RES_IN ||
57e0cee0:	e5953010 	ldr	r3, [r5, #16]
57e0cee4:	e353000c 	cmp	r3, #12
57e0cee8:	13a02000 	movne	r2, #0
57e0ceec:	03a02001 	moveq	r2, #1
57e0cef0:	e3530006 	cmp	r3, #6
57e0cef4:	13a03000 	movne	r3, #0
57e0cef8:	03a03001 	moveq	r3, #1
57e0cefc:	e1930002 	orrs	r0, r3, r2
57e0cf00:	0a000019 	beq	57e0cf6c <run_list_real+0xa0>
		    rpipe->r_mode == RES_FOR) &&
		    (rpipe->next == NULL)) {
57e0cf04:	e5956008 	ldr	r6, [r5, #8]
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
		if ((rpipe->r_mode == RES_IN ||
		    rpipe->r_mode == RES_FOR) &&
57e0cf08:	e3560000 	cmp	r6, #0
57e0cf0c:	1a000003 	bne	57e0cf20 <run_list_real+0x54>
		    (rpipe->next == NULL)) {
				syntax();
57e0cf10:	ebfffc2e 	bl	57e0bfd0 <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
57e0cf14:	e59f377c 	ldr	r3, [pc, #1916]	; 57e0d698 <run_list_real+0x7cc>
57e0cf18:	e5836104 	str	r6, [r3, #260]	; 0x104
57e0cf1c:	ea0001d7 	b	57e0d680 <run_list_real+0x7b4>
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
57e0cf20:	e3520000 	cmp	r2, #0
57e0cf24:	0a000006 	beq	57e0cf44 <run_list_real+0x78>
57e0cf28:	e5963010 	ldr	r3, [r6, #16]
57e0cf2c:	e353000c 	cmp	r3, #12
57e0cf30:	1a00000d 	bne	57e0cf6c <run_list_real+0xa0>
			(rpipe->next->r_mode == RES_IN &&
			rpipe->next->progs->argv != NULL))||
57e0cf34:	e5963004 	ldr	r3, [r6, #4]
				flag_repeat = 0;
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
			(rpipe->next->r_mode == RES_IN &&
57e0cf38:	e5933000 	ldr	r3, [r3]
57e0cf3c:	e3530000 	cmp	r3, #0
57e0cf40:	ea000003 	b	57e0cf54 <run_list_real+0x88>
			rpipe->next->progs->argv != NULL))||
57e0cf44:	e3530000 	cmp	r3, #0
57e0cf48:	0a000007 	beq	57e0cf6c <run_list_real+0xa0>
			(rpipe->r_mode == RES_FOR &&
57e0cf4c:	e5963010 	ldr	r3, [r6, #16]
57e0cf50:	e353000c 	cmp	r3, #12
57e0cf54:	0a000004 	beq	57e0cf6c <run_list_real+0xa0>
			rpipe->next->r_mode != RES_IN)) {
				syntax();
57e0cf58:	ebfffc1c 	bl	57e0bfd0 <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
57e0cf5c:	e59f3734 	ldr	r3, [pc, #1844]	; 57e0d698 <run_list_real+0x7cc>
57e0cf60:	e3a02000 	mov	r2, #0
57e0cf64:	e5832104 	str	r2, [r3, #260]	; 0x104
57e0cf68:	ea0001c4 	b	57e0d680 <run_list_real+0x7b4>
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
57e0cf6c:	e5955008 	ldr	r5, [r5, #8]
57e0cf70:	e3550000 	cmp	r5, #0
57e0cf74:	1affffd9 	bne	57e0cee0 <run_list_real+0x14>
57e0cf78:	e3a09001 	mov	r9, #1
57e0cf7c:	e1a07009 	mov	r7, r9
57e0cf80:	e3a0300b 	mov	r3, #11
57e0cf84:	e58d5028 	str	r5, [sp, #40]	; 0x28
57e0cf88:	e58d5018 	str	r5, [sp, #24]
57e0cf8c:	e58d5014 	str	r5, [sp, #20]
57e0cf90:	e1a0a005 	mov	sl, r5
57e0cf94:	e1a0b005 	mov	fp, r5
57e0cf98:	e58d5020 	str	r5, [sp, #32]
57e0cf9c:	e1a06005 	mov	r6, r5
57e0cfa0:	e58d501c 	str	r5, [sp, #28]
57e0cfa4:	e1a09005 	mov	r9, r5
57e0cfa8:	ea0001b1 	b	57e0d674 <run_list_real+0x7a8>
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
		if (pi->r_mode == RES_WHILE || pi->r_mode == RES_UNTIL ||
57e0cfac:	e5942010 	ldr	r2, [r4, #16]
57e0cfb0:	e2422006 	sub	r2, r2, #6
57e0cfb4:	e3520002 	cmp	r2, #2
57e0cfb8:	8a00000a 	bhi	57e0cfe8 <run_list_real+0x11c>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
57e0cfbc:	e58d3008 	str	r3, [sp, #8]
57e0cfc0:	ebfff146 	bl	57e094e0 <ctrlc>
				if ((had_ctrlc())) {
57e0cfc4:	ebfff15e 	bl	57e09544 <had_ctrlc>
57e0cfc8:	e3500000 	cmp	r0, #0
57e0cfcc:	e59d3008 	ldr	r3, [sp, #8]
57e0cfd0:	1a0001aa 	bne	57e0d680 <run_list_real+0x7b4>
					return 1;
				}
#endif
				flag_restore = 0;
				if (!rpipe) {
57e0cfd4:	e3590000 	cmp	r9, #0
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
57e0cfd8:	158d0014 	strne	r0, [sp, #20]
				if (!rpipe) {
57e0cfdc:	01a09004 	moveq	r9, r4
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
57e0cfe0:	058d0014 	streq	r0, [sp, #20]
				if (!rpipe) {
					flag_rep = 0;
57e0cfe4:	01a0b000 	moveq	fp, r0
					rpipe = pi;
				}
		}
		rmode = pi->r_mode;
57e0cfe8:	e5945010 	ldr	r5, [r4, #16]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
57e0cfec:	e1550003 	cmp	r5, r3
57e0cff0:	13a07000 	movne	r7, #0
57e0cff4:	02077001 	andeq	r7, r7, #1
57e0cff8:	e3570000 	cmp	r7, #0
57e0cffc:	0a000003 	beq	57e0d010 <run_list_real+0x144>
			if (pi->followup == PIPE_SEQ) flag_skip=0;
57e0d000:	e594700c 	ldr	r7, [r4, #12]
57e0d004:	e2577001 	subs	r7, r7, #1
57e0d008:	13a07001 	movne	r7, #1
57e0d00c:	ea000194 	b	57e0d664 <run_list_real+0x798>
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
57e0d010:	e3550002 	cmp	r5, #2
57e0d014:	13a02000 	movne	r2, #0
57e0d018:	03a02001 	moveq	r2, #1
57e0d01c:	e3550004 	cmp	r5, #4
57e0d020:	13a03000 	movne	r3, #0
57e0d024:	03a03001 	moveq	r3, #1
57e0d028:	e1931002 	orrs	r1, r3, r2
57e0d02c:	e59d0018 	ldr	r0, [sp, #24]
57e0d030:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
57e0d034:	11a00001 	movne	r0, r1
		if (rmode == RES_THEN &&  if_code) continue;
57e0d038:	e3500000 	cmp	r0, #0
57e0d03c:	03a02000 	moveq	r2, #0
57e0d040:	12022001 	andne	r2, r2, #1
57e0d044:	e3520000 	cmp	r2, #0
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
57e0d048:	e58d0018 	str	r0, [sp, #24]
		if (rmode == RES_THEN &&  if_code) continue;
57e0d04c:	1a000182 	bne	57e0d65c <run_list_real+0x790>
		if (rmode == RES_ELSE && !if_code) continue;
57e0d050:	e2707001 	rsbs	r7, r0, #1
57e0d054:	33a07000 	movcc	r7, #0
57e0d058:	e1170003 	tst	r7, r3
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
57e0d05c:	13a0300b 	movne	r3, #11
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
		if (rmode == RES_THEN &&  if_code) continue;
		if (rmode == RES_ELSE && !if_code) continue;
57e0d060:	158d2018 	strne	r2, [sp, #24]
57e0d064:	1a00017d 	bne	57e0d660 <run_list_real+0x794>
		if (rmode == RES_ELIF && !if_code) break;
57e0d068:	e3550003 	cmp	r5, #3
57e0d06c:	13a02000 	movne	r2, #0
57e0d070:	03a02001 	moveq	r2, #1
57e0d074:	e0177002 	ands	r7, r7, r2
57e0d078:	e58d202c 	str	r2, [sp, #44]	; 0x2c
57e0d07c:	1a000180 	bne	57e0d684 <run_list_real+0x7b8>
		if (rmode == RES_FOR && pi->num_progs) {
57e0d080:	e3550006 	cmp	r5, #6
57e0d084:	1a000082 	bne	57e0d294 <run_list_real+0x3c8>
57e0d088:	e5943000 	ldr	r3, [r4]
57e0d08c:	e3530000 	cmp	r3, #0
57e0d090:	0a00008d 	beq	57e0d2cc <run_list_real+0x400>
			if (!list) {
57e0d094:	e3560000 	cmp	r6, #0
57e0d098:	1a00005f 	bne	57e0d21c <run_list_real+0x350>
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
57e0d09c:	e5943008 	ldr	r3, [r4, #8]
57e0d0a0:	e5933004 	ldr	r3, [r3, #4]
57e0d0a4:	e5933000 	ldr	r3, [r3]
57e0d0a8:	e3530000 	cmp	r3, #0
57e0d0ac:	0a00016a 	beq	57e0d65c <run_list_real+0x790>
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
57e0d0b0:	e5942004 	ldr	r2, [r4, #4]
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
57e0d0b4:	e5922000 	ldr	r2, [r2]
57e0d0b8:	e5922000 	ldr	r2, [r2]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
57e0d0bc:	e58d3008 	str	r3, [sp, #8]
57e0d0c0:	e1a00002 	mov	r0, r2
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
57e0d0c4:	e58d2010 	str	r2, [sp, #16]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
57e0d0c8:	eb005be0 	bl	57e24050 <strlen>
57e0d0cc:	e58d001c 	str	r0, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
57e0d0d0:	e3a00004 	mov	r0, #4
57e0d0d4:	ebfffbfc 	bl	57e0c0cc <xmalloc>
57e0d0d8:	e59d3008 	ldr	r3, [sp, #8]
57e0d0dc:	e58d9024 	str	r9, [sp, #36]	; 0x24
57e0d0e0:	e58d300c 	str	r3, [sp, #12]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
57e0d0e4:	e59d301c 	ldr	r3, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
57e0d0e8:	e1a06000 	mov	r6, r0
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
57e0d0ec:	e2833002 	add	r3, r3, #2
57e0d0f0:	e58d3020 	str	r3, [sp, #32]
57e0d0f4:	e58da030 	str	sl, [sp, #48]	; 0x30
57e0d0f8:	e58d5034 	str	r5, [sp, #52]	; 0x34
57e0d0fc:	e1a09004 	mov	r9, r4
57e0d100:	ea000034 	b	57e0d1d8 <run_list_real+0x30c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
57e0d104:	e3a01000 	mov	r1, #0
57e0d108:	ebfffe58 	bl	57e0ca70 <insert_var_value_sub>
57e0d10c:	e1a0b000 	mov	fp, r0
57e0d110:	e1a0a000 	mov	sl, r0
57e0d114:	ea000026 	b	57e0d1b4 <run_list_real+0x2e8>
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
57e0d118:	e3530020 	cmp	r3, #32
				p1++;
57e0d11c:	028bb001 	addeq	fp, fp, #1
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
57e0d120:	0a000023 	beq	57e0d1b4 <run_list_real+0x2e8>
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
57e0d124:	e1a0000b 	mov	r0, fp
57e0d128:	e3a01020 	mov	r1, #32
57e0d12c:	eb005bba 	bl	57e2401c <strchr>
57e0d130:	e2505000 	subs	r5, r0, #0
				len = p2 - p1;
57e0d134:	106b4005 	rsbne	r4, fp, r5
		while (*p1) {
			if ((*p1 == ' ')) {
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
57e0d138:	1a000003 	bne	57e0d14c <run_list_real+0x280>
				len = p2 - p1;
			} else {
				len = strlen(p1);
57e0d13c:	e1a0000b 	mov	r0, fp
57e0d140:	eb005bc2 	bl	57e24050 <strlen>
57e0d144:	e1a04000 	mov	r4, r0
				p2 = p1 + len;
57e0d148:	e08b5000 	add	r5, fp, r0
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
57e0d14c:	e2871002 	add	r1, r7, #2
57e0d150:	e1a00006 	mov	r0, r6
57e0d154:	e1a01101 	lsl	r1, r1, #2
57e0d158:	ebfffc8e 	bl	57e0c398 <xrealloc>
			list[n] = xmalloc(2 + name_len + len);
57e0d15c:	e59d1020 	ldr	r1, [sp, #32]
				len = strlen(p1);
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
57e0d160:	e1a06000 	mov	r6, r0
			list[n] = xmalloc(2 + name_len + len);
57e0d164:	e0810004 	add	r0, r1, r4
57e0d168:	ebfffbd7 	bl	57e0c0cc <xmalloc>
			strcpy(list[n], name);
57e0d16c:	e59d1010 	ldr	r1, [sp, #16]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
57e0d170:	e7860107 	str	r0, [r6, r7, lsl #2]
			strcpy(list[n], name);
57e0d174:	eb005b59 	bl	57e23ee0 <strcpy>
			strcat(list[n], "=");
57e0d178:	e7960107 	ldr	r0, [r6, r7, lsl #2]
57e0d17c:	e59f1518 	ldr	r1, [pc, #1304]	; 57e0d69c <run_list_real+0x7d0>
57e0d180:	eb005b67 	bl	57e23f24 <strcat>
			strncat(list[n], p1, len);
57e0d184:	e1a02004 	mov	r2, r4
57e0d188:	e7960107 	ldr	r0, [r6, r7, lsl #2]
57e0d18c:	e1a0100b 	mov	r1, fp
57e0d190:	eb005b6f 	bl	57e23f54 <strncat>
			list[n++][name_len + len + 1] = '\0';
57e0d194:	e7963107 	ldr	r3, [r6, r7, lsl #2]
57e0d198:	e59d201c 	ldr	r2, [sp, #28]
57e0d19c:	e2877001 	add	r7, r7, #1
57e0d1a0:	e0833002 	add	r3, r3, r2
57e0d1a4:	e0834004 	add	r4, r3, r4
57e0d1a8:	e3a03000 	mov	r3, #0
57e0d1ac:	e5c43001 	strb	r3, [r4, #1]
			p1 = p2;
57e0d1b0:	e1a0b005 	mov	fp, r5
	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
57e0d1b4:	e5db3000 	ldrb	r3, [fp]
57e0d1b8:	e3530000 	cmp	r3, #0
57e0d1bc:	1affffd5 	bne	57e0d118 <run_list_real+0x24c>
			strcat(list[n], "=");
			strncat(list[n], p1, len);
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
57e0d1c0:	e59d000c 	ldr	r0, [sp, #12]
57e0d1c4:	e5103004 	ldr	r3, [r0, #-4]
57e0d1c8:	e15a0003 	cmp	sl, r3
57e0d1cc:	0a000001 	beq	57e0d1d8 <run_list_real+0x30c>
57e0d1d0:	e1a0000a 	mov	r0, sl
57e0d1d4:	ebfff1f0 	bl	57e0999c <free>
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
57e0d1d8:	e59d100c 	ldr	r1, [sp, #12]
57e0d1dc:	e4910004 	ldr	r0, [r1], #4
57e0d1e0:	e3500000 	cmp	r0, #0
57e0d1e4:	e58d100c 	str	r1, [sp, #12]
57e0d1e8:	1affffc5 	bne	57e0d104 <run_list_real+0x238>
57e0d1ec:	e1a04009 	mov	r4, r9
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
57e0d1f0:	e5943004 	ldr	r3, [r4, #4]
57e0d1f4:	e59da030 	ldr	sl, [sp, #48]	; 0x30
57e0d1f8:	e5933000 	ldr	r3, [r3]
57e0d1fc:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
57e0d200:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
	}
	list[n] = NULL;
57e0d204:	e7860107 	str	r0, [r6, r7, lsl #2]
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
57e0d208:	e5932000 	ldr	r2, [r3]
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
57e0d20c:	e3a0b001 	mov	fp, #1
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
57e0d210:	e58d201c 	str	r2, [sp, #28]
				pi->progs->argv[0] = NULL;
57e0d214:	e5830000 	str	r0, [r3]
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
57e0d218:	e58d6020 	str	r6, [sp, #32]
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
57e0d21c:	e5962000 	ldr	r2, [r6]
57e0d220:	e5943004 	ldr	r3, [r4, #4]
57e0d224:	e3520000 	cmp	r2, #0
57e0d228:	1a00000f 	bne	57e0d26c <run_list_real+0x3a0>
				free(pi->progs->argv[0]);
57e0d22c:	e5933000 	ldr	r3, [r3]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
57e0d230:	e3a07001 	mov	r7, #1
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
57e0d234:	e5930000 	ldr	r0, [r3]
57e0d238:	e58d2008 	str	r2, [sp, #8]
57e0d23c:	ebfff1d6 	bl	57e0999c <free>
				free(save_list);
57e0d240:	e59d0020 	ldr	r0, [sp, #32]
57e0d244:	ebfff1d4 	bl	57e0999c <free>
				list = NULL;
				flag_rep = 0;
				pi->progs->argv[0] = save_name;
57e0d248:	e5943004 	ldr	r3, [r4, #4]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
57e0d24c:	e59d2008 	ldr	r2, [sp, #8]
				pi->progs->argv[0] = save_name;
57e0d250:	e5933000 	ldr	r3, [r3]
57e0d254:	e59d001c 	ldr	r0, [sp, #28]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
57e0d258:	e1a0b002 	mov	fp, r2
				pi->progs->argv[0] = save_name;
57e0d25c:	e5830000 	str	r0, [r3]
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
57e0d260:	e1a06002 	mov	r6, r2
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
57e0d264:	e3a0300b 	mov	r3, #11
				pi->progs->argv[0] = save_name;
#ifndef __U_BOOT__
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
				continue;
57e0d268:	ea0000fd 	b	57e0d664 <run_list_real+0x798>
			} else {
				/* insert new value from list for variable */
				if (pi->progs->argv[0])
57e0d26c:	e5933000 	ldr	r3, [r3]
57e0d270:	e5930000 	ldr	r0, [r3]
57e0d274:	e3500000 	cmp	r0, #0
57e0d278:	0a000000 	beq	57e0d280 <run_list_real+0x3b4>
					free(pi->progs->argv[0]);
57e0d27c:	ebfff1c6 	bl	57e0999c <free>
				pi->progs->argv[0] = *list++;
57e0d280:	e5943004 	ldr	r3, [r4, #4]
57e0d284:	e4962004 	ldr	r2, [r6], #4
57e0d288:	e5933000 	ldr	r3, [r3]
57e0d28c:	e5832000 	str	r2, [r3]
57e0d290:	ea00000d 	b	57e0d2cc <run_list_real+0x400>
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
			}
		}
		if (rmode == RES_IN) continue;
57e0d294:	e355000c 	cmp	r5, #12
57e0d298:	0a0000ef 	beq	57e0d65c <run_list_real+0x790>
		if (rmode == RES_DO) {
57e0d29c:	e3550009 	cmp	r5, #9
57e0d2a0:	1a000002 	bne	57e0d2b0 <run_list_real+0x3e4>
			if (!flag_rep) continue;
57e0d2a4:	e35b0000 	cmp	fp, #0
57e0d2a8:	0a0000eb 	beq	57e0d65c <run_list_real+0x790>
57e0d2ac:	ea000006 	b	57e0d2cc <run_list_real+0x400>
		}
		if ((rmode == RES_DONE)) {
57e0d2b0:	e355000a 	cmp	r5, #10
57e0d2b4:	1a000004 	bne	57e0d2cc <run_list_real+0x400>
			if (flag_rep) {
				flag_restore = 1;
57e0d2b8:	e59d1014 	ldr	r1, [sp, #20]
57e0d2bc:	e35b0000 	cmp	fp, #0
57e0d2c0:	13a01001 	movne	r1, #1
57e0d2c4:	e58d1014 	str	r1, [sp, #20]
57e0d2c8:	03a09000 	moveq	r9, #0
			} else {
				rpipe = NULL;
			}
		}
		if (pi->num_progs == 0) continue;
57e0d2cc:	e5943000 	ldr	r3, [r4]
57e0d2d0:	e3530000 	cmp	r3, #0
57e0d2d4:	0a0000e0 	beq	57e0d65c <run_list_real+0x790>
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
57e0d2d8:	e59f23b8 	ldr	r2, [pc, #952]	; 57e0d698 <run_list_real+0x7cc>

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
57e0d2dc:	e3530001 	cmp	r3, #1
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
57e0d2e0:	e5922108 	ldr	r2, [r2, #264]	; 0x108
57e0d2e4:	e58d2010 	str	r2, [sp, #16]

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
57e0d2e8:	1a0000e8 	bne	57e0d690 <run_list_real+0x7c4>
57e0d2ec:	e5947004 	ldr	r7, [r4, #4]
		/* XXX could we merge code with following builtin case,
		 * by creating a pseudo builtin that calls run_list_real? */
		rcode = run_list_real(child->group);
		restore_redirects(squirrel);
#else
		if (pi->num_progs == 1 && child->group) {
57e0d2f0:	e5970008 	ldr	r0, [r7, #8]
57e0d2f4:	e3500000 	cmp	r0, #0
57e0d2f8:	0a000001 	beq	57e0d304 <run_list_real+0x438>
		int rcode;
		debug_printf("non-subshell grouping\n");
		rcode = run_list_real(child->group);
57e0d2fc:	ebfffef2 	bl	57e0cecc <run_list_real>
57e0d300:	ea0000b3 	b	57e0d5d4 <run_list_real+0x708>
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
57e0d304:	e5972000 	ldr	r2, [r7]
57e0d308:	e3520000 	cmp	r2, #0
57e0d30c:	0a0000df 	beq	57e0d690 <run_list_real+0x7c4>
57e0d310:	e1a01007 	mov	r1, r7
57e0d314:	e1a0c004 	mov	ip, r4
57e0d318:	e1a0a000 	mov	sl, r0
57e0d31c:	e1a07005 	mov	r7, r5
57e0d320:	e1a04002 	mov	r4, r2
57e0d324:	ea000000 	b	57e0d32c <run_list_real+0x460>
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
57e0d328:	e28aa001 	add	sl, sl, #1
57e0d32c:	e4945004 	ldr	r5, [r4], #4
57e0d330:	e58d1008 	str	r1, [sp, #8]
57e0d334:	e1a00005 	mov	r0, r5
57e0d338:	e58dc004 	str	ip, [sp, #4]
57e0d33c:	ebfffb06 	bl	57e0bf5c <is_assignment>
57e0d340:	e3500000 	cmp	r0, #0
57e0d344:	e59d1008 	ldr	r1, [sp, #8]
57e0d348:	e59dc004 	ldr	ip, [sp, #4]
57e0d34c:	1afffff5 	bne	57e0d328 <run_list_real+0x45c>
		if (i!=0 && child->argv[i]==NULL) {
57e0d350:	e35a0000 	cmp	sl, #0
57e0d354:	e1a03005 	mov	r3, r5
57e0d358:	e1a0400c 	mov	r4, ip
57e0d35c:	e1a05007 	mov	r5, r7
57e0d360:	e1a07001 	mov	r7, r1
57e0d364:	0a000035 	beq	57e0d440 <run_list_real+0x574>
57e0d368:	e3530000 	cmp	r3, #0
57e0d36c:	01a0a003 	moveq	sl, r3
57e0d370:	1a000031 	bne	57e0d43c <run_list_real+0x570>
57e0d374:	ea000018 	b	57e0d3dc <run_list_real+0x510>
				 * not exported, we need only set this as a local variable.
				 * This junk is all to decide whether or not to export this
				 * variable. */
				int export_me=0;
				char *name, *value;
				name = xstrdup(child->argv[i]);
57e0d378:	eb005b54 	bl	57e240d0 <strdup>
				debug_printf("Local environment set: %s\n", name);
				value = strchr(name, '=');
57e0d37c:	e3a0103d 	mov	r1, #61	; 0x3d
57e0d380:	e58d0008 	str	r0, [sp, #8]
57e0d384:	eb005b24 	bl	57e2401c <strchr>
				if (value)
57e0d388:	e59d3008 	ldr	r3, [sp, #8]
57e0d38c:	e3500000 	cmp	r0, #0
					*value=0;
57e0d390:	13a01000 	movne	r1, #0
57e0d394:	15c01000 	strbne	r1, [r0]
#ifndef __U_BOOT__
				if ( get_local_var(name)) {
					export_me=1;
				}
#endif
				free(name);
57e0d398:	e1a00003 	mov	r0, r3
57e0d39c:	ebfff17e 	bl	57e0999c <free>
				p = insert_var_value(child->argv[i]);
57e0d3a0:	e5973000 	ldr	r3, [r7]
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
57e0d3a4:	e3a01000 	mov	r1, #0
57e0d3a8:	e793000a 	ldr	r0, [r3, sl]
57e0d3ac:	ebfffdaf 	bl	57e0ca70 <insert_var_value_sub>
					export_me=1;
				}
#endif
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
57e0d3b0:	e3a01000 	mov	r1, #0
57e0d3b4:	e58d0008 	str	r0, [sp, #8]
57e0d3b8:	ebfffd3e 	bl	57e0c8b8 <set_local_var>
				if (p != child->argv[i]) free(p);
57e0d3bc:	e5972000 	ldr	r2, [r7]
57e0d3c0:	e59d3008 	ldr	r3, [sp, #8]
57e0d3c4:	e792200a 	ldr	r2, [r2, sl]
57e0d3c8:	e1530002 	cmp	r3, r2
57e0d3cc:	0a000001 	beq	57e0d3d8 <run_list_real+0x50c>
57e0d3d0:	e1a00003 	mov	r0, r3
57e0d3d4:	ebfff170 	bl	57e0999c <free>
57e0d3d8:	e28aa004 	add	sl, sl, #4
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
			/* assignments, but no command: set the local environment */
			for (i=0; child->argv[i]!=NULL; i++) {
57e0d3dc:	e5973000 	ldr	r3, [r7]
57e0d3e0:	e793000a 	ldr	r0, [r3, sl]
57e0d3e4:	e3500000 	cmp	r0, #0
57e0d3e8:	1affffe2 	bne	57e0d378 <run_list_real+0x4ac>
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
57e0d3ec:	e1a0a000 	mov	sl, r0
57e0d3f0:	ea000080 	b	57e0d5f8 <run_list_real+0x72c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
57e0d3f4:	e1a00003 	mov	r0, r3
57e0d3f8:	e3a01000 	mov	r1, #0
57e0d3fc:	ebfffd9b 	bl	57e0ca70 <insert_var_value_sub>
		for (i = 0; is_assignment(child->argv[i]); i++) {
			p = insert_var_value(child->argv[i]);
#ifndef __U_BOOT__
			putenv(strdup(p));
#else
			set_local_var(p, 0);
57e0d400:	e3a01000 	mov	r1, #0
57e0d404:	e58d0008 	str	r0, [sp, #8]
57e0d408:	ebfffd2a 	bl	57e0c8b8 <set_local_var>
#endif
			if (p != child->argv[i]) {
57e0d40c:	e5972000 	ldr	r2, [r7]
57e0d410:	e59d3008 	ldr	r3, [sp, #8]
57e0d414:	e792200a 	ldr	r2, [r2, sl]
57e0d418:	e1530002 	cmp	r3, r2
57e0d41c:	0a000004 	beq	57e0d434 <run_list_real+0x568>
				child->sp--;
57e0d420:	e597200c 	ldr	r2, [r7, #12]
				free(p);
57e0d424:	e1a00003 	mov	r0, r3
			putenv(strdup(p));
#else
			set_local_var(p, 0);
#endif
			if (p != child->argv[i]) {
				child->sp--;
57e0d428:	e2422001 	sub	r2, r2, #1
57e0d42c:	e587200c 	str	r2, [r7, #12]
				free(p);
57e0d430:	ebfff159 	bl	57e0999c <free>
57e0d434:	e28aa004 	add	sl, sl, #4
57e0d438:	ea000000 	b	57e0d440 <run_list_real+0x574>
		rcode = run_list_real(child->group);
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
57e0d43c:	e1a0a000 	mov	sl, r0
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
		}
		for (i = 0; is_assignment(child->argv[i]); i++) {
57e0d440:	e5973000 	ldr	r3, [r7]
57e0d444:	e083200a 	add	r2, r3, sl
57e0d448:	e793300a 	ldr	r3, [r3, sl]
57e0d44c:	e58d200c 	str	r2, [sp, #12]
57e0d450:	e1a00003 	mov	r0, r3
57e0d454:	e58d3008 	str	r3, [sp, #8]
57e0d458:	ebfffabf 	bl	57e0bf5c <is_assignment>
57e0d45c:	e2502000 	subs	r2, r0, #0
57e0d460:	e59d3008 	ldr	r3, [sp, #8]
57e0d464:	1affffe2 	bne	57e0d3f4 <run_list_real+0x528>
			if (p != child->argv[i]) {
				child->sp--;
				free(p);
			}
		}
		if (child->sp) {
57e0d468:	e597100c 	ldr	r1, [r7, #12]
57e0d46c:	e3510000 	cmp	r1, #0
57e0d470:	0a000046 	beq	57e0d590 <run_list_real+0x6c4>
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
57e0d474:	e59f0224 	ldr	r0, [pc, #548]	; 57e0d6a0 <run_list_real+0x7d4>
57e0d478:	e58d2008 	str	r2, [sp, #8]
57e0d47c:	ebfffce9 	bl	57e0c828 <get_local_var>
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
57e0d480:	e3500000 	cmp	r0, #0
57e0d484:	e59d2008 	ldr	r2, [sp, #8]
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
57e0d488:	058d0010 	streq	r0, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
57e0d48c:	0a000006 	beq	57e0d4ac <run_list_real+0x5e0>
57e0d490:	e5d03000 	ldrb	r3, [r0]
57e0d494:	e3530030 	cmp	r3, #48	; 0x30
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
57e0d498:	058d2010 	streq	r2, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
57e0d49c:	0a000002 	beq	57e0d4ac <run_list_real+0x5e0>
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
57e0d4a0:	e2533000 	subs	r3, r3, #0
57e0d4a4:	13a03001 	movne	r3, #1
57e0d4a8:	e58d3010 	str	r3, [sp, #16]
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
57e0d4ac:	e3a03002 	mov	r3, #2
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
57e0d4b0:	e3a0a000 	mov	sl, #0
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
57e0d4b4:	e58d3024 	str	r3, [sp, #36]	; 0x24

/* Make new string for parser */
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
57e0d4b8:	e1a0700a 	mov	r7, sl
57e0d4bc:	e58d6030 	str	r6, [sp, #48]	; 0x30
57e0d4c0:	ea00001c 	b	57e0d538 <run_list_real+0x66c>

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
57e0d4c4:	e1a00003 	mov	r0, r3
57e0d4c8:	e59d1010 	ldr	r1, [sp, #16]
57e0d4cc:	ebfffd67 	bl	57e0ca70 <insert_var_value_sub>
57e0d4d0:	e1a06000 	mov	r6, r0
		str = xrealloc(str, (len + strlen(p)));
57e0d4d4:	eb005add 	bl	57e24050 <strlen>
57e0d4d8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
57e0d4dc:	e0801002 	add	r1, r0, r2
57e0d4e0:	e1a00007 	mov	r0, r7
57e0d4e4:	ebfffbab 	bl	57e0c398 <xrealloc>
		if (n) {
57e0d4e8:	e35a0000 	cmp	sl, #0
	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
57e0d4ec:	e1a07000 	mov	r7, r0
		if (n) {
			strcat(str, " ");
		} else {
			*str = '\0';
57e0d4f0:	05c0a000 	strbeq	sl, [r0]
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
		if (n) {
57e0d4f4:	0a000001 	beq	57e0d500 <run_list_real+0x634>
			strcat(str, " ");
57e0d4f8:	e59f11a4 	ldr	r1, [pc, #420]	; 57e0d6a4 <run_list_real+0x7d8>
57e0d4fc:	eb005a88 	bl	57e23f24 <strcat>
		} else {
			*str = '\0';
		}
		strcat(str, p);
57e0d500:	e1a01006 	mov	r1, r6
57e0d504:	e1a00007 	mov	r0, r7
57e0d508:	eb005a85 	bl	57e23f24 <strcat>
		len = strlen(str) + 3;
57e0d50c:	e1a00007 	mov	r0, r7
57e0d510:	eb005ace 	bl	57e24050 <strlen>
57e0d514:	e2800003 	add	r0, r0, #3
57e0d518:	e58d0024 	str	r0, [sp, #36]	; 0x24
		if (p != inp[n]) free(p);
57e0d51c:	e59d000c 	ldr	r0, [sp, #12]
57e0d520:	e5103004 	ldr	r3, [r0, #-4]
57e0d524:	e1560003 	cmp	r6, r3
57e0d528:	0a000001 	beq	57e0d534 <run_list_real+0x668>
57e0d52c:	e1a00006 	mov	r0, r6
57e0d530:	ebfff119 	bl	57e0999c <free>
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
57e0d534:	e28aa001 	add	sl, sl, #1
57e0d538:	e59d100c 	ldr	r1, [sp, #12]
57e0d53c:	e4913004 	ldr	r3, [r1], #4
57e0d540:	e3530000 	cmp	r3, #0
57e0d544:	e58d100c 	str	r1, [sp, #12]
57e0d548:	1affffdd 	bne	57e0d4c4 <run_list_real+0x5f8>
		}
		strcat(str, p);
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
57e0d54c:	e1a00007 	mov	r0, r7
57e0d550:	e58d3008 	str	r3, [sp, #8]
57e0d554:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
57e0d558:	eb005abc 	bl	57e24050 <strlen>
	*(str + len) = '\n';
57e0d55c:	e1a02007 	mov	r2, r7
57e0d560:	e3a0100a 	mov	r1, #10
57e0d564:	e7e21000 	strb	r1, [r2, r0]!
	*(str + len + 1) = '\0';
57e0d568:	e59d3008 	ldr	r3, [sp, #8]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
57e0d56c:	e3a01005 	mov	r1, #5
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
	*(str + len) = '\n';
	*(str + len + 1) = '\0';
57e0d570:	e5c23001 	strb	r3, [r2, #1]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
57e0d574:	e1a00007 	mov	r0, r7
57e0d578:	ebfffe17 	bl	57e0cddc <parse_string_outer>
			free(str);
57e0d57c:	e1a00007 	mov	r0, r7
57e0d580:	ebfff105 	bl	57e0999c <free>
			return last_return_code;
57e0d584:	e59f210c 	ldr	r2, [pc, #268]	; 57e0d698 <run_list_real+0x7cc>
57e0d588:	e592a234 	ldr	sl, [r2, #564]	; 0x234
57e0d58c:	ea000011 	b	57e0d5d8 <run_list_real+0x70c>
		}
#else
		/* check ";", because ,example , argv consist from
		 * "help;flinfo" must not execute
		 */
		if (strchr(child->argv[i], ';')) {
57e0d590:	e1a00003 	mov	r0, r3
57e0d594:	e3a0103b 	mov	r1, #59	; 0x3b
57e0d598:	eb005a9f 	bl	57e2401c <strchr>
57e0d59c:	e3500000 	cmp	r0, #0
57e0d5a0:	0a000004 	beq	57e0d5b8 <run_list_real+0x6ec>
			printf("Unknown command '%s' - try 'help' or use "
57e0d5a4:	e5973000 	ldr	r3, [r7]
57e0d5a8:	e59f00f8 	ldr	r0, [pc, #248]	; 57e0d6a8 <run_list_real+0x7dc>
57e0d5ac:	e793100a 	ldr	r1, [r3, sl]
57e0d5b0:	ebffefa5 	bl	57e0944c <printf>
57e0d5b4:	ea000035 	b	57e0d690 <run_list_real+0x7c4>
					"'run' command\n", child->argv[i]);
			return -1;
		}
		/* Process the command */
		return cmd_process(flag, child->argc, child->argv,
57e0d5b8:	e59d3010 	ldr	r3, [sp, #16]
57e0d5bc:	e5971004 	ldr	r1, [r7, #4]
57e0d5c0:	e2530000 	subs	r0, r3, #0
57e0d5c4:	13a00001 	movne	r0, #1
57e0d5c8:	e5972000 	ldr	r2, [r7]
57e0d5cc:	e59f30d8 	ldr	r3, [pc, #216]	; 57e0d6ac <run_list_real+0x7e0>
57e0d5d0:	ebffeed3 	bl	57e09124 <cmd_process>
57e0d5d4:	e1a0a000 	mov	sl, r0
			}
			debug_printf("checkjobs returned %d\n",rcode);
		}
		last_return_code=rcode;
#else
		if (rcode < -1) {
57e0d5d8:	e37a0001 	cmn	sl, #1
57e0d5dc:	aa000005 	bge	57e0d5f8 <run_list_real+0x72c>
			last_return_code = -rcode - 2;
57e0d5e0:	e3e03001 	mvn	r3, #1
57e0d5e4:	e59f20ac 	ldr	r2, [pc, #172]	; 57e0d698 <run_list_real+0x7cc>
57e0d5e8:	e06a3003 	rsb	r3, sl, r3
57e0d5ec:	e5823234 	str	r3, [r2, #564]	; 0x234
			return -2;	/* exit */
57e0d5f0:	e3e0a001 	mvn	sl, #1
57e0d5f4:	ea000022 	b	57e0d684 <run_list_real+0x7b8>
		last_return_code=(rcode == 0) ? 0 : 1;
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
57e0d5f8:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
57e0d5fc:	e25a3000 	subs	r3, sl, #0
57e0d600:	13a03001 	movne	r3, #1
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
57e0d604:	e3550001 	cmp	r5, #1
57e0d608:	03822001 	orreq	r2, r2, #1
57e0d60c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
57e0d610:	e3520000 	cmp	r2, #0
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
57e0d614:	e59f007c 	ldr	r0, [pc, #124]	; 57e0d698 <run_list_real+0x7cc>
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
57e0d618:	11a0100a 	movne	r1, sl
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
57e0d61c:	e3550007 	cmp	r5, #7
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
57e0d620:	e5803234 	str	r3, [r0, #564]	; 0x234
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
57e0d624:	e58d1028 	str	r1, [sp, #40]	; 0x28
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
			flag_rep = !last_return_code;
57e0d628:	0223b001 	eoreq	fp, r3, #1
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
57e0d62c:	0a000001 	beq	57e0d638 <run_list_real+0x76c>
			flag_rep = !last_return_code;
		if (rmode == RES_UNTIL)
			flag_rep = last_return_code;
57e0d630:	e3550008 	cmp	r5, #8
57e0d634:	01a0b003 	moveq	fp, r3
		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
57e0d638:	e35a0000 	cmp	sl, #0
57e0d63c:	e594300c 	ldr	r3, [r4, #12]
57e0d640:	1a000001 	bne	57e0d64c <run_list_real+0x780>
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
57e0d644:	e3530003 	cmp	r3, #3
57e0d648:	ea000000 	b	57e0d650 <run_list_real+0x784>
57e0d64c:	e3530002 	cmp	r3, #2
57e0d650:	01a03005 	moveq	r3, r5
57e0d654:	13a0300b 	movne	r3, #11
57e0d658:	ea000000 	b	57e0d660 <run_list_real+0x794>
57e0d65c:	e3a0300b 	mov	r3, #11
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
57e0d660:	e3a07001 	mov	r7, #1
				flag_repeat = 0;
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
57e0d664:	e59d2014 	ldr	r2, [sp, #20]
57e0d668:	e3520000 	cmp	r2, #0
57e0d66c:	05944008 	ldreq	r4, [r4, #8]
57e0d670:	11a04009 	movne	r4, r9
57e0d674:	e3540000 	cmp	r4, #0
57e0d678:	1afffe4b 	bne	57e0cfac <run_list_real+0xe0>
57e0d67c:	ea000000 	b	57e0d684 <run_list_real+0x7b8>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
57e0d680:	e3a0a001 	mov	sl, #1
#ifndef __U_BOOT__
		checkjobs(NULL);
#endif
	}
	return rcode;
}
57e0d684:	e1a0000a 	mov	r0, sl
57e0d688:	e28dd038 	add	sp, sp, #56	; 0x38
57e0d68c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		/* If there isn't another process, nextin is garbage
		   but it doesn't matter */
		nextin = pipefds[0];
	}
#endif
	return -1;
57e0d690:	e3e0a000 	mvn	sl, #0
57e0d694:	eaffffd7 	b	57e0d5f8 <run_list_real+0x72c>
57e0d698:	57e38434 	.word	0x57e38434
57e0d69c:	57e2ff2a 	.word	0x57e2ff2a
57e0d6a0:	57e32345 	.word	0x57e32345
57e0d6a4:	57e35c4a 	.word	0x57e35c4a
57e0d6a8:	57e32352 	.word	0x57e32352
57e0d6ac:	57e38538 	.word	0x57e38538

57e0d6b0 <parse_stream_outer>:
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
static int parse_stream_outer(struct in_str *inp, int flag)
{
57e0d6b0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e0d6b4:	e24dd048 	sub	sp, sp, #72	; 0x48

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
57e0d6b8:	e28d5030 	add	r5, sp, #48	; 0x30
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
static int parse_stream_outer(struct in_str *inp, int flag)
{
57e0d6bc:	e58d100c 	str	r1, [sp, #12]
57e0d6c0:	e1a04000 	mov	r4, r0

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
57e0d6c4:	e3a01000 	mov	r1, #0
57e0d6c8:	e1a00005 	mov	r0, r5
57e0d6cc:	e3a02014 	mov	r2, #20
57e0d6d0:	eb005ae9 	bl	57e2427c <memset>
}

static void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
57e0d6d4:	e59f769c 	ldr	r7, [pc, #1692]	; 57e0dd78 <parse_stream_outer+0x6c8>

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
57e0d6d8:	e3a0a000 	mov	sl, #0
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
57e0d6dc:	e28d6014 	add	r6, sp, #20
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
57e0d6e0:	e59d200c 	ldr	r2, [sp, #12]
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
57e0d6e4:	e3a09000 	mov	r9, #0
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
57e0d6e8:	e58d202c 	str	r2, [sp, #44]	; 0x2c
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
57e0d6ec:	e58d901c 	str	r9, [sp, #28]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
57e0d6f0:	e58d9014 	str	r9, [sp, #20]
	ctx->list_head=new_pipe();
57e0d6f4:	ebfffa7c 	bl	57e0c0ec <new_pipe>
57e0d6f8:	e58d0018 	str	r0, [sp, #24]
	ctx->pipe=ctx->list_head;
57e0d6fc:	e58d001c 	str	r0, [sp, #28]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
#ifdef __U_BOOT__
	ctx->old_flag=0;
#endif
	done_command(ctx);   /* creates the memory for working child */
57e0d700:	e1a00006 	mov	r0, r6
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
57e0d704:	e58d9020 	str	r9, [sp, #32]
	ctx->stack=NULL;
57e0d708:	e58d9028 	str	r9, [sp, #40]	; 0x28
#ifdef __U_BOOT__
	ctx->old_flag=0;
57e0d70c:	e58d9024 	str	r9, [sp, #36]	; 0x24
#endif
	done_command(ctx);   /* creates the memory for working child */
57e0d710:	ebfffb28 	bl	57e0c3b8 <done_command>
}

static void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
57e0d714:	e59f0660 	ldr	r0, [pc, #1632]	; 57e0dd7c <parse_stream_outer+0x6cc>
57e0d718:	ebffe7f2 	bl	57e076e8 <getenv>
	if (ifs == NULL) ifs=(uchar *)" \t\n";
57e0d71c:	e59f365c 	ldr	r3, [pc, #1628]	; 57e0dd80 <parse_stream_outer+0x6d0>
57e0d720:	e1500009 	cmp	r0, r9
57e0d724:	01a00003 	moveq	r0, r3
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
57e0d728:	e3a02c01 	mov	r2, #256	; 0x100

static void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
	if (ifs == NULL) ifs=(uchar *)" \t\n";
57e0d72c:	e5870238 	str	r0, [r7, #568]	; 0x238
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
57e0d730:	e1a01009 	mov	r1, r9
57e0d734:	e59f063c 	ldr	r0, [pc, #1596]	; 57e0dd78 <parse_stream_outer+0x6c8>
57e0d738:	eb005acf 	bl	57e2427c <memset>
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
57e0d73c:	e3a03004 	mov	r3, #4
		mapset(subst, 3);       /* never flow through */
57e0d740:	e28d0044 	add	r0, sp, #68	; 0x44
57e0d744:	e3a01003 	mov	r1, #3
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
57e0d748:	e5cd3044 	strb	r3, [sp, #68]	; 0x44
57e0d74c:	e5cd9045 	strb	r9, [sp, #69]	; 0x45
		mapset(subst, 3);       /* never flow through */
57e0d750:	ebfffa16 	bl	57e0bfb0 <mapset>
	}
	mapset((uchar *)"\\$'\"", 3);       /* never flow through */
57e0d754:	e59f0628 	ldr	r0, [pc, #1576]	; 57e0dd84 <parse_stream_outer+0x6d4>
57e0d758:	e3a01003 	mov	r1, #3
57e0d75c:	ebfffa13 	bl	57e0bfb0 <mapset>
	mapset((uchar *)";&|#", 1);         /* flow through if quoted */
57e0d760:	e59f0620 	ldr	r0, [pc, #1568]	; 57e0dd88 <parse_stream_outer+0x6d8>
57e0d764:	e3a01001 	mov	r1, #1
57e0d768:	ebfffa10 	bl	57e0bfb0 <mapset>
#endif
	mapset(ifs, 2);            /* also flow through if quoted */
57e0d76c:	e5970238 	ldr	r0, [r7, #568]	; 0x238
57e0d770:	e3a01002 	mov	r1, #2
57e0d774:	ebfffa0d 	bl	57e0bfb0 <mapset>
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
		update_ifs_map();
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
57e0d778:	e59d200c 	ldr	r2, [sp, #12]
57e0d77c:	e2023006 	and	r3, r2, #6
57e0d780:	e3530002 	cmp	r3, #2
57e0d784:	0a000002 	beq	57e0d794 <parse_stream_outer+0xe4>
57e0d788:	e59f05fc 	ldr	r0, [pc, #1532]	; 57e0dd8c <parse_stream_outer+0x6dc>
57e0d78c:	e1a01009 	mov	r1, r9
57e0d790:	ebfffa06 	bl	57e0bfb0 <mapset>
		inp->promptmode=1;
57e0d794:	e3a03001 	mov	r3, #1
57e0d798:	e5843008 	str	r3, [r4, #8]
57e0d79c:	e58da008 	str	sl, [sp, #8]
57e0d7a0:	ea000109 	b	57e0dbcc <parse_stream_outer+0x51c>

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
		m = map[ch];
#ifdef __U_BOOT__
		if (input->__promptme == 0) return 1;
57e0d7a4:	e5943004 	ldr	r3, [r4, #4]
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
		m = map[ch];
57e0d7a8:	e7d7b009 	ldrb	fp, [r7, r9]
#ifdef __U_BOOT__
		if (input->__promptme == 0) return 1;
57e0d7ac:	e3530000 	cmp	r3, #0
57e0d7b0:	0a00010d 	beq	57e0dbec <parse_stream_outer+0x53c>
#endif
		next = (ch == '\n') ? 0 : b_peek(input);
57e0d7b4:	e359000a 	cmp	r9, #10
57e0d7b8:	03a0a000 	moveq	sl, #0
57e0d7bc:	0a000003 	beq	57e0d7d0 <parse_stream_outer+0x120>
57e0d7c0:	e5943010 	ldr	r3, [r4, #16]
57e0d7c4:	e1a00004 	mov	r0, r4
57e0d7c8:	e12fff33 	blx	r3
57e0d7cc:	e1a0a000 	mov	sl, r0

		debug_printf("parse_stream: ch=%c (%d) m=%d quote=%d - %c\n",
			ch >= ' ' ? ch : '.', ch, m,
			dest->quote, ctx->stack == NULL ? '*' : '.');

		if (m==0 || ((m==1 || m==2) && dest->quote)) {
57e0d7d0:	e35b0000 	cmp	fp, #0
57e0d7d4:	0a000005 	beq	57e0d7f0 <parse_stream_outer+0x140>
57e0d7d8:	e24b3001 	sub	r3, fp, #1
57e0d7dc:	e3530001 	cmp	r3, #1
57e0d7e0:	8a000012 	bhi	57e0d830 <parse_stream_outer+0x180>
57e0d7e4:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
57e0d7e8:	e3530000 	cmp	r3, #0
57e0d7ec:	0a000002 	beq	57e0d7fc <parse_stream_outer+0x14c>
			b_addqchr(dest, ch, dest->quote);
57e0d7f0:	e1a00005 	mov	r0, r5
57e0d7f4:	e1a01009 	mov	r1, r9
57e0d7f8:	ea000042 	b	57e0d908 <parse_stream_outer+0x258>
		} else {
			if (m==2) {  /* unquoted IFS */
57e0d7fc:	e35b0002 	cmp	fp, #2
57e0d800:	1a00000a 	bne	57e0d830 <parse_stream_outer+0x180>
				if (done_word(dest, ctx)) {
57e0d804:	e1a00005 	mov	r0, r5
57e0d808:	e1a01006 	mov	r1, r6
57e0d80c:	ebfffb3b 	bl	57e0c500 <done_word>
57e0d810:	e3500000 	cmp	r0, #0
57e0d814:	1a0000f4 	bne	57e0dbec <parse_stream_outer+0x53c>
					return 1;
				}
				/* If we aren't performing a substitution, treat a newline as a
				 * command separator.  */
				if (end_trigger != '\0' && ch=='\n')
57e0d818:	e359000a 	cmp	r9, #10
57e0d81c:	1a0000ea 	bne	57e0dbcc <parse_stream_outer+0x51c>
					done_pipe(ctx,PIPE_SEQ);
57e0d820:	e1a00006 	mov	r0, r6
57e0d824:	e3a01001 	mov	r1, #1
57e0d828:	ebfffb04 	bl	57e0c440 <done_pipe>
57e0d82c:	ea000001 	b	57e0d838 <parse_stream_outer+0x188>
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
57e0d830:	e359000a 	cmp	r9, #10
57e0d834:	1a000005 	bne	57e0d850 <parse_stream_outer+0x1a0>
57e0d838:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
57e0d83c:	e3530000 	cmp	r3, #0
57e0d840:	1a000002 	bne	57e0d850 <parse_stream_outer+0x1a0>
57e0d844:	e59d3020 	ldr	r3, [sp, #32]
57e0d848:	e3530000 	cmp	r3, #0
57e0d84c:	0a000143 	beq	57e0dd60 <parse_stream_outer+0x6b0>
				done_pipe(ctx,PIPE_SEQ);
				run_list(ctx->list_head);
				initialize_context(ctx);
			}
#endif
			if (m!=2) switch (ch) {
57e0d850:	e35b0002 	cmp	fp, #2
57e0d854:	0a0000dc 	beq	57e0dbcc <parse_stream_outer+0x51c>
57e0d858:	e3590026 	cmp	r9, #38	; 0x26
57e0d85c:	0a0000af 	beq	57e0db20 <parse_stream_outer+0x470>
57e0d860:	8a00000a 	bhi	57e0d890 <parse_stream_outer+0x1e0>
57e0d864:	e3590022 	cmp	r9, #34	; 0x22
57e0d868:	0a00009f 	beq	57e0daec <parse_stream_outer+0x43c>
57e0d86c:	8a000002 	bhi	57e0d87c <parse_stream_outer+0x1cc>
57e0d870:	e3590004 	cmp	r9, #4
57e0d874:	1a0000d1 	bne	57e0dbc0 <parse_stream_outer+0x510>
57e0d878:	ea0000bf 	b	57e0db7c <parse_stream_outer+0x4cc>
57e0d87c:	e3590023 	cmp	r9, #35	; 0x23
57e0d880:	0a00000d 	beq	57e0d8bc <parse_stream_outer+0x20c>
57e0d884:	e3590024 	cmp	r9, #36	; 0x24
57e0d888:	1a0000cc 	bne	57e0dbc0 <parse_stream_outer+0x510>
57e0d88c:	ea00002c 	b	57e0d944 <parse_stream_outer+0x294>
57e0d890:	e359003b 	cmp	r9, #59	; 0x3b
57e0d894:	0a00009b 	beq	57e0db08 <parse_stream_outer+0x458>
57e0d898:	8a000002 	bhi	57e0d8a8 <parse_stream_outer+0x1f8>
57e0d89c:	e3590027 	cmp	r9, #39	; 0x27
57e0d8a0:	1a0000c6 	bne	57e0dbc0 <parse_stream_outer+0x510>
57e0d8a4:	ea000080 	b	57e0daac <parse_stream_outer+0x3fc>
57e0d8a8:	e359005c 	cmp	r9, #92	; 0x5c
57e0d8ac:	0a000018 	beq	57e0d914 <parse_stream_outer+0x264>
57e0d8b0:	e359007c 	cmp	r9, #124	; 0x7c
57e0d8b4:	1a0000c1 	bne	57e0dbc0 <parse_stream_outer+0x510>
57e0d8b8:	ea0000a3 	b	57e0db4c <parse_stream_outer+0x49c>
		case '#':
			if (dest->length == 0 && !dest->quote) {
57e0d8bc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0d8c0:	e3530000 	cmp	r3, #0
57e0d8c4:	1a00000d 	bne	57e0d900 <parse_stream_outer+0x250>
57e0d8c8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
57e0d8cc:	e3530000 	cmp	r3, #0
57e0d8d0:	0a000003 	beq	57e0d8e4 <parse_stream_outer+0x234>
57e0d8d4:	ea000009 	b	57e0d900 <parse_stream_outer+0x250>
				while(ch=b_peek(input),ch!=EOF && ch!='\n') { b_getch(input); }
57e0d8d8:	e594300c 	ldr	r3, [r4, #12]
57e0d8dc:	e1a00004 	mov	r0, r4
57e0d8e0:	e12fff33 	blx	r3
57e0d8e4:	e5943010 	ldr	r3, [r4, #16]
57e0d8e8:	e1a00004 	mov	r0, r4
57e0d8ec:	e12fff33 	blx	r3
57e0d8f0:	e350000a 	cmp	r0, #10
57e0d8f4:	13700001 	cmnne	r0, #1
57e0d8f8:	1afffff6 	bne	57e0d8d8 <parse_stream_outer+0x228>
57e0d8fc:	ea0000b2 	b	57e0dbcc <parse_stream_outer+0x51c>
			} else {
				b_addqchr(dest, ch, dest->quote);
57e0d900:	e1a00005 	mov	r0, r5
57e0d904:	e3a01023 	mov	r1, #35	; 0x23
57e0d908:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
57e0d90c:	ebfffbb2 	bl	57e0c7dc <b_addqchr>
57e0d910:	ea0000ad 	b	57e0dbcc <parse_stream_outer+0x51c>
			}
			break;
		case '\\':
			if (next == EOF) {
57e0d914:	e37a0001 	cmn	sl, #1
57e0d918:	0a0000a8 	beq	57e0dbc0 <parse_stream_outer+0x510>
				syntax();
				return 1;
			}
			b_addqchr(dest, '\\', dest->quote);
57e0d91c:	e1a01009 	mov	r1, r9
57e0d920:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
57e0d924:	e1a00005 	mov	r0, r5
57e0d928:	ebfffbab 	bl	57e0c7dc <b_addqchr>
			b_addqchr(dest, b_getch(input), dest->quote);
57e0d92c:	e594300c 	ldr	r3, [r4, #12]
57e0d930:	e1a00004 	mov	r0, r4
57e0d934:	e12fff33 	blx	r3
57e0d938:	e1a01000 	mov	r1, r0
57e0d93c:	e1a00005 	mov	r0, r5
57e0d940:	eafffff0 	b	57e0d908 <parse_stream_outer+0x258>
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
57e0d944:	e5943010 	ldr	r3, [r4, #16]
57e0d948:	e1a00004 	mov	r0, r4
57e0d94c:	e12fff33 	blx	r3
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
57e0d950:	e59f2438 	ldr	r2, [pc, #1080]	; 57e0dd90 <parse_stream_outer+0x6e0>
57e0d954:	e20030ff 	and	r3, r0, #255	; 0xff
57e0d958:	e7d23003 	ldrb	r3, [r2, r3]
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
57e0d95c:	e1a0a000 	mov	sl, r0
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
57e0d960:	e3130003 	tst	r3, #3
57e0d964:	0a00001b 	beq	57e0d9d8 <parse_stream_outer+0x328>
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
57e0d968:	e1a00005 	mov	r0, r5
57e0d96c:	e3a01003 	mov	r1, #3
57e0d970:	ebfffac4 	bl	57e0c488 <b_addchr>
		ctx->child->sp++;
57e0d974:	e59d3014 	ldr	r3, [sp, #20]
57e0d978:	e593200c 	ldr	r2, [r3, #12]
57e0d97c:	e2822001 	add	r2, r2, #1
57e0d980:	e583200c 	str	r2, [r3, #12]
57e0d984:	ea000005 	b	57e0d9a0 <parse_stream_outer+0x2f0>
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
			b_getch(input);
57e0d988:	e594300c 	ldr	r3, [r4, #12]
57e0d98c:	e1a00004 	mov	r0, r4
57e0d990:	e12fff33 	blx	r3
			b_addchr(dest,ch);
57e0d994:	e1a00005 	mov	r0, r5
57e0d998:	e1a0100a 	mov	r1, sl
57e0d99c:	ebfffab9 	bl	57e0c488 <b_addchr>
	int ch = input->peek(input);  /* first character after the $ */
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
		ctx->child->sp++;
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
57e0d9a0:	e5943010 	ldr	r3, [r4, #16]
57e0d9a4:	e1a00004 	mov	r0, r4
57e0d9a8:	e12fff33 	blx	r3
57e0d9ac:	e59f23dc 	ldr	r2, [pc, #988]	; 57e0dd90 <parse_stream_outer+0x6e0>
57e0d9b0:	e20030ff 	and	r3, r0, #255	; 0xff
57e0d9b4:	e7d23003 	ldrb	r3, [r2, r3]
57e0d9b8:	e1a0a000 	mov	sl, r0
57e0d9bc:	e2133007 	ands	r3, r3, #7
57e0d9c0:	13a03001 	movne	r3, #1
57e0d9c4:	e350005f 	cmp	r0, #95	; 0x5f
57e0d9c8:	03833001 	orreq	r3, r3, #1
57e0d9cc:	e3530000 	cmp	r3, #0
57e0d9d0:	1affffec 	bne	57e0d988 <parse_stream_outer+0x2d8>
57e0d9d4:	ea000030 	b	57e0da9c <parse_stream_outer+0x3ec>
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
57e0d9d8:	e350003f 	cmp	r0, #63	; 0x3f
57e0d9dc:	0a000004 	beq	57e0d9f4 <parse_stream_outer+0x344>
57e0d9e0:	e350007b 	cmp	r0, #123	; 0x7b
			error_msg("unhandled syntax: $%c",ch);
			return 1;
			break;
#endif
		default:
			b_addqchr(dest,'$',dest->quote);
57e0d9e4:	11a00005 	movne	r0, r5
57e0d9e8:	13a01024 	movne	r1, #36	; 0x24
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
57e0d9ec:	1affffc5 	bne	57e0d908 <parse_stream_outer+0x258>
57e0d9f0:	ea000013 	b	57e0da44 <parse_stream_outer+0x394>
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
57e0d9f4:	e59d3014 	ldr	r3, [sp, #20]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
57e0d9f8:	e1a00005 	mov	r0, r5
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
57e0d9fc:	e593200c 	ldr	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
57e0da00:	e3a01003 	mov	r1, #3
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
57e0da04:	e2822001 	add	r2, r2, #1
57e0da08:	e583200c 	str	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
57e0da0c:	ebfffa9d 	bl	57e0c488 <b_addchr>
			b_addchr(dest, '$');
57e0da10:	e1a01009 	mov	r1, r9
57e0da14:	e1a00005 	mov	r0, r5
57e0da18:	ebfffa9a 	bl	57e0c488 <b_addchr>
			b_addchr(dest, '?');
57e0da1c:	e1a0100a 	mov	r1, sl
57e0da20:	e1a00005 	mov	r0, r5
57e0da24:	ebfffa97 	bl	57e0c488 <b_addchr>
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
57e0da28:	e1a00005 	mov	r0, r5
57e0da2c:	e3a01003 	mov	r1, #3
57e0da30:	ebfffa94 	bl	57e0c488 <b_addchr>
	/* Eat the character if the flag was set.  If the compiler
	 * is smart enough, we could substitute "b_getch(input);"
	 * for all the "advance = 1;" above, and also end up with
	 * a nice size-optimized program.  Hah!  That'll be the day.
	 */
	if (advance) b_getch(input);
57e0da34:	e594300c 	ldr	r3, [r4, #12]
57e0da38:	e1a00004 	mov	r0, r4
57e0da3c:	e12fff33 	blx	r3
57e0da40:	ea000061 	b	57e0dbcc <parse_stream_outer+0x51c>
			b_adduint(dest,global_argc ? global_argc-1 : 0);
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
57e0da44:	e1a00005 	mov	r0, r5
57e0da48:	e3a01003 	mov	r1, #3
57e0da4c:	ebfffa8d 	bl	57e0c488 <b_addchr>
			ctx->child->sp++;
57e0da50:	e59d3014 	ldr	r3, [sp, #20]
			b_getch(input);
57e0da54:	e1a00004 	mov	r0, r4
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
57e0da58:	e593200c 	ldr	r2, [r3, #12]
57e0da5c:	e2822001 	add	r2, r2, #1
57e0da60:	e583200c 	str	r2, [r3, #12]
			b_getch(input);
57e0da64:	e594300c 	ldr	r3, [r4, #12]
57e0da68:	e12fff33 	blx	r3
57e0da6c:	ea000001 	b	57e0da78 <parse_stream_outer+0x3c8>
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
				b_addchr(dest,ch);
57e0da70:	e1a00005 	mov	r0, r5
57e0da74:	ebfffa83 	bl	57e0c488 <b_addchr>
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
			b_getch(input);
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
57e0da78:	e594300c 	ldr	r3, [r4, #12]
57e0da7c:	e1a00004 	mov	r0, r4
57e0da80:	e12fff33 	blx	r3
57e0da84:	e350007d 	cmp	r0, #125	; 0x7d
57e0da88:	13700001 	cmnne	r0, #1
57e0da8c:	e1a01000 	mov	r1, r0
57e0da90:	1afffff6 	bne	57e0da70 <parse_stream_outer+0x3c0>
				b_addchr(dest,ch);
			}
			if (ch != '}') {
57e0da94:	e350007d 	cmp	r0, #125	; 0x7d
57e0da98:	1a000048 	bne	57e0dbc0 <parse_stream_outer+0x510>
				syntax();
				return 1;
			}
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
57e0da9c:	e1a00005 	mov	r0, r5
57e0daa0:	e3a01003 	mov	r1, #3
57e0daa4:	ebfffa77 	bl	57e0c488 <b_addchr>
57e0daa8:	ea000047 	b	57e0dbcc <parse_stream_outer+0x51c>
			break;
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
57e0daac:	e3a03001 	mov	r3, #1
57e0dab0:	e58d3040 	str	r3, [sp, #64]	; 0x40
57e0dab4:	ea000004 	b	57e0dacc <parse_stream_outer+0x41c>
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
#ifdef __U_BOOT__
				if(input->__promptme == 0) return 1;
57e0dab8:	e5943004 	ldr	r3, [r4, #4]
57e0dabc:	e3530000 	cmp	r3, #0
57e0dac0:	0a000049 	beq	57e0dbec <parse_stream_outer+0x53c>
#endif
				b_addchr(dest,ch);
57e0dac4:	e1a00005 	mov	r0, r5
57e0dac8:	ebfffa6e 	bl	57e0c488 <b_addchr>
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
57e0dacc:	e594300c 	ldr	r3, [r4, #12]
57e0dad0:	e1a00004 	mov	r0, r4
57e0dad4:	e12fff33 	blx	r3
57e0dad8:	e3500027 	cmp	r0, #39	; 0x27
57e0dadc:	13700001 	cmnne	r0, #1
57e0dae0:	e1a01000 	mov	r1, r0
57e0dae4:	1afffff3 	bne	57e0dab8 <parse_stream_outer+0x408>
57e0dae8:	ea000032 	b	57e0dbb8 <parse_stream_outer+0x508>
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
			dest->quote = !dest->quote;
57e0daec:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
57e0daf0:	e3a02001 	mov	r2, #1
			dest->quote = !dest->quote;
57e0daf4:	e2733001 	rsbs	r3, r3, #1
57e0daf8:	33a03000 	movcc	r3, #0
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
57e0dafc:	e58d2040 	str	r2, [sp, #64]	; 0x40
			dest->quote = !dest->quote;
57e0db00:	e58d303c 	str	r3, [sp, #60]	; 0x3c
57e0db04:	ea000030 	b	57e0dbcc <parse_stream_outer+0x51c>
			}
			setup_redirect(ctx, redir_fd, redir_style, input);
			break;
#endif
		case ';':
			done_word(dest, ctx);
57e0db08:	e1a01006 	mov	r1, r6
57e0db0c:	e1a00005 	mov	r0, r5
57e0db10:	ebfffa7a 	bl	57e0c500 <done_word>
			done_pipe(ctx,PIPE_SEQ);
57e0db14:	e1a00006 	mov	r0, r6
57e0db18:	e3a01001 	mov	r1, #1
57e0db1c:	ea000014 	b	57e0db74 <parse_stream_outer+0x4c4>
			break;
		case '&':
			done_word(dest, ctx);
57e0db20:	e1a00005 	mov	r0, r5
57e0db24:	e1a01006 	mov	r1, r6
57e0db28:	ebfffa74 	bl	57e0c500 <done_word>
			if (next=='&') {
57e0db2c:	e35a0026 	cmp	sl, #38	; 0x26
57e0db30:	1a000022 	bne	57e0dbc0 <parse_stream_outer+0x510>
				b_getch(input);
57e0db34:	e594300c 	ldr	r3, [r4, #12]
57e0db38:	e1a00004 	mov	r0, r4
57e0db3c:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_AND);
57e0db40:	e1a00006 	mov	r0, r6
57e0db44:	e3a01002 	mov	r1, #2
57e0db48:	ea000009 	b	57e0db74 <parse_stream_outer+0x4c4>
				return 1;
#endif
			}
			break;
		case '|':
			done_word(dest, ctx);
57e0db4c:	e1a00005 	mov	r0, r5
57e0db50:	e1a01006 	mov	r1, r6
57e0db54:	ebfffa69 	bl	57e0c500 <done_word>
			if (next=='|') {
57e0db58:	e35a007c 	cmp	sl, #124	; 0x7c
57e0db5c:	1a000017 	bne	57e0dbc0 <parse_stream_outer+0x510>
				b_getch(input);
57e0db60:	e594300c 	ldr	r3, [r4, #12]
57e0db64:	e1a00004 	mov	r0, r4
57e0db68:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_OR);
57e0db6c:	e1a00006 	mov	r0, r6
57e0db70:	e3a01003 	mov	r1, #3
57e0db74:	ebfffa31 	bl	57e0c440 <done_pipe>
57e0db78:	ea000013 	b	57e0dbcc <parse_stream_outer+0x51c>
			syntax();   /* Proper use of this character caught by end_trigger */
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
57e0db7c:	e3a03001 	mov	r3, #1
57e0db80:	e58d3040 	str	r3, [sp, #64]	; 0x40
57e0db84:	ea000004 	b	57e0db9c <parse_stream_outer+0x4ec>
			while (ch = b_getch(input), ch != EOF &&
			    ch != SUBSTED_VAR_SYMBOL) {
				debug_printf("subst, pass=%d\n", ch);
				if (input->__promptme == 0)
57e0db88:	e5943004 	ldr	r3, [r4, #4]
57e0db8c:	e3530000 	cmp	r3, #0
57e0db90:	0a000015 	beq	57e0dbec <parse_stream_outer+0x53c>
					return 1;
				b_addchr(dest, ch);
57e0db94:	e1a00005 	mov	r0, r5
57e0db98:	ebfffa3a 	bl	57e0c488 <b_addchr>
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
			while (ch = b_getch(input), ch != EOF &&
57e0db9c:	e594300c 	ldr	r3, [r4, #12]
57e0dba0:	e1a00004 	mov	r0, r4
57e0dba4:	e12fff33 	blx	r3
57e0dba8:	e3500004 	cmp	r0, #4
57e0dbac:	13700001 	cmnne	r0, #1
57e0dbb0:	e1a01000 	mov	r1, r0
57e0dbb4:	1afffff3 	bne	57e0db88 <parse_stream_outer+0x4d8>
				if (input->__promptme == 0)
					return 1;
				b_addchr(dest, ch);
			}
			debug_printf("subst, term=%d\n", ch);
			if (ch == EOF) {
57e0dbb8:	e3710001 	cmn	r1, #1
57e0dbbc:	1a000002 	bne	57e0dbcc <parse_stream_outer+0x51c>
57e0dbc0:	e59da008 	ldr	sl, [sp, #8]
				syntax();
				return 1;
			}
			break;
		default:
			syntax();   /* this is really an internal logic error */
57e0dbc4:	ebfff901 	bl	57e0bfd0 <syntax_err>
57e0dbc8:	ea000008 	b	57e0dbf0 <parse_stream_outer+0x540>
	/* Only double-quote state is handled in the state variable dest->quote.
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
57e0dbcc:	e594300c 	ldr	r3, [r4, #12]
57e0dbd0:	e1a00004 	mov	r0, r4
57e0dbd4:	e12fff33 	blx	r3
57e0dbd8:	e3700001 	cmn	r0, #1
57e0dbdc:	e1a09000 	mov	r9, r0
57e0dbe0:	1afffeef 	bne	57e0d7a4 <parse_stream_outer+0xf4>
57e0dbe4:	e59da008 	ldr	sl, [sp, #8]
57e0dbe8:	ea00005e 	b	57e0dd68 <parse_stream_outer+0x6b8>
57e0dbec:	e59da008 	ldr	sl, [sp, #8]
		update_ifs_map();
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
57e0dbf0:	e3a03000 	mov	r3, #0
57e0dbf4:	e5873104 	str	r3, [r7, #260]	; 0x104
57e0dbf8:	e3a09001 	mov	r9, #1
57e0dbfc:	ea000028 	b	57e0dca4 <parse_stream_outer+0x5f4>
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
			syntax();
57e0dc00:	ebfff8f2 	bl	57e0bfd0 <syntax_err>
#ifdef __U_BOOT__
			flag_repeat = 0;
57e0dc04:	e3a03000 	mov	r3, #0
57e0dc08:	e5873104 	str	r3, [r7, #260]	; 0x104
57e0dc0c:	ea00004f 	b	57e0dd50 <parse_stream_outer+0x6a0>
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
			done_word(&temp, &ctx);
57e0dc10:	e1a01006 	mov	r1, r6
57e0dc14:	e1a00005 	mov	r0, r5
57e0dc18:	ebfffa38 	bl	57e0c500 <done_word>
			done_pipe(&ctx,PIPE_SEQ);
57e0dc1c:	e3a01001 	mov	r1, #1
57e0dc20:	e1a00006 	mov	r0, r6
57e0dc24:	ebfffa05 	bl	57e0c440 <done_pipe>
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
57e0dc28:	e59d3018 	ldr	r3, [sp, #24]
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
57e0dc2c:	e1a00003 	mov	r0, r3
57e0dc30:	e58d3004 	str	r3, [sp, #4]
57e0dc34:	ebfffca4 	bl	57e0cecc <run_list_real>
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
57e0dc38:	e59d3004 	ldr	r3, [sp, #4]
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
57e0dc3c:	e1a0a000 	mov	sl, r0
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
57e0dc40:	e1a0100b 	mov	r1, fp
57e0dc44:	e1a00003 	mov	r0, r3
57e0dc48:	ebfff99b 	bl	57e0c2bc <free_pipe_list>
			done_pipe(&ctx,PIPE_SEQ);
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
57e0dc4c:	e37a0002 	cmn	sl, #2
57e0dc50:	1a000010 	bne	57e0dc98 <parse_stream_outer+0x5e8>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0dc54:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
57e0dc58:	e58db034 	str	fp, [sp, #52]	; 0x34
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0dc5c:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
57e0dc60:	e58db040 	str	fp, [sp, #64]	; 0x40
	if (o->data != NULL) *o->data = '\0';
57e0dc64:	15c3b000 	strbne	fp, [r3]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
57e0dc68:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
57e0dc6c:	ebffef4a 	bl	57e0999c <free>
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
57e0dc70:	e5942010 	ldr	r2, [r4, #16]
57e0dc74:	e59f3118 	ldr	r3, [pc, #280]	; 57e0dd94 <parse_stream_outer+0x6e4>

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
57e0dc78:	e3a0a000 	mov	sl, #0
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
57e0dc7c:	e1520003 	cmp	r2, r3

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
57e0dc80:	e58da030 	str	sl, [sp, #48]	; 0x30
	o->maxlen = 0;
57e0dc84:	e58da038 	str	sl, [sp, #56]	; 0x38
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
57e0dc88:	1a00002c 	bne	57e0dd40 <parse_stream_outer+0x690>
					printf("exit not allowed from main input shell.\n");
57e0dc8c:	e59f0104 	ldr	r0, [pc, #260]	; 57e0dd98 <parse_stream_outer+0x6e8>
57e0dc90:	ebffeded 	bl	57e0944c <printf>
					continue;
57e0dc94:	ea000024 	b	57e0dd2c <parse_stream_outer+0x67c>
				}
				break;
			}
			if (code == -1)
57e0dc98:	e37a0001 	cmn	sl, #1
			    flag_repeat = 0;
57e0dc9c:	0587b104 	streq	fp, [r7, #260]	; 0x104
57e0dca0:	ea000016 	b	57e0dd00 <parse_stream_outer+0x650>
#endif
		} else {
			if (ctx.old_flag != 0) {
57e0dca4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e0dca8:	e3530000 	cmp	r3, #0
57e0dcac:	0a000007 	beq	57e0dcd0 <parse_stream_outer+0x620>
				free(ctx.stack);
57e0dcb0:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
57e0dcb4:	ebffef38 	bl	57e0999c <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0dcb8:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
57e0dcbc:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0dcc0:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
57e0dcc4:	e58d3034 	str	r3, [sp, #52]	; 0x34
	o->nonnull = 0;
57e0dcc8:	e58d3040 	str	r3, [sp, #64]	; 0x40
	if (o->data != NULL) *o->data = '\0';
57e0dccc:	15c23000 	strbne	r3, [r2]
			if (ctx.old_flag != 0) {
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
57e0dcd0:	e5943004 	ldr	r3, [r4, #4]
57e0dcd4:	e3530000 	cmp	r3, #0
57e0dcd8:	1a000001 	bne	57e0dce4 <parse_stream_outer+0x634>
57e0dcdc:	e59f00b8 	ldr	r0, [pc, #184]	; 57e0dd9c <parse_stream_outer+0x6ec>
57e0dce0:	ebffedd9 	bl	57e0944c <printf>
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
57e0dce4:	e3a01000 	mov	r1, #0
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
57e0dce8:	e3a03001 	mov	r3, #1
57e0dcec:	e884000a 	stm	r4, {r1, r3}
#endif
			temp.nonnull = 0;
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
57e0dcf0:	e59d0018 	ldr	r0, [sp, #24]
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
57e0dcf4:	e58d1040 	str	r1, [sp, #64]	; 0x40
			temp.quote = 0;
57e0dcf8:	e58d103c 	str	r1, [sp, #60]	; 0x3c
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
57e0dcfc:	ebfff96e 	bl	57e0c2bc <free_pipe_list>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0dd00:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
57e0dd04:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
57e0dd08:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
57e0dd0c:	e58d3034 	str	r3, [sp, #52]	; 0x34
	o->nonnull = 0;
57e0dd10:	e58d3040 	str	r3, [sp, #64]	; 0x40
	if (o->data != NULL) *o->data = '\0';
57e0dd14:	15c23000 	strbne	r3, [r2]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
57e0dd18:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
57e0dd1c:	ebffef1e 	bl	57e0999c <free>
	o->data = NULL;
57e0dd20:	e3a03000 	mov	r3, #0
57e0dd24:	e58d3030 	str	r3, [sp, #48]	; 0x30
	o->maxlen = 0;
57e0dd28:	e58d3038 	str	r3, [sp, #56]	; 0x38
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
		}
		b_free(&temp);
	} while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP));   /* loop on syntax errors, return on EOF */
57e0dd2c:	e3790001 	cmn	r9, #1
57e0dd30:	0a000002 	beq	57e0dd40 <parse_stream_outer+0x690>
57e0dd34:	e59d200c 	ldr	r2, [sp, #12]
57e0dd38:	e3120001 	tst	r2, #1
57e0dd3c:	0afffe67 	beq	57e0d6e0 <parse_stream_outer+0x30>
#ifndef __U_BOOT__
	return 0;
#else
	return (code != 0) ? 1 : 0;
#endif /* __U_BOOT__ */
}
57e0dd40:	e25a0000 	subs	r0, sl, #0
57e0dd44:	13a00001 	movne	r0, #1
57e0dd48:	e28dd048 	add	sp, sp, #72	; 0x48
57e0dd4c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			syntax();
#ifdef __U_BOOT__
			flag_repeat = 0;
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
57e0dd50:	e59db024 	ldr	fp, [sp, #36]	; 0x24
57e0dd54:	e35b0000 	cmp	fp, #0
57e0dd58:	1affffd1 	bne	57e0dca4 <parse_stream_outer+0x5f4>
57e0dd5c:	eaffffab 	b	57e0dc10 <parse_stream_outer+0x560>
57e0dd60:	e59da008 	ldr	sl, [sp, #8]
				if (end_trigger != '\0' && ch=='\n')
					done_pipe(ctx,PIPE_SEQ);
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
				debug_printf("leaving parse_stream (triggered)\n");
				return 0;
57e0dd64:	e1a09003 	mov	r9, r3
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
57e0dd68:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e0dd6c:	e3530000 	cmp	r3, #0
57e0dd70:	0afffff6 	beq	57e0dd50 <parse_stream_outer+0x6a0>
57e0dd74:	eaffffa1 	b	57e0dc00 <parse_stream_outer+0x550>
57e0dd78:	57e38434 	.word	0x57e38434
57e0dd7c:	57e3238a 	.word	0x57e3238a
57e0dd80:	57e3238e 	.word	0x57e3238e
57e0dd84:	57e32392 	.word	0x57e32392
57e0dd88:	57e32397 	.word	0x57e32397
57e0dd8c:	57e3239c 	.word	0x57e3239c
57e0dd90:	57e2d4d0 	.word	0x57e2d4d0
57e0dd94:	57e0bf50 	.word	0x57e0bf50
57e0dd98:	57e323a1 	.word	0x57e323a1
57e0dd9c:	57e323ca 	.word	0x57e323ca

57e0dda0 <parse_file_outer>:
#ifndef __U_BOOT__
static int parse_file_outer(FILE *f)
#else
int parse_file_outer(void)
#endif
{
57e0dda0:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
57e0dda4:	e59f3030 	ldr	r3, [pc, #48]	; 57e0dddc <parse_file_outer+0x3c>
	i->__promptme=1;
	i->promptmode=1;
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
57e0dda8:	e28d0018 	add	r0, sp, #24
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
57e0ddac:	e58d3014 	str	r3, [sp, #20]
	i->get = file_get;
57e0ddb0:	e59f3028 	ldr	r3, [pc, #40]	; 57e0dde0 <parse_file_outer+0x40>
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
57e0ddb4:	e3a01002 	mov	r1, #2
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
	i->get = file_get;
57e0ddb8:	e58d3010 	str	r3, [sp, #16]
	i->__promptme=1;
57e0ddbc:	e3a03001 	mov	r3, #1
57e0ddc0:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
57e0ddc4:	e58d300c 	str	r3, [sp, #12]
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
57e0ddc8:	e3a03000 	mov	r3, #0
57e0ddcc:	e5203014 	str	r3, [r0, #-20]!
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
57e0ddd0:	ebfffe36 	bl	57e0d6b0 <parse_stream_outer>
	return rcode;
}
57e0ddd4:	e28dd01c 	add	sp, sp, #28
57e0ddd8:	e8bd8000 	pop	{pc}
57e0dddc:	57e0bf50 	.word	0x57e0bf50
57e0dde0:	57e0c114 	.word	0x57e0c114

57e0dde4 <u_boot_hush_start>:
	}
}
#endif

int u_boot_hush_start(void)
{
57e0dde4:	e92d4038 	push	{r3, r4, r5, lr}
	if (top_vars == NULL) {
57e0dde8:	e59f503c 	ldr	r5, [pc, #60]	; 57e0de2c <u_boot_hush_start+0x48>
57e0ddec:	e5954100 	ldr	r4, [r5, #256]	; 0x100
57e0ddf0:	e3540000 	cmp	r4, #0
57e0ddf4:	1a00000a 	bne	57e0de24 <u_boot_hush_start+0x40>
		top_vars = malloc(sizeof(struct variables));
57e0ddf8:	e3a00014 	mov	r0, #20
57e0ddfc:	ebffef70 	bl	57e09bc4 <malloc>
		top_vars->name = "HUSH_VERSION";
57e0de00:	e59f3028 	ldr	r3, [pc, #40]	; 57e0de30 <u_boot_hush_start+0x4c>
#endif

int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
57e0de04:	e5850100 	str	r0, [r5, #256]	; 0x100
		top_vars->name = "HUSH_VERSION";
57e0de08:	e5803000 	str	r3, [r0]
		top_vars->value = "0.01";
57e0de0c:	e59f3020 	ldr	r3, [pc, #32]	; 57e0de34 <u_boot_hush_start+0x50>
		top_vars->next = NULL;
57e0de10:	e5804010 	str	r4, [r0, #16]
int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
57e0de14:	e5803004 	str	r3, [r0, #4]
		top_vars->next = NULL;
		top_vars->flg_export = 0;
		top_vars->flg_read_only = 1;
57e0de18:	e3a03001 	mov	r3, #1
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
		top_vars->next = NULL;
		top_vars->flg_export = 0;
57e0de1c:	e5804008 	str	r4, [r0, #8]
		top_vars->flg_read_only = 1;
57e0de20:	e580300c 	str	r3, [r0, #12]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		u_boot_hush_reloc();
#endif
	}
	return 0;
}
57e0de24:	e3a00000 	mov	r0, #0
57e0de28:	e8bd8038 	pop	{r3, r4, r5, pc}
57e0de2c:	57e38434 	.word	0x57e38434
57e0de30:	57e323d7 	.word	0x57e323d7
57e0de34:	57e323e4 	.word	0x57e323e4

57e0de38 <on_loadaddr>:
ulong save_size;			/* Default Save Size (in bytes) */

static int on_loadaddr(const char *name, const char *value, enum env_op op,
	int flags)
{
	switch (op) {
57e0de38:	e3520000 	cmp	r2, #0
ulong save_addr;			/* Default Save Address */
ulong save_size;			/* Default Save Size (in bytes) */

static int on_loadaddr(const char *name, const char *value, enum env_op op,
	int flags)
{
57e0de3c:	e92d4008 	push	{r3, lr}
	switch (op) {
57e0de40:	0a000001 	beq	57e0de4c <on_loadaddr+0x14>
57e0de44:	e3520002 	cmp	r2, #2
57e0de48:	1a000005 	bne	57e0de64 <on_loadaddr+0x2c>
	case env_op_create:
	case env_op_overwrite:
		load_addr = simple_strtoul(value, NULL, 16);
57e0de4c:	e1a00001 	mov	r0, r1
57e0de50:	e3a02010 	mov	r2, #16
57e0de54:	e3a01000 	mov	r1, #0
57e0de58:	eb005c91 	bl	57e250a4 <simple_strtoul>
57e0de5c:	e59f3008 	ldr	r3, [pc, #8]	; 57e0de6c <on_loadaddr+0x34>
57e0de60:	e5830000 	str	r0, [r3]
	default:
		break;
	}

	return 0;
}
57e0de64:	e3a00000 	mov	r0, #0
57e0de68:	e8bd8008 	pop	{r3, pc}
57e0de6c:	57e36e60 	.word	0x57e36e60

57e0de70 <image_check_hcrc>:

/*****************************************************************************/
/* Legacy format routines */
/*****************************************************************************/
int image_check_hcrc(const image_header_t *hdr)
{
57e0de70:	e92d4030 	push	{r4, r5, lr}
57e0de74:	e1a04000 	mov	r4, r0
57e0de78:	e24dd044 	sub	sp, sp, #68	; 0x44
	ulong hcrc;
	ulong len = image_get_header_size();
	image_header_t header;

	/* Copy header so we can blank CRC field for re-calculation */
	memmove(&header, (char *)hdr, image_get_header_size());
57e0de7c:	e1a01004 	mov	r1, r4
57e0de80:	e1a0000d 	mov	r0, sp
57e0de84:	e3a02040 	mov	r2, #64	; 0x40
57e0de88:	eb00593c 	bl	57e24380 <memmove>
	image_set_hcrc(&header, 0);

	hcrc = crc32(0, (unsigned char *)&header, len);
57e0de8c:	e1a0100d 	mov	r1, sp
	static inline void image_set_##f(image_header_t *hdr, uint32_t val) \
	{ \
		hdr->ih_##f = cpu_to_uimage(val); \
	}
image_set_hdr_l(magic)		/* image_set_magic */
image_set_hdr_l(hcrc)		/* image_set_hcrc */
57e0de90:	e3a00000 	mov	r0, #0
57e0de94:	e3a02040 	mov	r2, #64	; 0x40
57e0de98:	e58d0004 	str	r0, [sp, #4]
57e0de9c:	eb0050db 	bl	57e22210 <crc32>

	return 0;

error:
	return -1;
}
57e0dea0:	e5943004 	ldr	r3, [r4, #4]
	ulong hcrc;
	ulong len = image_get_header_size();
	image_header_t header;

	/* Copy header so we can blank CRC field for re-calculation */
	memmove(&header, (char *)hdr, image_get_header_size());
57e0dea4:	e1a0500d 	mov	r5, sp
57e0dea8:	e1a02c03 	lsl	r2, r3, #24
57e0deac:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e0deb0:	e1822c23 	orr	r2, r2, r3, lsr #24
57e0deb4:	e1822401 	orr	r2, r2, r1, lsl #8
57e0deb8:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e0debc:	e1823423 	orr	r3, r2, r3, lsr #8
	image_set_hcrc(&header, 0);

	hcrc = crc32(0, (unsigned char *)&header, len);

	return (hcrc == image_get_hcrc(hdr));
}
57e0dec0:	e1500003 	cmp	r0, r3
57e0dec4:	13a00000 	movne	r0, #0
57e0dec8:	03a00001 	moveq	r0, #1
57e0decc:	e28dd044 	add	sp, sp, #68	; 0x44
57e0ded0:	e8bd8030 	pop	{r4, r5, pc}

57e0ded4 <image_check_dcrc>:

	return 0;

error:
	return -1;
}
57e0ded4:	e590200c 	ldr	r2, [r0, #12]

	return (hcrc == image_get_hcrc(hdr));
}

int image_check_dcrc(const image_header_t *hdr)
{
57e0ded8:	e92d4010 	push	{r4, lr}
57e0dedc:	e1a03c02 	lsl	r3, r2, #24
57e0dee0:	e2021cff 	and	r1, r2, #65280	; 0xff00
57e0dee4:	e1833c22 	orr	r3, r3, r2, lsr #24
57e0dee8:	e1a04000 	mov	r4, r0
57e0deec:	e1833401 	orr	r3, r3, r1, lsl #8
57e0def0:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
57e0def4:	e2841040 	add	r1, r4, #64	; 0x40
57e0def8:	e1832422 	orr	r2, r3, r2, lsr #8
57e0defc:	e3a00000 	mov	r0, #0
57e0df00:	e3a03801 	mov	r3, #65536	; 0x10000
57e0df04:	eb0050c6 	bl	57e22224 <crc32_wd>

	return 0;

error:
	return -1;
}
57e0df08:	e5943018 	ldr	r3, [r4, #24]
57e0df0c:	e1a02c03 	lsl	r2, r3, #24
57e0df10:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e0df14:	e1822c23 	orr	r2, r2, r3, lsr #24
57e0df18:	e1822401 	orr	r2, r2, r1, lsl #8
57e0df1c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e0df20:	e1823423 	orr	r3, r2, r3, lsr #8
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);

	return (dcrc == image_get_dcrc(hdr));
}
57e0df24:	e1500003 	cmp	r0, r3
57e0df28:	13a00000 	movne	r0, #0
57e0df2c:	03a00001 	moveq	r0, #1
57e0df30:	e8bd8010 	pop	{r4, pc}

57e0df34 <image_multi_count>:
	/* get start of the image payload, which in case of multi
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* count non empty slots */
	for (i = 0; size[i]; ++i)
57e0df34:	e280303c 	add	r3, r0, #60	; 0x3c
57e0df38:	e3a00000 	mov	r0, #0
57e0df3c:	ea000000 	b	57e0df44 <image_multi_count+0x10>
57e0df40:	e2800001 	add	r0, r0, #1
57e0df44:	e5b32004 	ldr	r2, [r3, #4]!
57e0df48:	e3520000 	cmp	r2, #0
57e0df4c:	1afffffb 	bne	57e0df40 <image_multi_count+0xc>
		count++;

	return count;
}
57e0df50:	e12fff1e 	bx	lr

57e0df54 <image_multi_getimg>:
 *     data address and size of the component, if idx is valid
 *     0 in data and len, if idx is out of range
 */
void image_multi_getimg(const image_header_t *hdr, ulong idx,
			ulong *data, ulong *len)
{
57e0df54:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e0df58:	e1a07003 	mov	r7, r3
57e0df5c:	e1a05001 	mov	r5, r1
57e0df60:	e1a04000 	mov	r4, r0
57e0df64:	e1a06002 	mov	r6, r2
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
57e0df68:	ebfffff1 	bl	57e0df34 <image_multi_count>

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
57e0df6c:	e1550000 	cmp	r5, r0
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
57e0df70:	23a03000 	movcs	r3, #0
57e0df74:	25873000 	strcs	r3, [r7]

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
57e0df78:	2a00001c 	bcs	57e0dff0 <image_multi_getimg+0x9c>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
57e0df7c:	e284c040 	add	ip, r4, #64	; 0x40
		*len = uimage_to_cpu(size[idx]);
57e0df80:	e79c2105 	ldr	r2, [ip, r5, lsl #2]
57e0df84:	e284403c 	add	r4, r4, #60	; 0x3c
57e0df88:	e1a03c02 	lsl	r3, r2, #24
57e0df8c:	e2021cff 	and	r1, r2, #65280	; 0xff00
57e0df90:	e1833c22 	orr	r3, r3, r2, lsr #24
57e0df94:	e1833401 	orr	r3, r3, r1, lsl #8
57e0df98:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
57e0df9c:	e1832422 	orr	r2, r3, r2, lsr #8
		offset = 0;
57e0dfa0:	e3a03000 	mov	r3, #0
	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
57e0dfa4:	e5872000 	str	r2, [r7]
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
57e0dfa8:	e1a01003 	mov	r1, r3
57e0dfac:	ea00000a 	b	57e0dfdc <image_multi_getimg+0x88>
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
57e0dfb0:	e5b42004 	ldr	r2, [r4, #4]!
	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
57e0dfb4:	e2811001 	add	r1, r1, #1
57e0dfb8:	e1a07c02 	lsl	r7, r2, #24
57e0dfbc:	e1877c22 	orr	r7, r7, r2, lsr #24
57e0dfc0:	e202acff 	and	sl, r2, #65280	; 0xff00
57e0dfc4:	e187740a 	orr	r7, r7, sl, lsl #8
57e0dfc8:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
57e0dfcc:	e1872422 	orr	r2, r7, r2, lsr #8
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
57e0dfd0:	e2822003 	add	r2, r2, #3
57e0dfd4:	e3c22003 	bic	r2, r2, #3
57e0dfd8:	e0833002 	add	r3, r3, r2
	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
57e0dfdc:	e1510005 	cmp	r1, r5
57e0dfe0:	1afffff2 	bne	57e0dfb0 <image_multi_getimg+0x5c>
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);
57e0dfe4:	e2800001 	add	r0, r0, #1
57e0dfe8:	e08cc100 	add	ip, ip, r0, lsl #2
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
57e0dfec:	e08c3003 	add	r3, ip, r3
	} else {
		*len = 0;
		*data = 0;
57e0dff0:	e5863000 	str	r3, [r6]
57e0dff4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

57e0dff8 <getenv_bootm_low>:
	return 0;
}
U_BOOT_ENV_CALLBACK(loadaddr, on_loadaddr);

ulong getenv_bootm_low(void)
{
57e0dff8:	e92d4010 	push	{r4, lr}
	char *s = getenv("bootm_low");
57e0dffc:	e59f0020 	ldr	r0, [pc, #32]	; 57e0e024 <getenv_bootm_low+0x2c>
57e0e000:	ebffe5b8 	bl	57e076e8 <getenv>
	if (s) {
57e0e004:	e3500000 	cmp	r0, #0
57e0e008:	0a000003 	beq	57e0e01c <getenv_bootm_low+0x24>
		ulong tmp = simple_strtoul(s, NULL, 16);
57e0e00c:	e3a01000 	mov	r1, #0
57e0e010:	e3a02010 	mov	r2, #16
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
57e0e014:	e8bd4010 	pop	{r4, lr}

ulong getenv_bootm_low(void)
{
	char *s = getenv("bootm_low");
	if (s) {
		ulong tmp = simple_strtoul(s, NULL, 16);
57e0e018:	ea005c21 	b	57e250a4 <simple_strtoul>
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
57e0e01c:	e3a00205 	mov	r0, #1342177280	; 0x50000000
57e0e020:	e8bd8010 	pop	{r4, pc}
57e0e024:	57e324aa 	.word	0x57e324aa

57e0e028 <getenv_bootm_size>:

phys_size_t getenv_bootm_size(void)
{
57e0e028:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_size");
57e0e02c:	e59f0048 	ldr	r0, [pc, #72]	; 57e0e07c <getenv_bootm_size+0x54>
57e0e030:	ebffe5ac 	bl	57e076e8 <getenv>
	if (s) {
57e0e034:	e2504000 	subs	r4, r0, #0
57e0e038:	0a000003 	beq	57e0e04c <getenv_bootm_size+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
57e0e03c:	e3a02010 	mov	r2, #16
57e0e040:	e3a01000 	mov	r1, #0
57e0e044:	eb005c86 	bl	57e25264 <simple_strtoull>
		return tmp;
57e0e048:	e8bd8010 	pop	{r4, pc}
	}
	s = getenv("bootm_low");
57e0e04c:	e59f002c 	ldr	r0, [pc, #44]	; 57e0e080 <getenv_bootm_size+0x58>
57e0e050:	ebffe5a4 	bl	57e076e8 <getenv>
	if (s)
57e0e054:	e2503000 	subs	r3, r0, #0
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
	else
		tmp = 0;
57e0e058:	01a00003 	moveq	r0, r3
	if (s) {
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
		return tmp;
	}
	s = getenv("bootm_low");
	if (s)
57e0e05c:	0a000002 	beq	57e0e06c <getenv_bootm_size+0x44>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
57e0e060:	e1a01004 	mov	r1, r4
57e0e064:	e3a02010 	mov	r2, #16
57e0e068:	eb005c7d 	bl	57e25264 <simple_strtoull>
	else
		tmp = 0;


#if defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].size - tmp;
57e0e06c:	e5983000 	ldr	r3, [r8]
57e0e070:	e593301c 	ldr	r3, [r3, #28]
57e0e074:	e0600003 	rsb	r0, r0, r3
#else
	return gd->bd->bi_memsize - tmp;
#endif
}
57e0e078:	e8bd8010 	pop	{r4, pc}
57e0e07c:	57e324b4 	.word	0x57e324b4
57e0e080:	57e324aa 	.word	0x57e324aa

57e0e084 <getenv_bootm_mapsize>:

phys_size_t getenv_bootm_mapsize(void)
{
57e0e084:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_mapsize");
57e0e088:	e59f0020 	ldr	r0, [pc, #32]	; 57e0e0b0 <getenv_bootm_mapsize+0x2c>
57e0e08c:	ebffe595 	bl	57e076e8 <getenv>
	if (s) {
57e0e090:	e3500000 	cmp	r0, #0
57e0e094:	0a000003 	beq	57e0e0a8 <getenv_bootm_mapsize+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
57e0e098:	e3a02010 	mov	r2, #16
57e0e09c:	e3a01000 	mov	r1, #0
57e0e0a0:	eb005c6f 	bl	57e25264 <simple_strtoull>
#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
#endif
}
57e0e0a4:	e8bd8010 	pop	{r4, pc}
57e0e0a8:	e8bd4010 	pop	{r4, lr}
	}

#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
57e0e0ac:	eaffffdd 	b	57e0e028 <getenv_bootm_size>
57e0e0b0:	57e324bf 	.word	0x57e324bf

57e0e0b4 <memmove_wd>:
#endif
}

void memmove_wd(void *to, void *from, size_t len, ulong chunksz)
{
	if (to == from)
57e0e0b4:	e1510000 	cmp	r1, r0
57e0e0b8:	012fff1e 	bxeq	lr
		to += tail;
		from += tail;
		len -= tail;
	}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
	memmove(to, from, len);
57e0e0bc:	ea0058af 	b	57e24380 <memmove>

57e0e0c0 <genimg_print_size>:
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
}
#endif /* !USE_HOSTCC */

void genimg_print_size(uint32_t size)
{
57e0e0c0:	e92d4010 	push	{r4, lr}
57e0e0c4:	e1a04000 	mov	r4, r0
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
57e0e0c8:	e1a01004 	mov	r1, r4
57e0e0cc:	e59f0014 	ldr	r0, [pc, #20]	; 57e0e0e8 <genimg_print_size+0x28>
57e0e0d0:	ebffecdd 	bl	57e0944c <printf>
	print_size(size, "\n");
57e0e0d4:	e59f2010 	ldr	r2, [pc, #16]	; 57e0e0ec <genimg_print_size+0x2c>
57e0e0d8:	e1a00004 	mov	r0, r4
57e0e0dc:	e3a01000 	mov	r1, #0
#else
	printf("%d Bytes = %.2f kB = %.2f MB\n",
			size, (double)size / 1.024e3,
			(double)size / 1.048576e6);
#endif
}
57e0e0e0:	e8bd4010 	pop	{r4, lr}

void genimg_print_size(uint32_t size)
{
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
	print_size(size, "\n");
57e0e0e4:	ea005061 	b	57e22270 <print_size>
57e0e0e8:	57e324cd 	.word	0x57e324cd
57e0e0ec:	57e32390 	.word	0x57e32390

57e0e0f0 <get_table_entry_name>:
 * returns:
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
57e0e0f0:	e1a03000 	mov	r3, r0
	for (; table->id >= 0; ++table) {
57e0e0f4:	ea000003 	b	57e0e108 <get_table_entry_name+0x18>
		if (table->id == id)
57e0e0f8:	e1500002 	cmp	r0, r2
#if defined(USE_HOSTCC) || !defined(CONFIG_NEEDS_MANUAL_RELOC)
			return table->lname;
57e0e0fc:	05931008 	ldreq	r1, [r3, #8]
57e0e100:	0a000003 	beq	57e0e114 <get_table_entry_name+0x24>
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
	for (; table->id >= 0; ++table) {
57e0e104:	e283300c 	add	r3, r3, #12
57e0e108:	e5930000 	ldr	r0, [r3]
57e0e10c:	e3500000 	cmp	r0, #0
57e0e110:	aafffff8 	bge	57e0e0f8 <get_table_entry_name+0x8>
#else
			return table->lname + gd->reloc_off;
#endif
	}
	return (msg);
}
57e0e114:	e1a00001 	mov	r0, r1
57e0e118:	e12fff1e 	bx	lr

57e0e11c <genimg_get_os_name>:

const char *genimg_get_os_name(uint8_t os)
{
57e0e11c:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_os, "Unknown OS", os));
57e0e120:	e59f1004 	ldr	r1, [pc, #4]	; 57e0e12c <genimg_get_os_name+0x10>
57e0e124:	e59f0004 	ldr	r0, [pc, #4]	; 57e0e130 <genimg_get_os_name+0x14>
57e0e128:	eafffff0 	b	57e0e0f0 <get_table_entry_name>
57e0e12c:	57e324d9 	.word	0x57e324d9
57e0e130:	57e2bf98 	.word	0x57e2bf98

57e0e134 <genimg_get_arch_name>:
}

const char *genimg_get_arch_name(uint8_t arch)
{
57e0e134:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_arch, "Unknown Architecture",
57e0e138:	e59f1004 	ldr	r1, [pc, #4]	; 57e0e144 <genimg_get_arch_name+0x10>
57e0e13c:	e59f0004 	ldr	r0, [pc, #4]	; 57e0e148 <genimg_get_arch_name+0x14>
57e0e140:	eaffffea 	b	57e0e0f0 <get_table_entry_name>
57e0e144:	57e324e4 	.word	0x57e324e4
57e0e148:	57e2c004 	.word	0x57e2c004

57e0e14c <genimg_get_type_name>:
					arch));
}

const char *genimg_get_type_name(uint8_t type)
{
57e0e14c:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_type, "Unknown Image", type));
57e0e150:	e59f1004 	ldr	r1, [pc, #4]	; 57e0e15c <genimg_get_type_name+0x10>
57e0e154:	e59f0004 	ldr	r0, [pc, #4]	; 57e0e160 <genimg_get_type_name+0x14>
57e0e158:	eaffffe4 	b	57e0e0f0 <get_table_entry_name>
57e0e15c:	57e324f9 	.word	0x57e324f9
57e0e160:	57e2c100 	.word	0x57e2c100

57e0e164 <genimg_get_comp_name>:
}

const char *genimg_get_comp_name(uint8_t comp)
{
57e0e164:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_comp, "Unknown Compression",
57e0e168:	e59f1004 	ldr	r1, [pc, #4]	; 57e0e174 <genimg_get_comp_name+0x10>
57e0e16c:	e59f0004 	ldr	r0, [pc, #4]	; 57e0e178 <genimg_get_comp_name+0x14>
57e0e170:	eaffffde 	b	57e0e0f0 <get_table_entry_name>
57e0e174:	57e32507 	.word	0x57e32507
57e0e178:	57e2c1cc 	.word	0x57e2c1cc

57e0e17c <image_print_contents>:
 *
 * returns:
 *     no returned results
 */
void image_print_contents(const void *ptr)
{
57e0e17c:	e92d44ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, sl, lr}
57e0e180:	e1a04000 	mov	r4, r0
	p = "";
#else
	p = "   ";
#endif

	printf("%sImage Name:   %.*s\n", p, IH_NMLEN, image_get_name(hdr));
57e0e184:	e3a02020 	mov	r2, #32
57e0e188:	e0843002 	add	r3, r4, r2
57e0e18c:	e59f116c 	ldr	r1, [pc, #364]	; 57e0e300 <image_print_contents+0x184>
57e0e190:	e59f016c 	ldr	r0, [pc, #364]	; 57e0e304 <image_print_contents+0x188>
57e0e194:	ebffecac 	bl	57e0944c <printf>
#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
57e0e198:	e59f1160 	ldr	r1, [pc, #352]	; 57e0e300 <image_print_contents+0x184>
57e0e19c:	e59f0164 	ldr	r0, [pc, #356]	; 57e0e308 <image_print_contents+0x18c>
57e0e1a0:	ebffeca9 	bl	57e0944c <printf>

static void image_print_type(const image_header_t *hdr)
{
	const char *os, *arch, *type, *comp;

	os = genimg_get_os_name(image_get_os(hdr));
57e0e1a4:	e5d4001c 	ldrb	r0, [r4, #28]
57e0e1a8:	ebffffdb 	bl	57e0e11c <genimg_get_os_name>
57e0e1ac:	e1a06000 	mov	r6, r0
	arch = genimg_get_arch_name(image_get_arch(hdr));
57e0e1b0:	e5d4001d 	ldrb	r0, [r4, #29]
57e0e1b4:	ebffffde 	bl	57e0e134 <genimg_get_arch_name>
57e0e1b8:	e1a07000 	mov	r7, r0
	type = genimg_get_type_name(image_get_type(hdr));
57e0e1bc:	e5d4001e 	ldrb	r0, [r4, #30]
57e0e1c0:	ebffffe1 	bl	57e0e14c <genimg_get_type_name>
57e0e1c4:	e1a05000 	mov	r5, r0
	comp = genimg_get_comp_name(image_get_comp(hdr));
57e0e1c8:	e5d4001f 	ldrb	r0, [r4, #31]
57e0e1cc:	ebffffe4 	bl	57e0e164 <genimg_get_comp_name>

	printf("%s %s %s (%s)\n", arch, os, type, comp);
57e0e1d0:	e1a02006 	mov	r2, r6
57e0e1d4:	e1a03005 	mov	r3, r5
57e0e1d8:	e58d0000 	str	r0, [sp]
57e0e1dc:	e1a01007 	mov	r1, r7
57e0e1e0:	e59f0124 	ldr	r0, [pc, #292]	; 57e0e30c <image_print_contents+0x190>
57e0e1e4:	ebffec98 	bl	57e0944c <printf>
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
	image_print_type(hdr);
	printf("%sData Size:    ", p);
57e0e1e8:	e59f1110 	ldr	r1, [pc, #272]	; 57e0e300 <image_print_contents+0x184>
57e0e1ec:	e59f011c 	ldr	r0, [pc, #284]	; 57e0e310 <image_print_contents+0x194>
57e0e1f0:	ebffec95 	bl	57e0944c <printf>

	return 0;

error:
	return -1;
}
57e0e1f4:	e594300c 	ldr	r3, [r4, #12]
57e0e1f8:	e1a02c03 	lsl	r2, r3, #24
57e0e1fc:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e0e200:	e1822c23 	orr	r2, r2, r3, lsr #24
57e0e204:	e1822401 	orr	r2, r2, r1, lsl #8
57e0e208:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
	image_print_type(hdr);
	printf("%sData Size:    ", p);
	genimg_print_size(image_get_data_size(hdr));
57e0e20c:	e1820423 	orr	r0, r2, r3, lsr #8
57e0e210:	ebffffaa 	bl	57e0e0c0 <genimg_print_size>

	return 0;

error:
	return -1;
}
57e0e214:	e5942010 	ldr	r2, [r4, #16]
#endif
	printf("%sImage Type:   ", p);
	image_print_type(hdr);
	printf("%sData Size:    ", p);
	genimg_print_size(image_get_data_size(hdr));
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
57e0e218:	e59f00f4 	ldr	r0, [pc, #244]	; 57e0e314 <image_print_contents+0x198>
57e0e21c:	e1a03c02 	lsl	r3, r2, #24
57e0e220:	e2021cff 	and	r1, r2, #65280	; 0xff00
57e0e224:	e1833c22 	orr	r3, r3, r2, lsr #24
57e0e228:	e1833401 	orr	r3, r3, r1, lsl #8
57e0e22c:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
57e0e230:	e1832422 	orr	r2, r3, r2, lsr #8
57e0e234:	e59f10c4 	ldr	r1, [pc, #196]	; 57e0e300 <image_print_contents+0x184>
57e0e238:	ebffec83 	bl	57e0944c <printf>

	return 0;

error:
	return -1;
}
57e0e23c:	e5942014 	ldr	r2, [r4, #20]
	printf("%sImage Type:   ", p);
	image_print_type(hdr);
	printf("%sData Size:    ", p);
	genimg_print_size(image_get_data_size(hdr));
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));
57e0e240:	e59f00d0 	ldr	r0, [pc, #208]	; 57e0e318 <image_print_contents+0x19c>
57e0e244:	e1a03c02 	lsl	r3, r2, #24
57e0e248:	e2021cff 	and	r1, r2, #65280	; 0xff00
57e0e24c:	e1833c22 	orr	r3, r3, r2, lsr #24
57e0e250:	e1833401 	orr	r3, r3, r1, lsl #8
57e0e254:	e20228ff 	and	r2, r2, #16711680	; 0xff0000
57e0e258:	e1832422 	orr	r2, r3, r2, lsr #8
57e0e25c:	e59f109c 	ldr	r1, [pc, #156]	; 57e0e300 <image_print_contents+0x184>
57e0e260:	ebffec79 	bl	57e0944c <printf>

	return 0;

error:
	return -1;
}
57e0e264:	e5d4301e 	ldrb	r3, [r4, #30]
	printf("%sData Size:    ", p);
	genimg_print_size(image_get_data_size(hdr));
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
57e0e268:	e3530004 	cmp	r3, #4
57e0e26c:	0a000001 	beq	57e0e278 <image_print_contents+0xfc>
57e0e270:	e3530006 	cmp	r3, #6
57e0e274:	1a000020 	bne	57e0e2fc <image_print_contents+0x180>
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
57e0e278:	e1a00004 	mov	r0, r4
57e0e27c:	ebffff2c 	bl	57e0df34 <image_multi_count>

		printf("%sContents:\n", p);
57e0e280:	e59f1078 	ldr	r1, [pc, #120]	; 57e0e300 <image_print_contents+0x184>

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
57e0e284:	e1a06000 	mov	r6, r0

		printf("%sContents:\n", p);
57e0e288:	e59f008c 	ldr	r0, [pc, #140]	; 57e0e31c <image_print_contents+0x1a0>
57e0e28c:	ebffec6e 	bl	57e0944c <printf>
		for (i = 0; i < count; i++) {
57e0e290:	e3a05000 	mov	r5, #0
			image_multi_getimg(hdr, i, &data, &len);
57e0e294:	e28d700c 	add	r7, sp, #12
57e0e298:	e28da008 	add	sl, sp, #8
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
57e0e29c:	ea000014 	b	57e0e2f4 <image_print_contents+0x178>
			image_multi_getimg(hdr, i, &data, &len);
57e0e2a0:	e1a0300a 	mov	r3, sl
57e0e2a4:	e1a00004 	mov	r0, r4
57e0e2a8:	e1a01005 	mov	r1, r5
57e0e2ac:	e1a02007 	mov	r2, r7
57e0e2b0:	ebffff27 	bl	57e0df54 <image_multi_getimg>

			printf("%s   Image %d: ", p, i);
57e0e2b4:	e59f1044 	ldr	r1, [pc, #68]	; 57e0e300 <image_print_contents+0x184>
57e0e2b8:	e1a02005 	mov	r2, r5
57e0e2bc:	e59f005c 	ldr	r0, [pc, #92]	; 57e0e320 <image_print_contents+0x1a4>
57e0e2c0:	ebffec61 	bl	57e0944c <printf>
			genimg_print_size(len);
57e0e2c4:	e59d0008 	ldr	r0, [sp, #8]
57e0e2c8:	ebffff7c 	bl	57e0e0c0 <genimg_print_size>

			if (image_check_type(hdr, IH_TYPE_SCRIPT) && i > 0) {
57e0e2cc:	e5d4301e 	ldrb	r3, [r4, #30]
57e0e2d0:	e3530006 	cmp	r3, #6
57e0e2d4:	1a000005 	bne	57e0e2f0 <image_print_contents+0x174>
57e0e2d8:	e3550000 	cmp	r5, #0
57e0e2dc:	0a000003 	beq	57e0e2f0 <image_print_contents+0x174>
				/*
				 * the user may need to know offsets
				 * if planning to do something with
				 * multiple files
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
57e0e2e0:	e59f003c 	ldr	r0, [pc, #60]	; 57e0e324 <image_print_contents+0x1a8>
57e0e2e4:	e59f1014 	ldr	r1, [pc, #20]	; 57e0e300 <image_print_contents+0x184>
57e0e2e8:	e59d200c 	ldr	r2, [sp, #12]
57e0e2ec:	ebffec56 	bl	57e0944c <printf>
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
57e0e2f0:	e2855001 	add	r5, r5, #1
57e0e2f4:	e1550006 	cmp	r5, r6
57e0e2f8:	3affffe8 	bcc	57e0e2a0 <image_print_contents+0x124>
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
			}
		}
	}
}
57e0e2fc:	e8bd84ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, sl, pc}
57e0e300:	57e35099 	.word	0x57e35099
57e0e304:	57e3251b 	.word	0x57e3251b
57e0e308:	57e32531 	.word	0x57e32531
57e0e30c:	57e32542 	.word	0x57e32542
57e0e310:	57e32551 	.word	0x57e32551
57e0e314:	57e32562 	.word	0x57e32562
57e0e318:	57e32578 	.word	0x57e32578
57e0e31c:	57e3258e 	.word	0x57e3258e
57e0e320:	57e3259b 	.word	0x57e3259b
57e0e324:	57e325ab 	.word	0x57e325ab

57e0e328 <get_table_entry_id>:
 *     entry id if translation succeeds
 *     -1 otherwise
 */
int get_table_entry_id(const table_entry_t *table,
		const char *table_name, const char *name)
{
57e0e328:	e92d4038 	push	{r3, r4, r5, lr}
57e0e32c:	e1a05002 	mov	r5, r2
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
57e0e330:	e1a04000 	mov	r4, r0
57e0e334:	ea000009 	b	57e0e360 <get_table_entry_id+0x38>
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		if (t->sname && strcmp(t->sname + gd->reloc_off, name) == 0)
#else
		if (t->sname && strcmp(t->sname, name) == 0)
57e0e338:	e5940004 	ldr	r0, [r4, #4]
57e0e33c:	e3500000 	cmp	r0, #0
57e0e340:	0a000005 	beq	57e0e35c <get_table_entry_id+0x34>
57e0e344:	e1a01005 	mov	r1, r5
57e0e348:	eb005715 	bl	57e23fa4 <strcmp>
57e0e34c:	e3500000 	cmp	r0, #0
57e0e350:	1a000001 	bne	57e0e35c <get_table_entry_id+0x34>
#endif
			return (t->id);
57e0e354:	e5940000 	ldr	r0, [r4]
57e0e358:	e8bd8038 	pop	{r3, r4, r5, pc}
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
57e0e35c:	e284400c 	add	r4, r4, #12
57e0e360:	e5943000 	ldr	r3, [r4]
57e0e364:	e3530000 	cmp	r3, #0
57e0e368:	aafffff2 	bge	57e0e338 <get_table_entry_id+0x10>
#endif
			return (t->id);
	}
	debug("Invalid %s Type: %s\n", table_name, name);
#endif /* USE_HOSTCC */
	return (-1);
57e0e36c:	e3e00000 	mvn	r0, #0
}
57e0e370:	e8bd8038 	pop	{r3, r4, r5, pc}

57e0e374 <genimg_get_os_id>:

int genimg_get_os_id(const char *name)
{
57e0e374:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_os, "OS", name));
57e0e378:	e59f1004 	ldr	r1, [pc, #4]	; 57e0e384 <genimg_get_os_id+0x10>
57e0e37c:	e59f0004 	ldr	r0, [pc, #4]	; 57e0e388 <genimg_get_os_id+0x14>
57e0e380:	eaffffe8 	b	57e0e328 <get_table_entry_id>
57e0e384:	57e329d1 	.word	0x57e329d1
57e0e388:	57e2bf98 	.word	0x57e2bf98

57e0e38c <genimg_get_arch_id>:
}

int genimg_get_arch_id(const char *name)
{
57e0e38c:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_arch, "CPU", name));
57e0e390:	e59f1004 	ldr	r1, [pc, #4]	; 57e0e39c <genimg_get_arch_id+0x10>
57e0e394:	e59f0004 	ldr	r0, [pc, #4]	; 57e0e3a0 <genimg_get_arch_id+0x14>
57e0e398:	eaffffe2 	b	57e0e328 <get_table_entry_id>
57e0e39c:	57e2e5b8 	.word	0x57e2e5b8
57e0e3a0:	57e2c004 	.word	0x57e2c004

57e0e3a4 <genimg_get_type_id>:
}

int genimg_get_type_id(const char *name)
{
57e0e3a4:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_type, "Image", name));
57e0e3a8:	e59f1004 	ldr	r1, [pc, #4]	; 57e0e3b4 <genimg_get_type_id+0x10>
57e0e3ac:	e59f0004 	ldr	r0, [pc, #4]	; 57e0e3b8 <genimg_get_type_id+0x14>
57e0e3b0:	eaffffdc 	b	57e0e328 <get_table_entry_id>
57e0e3b4:	57e32814 	.word	0x57e32814
57e0e3b8:	57e2c100 	.word	0x57e2c100

57e0e3bc <genimg_get_comp_id>:
}

int genimg_get_comp_id(const char *name)
{
57e0e3bc:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_comp, "Compression", name));
57e0e3c0:	e59f1004 	ldr	r1, [pc, #4]	; 57e0e3cc <genimg_get_comp_id+0x10>
57e0e3c4:	e59f0004 	ldr	r0, [pc, #4]	; 57e0e3d0 <genimg_get_comp_id+0x14>
57e0e3c8:	eaffffd6 	b	57e0e328 <get_table_entry_id>
57e0e3cc:	57e3250f 	.word	0x57e3250f
57e0e3d0:	57e2c1cc 	.word	0x57e2c1cc

57e0e3d4 <genimg_get_format>:

	return 0;

error:
	return -1;
}
57e0e3d4:	e5903000 	ldr	r3, [r0]
57e0e3d8:	e1a00c03 	lsl	r0, r3, #24
57e0e3dc:	e2032cff 	and	r2, r3, #65280	; 0xff00
57e0e3e0:	e1800c23 	orr	r0, r0, r3, lsr #24
57e0e3e4:	e1800402 	orr	r0, r0, r2, lsl #8
57e0e3e8:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
			format = IMAGE_FORMAT_FIT;
	}
#endif

	return format;
}
57e0e3ec:	e59f2010 	ldr	r2, [pc, #16]	; 57e0e404 <genimg_get_format+0x30>
57e0e3f0:	e1800423 	orr	r0, r0, r3, lsr #8
57e0e3f4:	e1500002 	cmp	r0, r2
57e0e3f8:	13a00000 	movne	r0, #0
57e0e3fc:	03a00001 	moveq	r0, #1
57e0e400:	e12fff1e 	bx	lr
57e0e404:	27051956 	.word	0x27051956

57e0e408 <genimg_get_image>:

	}
#endif /* CONFIG_HAS_DATAFLASH */

	return ram_addr;
}
57e0e408:	e12fff1e 	bx	lr

57e0e40c <genimg_has_config>:
#if defined(CONFIG_FIT)
	if (images->fit_uname_cfg)
		return 1;
#endif
	return 0;
}
57e0e40c:	e3a00000 	mov	r0, #0
57e0e410:	e12fff1e 	bx	lr

57e0e414 <boot_get_ramdisk>:
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
57e0e414:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
57e0e418:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
57e0e41c:	e59d502c 	ldr	r5, [sp, #44]	; 0x2c
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
57e0e420:	e3a09000 	mov	r9, #0

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
57e0e424:	e3500002 	cmp	r0, #2
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
57e0e428:	e5879000 	str	r9, [r7]
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
57e0e42c:	e1a06001 	mov	r6, r1
57e0e430:	e1a04002 	mov	r4, r2
57e0e434:	e1a0a003 	mov	sl, r3
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
	*rd_end = 0;
57e0e438:	e5859000 	str	r9, [r5]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
57e0e43c:	da000007 	ble	57e0e460 <boot_get_ramdisk+0x4c>
57e0e440:	e5910008 	ldr	r0, [r1, #8]
57e0e444:	e59f11fc 	ldr	r1, [pc, #508]	; 57e0e648 <boot_get_ramdisk+0x234>
57e0e448:	eb0056d5 	bl	57e23fa4 <strcmp>
57e0e44c:	e3500000 	cmp	r0, #0
		debug("## Skipping init Ramdisk\n");
		rd_len = rd_data = 0;
57e0e450:	058d0004 	streq	r0, [sp, #4]
57e0e454:	058d0000 	streq	r0, [sp]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
57e0e458:	0a000067 	beq	57e0e5fc <boot_get_ramdisk+0x1e8>
57e0e45c:	ea00006f 	b	57e0e620 <boot_get_ramdisk+0x20c>
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
57e0e460:	e5923044 	ldr	r3, [r2, #68]	; 0x44
57e0e464:	e3530000 	cmp	r3, #0
57e0e468:	1a000050 	bne	57e0e5b0 <boot_get_ramdisk+0x19c>
57e0e46c:	ea00005d 	b	57e0e5e8 <boot_get_ramdisk+0x1d4>
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
57e0e470:	e1a01006 	mov	r1, r6
57e0e474:	e59f01d0 	ldr	r0, [pc, #464]	; 57e0e64c <boot_get_ramdisk+0x238>
57e0e478:	ebffebf3 	bl	57e0944c <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e0e47c:	e3a00009 	mov	r0, #9
57e0e480:	eb000137 	bl	57e0e964 <__show_boot_progress>

	return 0;

error:
	return -1;
}
57e0e484:	e5963000 	ldr	r3, [r6]
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
					"Image at %08lx ...\n", rd_addr);

			bootstage_mark(BOOTSTAGE_ID_CHECK_RAMDISK);
			rd_hdr = image_get_ramdisk(rd_addr, arch,
57e0e488:	e5944084 	ldr	r4, [r4, #132]	; 0x84
57e0e48c:	e1a02c03 	lsl	r2, r3, #24
57e0e490:	e1822c23 	orr	r2, r2, r3, lsr #24
57e0e494:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e0e498:	e1822401 	orr	r2, r2, r1, lsl #8
57e0e49c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e0e4a0:	e1823423 	orr	r3, r2, r3, lsr #8
static const image_header_t *image_get_ramdisk(ulong rd_addr, uint8_t arch,
						int verify)
{
	const image_header_t *rd_hdr = (const image_header_t *)rd_addr;

	if (!image_check_magic(rd_hdr)) {
57e0e4a4:	e59f21a4 	ldr	r2, [pc, #420]	; 57e0e650 <boot_get_ramdisk+0x23c>
57e0e4a8:	e1530002 	cmp	r3, r2
57e0e4ac:	0a000003 	beq	57e0e4c0 <boot_get_ramdisk+0xac>
		puts("Bad Magic Number\n");
57e0e4b0:	e59f019c 	ldr	r0, [pc, #412]	; 57e0e654 <boot_get_ramdisk+0x240>
57e0e4b4:	ebffebda 	bl	57e09424 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e0e4b8:	e3e00009 	mvn	r0, #9
57e0e4bc:	ea000006 	b	57e0e4dc <boot_get_ramdisk+0xc8>
		bootstage_error(BOOTSTAGE_ID_RD_MAGIC);
		return NULL;
	}

	if (!image_check_hcrc(rd_hdr)) {
57e0e4c0:	e1a00006 	mov	r0, r6
57e0e4c4:	ebfffe69 	bl	57e0de70 <image_check_hcrc>
57e0e4c8:	e3500000 	cmp	r0, #0
57e0e4cc:	1a000004 	bne	57e0e4e4 <boot_get_ramdisk+0xd0>
		puts("Bad Header Checksum\n");
57e0e4d0:	e59f0180 	ldr	r0, [pc, #384]	; 57e0e658 <boot_get_ramdisk+0x244>
57e0e4d4:	ebffebd2 	bl	57e09424 <puts>
57e0e4d8:	e3e0000a 	mvn	r0, #10
57e0e4dc:	eb000120 	bl	57e0e964 <__show_boot_progress>
57e0e4e0:	ea00004c 	b	57e0e618 <boot_get_ramdisk+0x204>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e0e4e4:	e3a0000a 	mov	r0, #10
57e0e4e8:	eb00011d 	bl	57e0e964 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_RD_HDR_CHECKSUM);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_RD_MAGIC);
	image_print_contents(rd_hdr);
57e0e4ec:	e1a00006 	mov	r0, r6
57e0e4f0:	ebffff21 	bl	57e0e17c <image_print_contents>

	if (verify) {
57e0e4f4:	e3540000 	cmp	r4, #0
57e0e4f8:	0a00000b 	beq	57e0e52c <boot_get_ramdisk+0x118>
		puts("   Verifying Checksum ... ");
57e0e4fc:	e59f0158 	ldr	r0, [pc, #344]	; 57e0e65c <boot_get_ramdisk+0x248>
57e0e500:	ebffebc7 	bl	57e09424 <puts>
		if (!image_check_dcrc(rd_hdr)) {
57e0e504:	e1a00006 	mov	r0, r6
57e0e508:	ebfffe71 	bl	57e0ded4 <image_check_dcrc>
57e0e50c:	e3500000 	cmp	r0, #0
57e0e510:	1a000003 	bne	57e0e524 <boot_get_ramdisk+0x110>
			puts("Bad Data CRC\n");
57e0e514:	e59f0144 	ldr	r0, [pc, #324]	; 57e0e660 <boot_get_ramdisk+0x24c>
57e0e518:	ebffebc1 	bl	57e09424 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e0e51c:	e3e0000b 	mvn	r0, #11
57e0e520:	eaffffed 	b	57e0e4dc <boot_get_ramdisk+0xc8>
			bootstage_error(BOOTSTAGE_ID_RD_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
57e0e524:	e59f0138 	ldr	r0, [pc, #312]	; 57e0e664 <boot_get_ramdisk+0x250>
57e0e528:	ebffebbd 	bl	57e09424 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e0e52c:	e3a0000b 	mov	r0, #11
57e0e530:	eb00010b 	bl	57e0e964 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_RD_HDR_CHECKSUM);

	if (!image_check_os(rd_hdr, IH_OS_LINUX) ||
57e0e534:	e5d6301c 	ldrb	r3, [r6, #28]
57e0e538:	e3530005 	cmp	r3, #5
57e0e53c:	1a000005 	bne	57e0e558 <boot_get_ramdisk+0x144>
57e0e540:	e5d6301d 	ldrb	r3, [r6, #29]
57e0e544:	e153000a 	cmp	r3, sl
57e0e548:	1a000002 	bne	57e0e558 <boot_get_ramdisk+0x144>
	    !image_check_arch(rd_hdr, arch) ||
57e0e54c:	e5d6301e 	ldrb	r3, [r6, #30]
57e0e550:	e3530003 	cmp	r3, #3
57e0e554:	0a000007 	beq	57e0e578 <boot_get_ramdisk+0x164>
	    !image_check_type(rd_hdr, IH_TYPE_RAMDISK)) {
		printf("No Linux %s Ramdisk Image\n",
57e0e558:	e1a0000a 	mov	r0, sl
57e0e55c:	ebfffef4 	bl	57e0e134 <genimg_get_arch_name>
57e0e560:	e1a01000 	mov	r1, r0
57e0e564:	e59f00fc 	ldr	r0, [pc, #252]	; 57e0e668 <boot_get_ramdisk+0x254>
57e0e568:	ebffebb7 	bl	57e0944c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e0e56c:	e3e0000c 	mvn	r0, #12
57e0e570:	eb0000fb 	bl	57e0e964 <__show_boot_progress>
57e0e574:	ea00000b 	b	57e0e5a8 <boot_get_ramdisk+0x194>
57e0e578:	e2863040 	add	r3, r6, #64	; 0x40
							images->verify);

			if (rd_hdr == NULL)
				return 1;

			rd_data = image_get_data(rd_hdr);
57e0e57c:	e58d3004 	str	r3, [sp, #4]

	return 0;

error:
	return -1;
}
57e0e580:	e596300c 	ldr	r3, [r6, #12]
57e0e584:	e1a02c03 	lsl	r2, r3, #24
57e0e588:	e1822c23 	orr	r2, r2, r3, lsr #24
57e0e58c:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e0e590:	e1822401 	orr	r2, r2, r1, lsl #8
57e0e594:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e0e598:	e1823423 	orr	r3, r2, r3, lsr #8
57e0e59c:	ea000015 	b	57e0e5f8 <boot_get_ramdisk+0x1e4>
				rd_len = simple_strtoul(++end, NULL, 16);
				rd_data = rd_addr;
			} else
#endif
			{
				puts("Wrong Ramdisk Image Format\n");
57e0e5a0:	e59f00c4 	ldr	r0, [pc, #196]	; 57e0e66c <boot_get_ramdisk+0x258>
57e0e5a4:	ebffeb9e 	bl	57e09424 <puts>
				rd_data = rd_len = rd_load = 0;
				return 1;
57e0e5a8:	e3a09001 	mov	r9, #1
57e0e5ac:	ea000019 	b	57e0e618 <boot_get_ramdisk+0x204>
			}
		}
	} else if (images->legacy_hdr_valid &&
57e0e5b0:	e5d23022 	ldrb	r3, [r2, #34]	; 0x22
57e0e5b4:	e3530004 	cmp	r3, #4
57e0e5b8:	1a00000a 	bne	57e0e5e8 <boot_get_ramdisk+0x1d4>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e0e5bc:	e3a0000d 	mov	r0, #13
57e0e5c0:	eb0000e7 	bl	57e0e964 <__show_boot_progress>
		/*
		 * Now check if we have a legacy mult-component image,
		 * get second entry data start address and len.
		 */
		bootstage_mark(BOOTSTAGE_ID_RAMDISK);
		printf("## Loading init Ramdisk from multi component "
57e0e5c4:	e5941000 	ldr	r1, [r4]
57e0e5c8:	e59f00a0 	ldr	r0, [pc, #160]	; 57e0e670 <boot_get_ramdisk+0x25c>
57e0e5cc:	ebffeb9e 	bl	57e0944c <printf>
				"Legacy Image at %08lx ...\n",
				(ulong)images->legacy_hdr_os);

		image_multi_getimg(images->legacy_hdr_os, 1, &rd_data, &rd_len);
57e0e5d0:	e5940000 	ldr	r0, [r4]
57e0e5d4:	e3a01001 	mov	r1, #1
57e0e5d8:	e28d2004 	add	r2, sp, #4
57e0e5dc:	e1a0300d 	mov	r3, sp
57e0e5e0:	ebfffe5b 	bl	57e0df54 <image_multi_getimg>
57e0e5e4:	ea000004 	b	57e0e5fc <boot_get_ramdisk+0x1e8>
57e0e5e8:	e3a0000e 	mov	r0, #14
57e0e5ec:	eb0000dc 	bl	57e0e964 <__show_boot_progress>
	} else {
		/*
		 * no initrd image
		 */
		bootstage_mark(BOOTSTAGE_ID_NO_RAMDISK);
		rd_len = rd_data = 0;
57e0e5f0:	e3a03000 	mov	r3, #0
57e0e5f4:	e58d3004 	str	r3, [sp, #4]
57e0e5f8:	e58d3000 	str	r3, [sp]
	}

	if (!rd_data) {
57e0e5fc:	e59d9004 	ldr	r9, [sp, #4]
57e0e600:	e3590000 	cmp	r9, #0
		debug("## No init Ramdisk\n");
	} else {
		*rd_start = rd_data;
57e0e604:	15879000 	strne	r9, [r7]
		*rd_end = rd_data + rd_len;
57e0e608:	159d3000 	ldrne	r3, [sp]
57e0e60c:	10839009 	addne	r9, r3, r9
57e0e610:	15859000 	strne	r9, [r5]
	}
	debug("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
			*rd_start, *rd_end);

	return 0;
57e0e614:	13a09000 	movne	r9, #0
}
57e0e618:	e1a00009 	mov	r0, r9
57e0e61c:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
						"0x%08lx\n",
						fit_uname_ramdisk, rd_addr);
			} else
#endif
			{
				rd_addr = simple_strtoul(argv[2], NULL, 16);
57e0e620:	e1a01009 	mov	r1, r9
57e0e624:	e5960008 	ldr	r0, [r6, #8]
57e0e628:	e3a02010 	mov	r2, #16
57e0e62c:	eb005a9c 	bl	57e250a4 <simple_strtoul>
57e0e630:	e1a06000 	mov	r6, r0
		/*
		 * Check if there is an initrd image at the
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
57e0e634:	ebffff66 	bl	57e0e3d4 <genimg_get_format>
57e0e638:	e3500001 	cmp	r0, #1
57e0e63c:	e1a09000 	mov	r9, r0
57e0e640:	1affffd6 	bne	57e0e5a0 <boot_get_ramdisk+0x18c>
57e0e644:	eaffff89 	b	57e0e470 <boot_get_ramdisk+0x5c>
57e0e648:	57e3155e 	.word	0x57e3155e
57e0e64c:	57e325c3 	.word	0x57e325c3
57e0e650:	27051956 	.word	0x27051956
57e0e654:	57e2e62a 	.word	0x57e2e62a
57e0e658:	57e2e63f 	.word	0x57e2e63f
57e0e65c:	57e2e5d4 	.word	0x57e2e5d4
57e0e660:	57e2e657 	.word	0x57e2e657
57e0e664:	57e3455d 	.word	0x57e3455d
57e0e668:	57e325fb 	.word	0x57e325fb
57e0e66c:	57e32616 	.word	0x57e32616
57e0e670:	57e32632 	.word	0x57e32632

57e0e674 <boot_ramdisk_high>:
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
57e0e674:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
57e0e678:	e1a0a000 	mov	sl, r0
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
57e0e67c:	e59f010c 	ldr	r0, [pc, #268]	; 57e0e790 <boot_ramdisk_high+0x11c>
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
57e0e680:	e1a05003 	mov	r5, r3
57e0e684:	e1a04001 	mov	r4, r1
57e0e688:	e1a06002 	mov	r6, r2
57e0e68c:	e59d9020 	ldr	r9, [sp, #32]
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
57e0e690:	ebffe414 	bl	57e076e8 <getenv>
57e0e694:	e3500000 	cmp	r0, #0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
57e0e698:	03a07001 	moveq	r7, #1
		initrd_high = simple_strtoul(s, NULL, 16);
		if (initrd_high == ~0)
			initrd_copy_to_ram = 0;
	} else {
		/* not set, no restrictions to load high */
		initrd_high = ~0;
57e0e69c:	03e03000 	mvneq	r3, #0
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
57e0e6a0:	0a000005 	beq	57e0e6bc <boot_ramdisk_high+0x48>
		/* a value of "no" or a similar string will act like 0,
		 * turning the "load high" feature off. This is intentional.
		 */
		initrd_high = simple_strtoul(s, NULL, 16);
57e0e6a4:	e3a01000 	mov	r1, #0
57e0e6a8:	e3a02010 	mov	r2, #16
57e0e6ac:	eb005a7c 	bl	57e250a4 <simple_strtoul>
57e0e6b0:	e1a03000 	mov	r3, r0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
57e0e6b4:	e2907001 	adds	r7, r0, #1
57e0e6b8:	13a07001 	movne	r7, #1
#endif

	debug("## initrd_high = 0x%08lx, copy_to_ram = %d\n",
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
57e0e6bc:	e3540000 	cmp	r4, #0
57e0e6c0:	0a00002e 	beq	57e0e780 <boot_ramdisk_high+0x10c>
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
57e0e6c4:	e3570000 	cmp	r7, #0
57e0e6c8:	1a000008 	bne	57e0e6f0 <boot_ramdisk_high+0x7c>
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
57e0e6cc:	e0863004 	add	r3, r6, r4
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
57e0e6d0:	e5854000 	str	r4, [r5]
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
57e0e6d4:	e1a0000a 	mov	r0, sl

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
57e0e6d8:	e5893000 	str	r3, [r9]
			lmb_reserve(lmb, rd_data, rd_len);
57e0e6dc:	e1a01004 	mov	r1, r4
57e0e6e0:	e1a02006 	mov	r2, r6
57e0e6e4:	eb0054f3 	bl	57e23ab8 <lmb_reserve>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
57e0e6e8:	e1a00007 	mov	r0, r7
57e0e6ec:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
		} else {
			if (initrd_high)
57e0e6f0:	e3530000 	cmp	r3, #0
57e0e6f4:	0a000004 	beq	57e0e70c <boot_ramdisk_high+0x98>
				*initrd_start = (ulong)lmb_alloc_base(lmb,
57e0e6f8:	e1a0000a 	mov	r0, sl
57e0e6fc:	e1a01006 	mov	r1, r6
57e0e700:	e3a02a01 	mov	r2, #4096	; 0x1000
57e0e704:	eb00554e 	bl	57e23c44 <lmb_alloc_base>
57e0e708:	ea000003 	b	57e0e71c <boot_ramdisk_high+0xa8>
						rd_len, 0x1000, initrd_high);
			else
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
57e0e70c:	e1a0000a 	mov	r0, sl
57e0e710:	e1a01006 	mov	r1, r6
57e0e714:	e3a02a01 	mov	r2, #4096	; 0x1000
57e0e718:	eb005556 	bl	57e23c78 <lmb_alloc>
57e0e71c:	e5850000 	str	r0, [r5]
								 0x1000);

			if (*initrd_start == 0) {
57e0e720:	e5953000 	ldr	r3, [r5]
57e0e724:	e3530000 	cmp	r3, #0
57e0e728:	1a000003 	bne	57e0e73c <boot_ramdisk_high+0xc8>
				puts("ramdisk - allocation error\n");
57e0e72c:	e59f0060 	ldr	r0, [pc, #96]	; 57e0e794 <boot_ramdisk_high+0x120>
57e0e730:	ebffeb3b 	bl	57e09424 <puts>
			*initrd_start, *initrd_end);

	return 0;

error:
	return -1;
57e0e734:	e3e00000 	mvn	r0, #0
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
								 0x1000);

			if (*initrd_start == 0) {
				puts("ramdisk - allocation error\n");
				goto error;
57e0e738:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
57e0e73c:	e3a0000c 	mov	r0, #12
57e0e740:	eb000087 	bl	57e0e964 <__show_boot_progress>
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
57e0e744:	e5952000 	ldr	r2, [r5]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
57e0e748:	e59f0048 	ldr	r0, [pc, #72]	; 57e0e798 <boot_ramdisk_high+0x124>
				puts("ramdisk - allocation error\n");
				goto error;
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
57e0e74c:	e0862002 	add	r2, r6, r2
57e0e750:	e5892000 	str	r2, [r9]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
57e0e754:	e5951000 	ldr	r1, [r5]
57e0e758:	ebffeb3b 	bl	57e0944c <printf>
					*initrd_start, *initrd_end);

			memmove_wd((void *)*initrd_start,
57e0e75c:	e5950000 	ldr	r0, [r5]
57e0e760:	e1a01004 	mov	r1, r4
57e0e764:	e1a02006 	mov	r2, r6
57e0e768:	e3a03801 	mov	r3, #65536	; 0x10000
57e0e76c:	ebfffe50 	bl	57e0e0b4 <memmove_wd>
			 * AMP boot scenarios in which we might not be
			 * HW cache coherent
			 */
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
57e0e770:	e59f0024 	ldr	r0, [pc, #36]	; 57e0e79c <boot_ramdisk_high+0x128>
57e0e774:	ebffeb2a 	bl	57e09424 <puts>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
57e0e778:	e3a00000 	mov	r0, #0
57e0e77c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
57e0e780:	e5854000 	str	r4, [r5]
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
57e0e784:	e1a00004 	mov	r0, r4
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
		*initrd_end = 0;
57e0e788:	e5894000 	str	r4, [r9]

	return 0;

error:
	return -1;
}
57e0e78c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
57e0e790:	57e3267a 	.word	0x57e3267a
57e0e794:	57e32686 	.word	0x57e32686
57e0e798:	57e326a2 	.word	0x57e326a2
57e0e79c:	57e3455d 	.word	0x57e3455d

57e0e7a0 <delete_char>:
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
57e0e7a0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e0e7a4:	e1a07003 	mov	r7, r3
	char *s;

	if (*np == 0) {
57e0e7a8:	e5933000 	ldr	r3, [r3]
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
57e0e7ac:	e1a04000 	mov	r4, r0
	char *s;

	if (*np == 0) {
57e0e7b0:	e3530000 	cmp	r3, #0
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
57e0e7b4:	e1a05001 	mov	r5, r1
57e0e7b8:	e1a06002 	mov	r6, r2
57e0e7bc:	e59da018 	ldr	sl, [sp, #24]
	char *s;

	if (*np == 0) {
57e0e7c0:	0a000028 	beq	57e0e868 <delete_char+0xc8>
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
57e0e7c4:	e5753001 	ldrb	r3, [r5, #-1]!
57e0e7c8:	e3530009 	cmp	r3, #9
57e0e7cc:	1a00001d 	bne	57e0e848 <delete_char+0xa8>
57e0e7d0:	ea000004 	b	57e0e7e8 <delete_char+0x48>
		while (*colp > plen) {
			puts (erase_seq);
57e0e7d4:	e59f0094 	ldr	r0, [pc, #148]	; 57e0e870 <delete_char+0xd0>
57e0e7d8:	ebffeb11 	bl	57e09424 <puts>
			(*colp)--;
57e0e7dc:	e5963000 	ldr	r3, [r6]
57e0e7e0:	e2433001 	sub	r3, r3, #1
57e0e7e4:	e5863000 	str	r3, [r6]
	if (*np == 0) {
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
57e0e7e8:	e5963000 	ldr	r3, [r6]
57e0e7ec:	e153000a 	cmp	r3, sl
57e0e7f0:	cafffff7 	bgt	57e0e7d4 <delete_char+0x34>
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
				puts (tab_seq+((*colp) & 07));
57e0e7f4:	e59fa078 	ldr	sl, [pc, #120]	; 57e0e874 <delete_char+0xd4>
57e0e7f8:	ea00000f 	b	57e0e83c <delete_char+0x9c>
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
57e0e7fc:	e4d43001 	ldrb	r3, [r4], #1
57e0e800:	e5960000 	ldr	r0, [r6]
57e0e804:	e3530009 	cmp	r3, #9
57e0e808:	1a000007 	bne	57e0e82c <delete_char+0x8c>
				puts (tab_seq+((*colp) & 07));
57e0e80c:	e2000007 	and	r0, r0, #7
57e0e810:	e08a0000 	add	r0, sl, r0
57e0e814:	ebffeb02 	bl	57e09424 <puts>
				*colp += 8 - ((*colp) & 07);
57e0e818:	e5963000 	ldr	r3, [r6]
57e0e81c:	e3c33007 	bic	r3, r3, #7
57e0e820:	e2833008 	add	r3, r3, #8
57e0e824:	e5863000 	str	r3, [r6]
57e0e828:	ea000003 	b	57e0e83c <delete_char+0x9c>
			} else {
				++(*colp);
57e0e82c:	e2800001 	add	r0, r0, #1
57e0e830:	e5860000 	str	r0, [r6]
				putc (*s);
57e0e834:	e5540001 	ldrb	r0, [r4, #-1]
57e0e838:	ebffeaef 	bl	57e093fc <putc>
	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
57e0e83c:	e1550004 	cmp	r5, r4
57e0e840:	8affffed 	bhi	57e0e7fc <delete_char+0x5c>
57e0e844:	ea000004 	b	57e0e85c <delete_char+0xbc>
				++(*colp);
				putc (*s);
			}
		}
	} else {
		puts (erase_seq);
57e0e848:	e59f0020 	ldr	r0, [pc, #32]	; 57e0e870 <delete_char+0xd0>
57e0e84c:	ebffeaf4 	bl	57e09424 <puts>
		(*colp)--;
57e0e850:	e5963000 	ldr	r3, [r6]
57e0e854:	e2433001 	sub	r3, r3, #1
57e0e858:	e5863000 	str	r3, [r6]
	}
	(*np)--;
57e0e85c:	e5973000 	ldr	r3, [r7]
57e0e860:	e2433001 	sub	r3, r3, #1
57e0e864:	e5873000 	str	r3, [r7]
	return (p);
}
57e0e868:	e1a00005 	mov	r0, r5
57e0e86c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e0e870:	57e2c214 	.word	0x57e2c214
57e0e874:	57e2c218 	.word	0x57e2c218

57e0e878 <cread_add_char>:
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
57e0e878:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
57e0e87c:	e3510000 	cmp	r1, #0
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
57e0e880:	e1a04002 	mov	r4, r2
57e0e884:	e1a05000 	mov	r5, r0
57e0e888:	e59d6018 	ldr	r6, [sp, #24]
57e0e88c:	e59d201c 	ldr	r2, [sp, #28]
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
57e0e890:	1a000003 	bne	57e0e8a4 <cread_add_char+0x2c>
57e0e894:	e594c000 	ldr	ip, [r4]
57e0e898:	e5930000 	ldr	r0, [r3]
57e0e89c:	e15c0000 	cmp	ip, r0
57e0e8a0:	1a000023 	bne	57e0e934 <cread_add_char+0xbc>
		if (*eol_num > len - 1) {
57e0e8a4:	e5937000 	ldr	r7, [r3]
57e0e8a8:	e2422001 	sub	r2, r2, #1
57e0e8ac:	e1570002 	cmp	r7, r2
57e0e8b0:	9a000002 	bls	57e0e8c0 <cread_add_char+0x48>
			getcmd_cbeep();
57e0e8b4:	e3a00007 	mov	r0, #7
		wlen = 1;
		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
	}
}
57e0e8b8:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
57e0e8bc:	eaffeace 	b	57e093fc <putc>
			return;
		}
		(*eol_num)++;
57e0e8c0:	e2877001 	add	r7, r7, #1
	}

	if (insert) {
57e0e8c4:	e3510000 	cmp	r1, #0
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
			return;
		}
		(*eol_num)++;
57e0e8c8:	e5837000 	str	r7, [r3]
	}

	if (insert) {
57e0e8cc:	0a000018 	beq	57e0e934 <cread_add_char+0xbc>
		wlen = *eol_num - *num;
57e0e8d0:	e5941000 	ldr	r1, [r4]
57e0e8d4:	e0617007 	rsb	r7, r1, r7
		if (wlen > 1) {
57e0e8d8:	e3570001 	cmp	r7, #1
57e0e8dc:	9a000004 	bls	57e0e8f4 <cread_add_char+0x7c>
			memmove(&buf[*num+1], &buf[*num], wlen-1);
57e0e8e0:	e2810001 	add	r0, r1, #1
57e0e8e4:	e0860000 	add	r0, r6, r0
57e0e8e8:	e0861001 	add	r1, r6, r1
57e0e8ec:	e2472001 	sub	r2, r7, #1
57e0e8f0:	eb0056a2 	bl	57e24380 <memmove>
		}

		buf[*num] = ichar;
57e0e8f4:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
57e0e8f8:	e59f0060 	ldr	r0, [pc, #96]	; 57e0e960 <cread_add_char+0xe8>
		wlen = *eol_num - *num;
		if (wlen > 1) {
			memmove(&buf[*num+1], &buf[*num], wlen-1);
		}

		buf[*num] = ichar;
57e0e8fc:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
57e0e900:	e5942000 	ldr	r2, [r4]
57e0e904:	e1a01007 	mov	r1, r7
57e0e908:	e0862002 	add	r2, r6, r2
57e0e90c:	ebffeace 	bl	57e0944c <printf>
		(*num)++;
57e0e910:	e5943000 	ldr	r3, [r4]
57e0e914:	e2833001 	add	r3, r3, #1
57e0e918:	e5843000 	str	r3, [r4]
		while (--wlen) {
57e0e91c:	ea000001 	b	57e0e928 <cread_add_char+0xb0>
			getcmd_putch(CTL_BACKSPACE);
57e0e920:	e3a00008 	mov	r0, #8
57e0e924:	ebffeab4 	bl	57e093fc <putc>
		}

		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
		while (--wlen) {
57e0e928:	e2577001 	subs	r7, r7, #1
57e0e92c:	1afffffb 	bne	57e0e920 <cread_add_char+0xa8>
57e0e930:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
57e0e934:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
57e0e938:	e59f0020 	ldr	r0, [pc, #32]	; 57e0e960 <cread_add_char+0xe8>
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
57e0e93c:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
57e0e940:	e5942000 	ldr	r2, [r4]
57e0e944:	e3a01001 	mov	r1, #1
57e0e948:	e0862002 	add	r2, r6, r2
57e0e94c:	ebffeabe 	bl	57e0944c <printf>
		(*num)++;
57e0e950:	e5943000 	ldr	r3, [r4]
57e0e954:	e2833001 	add	r3, r3, #1
57e0e958:	e5843000 	str	r3, [r4]
57e0e95c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
57e0e960:	57e32a2d 	.word	0x57e32a2d

57e0e964 <__show_boot_progress>:
DECLARE_GLOBAL_DATA_PTR;

/*
 * Board-specific Platform code can reimplement show_boot_progress () if needed
 */
void inline __show_boot_progress (int val) {}
57e0e964:	e12fff1e 	bx	lr

57e0e968 <readline_into_buffer>:
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
57e0e968:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
57e0e96c:	e5983004 	ldr	r3, [r8, #4]
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
57e0e970:	e24dd040 	sub	sp, sp, #64	; 0x40
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
57e0e974:	e2133001 	ands	r3, r3, #1
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
57e0e978:	e1a06000 	mov	r6, r0
57e0e97c:	e1a04001 	mov	r4, r1
57e0e980:	e58d201c 	str	r2, [sp, #28]
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
57e0e984:	0a0001bd 	beq	57e0f080 <readline_into_buffer+0x718>
		if (!initted) {
57e0e988:	e59f28dc 	ldr	r2, [pc, #2268]	; 57e0f26c <readline_into_buffer+0x904>
57e0e98c:	e5923000 	ldr	r3, [r2]
57e0e990:	e3530000 	cmp	r3, #0
57e0e994:	1a000010 	bne	57e0e9dc <readline_into_buffer+0x74>
{
	int i;

	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
57e0e998:	e59f18d0 	ldr	r1, [pc, #2256]	; 57e0f270 <readline_into_buffer+0x908>
57e0e99c:	e3e00000 	mvn	r0, #0
57e0e9a0:	e5810000 	str	r0, [r1]
	hist_num = 0;
57e0e9a4:	e59f18c8 	ldr	r1, [pc, #2248]	; 57e0f274 <readline_into_buffer+0x90c>

	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
57e0e9a8:	e59f08c8 	ldr	r0, [pc, #2248]	; 57e0f278 <readline_into_buffer+0x910>

static void hist_init(void)
{
	int i;

	hist_max = 0;
57e0e9ac:	e5823004 	str	r3, [r2, #4]
	hist_add_idx = 0;
57e0e9b0:	e5823008 	str	r3, [r2, #8]
	hist_cur = -1;
	hist_num = 0;
57e0e9b4:	e582300c 	str	r3, [r2, #12]

	for (i = 0; i < HIST_MAX; i++) {
		hist_list[i] = hist_lines[i];
57e0e9b8:	e2822010 	add	r2, r2, #16
57e0e9bc:	e5a12004 	str	r2, [r1, #4]!
		hist_list[i][0] = '\0';
57e0e9c0:	e4c23100 	strb	r3, [r2], #256	; 0x100
57e0e9c4:	e2822001 	add	r2, r2, #1
	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
	hist_num = 0;

	for (i = 0; i < HIST_MAX; i++) {
57e0e9c8:	e1520000 	cmp	r2, r0
57e0e9cc:	1afffffa 	bne	57e0e9bc <readline_into_buffer+0x54>
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
		if (!initted) {
			hist_init();
			initted = 1;
57e0e9d0:	e59f3894 	ldr	r3, [pc, #2196]	; 57e0f26c <readline_into_buffer+0x904>
57e0e9d4:	e3a02001 	mov	r2, #1
57e0e9d8:	e5832000 	str	r2, [r3]
		}

		if (prompt)
57e0e9dc:	e3560000 	cmp	r6, #0
57e0e9e0:	0a000001 	beq	57e0e9ec <readline_into_buffer+0x84>
			puts (prompt);
57e0e9e4:	e1a00006 	mov	r0, r6
57e0e9e8:	ebffea8d 	bl	57e09424 <puts>
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
57e0e9ec:	e3a03000 	mov	r3, #0
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
57e0e9f0:	e1a00004 	mov	r0, r4
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
57e0e9f4:	e58d3034 	str	r3, [sp, #52]	; 0x34
	unsigned long eol_num = 0;
57e0e9f8:	e58d3030 	str	r3, [sp, #48]	; 0x30
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
57e0e9fc:	eb005593 	bl	57e24050 <strlen>
	int first = 1;

	if (init_len)
57e0ea00:	e2505000 	subs	r5, r0, #0
57e0ea04:	1a000012 	bne	57e0ea54 <readline_into_buffer+0xec>
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
57e0ea08:	e59d101c 	ldr	r1, [sp, #28]
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
57e0ea0c:	e3a0b001 	mov	fp, #1
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
57e0ea10:	e1a00001 	mov	r0, r1
57e0ea14:	e1a01fc0 	asr	r1, r0, #31
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
57e0ea18:	e3a0a000 	mov	sl, #0
57e0ea1c:	e1a0700b 	mov	r7, fp
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
57e0ea20:	e58d0020 	str	r0, [sp, #32]
57e0ea24:	e58d1024 	str	r1, [sp, #36]	; 0x24

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
57e0ea28:	e59f5840 	ldr	r5, [pc, #2112]	; 57e0f270 <readline_into_buffer+0x908>
		return NULL;

	if (hist_cur == hist_add_idx)
57e0ea2c:	e59f6838 	ldr	r6, [pc, #2104]	; 57e0f26c <readline_into_buffer+0x904>
57e0ea30:	ea00000f 	b	57e0ea74 <readline_into_buffer+0x10c>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
57e0ea34:	e4d60001 	ldrb	r0, [r6], #1
57e0ea38:	e3a01001 	mov	r1, #1
57e0ea3c:	e1a02007 	mov	r2, r7
57e0ea40:	e1a0300a 	mov	r3, sl
57e0ea44:	e88d0210 	stm	sp, {r4, r9}
		str++;
57e0ea48:	e2455001 	sub	r5, r5, #1

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
57e0ea4c:	ebffff89 	bl	57e0e878 <cread_add_char>
57e0ea50:	ea000003 	b	57e0ea64 <readline_into_buffer+0xfc>
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
	int first = 1;

	if (init_len)
57e0ea54:	e1a06004 	mov	r6, r4
		cread_add_str(buf, init_len, 1, &num, &eol_num, buf, *len);
57e0ea58:	e28d7034 	add	r7, sp, #52	; 0x34
57e0ea5c:	e28da030 	add	sl, sp, #48	; 0x30

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
57e0ea60:	e3a09c01 	mov	r9, #256	; 0x100
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
57e0ea64:	e3550000 	cmp	r5, #0
57e0ea68:	1afffff1 	bne	57e0ea34 <readline_into_buffer+0xcc>
57e0ea6c:	eaffffe5 	b	57e0ea08 <readline_into_buffer+0xa0>
		case CTL_CH('p'):
		case CTL_CH('n'):
		{
			char * hline;

			esc_len = 0;
57e0ea70:	e3a0a000 	mov	sl, #0
			if (retry_time >= 0 && get_ticks() > endtime)
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
57e0ea74:	e59d201c 	ldr	r2, [sp, #28]
57e0ea78:	e3520000 	cmp	r2, #0
57e0ea7c:	03a03000 	moveq	r3, #0
57e0ea80:	120b3001 	andne	r3, fp, #1
57e0ea84:	e3530000 	cmp	r3, #0
57e0ea88:	0a00001c 	beq	57e0eb00 <readline_into_buffer+0x198>
			uint64_t etime = endtick(timeout);
57e0ea8c:	ebffc7ec 	bl	57e00a44 <get_ticks>
57e0ea90:	e58d0010 	str	r0, [sp, #16]
57e0ea94:	e58d1014 	str	r1, [sp, #20]
57e0ea98:	ebffc7fe 	bl	57e00a98 <get_tbclk>
57e0ea9c:	e59d101c 	ldr	r1, [sp, #28]
57e0eaa0:	e1a0b00a 	mov	fp, sl
57e0eaa4:	e0832190 	umull	r2, r3, r0, r1
57e0eaa8:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
57e0eaac:	e0233190 	mla	r3, r0, r1, r3
57e0eab0:	e28d1010 	add	r1, sp, #16
57e0eab4:	e8910003 	ldm	r1, {r0, r1}
57e0eab8:	e0900002 	adds	r0, r0, r2
57e0eabc:	e0a11003 	adc	r1, r1, r3
57e0eac0:	e58d0010 	str	r0, [sp, #16]
57e0eac4:	e58d1014 	str	r1, [sp, #20]
57e0eac8:	e1a09000 	mov	r9, r0
57e0eacc:	e1a0a001 	mov	sl, r1
57e0ead0:	ea000005 	b	57e0eaec <readline_into_buffer+0x184>

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
57e0ead4:	ebffc7da 	bl	57e00a44 <get_ticks>
57e0ead8:	e15a0001 	cmp	sl, r1
57e0eadc:	8a000002 	bhi	57e0eaec <readline_into_buffer+0x184>
57e0eae0:	1a000164 	bne	57e0f078 <readline_into_buffer+0x710>
57e0eae4:	e1590000 	cmp	r9, r0
57e0eae8:	9a000162 	bls	57e0f078 <readline_into_buffer+0x710>
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
57e0eaec:	ebffea39 	bl	57e093d8 <tstc>
57e0eaf0:	e3500000 	cmp	r0, #0
57e0eaf4:	0afffff6 	beq	57e0ead4 <readline_into_buffer+0x16c>
57e0eaf8:	e1a0a00b 	mov	sl, fp
				if (get_ticks() >= etime)
					return -2;	/* timed out */
				WATCHDOG_RESET();
			}
			first = 0;
57e0eafc:	e3a0b000 	mov	fp, #0
		}

		ichar = getcmd_getch();
57e0eb00:	ebffea2b 	bl	57e093b4 <getc>
57e0eb04:	e20000ff 	and	r0, r0, #255	; 0xff

		if ((ichar == '\n') || (ichar == '\r')) {
57e0eb08:	e350000a 	cmp	r0, #10
57e0eb0c:	1350000d 	cmpne	r0, #13
57e0eb10:	13a09000 	movne	r9, #0
57e0eb14:	03a09001 	moveq	r9, #1
57e0eb18:	1a000009 	bne	57e0eb44 <readline_into_buffer+0x1dc>
			putc('\n');
57e0eb1c:	e3a0000a 	mov	r0, #10
57e0eb20:	ebffea35 	bl	57e093fc <putc>
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
			break;
		}
	}
	*len = eol_num;
57e0eb24:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
	buf[eol_num] = '\0';	/* lose the newline */
57e0eb28:	e3a03000 	mov	r3, #0
57e0eb2c:	e7c43006 	strb	r3, [r4, r6]

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
57e0eb30:	e5d43000 	ldrb	r3, [r4]
57e0eb34:	e3530021 	cmp	r3, #33	; 0x21
57e0eb38:	13530000 	cmpne	r3, #0
57e0eb3c:	0a000147 	beq	57e0f060 <readline_into_buffer+0x6f8>
57e0eb40:	ea000134 	b	57e0f018 <readline_into_buffer+0x6b0>
		}

		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
57e0eb44:	e35a0000 	cmp	sl, #0
57e0eb48:	0a000032 	beq	57e0ec18 <readline_into_buffer+0x2b0>
			if (esc_len == 1) {
57e0eb4c:	e35a0001 	cmp	sl, #1
57e0eb50:	1a00000d 	bne	57e0eb8c <readline_into_buffer+0x224>
				if (ichar == '[') {
57e0eb54:	e350005b 	cmp	r0, #91	; 0x5b
					esc_save[esc_len] = ichar;
57e0eb58:	05cd0029 	strbeq	r0, [sp, #41]	; 0x29
					esc_len = 2;
57e0eb5c:	03a0a002 	moveq	sl, #2
		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
			if (esc_len == 1) {
				if (ichar == '[') {
57e0eb60:	0affffc3 	beq	57e0ea74 <readline_into_buffer+0x10c>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
57e0eb64:	e3a03c01 	mov	r3, #256	; 0x100
57e0eb68:	e58d3004 	str	r3, [sp, #4]
57e0eb6c:	e5dd0028 	ldrb	r0, [sp, #40]	; 0x28
57e0eb70:	e1a01007 	mov	r1, r7
57e0eb74:	e28d2034 	add	r2, sp, #52	; 0x34
57e0eb78:	e28d3030 	add	r3, sp, #48	; 0x30
57e0eb7c:	e58d4000 	str	r4, [sp]
					esc_save[esc_len] = ichar;
					esc_len = 2;
				} else {
					cread_add_str(esc_save, esc_len, insert,
						      &num, &eol_num, buf, *len);
					esc_len = 0;
57e0eb80:	e1a0a009 	mov	sl, r9

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
57e0eb84:	ebffff3b 	bl	57e0e878 <cread_add_char>
57e0eb88:	eaffffb9 	b	57e0ea74 <readline_into_buffer+0x10c>
					esc_len = 0;
				}
				continue;
			}

			switch (ichar) {
57e0eb8c:	e2403041 	sub	r3, r0, #65	; 0x41
57e0eb90:	e3530007 	cmp	r3, #7
57e0eb94:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e0eb98:	ea000007 	b	57e0ebbc <readline_into_buffer+0x254>
57e0eb9c:	57e0eeb0 	.word	0x57e0eeb0
57e0eba0:	57e0eef4 	.word	0x57e0eef4
57e0eba4:	57e0ec0c 	.word	0x57e0ec0c
57e0eba8:	57e0ed0c 	.word	0x57e0ed0c
57e0ebac:	57e0ebbc 	.word	0x57e0ebbc
57e0ebb0:	57e0ebbc 	.word	0x57e0ebbc
57e0ebb4:	57e0ebbc 	.word	0x57e0ebbc
57e0ebb8:	57e0ecd8 	.word	0x57e0ecd8
			case 'B':	/* down arrow */
				ichar = CTL_CH('n');
				esc_len = 0;
				break;	/* pass off to ^N handler */
			default:
				esc_save[esc_len++] = ichar;
57e0ebbc:	e28d1040 	add	r1, sp, #64	; 0x40
57e0ebc0:	e081300a 	add	r3, r1, sl
57e0ebc4:	e5430018 	strb	r0, [r3, #-24]
57e0ebc8:	e28aa001 	add	sl, sl, #1
				cread_add_str(esc_save, esc_len, insert,
57e0ebcc:	e28d9028 	add	r9, sp, #40	; 0x28

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
57e0ebd0:	e3a0cc01 	mov	ip, #256	; 0x100
57e0ebd4:	ea000009 	b	57e0ec00 <readline_into_buffer+0x298>
57e0ebd8:	e4d90001 	ldrb	r0, [r9], #1
57e0ebdc:	e1a01007 	mov	r1, r7
57e0ebe0:	e28d2034 	add	r2, sp, #52	; 0x34
57e0ebe4:	e28d3030 	add	r3, sp, #48	; 0x30
57e0ebe8:	e58dc004 	str	ip, [sp, #4]
57e0ebec:	e58dc00c 	str	ip, [sp, #12]
57e0ebf0:	e58d4000 	str	r4, [sp]
57e0ebf4:	ebffff1f 	bl	57e0e878 <cread_add_char>
		str++;
57e0ebf8:	e59dc00c 	ldr	ip, [sp, #12]
57e0ebfc:	e24aa001 	sub	sl, sl, #1
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
57e0ec00:	e35a0000 	cmp	sl, #0
57e0ec04:	1afffff3 	bne	57e0ebd8 <readline_into_buffer+0x270>
57e0ec08:	eaffff99 	b	57e0ea74 <readline_into_buffer+0x10c>
			case 'D':	/* <- key */
				ichar = CTL_CH('b');
				esc_len = 0;
				break;
			case 'C':	/* -> key */
				ichar = CTL_CH('f');
57e0ec0c:	e3a00006 	mov	r0, #6
57e0ec10:	e350000b 	cmp	r0, #11
57e0ec14:	ea000001 	b	57e0ec20 <readline_into_buffer+0x2b8>
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
57e0ec18:	e350000b 	cmp	r0, #11
57e0ec1c:	0a00005e 	beq	57e0ed9c <readline_into_buffer+0x434>
57e0ec20:	8a00000f 	bhi	57e0ec64 <readline_into_buffer+0x2fc>
57e0ec24:	e3500004 	cmp	r0, #4
57e0ec28:	0a00003f 	beq	57e0ed2c <readline_into_buffer+0x3c4>
57e0ec2c:	8a000005 	bhi	57e0ec48 <readline_into_buffer+0x2e0>
57e0ec30:	e3500002 	cmp	r0, #2
57e0ec34:	0a000034 	beq	57e0ed0c <readline_into_buffer+0x3a4>
57e0ec38:	8a000140 	bhi	57e0f140 <readline_into_buffer+0x7d8>
57e0ec3c:	e3500001 	cmp	r0, #1
57e0ec40:	1a0000ec 	bne	57e0eff8 <readline_into_buffer+0x690>
57e0ec44:	ea000023 	b	57e0ecd8 <readline_into_buffer+0x370>
57e0ec48:	e3500006 	cmp	r0, #6
57e0ec4c:	0a000025 	beq	57e0ece8 <readline_into_buffer+0x380>
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
57e0ec50:	359d2034 	ldrcc	r2, [sp, #52]	; 0x34
57e0ec54:	359d1030 	ldrcc	r1, [sp, #48]	; 0x30
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
57e0ec58:	3a0000dd 	bcc	57e0efd4 <readline_into_buffer+0x66c>
57e0ec5c:	e3500008 	cmp	r0, #8
57e0ec60:	ea000015 	b	57e0ecbc <readline_into_buffer+0x354>
57e0ec64:	e3500015 	cmp	r0, #21
57e0ec68:	0a000061 	beq	57e0edf4 <readline_into_buffer+0x48c>
57e0ec6c:	8a000007 	bhi	57e0ec90 <readline_into_buffer+0x328>
57e0ec70:	e350000f 	cmp	r0, #15
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
			break;
		case CTL_CH('o'):
			insert = !insert;
57e0ec74:	02277001 	eoreq	r7, r7, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
57e0ec78:	0affff7c 	beq	57e0ea70 <readline_into_buffer+0x108>
57e0ec7c:	e3500010 	cmp	r0, #16
57e0ec80:	0a00008a 	beq	57e0eeb0 <readline_into_buffer+0x548>
57e0ec84:	e350000e 	cmp	r0, #14
57e0ec88:	1a0000da 	bne	57e0eff8 <readline_into_buffer+0x690>
57e0ec8c:	ea000098 	b	57e0eef4 <readline_into_buffer+0x58c>
57e0ec90:	e350001b 	cmp	r0, #27
		case 0x1b:
			if (esc_len == 0) {
				esc_save[esc_len] = ichar;
57e0ec94:	05cd0028 	strbeq	r0, [sp, #40]	; 0x28
				esc_len = 1;
57e0ec98:	03a0a001 	moveq	sl, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
57e0ec9c:	0affff74 	beq	57e0ea74 <readline_into_buffer+0x10c>
57e0eca0:	8a000002 	bhi	57e0ecb0 <readline_into_buffer+0x348>
57e0eca4:	e3500018 	cmp	r0, #24
57e0eca8:	1a0000d2 	bne	57e0eff8 <readline_into_buffer+0x690>
57e0ecac:	ea000050 	b	57e0edf4 <readline_into_buffer+0x48c>
57e0ecb0:	e350007f 	cmp	r0, #127	; 0x7f
57e0ecb4:	0a000061 	beq	57e0ee40 <readline_into_buffer+0x4d8>
57e0ecb8:	e35000ff 	cmp	r0, #255	; 0xff
57e0ecbc:	1a0000cd 	bne	57e0eff8 <readline_into_buffer+0x690>
57e0ecc0:	ea00005e 	b	57e0ee40 <readline_into_buffer+0x4d8>
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
57e0ecc4:	e3a00008 	mov	r0, #8
57e0ecc8:	ebffe9cb 	bl	57e093fc <putc>
57e0eccc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0ecd0:	e2433001 	sub	r3, r3, #1
57e0ecd4:	e58d3034 	str	r3, [sp, #52]	; 0x34
57e0ecd8:	e59da034 	ldr	sl, [sp, #52]	; 0x34
57e0ecdc:	e35a0000 	cmp	sl, #0
57e0ece0:	1afffff7 	bne	57e0ecc4 <readline_into_buffer+0x35c>
57e0ece4:	eaffff62 	b	57e0ea74 <readline_into_buffer+0x10c>
			break;
		case CTL_CH('c'):	/* ^C - break */
			*buf = '\0';	/* discard input */
			return (-1);
		case CTL_CH('f'):
			if (num < eol_num) {
57e0ece8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0ecec:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
57e0ecf0:	e1530002 	cmp	r3, r2
57e0ecf4:	2affff5d 	bcs	57e0ea70 <readline_into_buffer+0x108>
				getcmd_putch(buf[num]);
57e0ecf8:	e7d40003 	ldrb	r0, [r4, r3]
57e0ecfc:	ebffe9be 	bl	57e093fc <putc>
				num++;
57e0ed00:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0ed04:	e2833001 	add	r3, r3, #1
57e0ed08:	ea0000b8 	b	57e0eff0 <readline_into_buffer+0x688>
			}
			break;
		case CTL_CH('b'):
			if (num) {
57e0ed0c:	e59da034 	ldr	sl, [sp, #52]	; 0x34
57e0ed10:	e35a0000 	cmp	sl, #0
57e0ed14:	0affff56 	beq	57e0ea74 <readline_into_buffer+0x10c>
				getcmd_putch(CTL_BACKSPACE);
57e0ed18:	e3a00008 	mov	r0, #8
57e0ed1c:	ebffe9b6 	bl	57e093fc <putc>
				num--;
57e0ed20:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0ed24:	e2433001 	sub	r3, r3, #1
57e0ed28:	ea0000b0 	b	57e0eff0 <readline_into_buffer+0x688>
			}
			break;
		case CTL_CH('d'):
			if (num < eol_num) {
57e0ed2c:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
57e0ed30:	e59da030 	ldr	sl, [sp, #48]	; 0x30
57e0ed34:	e150000a 	cmp	r0, sl
57e0ed38:	2affff4c 	bcs	57e0ea70 <readline_into_buffer+0x108>
				wlen = eol_num - num - 1;
57e0ed3c:	e24aa001 	sub	sl, sl, #1
				if (wlen) {
57e0ed40:	e05aa000 	subs	sl, sl, r0
57e0ed44:	0a000009 	beq	57e0ed70 <readline_into_buffer+0x408>
					memmove(&buf[num], &buf[num+1], wlen);
57e0ed48:	e2801001 	add	r1, r0, #1
57e0ed4c:	e0841001 	add	r1, r4, r1
57e0ed50:	e1a0200a 	mov	r2, sl
57e0ed54:	e0840000 	add	r0, r4, r0
57e0ed58:	eb005588 	bl	57e24380 <memmove>
					putnstr(buf + num, wlen);
57e0ed5c:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
57e0ed60:	e59f0514 	ldr	r0, [pc, #1300]	; 57e0f27c <readline_into_buffer+0x914>
57e0ed64:	e1a0100a 	mov	r1, sl
57e0ed68:	e0842002 	add	r2, r4, r2
57e0ed6c:	ebffe9b6 	bl	57e0944c <printf>
				}

				getcmd_putch(' ');
57e0ed70:	e3a00020 	mov	r0, #32
57e0ed74:	ebffe9a0 	bl	57e093fc <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
57e0ed78:	e3a00008 	mov	r0, #8
57e0ed7c:	ebffe99e 	bl	57e093fc <putc>
				} while (wlen--);
57e0ed80:	e25aa001 	subs	sl, sl, #1
57e0ed84:	2afffffb 	bcs	57e0ed78 <readline_into_buffer+0x410>
				eol_num--;
57e0ed88:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
57e0ed8c:	e28aa001 	add	sl, sl, #1
57e0ed90:	e2433001 	sub	r3, r3, #1
57e0ed94:	e58d3030 	str	r3, [sp, #48]	; 0x30
57e0ed98:	eaffff35 	b	57e0ea74 <readline_into_buffer+0x10c>
			}
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
57e0ed9c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0eda0:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
57e0eda4:	e1530001 	cmp	r3, r1
57e0eda8:	2affff31 	bcs	57e0ea74 <readline_into_buffer+0x10c>
57e0edac:	e59f04cc 	ldr	r0, [pc, #1228]	; 57e0f280 <readline_into_buffer+0x918>
57e0edb0:	e0631001 	rsb	r1, r3, r1
57e0edb4:	e59f24c8 	ldr	r2, [pc, #1224]	; 57e0f284 <readline_into_buffer+0x91c>
57e0edb8:	ebffe9a3 	bl	57e0944c <printf>
57e0edbc:	e3a00008 	mov	r0, #8
57e0edc0:	ebffe98d 	bl	57e093fc <putc>
57e0edc4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
57e0edc8:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
57e0edcc:	e2433001 	sub	r3, r3, #1
57e0edd0:	e1530002 	cmp	r3, r2
57e0edd4:	e58d3030 	str	r3, [sp, #48]	; 0x30
57e0edd8:	8afffff7 	bhi	57e0edbc <readline_into_buffer+0x454>
57e0eddc:	eaffff23 	b	57e0ea70 <readline_into_buffer+0x108>
		case CTL_CH('o'):
			insert = !insert;
			break;
		case CTL_CH('x'):
		case CTL_CH('u'):
			BEGINNING_OF_LINE();
57e0ede0:	e3a00008 	mov	r0, #8
57e0ede4:	ebffe984 	bl	57e093fc <putc>
57e0ede8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0edec:	e2433001 	sub	r3, r3, #1
57e0edf0:	e58d3034 	str	r3, [sp, #52]	; 0x34
57e0edf4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0edf8:	e3530000 	cmp	r3, #0
57e0edfc:	1afffff7 	bne	57e0ede0 <readline_into_buffer+0x478>
			ERASE_TO_EOL();
57e0ee00:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
57e0ee04:	e3510000 	cmp	r1, #0
57e0ee08:	01a0a001 	moveq	sl, r1
57e0ee0c:	0affff18 	beq	57e0ea74 <readline_into_buffer+0x10c>
57e0ee10:	e59f0468 	ldr	r0, [pc, #1128]	; 57e0f280 <readline_into_buffer+0x918>
57e0ee14:	e59f2468 	ldr	r2, [pc, #1128]	; 57e0f284 <readline_into_buffer+0x91c>
57e0ee18:	ebffe98b 	bl	57e0944c <printf>
57e0ee1c:	e3a00008 	mov	r0, #8
57e0ee20:	ebffe975 	bl	57e093fc <putc>
57e0ee24:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
57e0ee28:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
57e0ee2c:	e2433001 	sub	r3, r3, #1
57e0ee30:	e1530002 	cmp	r3, r2
57e0ee34:	e58d3030 	str	r3, [sp, #48]	; 0x30
57e0ee38:	8afffff7 	bhi	57e0ee1c <readline_into_buffer+0x4b4>
57e0ee3c:	eaffff0b 	b	57e0ea70 <readline_into_buffer+0x108>
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
57e0ee40:	e59da034 	ldr	sl, [sp, #52]	; 0x34
57e0ee44:	e35a0000 	cmp	sl, #0
57e0ee48:	0affff09 	beq	57e0ea74 <readline_into_buffer+0x10c>
				wlen = eol_num - num;
57e0ee4c:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
				num--;
57e0ee50:	e24a0001 	sub	r0, sl, #1
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
57e0ee54:	e06a9009 	rsb	r9, sl, r9
				num--;
				memmove(&buf[num], &buf[num+1], wlen);
57e0ee58:	e084100a 	add	r1, r4, sl
57e0ee5c:	e1a02009 	mov	r2, r9
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
				num--;
57e0ee60:	e58d0034 	str	r0, [sp, #52]	; 0x34
				memmove(&buf[num], &buf[num+1], wlen);
57e0ee64:	e0840000 	add	r0, r4, r0
57e0ee68:	eb005544 	bl	57e24380 <memmove>
				getcmd_putch(CTL_BACKSPACE);
57e0ee6c:	e3a00008 	mov	r0, #8
57e0ee70:	ebffe961 	bl	57e093fc <putc>
				putnstr(buf + num, wlen);
57e0ee74:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
57e0ee78:	e59f03fc 	ldr	r0, [pc, #1020]	; 57e0f27c <readline_into_buffer+0x914>
57e0ee7c:	e1a01009 	mov	r1, r9
57e0ee80:	e0842002 	add	r2, r4, r2
57e0ee84:	ebffe970 	bl	57e0944c <printf>
				getcmd_putch(' ');
57e0ee88:	e3a00020 	mov	r0, #32
57e0ee8c:	ebffe95a 	bl	57e093fc <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
57e0ee90:	e3a00008 	mov	r0, #8
57e0ee94:	ebffe958 	bl	57e093fc <putc>
				} while (wlen--);
57e0ee98:	e2599001 	subs	r9, r9, #1
57e0ee9c:	2afffffb 	bcs	57e0ee90 <readline_into_buffer+0x528>
				eol_num--;
57e0eea0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
57e0eea4:	e2433001 	sub	r3, r3, #1
57e0eea8:	e58d3030 	str	r3, [sp, #48]	; 0x30
57e0eeac:	eafffeef 	b	57e0ea70 <readline_into_buffer+0x108>
static char* hist_prev(void)
{
	char *ret;
	int old_cur;

	if (hist_cur < 0)
57e0eeb0:	e5953000 	ldr	r3, [r5]
57e0eeb4:	e3530000 	cmp	r3, #0
57e0eeb8:	ba000024 	blt	57e0ef50 <readline_into_buffer+0x5e8>
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
57e0eebc:	e2432001 	sub	r2, r3, #1
57e0eec0:	e3720001 	cmn	r2, #1
57e0eec4:	e5852000 	str	r2, [r5]
		hist_cur = hist_max;
57e0eec8:	05962004 	ldreq	r2, [r6, #4]

	if (hist_cur == hist_add_idx) {
57e0eecc:	e5961008 	ldr	r1, [r6, #8]
	if (hist_cur < 0)
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;
57e0eed0:	05852000 	streq	r2, [r5]

	if (hist_cur == hist_add_idx) {
57e0eed4:	e5952000 	ldr	r2, [r5]
57e0eed8:	e1520001 	cmp	r2, r1
		hist_cur = old_cur;
57e0eedc:	05853000 	streq	r3, [r5]

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;

	if (hist_cur == hist_add_idx) {
57e0eee0:	0a00001a 	beq	57e0ef50 <readline_into_buffer+0x5e8>
		hist_cur = old_cur;
		ret = NULL;
	} else
		ret = hist_list[hist_cur];
57e0eee4:	e59f339c 	ldr	r3, [pc, #924]	; 57e0f288 <readline_into_buffer+0x920>
57e0eee8:	e0832102 	add	r2, r3, r2, lsl #2
57e0eeec:	e512abd4 	ldr	sl, [r2, #-3028]	; 0xbd4
57e0eef0:	ea000011 	b	57e0ef3c <readline_into_buffer+0x5d4>

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
57e0eef4:	e5953000 	ldr	r3, [r5]
57e0eef8:	e3530000 	cmp	r3, #0
57e0eefc:	ba000013 	blt	57e0ef50 <readline_into_buffer+0x5e8>
		return NULL;

	if (hist_cur == hist_add_idx)
57e0ef00:	e5962008 	ldr	r2, [r6, #8]
57e0ef04:	e1530002 	cmp	r3, r2
57e0ef08:	0a000010 	beq	57e0ef50 <readline_into_buffer+0x5e8>
		return NULL;

	if (++hist_cur > hist_max)
57e0ef0c:	e5961004 	ldr	r1, [r6, #4]
57e0ef10:	e2833001 	add	r3, r3, #1
57e0ef14:	e1530001 	cmp	r3, r1
		hist_cur = 0;
57e0ef18:	c3a00000 	movgt	r0, #0
		return NULL;

	if (hist_cur == hist_add_idx)
		return NULL;

	if (++hist_cur > hist_max)
57e0ef1c:	e5853000 	str	r3, [r5]
		hist_cur = 0;
57e0ef20:	c5850000 	strgt	r0, [r5]

	if (hist_cur == hist_add_idx) {
57e0ef24:	e5953000 	ldr	r3, [r5]
57e0ef28:	e1530002 	cmp	r3, r2
57e0ef2c:	0a000005 	beq	57e0ef48 <readline_into_buffer+0x5e0>
		ret = "";
	} else
		ret = hist_list[hist_cur];
57e0ef30:	e59f1350 	ldr	r1, [pc, #848]	; 57e0f288 <readline_into_buffer+0x920>
57e0ef34:	e0813103 	add	r3, r1, r3, lsl #2
57e0ef38:	e513abd4 	ldr	sl, [r3, #-3028]	; 0xbd4
			if (ichar == CTL_CH('p'))
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
57e0ef3c:	e35a0000 	cmp	sl, #0
57e0ef40:	1a00000a 	bne	57e0ef70 <readline_into_buffer+0x608>
57e0ef44:	ea000001 	b	57e0ef50 <readline_into_buffer+0x5e8>

	if (++hist_cur > hist_max)
		hist_cur = 0;

	if (hist_cur == hist_add_idx) {
		ret = "";
57e0ef48:	e59fa334 	ldr	sl, [pc, #820]	; 57e0f284 <readline_into_buffer+0x91c>
57e0ef4c:	ea000007 	b	57e0ef70 <readline_into_buffer+0x608>
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
				getcmd_cbeep();
57e0ef50:	e3a00007 	mov	r0, #7
57e0ef54:	ebffe928 	bl	57e093fc <putc>
57e0ef58:	eafffec4 	b	57e0ea70 <readline_into_buffer+0x108>
				continue;
			}

			/* nuke the current line */
			/* first, go home */
			BEGINNING_OF_LINE();
57e0ef5c:	e3a00008 	mov	r0, #8
57e0ef60:	ebffe925 	bl	57e093fc <putc>
57e0ef64:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0ef68:	e2433001 	sub	r3, r3, #1
57e0ef6c:	e58d3034 	str	r3, [sp, #52]	; 0x34
57e0ef70:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e0ef74:	e3530000 	cmp	r3, #0
57e0ef78:	1afffff7 	bne	57e0ef5c <readline_into_buffer+0x5f4>

			/* erase to end of line */
			ERASE_TO_EOL();
57e0ef7c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
57e0ef80:	e3510000 	cmp	r1, #0
57e0ef84:	0a00000a 	beq	57e0efb4 <readline_into_buffer+0x64c>
57e0ef88:	e59f02f0 	ldr	r0, [pc, #752]	; 57e0f280 <readline_into_buffer+0x918>
57e0ef8c:	e59f22f0 	ldr	r2, [pc, #752]	; 57e0f284 <readline_into_buffer+0x91c>
57e0ef90:	ebffe92d 	bl	57e0944c <printf>
57e0ef94:	e3a00008 	mov	r0, #8
57e0ef98:	ebffe917 	bl	57e093fc <putc>
57e0ef9c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
57e0efa0:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
57e0efa4:	e2433001 	sub	r3, r3, #1
57e0efa8:	e1530002 	cmp	r3, r2
57e0efac:	e58d3030 	str	r3, [sp, #48]	; 0x30
57e0efb0:	8afffff7 	bhi	57e0ef94 <readline_into_buffer+0x62c>

			/* copy new line into place and display */
			strcpy(buf, hline);
57e0efb4:	e1a0100a 	mov	r1, sl
57e0efb8:	e1a00004 	mov	r0, r4
57e0efbc:	eb0053c7 	bl	57e23ee0 <strcpy>
			eol_num = strlen(buf);
57e0efc0:	e1a00004 	mov	r0, r4
57e0efc4:	eb005421 	bl	57e24050 <strlen>
			REFRESH_TO_EOL();
57e0efc8:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
			/* erase to end of line */
			ERASE_TO_EOL();

			/* copy new line into place and display */
			strcpy(buf, hline);
			eol_num = strlen(buf);
57e0efcc:	e1a01000 	mov	r1, r0
57e0efd0:	e58d0030 	str	r0, [sp, #48]	; 0x30
			REFRESH_TO_EOL();
57e0efd4:	e1520001 	cmp	r2, r1
57e0efd8:	2afffea4 	bcs	57e0ea70 <readline_into_buffer+0x108>
57e0efdc:	e0621001 	rsb	r1, r2, r1
57e0efe0:	e59f0294 	ldr	r0, [pc, #660]	; 57e0f27c <readline_into_buffer+0x914>
57e0efe4:	e0842002 	add	r2, r4, r2
57e0efe8:	ebffe917 	bl	57e0944c <printf>
57e0efec:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
57e0eff0:	e58d3034 	str	r3, [sp, #52]	; 0x34
57e0eff4:	eafffe9d 	b	57e0ea70 <readline_into_buffer+0x108>
			}
			break;
		}
#endif
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
57e0eff8:	e3a03c01 	mov	r3, #256	; 0x100
57e0effc:	e58d3004 	str	r3, [sp, #4]
57e0f000:	e1a01007 	mov	r1, r7
57e0f004:	e28d2034 	add	r2, sp, #52	; 0x34
57e0f008:	e28d3030 	add	r3, sp, #48	; 0x30
57e0f00c:	e58d4000 	str	r4, [sp]
57e0f010:	ebfffe18 	bl	57e0e878 <cread_add_char>
57e0f014:	eafffe95 	b	57e0ea70 <readline_into_buffer+0x108>
	}
}

static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);
57e0f018:	e59f524c 	ldr	r5, [pc, #588]	; 57e0f26c <readline_into_buffer+0x904>
57e0f01c:	e59f3264 	ldr	r3, [pc, #612]	; 57e0f288 <readline_into_buffer+0x920>
57e0f020:	e5952008 	ldr	r2, [r5, #8]
57e0f024:	e1a01004 	mov	r1, r4
57e0f028:	e0833102 	add	r3, r3, r2, lsl #2
57e0f02c:	e5130bd4 	ldr	r0, [r3, #-3028]	; 0xbd4
57e0f030:	eb0053aa 	bl	57e23ee0 <strcpy>

	if (++hist_add_idx >= HIST_MAX)
57e0f034:	e995000c 	ldmib	r5, {r2, r3}
57e0f038:	e2833001 	add	r3, r3, #1
		hist_add_idx = 0;
57e0f03c:	e3530013 	cmp	r3, #19
57e0f040:	c3a03000 	movgt	r3, #0

	if (hist_add_idx > hist_max)
57e0f044:	e1530002 	cmp	r3, r2
static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);

	if (++hist_add_idx >= HIST_MAX)
		hist_add_idx = 0;
57e0f048:	e5853008 	str	r3, [r5, #8]

	if (hist_add_idx > hist_max)
		hist_max = hist_add_idx;
57e0f04c:	c5853004 	strgt	r3, [r5, #4]

	hist_num++;
57e0f050:	e59f3214 	ldr	r3, [pc, #532]	; 57e0f26c <readline_into_buffer+0x904>
57e0f054:	e593200c 	ldr	r2, [r3, #12]
57e0f058:	e2822001 	add	r2, r2, #1
57e0f05c:	e583200c 	str	r2, [r3, #12]
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
57e0f060:	e59f3204 	ldr	r3, [pc, #516]	; 57e0f26c <readline_into_buffer+0x904>

		if (prompt)
			puts (prompt);

		rc = cread_line(prompt, p, &len, timeout);
		return rc < 0 ? rc : len;
57e0f064:	e1a00006 	mov	r0, r6
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
57e0f068:	e5932008 	ldr	r2, [r3, #8]
57e0f06c:	e59f31fc 	ldr	r3, [pc, #508]	; 57e0f270 <readline_into_buffer+0x908>
57e0f070:	e5832000 	str	r2, [r3]
57e0f074:	ea00007a 	b	57e0f264 <readline_into_buffer+0x8fc>
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
					return -2;	/* timed out */
57e0f078:	e3e00001 	mvn	r0, #1
57e0f07c:	ea000078 	b	57e0f264 <readline_into_buffer+0x8fc>
	int	plen = 0;			/* prompt length	*/
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
57e0f080:	e3500000 	cmp	r0, #0
		return rc < 0 ? rc : len;

	} else {
#endif	/* CONFIG_CMDLINE_EDITING */
	char * p_buf = p;
	int	n = 0;				/* buffer index		*/
57e0f084:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	int	plen = 0;			/* prompt length	*/
57e0f088:	01a05000 	moveq	r5, r0
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
57e0f08c:	0a000003 	beq	57e0f0a0 <readline_into_buffer+0x738>
		plen = strlen (prompt);
57e0f090:	eb0053ee 	bl	57e24050 <strlen>
57e0f094:	e1a05000 	mov	r5, r0
		puts (prompt);
57e0f098:	e1a00006 	mov	r0, r6
57e0f09c:	ebffe8e0 	bl	57e09424 <puts>
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
57e0f0a0:	e59fb1e4 	ldr	fp, [pc, #484]	; 57e0f28c <readline_into_buffer+0x924>
	/* print prompt */
	if (prompt) {
		plen = strlen (prompt);
		puts (prompt);
	}
	col = plen;
57e0f0a4:	e58d5038 	str	r5, [sp, #56]	; 0x38
57e0f0a8:	e1a01004 	mov	r1, r4
					 * Echo input using puts() to force am
					 * LCD flush if we are using an LCD
					 */
					++col;
					buf[0] = c;
					buf[1] = '\0';
57e0f0ac:	e3a0a000 	mov	sl, #0
					puts(buf);
57e0f0b0:	e28d9028 	add	r9, sp, #40	; 0x28
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
57e0f0b4:	e28d6038 	add	r6, sp, #56	; 0x38
57e0f0b8:	e28d703c 	add	r7, sp, #60	; 0x3c
		while (!tstc()) {
			show_activity(0);
			WATCHDOG_RESET();
		}
#endif
		c = getc();
57e0f0bc:	e58d1008 	str	r1, [sp, #8]
57e0f0c0:	ebffe8bb 	bl	57e093b4 <getc>
57e0f0c4:	e20030ff 	and	r3, r0, #255	; 0xff

		/*
		 * Special character handling
		 */
		switch (c) {
57e0f0c8:	e353000a 	cmp	r3, #10
57e0f0cc:	e59d1008 	ldr	r1, [sp, #8]
57e0f0d0:	0a000012 	beq	57e0f120 <readline_into_buffer+0x7b8>
57e0f0d4:	8a000006 	bhi	57e0f0f4 <readline_into_buffer+0x78c>
57e0f0d8:	e3530003 	cmp	r3, #3
57e0f0dc:	0a000017 	beq	57e0f140 <readline_into_buffer+0x7d8>
57e0f0e0:	e3530008 	cmp	r3, #8
57e0f0e4:	0a000031 	beq	57e0f1b0 <readline_into_buffer+0x848>
57e0f0e8:	e3530000 	cmp	r3, #0
57e0f0ec:	0afffff2 	beq	57e0f0bc <readline_into_buffer+0x754>
57e0f0f0:	ea000035 	b	57e0f1cc <readline_into_buffer+0x864>
57e0f0f4:	e3530015 	cmp	r3, #21
57e0f0f8:	0a000019 	beq	57e0f164 <readline_into_buffer+0x7fc>
57e0f0fc:	8a000002 	bhi	57e0f10c <readline_into_buffer+0x7a4>
57e0f100:	e353000d 	cmp	r3, #13
57e0f104:	1a000030 	bne	57e0f1cc <readline_into_buffer+0x864>
57e0f108:	ea000004 	b	57e0f120 <readline_into_buffer+0x7b8>
57e0f10c:	e3530017 	cmp	r3, #23
57e0f110:	0a000019 	beq	57e0f17c <readline_into_buffer+0x814>
57e0f114:	e353007f 	cmp	r3, #127	; 0x7f
57e0f118:	1a00002b 	bne	57e0f1cc <readline_into_buffer+0x864>
57e0f11c:	ea000023 	b	57e0f1b0 <readline_into_buffer+0x848>
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
57e0f120:	e3a03000 	mov	r3, #0
57e0f124:	e5c13000 	strb	r3, [r1]
			puts ("\r\n");
57e0f128:	e59f0160 	ldr	r0, [pc, #352]	; 57e0f290 <readline_into_buffer+0x928>
57e0f12c:	e58d1008 	str	r1, [sp, #8]
57e0f130:	ebffe8bb 	bl	57e09424 <puts>
			return (p - p_buf);
57e0f134:	e59d1008 	ldr	r1, [sp, #8]
57e0f138:	e0640001 	rsb	r0, r4, r1
57e0f13c:	ea000048 	b	57e0f264 <readline_into_buffer+0x8fc>

		case '\0':				/* nul			*/
			continue;

		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
57e0f140:	e3a03000 	mov	r3, #0
57e0f144:	e5c43000 	strb	r3, [r4]
			return (-1);
57e0f148:	e3e00000 	mvn	r0, #0
57e0f14c:	ea000044 	b	57e0f264 <readline_into_buffer+0x8fc>

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
				puts (erase_seq);
57e0f150:	e59f013c 	ldr	r0, [pc, #316]	; 57e0f294 <readline_into_buffer+0x92c>
57e0f154:	ebffe8b2 	bl	57e09424 <puts>
				--col;
57e0f158:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
57e0f15c:	e2433001 	sub	r3, r3, #1
57e0f160:	e58d3038 	str	r3, [sp, #56]	; 0x38
		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
			return (-1);

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
57e0f164:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
57e0f168:	e1530005 	cmp	r3, r5
57e0f16c:	cafffff7 	bgt	57e0f150 <readline_into_buffer+0x7e8>
				puts (erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
57e0f170:	e58da03c 	str	sl, [sp, #60]	; 0x3c
			continue;
57e0f174:	e1a01004 	mov	r1, r4
57e0f178:	eaffffcf 	b	57e0f0bc <readline_into_buffer+0x754>

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
				p=delete_char(p_buf, p, &col, &n, plen);
57e0f17c:	e1a03007 	mov	r3, r7
57e0f180:	e1a00004 	mov	r0, r4
57e0f184:	e1a02006 	mov	r2, r6
57e0f188:	e58d5000 	str	r5, [sp]
57e0f18c:	ebfffd83 	bl	57e0e7a0 <delete_char>
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
57e0f190:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
				p=delete_char(p_buf, p, &col, &n, plen);
57e0f194:	e1a01000 	mov	r1, r0
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
57e0f198:	e3530000 	cmp	r3, #0
57e0f19c:	daffffc6 	ble	57e0f0bc <readline_into_buffer+0x754>
57e0f1a0:	e5d03000 	ldrb	r3, [r0]
57e0f1a4:	e3530020 	cmp	r3, #32
57e0f1a8:	1afffff3 	bne	57e0f17c <readline_into_buffer+0x814>
57e0f1ac:	eaffffc2 	b	57e0f0bc <readline_into_buffer+0x754>
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
57e0f1b0:	e1a00004 	mov	r0, r4
57e0f1b4:	e1a02006 	mov	r2, r6
57e0f1b8:	e1a03007 	mov	r3, r7
57e0f1bc:	e58d5000 	str	r5, [sp]
57e0f1c0:	ebfffd76 	bl	57e0e7a0 <delete_char>
57e0f1c4:	e1a01000 	mov	r1, r0
			continue;
57e0f1c8:	eaffffbb 	b	57e0f0bc <readline_into_buffer+0x754>

		default:
			/*
			 * Must be a normal character then
			 */
			if (n < CONFIG_SYS_CBSIZE-2) {
57e0f1cc:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
57e0f1d0:	e35200fd 	cmp	r2, #253	; 0xfd
57e0f1d4:	ca00001d 	bgt	57e0f250 <readline_into_buffer+0x8e8>
				if (c == '\t') {	/* expand TABs		*/
57e0f1d8:	e3530009 	cmp	r3, #9
57e0f1dc:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
57e0f1e0:	1a00000b 	bne	57e0f214 <readline_into_buffer+0x8ac>
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
57e0f1e4:	e2000007 	and	r0, r0, #7
57e0f1e8:	e08b0000 	add	r0, fp, r0
57e0f1ec:	e58d1008 	str	r1, [sp, #8]
57e0f1f0:	e58d300c 	str	r3, [sp, #12]
57e0f1f4:	ebffe88a 	bl	57e09424 <puts>
					col += 8 - (col&07);
57e0f1f8:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
57e0f1fc:	e59d1008 	ldr	r1, [sp, #8]
57e0f200:	e3c22007 	bic	r2, r2, #7
57e0f204:	e2822008 	add	r2, r2, #8
57e0f208:	e58d2038 	str	r2, [sp, #56]	; 0x38
57e0f20c:	e59d300c 	ldr	r3, [sp, #12]
57e0f210:	ea000009 	b	57e0f23c <readline_into_buffer+0x8d4>

					/*
					 * Echo input using puts() to force am
					 * LCD flush if we are using an LCD
					 */
					++col;
57e0f214:	e2800001 	add	r0, r0, #1
57e0f218:	e58d0038 	str	r0, [sp, #56]	; 0x38
					buf[0] = c;
					buf[1] = '\0';
					puts(buf);
57e0f21c:	e1a00009 	mov	r0, r9
					/*
					 * Echo input using puts() to force am
					 * LCD flush if we are using an LCD
					 */
					++col;
					buf[0] = c;
57e0f220:	e5cd3028 	strb	r3, [sp, #40]	; 0x28
					buf[1] = '\0';
					puts(buf);
57e0f224:	e58d1008 	str	r1, [sp, #8]
57e0f228:	e58d300c 	str	r3, [sp, #12]
					 * Echo input using puts() to force am
					 * LCD flush if we are using an LCD
					 */
					++col;
					buf[0] = c;
					buf[1] = '\0';
57e0f22c:	e5cda029 	strb	sl, [sp, #41]	; 0x29
					puts(buf);
57e0f230:	ebffe87b 	bl	57e09424 <puts>
57e0f234:	e59d300c 	ldr	r3, [sp, #12]
57e0f238:	e59d1008 	ldr	r1, [sp, #8]
				}
				*p++ = c;
57e0f23c:	e4c13001 	strb	r3, [r1], #1
				++n;
57e0f240:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
57e0f244:	e2833001 	add	r3, r3, #1
57e0f248:	e58d303c 	str	r3, [sp, #60]	; 0x3c
57e0f24c:	eaffff9a 	b	57e0f0bc <readline_into_buffer+0x754>
			} else {			/* Buffer full		*/
				putc ('\a');
57e0f250:	e3a00007 	mov	r0, #7
57e0f254:	e58d1008 	str	r1, [sp, #8]
57e0f258:	ebffe867 	bl	57e093fc <putc>
57e0f25c:	e59d1008 	ldr	r1, [sp, #8]
57e0f260:	eaffff95 	b	57e0f0bc <readline_into_buffer+0x754>
		}
	}
#ifdef CONFIG_CMDLINE_EDITING
	}
#endif
}
57e0f264:	e28dd040 	add	sp, sp, #64	; 0x40
57e0f268:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e0f26c:	57e38678 	.word	0x57e38678
57e0f270:	57e36e64 	.word	0x57e36e64
57e0f274:	57e39a98 	.word	0x57e39a98
57e0f278:	57e39a9c 	.word	0x57e39a9c
57e0f27c:	57e32a2d 	.word	0x57e32a2d
57e0f280:	57e32a32 	.word	0x57e32a32
57e0f284:	57e302de 	.word	0x57e302de
57e0f288:	57e3a670 	.word	0x57e3a670
57e0f28c:	57e2c218 	.word	0x57e2c218
57e0f290:	57e32a36 	.word	0x57e32a36
57e0f294:	57e2c214 	.word	0x57e2c214

57e0f298 <readline>:
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
57e0f298:	e59f300c 	ldr	r3, [pc, #12]	; 57e0f2ac <readline+0x14>

	return readline_into_buffer(prompt, console_buffer, 0);
57e0f29c:	e59f100c 	ldr	r1, [pc, #12]	; 57e0f2b0 <readline+0x18>
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
57e0f2a0:	e3a02000 	mov	r2, #0
57e0f2a4:	e5432b84 	strb	r2, [r3, #-2948]	; 0xb84

	return readline_into_buffer(prompt, console_buffer, 0);
57e0f2a8:	eafffdae 	b	57e0e968 <readline_into_buffer>
57e0f2ac:	57e3a670 	.word	0x57e3a670
57e0f2b0:	57e39aec 	.word	0x57e39aec

57e0f2b4 <parse_line>:
}

/****************************************************************************/

int parse_line (char *line, char *argv[])
{
57e0f2b4:	e92d4010 	push	{r4, lr}
	int nargs = 0;
57e0f2b8:	e1a0c001 	mov	ip, r1
57e0f2bc:	e3a04000 	mov	r4, #0
57e0f2c0:	e1a02000 	mov	r2, r0
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {

		/* skip any white space */
		while (isblank(*line))
57e0f2c4:	e4d03001 	ldrb	r3, [r0], #1
57e0f2c8:	e3530020 	cmp	r3, #32
57e0f2cc:	13530009 	cmpne	r3, #9
57e0f2d0:	0afffffa 	beq	57e0f2c0 <parse_line+0xc>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
57e0f2d4:	e3530000 	cmp	r3, #0
57e0f2d8:	0a000005 	beq	57e0f2f4 <parse_line+0x40>
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		argv[nargs++] = line;	/* begin of argument string	*/
57e0f2dc:	e48c2004 	str	r2, [ip], #4
57e0f2e0:	e2844001 	add	r4, r4, #1

		/* find end of string */
		while (*line && !isblank(*line))
57e0f2e4:	e1a00002 	mov	r0, r2
57e0f2e8:	e4d23001 	ldrb	r3, [r2], #1
57e0f2ec:	e3530000 	cmp	r3, #0
57e0f2f0:	1a000001 	bne	57e0f2fc <parse_line+0x48>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
			argv[nargs] = NULL;
57e0f2f4:	e7813104 	str	r3, [r1, r4, lsl #2]
#ifdef DEBUG_PARSER
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
57e0f2f8:	ea00000b 	b	57e0f32c <parse_line+0x78>
		}

		argv[nargs++] = line;	/* begin of argument string	*/

		/* find end of string */
		while (*line && !isblank(*line))
57e0f2fc:	e3530009 	cmp	r3, #9
57e0f300:	13530020 	cmpne	r3, #32
57e0f304:	03a03000 	moveq	r3, #0
57e0f308:	13a03001 	movne	r3, #1
57e0f30c:	1afffff4 	bne	57e0f2e4 <parse_line+0x30>
	int nargs = 0;

#ifdef DEBUG_PARSER
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {
57e0f310:	e3540010 	cmp	r4, #16
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		*line++ = '\0';		/* terminate current arg	 */
57e0f314:	e5c03000 	strb	r3, [r0]
57e0f318:	12800001 	addne	r0, r0, #1
57e0f31c:	1affffe7 	bne	57e0f2c0 <parse_line+0xc>
	}

	printf ("** Too many args (max. %d) **\n", CONFIG_SYS_MAXARGS);
57e0f320:	e59f000c 	ldr	r0, [pc, #12]	; 57e0f334 <parse_line+0x80>
57e0f324:	e1a01004 	mov	r1, r4
57e0f328:	ebffe847 	bl	57e0944c <printf>

#ifdef DEBUG_PARSER
	printf ("parse_line: nargs=%d\n", nargs);
#endif
	return (nargs);
}
57e0f32c:	e1a00004 	mov	r0, r4
57e0f330:	e8bd8010 	pop	{r4, pc}
57e0f334:	57e32a39 	.word	0x57e32a39

57e0f338 <run_command>:
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
57e0f338:	e3a01003 	mov	r1, #3
57e0f33c:	eafff6a6 	b	57e0cddc <parse_string_outer>

57e0f340 <run_command_list>:
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
57e0f340:	e3710001 	cmn	r1, #1
	return rcode;
}
#endif

int run_command_list(const char *cmd, int len, int flag)
{
57e0f344:	e92d4070 	push	{r4, r5, r6, lr}
57e0f348:	e1a06000 	mov	r6, r0
57e0f34c:	e1a04001 	mov	r4, r1
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
57e0f350:	1a000002 	bne	57e0f360 <run_command_list+0x20>
		len = strlen(cmd);
57e0f354:	eb00533d 	bl	57e24050 <strlen>
#endif

int run_command_list(const char *cmd, int len, int flag)
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
57e0f358:	e1a05006 	mov	r5, r6
57e0f35c:	ea000008 	b	57e0f384 <run_command_list+0x44>
		/* the built-in parser will change our string if it sees \n */
		need_buff = strchr(cmd, '\n') != NULL;
#endif
	}
	if (need_buff) {
		buff = malloc(len + 1);
57e0f360:	e2810001 	add	r0, r1, #1
57e0f364:	ebffea16 	bl	57e09bc4 <malloc>
		if (!buff)
57e0f368:	e2505000 	subs	r5, r0, #0
57e0f36c:	0a000008 	beq	57e0f394 <run_command_list+0x54>
			return 1;
		memcpy(buff, cmd, len);
57e0f370:	e1a01006 	mov	r1, r6
57e0f374:	e1a02004 	mov	r2, r4
57e0f378:	eb0053e3 	bl	57e2430c <memcpy>
		buff[len] = '\0';
57e0f37c:	e3a03000 	mov	r3, #0
57e0f380:	e7c53004 	strb	r3, [r5, r4]
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
57e0f384:	e1a00005 	mov	r0, r5
57e0f388:	e3a01002 	mov	r1, #2
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
57e0f38c:	e8bd4070 	pop	{r4, r5, r6, lr}
			return 1;
		memcpy(buff, cmd, len);
		buff[len] = '\0';
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
57e0f390:	eafff691 	b	57e0cddc <parse_string_outer>
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
57e0f394:	e3a00001 	mov	r0, #1
57e0f398:	e8bd8070 	pop	{r4, r5, r6, pc}

57e0f39c <main_loop>:


/****************************************************************************/

void main_loop (void)
{
57e0f39c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
		setenv ("ver", version_string);  /* set version variable */
	}
#endif /* CONFIG_VERSION_VARIABLE */

#ifdef CONFIG_SYS_HUSH_PARSER
	u_boot_hush_start ();
57e0f3a0:	ebfffa8f 	bl	57e0dde4 <u_boot_hush_start>
#if defined(CONFIG_UPDATE_TFTP)
	update_tftp (0UL);
#endif /* CONFIG_UPDATE_TFTP */

#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	s = getenv ("bootdelay");
57e0f3a4:	e59f00fc 	ldr	r0, [pc, #252]	; 57e0f4a8 <main_loop+0x10c>
57e0f3a8:	ebffe0ce 	bl	57e076e8 <getenv>
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
57e0f3ac:	e3500000 	cmp	r0, #0
57e0f3b0:	03a04003 	moveq	r4, #3
57e0f3b4:	0a000003 	beq	57e0f3c8 <main_loop+0x2c>
57e0f3b8:	e3a01000 	mov	r1, #0
57e0f3bc:	e3a0200a 	mov	r2, #10
57e0f3c0:	eb005780 	bl	57e251c8 <simple_strtol>
57e0f3c4:	e1a04000 	mov	r4, r0
		        (unsigned)bootlimit);
		s = getenv ("altbootcmd");
	}
	else
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");
57e0f3c8:	e59f00dc 	ldr	r0, [pc, #220]	; 57e0f4ac <main_loop+0x110>
57e0f3cc:	ebffe0c5 	bl	57e076e8 <getenv>

#endif /* CONFIG_OF_CONTROL */

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
57e0f3d0:	e3500000 	cmp	r0, #0
57e0f3d4:	13740001 	cmnne	r4, #1
57e0f3d8:	e1a06000 	mov	r6, r0
57e0f3dc:	0a00002f 	beq	57e0f4a0 <main_loop+0x104>
	int abort = 0;

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
57e0f3e0:	e3540000 	cmp	r4, #0
#ifndef CONFIG_MENU
static inline
#endif
int abortboot(int bootdelay)
{
	int abort = 0;
57e0f3e4:	b3a05000 	movlt	r5, #0

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
57e0f3e8:	ba00001d 	blt	57e0f464 <main_loop+0xc8>
		printf("Hit any key to stop autoboot: %2d ", bootdelay);
57e0f3ec:	e1a01004 	mov	r1, r4
57e0f3f0:	e59f00b8 	ldr	r0, [pc, #184]	; 57e0f4b0 <main_loop+0x114>
57e0f3f4:	ebffe814 	bl	57e0944c <printf>
	/*
	 * Check if key already pressed
	 * Don't check if bootdelay < 0
	 */
	if (bootdelay >= 0) {
		if (tstc()) {	/* we got a key press	*/
57e0f3f8:	ebffe7f6 	bl	57e093d8 <tstc>
57e0f3fc:	e2505000 	subs	r5, r0, #0
57e0f400:	0a000017 	beq	57e0f464 <main_loop+0xc8>
			(void) getc();  /* consume input	*/
57e0f404:	ebffe7ea 	bl	57e093b4 <getc>
			puts ("\b\b\b 0");
57e0f408:	e59f00a4 	ldr	r0, [pc, #164]	; 57e0f4b4 <main_loop+0x118>
57e0f40c:	ebffe804 	bl	57e09424 <puts>
			abort = 1;	/* don't auto boot	*/
57e0f410:	e3a05001 	mov	r5, #1
57e0f414:	ea000012 	b	57e0f464 <main_loop+0xc8>
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
57e0f418:	ebffe7ee 	bl	57e093d8 <tstc>
57e0f41c:	e3500000 	cmp	r0, #0
57e0f420:	0a000003 	beq	57e0f434 <main_loop+0x98>
				abort  = 1;	/* don't auto boot	*/
				bootdelay = 0;	/* no more delay	*/
# ifdef CONFIG_MENUKEY
				menukey = getc();
# else
				(void) getc();  /* consume input	*/
57e0f424:	ebffe7e2 	bl	57e093b4 <getc>

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
				abort  = 1;	/* don't auto boot	*/
57e0f428:	e3a05001 	mov	r5, #1
				bootdelay = 0;	/* no more delay	*/
57e0f42c:	e3a04000 	mov	r4, #0
57e0f430:	ea000008 	b	57e0f458 <main_loop+0xbc>
# else
				(void) getc();  /* consume input	*/
# endif
				break;
			}
			udelay(10000);
57e0f434:	e59f007c 	ldr	r0, [pc, #124]	; 57e0f4b8 <main_loop+0x11c>
57e0f438:	eb00543e 	bl	57e24538 <udelay>
	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
57e0f43c:	e2877001 	add	r7, r7, #1
57e0f440:	e3570063 	cmp	r7, #99	; 0x63
57e0f444:	c3a05000 	movgt	r5, #0
57e0f448:	d3a05001 	movle	r5, #1
57e0f44c:	e3550000 	cmp	r5, #0
57e0f450:	1afffff0 	bne	57e0f418 <main_loop+0x7c>
#endif

	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
57e0f454:	e2444001 	sub	r4, r4, #1
				break;
			}
			udelay(10000);
		}

		printf("\b\b\b%2d ", bootdelay);
57e0f458:	e59f005c 	ldr	r0, [pc, #92]	; 57e0f4bc <main_loop+0x120>
57e0f45c:	e1a01004 	mov	r1, r4
57e0f460:	ebffe7f9 	bl	57e0944c <printf>
			abort = 1;	/* don't auto boot	*/
		}
	}
#endif

	while ((bootdelay > 0) && (!abort)) {
57e0f464:	e2753001 	rsbs	r3, r5, #1
57e0f468:	33a03000 	movcc	r3, #0
57e0f46c:	e3540000 	cmp	r4, #0
57e0f470:	d3a03000 	movle	r3, #0
57e0f474:	e3530000 	cmp	r3, #0
57e0f478:	13a07000 	movne	r7, #0
57e0f47c:	1affffef 	bne	57e0f440 <main_loop+0xa4>
		}

		printf("\b\b\b%2d ", bootdelay);
	}

	putc('\n');
57e0f480:	e3a0000a 	mov	r0, #10
57e0f484:	ebffe7dc 	bl	57e093fc <putc>

#endif /* CONFIG_OF_CONTROL */

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
57e0f488:	e3550000 	cmp	r5, #0
57e0f48c:	1a000003 	bne	57e0f4a0 <main_loop+0x104>
# ifdef CONFIG_AUTOBOOT_KEYED
		int prev = disable_ctrlc(1);	/* disable Control C checking */
# endif

		run_command_list(s, -1, 0);
57e0f490:	e1a00006 	mov	r0, r6
57e0f494:	e3e01000 	mvn	r1, #0
57e0f498:	e1a02005 	mov	r2, r5
57e0f49c:	ebffffa7 	bl	57e0f340 <run_command_list>

	/*
	 * Main Loop for Monitor Command Processing
	 */
#ifdef CONFIG_SYS_HUSH_PARSER
	parse_file_outer();
57e0f4a0:	ebfffa3e 	bl	57e0dda0 <parse_file_outer>
57e0f4a4:	eafffffe 	b	57e0f4a4 <main_loop+0x108>
57e0f4a8:	57e32a58 	.word	0x57e32a58
57e0f4ac:	57e2e67c 	.word	0x57e2e67c
57e0f4b0:	57e32a62 	.word	0x57e32a62
57e0f4b4:	57e32a85 	.word	0x57e32a85
57e0f4b8:	00002710 	.word	0x00002710
57e0f4bc:	57e32a8b 	.word	0x57e32a8b

57e0f4c0 <do_run>:
#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int i;

	if (argc < 2)
57e0f4c0:	e3520001 	cmp	r2, #1

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
57e0f4c4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;
57e0f4c8:	d3e00000 	mvnle	r0, #0

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
57e0f4cc:	e1a04002 	mov	r4, r2
	int i;

	if (argc < 2)
57e0f4d0:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}
}

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
57e0f4d4:	e2836004 	add	r6, r3, #4
57e0f4d8:	e3a05001 	mov	r5, #1
{
	int i;

	if (argc < 2)
57e0f4dc:	e1a07006 	mov	r7, r6
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
57e0f4e0:	e4960004 	ldr	r0, [r6], #4
57e0f4e4:	ebffe07f 	bl	57e076e8 <getenv>
57e0f4e8:	e3500000 	cmp	r0, #0
57e0f4ec:	1a000004 	bne	57e0f504 <do_run+0x44>
			printf ("## Error: \"%s\" not defined\n", argv[i]);
57e0f4f0:	e59f0034 	ldr	r0, [pc, #52]	; 57e0f52c <do_run+0x6c>
57e0f4f4:	e5971000 	ldr	r1, [r7]
57e0f4f8:	ebffe7d3 	bl	57e0944c <printf>
			return 1;
57e0f4fc:	e3a00001 	mov	r0, #1
57e0f500:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
57e0f504:	e3a01003 	mov	r1, #3
57e0f508:	ebfff633 	bl	57e0cddc <parse_string_outer>
		if ((arg = getenv (argv[i])) == NULL) {
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
57e0f50c:	e3500000 	cmp	r0, #0
57e0f510:	1a000003 	bne	57e0f524 <do_run+0x64>
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
57e0f514:	e2855001 	add	r5, r5, #1
57e0f518:	e1550004 	cmp	r5, r4
57e0f51c:	baffffee 	blt	57e0f4dc <do_run+0x1c>
57e0f520:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
			return 1;
57e0f524:	e3a00001 	mov	r0, #1
	}
	return 0;
}
57e0f528:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e0f52c:	57e30dce 	.word	0x57e30dce

57e0f530 <get_ram_size>:
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
{
57e0f530:	e92d40f0 	push	{r4, r5, r6, r7, lr}
57e0f534:	e24dd084 	sub	sp, sp, #132	; 0x84
57e0f538:	e1a03000 	mov	r3, r0
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
57e0f53c:	e1a04121 	lsr	r4, r1, #2
57e0f540:	e1a021a1 	lsr	r2, r1, #3
57e0f544:	e24d0004 	sub	r0, sp, #4
	volatile long *addr;
	long           save[32];
	long           cnt;
	long           val;
	long           size;
	int            i = 0;
57e0f548:	e3a0c000 	mov	ip, #0

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
57e0f54c:	ea000005 	b	57e0f568 <get_ram_size+0x38>
		addr = base + cnt;	/* pointer arith! */
		sync ();
		save[i++] = *addr;
57e0f550:	e7935102 	ldr	r5, [r3, r2, lsl #2]
57e0f554:	e28cc001 	add	ip, ip, #1
57e0f558:	e5a05004 	str	r5, [r0, #4]!
		sync ();
		*addr = ~cnt;
57e0f55c:	e1e05002 	mvn	r5, r2
57e0f560:	e7835102 	str	r5, [r3, r2, lsl #2]
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
57e0f564:	e1a020c2 	asr	r2, r2, #1
57e0f568:	e3520000 	cmp	r2, #0
57e0f56c:	1afffff7 	bne	57e0f550 <get_ram_size+0x20>
		*addr = ~cnt;
	}

	addr = base;
	sync ();
	save[i] = *addr;
57e0f570:	e5935000 	ldr	r5, [r3]
57e0f574:	e1a0010c 	lsl	r0, ip, #2
57e0f578:	e28d7080 	add	r7, sp, #128	; 0x80
57e0f57c:	e0876000 	add	r6, r7, r0
57e0f580:	e5065080 	str	r5, [r6, #-128]	; 0x80
	sync ();
	*addr = 0;
57e0f584:	e5832000 	str	r2, [r3]

	sync ();
	if ((val = *addr) != 0) {
57e0f588:	e5932000 	ldr	r2, [r3]
57e0f58c:	e3520000 	cmp	r2, #0
57e0f590:	e1a0200d 	mov	r2, sp
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
57e0f594:	10820000 	addne	r0, r2, r0
57e0f598:	008d5000 	addeq	r5, sp, r0
57e0f59c:	03a02001 	moveq	r2, #1
	sync ();
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
57e0f5a0:	15835000 	strne	r5, [r3]
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
57e0f5a4:	13a02001 	movne	r2, #1
	save[i] = *addr;
	sync ();
	*addr = 0;

	sync ();
	if ((val = *addr) != 0) {
57e0f5a8:	1a000003 	bne	57e0f5bc <get_ram_size+0x8c>
57e0f5ac:	ea000018 	b	57e0f614 <get_ram_size+0xe4>
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
57e0f5b0:	e5301004 	ldr	r1, [r0, #-4]!
57e0f5b4:	e7831102 	str	r1, [r3, r2, lsl #2]
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
57e0f5b8:	e1a02082 	lsl	r2, r2, #1
57e0f5bc:	e1520004 	cmp	r2, r4
57e0f5c0:	3afffffa 	bcc	57e0f5b0 <get_ram_size+0x80>
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
		}
		return (0);
57e0f5c4:	e3a00000 	mov	r0, #0
57e0f5c8:	ea000014 	b	57e0f620 <get_ram_size+0xf0>
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
		*addr = save[--i];
57e0f5cc:	e5356004 	ldr	r6, [r5, #-4]!
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
57e0f5d0:	e7937102 	ldr	r7, [r3, r2, lsl #2]
		*addr = save[--i];
57e0f5d4:	e7836102 	str	r6, [r3, r2, lsl #2]
		if (val != ~cnt) {
57e0f5d8:	e1e06002 	mvn	r6, r2
57e0f5dc:	e1570006 	cmp	r7, r6
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
57e0f5e0:	e1a00102 	lsl	r0, r2, #2
		val = *addr;
		*addr = save[--i];
57e0f5e4:	e24cc001 	sub	ip, ip, #1
57e0f5e8:	e1a02082 	lsl	r2, r2, #1
		if (val != ~cnt) {
57e0f5ec:	0a000008 	beq	57e0f614 <get_ram_size+0xe4>
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
57e0f5f0:	e1a0100d 	mov	r1, sp
57e0f5f4:	e081c10c 	add	ip, r1, ip, lsl #2
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
57e0f5f8:	ea000002 	b	57e0f608 <get_ram_size+0xd8>
				addr  = base + cnt;
				*addr = save[--i];
57e0f5fc:	e53c1004 	ldr	r1, [ip, #-4]!
57e0f600:	e7831102 	str	r1, [r3, r2, lsl #2]
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
57e0f604:	e1a02082 	lsl	r2, r2, #1
57e0f608:	e1520004 	cmp	r2, r4
57e0f60c:	3afffffa 	bcc	57e0f5fc <get_ram_size+0xcc>
57e0f610:	ea000002 	b	57e0f620 <get_ram_size+0xf0>
			*addr = save[--i];
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
57e0f614:	e1520004 	cmp	r2, r4
57e0f618:	3affffeb 	bcc	57e0f5cc <get_ram_size+0x9c>
			}
			return (size);
		}
	}

	return (maxsize);
57e0f61c:	e1a00001 	mov	r0, r1
}
57e0f620:	e28dd084 	add	sp, sp, #132	; 0x84
57e0f624:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

57e0f628 <hex1_bin>:
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
57e0f628:	e2403030 	sub	r3, r0, #48	; 0x30
57e0f62c:	e20320ff 	and	r2, r3, #255	; 0xff
57e0f630:	e3520009 	cmp	r2, #9
		return (c - '0');
57e0f634:	91a00003 	movls	r0, r3
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
57e0f638:	912fff1e 	bxls	lr
		return (c - '0');
	if (c >= 'a' && c <= 'f')
57e0f63c:	e2403061 	sub	r3, r0, #97	; 0x61
57e0f640:	e3530005 	cmp	r3, #5
		return (c + 10 - 'a');
57e0f644:	92400057 	subls	r0, r0, #87	; 0x57

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	if (c >= 'a' && c <= 'f')
57e0f648:	912fff1e 	bxls	lr
		return (c + 10 - 'a');
	if (c >= 'A' && c <= 'F')
57e0f64c:	e2403041 	sub	r3, r0, #65	; 0x41
57e0f650:	e3530005 	cmp	r3, #5
		return (c + 10 - 'A');
57e0f654:	92400037 	subls	r0, r0, #55	; 0x37
	return (-1);
57e0f658:	83e00000 	mvnhi	r0, #0
}
57e0f65c:	e12fff1e 	bx	lr

57e0f660 <hex2_bin>:

static int hex2_bin (char *s)
{
57e0f660:	e92d4038 	push	{r3, r4, r5, lr}
57e0f664:	e1a04000 	mov	r4, r0
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
57e0f668:	e5d00000 	ldrb	r0, [r0]
57e0f66c:	ebffffed 	bl	57e0f628 <hex1_bin>
57e0f670:	e2505000 	subs	r5, r0, #0
		return (-1);
57e0f674:	b3e00000 	mvnlt	r0, #0

static int hex2_bin (char *s)
{
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
57e0f678:	b8bd8038 	poplt	{r3, r4, r5, pc}
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
57e0f67c:	e5d40001 	ldrb	r0, [r4, #1]
57e0f680:	ebffffe8 	bl	57e0f628 <hex1_bin>
57e0f684:	e3500000 	cmp	r0, #0
		return (-1);
	}

	return ((i<<4) + j);
57e0f688:	a0800205 	addge	r0, r0, r5, lsl #4

	if ((i = hex1_bin(*s++)) < 0) {
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
		return (-1);
57e0f68c:	b3e00000 	mvnlt	r0, #0
	}

	return ((i<<4) + j);
}
57e0f690:	e8bd8038 	pop	{r3, r4, r5, pc}

57e0f694 <srec_decode>:

static int hex1_bin (char  c);
static int hex2_bin (char *s);

int srec_decode (char *input, int *count, ulong *addr, char *data)
{
57e0f694:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e0f698:	e1a04001 	mov	r4, r1
57e0f69c:	e1a05002 	mov	r5, r2
57e0f6a0:	e1a09003 	mov	r9, r3

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
57e0f6a4:	ea000002 	b	57e0f6b4 <srec_decode+0x20>
		if (*input == 'S') {		/* skip 'S' */
57e0f6a8:	e3530053 	cmp	r3, #83	; 0x53
			++input;
57e0f6ac:	01a07000 	moveq	r7, r0
			break;
57e0f6b0:	0a000004 	beq	57e0f6c8 <srec_decode+0x34>

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
57e0f6b4:	e5d03000 	ldrb	r3, [r0]
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
57e0f6b8:	e1a07000 	mov	r7, r0

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
57e0f6bc:	e3530000 	cmp	r3, #0
57e0f6c0:	e2800001 	add	r0, r0, #1
57e0f6c4:	1afffff7 	bne	57e0f6a8 <srec_decode+0x14>
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
57e0f6c8:	e5d7b000 	ldrb	fp, [r7]
57e0f6cc:	e35b0000 	cmp	fp, #0
		return (SREC_EMPTY);
57e0f6d0:	03a0600a 	moveq	r6, #10
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
57e0f6d4:	0a000089 	beq	57e0f900 <srec_decode+0x26c>
		return (SREC_EMPTY);
	}

	v = *input++;				/* record type		*/
57e0f6d8:	e2877001 	add	r7, r7, #1

	if ((*count = hex2_bin(input)) < 0) {
57e0f6dc:	e1a00007 	mov	r0, r7
57e0f6e0:	ebffffde 	bl	57e0f660 <hex2_bin>
57e0f6e4:	e3500000 	cmp	r0, #0
57e0f6e8:	e5840000 	str	r0, [r4]
57e0f6ec:	ba000082 	blt	57e0f8fc <srec_decode+0x268>
	}

	chksum += *count;
	input  += 2;

	switch (v) {				/* record type		*/
57e0f6f0:	e24b3030 	sub	r3, fp, #48	; 0x30
57e0f6f4:	e3530009 	cmp	r3, #9
57e0f6f8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e0f6fc:	ea00007c 	b	57e0f8f4 <srec_decode+0x260>
57e0f700:	57e0f728 	.word	0x57e0f728
57e0f704:	57e0f738 	.word	0x57e0f738
57e0f708:	57e0f748 	.word	0x57e0f748
57e0f70c:	57e0f758 	.word	0x57e0f758
57e0f710:	57e0f8f4 	.word	0x57e0f8f4
57e0f714:	57e0f768 	.word	0x57e0f768
57e0f718:	57e0f8f4 	.word	0x57e0f8f4
57e0f71c:	57e0f778 	.word	0x57e0f778
57e0f720:	57e0f788 	.word	0x57e0f788
57e0f724:	57e0f798 	.word	0x57e0f798

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
57e0f728:	e2403003 	sub	r3, r0, #3
57e0f72c:	e5843000 	str	r3, [r4]
	input  += 2;

	switch (v) {				/* record type		*/

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
57e0f730:	e3a06000 	mov	r6, #0
		*count   -= 3;			/* - checksum and addr	*/
		break;
57e0f734:	ea00001a 	b	57e0f7a4 <srec_decode+0x110>
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
57e0f738:	e2403003 	sub	r3, r0, #3
57e0f73c:	e5843000 	str	r3, [r4]
	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
57e0f740:	e3a06001 	mov	r6, #1
		*count   -= 3;			/* - checksum and addr	*/
		break;
57e0f744:	ea000016 	b	57e0f7a4 <srec_decode+0x110>
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
57e0f748:	e2403004 	sub	r3, r0, #4
57e0f74c:	e5843000 	str	r3, [r4]
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
57e0f750:	e3a06002 	mov	r6, #2
		*count   -= 4;			/* - checksum and addr	*/
		break;
57e0f754:	ea000012 	b	57e0f7a4 <srec_decode+0x110>
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
57e0f758:	e2403005 	sub	r3, r0, #5
57e0f75c:	e5843000 	str	r3, [r4]
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
57e0f760:	e3a06003 	mov	r6, #3
		*count   -= 5;			/* - checksum and addr	*/
		break;
57e0f764:	ea00000e 	b	57e0f7a4 <srec_decode+0x110>
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
57e0f768:	e3a03000 	mov	r3, #0
57e0f76c:	e5843000 	str	r3, [r4]
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
57e0f770:	e3a06005 	mov	r6, #5
		*count    = 0;			/* no data		*/
		break;
57e0f774:	ea00000a 	b	57e0f7a4 <srec_decode+0x110>
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
57e0f778:	e2403005 	sub	r3, r0, #5
57e0f77c:	e5843000 	str	r3, [r4]
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
		break;
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
57e0f780:	e3a06007 	mov	r6, #7
		*count   -= 5;			/* - checksum and addr	*/
		break;
57e0f784:	ea000006 	b	57e0f7a4 <srec_decode+0x110>
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
57e0f788:	e2403004 	sub	r3, r0, #4
57e0f78c:	e5843000 	str	r3, [r4]
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
57e0f790:	e3a06008 	mov	r6, #8
		*count   -= 4;			/* - checksum and addr	*/
		break;
57e0f794:	ea000002 	b	57e0f7a4 <srec_decode+0x110>
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
57e0f798:	e2403003 	sub	r3, r0, #3
57e0f79c:	e5843000 	str	r3, [r4]
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
57e0f7a0:	e3a06009 	mov	r6, #9
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
57e0f7a4:	e3a03000 	mov	r3, #0

	switch (v) {
57e0f7a8:	e24bb030 	sub	fp, fp, #48	; 0x30
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
57e0f7ac:	e5853000 	str	r3, [r5]

	switch (v) {
57e0f7b0:	e20b30ff 	and	r3, fp, #255	; 0xff
57e0f7b4:	e3530009 	cmp	r3, #9

	if ((*count = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
	}

	chksum += *count;
57e0f7b8:	e200a0ff 	and	sl, r0, #255	; 0xff
	input  += 2;
57e0f7bc:	e2877002 	add	r7, r7, #2
	}

	/* read address field */
	*addr = 0;

	switch (v) {
57e0f7c0:	8a00004b 	bhi	57e0f8f4 <srec_decode+0x260>
57e0f7c4:	e1a0bc0b 	lsl	fp, fp, #24
57e0f7c8:	e3a03001 	mov	r3, #1
57e0f7cc:	e1a0bc4b 	asr	fp, fp, #24
57e0f7d0:	e1a0bb13 	lsl	fp, r3, fp
57e0f7d4:	e59f312c 	ldr	r3, [pc, #300]	; 57e0f908 <srec_decode+0x274>
57e0f7d8:	e00b3003 	and	r3, fp, r3
57e0f7dc:	e3530000 	cmp	r3, #0
57e0f7e0:	1a000016 	bne	57e0f840 <srec_decode+0x1ac>
57e0f7e4:	e31b0088 	tst	fp, #136	; 0x88
57e0f7e8:	1a000002 	bne	57e0f7f8 <srec_decode+0x164>
57e0f7ec:	e31b0f41 	tst	fp, #260	; 0x104
57e0f7f0:	1a000008 	bne	57e0f818 <srec_decode+0x184>
57e0f7f4:	ea00003e 	b	57e0f8f4 <srec_decode+0x260>
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
57e0f7f8:	e1a00007 	mov	r0, r7
57e0f7fc:	ebffff97 	bl	57e0f660 <hex2_bin>
57e0f800:	e3500000 	cmp	r0, #0
57e0f804:	ba00003c 	blt	57e0f8fc <srec_decode+0x268>
			return (SREC_E_NOSREC);
		}
		*addr  += v;
		chksum += v;
57e0f808:	e08aa000 	add	sl, sl, r0
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr  += v;
57e0f80c:	e5850000 	str	r0, [r5]
		chksum += v;
57e0f810:	e20aa0ff 	and	sl, sl, #255	; 0xff
		input  += 2;
57e0f814:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '2':				/* 3 byte addr field	*/
	case '8':
		if ((v = hex2_bin(input)) < 0) {
57e0f818:	e1a00007 	mov	r0, r7
57e0f81c:	ebffff8f 	bl	57e0f660 <hex2_bin>
57e0f820:	e3500000 	cmp	r0, #0
57e0f824:	ba000034 	blt	57e0f8fc <srec_decode+0x268>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
57e0f828:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
57e0f82c:	e08aa000 	add	sl, sl, r0
	case '8':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
57e0f830:	e0803403 	add	r3, r0, r3, lsl #8
57e0f834:	e5853000 	str	r3, [r5]
		chksum += v;
57e0f838:	e20aa0ff 	and	sl, sl, #255	; 0xff
		input  += 2;
57e0f83c:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '0':				/* 2 byte addr field	*/
	case '1':
	case '5':
	case '9':
		if ((v = hex2_bin(input)) < 0) {
57e0f840:	e1a00007 	mov	r0, r7
57e0f844:	ebffff85 	bl	57e0f660 <hex2_bin>
57e0f848:	e250b000 	subs	fp, r0, #0
57e0f84c:	ba00002a 	blt	57e0f8fc <srec_decode+0x268>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
57e0f850:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
		input  += 2;
57e0f854:	e2877002 	add	r7, r7, #2
	case '9':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
57e0f858:	e08b3403 	add	r3, fp, r3, lsl #8
57e0f85c:	e5853000 	str	r3, [r5]
		chksum += v;
		input  += 2;

		if ((v = hex2_bin(input)) < 0) {
57e0f860:	e1a00007 	mov	r0, r7
57e0f864:	e58d3004 	str	r3, [sp, #4]
57e0f868:	ebffff7c 	bl	57e0f660 <hex2_bin>
57e0f86c:	e3500000 	cmp	r0, #0
57e0f870:	e59d3004 	ldr	r3, [sp, #4]
57e0f874:	ba000020 	blt	57e0f8fc <srec_decode+0x268>
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
		chksum += v;
57e0f878:	e08aa00b 	add	sl, sl, fp

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
57e0f87c:	e0803403 	add	r3, r0, r3, lsl #8
		chksum += v;
57e0f880:	e08aa000 	add	sl, sl, r0

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
57e0f884:	e5853000 	str	r3, [r5]
		chksum += v;
57e0f888:	e20aa0ff 	and	sl, sl, #255	; 0xff
		input  += 2;
57e0f88c:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
57e0f890:	e3a05000 	mov	r5, #0
57e0f894:	ea000009 	b	57e0f8c0 <srec_decode+0x22c>
		if ((v = hex2_bin(input)) < 0) {
57e0f898:	e1a00007 	mov	r0, r7
57e0f89c:	ebffff6f 	bl	57e0f660 <hex2_bin>
57e0f8a0:	e3500000 	cmp	r0, #0
57e0f8a4:	ba000014 	blt	57e0f8fc <srec_decode+0x268>
			return (SREC_E_NOSREC);
		}
		data[i] = v;
57e0f8a8:	e20000ff 	and	r0, r0, #255	; 0xff
		chksum += v;
57e0f8ac:	e080a00a 	add	sl, r0, sl
	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		data[i] = v;
57e0f8b0:	e7c90005 	strb	r0, [r9, r5]
		chksum += v;
57e0f8b4:	e20aa0ff 	and	sl, sl, #255	; 0xff
		input  += 2;
57e0f8b8:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
57e0f8bc:	e2855001 	add	r5, r5, #1
57e0f8c0:	e5943000 	ldr	r3, [r4]
57e0f8c4:	e1550003 	cmp	r5, r3
57e0f8c8:	bafffff2 	blt	57e0f898 <srec_decode+0x204>
		chksum += v;
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
57e0f8cc:	e1a00007 	mov	r0, r7
57e0f8d0:	ebffff62 	bl	57e0f660 <hex2_bin>
57e0f8d4:	e3500000 	cmp	r0, #0
57e0f8d8:	ba000007 	blt	57e0f8fc <srec_decode+0x268>
		return (SREC_E_NOSREC);
	}

	if ((unsigned char)v != (unsigned char)~chksum) {
57e0f8dc:	e1e0a00a 	mvn	sl, sl
57e0f8e0:	e20000ff 	and	r0, r0, #255	; 0xff
57e0f8e4:	e20aa0ff 	and	sl, sl, #255	; 0xff
		return (SREC_E_BADCHKS);
57e0f8e8:	e150000a 	cmp	r0, sl
57e0f8ec:	13e06002 	mvnne	r6, #2
57e0f8f0:	ea000002 	b	57e0f900 <srec_decode+0x26c>
		chksum += v;
		input  += 2;

		break;
	default:
		return (SREC_E_BADTYPE);
57e0f8f4:	e3e06000 	mvn	r6, #0
57e0f8f8:	ea000000 	b	57e0f900 <srec_decode+0x26c>
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
57e0f8fc:	e3e06001 	mvn	r6, #1
	if ((unsigned char)v != (unsigned char)~chksum) {
		return (SREC_E_BADCHKS);
	}

	return (srec_type);
}
57e0f900:	e1a00006 	mov	r0, r6
57e0f904:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e0f908:	00000223 	.word	0x00000223

57e0f90c <stdio_get_list>:
 **************************************************************************
 */
struct list_head* stdio_get_list(void)
{
	return &(devs.list);
}
57e0f90c:	e59f0000 	ldr	r0, [pc, #0]	; 57e0f914 <stdio_get_list+0x8>
57e0f910:	e12fff1e 	bx	lr
57e0f914:	57e39c24 	.word	0x57e39c24

57e0f918 <stdio_get_by_name>:

struct stdio_dev* stdio_get_by_name(const char *name)
{
57e0f918:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
57e0f91c:	e2507000 	subs	r7, r0, #0
		return NULL;

	list_for_each(pos, &(devs.list)) {
57e0f920:	159f6040 	ldrne	r6, [pc, #64]	; 57e0f968 <stdio_get_by_name+0x50>
57e0f924:	15b65034 	ldrne	r5, [r6, #52]!	; 0x34
struct stdio_dev* stdio_get_by_name(const char *name)
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
57e0f928:	0a00000b 	beq	57e0f95c <stdio_get_by_name+0x44>
57e0f92c:	ea000006 	b	57e0f94c <stdio_get_by_name+0x34>
		return NULL;

	list_for_each(pos, &(devs.list)) {
		dev = list_entry(pos, struct stdio_dev, list);
57e0f930:	e2454034 	sub	r4, r5, #52	; 0x34
		if(strcmp(dev->name, name) == 0)
57e0f934:	e2840008 	add	r0, r4, #8
57e0f938:	e1a01007 	mov	r1, r7
57e0f93c:	eb005198 	bl	57e23fa4 <strcmp>
57e0f940:	e3500000 	cmp	r0, #0
57e0f944:	0a000005 	beq	57e0f960 <stdio_get_by_name+0x48>
	struct stdio_dev *dev;

	if(!name)
		return NULL;

	list_for_each(pos, &(devs.list)) {
57e0f948:	e5955000 	ldr	r5, [r5]
57e0f94c:	e1550006 	cmp	r5, r6
57e0f950:	1afffff6 	bne	57e0f930 <stdio_get_by_name+0x18>
		dev = list_entry(pos, struct stdio_dev, list);
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
57e0f954:	e3a04000 	mov	r4, #0
57e0f958:	ea000000 	b	57e0f960 <stdio_get_by_name+0x48>
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
		return NULL;
57e0f95c:	e1a04007 	mov	r4, r7
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
}
57e0f960:	e1a00004 	mov	r0, r4
57e0f964:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e0f968:	57e39bf0 	.word	0x57e39bf0

57e0f96c <stdio_clone>:

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
57e0f96c:	e92d4038 	push	{r3, r4, r5, lr}
	struct stdio_dev *_dev;

	if(!dev)
57e0f970:	e2505000 	subs	r5, r0, #0
		return NULL;
57e0f974:	01a04005 	moveq	r4, r5

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
	struct stdio_dev *_dev;

	if(!dev)
57e0f978:	0a000007 	beq	57e0f99c <stdio_clone+0x30>
		return NULL;

	_dev = calloc(1, sizeof(struct stdio_dev));
57e0f97c:	e3a00001 	mov	r0, #1
57e0f980:	e3a0103c 	mov	r1, #60	; 0x3c
57e0f984:	ebffe9fc 	bl	57e0a17c <calloc>

	if(!_dev)
57e0f988:	e2504000 	subs	r4, r0, #0
57e0f98c:	0a000002 	beq	57e0f99c <stdio_clone+0x30>
		return NULL;

	memcpy(_dev, dev, sizeof(struct stdio_dev));
57e0f990:	e1a01005 	mov	r1, r5
57e0f994:	e3a0203c 	mov	r2, #60	; 0x3c
57e0f998:	eb00525b 	bl	57e2430c <memcpy>

	return _dev;
}
57e0f99c:	e1a00004 	mov	r0, r4
57e0f9a0:	e8bd8038 	pop	{r3, r4, r5, pc}

57e0f9a4 <stdio_register>:

int stdio_register (struct stdio_dev * dev)
{
57e0f9a4:	e92d4008 	push	{r3, lr}
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
57e0f9a8:	ebffffef 	bl	57e0f96c <stdio_clone>
	if(!_dev)
57e0f9ac:	e3500000 	cmp	r0, #0
57e0f9b0:	0a000009 	beq	57e0f9dc <stdio_register+0x38>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
57e0f9b4:	e59f3028 	ldr	r3, [pc, #40]	; 57e0f9e4 <stdio_register+0x40>
		return -1;
	list_add_tail(&(_dev->list), &(devs.list));
57e0f9b8:	e2801034 	add	r1, r0, #52	; 0x34
57e0f9bc:	e5932038 	ldr	r2, [r3, #56]	; 0x38
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
57e0f9c0:	e5831038 	str	r1, [r3, #56]	; 0x38
	new->next = next;
57e0f9c4:	e2833034 	add	r3, r3, #52	; 0x34
57e0f9c8:	e5803034 	str	r3, [r0, #52]	; 0x34
	new->prev = prev;
57e0f9cc:	e5802038 	str	r2, [r0, #56]	; 0x38
	prev->next = new;
57e0f9d0:	e5821000 	str	r1, [r2]
	return 0;
57e0f9d4:	e3a00000 	mov	r0, #0
57e0f9d8:	e8bd8008 	pop	{r3, pc}
{
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
	if(!_dev)
		return -1;
57e0f9dc:	e3e00000 	mvn	r0, #0
	list_add_tail(&(_dev->list), &(devs.list));
	return 0;
}
57e0f9e0:	e8bd8008 	pop	{r3, pc}
57e0f9e4:	57e39bf0 	.word	0x57e39bf0

57e0f9e8 <stdio_init>:
	return 0;
}
#endif	/* CONFIG_SYS_STDIO_DEREGISTER */

int stdio_init (void)
{
57e0f9e8:	e92d4010 	push	{r4, lr}
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
57e0f9ec:	e59f306c 	ldr	r3, [pc, #108]	; 57e0fa60 <stdio_init+0x78>
57e0f9f0:	e24dd040 	sub	sp, sp, #64	; 0x40
57e0f9f4:	e2832034 	add	r2, r3, #52	; 0x34

static void drv_system_init (void)
{
	struct stdio_dev dev;

	memset (&dev, 0, sizeof (dev));
57e0f9f8:	e28d4004 	add	r4, sp, #4
57e0f9fc:	e5832034 	str	r2, [r3, #52]	; 0x34
	list->prev = list;
57e0fa00:	e5832038 	str	r2, [r3, #56]	; 0x38
57e0fa04:	e1a00004 	mov	r0, r4
57e0fa08:	e3a0203c 	mov	r2, #60	; 0x3c
57e0fa0c:	e3a01000 	mov	r1, #0
57e0fa10:	eb005219 	bl	57e2427c <memset>

	strcpy (dev.name, "serial");
57e0fa14:	e59f1048 	ldr	r1, [pc, #72]	; 57e0fa64 <stdio_init+0x7c>
57e0fa18:	e2840008 	add	r0, r4, #8
57e0fa1c:	eb00512f 	bl	57e23ee0 <strcpy>
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
57e0fa20:	e3a0310e 	mov	r3, #-2147483645	; 0x80000003
57e0fa24:	e58d3004 	str	r3, [sp, #4]
	dev.putc = serial_putc;
57e0fa28:	e59f3038 	ldr	r3, [pc, #56]	; 57e0fa68 <stdio_init+0x80>
	dev.puts = serial_puts;
	dev.getc = serial_getc;
	dev.tstc = serial_tstc;
	stdio_register (&dev);
57e0fa2c:	e1a00004 	mov	r0, r4

	memset (&dev, 0, sizeof (dev));

	strcpy (dev.name, "serial");
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
	dev.putc = serial_putc;
57e0fa30:	e58d3024 	str	r3, [sp, #36]	; 0x24
	dev.puts = serial_puts;
57e0fa34:	e59f3030 	ldr	r3, [pc, #48]	; 57e0fa6c <stdio_init+0x84>
57e0fa38:	e58d3028 	str	r3, [sp, #40]	; 0x28
	dev.getc = serial_getc;
57e0fa3c:	e59f302c 	ldr	r3, [pc, #44]	; 57e0fa70 <stdio_init+0x88>
57e0fa40:	e58d3030 	str	r3, [sp, #48]	; 0x30
	dev.tstc = serial_tstc;
57e0fa44:	e59f3028 	ldr	r3, [pc, #40]	; 57e0fa74 <stdio_init+0x8c>
57e0fa48:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	stdio_register (&dev);
57e0fa4c:	ebffffd4 	bl	57e0f9a4 <stdio_register>
#endif
#ifdef CONFIG_LOGBUFFER
	drv_logbuff_init ();
#endif
	drv_system_init ();
	serial_stdio_init ();
57e0fa50:	eb003518 	bl	57e1ceb8 <serial_stdio_init>
#endif
#ifdef CONFIG_CBMEM_CONSOLE
	cbmemc_init();
#endif
	return (0);
}
57e0fa54:	e3a00000 	mov	r0, #0
57e0fa58:	e28dd040 	add	sp, sp, #64	; 0x40
57e0fa5c:	e8bd8010 	pop	{r4, pc}
57e0fa60:	57e39bf0 	.word	0x57e39bf0
57e0fa64:	57e32a93 	.word	0x57e32a93
57e0fa68:	57e1d1f4 	.word	0x57e1d1f4
57e0fa6c:	57e1d210 	.word	0x57e1d210
57e0fa70:	57e1d1cc 	.word	0x57e1d1cc
57e0fa74:	57e1d1e0 	.word	0x57e1d1e0

57e0fa78 <usb_set_maxpacket_ep>:
	struct usb_endpoint_descriptor *ep;
	u16 ep_wMaxPacketSize;

	ep = &dev->config.if_desc[if_idx].ep_desc[ep_idx];

	b = ep->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
57e0fa78:	e3a0309c 	mov	r3, #156	; 0x9c
57e0fa7c:	e0822182 	add	r2, r2, r2, lsl #3
57e0fa80:	e0222193 	mla	r2, r3, r1, r2
 *
 * NOTE: Similar behaviour was observed with GCC4.6 on ARMv5.
 */
static void noinline
usb_set_maxpacket_ep(struct usb_device *dev, int if_idx, int ep_idx)
{
57e0fa84:	e92d4030 	push	{r4, r5, lr}
	struct usb_endpoint_descriptor *ep;
	u16 ep_wMaxPacketSize;

	ep = &dev->config.if_desc[if_idx].ep_desc[ep_idx];

	b = ep->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
57e0fa88:	e0805002 	add	r5, r0, r2
	ep_wMaxPacketSize = get_unaligned(&ep->wMaxPacketSize);
57e0fa8c:	e2822e12 	add	r2, r2, #288	; 0x120
57e0fa90:	e0802002 	add	r2, r0, r2
57e0fa94:	e5d2100d 	ldrb	r1, [r2, #13]
57e0fa98:	e5d2300c 	ldrb	r3, [r2, #12]

	if ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
57e0fa9c:	e5d5212b 	ldrb	r2, [r5, #299]	; 0x12b
	struct usb_endpoint_descriptor *ep;
	u16 ep_wMaxPacketSize;

	ep = &dev->config.if_desc[if_idx].ep_desc[ep_idx];

	b = ep->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
57e0faa0:	e5d5412a 	ldrb	r4, [r5, #298]	; 0x12a
	ep_wMaxPacketSize = get_unaligned(&ep->wMaxPacketSize);

	if ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
57e0faa4:	e3120003 	tst	r2, #3
	struct usb_endpoint_descriptor *ep;
	u16 ep_wMaxPacketSize;

	ep = &dev->config.if_desc[if_idx].ep_desc[ep_idx];

	b = ep->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
57e0faa8:	e204c00f 	and	ip, r4, #15
57e0faac:	e1833401 	orr	r3, r3, r1, lsl #8
	ep_wMaxPacketSize = get_unaligned(&ep->wMaxPacketSize);

	if ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
57e0fab0:	1a000003 	bne	57e0fac4 <usb_set_maxpacket_ep+0x4c>
						USB_ENDPOINT_XFER_CONTROL) {
		/* Control => bidirectional */
		dev->epmaxpacketout[b] = ep_wMaxPacketSize;
57e0fab4:	e080210c 	add	r2, r0, ip, lsl #2
57e0fab8:	e58230bc 	str	r3, [r2, #188]	; 0xbc
		dev->epmaxpacketin[b] = ep_wMaxPacketSize;
57e0fabc:	e582307c 	str	r3, [r2, #124]	; 0x7c
57e0fac0:	e8bd8030 	pop	{r4, r5, pc}
		USB_PRINTF("##Control EP epmaxpacketout/in[%d] = %d\n",
			   b, dev->epmaxpacketin[b]);
	} else {
		if ((ep->bEndpointAddress & 0x80) == 0) {
57e0fac4:	e3140080 	tst	r4, #128	; 0x80
			/* OUT Endpoint */
			if (ep_wMaxPacketSize > dev->epmaxpacketout[b]) {
57e0fac8:	028cc02e 	addeq	ip, ip, #46	; 0x2e
				USB_PRINTF("##EP epmaxpacketout[%d] = %d\n",
					   b, dev->epmaxpacketout[b]);
			}
		} else {
			/* IN Endpoint */
			if (ep_wMaxPacketSize > dev->epmaxpacketin[b]) {
57e0facc:	128cc01e 	addne	ip, ip, #30
57e0fad0:	e080010c 	add	r0, r0, ip, lsl #2
57e0fad4:	e5902004 	ldr	r2, [r0, #4]
57e0fad8:	e1530002 	cmp	r3, r2
				dev->epmaxpacketin[b] = ep_wMaxPacketSize;
57e0fadc:	c5803004 	strgt	r3, [r0, #4]
57e0fae0:	e8bd8030 	pop	{r4, r5, pc}

57e0fae4 <usb_stop>:

/******************************************************************************
 * Stop USB this stops the LowLevel Part and deregisters USB devices.
 */
int usb_stop(void)
{
57e0fae4:	e92d4010 	push	{r4, lr}
	int i;

	if (usb_started) {
57e0fae8:	e59f3040 	ldr	r3, [pc, #64]	; 57e0fb30 <usb_stop+0x4c>
57e0faec:	e5d32000 	ldrb	r2, [r3]
57e0faf0:	e3520000 	cmp	r2, #0
57e0faf4:	0a00000b 	beq	57e0fb28 <usb_stop+0x44>
		asynch_allowed = 1;
57e0faf8:	e3a02001 	mov	r2, #1
		usb_started = 0;
57e0fafc:	e3a04000 	mov	r4, #0
int usb_stop(void)
{
	int i;

	if (usb_started) {
		asynch_allowed = 1;
57e0fb00:	e5832004 	str	r2, [r3, #4]
		usb_started = 0;
57e0fb04:	e5c34000 	strb	r4, [r3]
		usb_hub_reset();
57e0fb08:	eb00042d 	bl	57e10bc4 <usb_hub_reset>

		for (i = 0; i < CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
			if (usb_lowlevel_stop(i))
57e0fb0c:	e1a00004 	mov	r0, r4
57e0fb10:	eb003bb9 	bl	57e1e9fc <usb_lowlevel_stop>
57e0fb14:	e1500004 	cmp	r0, r4
57e0fb18:	0a000002 	beq	57e0fb28 <usb_stop+0x44>
				printf("failed to stop USB controller %d\n", i);
57e0fb1c:	e59f0010 	ldr	r0, [pc, #16]	; 57e0fb34 <usb_stop+0x50>
57e0fb20:	e1a01004 	mov	r1, r4
57e0fb24:	ebffe648 	bl	57e0944c <printf>
		}
	}

	return 0;
}
57e0fb28:	e3a00000 	mov	r0, #0
57e0fb2c:	e8bd8010 	pop	{r4, pc}
57e0fb30:	57e39c40 	.word	0x57e39c40
57e0fb34:	57e32a9a 	.word	0x57e32a9a

57e0fb38 <usb_disable_asynch>:
 * transfers that uses the exclusiv access to the control and bulk messages.
 * Returns the old value so it can be restored later.
 */
int usb_disable_asynch(int disable)
{
	int old_value = asynch_allowed;
57e0fb38:	e59f3014 	ldr	r3, [pc, #20]	; 57e0fb54 <usb_disable_asynch+0x1c>

	asynch_allowed = !disable;
57e0fb3c:	e2700001 	rsbs	r0, r0, #1
57e0fb40:	33a00000 	movcc	r0, #0
 * transfers that uses the exclusiv access to the control and bulk messages.
 * Returns the old value so it can be restored later.
 */
int usb_disable_asynch(int disable)
{
	int old_value = asynch_allowed;
57e0fb44:	e5932004 	ldr	r2, [r3, #4]

	asynch_allowed = !disable;
57e0fb48:	e5830004 	str	r0, [r3, #4]
	return old_value;
}
57e0fb4c:	e1a00002 	mov	r0, r2
57e0fb50:	e12fff1e 	bx	lr
57e0fb54:	57e39c40 	.word	0x57e39c40

57e0fb58 <usb_submit_int_msg>:
 * submits an Interrupt Message
 */
int usb_submit_int_msg(struct usb_device *dev, unsigned long pipe,
			void *buffer, int transfer_len, int interval)
{
	return submit_int_msg(dev, pipe, buffer, transfer_len, interval);
57e0fb58:	ea003b3c 	b	57e1e850 <submit_int_msg>

57e0fb5c <usb_control_msg>:
 */
int usb_control_msg(struct usb_device *dev, unsigned int pipe,
			unsigned char request, unsigned char requesttype,
			unsigned short value, unsigned short index,
			void *data, unsigned short size, int timeout)
{
57e0fb5c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
57e0fb60:	e24dd08c 	sub	sp, sp, #140	; 0x8c
57e0fb64:	e59d60b0 	ldr	r6, [sp, #176]	; 0xb0
57e0fb68:	e1a05000 	mov	r5, r0
	ALLOC_CACHE_ALIGN_BUFFER(struct devrequest, setup_packet, 1);

	if ((timeout == 0) && (!asynch_allowed)) {
57e0fb6c:	e3560000 	cmp	r6, #0
 */
int usb_control_msg(struct usb_device *dev, unsigned int pipe,
			unsigned char request, unsigned char requesttype,
			unsigned short value, unsigned short index,
			void *data, unsigned short size, int timeout)
{
57e0fb70:	e1ddcab0 	ldrh	ip, [sp, #160]	; 0xa0
57e0fb74:	e1dd0ab4 	ldrh	r0, [sp, #164]	; 0xa4
57e0fb78:	e1dd4abc 	ldrh	r4, [sp, #172]	; 0xac
	ALLOC_CACHE_ALIGN_BUFFER(struct devrequest, setup_packet, 1);

	if ((timeout == 0) && (!asynch_allowed)) {
57e0fb7c:	1a000003 	bne	57e0fb90 <usb_control_msg+0x34>
57e0fb80:	e59f70ac 	ldr	r7, [pc, #172]	; 57e0fc34 <usb_control_msg+0xd8>
57e0fb84:	e5977004 	ldr	r7, [r7, #4]
57e0fb88:	e3570000 	cmp	r7, #0
57e0fb8c:	0a000024 	beq	57e0fc24 <usb_control_msg+0xc8>
int usb_control_msg(struct usb_device *dev, unsigned int pipe,
			unsigned char request, unsigned char requesttype,
			unsigned short value, unsigned short index,
			void *data, unsigned short size, int timeout)
{
	ALLOC_CACHE_ALIGN_BUFFER(struct devrequest, setup_packet, 1);
57e0fb90:	e28de047 	add	lr, sp, #71	; 0x47
57e0fb94:	e3cee03f 	bic	lr, lr, #63	; 0x3f
		/* request for a asynch control pipe is not allowed */
		return -1;
	}

	/* set setup command */
	setup_packet->requesttype = requesttype;
57e0fb98:	e5ce3000 	strb	r3, [lr]
	setup_packet->request = request;
	setup_packet->value = cpu_to_le16(value);
57e0fb9c:	e5cec002 	strb	ip, [lr, #2]
	setup_packet->index = cpu_to_le16(index);
57e0fba0:	e5ce0004 	strb	r0, [lr, #4]
	}

	/* set setup command */
	setup_packet->requesttype = requesttype;
	setup_packet->request = request;
	setup_packet->value = cpu_to_le16(value);
57e0fba4:	e1a0c42c 	lsr	ip, ip, #8
	setup_packet->index = cpu_to_le16(index);
57e0fba8:	e1a00420 	lsr	r0, r0, #8
	setup_packet->length = cpu_to_le16(size);
57e0fbac:	e1a03424 	lsr	r3, r4, #8

	/* set setup command */
	setup_packet->requesttype = requesttype;
	setup_packet->request = request;
	setup_packet->value = cpu_to_le16(value);
	setup_packet->index = cpu_to_le16(index);
57e0fbb0:	e5ce0005 	strb	r0, [lr, #5]
	setup_packet->length = cpu_to_le16(size);
57e0fbb4:	e5ce3007 	strb	r3, [lr, #7]
		return -1;
	}

	/* set setup command */
	setup_packet->requesttype = requesttype;
	setup_packet->request = request;
57e0fbb8:	e5ce2001 	strb	r2, [lr, #1]
	setup_packet->value = cpu_to_le16(value);
57e0fbbc:	e5cec003 	strb	ip, [lr, #3]
	setup_packet->index = cpu_to_le16(index);
	setup_packet->length = cpu_to_le16(size);
57e0fbc0:	e5ce4006 	strb	r4, [lr, #6]
	USB_PRINTF("usb_control_msg: request: 0x%X, requesttype: 0x%X, " \
		   "value 0x%X index 0x%X length 0x%X\n",
		   request, requesttype, value, index, size);
	dev->status = USB_ST_NOT_PROC; /*not yet processed */
57e0fbc4:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
57e0fbc8:	e5853614 	str	r3, [r5, #1556]	; 0x614

	if (submit_control_msg(dev, pipe, data, size, setup_packet) < 0)
57e0fbcc:	e1a00005 	mov	r0, r5
57e0fbd0:	e59d20a8 	ldr	r2, [sp, #168]	; 0xa8
57e0fbd4:	e1a03004 	mov	r3, r4
57e0fbd8:	e58de000 	str	lr, [sp]
57e0fbdc:	eb0039ac 	bl	57e1e294 <submit_control_msg>
57e0fbe0:	e3500000 	cmp	r0, #0
57e0fbe4:	ba00000e 	blt	57e0fc24 <usb_control_msg+0xc8>
		return -1;
	if (timeout == 0)
57e0fbe8:	e3560000 	cmp	r6, #0
57e0fbec:	0a00000d 	beq	57e0fc28 <usb_control_msg+0xcc>
57e0fbf0:	ea000005 	b	57e0fc0c <usb_control_msg+0xb0>
	 * Wait for status to update until timeout expires, USB driver
	 * interrupt handler may set the status when the USB operation has
	 * been completed.
	 */
	while (timeout--) {
		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
57e0fbf4:	e5953614 	ldr	r3, [r5, #1556]	; 0x614
		   request, requesttype, value, index, size);
	dev->status = USB_ST_NOT_PROC; /*not yet processed */

	if (submit_control_msg(dev, pipe, data, size, setup_packet) < 0)
		return -1;
	if (timeout == 0)
57e0fbf8:	e2466001 	sub	r6, r6, #1
	 * Wait for status to update until timeout expires, USB driver
	 * interrupt handler may set the status when the USB operation has
	 * been completed.
	 */
	while (timeout--) {
		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
57e0fbfc:	e3530000 	cmp	r3, #0
57e0fc00:	aa000003 	bge	57e0fc14 <usb_control_msg+0xb8>
			break;
		mdelay(1);
57e0fc04:	e3a00001 	mov	r0, #1
57e0fc08:	eb005256 	bl	57e24568 <mdelay>
	/*
	 * Wait for status to update until timeout expires, USB driver
	 * interrupt handler may set the status when the USB operation has
	 * been completed.
	 */
	while (timeout--) {
57e0fc0c:	e3560000 	cmp	r6, #0
57e0fc10:	1afffff7 	bne	57e0fbf4 <usb_control_msg+0x98>
		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
			break;
		mdelay(1);
	}
	if (dev->status)
57e0fc14:	e5953614 	ldr	r3, [r5, #1556]	; 0x614
57e0fc18:	e3530000 	cmp	r3, #0
		return -1;

	return dev->act_len;
57e0fc1c:	05954618 	ldreq	r4, [r5, #1560]	; 0x618
	while (timeout--) {
		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
			break;
		mdelay(1);
	}
	if (dev->status)
57e0fc20:	0a000000 	beq	57e0fc28 <usb_control_msg+0xcc>
		return -1;
57e0fc24:	e3e04000 	mvn	r4, #0

	return dev->act_len;

}
57e0fc28:	e1a00004 	mov	r0, r4
57e0fc2c:	e28dd08c 	add	sp, sp, #140	; 0x8c
57e0fc30:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
57e0fc34:	57e39c40 	.word	0x57e39c40

57e0fc38 <usb_get_descriptor>:
/**********************************************************************
 * get_descriptor type
 */
static int usb_get_descriptor(struct usb_device *dev, unsigned char type,
			unsigned char index, void *buf, int size)
{
57e0fc38:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	int res;
	res = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
57e0fc3c:	e590c000 	ldr	ip, [r0]
57e0fc40:	e590e068 	ldr	lr, [r0, #104]	; 0x68
57e0fc44:	e58d3008 	str	r3, [sp, #8]
57e0fc48:	e59d3020 	ldr	r3, [sp, #32]
57e0fc4c:	e0822401 	add	r2, r2, r1, lsl #8
57e0fc50:	e1a02802 	lsl	r2, r2, #16
57e0fc54:	e1a03803 	lsl	r3, r3, #16
57e0fc58:	e1a02822 	lsr	r2, r2, #16
57e0fc5c:	e1a03823 	lsr	r3, r3, #16
57e0fc60:	e38ee102 	orr	lr, lr, #-2147483648	; 0x80000000
57e0fc64:	e38ee080 	orr	lr, lr, #128	; 0x80
57e0fc68:	e58d2000 	str	r2, [sp]
57e0fc6c:	e58d300c 	str	r3, [sp, #12]
57e0fc70:	e3a02000 	mov	r2, #0
57e0fc74:	e3a03064 	mov	r3, #100	; 0x64
57e0fc78:	e58d2004 	str	r2, [sp, #4]
57e0fc7c:	e58d3010 	str	r3, [sp, #16]
57e0fc80:	e18e140c 	orr	r1, lr, ip, lsl #8
57e0fc84:	e2822006 	add	r2, r2, #6
57e0fc88:	e283301c 	add	r3, r3, #28
57e0fc8c:	ebffffb2 	bl	57e0fb5c <usb_control_msg>
			USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
			(type << 8) + index, 0,
			buf, size, USB_CNTL_TIMEOUT);
	return res;
}
57e0fc90:	e28dd01c 	add	sp, sp, #28
57e0fc94:	e8bd8000 	pop	{pc}

57e0fc98 <usb_get_string>:
/********************************************************************
 * get string index in buffer
 */
static int usb_get_string(struct usb_device *dev, unsigned short langid,
		   unsigned char index, void *buf, int size)
{
57e0fc98:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e0fc9c:	e24dd018 	sub	sp, sp, #24
	int i;
	int result;

	for (i = 0; i < 3; ++i) {
		/* some devices are flaky */
		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
57e0fca0:	e1dd93b8 	ldrh	r9, [sp, #56]	; 0x38
/********************************************************************
 * get string index in buffer
 */
static int usb_get_string(struct usb_device *dev, unsigned short langid,
		   unsigned char index, void *buf, int size)
{
57e0fca4:	e1a05000 	mov	r5, r0
57e0fca8:	e1a06001 	mov	r6, r1
57e0fcac:	e1a07003 	mov	r7, r3
	int i;
	int result;

	for (i = 0; i < 3; ++i) {
57e0fcb0:	e3a04000 	mov	r4, #0
		/* some devices are flaky */
		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
57e0fcb4:	e282ac03 	add	sl, r2, #768	; 0x300
57e0fcb8:	e3a0b064 	mov	fp, #100	; 0x64
57e0fcbc:	e5953068 	ldr	r3, [r5, #104]	; 0x68
57e0fcc0:	e5951000 	ldr	r1, [r5]
57e0fcc4:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
57e0fcc8:	e3833080 	orr	r3, r3, #128	; 0x80
57e0fccc:	e1831401 	orr	r1, r3, r1, lsl #8
57e0fcd0:	e1a00005 	mov	r0, r5
57e0fcd4:	e3a02006 	mov	r2, #6
57e0fcd8:	e3a03080 	mov	r3, #128	; 0x80
57e0fcdc:	e58da000 	str	sl, [sp]
57e0fce0:	e98d0ac0 	stmib	sp, {r6, r7, r9, fp}
57e0fce4:	ebffff9c 	bl	57e0fb5c <usb_control_msg>
			USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
			(USB_DT_STRING << 8) + index, langid, buf, size,
			USB_CNTL_TIMEOUT);

		if (result > 0)
57e0fce8:	e3500000 	cmp	r0, #0
57e0fcec:	ca000002 	bgt	57e0fcfc <usb_get_string+0x64>
		   unsigned char index, void *buf, int size)
{
	int i;
	int result;

	for (i = 0; i < 3; ++i) {
57e0fcf0:	e2844001 	add	r4, r4, #1
57e0fcf4:	e3540003 	cmp	r4, #3
57e0fcf8:	1affffef 	bne	57e0fcbc <usb_get_string+0x24>
		if (result > 0)
			break;
	}

	return result;
}
57e0fcfc:	e28dd018 	add	sp, sp, #24
57e0fd00:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e0fd04 <usb_string_sub>:
}


static int usb_string_sub(struct usb_device *dev, unsigned int langid,
		unsigned int index, unsigned char *buf)
{
57e0fd04:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	int rc;

	/* Try to read the string descriptor by asking for the maximum
	 * possible number of bytes */
	rc = usb_get_string(dev, langid, index, buf, 255);
57e0fd08:	e1a01801 	lsl	r1, r1, #16
57e0fd0c:	e20250ff 	and	r5, r2, #255	; 0xff
57e0fd10:	e1a06821 	lsr	r6, r1, #16
57e0fd14:	e3a020ff 	mov	r2, #255	; 0xff
57e0fd18:	e58d2000 	str	r2, [sp]
57e0fd1c:	e1a01006 	mov	r1, r6
57e0fd20:	e1a02005 	mov	r2, r5
}


static int usb_string_sub(struct usb_device *dev, unsigned int langid,
		unsigned int index, unsigned char *buf)
{
57e0fd24:	e1a07000 	mov	r7, r0
57e0fd28:	e1a04003 	mov	r4, r3
	int rc;

	/* Try to read the string descriptor by asking for the maximum
	 * possible number of bytes */
	rc = usb_get_string(dev, langid, index, buf, 255);
57e0fd2c:	ebffffd9 	bl	57e0fc98 <usb_get_string>

	/* If that failed try to read the descriptor length, then
	 * ask for just that many bytes */
	if (rc < 2) {
57e0fd30:	e3500001 	cmp	r0, #1
57e0fd34:	ca000012 	bgt	57e0fd84 <usb_string_sub+0x80>
		rc = usb_get_string(dev, langid, index, buf, 2);
57e0fd38:	e3a03002 	mov	r3, #2
57e0fd3c:	e58d3000 	str	r3, [sp]
57e0fd40:	e1a00007 	mov	r0, r7
57e0fd44:	e1a01006 	mov	r1, r6
57e0fd48:	e1a02005 	mov	r2, r5
57e0fd4c:	e1a03004 	mov	r3, r4
57e0fd50:	ebffffd0 	bl	57e0fc98 <usb_get_string>
		if (rc == 2)
57e0fd54:	e3500002 	cmp	r0, #2
57e0fd58:	1a000006 	bne	57e0fd78 <usb_string_sub+0x74>
			rc = usb_get_string(dev, langid, index, buf, buf[0]);
57e0fd5c:	e5d43000 	ldrb	r3, [r4]
57e0fd60:	e1a00007 	mov	r0, r7
57e0fd64:	e58d3000 	str	r3, [sp]
57e0fd68:	e1a01006 	mov	r1, r6
57e0fd6c:	e1a02005 	mov	r2, r5
57e0fd70:	e1a03004 	mov	r3, r4
57e0fd74:	ebffffc7 	bl	57e0fc98 <usb_get_string>
	}

	if (rc >= 2) {
57e0fd78:	e3500001 	cmp	r0, #1

		rc = rc - (rc & 1); /* force a multiple of two */
	}

	if (rc < 2)
		rc = -1;
57e0fd7c:	d3e00000 	mvnle	r0, #0
		rc = usb_get_string(dev, langid, index, buf, 2);
		if (rc == 2)
			rc = usb_get_string(dev, langid, index, buf, buf[0]);
	}

	if (rc >= 2) {
57e0fd80:	da00001d 	ble	57e0fdfc <usb_string_sub+0xf8>
		if (!buf[0] && !buf[1])
57e0fd84:	e5d43000 	ldrb	r3, [r4]
57e0fd88:	e3530000 	cmp	r3, #0
57e0fd8c:	1a000014 	bne	57e0fde4 <usb_string_sub+0xe0>
57e0fd90:	e5d43001 	ldrb	r3, [r4, #1]
57e0fd94:	e3530000 	cmp	r3, #0
57e0fd98:	1a000011 	bne	57e0fde4 <usb_string_sub+0xe0>
57e0fd9c:	e3a02003 	mov	r2, #3
57e0fda0:	e2833002 	add	r3, r3, #2
static void usb_try_string_workarounds(unsigned char *buf, int *length)
{
	int newlength, oldlength = *length;

	for (newlength = 2; newlength + 1 < oldlength; newlength += 2)
		if (!isprint(buf[newlength]) || buf[newlength + 1])
57e0fda4:	e59f1054 	ldr	r1, [pc, #84]	; 57e0fe00 <usb_string_sub+0xfc>
57e0fda8:	ea000008 	b	57e0fdd0 <usb_string_sub+0xcc>
57e0fdac:	e7d4c003 	ldrb	ip, [r4, r3]
57e0fdb0:	e7d1c00c 	ldrb	ip, [r1, ip]
57e0fdb4:	e31c0097 	tst	ip, #151	; 0x97
57e0fdb8:	0a000006 	beq	57e0fdd8 <usb_string_sub+0xd4>
57e0fdbc:	e7d4c002 	ldrb	ip, [r4, r2]
57e0fdc0:	e2822002 	add	r2, r2, #2
57e0fdc4:	e35c0000 	cmp	ip, #0
57e0fdc8:	1a000002 	bne	57e0fdd8 <usb_string_sub+0xd4>

static void usb_try_string_workarounds(unsigned char *buf, int *length)
{
	int newlength, oldlength = *length;

	for (newlength = 2; newlength + 1 < oldlength; newlength += 2)
57e0fdcc:	e2833002 	add	r3, r3, #2
57e0fdd0:	e1520000 	cmp	r2, r0
57e0fdd4:	bafffff4 	blt	57e0fdac <usb_string_sub+0xa8>
		if (!isprint(buf[newlength]) || buf[newlength + 1])
			break;

	if (newlength > 2) {
57e0fdd8:	e3530002 	cmp	r3, #2
		buf[0] = newlength;
57e0fddc:	15c43000 	strbne	r3, [r4]
57e0fde0:	11a00003 	movne	r0, r3
	if (rc >= 2) {
		if (!buf[0] && !buf[1])
			usb_try_string_workarounds(buf, &rc);

		/* There might be extra junk at the end of the descriptor */
		if (buf[0] < rc)
57e0fde4:	e5d43000 	ldrb	r3, [r4]
	for (newlength = 2; newlength + 1 < oldlength; newlength += 2)
		if (!isprint(buf[newlength]) || buf[newlength + 1])
			break;

	if (newlength > 2) {
		buf[0] = newlength;
57e0fde8:	e1500003 	cmp	r0, r3
57e0fdec:	a1a00003 	movge	r0, r3

		/* There might be extra junk at the end of the descriptor */
		if (buf[0] < rc)
			rc = buf[0];

		rc = rc - (rc & 1); /* force a multiple of two */
57e0fdf0:	e3c00001 	bic	r0, r0, #1
	}

	if (rc < 2)
		rc = -1;
57e0fdf4:	e3500001 	cmp	r0, #1
57e0fdf8:	d3e00000 	mvnle	r0, #0

	return rc;
}
57e0fdfc:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
57e0fe00:	57e2d4d0 	.word	0x57e2d4d0

57e0fe04 <usb_bulk_msg>:
 * synchronous behavior
 */
int usb_bulk_msg(struct usb_device *dev, unsigned int pipe,
			void *data, int len, int *actual_length, int timeout)
{
	if (len < 0)
57e0fe04:	e3530000 	cmp	r3, #0
 * -1 if Error.
 * synchronous behavior
 */
int usb_bulk_msg(struct usb_device *dev, unsigned int pipe,
			void *data, int len, int *actual_length, int timeout)
{
57e0fe08:	e92d4038 	push	{r3, r4, r5, lr}
57e0fe0c:	e1a04000 	mov	r4, r0
	if (len < 0)
		return -1;
57e0fe10:	b3e00000 	mvnlt	r0, #0
 * synchronous behavior
 */
int usb_bulk_msg(struct usb_device *dev, unsigned int pipe,
			void *data, int len, int *actual_length, int timeout)
{
	if (len < 0)
57e0fe14:	b8bd8038 	poplt	{r3, r4, r5, pc}
		return -1;
	dev->status = USB_ST_NOT_PROC; /*not yet processed */
57e0fe18:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
57e0fe1c:	e584c614 	str	ip, [r4, #1556]	; 0x614
	if (submit_bulk_msg(dev, pipe, data, len) < 0)
57e0fe20:	eb003915 	bl	57e1e27c <submit_bulk_msg>
57e0fe24:	e3500000 	cmp	r0, #0
57e0fe28:	a59d5014 	ldrge	r5, [sp, #20]
57e0fe2c:	aa000006 	bge	57e0fe4c <usb_bulk_msg+0x48>
57e0fe30:	ea00000e 	b	57e0fe70 <usb_bulk_msg+0x6c>
		return -1;
	while (timeout--) {
		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
57e0fe34:	e5943614 	ldr	r3, [r4, #1556]	; 0x614
			void *data, int len, int *actual_length, int timeout)
{
	if (len < 0)
		return -1;
	dev->status = USB_ST_NOT_PROC; /*not yet processed */
	if (submit_bulk_msg(dev, pipe, data, len) < 0)
57e0fe38:	e2455001 	sub	r5, r5, #1
		return -1;
	while (timeout--) {
		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
57e0fe3c:	e3530000 	cmp	r3, #0
57e0fe40:	aa000003 	bge	57e0fe54 <usb_bulk_msg+0x50>
			break;
		mdelay(1);
57e0fe44:	e3a00001 	mov	r0, #1
57e0fe48:	eb0051c6 	bl	57e24568 <mdelay>
	if (len < 0)
		return -1;
	dev->status = USB_ST_NOT_PROC; /*not yet processed */
	if (submit_bulk_msg(dev, pipe, data, len) < 0)
		return -1;
	while (timeout--) {
57e0fe4c:	e3550000 	cmp	r5, #0
57e0fe50:	1afffff7 	bne	57e0fe34 <usb_bulk_msg+0x30>
		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
			break;
		mdelay(1);
	}
	*actual_length = dev->act_len;
	if (dev->status == 0)
57e0fe54:	e5940614 	ldr	r0, [r4, #1556]	; 0x614
	while (timeout--) {
		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
			break;
		mdelay(1);
	}
	*actual_length = dev->act_len;
57e0fe58:	e5942618 	ldr	r2, [r4, #1560]	; 0x618
57e0fe5c:	e59d3010 	ldr	r3, [sp, #16]
	if (dev->status == 0)
		return 0;
57e0fe60:	e3500000 	cmp	r0, #0
	while (timeout--) {
		if (!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
			break;
		mdelay(1);
	}
	*actual_length = dev->act_len;
57e0fe64:	e5832000 	str	r2, [r3]
	if (dev->status == 0)
		return 0;
57e0fe68:	13e00000 	mvnne	r0, #0
57e0fe6c:	e8bd8038 	pop	{r3, r4, r5, pc}
{
	if (len < 0)
		return -1;
	dev->status = USB_ST_NOT_PROC; /*not yet processed */
	if (submit_bulk_msg(dev, pipe, data, len) < 0)
		return -1;
57e0fe70:	e3e00000 	mvn	r0, #0
	*actual_length = dev->act_len;
	if (dev->status == 0)
		return 0;
	else
		return -1;
}
57e0fe74:	e8bd8038 	pop	{r3, r4, r5, pc}

57e0fe78 <usb_maxpacket>:
 * the configurations values
 */
int usb_maxpacket(struct usb_device *dev, unsigned long pipe)
{
	/* direction is out -> use emaxpacket out */
	if ((pipe & USB_DIR_IN) == 0)
57e0fe78:	e3110080 	tst	r1, #128	; 0x80
57e0fe7c:	e1a017a1 	lsr	r1, r1, #15
		return dev->epmaxpacketout[((pipe>>15) & 0xf)];
57e0fe80:	0201100f 	andeq	r1, r1, #15
	else
		return dev->epmaxpacketin[((pipe>>15) & 0xf)];
57e0fe84:	1201100f 	andne	r1, r1, #15
 */
int usb_maxpacket(struct usb_device *dev, unsigned long pipe)
{
	/* direction is out -> use emaxpacket out */
	if ((pipe & USB_DIR_IN) == 0)
		return dev->epmaxpacketout[((pipe>>15) & 0xf)];
57e0fe88:	00800101 	addeq	r0, r0, r1, lsl #2
	else
		return dev->epmaxpacketin[((pipe>>15) & 0xf)];
57e0fe8c:	10800101 	addne	r0, r0, r1, lsl #2
 */
int usb_maxpacket(struct usb_device *dev, unsigned long pipe)
{
	/* direction is out -> use emaxpacket out */
	if ((pipe & USB_DIR_IN) == 0)
		return dev->epmaxpacketout[((pipe>>15) & 0xf)];
57e0fe90:	059000bc 	ldreq	r0, [r0, #188]	; 0xbc
	else
		return dev->epmaxpacketin[((pipe>>15) & 0xf)];
57e0fe94:	1590007c 	ldrne	r0, [r0, #124]	; 0x7c
}
57e0fe98:	e12fff1e 	bx	lr

57e0fe9c <usb_clear_halt>:
 * Clears an endpoint
 * endp: endpoint number in bits 0-3;
 * direction flag in bit 7 (1 = IN, 0 = OUT)
 */
int usb_clear_halt(struct usb_device *dev, int pipe)
{
57e0fe9c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int result;
	int endp = usb_pipeendpoint(pipe)|(usb_pipein(pipe)<<7);
57e0fea0:	e1a077c1 	asr	r7, r1, #15

	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e0fea4:	e5903068 	ldr	r3, [r0, #104]	; 0x68
 * direction flag in bit 7 (1 = IN, 0 = OUT)
 */
int usb_clear_halt(struct usb_device *dev, int pipe)
{
	int result;
	int endp = usb_pipeendpoint(pipe)|(usb_pipein(pipe)<<7);
57e0fea8:	e2016080 	and	r6, r1, #128	; 0x80
57e0feac:	e207700f 	and	r7, r7, #15

	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e0feb0:	e5901000 	ldr	r1, [r0]
 * Clears an endpoint
 * endp: endpoint number in bits 0-3;
 * direction flag in bit 7 (1 = IN, 0 = OUT)
 */
int usb_clear_halt(struct usb_device *dev, int pipe)
{
57e0feb4:	e24dd01c 	sub	sp, sp, #28
	int result;
	int endp = usb_pipeendpoint(pipe)|(usb_pipein(pipe)<<7);

	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e0feb8:	e1872006 	orr	r2, r7, r6
57e0febc:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
57e0fec0:	e58d2004 	str	r2, [sp, #4]
57e0fec4:	e3a02f4b 	mov	r2, #300	; 0x12c
57e0fec8:	e3a04000 	mov	r4, #0
57e0fecc:	e58d2010 	str	r2, [sp, #16]
57e0fed0:	e1831401 	orr	r1, r3, r1, lsl #8
57e0fed4:	e3a02001 	mov	r2, #1
57e0fed8:	e3a03002 	mov	r3, #2
 * Clears an endpoint
 * endp: endpoint number in bits 0-3;
 * direction flag in bit 7 (1 = IN, 0 = OUT)
 */
int usb_clear_halt(struct usb_device *dev, int pipe)
{
57e0fedc:	e1a05000 	mov	r5, r0
	int result;
	int endp = usb_pipeendpoint(pipe)|(usb_pipein(pipe)<<7);

	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e0fee0:	e58d4000 	str	r4, [sp]
57e0fee4:	e58d4008 	str	r4, [sp, #8]
57e0fee8:	e58d400c 	str	r4, [sp, #12]
57e0feec:	ebffff1a 	bl	57e0fb5c <usb_control_msg>
				 USB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT, 0,
				 endp, NULL, 0, USB_CNTL_TIMEOUT * 3);

	/* don't clear if failed */
	if (result < 0)
57e0fef0:	e3500000 	cmp	r0, #0
57e0fef4:	ba000010 	blt	57e0ff3c <usb_clear_halt+0xa0>
	/*
	 * NOTE: we do not get status and verify reset was successful
	 * as some devices are reported to lock up upon this check..
	 */

	usb_endpoint_running(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe));
57e0fef8:	e3a03001 	mov	r3, #1
57e0fefc:	e1e07713 	mvn	r7, r3, lsl r7
57e0ff00:	e1560004 	cmp	r6, r4
57e0ff04:	03a03074 	moveq	r3, #116	; 0x74
57e0ff08:	13a03070 	movne	r3, #112	; 0x70
57e0ff0c:	e0853003 	add	r3, r5, r3
57e0ff10:	e5932004 	ldr	r2, [r3, #4]

	/* toggle is reset on clear */
	usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe), 0);
57e0ff14:	e1560004 	cmp	r6, r4
57e0ff18:	13a06068 	movne	r6, #104	; 0x68
57e0ff1c:	03a0606c 	moveq	r6, #108	; 0x6c
	/*
	 * NOTE: we do not get status and verify reset was successful
	 * as some devices are reported to lock up upon this check..
	 */

	usb_endpoint_running(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe));
57e0ff20:	e0072002 	and	r2, r7, r2

	/* toggle is reset on clear */
	usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe), 0);
57e0ff24:	e0855006 	add	r5, r5, r6
	/*
	 * NOTE: we do not get status and verify reset was successful
	 * as some devices are reported to lock up upon this check..
	 */

	usb_endpoint_running(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe));
57e0ff28:	e5832004 	str	r2, [r3, #4]

	/* toggle is reset on clear */
	usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe), 0);
57e0ff2c:	e5953004 	ldr	r3, [r5, #4]
	return 0;
57e0ff30:	e1a00004 	mov	r0, r4
	 */

	usb_endpoint_running(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe));

	/* toggle is reset on clear */
	usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe), 0);
57e0ff34:	e0077003 	and	r7, r7, r3
57e0ff38:	e5857004 	str	r7, [r5, #4]
	return 0;
}
57e0ff3c:	e28dd01c 	add	sp, sp, #28
57e0ff40:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

57e0ff44 <usb_get_configuration_no>:
/**********************************************************************
 * gets configuration cfgno and store it in the buffer
 */
int usb_get_configuration_no(struct usb_device *dev,
			     unsigned char *buffer, int cfgno)
{
57e0ff44:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
57e0ff48:	e1a04001 	mov	r4, r1
	int result;
	unsigned int tmp;
	struct usb_config_descriptor *config;

	config = (struct usb_config_descriptor *)&buffer[0];
	result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno, buffer, 9);
57e0ff4c:	e20270ff 	and	r7, r2, #255	; 0xff
57e0ff50:	e1a02007 	mov	r2, r7
57e0ff54:	e3a06009 	mov	r6, #9
57e0ff58:	e3a01002 	mov	r1, #2
57e0ff5c:	e1a03004 	mov	r3, r4
/**********************************************************************
 * gets configuration cfgno and store it in the buffer
 */
int usb_get_configuration_no(struct usb_device *dev,
			     unsigned char *buffer, int cfgno)
{
57e0ff60:	e1a05000 	mov	r5, r0
	int result;
	unsigned int tmp;
	struct usb_config_descriptor *config;

	config = (struct usb_config_descriptor *)&buffer[0];
	result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno, buffer, 9);
57e0ff64:	e58d6000 	str	r6, [sp]
57e0ff68:	ebffff32 	bl	57e0fc38 <usb_get_descriptor>
	if (result < 9) {
57e0ff6c:	e3500008 	cmp	r0, #8
	int result;
	unsigned int tmp;
	struct usb_config_descriptor *config;

	config = (struct usb_config_descriptor *)&buffer[0];
	result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno, buffer, 9);
57e0ff70:	e1a02000 	mov	r2, r0
	if (result < 9) {
57e0ff74:	ca000008 	bgt	57e0ff9c <usb_get_configuration_no+0x58>
		if (result < 0)
57e0ff78:	e3500000 	cmp	r0, #0
			printf("unable to get descriptor, error %lX\n",
57e0ff7c:	b59f0054 	ldrlt	r0, [pc, #84]	; 57e0ffd8 <usb_get_configuration_no+0x94>
57e0ff80:	b5951614 	ldrlt	r1, [r5, #1556]	; 0x614
	struct usb_config_descriptor *config;

	config = (struct usb_config_descriptor *)&buffer[0];
	result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno, buffer, 9);
	if (result < 9) {
		if (result < 0)
57e0ff84:	ba00000a 	blt	57e0ffb4 <usb_get_configuration_no+0x70>
			printf("unable to get descriptor, error %lX\n",
				dev->status);
		else
			printf("config descriptor too short " \
57e0ff88:	e59f004c 	ldr	r0, [pc, #76]	; 57e0ffdc <usb_get_configuration_no+0x98>
57e0ff8c:	e1a01006 	mov	r1, r6
57e0ff90:	ebffe52d 	bl	57e0944c <printf>
				"(expected %i, got %i)\n", 9, result);
		return -1;
57e0ff94:	e3e00000 	mvn	r0, #0
57e0ff98:	ea00000d 	b	57e0ffd4 <usb_get_configuration_no+0x90>
	}
	tmp = le16_to_cpu(config->wTotalLength);
57e0ff9c:	e5d43002 	ldrb	r3, [r4, #2]
57e0ffa0:	e5d41003 	ldrb	r1, [r4, #3]
57e0ffa4:	e1831401 	orr	r1, r3, r1, lsl #8

	if (tmp > USB_BUFSIZ) {
57e0ffa8:	e3510c02 	cmp	r1, #512	; 0x200
57e0ffac:	9a000002 	bls	57e0ffbc <usb_get_configuration_no+0x78>
		printf("usb_get_configuration_no: failed to get " \
57e0ffb0:	e59f0028 	ldr	r0, [pc, #40]	; 57e0ffe0 <usb_get_configuration_no+0x9c>
57e0ffb4:	ebffe524 	bl	57e0944c <printf>
57e0ffb8:	eafffff5 	b	57e0ff94 <usb_get_configuration_no+0x50>
		       "descriptor - too long: %d\n", tmp);
		return -1;
	}

	result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno, buffer, tmp);
57e0ffbc:	e58d1000 	str	r1, [sp]
57e0ffc0:	e1a00005 	mov	r0, r5
57e0ffc4:	e3a01002 	mov	r1, #2
57e0ffc8:	e1a02007 	mov	r2, r7
57e0ffcc:	e1a03004 	mov	r3, r4
57e0ffd0:	ebffff18 	bl	57e0fc38 <usb_get_descriptor>
	USB_PRINTF("get_conf_no %d Result %d, wLength %d\n",
		   cfgno, result, tmp);
	return result;
}
57e0ffd4:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
57e0ffd8:	57e32abc 	.word	0x57e32abc
57e0ffdc:	57e32ae1 	.word	0x57e32ae1
57e0ffe0:	57e32b14 	.word	0x57e32b14

57e0ffe4 <usb_set_interface>:

/********************************************************************
 * set interface number to interface
 */
int usb_set_interface(struct usb_device *dev, int interface, int alternate)
{
57e0ffe4:	e92d4030 	push	{r4, r5, lr}
	struct usb_interface *if_face = NULL;
	int ret, i;

	for (i = 0; i < dev->config.desc.bNumInterfaces; i++) {
57e0ffe8:	e1a0c000 	mov	ip, r0

/********************************************************************
 * set interface number to interface
 */
int usb_set_interface(struct usb_device *dev, int interface, int alternate)
{
57e0ffec:	e24dd01c 	sub	sp, sp, #28
	struct usb_interface *if_face = NULL;
	int ret, i;

	for (i = 0; i < dev->config.desc.bNumInterfaces; i++) {
57e0fff0:	e5d04116 	ldrb	r4, [r0, #278]	; 0x116
57e0fff4:	e3a03000 	mov	r3, #0
57e0fff8:	ea00000a 	b	57e10028 <usb_set_interface+0x44>
		if (dev->config.if_desc[i].desc.bInterfaceNumber == interface) {
57e0fffc:	e5dc511e 	ldrb	r5, [ip, #286]	; 0x11e
57e10000:	e28cc09c 	add	ip, ip, #156	; 0x9c
57e10004:	e1550001 	cmp	r5, r1
57e10008:	1a000005 	bne	57e10024 <usb_set_interface+0x40>
	 * According to 9.4.10 of the Universal Serial Bus Specification
	 * Revision 2.0 such devices can return with a STALL. This results in
	 * some USB sticks timeouting during initialization and then being
	 * unusable in U-Boot.
	 */
	if (if_face->num_altsetting == 1)
57e1000c:	e3a0c09c 	mov	ip, #156	; 0x9c
57e10010:	e023039c 	mla	r3, ip, r3, r0
57e10014:	e5d33126 	ldrb	r3, [r3, #294]	; 0x126
57e10018:	e3530001 	cmp	r3, #1
57e1001c:	1a000007 	bne	57e10040 <usb_set_interface+0x5c>
57e10020:	ea00001a 	b	57e10090 <usb_set_interface+0xac>
int usb_set_interface(struct usb_device *dev, int interface, int alternate)
{
	struct usb_interface *if_face = NULL;
	int ret, i;

	for (i = 0; i < dev->config.desc.bNumInterfaces; i++) {
57e10024:	e2833001 	add	r3, r3, #1
57e10028:	e1530004 	cmp	r3, r4
57e1002c:	bafffff2 	blt	57e0fffc <usb_set_interface+0x18>
			if_face = &dev->config.if_desc[i];
			break;
		}
	}
	if (!if_face) {
		printf("selecting invalid interface %d", interface);
57e10030:	e59f0064 	ldr	r0, [pc, #100]	; 57e1009c <usb_set_interface+0xb8>
57e10034:	ebffe504 	bl	57e0944c <printf>
		return -1;
57e10038:	e3e00000 	mvn	r0, #0
57e1003c:	ea000014 	b	57e10094 <usb_set_interface+0xb0>
	 * unusable in U-Boot.
	 */
	if (if_face->num_altsetting == 1)
		return 0;

	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e10040:	e1a02802 	lsl	r2, r2, #16
57e10044:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e10048:	e1a02822 	lsr	r2, r2, #16
57e1004c:	e590c000 	ldr	ip, [r0]
57e10050:	e1a01801 	lsl	r1, r1, #16
57e10054:	e58d2000 	str	r2, [sp]
57e10058:	e3a02000 	mov	r2, #0
57e1005c:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
57e10060:	e1a01821 	lsr	r1, r1, #16
57e10064:	e58d2008 	str	r2, [sp, #8]
57e10068:	e58d200c 	str	r2, [sp, #12]
57e1006c:	e2822f7d 	add	r2, r2, #500	; 0x1f4
57e10070:	e58d1004 	str	r1, [sp, #4]
57e10074:	e58d2010 	str	r2, [sp, #16]
57e10078:	e183140c 	orr	r1, r3, ip, lsl #8
57e1007c:	e3a0200b 	mov	r2, #11
57e10080:	e3a03001 	mov	r3, #1
57e10084:	ebfffeb4 	bl	57e0fb5c <usb_control_msg>
57e10088:	e0000fc0 	and	r0, r0, r0, asr #31
57e1008c:	ea000000 	b	57e10094 <usb_set_interface+0xb0>
	 * Revision 2.0 such devices can return with a STALL. This results in
	 * some USB sticks timeouting during initialization and then being
	 * unusable in U-Boot.
	 */
	if (if_face->num_altsetting == 1)
		return 0;
57e10090:	e3a00000 	mov	r0, #0
				USB_CNTL_TIMEOUT * 5);
	if (ret < 0)
		return ret;

	return 0;
}
57e10094:	e28dd01c 	add	sp, sp, #28
57e10098:	e8bd8030 	pop	{r4, r5, pc}
57e1009c:	57e32b57 	.word	0x57e32b57

57e100a0 <usb_set_protocol>:

/********************************************************************
 * set protocol to protocol
 */
int usb_set_protocol(struct usb_device *dev, int ifnum, int protocol)
{
57e100a0:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e100a4:	e1a02802 	lsl	r2, r2, #16
57e100a8:	e590c068 	ldr	ip, [r0, #104]	; 0x68
57e100ac:	e1a02822 	lsr	r2, r2, #16
57e100b0:	e5903000 	ldr	r3, [r0]
57e100b4:	e1a01801 	lsl	r1, r1, #16
57e100b8:	e58d2000 	str	r2, [sp]
57e100bc:	e3a02000 	mov	r2, #0
57e100c0:	e38cc102 	orr	ip, ip, #-2147483648	; 0x80000000
57e100c4:	e1a01821 	lsr	r1, r1, #16
57e100c8:	e58d2008 	str	r2, [sp, #8]
57e100cc:	e58d200c 	str	r2, [sp, #12]
57e100d0:	e2822064 	add	r2, r2, #100	; 0x64
57e100d4:	e58d1004 	str	r1, [sp, #4]
57e100d8:	e58d2010 	str	r2, [sp, #16]
57e100dc:	e18c1403 	orr	r1, ip, r3, lsl #8
57e100e0:	e3a0200b 	mov	r2, #11
57e100e4:	e3a03021 	mov	r3, #33	; 0x21
57e100e8:	ebfffe9b 	bl	57e0fb5c <usb_control_msg>
		USB_REQ_SET_PROTOCOL, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
		protocol, ifnum, NULL, 0, USB_CNTL_TIMEOUT);
}
57e100ec:	e28dd01c 	add	sp, sp, #28
57e100f0:	e8bd8000 	pop	{pc}

57e100f4 <usb_set_idle>:

/********************************************************************
 * set idle
 */
int usb_set_idle(struct usb_device *dev, int ifnum, int duration, int report_id)
{
57e100f4:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e100f8:	e1833402 	orr	r3, r3, r2, lsl #8
57e100fc:	e1a03803 	lsl	r3, r3, #16
57e10100:	e590e068 	ldr	lr, [r0, #104]	; 0x68
57e10104:	e1a03823 	lsr	r3, r3, #16
57e10108:	e590c000 	ldr	ip, [r0]
57e1010c:	e1a01801 	lsl	r1, r1, #16
57e10110:	e58d3000 	str	r3, [sp]
57e10114:	e3a03000 	mov	r3, #0
57e10118:	e38ee102 	orr	lr, lr, #-2147483648	; 0x80000000
57e1011c:	e1a01821 	lsr	r1, r1, #16
57e10120:	e58d3008 	str	r3, [sp, #8]
57e10124:	e58d300c 	str	r3, [sp, #12]
57e10128:	e2833064 	add	r3, r3, #100	; 0x64
57e1012c:	e58d1004 	str	r1, [sp, #4]
57e10130:	e58d3010 	str	r3, [sp, #16]
57e10134:	e18e140c 	orr	r1, lr, ip, lsl #8
57e10138:	e3a0200a 	mov	r2, #10
57e1013c:	e3a03021 	mov	r3, #33	; 0x21
57e10140:	ebfffe85 	bl	57e0fb5c <usb_control_msg>
		USB_REQ_SET_IDLE, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
		(duration << 8) | report_id, ifnum, NULL, 0, USB_CNTL_TIMEOUT);
}
57e10144:	e28dd01c 	add	sp, sp, #28
57e10148:	e8bd8000 	pop	{pc}

57e1014c <usb_get_report>:
/********************************************************************
 * get report
 */
int usb_get_report(struct usb_device *dev, int ifnum, unsigned char type,
		   unsigned char id, void *buf, int size)
{
57e1014c:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
57e10150:	e0833402 	add	r3, r3, r2, lsl #8
57e10154:	e1a03803 	lsl	r3, r3, #16
57e10158:	e1a03823 	lsr	r3, r3, #16
57e1015c:	e590c000 	ldr	ip, [r0]
57e10160:	e590e068 	ldr	lr, [r0, #104]	; 0x68
57e10164:	e58d3000 	str	r3, [sp]
57e10168:	e59d3020 	ldr	r3, [sp, #32]
57e1016c:	e38ee102 	orr	lr, lr, #-2147483648	; 0x80000000
57e10170:	e58d3008 	str	r3, [sp, #8]
57e10174:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e10178:	e1a01801 	lsl	r1, r1, #16
57e1017c:	e1a03803 	lsl	r3, r3, #16
57e10180:	e1a03823 	lsr	r3, r3, #16
57e10184:	e38ee080 	orr	lr, lr, #128	; 0x80
57e10188:	e1a01821 	lsr	r1, r1, #16
57e1018c:	e58d300c 	str	r3, [sp, #12]
57e10190:	e3a03064 	mov	r3, #100	; 0x64
57e10194:	e58d1004 	str	r1, [sp, #4]
57e10198:	e58d3010 	str	r3, [sp, #16]
57e1019c:	e18e140c 	orr	r1, lr, ip, lsl #8
57e101a0:	e3a02001 	mov	r2, #1
57e101a4:	e283303d 	add	r3, r3, #61	; 0x3d
57e101a8:	ebfffe6b 	bl	57e0fb5c <usb_control_msg>
			USB_REQ_GET_REPORT,
			USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
			(type << 8) + id, ifnum, buf, size, USB_CNTL_TIMEOUT);
}
57e101ac:	e28dd01c 	add	sp, sp, #28
57e101b0:	e8bd8000 	pop	{pc}

57e101b4 <usb_get_class_descriptor>:
/********************************************************************
 * get class descriptor
 */
int usb_get_class_descriptor(struct usb_device *dev, int ifnum,
		unsigned char type, unsigned char id, void *buf, int size)
{
57e101b4:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
57e101b8:	e0833402 	add	r3, r3, r2, lsl #8
57e101bc:	e1a03803 	lsl	r3, r3, #16
57e101c0:	e1a03823 	lsr	r3, r3, #16
57e101c4:	e590c000 	ldr	ip, [r0]
57e101c8:	e590e068 	ldr	lr, [r0, #104]	; 0x68
57e101cc:	e58d3000 	str	r3, [sp]
57e101d0:	e59d3020 	ldr	r3, [sp, #32]
57e101d4:	e38ee102 	orr	lr, lr, #-2147483648	; 0x80000000
57e101d8:	e58d3008 	str	r3, [sp, #8]
57e101dc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e101e0:	e1a01801 	lsl	r1, r1, #16
57e101e4:	e1a03803 	lsl	r3, r3, #16
57e101e8:	e1a03823 	lsr	r3, r3, #16
57e101ec:	e38ee080 	orr	lr, lr, #128	; 0x80
57e101f0:	e1a01821 	lsr	r1, r1, #16
57e101f4:	e58d300c 	str	r3, [sp, #12]
57e101f8:	e3a03064 	mov	r3, #100	; 0x64
57e101fc:	e58d1004 	str	r1, [sp, #4]
57e10200:	e58d3010 	str	r3, [sp, #16]
57e10204:	e18e140c 	orr	r1, lr, ip, lsl #8
57e10208:	e3a02006 	mov	r2, #6
57e1020c:	e283301d 	add	r3, r3, #29
57e10210:	ebfffe51 	bl	57e0fb5c <usb_control_msg>
		USB_REQ_GET_DESCRIPTOR, USB_RECIP_INTERFACE | USB_DIR_IN,
		(type << 8) + id, ifnum, buf, size, USB_CNTL_TIMEOUT);
}
57e10214:	e28dd01c 	add	sp, sp, #28
57e10218:	e8bd8000 	pop	{pc}

57e1021c <usb_string>:
 * usb_string:
 * Get string index and translate it to ascii.
 * returns string length (> 0) or error (< 0)
 */
int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
{
57e1021c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, mybuf, USB_BUFSIZ);
	unsigned char *tbuf;
	int err;
	unsigned int u, idx;

	if (size <= 0 || !buf || !index)
57e10220:	e3520000 	cmp	r2, #0
57e10224:	13530000 	cmpne	r3, #0
57e10228:	e1a0a003 	mov	sl, r3
 * usb_string:
 * Get string index and translate it to ascii.
 * returns string length (> 0) or error (< 0)
 */
int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
{
57e1022c:	e24ddd09 	sub	sp, sp, #576	; 0x240
57e10230:	e1a06000 	mov	r6, r0
57e10234:	e1a07001 	mov	r7, r1
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, mybuf, USB_BUFSIZ);
	unsigned char *tbuf;
	int err;
	unsigned int u, idx;

	if (size <= 0 || !buf || !index)
57e10238:	e1a05002 	mov	r5, r2
57e1023c:	13a03000 	movne	r3, #0
57e10240:	03a03001 	moveq	r3, #1
57e10244:	0a000031 	beq	57e10310 <usb_string+0xf4>
57e10248:	e3510000 	cmp	r1, #0
57e1024c:	0a00002f 	beq	57e10310 <usb_string+0xf4>
		return -1;
	buf[0] = 0;
57e10250:	e5c23000 	strb	r3, [r2]
	tbuf = &mybuf[0];

	/* get langid for strings if it's not yet known */
	if (!dev->have_langid) {
57e10254:	e59015fc 	ldr	r1, [r0, #1532]	; 0x5fc
 * Get string index and translate it to ascii.
 * returns string length (> 0) or error (< 0)
 */
int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, mybuf, USB_BUFSIZ);
57e10258:	e28d403f 	add	r4, sp, #63	; 0x3f
		return -1;
	buf[0] = 0;
	tbuf = &mybuf[0];

	/* get langid for strings if it's not yet known */
	if (!dev->have_langid) {
57e1025c:	e3510000 	cmp	r1, #0
 * Get string index and translate it to ascii.
 * returns string length (> 0) or error (< 0)
 */
int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, mybuf, USB_BUFSIZ);
57e10260:	e3c4403f 	bic	r4, r4, #63	; 0x3f
		return -1;
	buf[0] = 0;
	tbuf = &mybuf[0];

	/* get langid for strings if it's not yet known */
	if (!dev->have_langid) {
57e10264:	1a00000d 	bne	57e102a0 <usb_string+0x84>
		err = usb_string_sub(dev, 0, 0, tbuf);
57e10268:	e1a02001 	mov	r2, r1
57e1026c:	e1a03004 	mov	r3, r4
57e10270:	ebfffea3 	bl	57e0fd04 <usb_string_sub>
		if (err < 0) {
57e10274:	e3500000 	cmp	r0, #0
57e10278:	ba000024 	blt	57e10310 <usb_string+0xf4>
			USB_PRINTF("error getting string descriptor 0 " \
				   "(error=%lx)\n", dev->status);
			return -1;
		} else if (tbuf[0] < 4) {
57e1027c:	e5d43000 	ldrb	r3, [r4]
57e10280:	e3530003 	cmp	r3, #3
57e10284:	9a000021 	bls	57e10310 <usb_string+0xf4>
			USB_PRINTF("string descriptor 0 too short\n");
			return -1;
		} else {
			dev->have_langid = -1;
57e10288:	e3e03000 	mvn	r3, #0
57e1028c:	e58635fc 	str	r3, [r6, #1532]	; 0x5fc
			dev->string_langid = tbuf[2] | (tbuf[3] << 8);
57e10290:	e5d42003 	ldrb	r2, [r4, #3]
57e10294:	e5d43002 	ldrb	r3, [r4, #2]
57e10298:	e1833402 	orr	r3, r3, r2, lsl #8
57e1029c:	e5863600 	str	r3, [r6, #1536]	; 0x600
				   "language ID 0x%x\n",
				   dev->devnum, dev->string_langid);
		}
	}

	err = usb_string_sub(dev, dev->string_langid, index, tbuf);
57e102a0:	e1a00006 	mov	r0, r6
57e102a4:	e5961600 	ldr	r1, [r6, #1536]	; 0x600
57e102a8:	e1a02007 	mov	r2, r7
57e102ac:	e1a03004 	mov	r3, r4
57e102b0:	ebfffe93 	bl	57e0fd04 <usb_string_sub>
	if (err < 0)
57e102b4:	e3500000 	cmp	r0, #0
57e102b8:	ba000015 	blt	57e10314 <usb_string+0xf8>
		return err;

	size--;		/* leave room for trailing NULL char in output buffer */
57e102bc:	e24aa001 	sub	sl, sl, #1
	for (idx = 0, u = 2; u < err; u += 2) {
57e102c0:	e3a02001 	mov	r2, #1
57e102c4:	e3a03000 	mov	r3, #0
		if (idx >= size)
			break;
		if (tbuf[u+1])			/* high byte */
			buf[idx++] = '?';  /* non-ASCII character */
57e102c8:	e3a0103f 	mov	r1, #63	; 0x3f
	err = usb_string_sub(dev, dev->string_langid, index, tbuf);
	if (err < 0)
		return err;

	size--;		/* leave room for trailing NULL char in output buffer */
	for (idx = 0, u = 2; u < err; u += 2) {
57e102cc:	ea000009 	b	57e102f8 <usb_string+0xdc>
		if (idx >= size)
57e102d0:	e153000a 	cmp	r3, sl
57e102d4:	2a000009 	bcs	57e10300 <usb_string+0xe4>
			break;
		if (tbuf[u+1])			/* high byte */
57e102d8:	e5d4c003 	ldrb	ip, [r4, #3]
			buf[idx++] = '?';  /* non-ASCII character */
		else
			buf[idx++] = tbuf[u];
57e102dc:	e2822001 	add	r2, r2, #1

	size--;		/* leave room for trailing NULL char in output buffer */
	for (idx = 0, u = 2; u < err; u += 2) {
		if (idx >= size)
			break;
		if (tbuf[u+1])			/* high byte */
57e102e0:	e35c0000 	cmp	ip, #0
			buf[idx++] = '?';  /* non-ASCII character */
		else
			buf[idx++] = tbuf[u];
57e102e4:	05d4c002 	ldrbeq	ip, [r4, #2]
	size--;		/* leave room for trailing NULL char in output buffer */
	for (idx = 0, u = 2; u < err; u += 2) {
		if (idx >= size)
			break;
		if (tbuf[u+1])			/* high byte */
			buf[idx++] = '?';  /* non-ASCII character */
57e102e8:	17c51003 	strbne	r1, [r5, r3]
		else
			buf[idx++] = tbuf[u];
57e102ec:	07c5c003 	strbeq	ip, [r5, r3]
57e102f0:	e2844002 	add	r4, r4, #2
57e102f4:	e2833001 	add	r3, r3, #1
	err = usb_string_sub(dev, dev->string_langid, index, tbuf);
	if (err < 0)
		return err;

	size--;		/* leave room for trailing NULL char in output buffer */
	for (idx = 0, u = 2; u < err; u += 2) {
57e102f8:	e1500082 	cmp	r0, r2, lsl #1
57e102fc:	8afffff3 	bhi	57e102d0 <usb_string+0xb4>
		if (tbuf[u+1])			/* high byte */
			buf[idx++] = '?';  /* non-ASCII character */
		else
			buf[idx++] = tbuf[u];
	}
	buf[idx] = 0;
57e10300:	e3a02000 	mov	r2, #0
57e10304:	e7c52003 	strb	r2, [r5, r3]
	err = idx;
57e10308:	e1a00003 	mov	r0, r3
	return err;
57e1030c:	ea000000 	b	57e10314 <usb_string+0xf8>
			USB_PRINTF("error getting string descriptor 0 " \
				   "(error=%lx)\n", dev->status);
			return -1;
		} else if (tbuf[0] < 4) {
			USB_PRINTF("string descriptor 0 too short\n");
			return -1;
57e10310:	e3e00000 	mvn	r0, #0
			buf[idx++] = tbuf[u];
	}
	buf[idx] = 0;
	err = idx;
	return err;
}
57e10314:	e28ddd09 	add	sp, sp, #576	; 0x240
57e10318:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

57e1031c <usb_get_dev_index>:
/* returns a pointer to the device with the index [index].
 * if the device is not assigned (dev->devnum==-1) returns NULL
 */
struct usb_device *usb_get_dev_index(int index)
{
	if (usb_dev[index].devnum == -1)
57e1031c:	e3a02d1a 	mov	r2, #1664	; 0x680
57e10320:	e0020290 	mul	r2, r0, r2
57e10324:	e59f3018 	ldr	r3, [pc, #24]	; 57e10344 <usb_get_dev_index+0x28>
57e10328:	e0831002 	add	r1, r3, r2
57e1032c:	e5911040 	ldr	r1, [r1, #64]	; 0x40
57e10330:	e3710001 	cmn	r1, #1
		return NULL;
	else
		return &usb_dev[index];
57e10334:	12833040 	addne	r3, r3, #64	; 0x40
57e10338:	10830002 	addne	r0, r3, r2
 * if the device is not assigned (dev->devnum==-1) returns NULL
 */
struct usb_device *usb_get_dev_index(int index)
{
	if (usb_dev[index].devnum == -1)
		return NULL;
57e1033c:	03a00000 	moveq	r0, #0
	else
		return &usb_dev[index];
}
57e10340:	e12fff1e 	bx	lr
57e10344:	57e39c40 	.word	0x57e39c40

57e10348 <usb_alloc_new_device>:

/* returns a pointer of a new device structure or NULL, if
 * no device struct is available
 */
struct usb_device *usb_alloc_new_device(void *controller)
{
57e10348:	e92d4070 	push	{r4, r5, r6, lr}
	int i;
	USB_PRINTF("New Device %d\n", dev_index);
	if (dev_index == USB_MAX_DEVICE) {
57e1034c:	e59f5078 	ldr	r5, [pc, #120]	; 57e103cc <usb_alloc_new_device+0x84>
57e10350:	e5151f88 	ldr	r1, [r5, #-3976]	; 0xf88
57e10354:	e3510020 	cmp	r1, #32
57e10358:	1a000003 	bne	57e1036c <usb_alloc_new_device+0x24>
		printf("ERROR, too many USB Devices, max=%d\n", USB_MAX_DEVICE);
57e1035c:	e59f006c 	ldr	r0, [pc, #108]	; 57e103d0 <usb_alloc_new_device+0x88>
57e10360:	ebffe439 	bl	57e0944c <printf>
		return NULL;
57e10364:	e3a00000 	mov	r0, #0
57e10368:	e8bd8070 	pop	{r4, r5, r6, pc}
	}
	/* default Address is 0, real addresses start with 1 */
	usb_dev[dev_index].devnum = dev_index + 1;
57e1036c:	e3a03d1a 	mov	r3, #1664	; 0x680
57e10370:	e2816001 	add	r6, r1, #1
57e10374:	e0010193 	mul	r1, r3, r1
57e10378:	e59f4054 	ldr	r4, [pc, #84]	; 57e103d4 <usb_alloc_new_device+0x8c>
	usb_dev[dev_index].maxchild = 0;
57e1037c:	e3a02000 	mov	r2, #0
	if (dev_index == USB_MAX_DEVICE) {
		printf("ERROR, too many USB Devices, max=%d\n", USB_MAX_DEVICE);
		return NULL;
	}
	/* default Address is 0, real addresses start with 1 */
	usb_dev[dev_index].devnum = dev_index + 1;
57e10380:	e0843001 	add	r3, r4, r1
	usb_dev[dev_index].maxchild = 0;
57e10384:	e283ce65 	add	ip, r3, #1616	; 0x650
57e10388:	e28cc008 	add	ip, ip, #8
	for (i = 0; i < USB_MAXCHILDREN; i++)
		usb_dev[dev_index].children[i] = NULL;
	usb_dev[dev_index].parent = NULL;
	usb_dev[dev_index].controller = controller;
57e1038c:	e5830688 	str	r0, [r3, #1672]	; 0x688
	dev_index++;
	return &usb_dev[dev_index - 1];
57e10390:	e2840040 	add	r0, r4, #64	; 0x40
	if (dev_index == USB_MAX_DEVICE) {
		printf("ERROR, too many USB Devices, max=%d\n", USB_MAX_DEVICE);
		return NULL;
	}
	/* default Address is 0, real addresses start with 1 */
	usb_dev[dev_index].devnum = dev_index + 1;
57e10394:	e5836040 	str	r6, [r3, #64]	; 0x40
	usb_dev[dev_index].maxchild = 0;
57e10398:	e58c2004 	str	r2, [ip, #4]
	for (i = 0; i < USB_MAXCHILDREN; i++)
		usb_dev[dev_index].children[i] = NULL;
57e1039c:	e5832668 	str	r2, [r3, #1640]	; 0x668
57e103a0:	e583266c 	str	r2, [r3, #1644]	; 0x66c
57e103a4:	e5832670 	str	r2, [r3, #1648]	; 0x670
57e103a8:	e5832674 	str	r2, [r3, #1652]	; 0x674
57e103ac:	e5832678 	str	r2, [r3, #1656]	; 0x678
57e103b0:	e583267c 	str	r2, [r3, #1660]	; 0x67c
57e103b4:	e5832680 	str	r2, [r3, #1664]	; 0x680
57e103b8:	e5832684 	str	r2, [r3, #1668]	; 0x684
	usb_dev[dev_index].parent = NULL;
57e103bc:	e5832664 	str	r2, [r3, #1636]	; 0x664
	usb_dev[dev_index].controller = controller;
	dev_index++;
57e103c0:	e5056f88 	str	r6, [r5, #-3976]	; 0xf88
	return &usb_dev[dev_index - 1];
57e103c4:	e0800001 	add	r0, r0, r1
}
57e103c8:	e8bd8070 	pop	{r4, r5, r6, pc}
57e103cc:	57e47c08 	.word	0x57e47c08
57e103d0:	57e32b76 	.word	0x57e32b76
57e103d4:	57e39c40 	.word	0x57e39c40

57e103d8 <usb_free_device>:
 * Free the newly created device node.
 * Called in error cases where configuring a newly attached
 * device fails for some reason.
 */
void usb_free_device(void)
{
57e103d8:	e92d4070 	push	{r4, r5, r6, lr}
	dev_index--;
57e103dc:	e59f5038 	ldr	r5, [pc, #56]	; 57e1041c <usb_free_device+0x44>
	USB_PRINTF("Freeing device node: %d\n", dev_index);
	memset(&usb_dev[dev_index], 0, sizeof(struct usb_device));
57e103e0:	e59f6038 	ldr	r6, [pc, #56]	; 57e10420 <usb_free_device+0x48>
 * Called in error cases where configuring a newly attached
 * device fails for some reason.
 */
void usb_free_device(void)
{
	dev_index--;
57e103e4:	e5153f88 	ldr	r3, [r5, #-3976]	; 0xf88
	USB_PRINTF("Freeing device node: %d\n", dev_index);
	memset(&usb_dev[dev_index], 0, sizeof(struct usb_device));
57e103e8:	e3a04d1a 	mov	r4, #1664	; 0x680
 * Called in error cases where configuring a newly attached
 * device fails for some reason.
 */
void usb_free_device(void)
{
	dev_index--;
57e103ec:	e2433001 	sub	r3, r3, #1
	USB_PRINTF("Freeing device node: %d\n", dev_index);
	memset(&usb_dev[dev_index], 0, sizeof(struct usb_device));
57e103f0:	e2860040 	add	r0, r6, #64	; 0x40
57e103f4:	e0200394 	mla	r0, r4, r3, r0
57e103f8:	e1a02004 	mov	r2, r4
57e103fc:	e3a01000 	mov	r1, #0
 * Called in error cases where configuring a newly attached
 * device fails for some reason.
 */
void usb_free_device(void)
{
	dev_index--;
57e10400:	e5053f88 	str	r3, [r5, #-3976]	; 0xf88
	USB_PRINTF("Freeing device node: %d\n", dev_index);
	memset(&usb_dev[dev_index], 0, sizeof(struct usb_device));
57e10404:	eb004f9c 	bl	57e2427c <memset>
	usb_dev[dev_index].devnum = -1;
57e10408:	e5153f88 	ldr	r3, [r5, #-3976]	; 0xf88
57e1040c:	e0246493 	mla	r4, r3, r4, r6
57e10410:	e3e03000 	mvn	r3, #0
57e10414:	e5843040 	str	r3, [r4, #64]	; 0x40
}
57e10418:	e8bd8070 	pop	{r4, r5, r6, pc}
57e1041c:	57e47c08 	.word	0x57e47c08
57e10420:	57e39c40 	.word	0x57e39c40

57e10424 <usb_new_device>:
 * get the ball rolling..
 *
 * Returns 0 for success, != 0 for error.
 */
int usb_new_device(struct usb_device *dev)
{
57e10424:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e10428:	e24dde27 	sub	sp, sp, #624	; 0x270
	int addr, err;
	int tmp;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, tmpbuf, USB_BUFSIZ);
57e1042c:	e28d506b 	add	r5, sp, #107	; 0x6b
	 * only 18 bytes long, this will terminate with a short packet.  But if
	 * the maxpacket size is 8 or 16 the device may be waiting to transmit
	 * some more, or keeps on retransmitting the 8 byte header. */

	desc = (struct usb_device_descriptor *)tmpbuf;
	dev->descriptor.bMaxPacketSize0 = 64;	    /* Start off at 64 bytes  */
57e10430:	e3a03040 	mov	r3, #64	; 0x40
	int tmp;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, tmpbuf, USB_BUFSIZ);

	/* We still haven't set the Address yet */
	addr = dev->devnum;
	dev->devnum = 0;
57e10434:	e3a07000 	mov	r7, #0
	 * some more, or keeps on retransmitting the 8 byte header. */

	desc = (struct usb_device_descriptor *)tmpbuf;
	dev->descriptor.bMaxPacketSize0 = 64;	    /* Start off at 64 bytes  */
	/* Default to 64 byte max packet size */
	dev->maxpacketsize = PACKET_SIZE_64;
57e10438:	e3a02003 	mov	r2, #3
 */
int usb_new_device(struct usb_device *dev)
{
	int addr, err;
	int tmp;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, tmpbuf, USB_BUFSIZ);
57e1043c:	e3c5503f 	bic	r5, r5, #63	; 0x3f

	/* We still haven't set the Address yet */
	addr = dev->devnum;
57e10440:	e590a000 	ldr	sl, [r0]
	 * only 18 bytes long, this will terminate with a short packet.  But if
	 * the maxpacket size is 8 or 16 the device may be waiting to transmit
	 * some more, or keeps on retransmitting the 8 byte header. */

	desc = (struct usb_device_descriptor *)tmpbuf;
	dev->descriptor.bMaxPacketSize0 = 64;	    /* Start off at 64 bytes  */
57e10444:	e5c03107 	strb	r3, [r0, #263]	; 0x107
	/* Default to 64 byte max packet size */
	dev->maxpacketsize = PACKET_SIZE_64;
57e10448:	e5802068 	str	r2, [r0, #104]	; 0x68
	dev->epmaxpacketin[0] = 64;
57e1044c:	e580307c 	str	r3, [r0, #124]	; 0x7c
	dev->epmaxpacketout[0] = 64;
57e10450:	e58030bc 	str	r3, [r0, #188]	; 0xbc
	int tmp;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, tmpbuf, USB_BUFSIZ);

	/* We still haven't set the Address yet */
	addr = dev->devnum;
	dev->devnum = 0;
57e10454:	e5807000 	str	r7, [r0]
	 * http://sourceforge.net/mailarchive/forum.php?
	 * thread_id=5729457&forum_id=5398
	 */
	struct usb_device_descriptor *desc;
	int port = -1;
	struct usb_device *parent = dev->parent;
57e10458:	e5906624 	ldr	r6, [r0, #1572]	; 0x624
	/* Default to 64 byte max packet size */
	dev->maxpacketsize = PACKET_SIZE_64;
	dev->epmaxpacketin[0] = 64;
	dev->epmaxpacketout[0] = 64;

	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, 64);
57e1045c:	e3a01001 	mov	r1, #1
57e10460:	e58d3000 	str	r3, [sp]
57e10464:	e1a02007 	mov	r2, r7
57e10468:	e1a03005 	mov	r3, r5
 * get the ball rolling..
 *
 * Returns 0 for success, != 0 for error.
 */
int usb_new_device(struct usb_device *dev)
{
57e1046c:	e1a04000 	mov	r4, r0
	/* Default to 64 byte max packet size */
	dev->maxpacketsize = PACKET_SIZE_64;
	dev->epmaxpacketin[0] = 64;
	dev->epmaxpacketout[0] = 64;

	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, 64);
57e10470:	ebfffdf0 	bl	57e0fc38 <usb_get_descriptor>
	if (err < 0) {
57e10474:	e1500007 	cmp	r0, r7
57e10478:	ba000114 	blt	57e108d0 <usb_new_device+0x4ac>
		USB_PRINTF("usb_new_device: usb_get_descriptor() failed\n");
		return 1;
	}

	dev->descriptor.bMaxPacketSize0 = desc->bMaxPacketSize0;
57e1047c:	e5d53007 	ldrb	r3, [r5, #7]

	/* find the port number we're at */
	if (parent) {
57e10480:	e1560007 	cmp	r6, r7
	if (err < 0) {
		USB_PRINTF("usb_new_device: usb_get_descriptor() failed\n");
		return 1;
	}

	dev->descriptor.bMaxPacketSize0 = desc->bMaxPacketSize0;
57e10484:	e5c43107 	strb	r3, [r4, #263]	; 0x107

	/* find the port number we're at */
	if (parent) {
		int j;

		for (j = 0; j < parent->maxchild; j++) {
57e10488:	1596361c 	ldrne	r3, [r6, #1564]	; 0x61c
 * and is in the default state. We need to identify the thing and
 * get the ball rolling..
 *
 * Returns 0 for success, != 0 for error.
 */
int usb_new_device(struct usb_device *dev)
57e1048c:	12866e62 	addne	r6, r6, #1568	; 0x620
57e10490:	12866004 	addne	r6, r6, #4
	}

	dev->descriptor.bMaxPacketSize0 = desc->bMaxPacketSize0;

	/* find the port number we're at */
	if (parent) {
57e10494:	1a000004 	bne	57e104ac <usb_new_device+0x88>
57e10498:	ea00000f 	b	57e104dc <usb_new_device+0xb8>
		int j;

		for (j = 0; j < parent->maxchild; j++) {
			if (parent->children[j] == dev) {
57e1049c:	e5b62004 	ldr	r2, [r6, #4]!
57e104a0:	e1520004 	cmp	r2, r4
57e104a4:	0a000003 	beq	57e104b8 <usb_new_device+0x94>

	/* find the port number we're at */
	if (parent) {
		int j;

		for (j = 0; j < parent->maxchild; j++) {
57e104a8:	e2877001 	add	r7, r7, #1
57e104ac:	e1570003 	cmp	r7, r3
57e104b0:	bafffff9 	blt	57e1049c <usb_new_device+0x78>
57e104b4:	ea000108 	b	57e108dc <usb_new_device+0x4b8>
			printf("usb_new_device:cannot locate device's port.\n");
			return 1;
		}

		/* reset the port for the second time */
		err = hub_port_reset(dev->parent, port, &portstatus);
57e104b8:	e28d2f9b 	add	r2, sp, #620	; 0x26c
57e104bc:	e1a01007 	mov	r1, r7
57e104c0:	e5940624 	ldr	r0, [r4, #1572]	; 0x624
57e104c4:	e2822002 	add	r2, r2, #2
57e104c8:	eb0001c2 	bl	57e10bd8 <hub_port_reset>
		if (err < 0) {
57e104cc:	e3500000 	cmp	r0, #0
			printf("\n     Couldn't reset port %i\n", port);
57e104d0:	b59f0410 	ldrlt	r0, [pc, #1040]	; 57e108e8 <usb_new_device+0x4c4>
57e104d4:	b1a01007 	movlt	r1, r7
			return 1;
		}

		/* reset the port for the second time */
		err = hub_port_reset(dev->parent, port, &portstatus);
		if (err < 0) {
57e104d8:	ba00002a 	blt	57e10588 <usb_new_device+0x164>
			return 1;
		}
	}
#endif

	dev->epmaxpacketin[0] = dev->descriptor.bMaxPacketSize0;
57e104dc:	e5d43107 	ldrb	r3, [r4, #263]	; 0x107
	dev->epmaxpacketout[0] = dev->descriptor.bMaxPacketSize0;
	switch (dev->descriptor.bMaxPacketSize0) {
57e104e0:	e3530010 	cmp	r3, #16
			return 1;
		}
	}
#endif

	dev->epmaxpacketin[0] = dev->descriptor.bMaxPacketSize0;
57e104e4:	e584307c 	str	r3, [r4, #124]	; 0x7c
	dev->epmaxpacketout[0] = dev->descriptor.bMaxPacketSize0;
57e104e8:	e58430bc 	str	r3, [r4, #188]	; 0xbc
	switch (dev->descriptor.bMaxPacketSize0) {
57e104ec:	0a00000a 	beq	57e1051c <usb_new_device+0xf8>
57e104f0:	8a000002 	bhi	57e10500 <usb_new_device+0xdc>
57e104f4:	e3530008 	cmp	r3, #8
57e104f8:	1a00000d 	bne	57e10534 <usb_new_device+0x110>
57e104fc:	ea000004 	b	57e10514 <usb_new_device+0xf0>
57e10500:	e3530020 	cmp	r3, #32
57e10504:	0a000006 	beq	57e10524 <usb_new_device+0x100>
57e10508:	e3530040 	cmp	r3, #64	; 0x40
57e1050c:	1a000008 	bne	57e10534 <usb_new_device+0x110>
57e10510:	ea000005 	b	57e1052c <usb_new_device+0x108>
	case 8:
		dev->maxpacketsize  = PACKET_SIZE_8;
57e10514:	e3a03000 	mov	r3, #0
57e10518:	ea000004 	b	57e10530 <usb_new_device+0x10c>
		break;
	case 16:
		dev->maxpacketsize = PACKET_SIZE_16;
57e1051c:	e3a03001 	mov	r3, #1
57e10520:	ea000002 	b	57e10530 <usb_new_device+0x10c>
		break;
	case 32:
		dev->maxpacketsize = PACKET_SIZE_32;
57e10524:	e3a03002 	mov	r3, #2
57e10528:	ea000000 	b	57e10530 <usb_new_device+0x10c>
		break;
	case 64:
		dev->maxpacketsize = PACKET_SIZE_64;
57e1052c:	e3a03003 	mov	r3, #3
57e10530:	e5843068 	str	r3, [r4, #104]	; 0x68
static int usb_set_address(struct usb_device *dev)
{
	int res;

	USB_PRINTF("set address %d\n", dev->devnum);
	res = usb_control_msg(dev, usb_snddefctrl(dev),
57e10534:	e5941004 	ldr	r1, [r4, #4]
57e10538:	e3a06000 	mov	r6, #0
		break;
	case 64:
		dev->maxpacketsize = PACKET_SIZE_64;
		break;
	}
	dev->devnum = addr;
57e1053c:	e584a000 	str	sl, [r4]
static int usb_set_address(struct usb_device *dev)
{
	int res;

	USB_PRINTF("set address %d\n", dev->devnum);
	res = usb_control_msg(dev, usb_snddefctrl(dev),
57e10540:	e3a03064 	mov	r3, #100	; 0x64
57e10544:	e1a01d01 	lsl	r1, r1, #26
57e10548:	e1a0a80a 	lsl	sl, sl, #16
57e1054c:	e58d3010 	str	r3, [sp, #16]
57e10550:	e1a0a82a 	lsr	sl, sl, #16
57e10554:	e1a00004 	mov	r0, r4
57e10558:	e3811102 	orr	r1, r1, #-2147483648	; 0x80000000
57e1055c:	e3a02005 	mov	r2, #5
57e10560:	e1a03006 	mov	r3, r6
57e10564:	e58da000 	str	sl, [sp]
57e10568:	e58d6004 	str	r6, [sp, #4]
57e1056c:	e58d6008 	str	r6, [sp, #8]
57e10570:	e58d600c 	str	r6, [sp, #12]
57e10574:	ebfffd78 	bl	57e0fb5c <usb_control_msg>
	}
	dev->devnum = addr;

	err = usb_set_address(dev); /* set address */

	if (err < 0) {
57e10578:	e1500006 	cmp	r0, r6
57e1057c:	aa000003 	bge	57e10590 <usb_new_device+0x16c>
		printf("\n      USB device not accepting new address " \
57e10580:	e59f0364 	ldr	r0, [pc, #868]	; 57e108ec <usb_new_device+0x4c8>
57e10584:	e5941614 	ldr	r1, [r4, #1556]	; 0x614
57e10588:	ebffe3af 	bl	57e0944c <printf>
57e1058c:	ea0000cf 	b	57e108d0 <usb_new_device+0x4ac>
			"(error=%lX)\n", dev->status);
		return 1;
	}

	mdelay(10);	/* Let the SET_ADDRESS settle */
57e10590:	e3a0000a 	mov	r0, #10
57e10594:	eb004ff3 	bl	57e24568 <mdelay>

	tmp = sizeof(dev->descriptor);

	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
57e10598:	e3a07012 	mov	r7, #18
57e1059c:	e1a02006 	mov	r2, r6
57e105a0:	e1a00004 	mov	r0, r4
57e105a4:	e3a01001 	mov	r1, #1
57e105a8:	e1a03005 	mov	r3, r5
57e105ac:	e58d7000 	str	r7, [sp]
57e105b0:	ebfffda0 	bl	57e0fc38 <usb_get_descriptor>
				 tmpbuf, sizeof(dev->descriptor));
	if (err < tmp) {
57e105b4:	e3500011 	cmp	r0, #17

	mdelay(10);	/* Let the SET_ADDRESS settle */

	tmp = sizeof(dev->descriptor);

	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
57e105b8:	e1a02000 	mov	r2, r0
				 tmpbuf, sizeof(dev->descriptor));
	if (err < tmp) {
57e105bc:	ca000007 	bgt	57e105e0 <usb_new_device+0x1bc>
		if (err < 0)
57e105c0:	e3500000 	cmp	r0, #0
			printf("unable to get device descriptor (error=%d)\n",
57e105c4:	b59f0324 	ldrlt	r0, [pc, #804]	; 57e108f0 <usb_new_device+0x4cc>
57e105c8:	b1a01002 	movlt	r1, r2
	tmp = sizeof(dev->descriptor);

	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
				 tmpbuf, sizeof(dev->descriptor));
	if (err < tmp) {
		if (err < 0)
57e105cc:	baffffed 	blt	57e10588 <usb_new_device+0x164>
			printf("unable to get device descriptor (error=%d)\n",
			       err);
		else
			printf("USB device descriptor short read " \
57e105d0:	e1a01007 	mov	r1, r7
57e105d4:	e59f0318 	ldr	r0, [pc, #792]	; 57e108f4 <usb_new_device+0x4d0>
57e105d8:	ebffe39b 	bl	57e0944c <printf>
57e105dc:	ea0000bb 	b	57e108d0 <usb_new_device+0x4ac>
				"(expected %i, got %i)\n", tmp, err);
		return 1;
	}
	memcpy(&dev->descriptor, tmpbuf, sizeof(dev->descriptor));
57e105e0:	e1a01005 	mov	r1, r5
57e105e4:	e1a02007 	mov	r2, r7
57e105e8:	e2840c01 	add	r0, r4, #256	; 0x100
57e105ec:	eb004f46 	bl	57e2430c <memcpy>
	le16_to_cpus(&dev->descriptor.bcdUSB);
	le16_to_cpus(&dev->descriptor.idVendor);
	le16_to_cpus(&dev->descriptor.idProduct);
	le16_to_cpus(&dev->descriptor.bcdDevice);
	/* only support for one config for now */
	err = usb_get_configuration_no(dev, tmpbuf, 0);
57e105f0:	e1a00004 	mov	r0, r4
57e105f4:	e1a01005 	mov	r1, r5
57e105f8:	e1a02006 	mov	r2, r6
57e105fc:	ebfffe50 	bl	57e0ff44 <usb_get_configuration_no>
	if (err < 0) {
57e10600:	e3500000 	cmp	r0, #0
57e10604:	aa000005 	bge	57e10620 <usb_new_device+0x1fc>
		printf("usb_new_device: Cannot read configuration, " \
57e10608:	e3a03f42 	mov	r3, #264	; 0x108
57e1060c:	e19410b3 	ldrh	r1, [r4, r3]
57e10610:	e2833002 	add	r3, r3, #2
57e10614:	e59f02dc 	ldr	r0, [pc, #732]	; 57e108f8 <usb_new_device+0x4d4>
57e10618:	e19420b3 	ldrh	r2, [r4, r3]
57e1061c:	ea000091 	b	57e10868 <usb_new_device+0x444>

	ifno = -1;
	epno = -1;
	curr_if_num = -1;

	dev->configno = cfgno;
57e10620:	e58460fc 	str	r6, [r4, #252]	; 0xfc
	head = (struct usb_descriptor_header *) &buffer[0];
	if (head->bDescriptorType != USB_DT_CONFIG) {
57e10624:	e5d51001 	ldrb	r1, [r5, #1]
57e10628:	e3510002 	cmp	r1, #2
57e1062c:	0a000004 	beq	57e10644 <usb_new_device+0x220>
		printf(" ERROR: NOT USB_CONFIG_DESC %x\n",
57e10630:	e59f02c4 	ldr	r0, [pc, #708]	; 57e108fc <usb_new_device+0x4d8>
57e10634:	ebffe384 	bl	57e0944c <printf>
57e10638:	e1a07004 	mov	r7, r4
	struct usb_descriptor_header *head;
	int index, ifno, epno, curr_if_num;
	int i;
	u16 ep_wMaxPacketSize;

	ifno = -1;
57e1063c:	e3a05000 	mov	r5, #0
57e10640:	ea00005d 	b	57e107bc <usb_new_device+0x398>
	if (head->bDescriptorType != USB_DT_CONFIG) {
		printf(" ERROR: NOT USB_CONFIG_DESC %x\n",
			head->bDescriptorType);
		return -1;
	}
	memcpy(&dev->config, buffer, buffer[0]);
57e10644:	e2840e11 	add	r0, r4, #272	; 0x110
57e10648:	e1a01005 	mov	r1, r5
57e1064c:	e2800002 	add	r0, r0, #2
57e10650:	e5d52000 	ldrb	r2, [r5]
57e10654:	eb004f2c 	bl	57e2430c <memcpy>
	le16_to_cpus(&(dev->config.desc.wTotalLength));
	dev->config.no_of_if = 0;

	index = dev->config.desc.bLength;
57e10658:	e5d47112 	ldrb	r7, [r4, #274]	; 0x112
	int i;
	u16 ep_wMaxPacketSize;

	ifno = -1;
	epno = -1;
	curr_if_num = -1;
57e1065c:	e3e03000 	mvn	r3, #0
			if (((struct usb_interface_descriptor *) \
			     &buffer[index])->bInterfaceNumber != curr_if_num) {
				/* this is a new interface, copy new desc */
				ifno = dev->config.no_of_if;
				dev->config.no_of_if++;
				memcpy(&dev->config.if_desc[ifno],
57e10660:	e2841f47 	add	r1, r4, #284	; 0x11c
			head->bDescriptorType);
		return -1;
	}
	memcpy(&dev->config, buffer, buffer[0]);
	le16_to_cpus(&(dev->config.desc.wTotalLength));
	dev->config.no_of_if = 0;
57e10664:	e5c4611b 	strb	r6, [r4, #283]	; 0x11b

	index = dev->config.desc.bLength;
	/* Ok the first entry must be a configuration entry,
	 * now process the others */
	head = (struct usb_descriptor_header *) &buffer[index];
57e10668:	e0859007 	add	r9, r5, r7
	struct usb_descriptor_header *head;
	int index, ifno, epno, curr_if_num;
	int i;
	u16 ep_wMaxPacketSize;

	ifno = -1;
57e1066c:	e1a0a003 	mov	sl, r3
				dev->config.if_desc[ifno].num_altsetting = 1;
				curr_if_num =
				     dev->config.if_desc[ifno].desc.bInterfaceNumber;
			} else {
				/* found alternate setting for the interface */
				dev->config.if_desc[ifno].num_altsetting++;
57e10670:	e3a0c09c 	mov	ip, #156	; 0x9c
			if (((struct usb_interface_descriptor *) \
			     &buffer[index])->bInterfaceNumber != curr_if_num) {
				/* this is a new interface, copy new desc */
				ifno = dev->config.no_of_if;
				dev->config.no_of_if++;
				memcpy(&dev->config.if_desc[ifno],
57e10674:	e58d1024 	str	r1, [sp, #36]	; 0x24
57e10678:	e1a06005 	mov	r6, r5
57e1067c:	e1a0b003 	mov	fp, r3
57e10680:	ea00003d 	b	57e1077c <usb_new_device+0x358>
	index = dev->config.desc.bLength;
	/* Ok the first entry must be a configuration entry,
	 * now process the others */
	head = (struct usb_descriptor_header *) &buffer[index];
	while (index + 1 < dev->config.desc.wTotalLength) {
		switch (head->bDescriptorType) {
57e10684:	e5d93001 	ldrb	r3, [r9, #1]
57e10688:	e3530004 	cmp	r3, #4
57e1068c:	0a000002 	beq	57e1069c <usb_new_device+0x278>
57e10690:	e3530005 	cmp	r3, #5
57e10694:	1a000032 	bne	57e10764 <usb_new_device+0x340>
57e10698:	ea000018 	b	57e10700 <usb_new_device+0x2dc>
		case USB_DT_INTERFACE:
			if (((struct usb_interface_descriptor *) \
			     &buffer[index])->bInterfaceNumber != curr_if_num) {
57e1069c:	e0861007 	add	r1, r6, r7
57e106a0:	e5d13002 	ldrb	r3, [r1, #2]
	 * now process the others */
	head = (struct usb_descriptor_header *) &buffer[index];
	while (index + 1 < dev->config.desc.wTotalLength) {
		switch (head->bDescriptorType) {
		case USB_DT_INTERFACE:
			if (((struct usb_interface_descriptor *) \
57e106a4:	e153000b 	cmp	r3, fp
57e106a8:	0a00000f 	beq	57e106ec <usb_new_device+0x2c8>
			     &buffer[index])->bInterfaceNumber != curr_if_num) {
				/* this is a new interface, copy new desc */
				ifno = dev->config.no_of_if;
57e106ac:	e5d4a11b 	ldrb	sl, [r4, #283]	; 0x11b
				dev->config.no_of_if++;
				memcpy(&dev->config.if_desc[ifno],
57e106b0:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
57e106b4:	e0050a9c 	mul	r5, ip, sl
		case USB_DT_INTERFACE:
			if (((struct usb_interface_descriptor *) \
			     &buffer[index])->bInterfaceNumber != curr_if_num) {
				/* this is a new interface, copy new desc */
				ifno = dev->config.no_of_if;
				dev->config.no_of_if++;
57e106b8:	e28a3001 	add	r3, sl, #1
57e106bc:	e5c4311b 	strb	r3, [r4, #283]	; 0x11b
				memcpy(&dev->config.if_desc[ifno],
57e106c0:	e0820005 	add	r0, r2, r5
57e106c4:	e7d62007 	ldrb	r2, [r6, r7]
					&buffer[index], buffer[index]);
				dev->config.if_desc[ifno].no_of_ep = 0;
57e106c8:	e0845005 	add	r5, r4, r5
			if (((struct usb_interface_descriptor *) \
			     &buffer[index])->bInterfaceNumber != curr_if_num) {
				/* this is a new interface, copy new desc */
				ifno = dev->config.no_of_if;
				dev->config.no_of_if++;
				memcpy(&dev->config.if_desc[ifno],
57e106cc:	e58dc01c 	str	ip, [sp, #28]
57e106d0:	eb004f0d 	bl	57e2430c <memcpy>
					&buffer[index], buffer[index]);
				dev->config.if_desc[ifno].no_of_ep = 0;
57e106d4:	e3a03000 	mov	r3, #0
				dev->config.if_desc[ifno].num_altsetting = 1;
57e106d8:	e3a01001 	mov	r1, #1
				/* this is a new interface, copy new desc */
				ifno = dev->config.no_of_if;
				dev->config.no_of_if++;
				memcpy(&dev->config.if_desc[ifno],
					&buffer[index], buffer[index]);
				dev->config.if_desc[ifno].no_of_ep = 0;
57e106dc:	e5c53125 	strb	r3, [r5, #293]	; 0x125
				dev->config.if_desc[ifno].num_altsetting = 1;
57e106e0:	e5c51126 	strb	r1, [r5, #294]	; 0x126
				curr_if_num =
57e106e4:	e5d5b11e 	ldrb	fp, [r5, #286]	; 0x11e
57e106e8:	ea00001b 	b	57e1075c <usb_new_device+0x338>
				     dev->config.if_desc[ifno].desc.bInterfaceNumber;
			} else {
				/* found alternate setting for the interface */
				dev->config.if_desc[ifno].num_altsetting++;
57e106ec:	e0234a9c 	mla	r3, ip, sl, r4
57e106f0:	e5d32126 	ldrb	r2, [r3, #294]	; 0x126
57e106f4:	e2822001 	add	r2, r2, #1
57e106f8:	e5c32126 	strb	r2, [r3, #294]	; 0x126
57e106fc:	ea00001b 	b	57e10770 <usb_new_device+0x34c>
			}
			break;
		case USB_DT_ENDPOINT:
			epno = dev->config.if_desc[ifno].no_of_ep;
57e10700:	e0030a9c 	mul	r3, ip, sl
57e10704:	e0842003 	add	r2, r4, r3
57e10708:	e5d25125 	ldrb	r5, [r2, #293]	; 0x125
			/* found an endpoint */
			dev->config.if_desc[ifno].no_of_ep++;
			memcpy(&dev->config.if_desc[ifno].ep_desc[epno],
57e1070c:	e2820f4a 	add	r0, r2, #296	; 0x128
			}
			break;
		case USB_DT_ENDPOINT:
			epno = dev->config.if_desc[ifno].no_of_ep;
			/* found an endpoint */
			dev->config.if_desc[ifno].no_of_ep++;
57e10710:	e2851001 	add	r1, r5, #1
57e10714:	e5c21125 	strb	r1, [r2, #293]	; 0x125
			memcpy(&dev->config.if_desc[ifno].ep_desc[epno],
57e10718:	e0855185 	add	r5, r5, r5, lsl #3
57e1071c:	e7d62007 	ldrb	r2, [r6, r7]
57e10720:	e0861007 	add	r1, r6, r7
57e10724:	e0800005 	add	r0, r0, r5
57e10728:	e58d3020 	str	r3, [sp, #32]
57e1072c:	e58dc01c 	str	ip, [sp, #28]
57e10730:	eb004ef5 	bl	57e2430c <memcpy>
				&buffer[index], buffer[index]);
			ep_wMaxPacketSize = get_unaligned(&dev->config.\
57e10734:	e59d3020 	ldr	r3, [sp, #32]
57e10738:	e0853003 	add	r3, r5, r3
57e1073c:	e2833e12 	add	r3, r3, #288	; 0x120
57e10740:	e0843003 	add	r3, r4, r3
57e10744:	e5d3100d 	ldrb	r1, [r3, #13]
57e10748:	e5d3200c 	ldrb	r2, [r3, #12]
57e1074c:	e1822401 	orr	r2, r2, r1, lsl #8
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
57e10750:	e5c3200c 	strb	r2, [r3, #12]
	*p++ = val >> 8;
57e10754:	e1a02422 	lsr	r2, r2, #8
57e10758:	e5c3200d 	strb	r2, [r3, #13]
57e1075c:	e59dc01c 	ldr	ip, [sp, #28]
57e10760:	ea000002 	b	57e10770 <usb_new_device+0x34c>
					ep_desc[epno].\
					wMaxPacketSize);
			USB_PRINTF("if %d, ep %d\n", ifno, epno);
			break;
		default:
			if (head->bLength == 0)
57e10764:	e5d93000 	ldrb	r3, [r9]
57e10768:	e3530000 	cmp	r3, #0
57e1076c:	0affffb1 	beq	57e10638 <usb_new_device+0x214>
					USB_PRINTF("%02X ", *ch++);
				USB_PRINTF("\n\n\n");
			}
			break;
		}
		index += head->bLength;
57e10770:	e5d93000 	ldrb	r3, [r9]
57e10774:	e0877003 	add	r7, r7, r3
		head = (struct usb_descriptor_header *)&buffer[index];
57e10778:	e0869007 	add	r9, r6, r7

	index = dev->config.desc.bLength;
	/* Ok the first entry must be a configuration entry,
	 * now process the others */
	head = (struct usb_descriptor_header *) &buffer[index];
	while (index + 1 < dev->config.desc.wTotalLength) {
57e1077c:	e3a01f45 	mov	r1, #276	; 0x114
57e10780:	e19430b1 	ldrh	r3, [r4, r1]
57e10784:	e2872001 	add	r2, r7, #1
57e10788:	e1520003 	cmp	r2, r3
57e1078c:	baffffbc 	blt	57e10684 <usb_new_device+0x260>
57e10790:	eaffffa8 	b	57e10638 <usb_new_device+0x214>
{
	int i, ii;

	for (i = 0; i < dev->config.desc.bNumInterfaces; i++)
		for (ii = 0; ii < dev->config.if_desc[i].desc.bNumEndpoints; ii++)
			usb_set_maxpacket_ep(dev, i, ii);
57e10794:	e1a02006 	mov	r2, r6
57e10798:	e1a00004 	mov	r0, r4
57e1079c:	e1a01005 	mov	r1, r5
57e107a0:	ebfffcb4 	bl	57e0fa78 <usb_set_maxpacket_ep>
static int usb_set_maxpacket(struct usb_device *dev)
{
	int i, ii;

	for (i = 0; i < dev->config.desc.bNumInterfaces; i++)
		for (ii = 0; ii < dev->config.if_desc[i].desc.bNumEndpoints; ii++)
57e107a4:	e2866001 	add	r6, r6, #1
57e107a8:	e5d73120 	ldrb	r3, [r7, #288]	; 0x120
57e107ac:	e1560003 	cmp	r6, r3
57e107b0:	bafffff7 	blt	57e10794 <usb_new_device+0x370>
 */
static int usb_set_maxpacket(struct usb_device *dev)
{
	int i, ii;

	for (i = 0; i < dev->config.desc.bNumInterfaces; i++)
57e107b4:	e2855001 	add	r5, r5, #1
57e107b8:	e287709c 	add	r7, r7, #156	; 0x9c
57e107bc:	e5d43116 	ldrb	r3, [r4, #278]	; 0x116
57e107c0:	e1550003 	cmp	r5, r3
57e107c4:	b3a06000 	movlt	r6, #0
57e107c8:	bafffff6 	blt	57e107a8 <usb_new_device+0x384>
static int usb_set_configuration(struct usb_device *dev, int configuration)
{
	int res;
	USB_PRINTF("set configuration %d\n", configuration);
	/* set setup command */
	res = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e107cc:	e5942068 	ldr	r2, [r4, #104]	; 0x68
57e107d0:	e5d43117 	ldrb	r3, [r4, #279]	; 0x117
57e107d4:	e5941000 	ldr	r1, [r4]
57e107d8:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
57e107dc:	e3a00064 	mov	r0, #100	; 0x64
57e107e0:	e58d3000 	str	r3, [sp]
57e107e4:	e58d0010 	str	r0, [sp, #16]
57e107e8:	e3a03000 	mov	r3, #0
57e107ec:	e1821401 	orr	r1, r2, r1, lsl #8
57e107f0:	e1a00004 	mov	r0, r4
57e107f4:	e3a02009 	mov	r2, #9
57e107f8:	e58d3004 	str	r3, [sp, #4]
57e107fc:	e58d3008 	str	r3, [sp, #8]
57e10800:	e58d300c 	str	r3, [sp, #12]
57e10804:	ebfffcd4 	bl	57e0fb5c <usb_control_msg>
				USB_REQ_SET_CONFIGURATION, 0,
				configuration, 0,
				NULL, 0, USB_CNTL_TIMEOUT);
	if (res == 0) {
57e10808:	e2505000 	subs	r5, r0, #0
57e1080c:	1a000012 	bne	57e1085c <usb_new_device+0x438>
		return -1;
	}
	USB_PRINTF("new device strings: Mfr=%d, Product=%d, SerialNumber=%d\n",
		   dev->descriptor.iManufacturer, dev->descriptor.iProduct,
		   dev->descriptor.iSerialNumber);
	memset(dev->mf, 0, sizeof(dev->mf));
57e10810:	e2846008 	add	r6, r4, #8
57e10814:	e1a01005 	mov	r1, r5
57e10818:	e3a02020 	mov	r2, #32
	res = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
				USB_REQ_SET_CONFIGURATION, 0,
				configuration, 0,
				NULL, 0, USB_CNTL_TIMEOUT);
	if (res == 0) {
		dev->toggle[0] = 0;
57e1081c:	e584506c 	str	r5, [r4, #108]	; 0x6c
		dev->toggle[1] = 0;
57e10820:	e5845070 	str	r5, [r4, #112]	; 0x70
		return -1;
	}
	USB_PRINTF("new device strings: Mfr=%d, Product=%d, SerialNumber=%d\n",
		   dev->descriptor.iManufacturer, dev->descriptor.iProduct,
		   dev->descriptor.iSerialNumber);
	memset(dev->mf, 0, sizeof(dev->mf));
57e10824:	e1a00006 	mov	r0, r6
57e10828:	eb004e93 	bl	57e2427c <memset>
	memset(dev->prod, 0, sizeof(dev->prod));
57e1082c:	e1a01005 	mov	r1, r5
57e10830:	e3a02020 	mov	r2, #32
57e10834:	e2840028 	add	r0, r4, #40	; 0x28
57e10838:	eb004e8f 	bl	57e2427c <memset>
	memset(dev->serial, 0, sizeof(dev->serial));
57e1083c:	e1a01005 	mov	r1, r5
57e10840:	e2840048 	add	r0, r4, #72	; 0x48
57e10844:	e3a02020 	mov	r2, #32
57e10848:	eb004e8b 	bl	57e2427c <memset>
	if (dev->descriptor.iManufacturer)
57e1084c:	e5d4110e 	ldrb	r1, [r4, #270]	; 0x10e
57e10850:	e3510000 	cmp	r1, #0
57e10854:	0a00000a 	beq	57e10884 <usb_new_device+0x460>
57e10858:	ea000005 	b	57e10874 <usb_new_device+0x450>
	}
	usb_parse_config(dev, tmpbuf, 0);
	usb_set_maxpacket(dev);
	/* we set the default configuration here */
	if (usb_set_configuration(dev, dev->config.desc.bConfigurationValue)) {
		printf("failed to set default configuration " \
57e1085c:	e59f009c 	ldr	r0, [pc, #156]	; 57e10900 <usb_new_device+0x4dc>
57e10860:	e5941618 	ldr	r1, [r4, #1560]	; 0x618
57e10864:	e5942614 	ldr	r2, [r4, #1556]	; 0x614
57e10868:	ebffe2f7 	bl	57e0944c <printf>
			"len %d, status %lX\n", dev->act_len, dev->status);
		return -1;
57e1086c:	e3e00000 	mvn	r0, #0
57e10870:	ea000017 	b	57e108d4 <usb_new_device+0x4b0>
		   dev->descriptor.iSerialNumber);
	memset(dev->mf, 0, sizeof(dev->mf));
	memset(dev->prod, 0, sizeof(dev->prod));
	memset(dev->serial, 0, sizeof(dev->serial));
	if (dev->descriptor.iManufacturer)
		usb_string(dev, dev->descriptor.iManufacturer,
57e10874:	e1a00004 	mov	r0, r4
57e10878:	e1a02006 	mov	r2, r6
57e1087c:	e3a03020 	mov	r3, #32
57e10880:	ebfffe65 	bl	57e1021c <usb_string>
			   dev->mf, sizeof(dev->mf));
	if (dev->descriptor.iProduct)
57e10884:	e5d4110f 	ldrb	r1, [r4, #271]	; 0x10f
57e10888:	e3510000 	cmp	r1, #0
57e1088c:	0a000003 	beq	57e108a0 <usb_new_device+0x47c>
		usb_string(dev, dev->descriptor.iProduct,
57e10890:	e1a00004 	mov	r0, r4
57e10894:	e2842028 	add	r2, r4, #40	; 0x28
57e10898:	e3a03020 	mov	r3, #32
57e1089c:	ebfffe5e 	bl	57e1021c <usb_string>
			   dev->prod, sizeof(dev->prod));
	if (dev->descriptor.iSerialNumber)
57e108a0:	e5d41110 	ldrb	r1, [r4, #272]	; 0x110
57e108a4:	e3510000 	cmp	r1, #0
57e108a8:	0a000003 	beq	57e108bc <usb_new_device+0x498>
		usb_string(dev, dev->descriptor.iSerialNumber,
57e108ac:	e1a00004 	mov	r0, r4
57e108b0:	e2842048 	add	r2, r4, #72	; 0x48
57e108b4:	e3a03020 	mov	r3, #32
57e108b8:	ebfffe57 	bl	57e1021c <usb_string>
			   dev->serial, sizeof(dev->serial));
	USB_PRINTF("Manufacturer %s\n", dev->mf);
	USB_PRINTF("Product      %s\n", dev->prod);
	USB_PRINTF("SerialNumber %s\n", dev->serial);
	/* now prode if the device is a hub */
	usb_hub_probe(dev, 0);
57e108bc:	e1a00004 	mov	r0, r4
57e108c0:	e3a01000 	mov	r1, #0
57e108c4:	eb0001f0 	bl	57e1108c <usb_hub_probe>
	return 0;
57e108c8:	e3a00000 	mov	r0, #0
57e108cc:	ea000000 	b	57e108d4 <usb_new_device+0x4b0>
	dev->epmaxpacketout[0] = 64;

	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, 64);
	if (err < 0) {
		USB_PRINTF("usb_new_device: usb_get_descriptor() failed\n");
		return 1;
57e108d0:	e3a00001 	mov	r0, #1
	USB_PRINTF("Product      %s\n", dev->prod);
	USB_PRINTF("SerialNumber %s\n", dev->serial);
	/* now prode if the device is a hub */
	usb_hub_probe(dev, 0);
	return 0;
}
57e108d4:	e28dde27 	add	sp, sp, #624	; 0x270
57e108d8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
				port = j;
				break;
			}
		}
		if (port < 0) {
			printf("usb_new_device:cannot locate device's port.\n");
57e108dc:	e59f0020 	ldr	r0, [pc, #32]	; 57e10904 <usb_new_device+0x4e0>
57e108e0:	ebffe2d9 	bl	57e0944c <printf>
57e108e4:	eafffff9 	b	57e108d0 <usb_new_device+0x4ac>
57e108e8:	57e32b9b 	.word	0x57e32b9b
57e108ec:	57e32bb9 	.word	0x57e32bb9
57e108f0:	57e32bf2 	.word	0x57e32bf2
57e108f4:	57e32c1e 	.word	0x57e32c1e
57e108f8:	57e32c56 	.word	0x57e32c56
57e108fc:	57e32c9c 	.word	0x57e32c9c
57e10900:	57e32cbc 	.word	0x57e32cbc
57e10904:	57e32cf4 	.word	0x57e32cf4

57e10908 <usb_init>:
{
	void *ctrl;
	struct usb_device *dev;
	int i, start_index = 0;

	dev_index = 0;
57e10908:	e59f30f4 	ldr	r3, [pc, #244]	; 57e10a04 <usb_init+0xfc>

/***************************************************************************
 * Init USB Device
 */
int usb_init(void)
{
57e1090c:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
	void *ctrl;
	struct usb_device *dev;
	int i, start_index = 0;

	dev_index = 0;
57e10910:	e3a02000 	mov	r2, #0
	asynch_allowed = 1;
57e10914:	e59f40ec 	ldr	r4, [pc, #236]	; 57e10a08 <usb_init+0x100>
{
	void *ctrl;
	struct usb_device *dev;
	int i, start_index = 0;

	dev_index = 0;
57e10918:	e5032f88 	str	r2, [r3, #-3976]	; 0xf88
	asynch_allowed = 1;
57e1091c:	e3a03001 	mov	r3, #1
57e10920:	e5843004 	str	r3, [r4, #4]
	usb_hub_reset();
57e10924:	eb0000a6 	bl	57e10bc4 <usb_hub_reset>
#endif

/***************************************************************************
 * Init USB Device
 */
int usb_init(void)
57e10928:	e59f60dc 	ldr	r6, [pc, #220]	; 57e10a0c <usb_init+0x104>
	asynch_allowed = 1;
	usb_hub_reset();

	/* first make all devices unknown */
	for (i = 0; i < USB_MAX_DEVICE; i++) {
		memset(&usb_dev[i], 0, sizeof(struct usb_device));
57e1092c:	e2844040 	add	r4, r4, #64	; 0x40
		usb_dev[i].devnum = -1;
57e10930:	e3e05000 	mvn	r5, #0
	asynch_allowed = 1;
	usb_hub_reset();

	/* first make all devices unknown */
	for (i = 0; i < USB_MAX_DEVICE; i++) {
		memset(&usb_dev[i], 0, sizeof(struct usb_device));
57e10934:	e1a00004 	mov	r0, r4
57e10938:	e3a01000 	mov	r1, #0
57e1093c:	e3a02d1a 	mov	r2, #1664	; 0x680
57e10940:	eb004e4d 	bl	57e2427c <memset>
		usb_dev[i].devnum = -1;
57e10944:	e4845680 	str	r5, [r4], #1664	; 0x680
	dev_index = 0;
	asynch_allowed = 1;
	usb_hub_reset();

	/* first make all devices unknown */
	for (i = 0; i < USB_MAX_DEVICE; i++) {
57e10948:	e1540006 	cmp	r4, r6
57e1094c:	1afffff8 	bne	57e10934 <usb_init+0x2c>
	}

	/* init low_level USB */
	for (i = 0; i < CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
		/* init low_level USB */
		printf("USB%d:   ", i);
57e10950:	e3a01000 	mov	r1, #0
57e10954:	e59f00b4 	ldr	r0, [pc, #180]	; 57e10a10 <usb_init+0x108>
57e10958:	ebffe2bb 	bl	57e0944c <printf>
		if (usb_lowlevel_init(i, &ctrl)) {
57e1095c:	e28d1004 	add	r1, sp, #4
57e10960:	e3a00000 	mov	r0, #0
57e10964:	eb0037c0 	bl	57e1e86c <usb_lowlevel_init>
57e10968:	e2501000 	subs	r1, r0, #0
57e1096c:	1a000019 	bne	57e109d8 <usb_init+0xd0>
		}
		/*
		 * lowlevel init is OK, now scan the bus for devices
		 * i.e. search HUBs and configure them
		 */
		start_index = dev_index;
57e10970:	e59f308c 	ldr	r3, [pc, #140]	; 57e10a04 <usb_init+0xfc>
		printf("scanning bus %d for devices... ", i);
57e10974:	e59f0098 	ldr	r0, [pc, #152]	; 57e10a14 <usb_init+0x10c>
		}
		/*
		 * lowlevel init is OK, now scan the bus for devices
		 * i.e. search HUBs and configure them
		 */
		start_index = dev_index;
57e10978:	e5134f88 	ldr	r4, [r3, #-3976]	; 0xf88
		printf("scanning bus %d for devices... ", i);
57e1097c:	ebffe2b2 	bl	57e0944c <printf>
		dev = usb_alloc_new_device(ctrl);
57e10980:	e59d0004 	ldr	r0, [sp, #4]
57e10984:	ebfffe6f 	bl	57e10348 <usb_alloc_new_device>
		/*
		 * device 0 is always present
		 * (root hub, so let it analyze)
		 */
		if (dev)
57e10988:	e3500000 	cmp	r0, #0
57e1098c:	1a00000f 	bne	57e109d0 <usb_init+0xc8>
			usb_new_device(dev);

		if (start_index == dev_index)
57e10990:	e59f306c 	ldr	r3, [pc, #108]	; 57e10a04 <usb_init+0xfc>
57e10994:	e5131f88 	ldr	r1, [r3, #-3976]	; 0xf88
57e10998:	e1540001 	cmp	r4, r1
57e1099c:	1a000004 	bne	57e109b4 <usb_init+0xac>
57e109a0:	ea000007 	b	57e109c4 <usb_init+0xbc>
			puts("No USB Device found\n");
		else
			printf("%d USB Device(s) found\n",
				dev_index - start_index);

		usb_started = 1;
57e109a4:	e59f305c 	ldr	r3, [pc, #92]	; 57e10a08 <usb_init+0x100>
57e109a8:	e3a02001 	mov	r2, #1
57e109ac:	e5c32000 	strb	r2, [r3]
57e109b0:	ea00000a 	b	57e109e0 <usb_init+0xd8>
			usb_new_device(dev);

		if (start_index == dev_index)
			puts("No USB Device found\n");
		else
			printf("%d USB Device(s) found\n",
57e109b4:	e0641001 	rsb	r1, r4, r1
57e109b8:	e59f0058 	ldr	r0, [pc, #88]	; 57e10a18 <usb_init+0x110>
57e109bc:	ebffe2a2 	bl	57e0944c <printf>
57e109c0:	eafffff7 	b	57e109a4 <usb_init+0x9c>
		 */
		if (dev)
			usb_new_device(dev);

		if (start_index == dev_index)
			puts("No USB Device found\n");
57e109c4:	e59f0050 	ldr	r0, [pc, #80]	; 57e10a1c <usb_init+0x114>
57e109c8:	ebffe295 	bl	57e09424 <puts>
57e109cc:	eafffff4 	b	57e109a4 <usb_init+0x9c>
		/*
		 * device 0 is always present
		 * (root hub, so let it analyze)
		 */
		if (dev)
			usb_new_device(dev);
57e109d0:	ebfffe93 	bl	57e10424 <usb_new_device>
57e109d4:	eaffffed 	b	57e10990 <usb_init+0x88>
	/* init low_level USB */
	for (i = 0; i < CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
		/* init low_level USB */
		printf("USB%d:   ", i);
		if (usb_lowlevel_init(i, &ctrl)) {
			puts("lowlevel init failed\n");
57e109d8:	e59f0040 	ldr	r0, [pc, #64]	; 57e10a20 <usb_init+0x118>
57e109dc:	ebffe290 	bl	57e09424 <puts>
		usb_started = 1;
	}

	USB_PRINTF("scan end\n");
	/* if we were not able to find at least one working bus, bail out */
	if (!usb_started) {
57e109e0:	e59f3020 	ldr	r3, [pc, #32]	; 57e10a08 <usb_init+0x100>
57e109e4:	e5d33000 	ldrb	r3, [r3]
57e109e8:	e3530000 	cmp	r3, #0
		puts("USB error: all controllers failed lowlevel init\n");
		return -1;
	}

	return 0;
57e109ec:	13a00000 	movne	r0, #0
		usb_started = 1;
	}

	USB_PRINTF("scan end\n");
	/* if we were not able to find at least one working bus, bail out */
	if (!usb_started) {
57e109f0:	1a000002 	bne	57e10a00 <usb_init+0xf8>
		puts("USB error: all controllers failed lowlevel init\n");
57e109f4:	e59f0028 	ldr	r0, [pc, #40]	; 57e10a24 <usb_init+0x11c>
57e109f8:	ebffe289 	bl	57e09424 <puts>
		return -1;
57e109fc:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
57e10a00:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
57e10a04:	57e47c08 	.word	0x57e47c08
57e10a08:	57e39c40 	.word	0x57e39c40
57e10a0c:	57e46c80 	.word	0x57e46c80
57e10a10:	57e32d21 	.word	0x57e32d21
57e10a14:	57e32d2b 	.word	0x57e32d2b
57e10a18:	57e32d4b 	.word	0x57e32d4b
57e10a1c:	57e32d63 	.word	0x57e32d63
57e10a20:	57e32d78 	.word	0x57e32d78
57e10a24:	57e32d8e 	.word	0x57e32d8e

57e10a28 <usb_get_hub_descriptor>:
static struct usb_hub_device hub_dev[USB_MAX_HUB];
static int usb_hub_index;


static int usb_get_hub_descriptor(struct usb_device *dev, void *data, int size)
{
57e10a28:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
57e10a2c:	e590c068 	ldr	ip, [r0, #104]	; 0x68
57e10a30:	e1a02802 	lsl	r2, r2, #16
57e10a34:	e5903000 	ldr	r3, [r0]
57e10a38:	e1a02822 	lsr	r2, r2, #16
57e10a3c:	e38cc102 	orr	ip, ip, #-2147483648	; 0x80000000
57e10a40:	e38cc080 	orr	ip, ip, #128	; 0x80
57e10a44:	e3a0ec29 	mov	lr, #10496	; 0x2900
57e10a48:	e58d200c 	str	r2, [sp, #12]
57e10a4c:	e3a02064 	mov	r2, #100	; 0x64
57e10a50:	e58de000 	str	lr, [sp]
57e10a54:	e58d1008 	str	r1, [sp, #8]
57e10a58:	e24eec29 	sub	lr, lr, #10496	; 0x2900
57e10a5c:	e58d2010 	str	r2, [sp, #16]
57e10a60:	e18c1403 	orr	r1, ip, r3, lsl #8
57e10a64:	e3a02006 	mov	r2, #6
57e10a68:	e3a030a0 	mov	r3, #160	; 0xa0
57e10a6c:	e58de004 	str	lr, [sp, #4]
57e10a70:	ebfffc39 	bl	57e0fb5c <usb_control_msg>
		USB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,
		USB_DT_HUB << 8, 0, data, size, USB_CNTL_TIMEOUT);
}
57e10a74:	e28dd01c 	add	sp, sp, #28
57e10a78:	e8bd8000 	pop	{pc}

57e10a7c <usb_get_port_status>:
			USB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_HUB, 0, 0,
			data, sizeof(struct usb_hub_status), USB_CNTL_TIMEOUT);
}

static int usb_get_port_status(struct usb_device *dev, int port, void *data)
{
57e10a7c:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
57e10a80:	e590c068 	ldr	ip, [r0, #104]	; 0x68
57e10a84:	e590e000 	ldr	lr, [r0]
57e10a88:	e38cc102 	orr	ip, ip, #-2147483648	; 0x80000000
57e10a8c:	e58d2008 	str	r2, [sp, #8]
57e10a90:	e1a01801 	lsl	r1, r1, #16
57e10a94:	e3a02004 	mov	r2, #4
57e10a98:	e3a03000 	mov	r3, #0
57e10a9c:	e38cc080 	orr	ip, ip, #128	; 0x80
57e10aa0:	e1a01821 	lsr	r1, r1, #16
57e10aa4:	e58d200c 	str	r2, [sp, #12]
57e10aa8:	e2822060 	add	r2, r2, #96	; 0x60
57e10aac:	e58d3000 	str	r3, [sp]
57e10ab0:	e58d1004 	str	r1, [sp, #4]
57e10ab4:	e58d2010 	str	r2, [sp, #16]
57e10ab8:	e18c140e 	orr	r1, ip, lr, lsl #8
57e10abc:	e1a02003 	mov	r2, r3
57e10ac0:	e28330a3 	add	r3, r3, #163	; 0xa3
57e10ac4:	ebfffc24 	bl	57e0fb5c <usb_control_msg>
			USB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0, port,
			data, sizeof(struct usb_hub_status), USB_CNTL_TIMEOUT);
}
57e10ac8:	e28dd01c 	add	sp, sp, #28
57e10acc:	e8bd8000 	pop	{pc}

57e10ad0 <usb_set_port_feature>:
				USB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature,
				port, NULL, 0, USB_CNTL_TIMEOUT);
}

static int usb_set_port_feature(struct usb_device *dev, int port, int feature)
{
57e10ad0:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e10ad4:	e1a02802 	lsl	r2, r2, #16
57e10ad8:	e590c068 	ldr	ip, [r0, #104]	; 0x68
57e10adc:	e1a02822 	lsr	r2, r2, #16
57e10ae0:	e5903000 	ldr	r3, [r0]
57e10ae4:	e1a01801 	lsl	r1, r1, #16
57e10ae8:	e58d2000 	str	r2, [sp]
57e10aec:	e3a02000 	mov	r2, #0
57e10af0:	e38cc102 	orr	ip, ip, #-2147483648	; 0x80000000
57e10af4:	e1a01821 	lsr	r1, r1, #16
57e10af8:	e58d2008 	str	r2, [sp, #8]
57e10afc:	e58d200c 	str	r2, [sp, #12]
57e10b00:	e2822064 	add	r2, r2, #100	; 0x64
57e10b04:	e58d1004 	str	r1, [sp, #4]
57e10b08:	e58d2010 	str	r2, [sp, #16]
57e10b0c:	e18c1403 	orr	r1, ip, r3, lsl #8
57e10b10:	e3a02003 	mov	r2, #3
57e10b14:	e3a03023 	mov	r3, #35	; 0x23
57e10b18:	ebfffc0f 	bl	57e0fb5c <usb_control_msg>
				USB_REQ_SET_FEATURE, USB_RT_PORT, feature,
				port, NULL, 0, USB_CNTL_TIMEOUT);
}
57e10b1c:	e28dd01c 	add	sp, sp, #28
57e10b20:	e8bd8000 	pop	{pc}

57e10b24 <usb_hub_power_on>:
			data, sizeof(struct usb_hub_status), USB_CNTL_TIMEOUT);
}


static void usb_hub_power_on(struct usb_hub_device *hub)
{
57e10b24:	e92d4070 	push	{r4, r5, r6, lr}
	int i;
	struct usb_device *dev;
	unsigned pgood_delay = hub->desc.bPwrOn2PwrGood * 2;
57e10b28:	e5d06009 	ldrb	r6, [r0, #9]

	dev = hub->pusb_dev;
57e10b2c:	e5905000 	ldr	r5, [r0]

static void usb_hub_power_on(struct usb_hub_device *hub)
{
	int i;
	struct usb_device *dev;
	unsigned pgood_delay = hub->desc.bPwrOn2PwrGood * 2;
57e10b30:	e1a06086 	lsl	r6, r6, #1

	dev = hub->pusb_dev;
	/* Enable power to the ports */
	USB_HUB_PRINTF("enabling power on all ports\n");
	for (i = 0; i < dev->maxchild; i++) {
57e10b34:	e3a04000 	mov	r4, #0
57e10b38:	ea000004 	b	57e10b50 <usb_hub_power_on+0x2c>
		usb_set_port_feature(dev, i + 1, USB_PORT_FEAT_POWER);
57e10b3c:	e2844001 	add	r4, r4, #1
57e10b40:	e1a00005 	mov	r0, r5
57e10b44:	e1a01004 	mov	r1, r4
57e10b48:	e3a02008 	mov	r2, #8
57e10b4c:	ebffffdf 	bl	57e10ad0 <usb_set_port_feature>
	unsigned pgood_delay = hub->desc.bPwrOn2PwrGood * 2;

	dev = hub->pusb_dev;
	/* Enable power to the ports */
	USB_HUB_PRINTF("enabling power on all ports\n");
	for (i = 0; i < dev->maxchild; i++) {
57e10b50:	e595361c 	ldr	r3, [r5, #1564]	; 0x61c
57e10b54:	e1540003 	cmp	r4, r3
57e10b58:	bafffff7 	blt	57e10b3c <usb_hub_power_on+0x18>
		usb_set_port_feature(dev, i + 1, USB_PORT_FEAT_POWER);
		USB_HUB_PRINTF("port %d returns %lX\n", i + 1, dev->status);
	}

	/* Wait at least 100 msec for power to become stable */
	mdelay(max(pgood_delay, (unsigned)100));
57e10b5c:	e3560064 	cmp	r6, #100	; 0x64
57e10b60:	21a00006 	movcs	r0, r6
57e10b64:	33a00064 	movcc	r0, #100	; 0x64
}
57e10b68:	e8bd4070 	pop	{r4, r5, r6, lr}
		usb_set_port_feature(dev, i + 1, USB_PORT_FEAT_POWER);
		USB_HUB_PRINTF("port %d returns %lX\n", i + 1, dev->status);
	}

	/* Wait at least 100 msec for power to become stable */
	mdelay(max(pgood_delay, (unsigned)100));
57e10b6c:	ea004e7d 	b	57e24568 <mdelay>

57e10b70 <usb_clear_port_feature>:
		USB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,
		USB_DT_HUB << 8, 0, data, size, USB_CNTL_TIMEOUT);
}

static int usb_clear_port_feature(struct usb_device *dev, int port, int feature)
{
57e10b70:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
57e10b74:	e1a02802 	lsl	r2, r2, #16
57e10b78:	e590c068 	ldr	ip, [r0, #104]	; 0x68
57e10b7c:	e1a02822 	lsr	r2, r2, #16
57e10b80:	e5903000 	ldr	r3, [r0]
57e10b84:	e1a01801 	lsl	r1, r1, #16
57e10b88:	e58d2000 	str	r2, [sp]
57e10b8c:	e3a02000 	mov	r2, #0
57e10b90:	e38cc102 	orr	ip, ip, #-2147483648	; 0x80000000
57e10b94:	e1a01821 	lsr	r1, r1, #16
57e10b98:	e58d2008 	str	r2, [sp, #8]
57e10b9c:	e58d200c 	str	r2, [sp, #12]
57e10ba0:	e2822064 	add	r2, r2, #100	; 0x64
57e10ba4:	e58d1004 	str	r1, [sp, #4]
57e10ba8:	e58d2010 	str	r2, [sp, #16]
57e10bac:	e18c1403 	orr	r1, ip, r3, lsl #8
57e10bb0:	e3a02001 	mov	r2, #1
57e10bb4:	e3a03023 	mov	r3, #35	; 0x23
57e10bb8:	ebfffbe7 	bl	57e0fb5c <usb_control_msg>
				USB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature,
				port, NULL, 0, USB_CNTL_TIMEOUT);
}
57e10bbc:	e28dd01c 	add	sp, sp, #28
57e10bc0:	e8bd8000 	pop	{pc}

57e10bc4 <usb_hub_reset>:
	mdelay(max(pgood_delay, (unsigned)100));
}

void usb_hub_reset(void)
{
	usb_hub_index = 0;
57e10bc4:	e59f3008 	ldr	r3, [pc, #8]	; 57e10bd4 <usb_hub_reset+0x10>
57e10bc8:	e3a02000 	mov	r2, #0
57e10bcc:	e5832000 	str	r2, [r3]
}
57e10bd0:	e12fff1e 	bx	lr
57e10bd4:	57e46cc0 	.word	0x57e46cc0

57e10bd8 <hub_port_reset>:
		return "12 Mb/s";
}

int hub_port_reset(struct usb_device *dev, int port,
			unsigned short *portstat)
{
57e10bd8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e10bdc:	e24dd080 	sub	sp, sp, #128	; 0x80
	int tries;
	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
57e10be0:	e28d403f 	add	r4, sp, #63	; 0x3f
		return "12 Mb/s";
}

int hub_port_reset(struct usb_device *dev, int port,
			unsigned short *portstat)
{
57e10be4:	e1a07000 	mov	r7, r0
57e10be8:	e1a09002 	mov	r9, r2
	int tries;
	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
57e10bec:	e3c4403f 	bic	r4, r4, #63	; 0x3f
	unsigned short portstatus, portchange;

	USB_HUB_PRINTF("hub_port_reset: resetting port %d...\n", port);
	for (tries = 0; tries < MAX_TRIES; tries++) {
57e10bf0:	e3a0a000 	mov	sl, #0

		usb_set_port_feature(dev, port + 1, USB_PORT_FEAT_RESET);
57e10bf4:	e2816001 	add	r6, r1, #1
57e10bf8:	e1a01006 	mov	r1, r6
57e10bfc:	e3a02004 	mov	r2, #4
57e10c00:	e1a00007 	mov	r0, r7
57e10c04:	ebffffb1 	bl	57e10ad0 <usb_set_port_feature>
		mdelay(200);
57e10c08:	e3a000c8 	mov	r0, #200	; 0xc8
57e10c0c:	eb004e55 	bl	57e24568 <mdelay>

		if (usb_get_port_status(dev, port + 1, portsts) < 0) {
57e10c10:	e1a00007 	mov	r0, r7
57e10c14:	e1a01006 	mov	r1, r6
57e10c18:	e1a02004 	mov	r2, r4
57e10c1c:	ebffff96 	bl	57e10a7c <usb_get_port_status>
57e10c20:	e3500000 	cmp	r0, #0
57e10c24:	ba000015 	blt	57e10c80 <hub_port_reset+0xa8>
			USB_HUB_PRINTF("get_port_status failed status %lX\n",
					dev->status);
			return -1;
		}
		portstatus = le16_to_cpu(portsts->wPortStatus);
		portchange = le16_to_cpu(portsts->wPortChange);
57e10c28:	e5d4b002 	ldrb	fp, [r4, #2]
		if (usb_get_port_status(dev, port + 1, portsts) < 0) {
			USB_HUB_PRINTF("get_port_status failed status %lX\n",
					dev->status);
			return -1;
		}
		portstatus = le16_to_cpu(portsts->wPortStatus);
57e10c2c:	e5d43000 	ldrb	r3, [r4]
57e10c30:	e5d45001 	ldrb	r5, [r4, #1]
			       "  USB_PORT_STAT_ENABLE %d\n",
			(portchange & USB_PORT_STAT_C_CONNECTION) ? 1 : 0,
			(portstatus & USB_PORT_STAT_CONNECTION) ? 1 : 0,
			(portstatus & USB_PORT_STAT_ENABLE) ? 1 : 0);

		if ((portchange & USB_PORT_STAT_C_CONNECTION) ||
57e10c34:	e21bb001 	ands	fp, fp, #1
		if (usb_get_port_status(dev, port + 1, portsts) < 0) {
			USB_HUB_PRINTF("get_port_status failed status %lX\n",
					dev->status);
			return -1;
		}
		portstatus = le16_to_cpu(portsts->wPortStatus);
57e10c38:	e1835405 	orr	r5, r3, r5, lsl #8
			       "  USB_PORT_STAT_ENABLE %d\n",
			(portchange & USB_PORT_STAT_C_CONNECTION) ? 1 : 0,
			(portstatus & USB_PORT_STAT_CONNECTION) ? 1 : 0,
			(portstatus & USB_PORT_STAT_ENABLE) ? 1 : 0);

		if ((portchange & USB_PORT_STAT_C_CONNECTION) ||
57e10c3c:	1a00000f 	bne	57e10c80 <hub_port_reset+0xa8>
57e10c40:	e3150001 	tst	r5, #1
57e10c44:	0a00000d 	beq	57e10c80 <hub_port_reset+0xa8>
		    !(portstatus & USB_PORT_STAT_CONNECTION))
			return -1;

		if (portstatus & USB_PORT_STAT_ENABLE)
57e10c48:	e3150002 	tst	r5, #2
57e10c4c:	0a000006 	beq	57e10c6c <hub_port_reset+0x94>
				"disabling port.\n", port + 1, MAX_TRIES);
		USB_HUB_PRINTF("Maybe the USB cable is bad?\n");
		return -1;
	}

	usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_C_RESET);
57e10c50:	e1a00007 	mov	r0, r7
57e10c54:	e1a01006 	mov	r1, r6
57e10c58:	e3a02014 	mov	r2, #20
57e10c5c:	ebffffc3 	bl	57e10b70 <usb_clear_port_feature>
	*portstat = portstatus;
57e10c60:	e1c950b0 	strh	r5, [r9]
	return 0;
57e10c64:	e1a0000b 	mov	r0, fp
57e10c68:	ea000005 	b	57e10c84 <hub_port_reset+0xac>
			return -1;

		if (portstatus & USB_PORT_STAT_ENABLE)
			break;

		mdelay(200);
57e10c6c:	e3a000c8 	mov	r0, #200	; 0xc8
	int tries;
	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
	unsigned short portstatus, portchange;

	USB_HUB_PRINTF("hub_port_reset: resetting port %d...\n", port);
	for (tries = 0; tries < MAX_TRIES; tries++) {
57e10c70:	e28aa001 	add	sl, sl, #1
			return -1;

		if (portstatus & USB_PORT_STAT_ENABLE)
			break;

		mdelay(200);
57e10c74:	eb004e3b 	bl	57e24568 <mdelay>
	int tries;
	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
	unsigned short portstatus, portchange;

	USB_HUB_PRINTF("hub_port_reset: resetting port %d...\n", port);
	for (tries = 0; tries < MAX_TRIES; tries++) {
57e10c78:	e35a0005 	cmp	sl, #5
57e10c7c:	1affffdd 	bne	57e10bf8 <hub_port_reset+0x20>
			(portstatus & USB_PORT_STAT_CONNECTION) ? 1 : 0,
			(portstatus & USB_PORT_STAT_ENABLE) ? 1 : 0);

		if ((portchange & USB_PORT_STAT_C_CONNECTION) ||
		    !(portstatus & USB_PORT_STAT_CONNECTION))
			return -1;
57e10c80:	e3e00000 	mvn	r0, #0
	}

	usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_C_RESET);
	*portstat = portstatus;
	return 0;
}
57e10c84:	e28dd080 	add	sp, sp, #128	; 0x80
57e10c88:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e10c8c <usb_hub_port_connect_change>:


void usb_hub_port_connect_change(struct usb_device *dev, int port)
{
57e10c8c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
57e10c90:	e24dd08c 	sub	sp, sp, #140	; 0x8c
	struct usb_device *usb;
	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
57e10c94:	e28d7043 	add	r7, sp, #67	; 0x43
57e10c98:	e3c7703f 	bic	r7, r7, #63	; 0x3f
	unsigned short portstatus;

	/* Check status */
	if (usb_get_port_status(dev, port + 1, portsts) < 0) {
57e10c9c:	e2815001 	add	r5, r1, #1
	return 0;
}


void usb_hub_port_connect_change(struct usb_device *dev, int port)
{
57e10ca0:	e1a06001 	mov	r6, r1
	struct usb_device *usb;
	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
	unsigned short portstatus;

	/* Check status */
	if (usb_get_port_status(dev, port + 1, portsts) < 0) {
57e10ca4:	e1a02007 	mov	r2, r7
57e10ca8:	e1a01005 	mov	r1, r5
	return 0;
}


void usb_hub_port_connect_change(struct usb_device *dev, int port)
{
57e10cac:	e1a04000 	mov	r4, r0
	struct usb_device *usb;
	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
	unsigned short portstatus;

	/* Check status */
	if (usb_get_port_status(dev, port + 1, portsts) < 0) {
57e10cb0:	ebffff71 	bl	57e10a7c <usb_get_port_status>
57e10cb4:	e3500000 	cmp	r0, #0
57e10cb8:	ba000037 	blt	57e10d9c <usb_hub_port_connect_change+0x110>
		USB_HUB_PRINTF("get_port_status failed\n");
		return;
	}

	portstatus = le16_to_cpu(portsts->wPortStatus);
57e10cbc:	e5d72001 	ldrb	r2, [r7, #1]
57e10cc0:	e5d73000 	ldrb	r3, [r7]
			portstatus,
			le16_to_cpu(portsts->wPortChange),
			portspeed(portstatus));

	/* Clear the connection change status */
	usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_C_CONNECTION);
57e10cc4:	e1a00004 	mov	r0, r4
	if (usb_get_port_status(dev, port + 1, portsts) < 0) {
		USB_HUB_PRINTF("get_port_status failed\n");
		return;
	}

	portstatus = le16_to_cpu(portsts->wPortStatus);
57e10cc8:	e1833402 	orr	r3, r3, r2, lsl #8
			portstatus,
			le16_to_cpu(portsts->wPortChange),
			portspeed(portstatus));

	/* Clear the connection change status */
	usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_C_CONNECTION);
57e10ccc:	e1a01005 	mov	r1, r5
57e10cd0:	e3a02010 	mov	r2, #16
	if (usb_get_port_status(dev, port + 1, portsts) < 0) {
		USB_HUB_PRINTF("get_port_status failed\n");
		return;
	}

	portstatus = le16_to_cpu(portsts->wPortStatus);
57e10cd4:	e1cd38b6 	strh	r3, [sp, #134]	; 0x86
			portstatus,
			le16_to_cpu(portsts->wPortChange),
			portspeed(portstatus));

	/* Clear the connection change status */
	usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_C_CONNECTION);
57e10cd8:	ebffffa4 	bl	57e10b70 <usb_clear_port_feature>

	/* Disconnect any existing devices under this port */
	if (((!(portstatus & USB_PORT_STAT_CONNECTION)) &&
57e10cdc:	e1dd38b6 	ldrh	r3, [sp, #134]	; 0x86
57e10ce0:	e3130003 	tst	r3, #3
57e10ce4:	0a000003 	beq	57e10cf8 <usb_hub_port_connect_change+0x6c>
	     (!(portstatus & USB_PORT_STAT_ENABLE))) || (dev->children[port])) {
57e10ce8:	e0842106 	add	r2, r4, r6, lsl #2
57e10cec:	e5922628 	ldr	r2, [r2, #1576]	; 0x628
57e10cf0:	e3520000 	cmp	r2, #0
57e10cf4:	0a000001 	beq	57e10d00 <usb_hub_port_connect_change+0x74>
		USB_HUB_PRINTF("usb_disconnect(&hub->children[port]);\n");
		/* Return now if nothing is connected */
		if (!(portstatus & USB_PORT_STAT_CONNECTION))
57e10cf8:	e3130001 	tst	r3, #1
57e10cfc:	0a000026 	beq	57e10d9c <usb_hub_port_connect_change+0x110>
			return;
	}
	mdelay(200);
57e10d00:	e3a000c8 	mov	r0, #200	; 0xc8
57e10d04:	eb004e17 	bl	57e24568 <mdelay>

	/* Reset the port */
	if (hub_port_reset(dev, port, &portstatus) < 0) {
57e10d08:	e1a00004 	mov	r0, r4
57e10d0c:	e1a01006 	mov	r1, r6
57e10d10:	e28d2086 	add	r2, sp, #134	; 0x86
57e10d14:	ebffffaf 	bl	57e10bd8 <hub_port_reset>
57e10d18:	e3500000 	cmp	r0, #0
57e10d1c:	aa000003 	bge	57e10d30 <usb_hub_port_connect_change+0xa4>
		printf("cannot reset port %i!?\n", port + 1);
57e10d20:	e1a01005 	mov	r1, r5
57e10d24:	e59f0078 	ldr	r0, [pc, #120]	; 57e10da4 <usb_hub_port_connect_change+0x118>
57e10d28:	ebffe1c7 	bl	57e0944c <printf>
		return;
57e10d2c:	ea00001a 	b	57e10d9c <usb_hub_port_connect_change+0x110>
	}

	mdelay(200);
57e10d30:	e3a000c8 	mov	r0, #200	; 0xc8
57e10d34:	eb004e0b 	bl	57e24568 <mdelay>

	/* Allocate a new device struct for it */
	usb = usb_alloc_new_device(dev->controller);
57e10d38:	e5940648 	ldr	r0, [r4, #1608]	; 0x648
57e10d3c:	ebfffd81 	bl	57e10348 <usb_alloc_new_device>

	if (portstatus & USB_PORT_STAT_HIGH_SPEED)
57e10d40:	e1dd38b6 	ldrh	r3, [sp, #134]	; 0x86
57e10d44:	e3130b01 	tst	r3, #1024	; 0x400
		usb->speed = USB_SPEED_HIGH;
57e10d48:	13a03003 	movne	r3, #3
	mdelay(200);

	/* Allocate a new device struct for it */
	usb = usb_alloc_new_device(dev->controller);

	if (portstatus & USB_PORT_STAT_HIGH_SPEED)
57e10d4c:	1a000002 	bne	57e10d5c <usb_hub_port_connect_change+0xd0>
		usb->speed = USB_SPEED_HIGH;
	else if (portstatus & USB_PORT_STAT_LOW_SPEED)
57e10d50:	e3130c02 	tst	r3, #512	; 0x200
		usb->speed = USB_SPEED_LOW;
57e10d54:	13a03001 	movne	r3, #1
	else
		usb->speed = USB_SPEED_FULL;
57e10d58:	03a03002 	moveq	r3, #2

	dev->children[port] = usb;
57e10d5c:	e2866f62 	add	r6, r6, #392	; 0x188
57e10d60:	e2866002 	add	r6, r6, #2
	if (portstatus & USB_PORT_STAT_HIGH_SPEED)
		usb->speed = USB_SPEED_HIGH;
	else if (portstatus & USB_PORT_STAT_LOW_SPEED)
		usb->speed = USB_SPEED_LOW;
	else
		usb->speed = USB_SPEED_FULL;
57e10d64:	e5803004 	str	r3, [r0, #4]

	dev->children[port] = usb;
57e10d68:	e7840106 	str	r0, [r4, r6, lsl #2]
	usb->parent = dev;
57e10d6c:	e5804624 	str	r4, [r0, #1572]	; 0x624
	usb->portnr = port + 1;
57e10d70:	e5805620 	str	r5, [r0, #1568]	; 0x620
	/* Run it through the hoops (find a driver, etc) */
	if (usb_new_device(usb)) {
57e10d74:	ebfffdaa 	bl	57e10424 <usb_new_device>
57e10d78:	e3500000 	cmp	r0, #0
57e10d7c:	0a000006 	beq	57e10d9c <usb_hub_port_connect_change+0x110>
		/* Woops, disable the port */
		usb_free_device();
57e10d80:	ebfffd94 	bl	57e103d8 <usb_free_device>
		dev->children[port] = NULL;
57e10d84:	e3a03000 	mov	r3, #0
57e10d88:	e7843106 	str	r3, [r4, r6, lsl #2]
		USB_HUB_PRINTF("hub: disabling port %d\n", port + 1);
		usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_ENABLE);
57e10d8c:	e1a00004 	mov	r0, r4
57e10d90:	e1a01005 	mov	r1, r5
57e10d94:	e3a02001 	mov	r2, #1
57e10d98:	ebffff74 	bl	57e10b70 <usb_clear_port_feature>
	}
}
57e10d9c:	e28dd08c 	add	sp, sp, #140	; 0x8c
57e10da0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
57e10da4:	57e32dbf 	.word	0x57e32dbf

57e10da8 <usb_hub_configure>:


static int usb_hub_configure(struct usb_device *dev)
{
57e10da8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	usb_hub_index = 0;
}

static struct usb_hub_device *usb_hub_allocate(void)
{
	if (usb_hub_index < USB_MAX_HUB)
57e10dac:	e59f32c8 	ldr	r3, [pc, #712]	; 57e1107c <usb_hub_configure+0x2d4>
	}
}


static int usb_hub_configure(struct usb_device *dev)
{
57e10db0:	e24dde2e 	sub	sp, sp, #736	; 0x2e0
	usb_hub_index = 0;
}

static struct usb_hub_device *usb_hub_allocate(void)
{
	if (usb_hub_index < USB_MAX_HUB)
57e10db4:	e5937000 	ldr	r7, [r3]
	}
}


static int usb_hub_configure(struct usb_device *dev)
{
57e10db8:	e1a04000 	mov	r4, r0
	usb_hub_index = 0;
}

static struct usb_hub_device *usb_hub_allocate(void)
{
	if (usb_hub_index < USB_MAX_HUB)
57e10dbc:	e357000f 	cmp	r7, #15
57e10dc0:	ca00000e 	bgt	57e10e00 <usb_hub_configure+0x58>
		return &hub_dev[usb_hub_index++];
57e10dc4:	e1a0a207 	lsl	sl, r7, #4
57e10dc8:	e2872001 	add	r2, r7, #1


static int usb_hub_configure(struct usb_device *dev)
{
	int i;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, USB_BUFSIZ);
57e10dcc:	e28d605f 	add	r6, sp, #95	; 0x5f
}

static struct usb_hub_device *usb_hub_allocate(void)
{
	if (usb_hub_index < USB_MAX_HUB)
		return &hub_dev[usb_hub_index++];
57e10dd0:	e2839004 	add	r9, r3, #4


static int usb_hub_configure(struct usb_device *dev)
{
	int i;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, USB_BUFSIZ);
57e10dd4:	e3c6603f 	bic	r6, r6, #63	; 0x3f
}

static struct usb_hub_device *usb_hub_allocate(void)
{
	if (usb_hub_index < USB_MAX_HUB)
		return &hub_dev[usb_hub_index++];
57e10dd8:	e683200a 	str	r2, [r3], sl

	/* "allocate" Hub device */
	hub = usb_hub_allocate();
	if (hub == NULL)
		return -1;
	hub->pusb_dev = dev;
57e10ddc:	e5830004 	str	r0, [r3, #4]
	/* Get the the hub descriptor */
	if (usb_get_hub_descriptor(dev, buffer, 4) < 0) {
57e10de0:	e1a01006 	mov	r1, r6
57e10de4:	e3a02004 	mov	r2, #4

	/* "allocate" Hub device */
	hub = usb_hub_allocate();
	if (hub == NULL)
		return -1;
	hub->pusb_dev = dev;
57e10de8:	e283b004 	add	fp, r3, #4
	/* Get the the hub descriptor */
	if (usb_get_hub_descriptor(dev, buffer, 4) < 0) {
57e10dec:	ebffff0d 	bl	57e10a28 <usb_get_hub_descriptor>
57e10df0:	e3500000 	cmp	r0, #0
}

static struct usb_hub_device *usb_hub_allocate(void)
{
	if (usb_hub_index < USB_MAX_HUB)
		return &hub_dev[usb_hub_index++];
57e10df4:	e089500a 	add	r5, r9, sl
	hub = usb_hub_allocate();
	if (hub == NULL)
		return -1;
	hub->pusb_dev = dev;
	/* Get the the hub descriptor */
	if (usb_get_hub_descriptor(dev, buffer, 4) < 0) {
57e10df8:	ba000099 	blt	57e11064 <usb_hub_configure+0x2bc>
57e10dfc:	ea000003 	b	57e10e10 <usb_hub_configure+0x68>
static struct usb_hub_device *usb_hub_allocate(void)
{
	if (usb_hub_index < USB_MAX_HUB)
		return &hub_dev[usb_hub_index++];

	printf("ERROR: USB_MAX_HUB (%d) reached\n", USB_MAX_HUB);
57e10e00:	e3a01010 	mov	r1, #16
57e10e04:	e59f0274 	ldr	r0, [pc, #628]	; 57e11080 <usb_hub_configure+0x2d8>
57e10e08:	ebffe18f 	bl	57e0944c <printf>
57e10e0c:	ea000094 	b	57e11064 <usb_hub_configure+0x2bc>
				"descriptor - too long: %d\n",
				descriptor->bLength);
		return -1;
	}

	if (usb_get_hub_descriptor(dev, buffer, descriptor->bLength) < 0) {
57e10e10:	e1a00004 	mov	r0, r4
57e10e14:	e1a01006 	mov	r1, r6
57e10e18:	e5d62000 	ldrb	r2, [r6]
57e10e1c:	ebffff01 	bl	57e10a28 <usb_get_hub_descriptor>
57e10e20:	e3500000 	cmp	r0, #0
57e10e24:	ba00008e 	blt	57e11064 <usb_hub_configure+0x2bc>
		USB_HUB_PRINTF("usb_hub_configure: failed to get hub " \
				"descriptor 2nd giving up %lX\n", dev->status);
		return -1;
	}
	memcpy((unsigned char *)&hub->desc, buffer, descriptor->bLength);
57e10e28:	e1a01006 	mov	r1, r6
57e10e2c:	e5d62000 	ldrb	r2, [r6]
57e10e30:	e2850004 	add	r0, r5, #4
57e10e34:	eb004d34 	bl	57e2430c <memcpy>

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
57e10e38:	e5d62004 	ldrb	r2, [r6, #4]
57e10e3c:	e5d63003 	ldrb	r3, [r6, #3]
			&descriptor->wHubCharacteristics)),
			&hub->desc.wHubCharacteristics);
	/* set the bitmap */
	bitmap = (unsigned char *)&hub->desc.DeviceRemovable[0];
	/* devices not removable by default */
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8);
57e10e40:	e3a010ff 	mov	r1, #255	; 0xff
57e10e44:	e1833402 	orr	r3, r3, r2, lsl #8
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
57e10e48:	e5c53007 	strb	r3, [r5, #7]
	*p++ = val >> 8;
57e10e4c:	e1a03423 	lsr	r3, r3, #8
57e10e50:	e5c53008 	strb	r3, [r5, #8]
57e10e54:	e3a02002 	mov	r2, #2
57e10e58:	e285000b 	add	r0, r5, #11
	bitmap = (unsigned char *)&hub->desc.PortPowerCtrlMask[0];
57e10e5c:	e089a00a 	add	sl, r9, sl
			&descriptor->wHubCharacteristics)),
			&hub->desc.wHubCharacteristics);
	/* set the bitmap */
	bitmap = (unsigned char *)&hub->desc.DeviceRemovable[0];
	/* devices not removable by default */
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8);
57e10e60:	eb004d05 	bl	57e2427c <memset>
	bitmap = (unsigned char *)&hub->desc.PortPowerCtrlMask[0];
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8); /* PowerMask = 1B */
57e10e64:	e3a010ff 	mov	r1, #255	; 0xff
57e10e68:	e28a000d 	add	r0, sl, #13
57e10e6c:	e3a02002 	mov	r2, #2
57e10e70:	eb004d01 	bl	57e2427c <memset>

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
57e10e74:	e5db1006 	ldrb	r1, [fp, #6]
57e10e78:	e3a03000 	mov	r3, #0
57e10e7c:	e2811008 	add	r1, r1, #8
57e10e80:	e1a011c1 	asr	r1, r1, #3
		usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_ENABLE);
	}
}


static int usb_hub_configure(struct usb_device *dev)
57e10e84:	e0860003 	add	r0, r6, r3
57e10e88:	e0852003 	add	r2, r5, r3
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8);
	bitmap = (unsigned char *)&hub->desc.PortPowerCtrlMask[0];
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8); /* PowerMask = 1B */

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
		hub->desc.DeviceRemovable[i] = descriptor->DeviceRemovable[i];
57e10e8c:	e5d00007 	ldrb	r0, [r0, #7]
	/* devices not removable by default */
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8);
	bitmap = (unsigned char *)&hub->desc.PortPowerCtrlMask[0];
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8); /* PowerMask = 1B */

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
57e10e90:	e2833001 	add	r3, r3, #1
57e10e94:	e1530001 	cmp	r3, r1
		hub->desc.DeviceRemovable[i] = descriptor->DeviceRemovable[i];
57e10e98:	e5c2000b 	strb	r0, [r2, #11]
	/* devices not removable by default */
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8);
	bitmap = (unsigned char *)&hub->desc.PortPowerCtrlMask[0];
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8); /* PowerMask = 1B */

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
57e10e9c:	bafffff8 	blt	57e10e84 <usb_hub_configure+0xdc>
		usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_ENABLE);
	}
}


static int usb_hub_configure(struct usb_device *dev)
57e10ea0:	e59f31dc 	ldr	r3, [pc, #476]	; 57e11084 <usb_hub_configure+0x2dc>
57e10ea4:	e2862008 	add	r2, r6, #8
57e10ea8:	e0837207 	add	r7, r3, r7, lsl #4
57e10eac:	e287700c 	add	r7, r7, #12
57e10eb0:	e3a03000 	mov	r3, #0

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
		hub->desc.DeviceRemovable[i] = descriptor->DeviceRemovable[i];

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
		hub->desc.PortPowerCtrlMask[i] = descriptor->PortPowerCtrlMask[i];
57e10eb4:	e5f20001 	ldrb	r0, [r2, #1]!
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8); /* PowerMask = 1B */

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
		hub->desc.DeviceRemovable[i] = descriptor->DeviceRemovable[i];

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
57e10eb8:	e2833001 	add	r3, r3, #1
57e10ebc:	e1530001 	cmp	r3, r1
		hub->desc.PortPowerCtrlMask[i] = descriptor->PortPowerCtrlMask[i];
57e10ec0:	e5e70001 	strb	r0, [r7, #1]!
	memset(bitmap, 0xff, (USB_MAXCHILDREN+1+7)/8); /* PowerMask = 1B */

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
		hub->desc.DeviceRemovable[i] = descriptor->DeviceRemovable[i];

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
57e10ec4:	bafffffa 	blt	57e10eb4 <usb_hub_configure+0x10c>
		hub->desc.PortPowerCtrlMask[i] = descriptor->PortPowerCtrlMask[i];

	dev->maxchild = descriptor->bNbrPorts;
57e10ec8:	e5d63002 	ldrb	r3, [r6, #2]
				port, NULL, 0, USB_CNTL_TIMEOUT);
}

static int usb_get_hub_status(struct usb_device *dev, void *data)
{
	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
57e10ecc:	e5941000 	ldr	r1, [r4]
		hub->desc.DeviceRemovable[i] = descriptor->DeviceRemovable[i];

	for (i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++)
		hub->desc.PortPowerCtrlMask[i] = descriptor->PortPowerCtrlMask[i];

	dev->maxchild = descriptor->bNbrPorts;
57e10ed0:	e584361c 	str	r3, [r4, #1564]	; 0x61c
				port, NULL, 0, USB_CNTL_TIMEOUT);
}

static int usb_get_hub_status(struct usb_device *dev, void *data)
{
	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
57e10ed4:	e5943068 	ldr	r3, [r4, #104]	; 0x68
57e10ed8:	e3a02004 	mov	r2, #4
57e10edc:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
57e10ee0:	e3a07000 	mov	r7, #0
57e10ee4:	e3833080 	orr	r3, r3, #128	; 0x80
57e10ee8:	e58d200c 	str	r2, [sp, #12]
57e10eec:	e2822060 	add	r2, r2, #96	; 0x60
57e10ef0:	e58d2010 	str	r2, [sp, #16]
57e10ef4:	e1831401 	orr	r1, r3, r1, lsl #8
57e10ef8:	e1a00004 	mov	r0, r4
57e10efc:	e1a02007 	mov	r2, r7
57e10f00:	e3a030a0 	mov	r3, #160	; 0xa0
57e10f04:	e58d7000 	str	r7, [sp]
57e10f08:	e58d7004 	str	r7, [sp, #4]
57e10f0c:	e58d6008 	str	r6, [sp, #8]
57e10f10:	ebfffb11 	bl	57e0fb5c <usb_control_msg>
		USB_HUB_PRINTF("usb_hub_configure: failed to get Status - " \
				"too long: %d\n", descriptor->bLength);
		return -1;
	}

	if (usb_get_hub_status(dev, buffer) < 0) {
57e10f14:	e1500007 	cmp	r0, r7
57e10f18:	ba000051 	blt	57e11064 <usb_hub_configure+0x2bc>
		(le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? \
		"" : "no ");
	usb_hub_power_on(hub);

	for (i = 0; i < dev->maxchild; i++) {
		ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
57e10f1c:	e28d9fa7 	add	r9, sp, #668	; 0x29c
		(le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_LOCAL_POWER) ? \
		"lost (inactive)" : "good");
	USB_HUB_PRINTF("%sover-current condition exists\n",
		(le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? \
		"" : "no ");
	usb_hub_power_on(hub);
57e10f20:	e1a00005 	mov	r0, r5

	for (i = 0; i < dev->maxchild; i++) {
		ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
57e10f24:	e2899003 	add	r9, r9, #3
		(le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_LOCAL_POWER) ? \
		"lost (inactive)" : "good");
	USB_HUB_PRINTF("%sover-current condition exists\n",
		(le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? \
		"" : "no ");
	usb_hub_power_on(hub);
57e10f28:	ebfffefd 	bl	57e10b24 <usb_hub_power_on>
57e10f2c:	e1a0b004 	mov	fp, r4

	for (i = 0; i < dev->maxchild; i++) {
		ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
57e10f30:	e3c9903f 	bic	r9, r9, #63	; 0x3f
	USB_HUB_PRINTF("%sover-current condition exists\n",
		(le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? \
		"" : "no ");
	usb_hub_power_on(hub);

	for (i = 0; i < dev->maxchild; i++) {
57e10f34:	ea000045 	b	57e11050 <usb_hub_configure+0x2a8>
		ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
		unsigned short portstatus, portchange;
		int ret;
		ulong start = get_timer(0);
57e10f38:	e3a00000 	mov	r0, #0
57e10f3c:	ebffbef2 	bl	57e00b0c <get_timer>
		usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_ENABLE);
	}
}


static int usb_hub_configure(struct usb_device *dev)
57e10f40:	e2876001 	add	r6, r7, #1

	for (i = 0; i < dev->maxchild; i++) {
		ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
		unsigned short portstatus, portchange;
		int ret;
		ulong start = get_timer(0);
57e10f44:	e58d001c 	str	r0, [sp, #28]
		 *    a few broken pen drives and taking the max * 1.5 approach
		 *  - connection_change and connection state to report same
		 *    state
		 */
		do {
			ret = usb_get_port_status(dev, i + 1, portsts);
57e10f48:	e1a00004 	mov	r0, r4
57e10f4c:	e1a01006 	mov	r1, r6
57e10f50:	e1a02009 	mov	r2, r9
57e10f54:	ebfffec8 	bl	57e10a7c <usb_get_port_status>
			if (ret < 0) {
57e10f58:	e3500000 	cmp	r0, #0
57e10f5c:	ba000039 	blt	57e11048 <usb_hub_configure+0x2a0>
				USB_HUB_PRINTF("get_port_status failed\n");
				break;
			}

			portstatus = le16_to_cpu(portsts->wPortStatus);
57e10f60:	e5d93000 	ldrb	r3, [r9]
57e10f64:	e5d92001 	ldrb	r2, [r9, #1]
57e10f68:	e1832402 	orr	r2, r3, r2, lsl #8
57e10f6c:	e58d2018 	str	r2, [sp, #24]
			portchange = le16_to_cpu(portsts->wPortChange);
57e10f70:	e5d93002 	ldrb	r3, [r9, #2]
57e10f74:	e5d9a003 	ldrb	sl, [r9, #3]

			if ((portchange & USB_PORT_STAT_C_CONNECTION) ==
57e10f78:	e183a40a 	orr	sl, r3, sl, lsl #8
57e10f7c:	e022300a 	eor	r3, r2, sl
57e10f80:	e3130001 	tst	r3, #1
57e10f84:	0a000039 	beq	57e11070 <usb_hub_configure+0x2c8>
				(portstatus & USB_PORT_STAT_CONNECTION))
				break;

			mdelay(100);
57e10f88:	e3a00064 	mov	r0, #100	; 0x64
57e10f8c:	eb004d75 	bl	57e24568 <mdelay>
		} while (get_timer(start) < CONFIG_SYS_HZ * 10);
57e10f90:	e59d001c 	ldr	r0, [sp, #28]
57e10f94:	ebffbedc 	bl	57e00b0c <get_timer>
57e10f98:	e59f20e8 	ldr	r2, [pc, #232]	; 57e11088 <usb_hub_configure+0x2e0>
57e10f9c:	e1500002 	cmp	r0, r2
57e10fa0:	9affffe8 	bls	57e10f48 <usb_hub_configure+0x1a0>
57e10fa4:	ea000031 	b	57e11070 <usb_hub_configure+0x2c8>
		USB_HUB_PRINTF("Port %d Status %X Change %X\n",
				i + 1, portstatus, portchange);

		if (portchange & USB_PORT_STAT_C_CONNECTION) {
			USB_HUB_PRINTF("port %d connection change\n", i + 1);
			usb_hub_port_connect_change(dev, i);
57e10fa8:	e1a00004 	mov	r0, r4
57e10fac:	e1a01007 	mov	r1, r7
57e10fb0:	ebffff35 	bl	57e10c8c <usb_hub_port_connect_change>
		}
		if (portchange & USB_PORT_STAT_C_ENABLE) {
57e10fb4:	e31a0002 	tst	sl, #2
57e10fb8:	0a00000d 	beq	57e10ff4 <usb_hub_configure+0x24c>
			USB_HUB_PRINTF("port %d enable change, status %x\n",
					i + 1, portstatus);
			usb_clear_port_feature(dev, i + 1,
57e10fbc:	e3a02011 	mov	r2, #17
57e10fc0:	e1a00004 	mov	r0, r4
57e10fc4:	e1a01006 	mov	r1, r6
57e10fc8:	ebfffee8 	bl	57e10b70 <usb_clear_port_feature>
						USB_PORT_FEAT_C_ENABLE);

			/* EM interference sometimes causes bad shielded USB
			 * devices to be shutdown by the hub, this hack enables
			 * them again. Works at least with mouse driver */
			if (!(portstatus & USB_PORT_STAT_ENABLE) &&
57e10fcc:	e59d2018 	ldr	r2, [sp, #24]
57e10fd0:	e2023003 	and	r3, r2, #3
57e10fd4:	e3530001 	cmp	r3, #1
57e10fd8:	1a000005 	bne	57e10ff4 <usb_hub_configure+0x24c>
			     (portstatus & USB_PORT_STAT_CONNECTION) &&
57e10fdc:	e59b3628 	ldr	r3, [fp, #1576]	; 0x628
57e10fe0:	e3530000 	cmp	r3, #0
57e10fe4:	0a000002 	beq	57e10ff4 <usb_hub_configure+0x24c>
			     ((dev->children[i]))) {
				USB_HUB_PRINTF("already running port %i "  \
						"disabled by hub (EMI?), " \
						"re-enabling...\n", i + 1);
					usb_hub_port_connect_change(dev, i);
57e10fe8:	e1a00004 	mov	r0, r4
57e10fec:	e1a01007 	mov	r1, r7
57e10ff0:	ebffff25 	bl	57e10c8c <usb_hub_port_connect_change>
			}
		}
		if (portstatus & USB_PORT_STAT_SUSPEND) {
57e10ff4:	e59d3018 	ldr	r3, [sp, #24]
57e10ff8:	e3130004 	tst	r3, #4
57e10ffc:	0a000003 	beq	57e11010 <usb_hub_configure+0x268>
			USB_HUB_PRINTF("port %d suspend change\n", i + 1);
			usb_clear_port_feature(dev, i + 1,
57e11000:	e1a00004 	mov	r0, r4
57e11004:	e1a01006 	mov	r1, r6
57e11008:	e3a02002 	mov	r2, #2
57e1100c:	ebfffed7 	bl	57e10b70 <usb_clear_port_feature>
						USB_PORT_FEAT_SUSPEND);
		}

		if (portchange & USB_PORT_STAT_C_OVERCURRENT) {
57e11010:	e31a0008 	tst	sl, #8
57e11014:	0a000005 	beq	57e11030 <usb_hub_configure+0x288>
			USB_HUB_PRINTF("port %d over-current change\n", i + 1);
			usb_clear_port_feature(dev, i + 1,
57e11018:	e1a00004 	mov	r0, r4
57e1101c:	e1a01006 	mov	r1, r6
57e11020:	e3a02013 	mov	r2, #19
57e11024:	ebfffed1 	bl	57e10b70 <usb_clear_port_feature>
						USB_PORT_FEAT_C_OVER_CURRENT);
			usb_hub_power_on(hub);
57e11028:	e1a00005 	mov	r0, r5
57e1102c:	ebfffebc 	bl	57e10b24 <usb_hub_power_on>
		}

		if (portchange & USB_PORT_STAT_C_RESET) {
57e11030:	e31a0010 	tst	sl, #16
57e11034:	0a000003 	beq	57e11048 <usb_hub_configure+0x2a0>
			USB_HUB_PRINTF("port %d reset change\n", i + 1);
			usb_clear_port_feature(dev, i + 1,
57e11038:	e1a00004 	mov	r0, r4
57e1103c:	e1a01006 	mov	r1, r6
57e11040:	e3a02014 	mov	r2, #20
57e11044:	ebfffec9 	bl	57e10b70 <usb_clear_port_feature>
57e11048:	e28bb004 	add	fp, fp, #4
	USB_HUB_PRINTF("%sover-current condition exists\n",
		(le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? \
		"" : "no ");
	usb_hub_power_on(hub);

	for (i = 0; i < dev->maxchild; i++) {
57e1104c:	e1a07006 	mov	r7, r6
57e11050:	e594361c 	ldr	r3, [r4, #1564]	; 0x61c
57e11054:	e1570003 	cmp	r7, r3
57e11058:	baffffb6 	blt	57e10f38 <usb_hub_configure+0x190>
			usb_clear_port_feature(dev, i + 1,
						USB_PORT_FEAT_C_RESET);
		}
	} /* end for i all ports */

	return 0;
57e1105c:	e3a00000 	mov	r0, #0
57e11060:	ea000000 	b	57e11068 <usb_hub_configure+0x2c0>
	}

	if (usb_get_hub_status(dev, buffer) < 0) {
		USB_HUB_PRINTF("usb_hub_configure: failed to get Status %lX\n",
				dev->status);
		return -1;
57e11064:	e3e00000 	mvn	r0, #0
						USB_PORT_FEAT_C_RESET);
		}
	} /* end for i all ports */

	return 0;
}
57e11068:	e28dde2e 	add	sp, sp, #736	; 0x2e0
57e1106c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			continue;

		USB_HUB_PRINTF("Port %d Status %X Change %X\n",
				i + 1, portstatus, portchange);

		if (portchange & USB_PORT_STAT_C_CONNECTION) {
57e11070:	e31a0001 	tst	sl, #1
57e11074:	0affffce 	beq	57e10fb4 <usb_hub_configure+0x20c>
57e11078:	eaffffca 	b	57e10fa8 <usb_hub_configure+0x200>
57e1107c:	57e46cc0 	.word	0x57e46cc0
57e11080:	57e32dd7 	.word	0x57e32dd7
57e11084:	57e46cc4 	.word	0x57e46cc4
57e11088:	0000270f 	.word	0x0000270f

57e1108c <usb_hub_probe>:
	struct usb_endpoint_descriptor *ep;
	int ret;

	iface = &dev->config.if_desc[ifnum];
	/* Is it a hub? */
	if (iface->desc.bInterfaceClass != USB_CLASS_HUB)
57e1108c:	e3a0309c 	mov	r3, #156	; 0x9c
57e11090:	e0230391 	mla	r3, r1, r3, r0
57e11094:	e5d31121 	ldrb	r1, [r3, #289]	; 0x121
57e11098:	e2832f46 	add	r2, r3, #280	; 0x118
57e1109c:	e3510009 	cmp	r1, #9
57e110a0:	1a00000e 	bne	57e110e0 <usb_hub_probe+0x54>
		return 0;
	/* Some hubs have a subclass of 1, which AFAICT according to the */
	/*  specs is not defined, but it works */
	if ((iface->desc.bInterfaceSubClass != 0) &&
57e110a4:	e5d31122 	ldrb	r1, [r3, #290]	; 0x122
57e110a8:	e3510001 	cmp	r1, #1
57e110ac:	8a00000b 	bhi	57e110e0 <usb_hub_probe+0x54>
	    (iface->desc.bInterfaceSubClass != 1))
		return 0;
	/* Multiple endpoints? What kind of mutant ninja-hub is this? */
	if (iface->desc.bNumEndpoints != 1)
57e110b0:	e5d22008 	ldrb	r2, [r2, #8]
57e110b4:	e3520001 	cmp	r2, #1
57e110b8:	1a000008 	bne	57e110e0 <usb_hub_probe+0x54>
		return 0;
	ep = &iface->ep_desc[0];
	/* Output endpoint? Curiousier and curiousier.. */
	if (!(ep->bEndpointAddress & USB_DIR_IN))
57e110bc:	e2832e12 	add	r2, r3, #288	; 0x120
57e110c0:	e1d220da 	ldrsb	r2, [r2, #10]
57e110c4:	e3520000 	cmp	r2, #0
57e110c8:	aa000004 	bge	57e110e0 <usb_hub_probe+0x54>
		return 0;
	/* If it's not an interrupt endpoint, we'd better punt! */
	if ((ep->bmAttributes & 3) != 3)
57e110cc:	e5d3312b 	ldrb	r3, [r3, #299]	; 0x12b
57e110d0:	e2033003 	and	r3, r3, #3
57e110d4:	e3530003 	cmp	r3, #3
57e110d8:	1a000000 	bne	57e110e0 <usb_hub_probe+0x54>
		return 0;
	/* We found a hub */
	USB_HUB_PRINTF("USB hub found\n");
	ret = usb_hub_configure(dev);
57e110dc:	eaffff31 	b	57e10da8 <usb_hub_configure>
	return ret;
}
57e110e0:	e3a00000 	mov	r0, #0
57e110e4:	e12fff1e 	bx	lr

57e110e8 <usb_stor_irq>:
}

static int usb_stor_irq(struct usb_device *dev)
{
	struct us_data *us;
	us = (struct us_data *)dev->privptr;
57e110e8:	e5903610 	ldr	r3, [r0, #1552]	; 0x610

	if (us->ip_wanted)
		us->ip_wanted = 0;
	return 0;
}
57e110ec:	e3a00000 	mov	r0, #0
static int usb_stor_irq(struct usb_device *dev)
{
	struct us_data *us;
	us = (struct us_data *)dev->privptr;

	if (us->ip_wanted)
57e110f0:	e5932018 	ldr	r2, [r3, #24]
57e110f4:	e3520000 	cmp	r2, #0
		us->ip_wanted = 0;
57e110f8:	13a02000 	movne	r2, #0
57e110fc:	15832018 	strne	r2, [r3, #24]
	return 0;
}
57e11100:	e12fff1e 	bx	lr

57e11104 <usb_stor_BBB_reset>:
	/* if we get here, we're done and successful */
	return 0;
}

static int usb_stor_BBB_reset(struct us_data *us)
{
57e11104:	e92d4010 	push	{r4, lr}
57e11108:	e1a04000 	mov	r4, r0
	 * If the reset doesn't succeed, the device should be port reset.
	 *
	 * This comment stolen from FreeBSD's /sys/dev/usb/umass.c.
	 */
	USB_STOR_PRINTF("BBB_reset\n");
	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev, 0),
57e1110c:	e5900000 	ldr	r0, [r0]
	/* if we get here, we're done and successful */
	return 0;
}

static int usb_stor_BBB_reset(struct us_data *us)
{
57e11110:	e24dd018 	sub	sp, sp, #24
	 * If the reset doesn't succeed, the device should be port reset.
	 *
	 * This comment stolen from FreeBSD's /sys/dev/usb/umass.c.
	 */
	USB_STOR_PRINTF("BBB_reset\n");
	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev, 0),
57e11114:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e11118:	e5901000 	ldr	r1, [r0]
57e1111c:	e3a02000 	mov	r2, #0
57e11120:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
57e11124:	e58d2000 	str	r2, [sp]
57e11128:	e5d4c008 	ldrb	ip, [r4, #8]
57e1112c:	e58d2008 	str	r2, [sp, #8]
57e11130:	e58d200c 	str	r2, [sp, #12]
57e11134:	e2822f7d 	add	r2, r2, #500	; 0x1f4
57e11138:	e58d2010 	str	r2, [sp, #16]
57e1113c:	e1831401 	orr	r1, r3, r1, lsl #8
57e11140:	e3a020ff 	mov	r2, #255	; 0xff
57e11144:	e3a03021 	mov	r3, #33	; 0x21
57e11148:	e58dc004 	str	ip, [sp, #4]
57e1114c:	ebfffa82 	bl	57e0fb5c <usb_control_msg>
				 US_BBB_RESET,
				 USB_TYPE_CLASS | USB_RECIP_INTERFACE,
				 0, us->ifnum, NULL, 0, USB_CNTL_TIMEOUT * 5);

	if ((result < 0) && (us->pusb_dev->status & USB_ST_STALLED)) {
57e11150:	e3500000 	cmp	r0, #0
57e11154:	aa000004 	bge	57e1116c <usb_stor_BBB_reset+0x68>
57e11158:	e5943000 	ldr	r3, [r4]
57e1115c:	e5933614 	ldr	r3, [r3, #1556]	; 0x614
57e11160:	e3130002 	tst	r3, #2
		USB_STOR_PRINTF("RESET:stall\n");
		return -1;
57e11164:	13e00000 	mvnne	r0, #0
	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev, 0),
				 US_BBB_RESET,
				 USB_TYPE_CLASS | USB_RECIP_INTERFACE,
				 0, us->ifnum, NULL, 0, USB_CNTL_TIMEOUT * 5);

	if ((result < 0) && (us->pusb_dev->status & USB_ST_STALLED)) {
57e11168:	1a000017 	bne	57e111cc <usb_stor_BBB_reset+0xc8>
		USB_STOR_PRINTF("RESET:stall\n");
		return -1;
	}

	/* long wait for reset */
	mdelay(150);
57e1116c:	e3a00096 	mov	r0, #150	; 0x96
57e11170:	eb004cfc 	bl	57e24568 <mdelay>
	USB_STOR_PRINTF("BBB_reset result %d: status %lX reset\n", result,
			us->pusb_dev->status);
	pipe = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
57e11174:	e5940000 	ldr	r0, [r4]
57e11178:	e5d41009 	ldrb	r1, [r4, #9]
57e1117c:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e11180:	e5902000 	ldr	r2, [r0]
57e11184:	e3833103 	orr	r3, r3, #-1073741824	; 0xc0000000
57e11188:	e3833080 	orr	r3, r3, #128	; 0x80
57e1118c:	e1833402 	orr	r3, r3, r2, lsl #8
	result = usb_clear_halt(us->pusb_dev, pipe);
57e11190:	e1831781 	orr	r1, r3, r1, lsl #15
57e11194:	ebfffb40 	bl	57e0fe9c <usb_clear_halt>
	/* long wait for reset */
	mdelay(150);
57e11198:	e3a00096 	mov	r0, #150	; 0x96
57e1119c:	eb004cf1 	bl	57e24568 <mdelay>
	USB_STOR_PRINTF("BBB_reset result %d: status %lX clearing IN endpoint\n",
			result, us->pusb_dev->status);
	/* long wait for reset */
	pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
57e111a0:	e5940000 	ldr	r0, [r4]
57e111a4:	e5d4100a 	ldrb	r1, [r4, #10]
57e111a8:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e111ac:	e5902000 	ldr	r2, [r0]
57e111b0:	e3833103 	orr	r3, r3, #-1073741824	; 0xc0000000
57e111b4:	e1833402 	orr	r3, r3, r2, lsl #8
	result = usb_clear_halt(us->pusb_dev, pipe);
57e111b8:	e1831781 	orr	r1, r3, r1, lsl #15
57e111bc:	ebfffb36 	bl	57e0fe9c <usb_clear_halt>
	mdelay(150);
57e111c0:	e3a00096 	mov	r0, #150	; 0x96
57e111c4:	eb004ce7 	bl	57e24568 <mdelay>
	USB_STOR_PRINTF("BBB_reset result %d: status %lX"
			" clearing OUT endpoint\n", result,
			us->pusb_dev->status);
	USB_STOR_PRINTF("BBB_reset done\n");
	return 0;
57e111c8:	e3a00000 	mov	r0, #0
}
57e111cc:	e28dd018 	add	sp, sp, #24
57e111d0:	e8bd8010 	pop	{r4, pc}

57e111d4 <usb_stor_CB_reset>:
/* FIXME: this reset function doesn't really reset the port, and it
 * should. Actually it should probably do what it's doing here, and
 * reset the port physically
 */
static int usb_stor_CB_reset(struct us_data *us)
{
57e111d4:	e92d4070 	push	{r4, r5, r6, lr}
57e111d8:	e24dd028 	sub	sp, sp, #40	; 0x28
	unsigned char cmd[12];
	int result;

	USB_STOR_PRINTF("CB_reset\n");
	memset(cmd, 0xff, sizeof(cmd));
57e111dc:	e28d601c 	add	r6, sp, #28
/* FIXME: this reset function doesn't really reset the port, and it
 * should. Actually it should probably do what it's doing here, and
 * reset the port physically
 */
static int usb_stor_CB_reset(struct us_data *us)
{
57e111e0:	e1a04000 	mov	r4, r0
	unsigned char cmd[12];
	int result;

	USB_STOR_PRINTF("CB_reset\n");
	memset(cmd, 0xff, sizeof(cmd));
57e111e4:	e3a010ff 	mov	r1, #255	; 0xff
57e111e8:	e1a00006 	mov	r0, r6
57e111ec:	e3a0200c 	mov	r2, #12
57e111f0:	eb004c21 	bl	57e2427c <memset>
	cmd[0] = SCSI_SEND_DIAG;
57e111f4:	e3a0301d 	mov	r3, #29
57e111f8:	e5cd301c 	strb	r3, [sp, #28]
	cmd[1] = 4;
	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev, 0),
57e111fc:	e5940000 	ldr	r0, [r4]
	int result;

	USB_STOR_PRINTF("CB_reset\n");
	memset(cmd, 0xff, sizeof(cmd));
	cmd[0] = SCSI_SEND_DIAG;
	cmd[1] = 4;
57e11200:	e3a03004 	mov	r3, #4
57e11204:	e5cd301d 	strb	r3, [sp, #29]
	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev, 0),
57e11208:	e5d42008 	ldrb	r2, [r4, #8]
57e1120c:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e11210:	e5901000 	ldr	r1, [r0]
57e11214:	e58d2004 	str	r2, [sp, #4]
57e11218:	e3a0200c 	mov	r2, #12
57e1121c:	e3a05000 	mov	r5, #0
57e11220:	e58d200c 	str	r2, [sp, #12]
57e11224:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
57e11228:	e2822f7a 	add	r2, r2, #488	; 0x1e8
57e1122c:	e1831401 	orr	r1, r3, r1, lsl #8
57e11230:	e58d2010 	str	r2, [sp, #16]
57e11234:	e3a03021 	mov	r3, #33	; 0x21
57e11238:	e1a02005 	mov	r2, r5
57e1123c:	e58d5000 	str	r5, [sp]
57e11240:	e58d6008 	str	r6, [sp, #8]
57e11244:	ebfffa44 	bl	57e0fb5c <usb_control_msg>
				 USB_TYPE_CLASS | USB_RECIP_INTERFACE,
				 0, us->ifnum, cmd, sizeof(cmd),
				 USB_CNTL_TIMEOUT * 5);

	/* long wait for reset */
	mdelay(1500);
57e11248:	e59f0054 	ldr	r0, [pc, #84]	; 57e112a4 <usb_stor_CB_reset+0xd0>
57e1124c:	eb004cc5 	bl	57e24568 <mdelay>
	USB_STOR_PRINTF("CB_reset result %d: status %lX"
			" clearing endpoint halt\n", result,
			us->pusb_dev->status);
	usb_clear_halt(us->pusb_dev, usb_rcvbulkpipe(us->pusb_dev, us->ep_in));
57e11250:	e5940000 	ldr	r0, [r4]
57e11254:	e5d41009 	ldrb	r1, [r4, #9]
57e11258:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e1125c:	e5902000 	ldr	r2, [r0]
57e11260:	e3833103 	orr	r3, r3, #-1073741824	; 0xc0000000
57e11264:	e3833080 	orr	r3, r3, #128	; 0x80
57e11268:	e1833402 	orr	r3, r3, r2, lsl #8
57e1126c:	e1831781 	orr	r1, r3, r1, lsl #15
57e11270:	ebfffb09 	bl	57e0fe9c <usb_clear_halt>
	usb_clear_halt(us->pusb_dev, usb_rcvbulkpipe(us->pusb_dev, us->ep_out));
57e11274:	e5940000 	ldr	r0, [r4]
57e11278:	e5d4100a 	ldrb	r1, [r4, #10]
57e1127c:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e11280:	e5902000 	ldr	r2, [r0]
57e11284:	e3833103 	orr	r3, r3, #-1073741824	; 0xc0000000
57e11288:	e3833080 	orr	r3, r3, #128	; 0x80
57e1128c:	e1833402 	orr	r3, r3, r2, lsl #8
57e11290:	e1831781 	orr	r1, r3, r1, lsl #15
57e11294:	ebfffb00 	bl	57e0fe9c <usb_clear_halt>

	USB_STOR_PRINTF("CB_reset done\n");
	return 0;
}
57e11298:	e1a00005 	mov	r0, r5
57e1129c:	e28dd028 	add	sp, sp, #40	; 0x28
57e112a0:	e8bd8070 	pop	{r4, r5, r6, pc}
57e112a4:	000005dc 	.word	0x000005dc

57e112a8 <usb_stor_write>:
	return blkcnt;
}

unsigned long usb_stor_write(int device, unsigned long blknr,
				lbaint_t blkcnt, const void *buffer)
{
57e112a8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct usb_device *dev;
	struct us_data *ss;
	int retry, i;
	ccb *srb = &usb_ccb;

	if (blkcnt == 0)
57e112ac:	e252b000 	subs	fp, r2, #0
	return blkcnt;
}

unsigned long usb_stor_write(int device, unsigned long blknr,
				lbaint_t blkcnt, const void *buffer)
{
57e112b0:	e24dd020 	sub	sp, sp, #32
57e112b4:	e1a06001 	mov	r6, r1
57e112b8:	e1a07003 	mov	r7, r3
	struct usb_device *dev;
	struct us_data *ss;
	int retry, i;
	ccb *srb = &usb_ccb;

	if (blkcnt == 0)
57e112bc:	0a00007e 	beq	57e114bc <usb_stor_write+0x214>
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
		dev = usb_get_dev_index(i);
		if (dev == NULL)
			return 0;
		if (dev->devnum == usb_dev_desc[device].target)
57e112c0:	e59f3200 	ldr	r3, [pc, #512]	; 57e114c8 <usb_stor_write+0x220>
	ccb *srb = &usb_ccb;

	if (blkcnt == 0)
		return 0;

	device &= 0xff;
57e112c4:	e200a0ff 	and	sl, r0, #255	; 0xff
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
		dev = usb_get_dev_index(i);
		if (dev == NULL)
			return 0;
		if (dev->devnum == usb_dev_desc[device].target)
57e112c8:	e3a05070 	mov	r5, #112	; 0x70
57e112cc:	e025359a 	mla	r5, sl, r5, r3

	device &= 0xff;
	/* Setup  device */
	USB_STOR_PRINTF("\nusb_write: dev %d \n", device);
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
57e112d0:	e3a04000 	mov	r4, #0
		dev = usb_get_dev_index(i);
57e112d4:	e1a00004 	mov	r0, r4
57e112d8:	ebfffc0f 	bl	57e1031c <usb_get_dev_index>
		if (dev == NULL)
57e112dc:	e3500000 	cmp	r0, #0
57e112e0:	0a000074 	beq	57e114b8 <usb_stor_write+0x210>
			return 0;
		if (dev->devnum == usb_dev_desc[device].target)
57e112e4:	e5d53009 	ldrb	r3, [r5, #9]
57e112e8:	e5902000 	ldr	r2, [r0]
57e112ec:	e1520003 	cmp	r2, r3
57e112f0:	0a000002 	beq	57e11300 <usb_stor_write+0x58>

	device &= 0xff;
	/* Setup  device */
	USB_STOR_PRINTF("\nusb_write: dev %d \n", device);
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
57e112f4:	e2844001 	add	r4, r4, #1
57e112f8:	e3540020 	cmp	r4, #32
57e112fc:	1afffff4 	bne	57e112d4 <usb_stor_write+0x2c>
		if (dev == NULL)
			return 0;
		if (dev->devnum == usb_dev_desc[device].target)
			break;
	}
	ss = (struct us_data *)dev->privptr;
57e11300:	e5905610 	ldr	r5, [r0, #1552]	; 0x610

	usb_disable_asynch(1); /* asynch transfer not allowed */

	srb->lun = usb_dev_desc[device].lun;
57e11304:	e59f41bc 	ldr	r4, [pc, #444]	; 57e114c8 <usb_stor_write+0x220>
		if (dev->devnum == usb_dev_desc[device].target)
			break;
	}
	ss = (struct us_data *)dev->privptr;

	usb_disable_asynch(1); /* asynch transfer not allowed */
57e11308:	e3a00001 	mov	r0, #1
57e1130c:	ebfffa09 	bl	57e0fb38 <usb_disable_asynch>

	srb->lun = usb_dev_desc[device].lun;
57e11310:	e3a00070 	mov	r0, #112	; 0x70
57e11314:	e02a4a90 	mla	sl, r0, sl, r4
57e11318:	e5da300a 	ldrb	r3, [sl, #10]
	buf_addr = (unsigned long)buffer;
57e1131c:	e58d7004 	str	r7, [sp, #4]
	}
	ss = (struct us_data *)dev->privptr;

	usb_disable_asynch(1); /* asynch transfer not allowed */

	srb->lun = usb_dev_desc[device].lun;
57e11320:	e5c432c2 	strb	r3, [r4, #706]	; 0x2c2
	buf_addr = (unsigned long)buffer;
57e11324:	e1a0900b 	mov	r9, fp
		else
			smallblks = (unsigned short) blks;
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
57e11328:	e58da01c 	str	sl, [sp, #28]
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
	srb->pdata = &srb->sense_buf[0];
57e1132c:	e58db008 	str	fp, [sp, #8]
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_WRITE10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
57e11330:	e1a03826 	lsr	r3, r6, #16
57e11334:	e20330ff 	and	r3, r3, #255	; 0xff
		/* If write fails retry for max retry count else
		 * return with number of blocks written successfully.
		 */
		retry = 2;
		srb->pdata = (unsigned char *)buf_addr;
		if (blks > USB_MAX_XFER_BLK)
57e11338:	e3590014 	cmp	r9, #20
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_WRITE10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
57e1133c:	e58d3014 	str	r3, [sp, #20]
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e11340:	e1a03426 	lsr	r3, r6, #8
		retry = 2;
		srb->pdata = (unsigned char *)buf_addr;
		if (blks > USB_MAX_XFER_BLK)
			smallblks = USB_MAX_XFER_BLK;
		else
			smallblks = (unsigned short) blks;
57e11344:	91a0a809 	lslls	sl, r9, #16
			unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_WRITE10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
57e11348:	e1a02c26 	lsr	r2, r6, #24
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e1134c:	e20330ff 	and	r3, r3, #255	; 0xff
57e11350:	e3a0c003 	mov	ip, #3

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
57e11354:	e58d900c 	str	r9, [sp, #12]
		retry = 2;
		srb->pdata = (unsigned char *)buf_addr;
		if (blks > USB_MAX_XFER_BLK)
			smallblks = USB_MAX_XFER_BLK;
		else
			smallblks = (unsigned short) blks;
57e11358:	91a0a82a 	lsrls	sl, sl, #16

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
57e1135c:	e1a09006 	mov	r9, r6
		 * return with number of blocks written successfully.
		 */
		retry = 2;
		srb->pdata = (unsigned char *)buf_addr;
		if (blks > USB_MAX_XFER_BLK)
			smallblks = USB_MAX_XFER_BLK;
57e11360:	83a0a014 	movhi	sl, #20
			unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_WRITE10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
57e11364:	e58d2010 	str	r2, [sp, #16]
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e11368:	e58d3018 	str	r3, [sp, #24]

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
57e1136c:	e1a0600c 	mov	r6, ip
		else
			smallblks = (unsigned short) blks;
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
57e11370:	e59d201c 	ldr	r2, [sp, #28]
57e11374:	e59f714c 	ldr	r7, [pc, #332]	; 57e114c8 <usb_stor_write+0x220>
57e11378:	e5923014 	ldr	r3, [r2, #20]
}

static int usb_write_10(ccb *srb, struct us_data *ss, unsigned long start,
			unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
57e1137c:	e3a01000 	mov	r1, #0
		else
			smallblks = (unsigned short) blks;
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
57e11380:	e003039a 	mul	r3, sl, r3
57e11384:	e58432c4 	str	r3, [r4, #708]	; 0x2c4
		srb->pdata = (unsigned char *)buf_addr;
57e11388:	e59d3004 	ldr	r3, [sp, #4]
}

static int usb_write_10(ccb *srb, struct us_data *ss, unsigned long start,
			unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
57e1138c:	e3a0200c 	mov	r2, #12
			smallblks = (unsigned short) blks;
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
		srb->pdata = (unsigned char *)buf_addr;
57e11390:	e58432c8 	str	r3, [r4, #712]	; 0x2c8
}

static int usb_write_10(ccb *srb, struct us_data *ss, unsigned long start,
			unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
57e11394:	e2870d09 	add	r0, r7, #576	; 0x240
57e11398:	eb004bb7 	bl	57e2427c <memset>
	srb->cmd[0] = SCSI_WRITE10;
	srb->cmd[1] = srb->lun << 5;
57e1139c:	e5d432c2 	ldrb	r3, [r4, #706]	; 0x2c2

static int usb_write_10(ccb *srb, struct us_data *ss, unsigned long start,
			unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_WRITE10;
57e113a0:	e3a0202a 	mov	r2, #42	; 0x2a
	srb->cmd[1] = srb->lun << 5;
57e113a4:	e1a03283 	lsl	r3, r3, #5
57e113a8:	e5c43241 	strb	r3, [r4, #577]	; 0x241
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
57e113ac:	e59d3010 	ldr	r3, [sp, #16]

static int usb_write_10(ccb *srb, struct us_data *ss, unsigned long start,
			unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_WRITE10;
57e113b0:	e5c42240 	strb	r2, [r4, #576]	; 0x240
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
57e113b4:	e59d2014 	ldr	r2, [sp, #20]
			unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_WRITE10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
57e113b8:	e5c43242 	strb	r3, [r4, #578]	; 0x242
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e113bc:	e59d3018 	ldr	r3, [sp, #24]
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_WRITE10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
57e113c0:	e5c42243 	strb	r2, [r4, #579]	; 0x243
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
	srb->cmd[5] = ((unsigned char) (start)) & 0xff;
	srb->cmd[7] = ((unsigned char) (blocks >> 8)) & 0xff;
	srb->cmd[8] = (unsigned char) blocks & 0xff;
	srb->cmdlen = 12;
57e113c4:	e3a0b00c 	mov	fp, #12
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
	srb->cmd[5] = ((unsigned char) (start)) & 0xff;
	srb->cmd[7] = ((unsigned char) (blocks >> 8)) & 0xff;
57e113c8:	e3a02000 	mov	r2, #0
57e113cc:	e5c42247 	strb	r2, [r4, #583]	; 0x247
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_WRITE10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e113d0:	e5c43244 	strb	r3, [r4, #580]	; 0x244
	srb->cmd[5] = ((unsigned char) (start)) & 0xff;
57e113d4:	e5c49245 	strb	r9, [r4, #581]	; 0x245
	srb->cmd[7] = ((unsigned char) (blocks >> 8)) & 0xff;
	srb->cmd[8] = (unsigned char) blocks & 0xff;
57e113d8:	e5c4a248 	strb	sl, [r4, #584]	; 0x248
	srb->cmdlen = 12;
57e113dc:	e5c4b2c3 	strb	fp, [r4, #707]	; 0x2c3
	USB_STOR_PRINTF("write10: start %lx blocks %x\n", start, blocks);
	return ss->transport(srb, ss);
57e113e0:	e5953030 	ldr	r3, [r5, #48]	; 0x30
57e113e4:	e2870d09 	add	r0, r7, #576	; 0x240
57e113e8:	e58d2000 	str	r2, [sp]
57e113ec:	e1a01005 	mov	r1, r5
57e113f0:	e12fff33 	blx	r3
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
		srb->pdata = (unsigned char *)buf_addr;
		if (usb_write_10(srb, ss, start, smallblks)) {
57e113f4:	e3500000 	cmp	r0, #0
57e113f8:	e59d2000 	ldr	r2, [sp]
57e113fc:	0a00001d 	beq	57e11478 <usb_stor_write+0x1d0>

static int usb_request_sense(ccb *srb, struct us_data *ss)
{
	char *ptr;

	ptr = (char *)srb->pdata;
57e11400:	e594c2c8 	ldr	ip, [r4, #712]	; 0x2c8
	memset(&srb->cmd[0], 0, 12);
57e11404:	e1a01002 	mov	r1, r2
57e11408:	e2870d09 	add	r0, r7, #576	; 0x240
57e1140c:	e1a0200b 	mov	r2, fp
57e11410:	e58dc000 	str	ip, [sp]
57e11414:	eb004b98 	bl	57e2427c <memset>
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
57e11418:	e5d432c2 	ldrb	r3, [r4, #706]	; 0x2c2
{
	char *ptr;

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
57e1141c:	e3a02003 	mov	r2, #3
	srb->cmd[1] = srb->lun << 5;
57e11420:	e1a03283 	lsl	r3, r3, #5
57e11424:	e5c43241 	strb	r3, [r4, #577]	; 0x241
	srb->cmd[4] = 18;
57e11428:	e3a03012 	mov	r3, #18
57e1142c:	e5c43244 	strb	r3, [r4, #580]	; 0x244
	srb->datalen = 18;
	srb->pdata = &srb->sense_buf[0];
57e11430:	e59f3094 	ldr	r3, [pc, #148]	; 57e114cc <usb_stor_write+0x224>
{
	char *ptr;

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
57e11434:	e5c42240 	strb	r2, [r4, #576]	; 0x240
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
	srb->pdata = &srb->sense_buf[0];
	srb->cmdlen = 12;
57e11438:	e5c4b2c3 	strb	fp, [r4, #707]	; 0x2c3
	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
57e1143c:	e3a02012 	mov	r2, #18
	srb->pdata = &srb->sense_buf[0];
57e11440:	e58432c8 	str	r3, [r4, #712]	; 0x2c8
	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
57e11444:	e58422c4 	str	r2, [r4, #708]	; 0x2c4
	srb->pdata = &srb->sense_buf[0];
	srb->cmdlen = 12;
	ss->transport(srb, ss);
57e11448:	e5953030 	ldr	r3, [r5, #48]	; 0x30
57e1144c:	e2870d09 	add	r0, r7, #576	; 0x240
57e11450:	e1a01005 	mov	r1, r5
57e11454:	e12fff33 	blx	r3
	USB_STOR_PRINTF("Request Sense returned %02X %02X %02X\n",
			srb->sense_buf[2], srb->sense_buf[12],
			srb->sense_buf[13]);
	srb->pdata = (uchar *)ptr;
57e11458:	e59dc000 	ldr	ip, [sp]
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
		srb->pdata = (unsigned char *)buf_addr;
		if (usb_write_10(srb, ss, start, smallblks)) {
			USB_STOR_PRINTF("Write ERROR\n");
			usb_request_sense(srb, ss);
			if (retry--)
57e1145c:	e2566001 	subs	r6, r6, #1
	srb->cmdlen = 12;
	ss->transport(srb, ss);
	USB_STOR_PRINTF("Request Sense returned %02X %02X %02X\n",
			srb->sense_buf[2], srb->sense_buf[12],
			srb->sense_buf[13]);
	srb->pdata = (uchar *)ptr;
57e11460:	e584c2c8 	str	ip, [r4, #712]	; 0x2c8
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
		srb->pdata = (unsigned char *)buf_addr;
		if (usb_write_10(srb, ss, start, smallblks)) {
			USB_STOR_PRINTF("Write ERROR\n");
			usb_request_sense(srb, ss);
			if (retry--)
57e11464:	1affffc1 	bne	57e11370 <usb_stor_write+0xc8>
57e11468:	e59d900c 	ldr	r9, [sp, #12]
57e1146c:	e59db008 	ldr	fp, [sp, #8]
				goto retry_it;
			blkcnt -= blks;
57e11470:	e069b00b 	rsb	fp, r9, fp
			break;
57e11474:	ea000009 	b	57e114a0 <usb_stor_write+0x1f8>
57e11478:	e1a06009 	mov	r6, r9
57e1147c:	e59d900c 	ldr	r9, [sp, #12]
		}
		start += smallblks;
		blks -= smallblks;
		buf_addr += srb->datalen;
57e11480:	e59732c4 	ldr	r3, [r7, #708]	; 0x2c4
	} while (blks != 0);
57e11484:	e059900a 	subs	r9, r9, sl
			blkcnt -= blks;
			break;
		}
		start += smallblks;
		blks -= smallblks;
		buf_addr += srb->datalen;
57e11488:	159d2004 	ldrne	r2, [sp, #4]
			if (retry--)
				goto retry_it;
			blkcnt -= blks;
			break;
		}
		start += smallblks;
57e1148c:	1086600a 	addne	r6, r6, sl
		blks -= smallblks;
		buf_addr += srb->datalen;
57e11490:	10822003 	addne	r2, r2, r3
57e11494:	158d2004 	strne	r2, [sp, #4]
57e11498:	1affffa4 	bne	57e11330 <usb_stor_write+0x88>
57e1149c:	e59db008 	ldr	fp, [sp, #8]
	} while (blks != 0);
	ss->flags &= ~USB_READY;
57e114a0:	e5953004 	ldr	r3, [r5, #4]

	USB_STOR_PRINTF("usb_write: end startblk " LBAF
			", blccnt %x buffer %lx\n",
			start, smallblks, buf_addr);

	usb_disable_asynch(0); /* asynch transfer allowed */
57e114a4:	e3a00000 	mov	r0, #0
		}
		start += smallblks;
		blks -= smallblks;
		buf_addr += srb->datalen;
	} while (blks != 0);
	ss->flags &= ~USB_READY;
57e114a8:	e3c33001 	bic	r3, r3, #1
57e114ac:	e5853004 	str	r3, [r5, #4]

	USB_STOR_PRINTF("usb_write: end startblk " LBAF
			", blccnt %x buffer %lx\n",
			start, smallblks, buf_addr);

	usb_disable_asynch(0); /* asynch transfer allowed */
57e114b0:	ebfff9a0 	bl	57e0fb38 <usb_disable_asynch>
	if (blkcnt >= USB_MAX_XFER_BLK)
		debug("\n");
	return blkcnt;
57e114b4:	ea000000 	b	57e114bc <usb_stor_write+0x214>
	USB_STOR_PRINTF("\nusb_write: dev %d \n", device);
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
		dev = usb_get_dev_index(i);
		if (dev == NULL)
			return 0;
57e114b8:	e1a0b000 	mov	fp, r0
	usb_disable_asynch(0); /* asynch transfer allowed */
	if (blkcnt >= USB_MAX_XFER_BLK)
		debug("\n");
	return blkcnt;

}
57e114bc:	e1a0000b 	mov	r0, fp
57e114c0:	e28dd020 	add	sp, sp, #32
57e114c4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e114c8:	57e46e00 	.word	0x57e46e00
57e114cc:	57e47080 	.word	0x57e47080

57e114d0 <usb_stor_read>:
}
#endif /* CONFIG_USB_BIN_FIXUP */

unsigned long usb_stor_read(int device, unsigned long blknr,
			    lbaint_t blkcnt, void *buffer)
{
57e114d0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct usb_device *dev;
	struct us_data *ss;
	int retry, i;
	ccb *srb = &usb_ccb;

	if (blkcnt == 0)
57e114d4:	e252b000 	subs	fp, r2, #0
}
#endif /* CONFIG_USB_BIN_FIXUP */

unsigned long usb_stor_read(int device, unsigned long blknr,
			    lbaint_t blkcnt, void *buffer)
{
57e114d8:	e24dd020 	sub	sp, sp, #32
57e114dc:	e1a06001 	mov	r6, r1
57e114e0:	e1a07003 	mov	r7, r3
	struct usb_device *dev;
	struct us_data *ss;
	int retry, i;
	ccb *srb = &usb_ccb;

	if (blkcnt == 0)
57e114e4:	0a00007e 	beq	57e116e4 <usb_stor_read+0x214>
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
		dev = usb_get_dev_index(i);
		if (dev == NULL)
			return 0;
		if (dev->devnum == usb_dev_desc[device].target)
57e114e8:	e59f3200 	ldr	r3, [pc, #512]	; 57e116f0 <usb_stor_read+0x220>
	ccb *srb = &usb_ccb;

	if (blkcnt == 0)
		return 0;

	device &= 0xff;
57e114ec:	e200a0ff 	and	sl, r0, #255	; 0xff
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
		dev = usb_get_dev_index(i);
		if (dev == NULL)
			return 0;
		if (dev->devnum == usb_dev_desc[device].target)
57e114f0:	e3a05070 	mov	r5, #112	; 0x70
57e114f4:	e025359a 	mla	r5, sl, r5, r3

	device &= 0xff;
	/* Setup  device */
	USB_STOR_PRINTF("\nusb_read: dev %d \n", device);
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
57e114f8:	e3a04000 	mov	r4, #0
		dev = usb_get_dev_index(i);
57e114fc:	e1a00004 	mov	r0, r4
57e11500:	ebfffb85 	bl	57e1031c <usb_get_dev_index>
		if (dev == NULL)
57e11504:	e3500000 	cmp	r0, #0
57e11508:	0a000074 	beq	57e116e0 <usb_stor_read+0x210>
			return 0;
		if (dev->devnum == usb_dev_desc[device].target)
57e1150c:	e5d53009 	ldrb	r3, [r5, #9]
57e11510:	e5902000 	ldr	r2, [r0]
57e11514:	e1520003 	cmp	r2, r3
57e11518:	0a000002 	beq	57e11528 <usb_stor_read+0x58>

	device &= 0xff;
	/* Setup  device */
	USB_STOR_PRINTF("\nusb_read: dev %d \n", device);
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
57e1151c:	e2844001 	add	r4, r4, #1
57e11520:	e3540020 	cmp	r4, #32
57e11524:	1afffff4 	bne	57e114fc <usb_stor_read+0x2c>
		if (dev == NULL)
			return 0;
		if (dev->devnum == usb_dev_desc[device].target)
			break;
	}
	ss = (struct us_data *)dev->privptr;
57e11528:	e5905610 	ldr	r5, [r0, #1552]	; 0x610

	usb_disable_asynch(1); /* asynch transfer not allowed */
	srb->lun = usb_dev_desc[device].lun;
57e1152c:	e59f41bc 	ldr	r4, [pc, #444]	; 57e116f0 <usb_stor_read+0x220>
		if (dev->devnum == usb_dev_desc[device].target)
			break;
	}
	ss = (struct us_data *)dev->privptr;

	usb_disable_asynch(1); /* asynch transfer not allowed */
57e11530:	e3a00001 	mov	r0, #1
57e11534:	ebfff97f 	bl	57e0fb38 <usb_disable_asynch>
	srb->lun = usb_dev_desc[device].lun;
57e11538:	e3a00070 	mov	r0, #112	; 0x70
57e1153c:	e02a4a90 	mla	sl, r0, sl, r4
57e11540:	e5da300a 	ldrb	r3, [sl, #10]
	buf_addr = (unsigned long)buffer;
57e11544:	e58d7004 	str	r7, [sp, #4]
			break;
	}
	ss = (struct us_data *)dev->privptr;

	usb_disable_asynch(1); /* asynch transfer not allowed */
	srb->lun = usb_dev_desc[device].lun;
57e11548:	e5c432c2 	strb	r3, [r4, #706]	; 0x2c2
	buf_addr = (unsigned long)buffer;
57e1154c:	e1a0900b 	mov	r9, fp
		else
			smallblks = (unsigned short) blks;
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
57e11550:	e58da01c 	str	sl, [sp, #28]
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
	srb->pdata = &srb->sense_buf[0];
57e11554:	e58db008 	str	fp, [sp, #8]
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_READ10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
57e11558:	e1a03826 	lsr	r3, r6, #16
57e1155c:	e20330ff 	and	r3, r3, #255	; 0xff

	do {
		/* XXX need some comment here */
		retry = 2;
		srb->pdata = (unsigned char *)buf_addr;
		if (blks > USB_MAX_XFER_BLK)
57e11560:	e3590014 	cmp	r9, #20
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_READ10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
57e11564:	e58d3014 	str	r3, [sp, #20]
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e11568:	e1a03426 	lsr	r3, r6, #8
		retry = 2;
		srb->pdata = (unsigned char *)buf_addr;
		if (blks > USB_MAX_XFER_BLK)
			smallblks = USB_MAX_XFER_BLK;
		else
			smallblks = (unsigned short) blks;
57e1156c:	91a0a809 	lslls	sl, r9, #16
		       unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_READ10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
57e11570:	e1a02c26 	lsr	r2, r6, #24
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e11574:	e20330ff 	and	r3, r3, #255	; 0xff
57e11578:	e3a0c003 	mov	ip, #3

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
57e1157c:	e58d900c 	str	r9, [sp, #12]
		retry = 2;
		srb->pdata = (unsigned char *)buf_addr;
		if (blks > USB_MAX_XFER_BLK)
			smallblks = USB_MAX_XFER_BLK;
		else
			smallblks = (unsigned short) blks;
57e11580:	91a0a82a 	lsrls	sl, sl, #16

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
57e11584:	e1a09006 	mov	r9, r6
	do {
		/* XXX need some comment here */
		retry = 2;
		srb->pdata = (unsigned char *)buf_addr;
		if (blks > USB_MAX_XFER_BLK)
			smallblks = USB_MAX_XFER_BLK;
57e11588:	83a0a014 	movhi	sl, #20
		       unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_READ10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
57e1158c:	e58d2010 	str	r2, [sp, #16]
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e11590:	e58d3018 	str	r3, [sp, #24]

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
57e11594:	e1a0600c 	mov	r6, ip
		else
			smallblks = (unsigned short) blks;
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
57e11598:	e59d201c 	ldr	r2, [sp, #28]
57e1159c:	e59f714c 	ldr	r7, [pc, #332]	; 57e116f0 <usb_stor_read+0x220>
57e115a0:	e5923014 	ldr	r3, [r2, #20]
}

static int usb_read_10(ccb *srb, struct us_data *ss, unsigned long start,
		       unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
57e115a4:	e3a01000 	mov	r1, #0
		else
			smallblks = (unsigned short) blks;
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
57e115a8:	e003039a 	mul	r3, sl, r3
57e115ac:	e58432c4 	str	r3, [r4, #708]	; 0x2c4
		srb->pdata = (unsigned char *)buf_addr;
57e115b0:	e59d3004 	ldr	r3, [sp, #4]
}

static int usb_read_10(ccb *srb, struct us_data *ss, unsigned long start,
		       unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
57e115b4:	e3a0200c 	mov	r2, #12
			smallblks = (unsigned short) blks;
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
		srb->pdata = (unsigned char *)buf_addr;
57e115b8:	e58432c8 	str	r3, [r4, #712]	; 0x2c8
}

static int usb_read_10(ccb *srb, struct us_data *ss, unsigned long start,
		       unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
57e115bc:	e2870d09 	add	r0, r7, #576	; 0x240
57e115c0:	eb004b2d 	bl	57e2427c <memset>
	srb->cmd[0] = SCSI_READ10;
	srb->cmd[1] = srb->lun << 5;
57e115c4:	e5d432c2 	ldrb	r3, [r4, #706]	; 0x2c2

static int usb_read_10(ccb *srb, struct us_data *ss, unsigned long start,
		       unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_READ10;
57e115c8:	e3a02028 	mov	r2, #40	; 0x28
	srb->cmd[1] = srb->lun << 5;
57e115cc:	e1a03283 	lsl	r3, r3, #5
57e115d0:	e5c43241 	strb	r3, [r4, #577]	; 0x241
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
57e115d4:	e59d3010 	ldr	r3, [sp, #16]

static int usb_read_10(ccb *srb, struct us_data *ss, unsigned long start,
		       unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_READ10;
57e115d8:	e5c42240 	strb	r2, [r4, #576]	; 0x240
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
57e115dc:	e59d2014 	ldr	r2, [sp, #20]
		       unsigned short blocks)
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_READ10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
57e115e0:	e5c43242 	strb	r3, [r4, #578]	; 0x242
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e115e4:	e59d3018 	ldr	r3, [sp, #24]
{
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_READ10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
57e115e8:	e5c42243 	strb	r2, [r4, #579]	; 0x243
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
	srb->cmd[5] = ((unsigned char) (start)) & 0xff;
	srb->cmd[7] = ((unsigned char) (blocks >> 8)) & 0xff;
	srb->cmd[8] = (unsigned char) blocks & 0xff;
	srb->cmdlen = 12;
57e115ec:	e3a0b00c 	mov	fp, #12
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
	srb->cmd[5] = ((unsigned char) (start)) & 0xff;
	srb->cmd[7] = ((unsigned char) (blocks >> 8)) & 0xff;
57e115f0:	e3a02000 	mov	r2, #0
57e115f4:	e5c42247 	strb	r2, [r4, #583]	; 0x247
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_READ10;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
57e115f8:	e5c43244 	strb	r3, [r4, #580]	; 0x244
	srb->cmd[5] = ((unsigned char) (start)) & 0xff;
57e115fc:	e5c49245 	strb	r9, [r4, #581]	; 0x245
	srb->cmd[7] = ((unsigned char) (blocks >> 8)) & 0xff;
	srb->cmd[8] = (unsigned char) blocks & 0xff;
57e11600:	e5c4a248 	strb	sl, [r4, #584]	; 0x248
	srb->cmdlen = 12;
57e11604:	e5c4b2c3 	strb	fp, [r4, #707]	; 0x2c3
	USB_STOR_PRINTF("read10: start %lx blocks %x\n", start, blocks);
	return ss->transport(srb, ss);
57e11608:	e5953030 	ldr	r3, [r5, #48]	; 0x30
57e1160c:	e2870d09 	add	r0, r7, #576	; 0x240
57e11610:	e58d2000 	str	r2, [sp]
57e11614:	e1a01005 	mov	r1, r5
57e11618:	e12fff33 	blx	r3
retry_it:
		if (smallblks == USB_MAX_XFER_BLK)
			usb_show_progress();
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
		srb->pdata = (unsigned char *)buf_addr;
		if (usb_read_10(srb, ss, start, smallblks)) {
57e1161c:	e3500000 	cmp	r0, #0
57e11620:	e59d2000 	ldr	r2, [sp]
57e11624:	0a00001d 	beq	57e116a0 <usb_stor_read+0x1d0>

static int usb_request_sense(ccb *srb, struct us_data *ss)
{
	char *ptr;

	ptr = (char *)srb->pdata;
57e11628:	e594c2c8 	ldr	ip, [r4, #712]	; 0x2c8
	memset(&srb->cmd[0], 0, 12);
57e1162c:	e1a01002 	mov	r1, r2
57e11630:	e2870d09 	add	r0, r7, #576	; 0x240
57e11634:	e1a0200b 	mov	r2, fp
57e11638:	e58dc000 	str	ip, [sp]
57e1163c:	eb004b0e 	bl	57e2427c <memset>
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
57e11640:	e5d432c2 	ldrb	r3, [r4, #706]	; 0x2c2
{
	char *ptr;

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
57e11644:	e3a02003 	mov	r2, #3
	srb->cmd[1] = srb->lun << 5;
57e11648:	e1a03283 	lsl	r3, r3, #5
57e1164c:	e5c43241 	strb	r3, [r4, #577]	; 0x241
	srb->cmd[4] = 18;
57e11650:	e3a03012 	mov	r3, #18
57e11654:	e5c43244 	strb	r3, [r4, #580]	; 0x244
	srb->datalen = 18;
	srb->pdata = &srb->sense_buf[0];
57e11658:	e59f3094 	ldr	r3, [pc, #148]	; 57e116f4 <usb_stor_read+0x224>
{
	char *ptr;

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
57e1165c:	e5c42240 	strb	r2, [r4, #576]	; 0x240
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
	srb->pdata = &srb->sense_buf[0];
	srb->cmdlen = 12;
57e11660:	e5c4b2c3 	strb	fp, [r4, #707]	; 0x2c3
	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
57e11664:	e3a02012 	mov	r2, #18
	srb->pdata = &srb->sense_buf[0];
57e11668:	e58432c8 	str	r3, [r4, #712]	; 0x2c8
	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
57e1166c:	e58422c4 	str	r2, [r4, #708]	; 0x2c4
	srb->pdata = &srb->sense_buf[0];
	srb->cmdlen = 12;
	ss->transport(srb, ss);
57e11670:	e5953030 	ldr	r3, [r5, #48]	; 0x30
57e11674:	e2870d09 	add	r0, r7, #576	; 0x240
57e11678:	e1a01005 	mov	r1, r5
57e1167c:	e12fff33 	blx	r3
	USB_STOR_PRINTF("Request Sense returned %02X %02X %02X\n",
			srb->sense_buf[2], srb->sense_buf[12],
			srb->sense_buf[13]);
	srb->pdata = (uchar *)ptr;
57e11680:	e59dc000 	ldr	ip, [sp]
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
		srb->pdata = (unsigned char *)buf_addr;
		if (usb_read_10(srb, ss, start, smallblks)) {
			USB_STOR_PRINTF("Read ERROR\n");
			usb_request_sense(srb, ss);
			if (retry--)
57e11684:	e2566001 	subs	r6, r6, #1
	srb->cmdlen = 12;
	ss->transport(srb, ss);
	USB_STOR_PRINTF("Request Sense returned %02X %02X %02X\n",
			srb->sense_buf[2], srb->sense_buf[12],
			srb->sense_buf[13]);
	srb->pdata = (uchar *)ptr;
57e11688:	e584c2c8 	str	ip, [r4, #712]	; 0x2c8
		srb->datalen = usb_dev_desc[device].blksz * smallblks;
		srb->pdata = (unsigned char *)buf_addr;
		if (usb_read_10(srb, ss, start, smallblks)) {
			USB_STOR_PRINTF("Read ERROR\n");
			usb_request_sense(srb, ss);
			if (retry--)
57e1168c:	1affffc1 	bne	57e11598 <usb_stor_read+0xc8>
57e11690:	e59d900c 	ldr	r9, [sp, #12]
57e11694:	e59db008 	ldr	fp, [sp, #8]
				goto retry_it;
			blkcnt -= blks;
57e11698:	e069b00b 	rsb	fp, r9, fp
			break;
57e1169c:	ea000009 	b	57e116c8 <usb_stor_read+0x1f8>
57e116a0:	e1a06009 	mov	r6, r9
57e116a4:	e59d900c 	ldr	r9, [sp, #12]
		}
		start += smallblks;
		blks -= smallblks;
		buf_addr += srb->datalen;
57e116a8:	e59732c4 	ldr	r3, [r7, #708]	; 0x2c4
	} while (blks != 0);
57e116ac:	e059900a 	subs	r9, r9, sl
			blkcnt -= blks;
			break;
		}
		start += smallblks;
		blks -= smallblks;
		buf_addr += srb->datalen;
57e116b0:	159d2004 	ldrne	r2, [sp, #4]
			if (retry--)
				goto retry_it;
			blkcnt -= blks;
			break;
		}
		start += smallblks;
57e116b4:	1086600a 	addne	r6, r6, sl
		blks -= smallblks;
		buf_addr += srb->datalen;
57e116b8:	10822003 	addne	r2, r2, r3
57e116bc:	158d2004 	strne	r2, [sp, #4]
57e116c0:	1affffa4 	bne	57e11558 <usb_stor_read+0x88>
57e116c4:	e59db008 	ldr	fp, [sp, #8]
	} while (blks != 0);
	ss->flags &= ~USB_READY;
57e116c8:	e5953004 	ldr	r3, [r5, #4]

	USB_STOR_PRINTF("usb_read: end startblk " LBAF
			", blccnt %x buffer %lx\n",
			start, smallblks, buf_addr);

	usb_disable_asynch(0); /* asynch transfer allowed */
57e116cc:	e3a00000 	mov	r0, #0
		}
		start += smallblks;
		blks -= smallblks;
		buf_addr += srb->datalen;
	} while (blks != 0);
	ss->flags &= ~USB_READY;
57e116d0:	e3c33001 	bic	r3, r3, #1
57e116d4:	e5853004 	str	r3, [r5, #4]

	USB_STOR_PRINTF("usb_read: end startblk " LBAF
			", blccnt %x buffer %lx\n",
			start, smallblks, buf_addr);

	usb_disable_asynch(0); /* asynch transfer allowed */
57e116d8:	ebfff916 	bl	57e0fb38 <usb_disable_asynch>
	if (blkcnt >= USB_MAX_XFER_BLK)
		debug("\n");
	return blkcnt;
57e116dc:	ea000000 	b	57e116e4 <usb_stor_read+0x214>
	USB_STOR_PRINTF("\nusb_read: dev %d \n", device);
	dev = NULL;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
		dev = usb_get_dev_index(i);
		if (dev == NULL)
			return 0;
57e116e0:	e1a0b000 	mov	fp, r0

	usb_disable_asynch(0); /* asynch transfer allowed */
	if (blkcnt >= USB_MAX_XFER_BLK)
		debug("\n");
	return blkcnt;
}
57e116e4:	e1a0000b 	mov	r0, fp
57e116e8:	e28dd020 	add	sp, sp, #32
57e116ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e116f0:	57e46e00 	.word	0x57e46e00
57e116f4:	57e47080 	.word	0x57e47080

57e116f8 <usb_stor_BBB_clear_endpt_stall.clone.0>:

#define USB_TRANSPORT_UNKNOWN_RETRY 5
#define USB_TRANSPORT_NOT_READY_RETRY 10

/* clear a stall on an endpoint - special for BBB devices */
static int usb_stor_BBB_clear_endpt_stall(struct us_data *us, __u8 endpt)
57e116f8:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
{
	int result;

	/* ENDPOINT_HALT = 0, so set value to 0 */
	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev, 0),
57e116fc:	e5902068 	ldr	r2, [r0, #104]	; 0x68
57e11700:	e590c000 	ldr	ip, [r0]
57e11704:	e3a03000 	mov	r3, #0
57e11708:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
57e1170c:	e58d3000 	str	r3, [sp]
57e11710:	e58d3008 	str	r3, [sp, #8]
57e11714:	e58d300c 	str	r3, [sp, #12]
57e11718:	e2833f7d 	add	r3, r3, #500	; 0x1f4
57e1171c:	e58d1004 	str	r1, [sp, #4]
57e11720:	e58d3010 	str	r3, [sp, #16]
57e11724:	e182140c 	orr	r1, r2, ip, lsl #8
57e11728:	e3a03002 	mov	r3, #2
57e1172c:	e3a02001 	mov	r2, #1
57e11730:	ebfff909 	bl	57e0fb5c <usb_control_msg>
				USB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,
				0, endpt, NULL, 0, USB_CNTL_TIMEOUT * 5);
	return result;
}
57e11734:	e28dd01c 	add	sp, sp, #28
57e11738:	e8bd8000 	pop	{pc}

57e1173c <usb_stor_BBB_transport>:

static int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
{
57e1173c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
#ifdef BBB_XPORT_TRACE
	unsigned char *ptr;
	int index;
#endif

	dir_in = US_DIRECTION(srb->cmd[0]);
57e11740:	e59f2240 	ldr	r2, [pc, #576]	; 57e11988 <usb_stor_BBB_transport+0x24c>
57e11744:	e5d03000 	ldrb	r3, [r0]
				0, endpt, NULL, 0, USB_CNTL_TIMEOUT * 5);
	return result;
}

static int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
{
57e11748:	e24ddf46 	sub	sp, sp, #280	; 0x118
#ifdef BBB_XPORT_TRACE
	unsigned char *ptr;
	int index;
#endif

	dir_in = US_DIRECTION(srb->cmd[0]);
57e1174c:	e7d271a3 	ldrb	r7, [r2, r3, lsr #3]
			printf("cmd[%d] %#x ", result, srb->cmd[result]);
		printf("\n");
	}
#endif
	/* sanity checks */
	if (!(srb->cmdlen <= CBWCDBLENGTH)) {
57e11750:	e5d02083 	ldrb	r2, [r0, #131]	; 0x83
{
	int result, retry;
	int dir_in;
	int actlen, data_actlen;
	unsigned int pipe, pipein, pipeout;
	ALLOC_CACHE_ALIGN_BUFFER(umass_bbb_csw_t, csw, 1);
57e11754:	e28d60cb 	add	r6, sp, #203	; 0xcb
			printf("cmd[%d] %#x ", result, srb->cmd[result]);
		printf("\n");
	}
#endif
	/* sanity checks */
	if (!(srb->cmdlen <= CBWCDBLENGTH)) {
57e11758:	e3520010 	cmp	r2, #16
				0, endpt, NULL, 0, USB_CNTL_TIMEOUT * 5);
	return result;
}

static int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
{
57e1175c:	e1a05000 	mov	r5, r0
57e11760:	e1a04001 	mov	r4, r1
	int result, retry;
	int dir_in;
	int actlen, data_actlen;
	unsigned int pipe, pipein, pipeout;
	ALLOC_CACHE_ALIGN_BUFFER(umass_bbb_csw_t, csw, 1);
57e11764:	e3c6603f 	bic	r6, r6, #63	; 0x3f
			printf("cmd[%d] %#x ", result, srb->cmd[result]);
		printf("\n");
	}
#endif
	/* sanity checks */
	if (!(srb->cmdlen <= CBWCDBLENGTH)) {
57e11768:	8a000083 	bhi	57e1197c <usb_stor_BBB_transport+0x240>
#ifdef BBB_XPORT_TRACE
	unsigned char *ptr;
	int index;
#endif

	dir_in = US_DIRECTION(srb->cmd[0]);
57e1176c:	e2033007 	and	r3, r3, #7
57e11770:	e1a07357 	asr	r7, r7, r3
		USB_STOR_PRINTF("usb_stor_BBB_comdat:cmdlen too large\n");
		return -1;
	}

	/* always OUT to the ep */
	pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
57e11774:	e5913000 	ldr	r3, [r1]
{
	int result;
	int actlen;
	int dir_in;
	unsigned int pipe;
	ALLOC_CACHE_ALIGN_BUFFER(umass_bbb_cbw_t, cbw, 1);
57e11778:	e28da04b 	add	sl, sp, #75	; 0x4b
		USB_STOR_PRINTF("usb_stor_BBB_comdat:cmdlen too large\n");
		return -1;
	}

	/* always OUT to the ep */
	pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
57e1177c:	e5939068 	ldr	r9, [r3, #104]	; 0x68
57e11780:	e5933000 	ldr	r3, [r3]
57e11784:	e3899103 	orr	r9, r9, #-1073741824	; 0xc0000000
57e11788:	e1899403 	orr	r9, r9, r3, lsl #8
57e1178c:	e5d1300a 	ldrb	r3, [r1, #10]
{
	int result;
	int actlen;
	int dir_in;
	unsigned int pipe;
	ALLOC_CACHE_ALIGN_BUFFER(umass_bbb_cbw_t, cbw, 1);
57e11790:	e3caa03f 	bic	sl, sl, #63	; 0x3f
		USB_STOR_PRINTF("usb_stor_BBB_comdat:cmdlen too large\n");
		return -1;
	}

	/* always OUT to the ep */
	pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
57e11794:	e1899783 	orr	r9, r9, r3, lsl #15

	cbw->dCBWSignature = cpu_to_le32(CBWSIGNATURE);
57e11798:	e59f31ec 	ldr	r3, [pc, #492]	; 57e1198c <usb_stor_BBB_transport+0x250>
	cbw->dCBWTag = cpu_to_le32(CBWTag++);
	cbw->dCBWDataTransferLength = cpu_to_le32(srb->datalen);
	cbw->bCBWFlags = (dir_in ? CBWFLAGS_IN : CBWFLAGS_OUT);
57e1179c:	e2177001 	ands	r7, r7, #1
	}

	/* always OUT to the ep */
	pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);

	cbw->dCBWSignature = cpu_to_le32(CBWSIGNATURE);
57e117a0:	e58a3000 	str	r3, [sl]
	cbw->dCBWTag = cpu_to_le32(CBWTag++);
57e117a4:	e59f31e4 	ldr	r3, [pc, #484]	; 57e11990 <usb_stor_BBB_transport+0x254>
57e117a8:	e5931300 	ldr	r1, [r3, #768]	; 0x300
57e117ac:	e58a1004 	str	r1, [sl, #4]
57e117b0:	e2811001 	add	r1, r1, #1
57e117b4:	e5831300 	str	r1, [r3, #768]	; 0x300
	cbw->dCBWDataTransferLength = cpu_to_le32(srb->datalen);
57e117b8:	e5903084 	ldr	r3, [r0, #132]	; 0x84
	cbw->bCBWFlags = (dir_in ? CBWFLAGS_IN : CBWFLAGS_OUT);
	cbw->bCBWLUN = srb->lun;
	cbw->bCDBLength = srb->cmdlen;
	/* copy the command data into the CBW command data buffer */
	/* DST SRC LEN!!! */
	memcpy(cbw->CBWCDB, srb->cmd, srb->cmdlen);
57e117bc:	e1a01005 	mov	r1, r5
	/* always OUT to the ep */
	pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);

	cbw->dCBWSignature = cpu_to_le32(CBWSIGNATURE);
	cbw->dCBWTag = cpu_to_le32(CBWTag++);
	cbw->dCBWDataTransferLength = cpu_to_le32(srb->datalen);
57e117c0:	e58a3008 	str	r3, [sl, #8]
	cbw->bCBWFlags = (dir_in ? CBWFLAGS_IN : CBWFLAGS_OUT);
57e117c4:	01a03007 	moveq	r3, r7
57e117c8:	13a03080 	movne	r3, #128	; 0x80
57e117cc:	e5ca300c 	strb	r3, [sl, #12]
	cbw->bCBWLUN = srb->lun;
57e117d0:	e5d03082 	ldrb	r3, [r0, #130]	; 0x82
	cbw->bCDBLength = srb->cmdlen;
57e117d4:	e5ca200e 	strb	r2, [sl, #14]

	cbw->dCBWSignature = cpu_to_le32(CBWSIGNATURE);
	cbw->dCBWTag = cpu_to_le32(CBWTag++);
	cbw->dCBWDataTransferLength = cpu_to_le32(srb->datalen);
	cbw->bCBWFlags = (dir_in ? CBWFLAGS_IN : CBWFLAGS_OUT);
	cbw->bCBWLUN = srb->lun;
57e117d8:	e5ca300d 	strb	r3, [sl, #13]
	cbw->bCDBLength = srb->cmdlen;
	/* copy the command data into the CBW command data buffer */
	/* DST SRC LEN!!! */
	memcpy(cbw->CBWCDB, srb->cmd, srb->cmdlen);
57e117dc:	e28a000f 	add	r0, sl, #15
57e117e0:	eb004ac9 	bl	57e2430c <memcpy>
	result = usb_bulk_msg(us->pusb_dev, pipe, cbw, UMASS_BBB_CBW_SIZE,
57e117e4:	e28d3f43 	add	r3, sp, #268	; 0x10c
57e117e8:	e58d3000 	str	r3, [sp]
57e117ec:	e3a03f7d 	mov	r3, #500	; 0x1f4
57e117f0:	e58d3004 	str	r3, [sp, #4]
57e117f4:	e5940000 	ldr	r0, [r4]
57e117f8:	e1a01009 	mov	r1, r9
57e117fc:	e1a0200a 	mov	r2, sl
57e11800:	e3a0301f 	mov	r3, #31
57e11804:	ebfff97e 	bl	57e0fe04 <usb_bulk_msg>
	dir_in = US_DIRECTION(srb->cmd[0]);

	/* COMMAND phase */
	USB_STOR_PRINTF("COMMAND phase\n");
	result = usb_stor_BBB_comdat(srb, us);
	if (result < 0) {
57e11808:	e3500000 	cmp	r0, #0
57e1180c:	ba00005a 	blt	57e1197c <usb_stor_BBB_transport+0x240>
		USB_STOR_PRINTF("failed to send CBW status %ld\n",
			us->pusb_dev->status);
		usb_stor_BBB_reset(us);
		return USB_STOR_TRANSPORT_FAILED;
	}
	if (!(us->flags & USB_READY))
57e11810:	e5943004 	ldr	r3, [r4, #4]
57e11814:	e3130001 	tst	r3, #1
57e11818:	1a000001 	bne	57e11824 <usb_stor_BBB_transport+0xe8>
		mdelay(5);
57e1181c:	e3a00005 	mov	r0, #5
57e11820:	eb004b50 	bl	57e24568 <mdelay>
	pipein = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
57e11824:	e5940000 	ldr	r0, [r4]
57e11828:	e5d43009 	ldrb	r3, [r4, #9]
57e1182c:	e590c068 	ldr	ip, [r0, #104]	; 0x68
57e11830:	e5902000 	ldr	r2, [r0]
57e11834:	e38cc103 	orr	ip, ip, #-1073741824	; 0xc0000000
57e11838:	e1a02402 	lsl	r2, r2, #8
57e1183c:	e38ca080 	orr	sl, ip, #128	; 0x80
57e11840:	e18aa002 	orr	sl, sl, r2
57e11844:	e18aa783 	orr	sl, sl, r3, lsl #15
	pipeout = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
	/* DATA phase + error handling */
	data_actlen = 0;
57e11848:	e3a03000 	mov	r3, #0
57e1184c:	e58d3110 	str	r3, [sp, #272]	; 0x110
	/* no data, go immediately to the STATUS phase */
	if (srb->datalen == 0)
57e11850:	e5953084 	ldr	r3, [r5, #132]	; 0x84
		return USB_STOR_TRANSPORT_FAILED;
	}
	if (!(us->flags & USB_READY))
		mdelay(5);
	pipein = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
	pipeout = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
57e11854:	e5d4100a 	ldrb	r1, [r4, #10]
	/* DATA phase + error handling */
	data_actlen = 0;
	/* no data, go immediately to the STATUS phase */
	if (srb->datalen == 0)
57e11858:	e3530000 	cmp	r3, #0
57e1185c:	0a000015 	beq	57e118b8 <usb_stor_BBB_transport+0x17c>
		goto st;
	USB_STOR_PRINTF("DATA phase\n");
	if (dir_in)
57e11860:	e3570000 	cmp	r7, #0
		return USB_STOR_TRANSPORT_FAILED;
	}
	if (!(us->flags & USB_READY))
		mdelay(5);
	pipein = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
	pipeout = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
57e11864:	018c2002 	orreq	r2, ip, r2
57e11868:	01821781 	orreq	r1, r2, r1, lsl #15
	USB_STOR_PRINTF("DATA phase\n");
	if (dir_in)
		pipe = pipein;
	else
		pipe = pipeout;
	result = usb_bulk_msg(us->pusb_dev, pipe, srb->pdata, srb->datalen,
57e1186c:	e28d2e11 	add	r2, sp, #272	; 0x110
57e11870:	e58d2000 	str	r2, [sp]
57e11874:	e3a02f7d 	mov	r2, #500	; 0x1f4
	/* no data, go immediately to the STATUS phase */
	if (srb->datalen == 0)
		goto st;
	USB_STOR_PRINTF("DATA phase\n");
	if (dir_in)
		pipe = pipein;
57e11878:	11a0100a 	movne	r1, sl
	else
		pipe = pipeout;
	result = usb_bulk_msg(us->pusb_dev, pipe, srb->pdata, srb->datalen,
57e1187c:	e58d2004 	str	r2, [sp, #4]
57e11880:	e5952088 	ldr	r2, [r5, #136]	; 0x88
57e11884:	ebfff95e 	bl	57e0fe04 <usb_bulk_msg>
			      &data_actlen, USB_CNTL_TIMEOUT * 5);
	/* special handling of STALL in DATA phase */
	if ((result < 0) && (us->pusb_dev->status & USB_ST_STALLED)) {
57e11888:	e3500000 	cmp	r0, #0
57e1188c:	aa000009 	bge	57e118b8 <usb_stor_BBB_transport+0x17c>
57e11890:	e5940000 	ldr	r0, [r4]
57e11894:	e5903614 	ldr	r3, [r0, #1556]	; 0x614
57e11898:	e3130002 	tst	r3, #2
57e1189c:	0a000036 	beq	57e1197c <usb_stor_BBB_transport+0x240>
		USB_STOR_PRINTF("DATA:stall\n");
		/* clear the STALL on the endpoint */
		result = usb_stor_BBB_clear_endpt_stall(us,
57e118a0:	e3570000 	cmp	r7, #0
57e118a4:	15d41009 	ldrbne	r1, [r4, #9]
57e118a8:	05d4100a 	ldrbeq	r1, [r4, #10]
57e118ac:	ebffff91 	bl	57e116f8 <usb_stor_BBB_clear_endpt_stall.clone.0>
					dir_in ? us->ep_in : us->ep_out);
		if (result >= 0)
57e118b0:	e3500000 	cmp	r0, #0
57e118b4:	ba000030 	blt	57e1197c <usb_stor_BBB_transport+0x240>
		goto st;
	USB_STOR_PRINTF("DATA phase\n");
	if (dir_in)
		pipe = pipein;
	else
		pipe = pipeout;
57e118b8:	e3a07000 	mov	r7, #0
	/* STATUS phase + error handling */
st:
	retry = 0;
again:
	USB_STOR_PRINTF("STATUS phase\n");
	result = usb_bulk_msg(us->pusb_dev, pipein, csw, UMASS_BBB_CSW_SIZE,
57e118bc:	e28d9f45 	add	r9, sp, #276	; 0x114
57e118c0:	e3a0bf7d 	mov	fp, #500	; 0x1f4
57e118c4:	ea000000 	b	57e118cc <usb_stor_BBB_transport+0x190>
	if ((result < 0) && (retry < 1) &&
	    (us->pusb_dev->status & USB_ST_STALLED)) {
		USB_STOR_PRINTF("STATUS:stall\n");
		/* clear the STALL on the endpoint */
		result = usb_stor_BBB_clear_endpt_stall(us, us->ep_in);
		if (result >= 0 && (retry++ < 1))
57e118c8:	e3a07001 	mov	r7, #1
	/* STATUS phase + error handling */
st:
	retry = 0;
again:
	USB_STOR_PRINTF("STATUS phase\n");
	result = usb_bulk_msg(us->pusb_dev, pipein, csw, UMASS_BBB_CSW_SIZE,
57e118cc:	e5940000 	ldr	r0, [r4]
57e118d0:	e1a0100a 	mov	r1, sl
57e118d4:	e1a02006 	mov	r2, r6
57e118d8:	e3a0300d 	mov	r3, #13
57e118dc:	e88d0a00 	stm	sp, {r9, fp}
57e118e0:	ebfff947 	bl	57e0fe04 <usb_bulk_msg>
				&actlen, USB_CNTL_TIMEOUT*5);

	/* special handling of STALL in STATUS phase */
	if ((result < 0) && (retry < 1) &&
57e118e4:	e2277001 	eor	r7, r7, #1
57e118e8:	e0177fa0 	ands	r7, r7, r0, lsr #31
57e118ec:	0a000008 	beq	57e11914 <usb_stor_BBB_transport+0x1d8>
	    (us->pusb_dev->status & USB_ST_STALLED)) {
57e118f0:	e5940000 	ldr	r0, [r4]
57e118f4:	e5903614 	ldr	r3, [r0, #1556]	; 0x614
	USB_STOR_PRINTF("STATUS phase\n");
	result = usb_bulk_msg(us->pusb_dev, pipein, csw, UMASS_BBB_CSW_SIZE,
				&actlen, USB_CNTL_TIMEOUT*5);

	/* special handling of STALL in STATUS phase */
	if ((result < 0) && (retry < 1) &&
57e118f8:	e3130002 	tst	r3, #2
57e118fc:	0a00001e 	beq	57e1197c <usb_stor_BBB_transport+0x240>
	    (us->pusb_dev->status & USB_ST_STALLED)) {
		USB_STOR_PRINTF("STATUS:stall\n");
		/* clear the STALL on the endpoint */
		result = usb_stor_BBB_clear_endpt_stall(us, us->ep_in);
57e11900:	e5d41009 	ldrb	r1, [r4, #9]
57e11904:	ebffff7b 	bl	57e116f8 <usb_stor_BBB_clear_endpt_stall.clone.0>
		if (result >= 0 && (retry++ < 1))
57e11908:	e3500000 	cmp	r0, #0
57e1190c:	aaffffed 	bge	57e118c8 <usb_stor_BBB_transport+0x18c>
57e11910:	ea000019 	b	57e1197c <usb_stor_BBB_transport+0x240>
			/* do a retry */
			goto again;
	}
	if (result < 0) {
57e11914:	e3500000 	cmp	r0, #0
57e11918:	ba000017 	blt	57e1197c <usb_stor_BBB_transport+0x240>
#endif
	/* misuse pipe to get the residue */
	pipe = le32_to_cpu(csw->dCSWDataResidue);
	if (pipe == 0 && srb->datalen != 0 && srb->datalen - data_actlen != 0)
		pipe = srb->datalen - data_actlen;
	if (CSWSIGNATURE != le32_to_cpu(csw->dCSWSignature)) {
57e1191c:	e5962000 	ldr	r2, [r6]
57e11920:	e59f306c 	ldr	r3, [pc, #108]	; 57e11994 <usb_stor_BBB_transport+0x258>
57e11924:	e1520003 	cmp	r2, r3
57e11928:	1a000013 	bne	57e1197c <usb_stor_BBB_transport+0x240>
		USB_STOR_PRINTF("!CSWSIGNATURE\n");
		usb_stor_BBB_reset(us);
		return USB_STOR_TRANSPORT_FAILED;
	} else if ((CBWTag - 1) != le32_to_cpu(csw->dCSWTag)) {
57e1192c:	e59f305c 	ldr	r3, [pc, #92]	; 57e11990 <usb_stor_BBB_transport+0x254>
57e11930:	e5932300 	ldr	r2, [r3, #768]	; 0x300
57e11934:	e5963004 	ldr	r3, [r6, #4]
57e11938:	e2422001 	sub	r2, r2, #1
57e1193c:	e1520003 	cmp	r2, r3
57e11940:	1a00000d 	bne	57e1197c <usb_stor_BBB_transport+0x240>
		USB_STOR_PRINTF("!Tag\n");
		usb_stor_BBB_reset(us);
		return USB_STOR_TRANSPORT_FAILED;
	} else if (csw->bCSWStatus > CSWSTATUS_PHASE) {
57e11944:	e5d6300c 	ldrb	r3, [r6, #12]
57e11948:	e3530002 	cmp	r3, #2
57e1194c:	8a00000a 	bhi	57e1197c <usb_stor_BBB_transport+0x240>
		USB_STOR_PRINTF(">PHASE\n");
		usb_stor_BBB_reset(us);
		return USB_STOR_TRANSPORT_FAILED;
	} else if (csw->bCSWStatus == CSWSTATUS_PHASE) {
57e11950:	0a000009 	beq	57e1197c <usb_stor_BBB_transport+0x240>
		USB_STOR_PRINTF("=PHASE\n");
		usb_stor_BBB_reset(us);
		return USB_STOR_TRANSPORT_FAILED;
	} else if (data_actlen > srb->datalen) {
57e11954:	e5952084 	ldr	r2, [r5, #132]	; 0x84
57e11958:	e59d1110 	ldr	r1, [sp, #272]	; 0x110
57e1195c:	e1510002 	cmp	r1, r2
57e11960:	8a000002 	bhi	57e11970 <usb_stor_BBB_transport+0x234>
		USB_STOR_PRINTF("transferred %dB instead of %ldB\n",
			data_actlen, srb->datalen);
		return USB_STOR_TRANSPORT_FAILED;
	} else if (csw->bCSWStatus == CSWSTATUS_FAILED) {
		USB_STOR_PRINTF("FAILED\n");
		return USB_STOR_TRANSPORT_FAILED;
57e11964:	e3530001 	cmp	r3, #1
57e11968:	03e00000 	mvneq	r0, #0
57e1196c:	ea000000 	b	57e11974 <usb_stor_BBB_transport+0x238>
		usb_stor_BBB_reset(us);
		return USB_STOR_TRANSPORT_FAILED;
	} else if (data_actlen > srb->datalen) {
		USB_STOR_PRINTF("transferred %dB instead of %ldB\n",
			data_actlen, srb->datalen);
		return USB_STOR_TRANSPORT_FAILED;
57e11970:	e3e00000 	mvn	r0, #0
		USB_STOR_PRINTF("FAILED\n");
		return USB_STOR_TRANSPORT_FAILED;
	}

	return result;
}
57e11974:	e28ddf46 	add	sp, sp, #280	; 0x118
57e11978:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			goto st;
	}
	if (result < 0) {
		USB_STOR_PRINTF("usb_bulk_msg error status %ld\n",
			us->pusb_dev->status);
		usb_stor_BBB_reset(us);
57e1197c:	e1a00004 	mov	r0, r4
57e11980:	ebfffddf 	bl	57e11104 <usb_stor_BBB_reset>
57e11984:	eafffff9 	b	57e11970 <usb_stor_BBB_transport+0x234>
57e11988:	57e2c224 	.word	0x57e2c224
57e1198c:	43425355 	.word	0x43425355
57e11990:	57e46e00 	.word	0x57e46e00
57e11994:	53425355 	.word	0x53425355

57e11998 <usb_stor_CB_comdat>:

/* FIXME: we also need a CBI_command which sets up the completion
 * interrupt, and waits for it
 */
static int usb_stor_CB_comdat(ccb *srb, struct us_data *us)
{
57e11998:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int dir_in, retry;
	unsigned int pipe;
	unsigned long status;

	retry = 5;
	dir_in = US_DIRECTION(srb->cmd[0]);
57e1199c:	e59f2220 	ldr	r2, [pc, #544]	; 57e11bc4 <usb_stor_CB_comdat+0x22c>
57e119a0:	e5d03000 	ldrb	r3, [r0]

/* FIXME: we also need a CBI_command which sets up the completion
 * interrupt, and waits for it
 */
static int usb_stor_CB_comdat(ccb *srb, struct us_data *us)
{
57e119a4:	e24dd030 	sub	sp, sp, #48	; 0x30
	int dir_in, retry;
	unsigned int pipe;
	unsigned long status;

	retry = 5;
	dir_in = US_DIRECTION(srb->cmd[0]);
57e119a8:	e7d221a3 	ldrb	r2, [r2, r3, lsr #3]
57e119ac:	e2033007 	and	r3, r3, #7
57e119b0:	e1a03352 	asr	r3, r2, r3

	if (dir_in)
57e119b4:	e3130001 	tst	r3, #1

/* FIXME: we also need a CBI_command which sets up the completion
 * interrupt, and waits for it
 */
static int usb_stor_CB_comdat(ccb *srb, struct us_data *us)
{
57e119b8:	e1a06000 	mov	r6, r0
57e119bc:	e1a04001 	mov	r4, r1
57e119c0:	e5913000 	ldr	r3, [r1]
	unsigned long status;

	retry = 5;
	dir_in = US_DIRECTION(srb->cmd[0]);

	if (dir_in)
57e119c4:	0a000006 	beq	57e119e4 <usb_stor_CB_comdat+0x4c>
		pipe = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
57e119c8:	e593a068 	ldr	sl, [r3, #104]	; 0x68
57e119cc:	e5933000 	ldr	r3, [r3]
57e119d0:	e38aa103 	orr	sl, sl, #-1073741824	; 0xc0000000
57e119d4:	e38aa080 	orr	sl, sl, #128	; 0x80
57e119d8:	e18aa403 	orr	sl, sl, r3, lsl #8
57e119dc:	e5d13009 	ldrb	r3, [r1, #9]
57e119e0:	ea000004 	b	57e119f8 <usb_stor_CB_comdat+0x60>
	else
		pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
57e119e4:	e593a068 	ldr	sl, [r3, #104]	; 0x68
57e119e8:	e5933000 	ldr	r3, [r3]
57e119ec:	e38aa103 	orr	sl, sl, #-1073741824	; 0xc0000000
57e119f0:	e18aa403 	orr	sl, sl, r3, lsl #8
57e119f4:	e5d1300a 	ldrb	r3, [r1, #10]
			/* continue until this transfer is done */
		} while (this_xfer);
	}

	/* if we get here, we're done and successful */
	return 0;
57e119f8:	e3a0c005 	mov	ip, #5
	dir_in = US_DIRECTION(srb->cmd[0]);

	if (dir_in)
		pipe = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
	else
		pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
57e119fc:	e18aa783 	orr	sl, sl, r3, lsl #15
			/* continue until this transfer is done */
		} while (this_xfer);
	}

	/* if we get here, we're done and successful */
	return 0;
57e11a00:	e58dc020 	str	ip, [sp, #32]
57e11a04:	e3a09000 	mov	r9, #0
57e11a08:	ea000065 	b	57e11ba4 <usb_stor_CB_comdat+0x20c>
#ifdef USB_STOR_DEBUG
		usb_show_srb(srb);
#endif
		/* let's send the command via the control pipe */
		result = usb_control_msg(us->pusb_dev,
					 usb_sndctrlpipe(us->pusb_dev , 0),
57e11a0c:	e5940000 	ldr	r0, [r4]
		USB_STOR_PRINTF("CBI gets a command: Try %d\n", 5 - retry);
#ifdef USB_STOR_DEBUG
		usb_show_srb(srb);
#endif
		/* let's send the command via the control pipe */
		result = usb_control_msg(us->pusb_dev,
57e11a10:	e5d4c008 	ldrb	ip, [r4, #8]
57e11a14:	e3a02000 	mov	r2, #0
					 usb_sndctrlpipe(us->pusb_dev , 0),
57e11a18:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e11a1c:	e5901000 	ldr	r1, [r0]
		USB_STOR_PRINTF("CBI gets a command: Try %d\n", 5 - retry);
#ifdef USB_STOR_DEBUG
		usb_show_srb(srb);
#endif
		/* let's send the command via the control pipe */
		result = usb_control_msg(us->pusb_dev,
57e11a20:	e88d1004 	stm	sp, {r2, ip}
57e11a24:	e58d6008 	str	r6, [sp, #8]
57e11a28:	e5d6c083 	ldrb	ip, [r6, #131]	; 0x83
					 usb_sndctrlpipe(us->pusb_dev , 0),
57e11a2c:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
		USB_STOR_PRINTF("CBI gets a command: Try %d\n", 5 - retry);
#ifdef USB_STOR_DEBUG
		usb_show_srb(srb);
#endif
		/* let's send the command via the control pipe */
		result = usb_control_msg(us->pusb_dev,
57e11a30:	e58dc00c 	str	ip, [sp, #12]
57e11a34:	e1831401 	orr	r1, r3, r1, lsl #8
57e11a38:	e3a0cf7d 	mov	ip, #500	; 0x1f4
57e11a3c:	e3a03021 	mov	r3, #33	; 0x21
57e11a40:	e58dc010 	str	ip, [sp, #16]
57e11a44:	ebfff844 	bl	57e0fb5c <usb_control_msg>
					 srb->cmd, srb->cmdlen,
					 USB_CNTL_TIMEOUT * 5);
		USB_STOR_PRINTF("CB_transport: control msg returned %d,"
				" status %lX\n", result, us->pusb_dev->status);
		/* check the return code for the command */
		if (result < 0) {
57e11a48:	e2509000 	subs	r9, r0, #0
57e11a4c:	aa00000b 	bge	57e11a80 <usb_stor_CB_comdat+0xe8>
			if (us->pusb_dev->status & USB_ST_STALLED) {
57e11a50:	e5940000 	ldr	r0, [r4]
57e11a54:	e5905614 	ldr	r5, [r0, #1556]	; 0x614
57e11a58:	e3150002 	tst	r5, #2
57e11a5c:	0a000055 	beq	57e11bb8 <usb_stor_CB_comdat+0x220>
				status = us->pusb_dev->status;
				USB_STOR_PRINTF(" stall during command found,"
						" clear pipe\n");
				usb_clear_halt(us->pusb_dev,
					      usb_sndctrlpipe(us->pusb_dev, 0));
57e11a60:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e11a64:	e5901000 	ldr	r1, [r0]
57e11a68:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
		if (result < 0) {
			if (us->pusb_dev->status & USB_ST_STALLED) {
				status = us->pusb_dev->status;
				USB_STOR_PRINTF(" stall during command found,"
						" clear pipe\n");
				usb_clear_halt(us->pusb_dev,
57e11a6c:	e1831401 	orr	r1, r3, r1, lsl #8
57e11a70:	ebfff909 	bl	57e0fe9c <usb_clear_halt>
					      usb_sndctrlpipe(us->pusb_dev, 0));
				us->pusb_dev->status = status;
57e11a74:	e5943000 	ldr	r3, [r4]
57e11a78:	e5835614 	str	r5, [r3, #1556]	; 0x614
57e11a7c:	ea00004d 	b	57e11bb8 <usb_stor_CB_comdat+0x220>
		/* transfer the data payload for this command, if one exists*/

		USB_STOR_PRINTF("CB_transport: control msg returned %d,"
				" direction is %s to go 0x%lx\n", result,
				dir_in ? "IN" : "OUT", srb->datalen);
		if (srb->datalen) {
57e11a80:	e5967084 	ldr	r7, [r6, #132]	; 0x84
57e11a84:	e3570000 	cmp	r7, #0
57e11a88:	0a00004a 	beq	57e11bb8 <usb_stor_CB_comdat+0x220>
			result = us_one_transfer(us, pipe, (char *)srb->pdata,
57e11a8c:	e596c088 	ldr	ip, [r6, #136]	; 0x88
	int partial;
	int maxtry;
	int stat;

	/* determine the maximum packet size for these transfers */
	max_size = usb_maxpacket(us->pusb_dev, pipe) * 16;
57e11a90:	e5940000 	ldr	r0, [r4]
57e11a94:	e1a0100a 	mov	r1, sl
57e11a98:	e58dc01c 	str	ip, [sp, #28]
57e11a9c:	ebfff8f5 	bl	57e0fe78 <usb_maxpacket>
57e11aa0:	e59dc01c 	ldr	ip, [sp, #28]
57e11aa4:	e1a00200 	lsl	r0, r0, #4
57e11aa8:	e58d0024 	str	r0, [sp, #36]	; 0x24
57e11aac:	e1a09006 	mov	r9, r6

	/* while we have data left to transfer */
	while (length) {

		/* calculate how long this will be -- maximum or a remainder */
		this_xfer = length > max_size ? max_size : length;
57e11ab0:	e59db024 	ldr	fp, [sp, #36]	; 0x24
		length -= this_xfer;

		/* setup the retry counter */
		maxtry = 10;
57e11ab4:	e3a0600a 	mov	r6, #10

	/* while we have data left to transfer */
	while (length) {

		/* calculate how long this will be -- maximum or a remainder */
		this_xfer = length > max_size ? max_size : length;
57e11ab8:	e15b0007 	cmp	fp, r7
57e11abc:	a1a0b007 	movge	fp, r7
57e11ac0:	e1a0500b 	mov	r5, fp
		/* set up the transfer loop */
		do {
			/* transfer the data */
			USB_STOR_PRINTF("Bulk xfer 0x%x(%d) try #%d\n",
				  (unsigned int)buf, this_xfer, 11 - maxtry);
			result = usb_bulk_msg(us->pusb_dev, pipe, buf,
57e11ac4:	e28d302c 	add	r3, sp, #44	; 0x2c
57e11ac8:	e58d3000 	str	r3, [sp]
57e11acc:	e3a03f7d 	mov	r3, #500	; 0x1f4
57e11ad0:	e1a0200c 	mov	r2, ip
57e11ad4:	e58d3004 	str	r3, [sp, #4]
57e11ad8:	e5940000 	ldr	r0, [r4]
57e11adc:	e1a03005 	mov	r3, r5
57e11ae0:	e1a0100a 	mov	r1, sl
57e11ae4:	e58dc01c 	str	ip, [sp, #28]
57e11ae8:	ebfff8c5 	bl	57e0fe04 <usb_bulk_msg>
					      this_xfer, &partial,
					      USB_CNTL_TIMEOUT * 5);
			USB_STOR_PRINTF("bulk_msg returned %d xferred %d/%d\n",
				  result, partial, this_xfer);
			if (us->pusb_dev->status != 0) {
57e11aec:	e5942000 	ldr	r2, [r4]
57e11af0:	e59dc01c 	ldr	ip, [sp, #28]
57e11af4:	e5923614 	ldr	r3, [r2, #1556]	; 0x614
57e11af8:	e3530000 	cmp	r3, #0
57e11afc:	0a000015 	beq	57e11b58 <usb_stor_CB_comdat+0x1c0>
				 * we go on
				 */
#ifdef USB_STOR_DEBUG
				display_int_status(us->pusb_dev->status);
#endif
				if (us->pusb_dev->status & USB_ST_STALLED) {
57e11b00:	e3130002 	tst	r3, #2
57e11b04:	0a00000b 	beq	57e11b38 <usb_stor_CB_comdat+0x1a0>
57e11b08:	e1a06009 	mov	r6, r9
					USB_STOR_PRINTF("stalled ->clearing endpoint halt for pipe 0x%x\n", pipe);
					stat = us->pusb_dev->status;
					usb_clear_halt(us->pusb_dev, pipe);
57e11b0c:	e1a0100a 	mov	r1, sl
57e11b10:	e1a09000 	mov	r9, r0
57e11b14:	e1a00002 	mov	r0, r2
57e11b18:	e1a0b003 	mov	fp, r3
57e11b1c:	ebfff8de 	bl	57e0fe9c <usb_clear_halt>
					us->pusb_dev->status = stat;
57e11b20:	e5943000 	ldr	r3, [r4]
57e11b24:	e583b614 	str	fp, [r3, #1556]	; 0x614
					if (this_xfer == partial) {
						USB_STOR_PRINTF("bulk transferred with error %lX, but data ok\n", us->pusb_dev->status);
						return 0;
57e11b28:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
57e11b2c:	e1550003 	cmp	r5, r3
57e11b30:	03a09000 	moveq	r9, #0
57e11b34:	ea000016 	b	57e11b94 <usb_stor_CB_comdat+0x1fc>
					}
					else
						return result;
				}
				if (us->pusb_dev->status & USB_ST_NAK_REC) {
57e11b38:	e2133010 	ands	r3, r3, #16
57e11b3c:	1a000012 	bne	57e11b8c <usb_stor_CB_comdat+0x1f4>
					USB_STOR_PRINTF("Device NAKed bulk_msg\n");
					return result;
				}
				USB_STOR_PRINTF("bulk transferred with error");
				if (this_xfer == partial) {
57e11b40:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
57e11b44:	e1550002 	cmp	r5, r2
57e11b48:	0a00000b 	beq	57e11b7c <usb_stor_CB_comdat+0x1e4>
					return 0;
				}
				/* if our try counter reaches 0, bail out */
					USB_STOR_PRINTF(" %ld, data %d\n",
						us->pusb_dev->status, partial);
				if (!maxtry--)
57e11b4c:	e3560000 	cmp	r6, #0
57e11b50:	0a00000d 	beq	57e11b8c <usb_stor_CB_comdat+0x1f4>
57e11b54:	e2466001 	sub	r6, r6, #1
						return result;
			}
			/* update to show what data was transferred */
			this_xfer -= partial;
57e11b58:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
			buf += partial;
			/* continue until this transfer is done */
		} while (this_xfer);
57e11b5c:	e0555003 	subs	r5, r5, r3
				if (!maxtry--)
						return result;
			}
			/* update to show what data was transferred */
			this_xfer -= partial;
			buf += partial;
57e11b60:	e08cc003 	add	ip, ip, r3
			/* continue until this transfer is done */
		} while (this_xfer);
57e11b64:	1affffd6 	bne	57e11ac4 <usb_stor_CB_comdat+0x12c>

	/* determine the maximum packet size for these transfers */
	max_size = usb_maxpacket(us->pusb_dev, pipe) * 16;

	/* while we have data left to transfer */
	while (length) {
57e11b68:	e057700b 	subs	r7, r7, fp
57e11b6c:	1affffcf 	bne	57e11ab0 <usb_stor_CB_comdat+0x118>
57e11b70:	e1a06009 	mov	r6, r9
			/* continue until this transfer is done */
		} while (this_xfer);
	}

	/* if we get here, we're done and successful */
	return 0;
57e11b74:	e1a09007 	mov	r9, r7
57e11b78:	ea000005 	b	57e11b94 <usb_stor_CB_comdat+0x1fc>
57e11b7c:	e1a06009 	mov	r6, r9
57e11b80:	e1a0b003 	mov	fp, r3
				}
				USB_STOR_PRINTF("bulk transferred with error");
				if (this_xfer == partial) {
					USB_STOR_PRINTF(" %ld, but data ok\n",
							us->pusb_dev->status);
					return 0;
57e11b84:	e1a09003 	mov	r9, r3
57e11b88:	ea000001 	b	57e11b94 <usb_stor_CB_comdat+0x1fc>
57e11b8c:	e1a06009 	mov	r6, r9
57e11b90:	e1a09000 	mov	r9, r0
						 srb->datalen);
			USB_STOR_PRINTF("CBI attempted to transfer data,"
					" result is %d status %lX, len %d\n",
					result, us->pusb_dev->status,
					us->pusb_dev->act_len);
			if (!(us->pusb_dev->status & USB_ST_NAK_REC))
57e11b94:	e5943000 	ldr	r3, [r4]
57e11b98:	e5933614 	ldr	r3, [r3, #1556]	; 0x614
57e11b9c:	e3130010 	tst	r3, #16
57e11ba0:	0a000004 	beq	57e11bb8 <usb_stor_CB_comdat+0x220>
	if (dir_in)
		pipe = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
	else
		pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);

	while (retry--) {
57e11ba4:	e59d3020 	ldr	r3, [sp, #32]
57e11ba8:	e2433001 	sub	r3, r3, #1
57e11bac:	e3730001 	cmn	r3, #1
57e11bb0:	e58d3020 	str	r3, [sp, #32]
57e11bb4:	1affff94 	bne	57e11a0c <usb_stor_CB_comdat+0x74>
			break;
	}
	/* return result */

	return result;
}
57e11bb8:	e1a00009 	mov	r0, r9
57e11bbc:	e28dd030 	add	sp, sp, #48	; 0x30
57e11bc0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e11bc4:	57e2c224 	.word	0x57e2c224

57e11bc8 <usb_stor_CBI_get_status.clone.2>:


static int usb_stor_CBI_get_status(ccb *srb, struct us_data *us)
57e11bc8:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
{
	int timeout;

	us->ip_wanted = 1;
	submit_int_msg(us->pusb_dev, us->irqpipe,
57e11bcc:	e5d12025 	ldrb	r2, [r1, #37]	; 0x25

static int usb_stor_CBI_get_status(ccb *srb, struct us_data *us)
{
	int timeout;

	us->ip_wanted = 1;
57e11bd0:	e3a03001 	mov	r3, #1
57e11bd4:	e5813018 	str	r3, [r1, #24]

	return result;
}


static int usb_stor_CBI_get_status(ccb *srb, struct us_data *us)
57e11bd8:	e1a04001 	mov	r4, r1
{
	int timeout;

	us->ip_wanted = 1;
	submit_int_msg(us->pusb_dev, us->irqpipe,
57e11bdc:	e5d13024 	ldrb	r3, [r1, #36]	; 0x24
57e11be0:	e58d2000 	str	r2, [sp]

	return result;
}


static int usb_stor_CBI_get_status(ccb *srb, struct us_data *us)
57e11be4:	e1a05000 	mov	r5, r0
{
	int timeout;

	us->ip_wanted = 1;
	submit_int_msg(us->pusb_dev, us->irqpipe,
57e11be8:	e2842010 	add	r2, r4, #16
57e11bec:	e5910000 	ldr	r0, [r1]
57e11bf0:	e5911020 	ldr	r1, [r1, #32]
57e11bf4:	eb003315 	bl	57e1e850 <submit_int_msg>
			(void *) &us->ip_data, us->irqmaxp, us->irqinterval);
	timeout = 1000;
57e11bf8:	e3a06ffa 	mov	r6, #1000	; 0x3e8
57e11bfc:	ea000004 	b	57e11c14 <usb_stor_CBI_get_status.clone.2+0x4c>
	while (timeout--) {
		if ((volatile int *) us->ip_wanted == NULL)
57e11c00:	e5943018 	ldr	r3, [r4, #24]
57e11c04:	e3530000 	cmp	r3, #0
57e11c08:	0a000003 	beq	57e11c1c <usb_stor_CBI_get_status.clone.2+0x54>
			break;
		mdelay(10);
57e11c0c:	e3a0000a 	mov	r0, #10
57e11c10:	eb004a54 	bl	57e24568 <mdelay>

	us->ip_wanted = 1;
	submit_int_msg(us->pusb_dev, us->irqpipe,
			(void *) &us->ip_data, us->irqmaxp, us->irqinterval);
	timeout = 1000;
	while (timeout--) {
57e11c14:	e2566001 	subs	r6, r6, #1
57e11c18:	2afffff8 	bcs	57e11c00 <usb_stor_CBI_get_status.clone.2+0x38>
		if ((volatile int *) us->ip_wanted == NULL)
			break;
		mdelay(10);
	}
	if (us->ip_wanted) {
57e11c1c:	e5940018 	ldr	r0, [r4, #24]
57e11c20:	e3500000 	cmp	r0, #0
57e11c24:	0a000004 	beq	57e11c3c <usb_stor_CBI_get_status.clone.2+0x74>
		printf("	Did not get interrupt on CBI\n");
57e11c28:	e59f0064 	ldr	r0, [pc, #100]	; 57e11c94 <usb_stor_CBI_get_status.clone.2+0xcc>
57e11c2c:	ebffde06 	bl	57e0944c <printf>
		us->ip_wanted = 0;
57e11c30:	e3a03000 	mov	r3, #0
57e11c34:	e5843018 	str	r3, [r4, #24]
57e11c38:	ea000013 	b	57e11c8c <usb_stor_CBI_get_status.clone.2+0xc4>
	USB_STOR_PRINTF
		("Got interrupt data 0x%x, transfered %d status 0x%lX\n",
		 us->ip_data, us->pusb_dev->irq_act_len,
		 us->pusb_dev->irq_status);
	/* UFI gives us ASC and ASCQ, like a request sense */
	if (us->subclass == US_SC_UFI) {
57e11c3c:	e5d4300c 	ldrb	r3, [r4, #12]
57e11c40:	e3530004 	cmp	r3, #4
57e11c44:	1a000007 	bne	57e11c68 <usb_stor_CBI_get_status.clone.2+0xa0>
		if (srb->cmd[0] == SCSI_REQ_SENSE ||
57e11c48:	e5d53000 	ldrb	r3, [r5]
57e11c4c:	e3530003 	cmp	r3, #3
57e11c50:	13530012 	cmpne	r3, #18
57e11c54:	0a00000d 	beq	57e11c90 <usb_stor_CBI_get_status.clone.2+0xc8>
		    srb->cmd[0] == SCSI_INQUIRY)
			return USB_STOR_TRANSPORT_GOOD; /* Good */
		else if (us->ip_data)
57e11c58:	e1d401b0 	ldrh	r0, [r4, #16]
			return USB_STOR_TRANSPORT_FAILED;
57e11c5c:	e3500000 	cmp	r0, #0
57e11c60:	13e00000 	mvnne	r0, #0
57e11c64:	ea000009 	b	57e11c90 <usb_stor_CBI_get_status.clone.2+0xc8>
		else
			return USB_STOR_TRANSPORT_GOOD;
	}
	/* otherwise, we interpret the data normally */
	switch (us->ip_data) {
57e11c68:	e1d431b0 	ldrh	r3, [r4, #16]
57e11c6c:	e2433001 	sub	r3, r3, #1
57e11c70:	e1a03803 	lsl	r3, r3, #16
57e11c74:	e1a03823 	lsr	r3, r3, #16
57e11c78:	e3530001 	cmp	r3, #1
57e11c7c:	959f2014 	ldrls	r2, [pc, #20]	; 57e11c98 <usb_stor_CBI_get_status.clone.2+0xd0>
57e11c80:	90823103 	addls	r3, r2, r3, lsl #2
57e11c84:	95930020 	ldrls	r0, [r3, #32]
57e11c88:	9a000000 	bls	57e11c90 <usb_stor_CBI_get_status.clone.2+0xc8>
57e11c8c:	e3e00001 	mvn	r0, #1
		return USB_STOR_TRANSPORT_FAILED;
	default:
		return USB_STOR_TRANSPORT_ERROR;
	}			/* switch */
	return USB_STOR_TRANSPORT_ERROR;
}
57e11c90:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
57e11c94:	57e32df8 	.word	0x57e32df8
57e11c98:	57e2c224 	.word	0x57e2c224

57e11c9c <usb_stor_CB_transport>:

	return result;
}

static int usb_stor_CB_transport(ccb *srb, struct us_data *us)
{
57e11c9c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	memset(&psrb->cmd[0], 0, 12);
	psrb->cmd[0] = SCSI_REQ_SENSE;
	psrb->cmd[1] = srb->lun << 5;
	psrb->cmd[4] = 18;
	psrb->datalen = 18;
	psrb->pdata = &srb->sense_buf[0];
57e11ca0:	e2803040 	add	r3, r0, #64	; 0x40

	return result;
}

static int usb_stor_CB_transport(ccb *srb, struct us_data *us)
{
57e11ca4:	e24dd0d0 	sub	sp, sp, #208	; 0xd0
	int retry, notready;

	psrb = &reqsrb;
	status = USB_STOR_TRANSPORT_GOOD;
	retry = 0;
	notready = 0;
57e11ca8:	e3a06000 	mov	r6, #0

	return result;
}

static int usb_stor_CB_transport(ccb *srb, struct us_data *us)
{
57e11cac:	e1a04000 	mov	r4, r0
57e11cb0:	e1a05001 	mov	r5, r1
	ccb reqsrb;
	int retry, notready;

	psrb = &reqsrb;
	status = USB_STOR_TRANSPORT_GOOD;
	retry = 0;
57e11cb4:	e1a07006 	mov	r7, r6
		/* do not issue an autorequest after request sense */
		USB_STOR_PRINTF("No auto request and good\n");
		return USB_STOR_TRANSPORT_GOOD;
	}
	/* issue an request_sense */
	memset(&psrb->cmd[0], 0, 12);
57e11cb8:	e28da010 	add	sl, sp, #16
	psrb->cmd[0] = SCSI_REQ_SENSE;
	psrb->cmd[1] = srb->lun << 5;
	psrb->cmd[4] = 18;
57e11cbc:	e3a09012 	mov	r9, #18
	psrb->datalen = 18;
	psrb->pdata = &srb->sense_buf[0];
57e11cc0:	e58d300c 	str	r3, [sp, #12]
57e11cc4:	ea000000 	b	57e11ccc <usb_stor_CB_transport+0x30>
			mdelay(100);
			goto do_retry;
		}
		break;
	default:
		if (retry++ > USB_TRANSPORT_UNKNOWN_RETRY) {
57e11cc8:	e2877001 	add	r7, r7, #1
	status = USB_STOR_TRANSPORT_GOOD;
	retry = 0;
	notready = 0;
	/* issue the command */
do_retry:
	result = usb_stor_CB_comdat(srb, us);
57e11ccc:	e1a00004 	mov	r0, r4
57e11cd0:	e1a01005 	mov	r1, r5
57e11cd4:	ebffff2f 	bl	57e11998 <usb_stor_CB_comdat>
	USB_STOR_PRINTF("command / Data returned %d, status %lX\n",
			result, us->pusb_dev->status);
	/* if this is an CBI Protocol, get IRQ */
	if (us->protocol == US_PR_CBI) {
57e11cd8:	e5d5300d 	ldrb	r3, [r5, #13]
	status = USB_STOR_TRANSPORT_GOOD;
	retry = 0;
	notready = 0;
	/* issue the command */
do_retry:
	result = usb_stor_CB_comdat(srb, us);
57e11cdc:	e1a0b000 	mov	fp, r0
	USB_STOR_PRINTF("command / Data returned %d, status %lX\n",
			result, us->pusb_dev->status);
	/* if this is an CBI Protocol, get IRQ */
	if (us->protocol == US_PR_CBI) {
57e11ce0:	e3530000 	cmp	r3, #0
57e11ce4:	1a00000e 	bne	57e11d24 <usb_stor_CB_transport+0x88>
		status = usb_stor_CBI_get_status(srb, us);
57e11ce8:	e1a00004 	mov	r0, r4
57e11cec:	e1a01005 	mov	r1, r5
57e11cf0:	ebffffb4 	bl	57e11bc8 <usb_stor_CBI_get_status.clone.2>
		/* if the status is error, report it */
		if (status == USB_STOR_TRANSPORT_ERROR) {
57e11cf4:	e3700002 	cmn	r0, #2
57e11cf8:	0a000061 	beq	57e11e84 <usb_stor_CB_transport+0x1e8>
			USB_STOR_PRINTF(" USB CBI Command Error\n");
			return status;
		}
		srb->sense_buf[12] = (unsigned char)(us->ip_data >> 8);
57e11cfc:	e1d531b0 	ldrh	r3, [r5, #16]
57e11d00:	e1a03423 	lsr	r3, r3, #8
57e11d04:	e5c4304c 	strb	r3, [r4, #76]	; 0x4c
		srb->sense_buf[13] = (unsigned char)(us->ip_data & 0xff);
57e11d08:	e1d531b0 	ldrh	r3, [r5, #16]
57e11d0c:	e5c4304d 	strb	r3, [r4, #77]	; 0x4d
		if (!us->ip_data) {
57e11d10:	e1d531b0 	ldrh	r3, [r5, #16]
57e11d14:	e3530000 	cmp	r3, #0
57e11d18:	1a000001 	bne	57e11d24 <usb_stor_CB_transport+0x88>
			/* if the status is good, report it */
			if (status == USB_STOR_TRANSPORT_GOOD) {
57e11d1c:	e3500000 	cmp	r0, #0
57e11d20:	0a000057 	beq	57e11e84 <usb_stor_CB_transport+0x1e8>
			}
		}
	}
	/* do we have to issue an auto request? */
	/* HERE we have to check the result */
	if ((result < 0) && !(us->pusb_dev->status & USB_ST_STALLED)) {
57e11d24:	e35b0000 	cmp	fp, #0
57e11d28:	aa000007 	bge	57e11d4c <usb_stor_CB_transport+0xb0>
57e11d2c:	e5953000 	ldr	r3, [r5]
57e11d30:	e5933614 	ldr	r3, [r3, #1556]	; 0x614
57e11d34:	e3130002 	tst	r3, #2
57e11d38:	1a000003 	bne	57e11d4c <usb_stor_CB_transport+0xb0>
		USB_STOR_PRINTF("ERROR %lX\n", us->pusb_dev->status);
		us->transport_reset(us);
57e11d3c:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
57e11d40:	e1a00005 	mov	r0, r5
57e11d44:	e12fff33 	blx	r3
57e11d48:	ea00004a 	b	57e11e78 <usb_stor_CB_transport+0x1dc>
		return USB_STOR_TRANSPORT_ERROR;
	}
	if ((us->protocol == US_PR_CBI) &&
57e11d4c:	e5d5000d 	ldrb	r0, [r5, #13]
57e11d50:	e3500000 	cmp	r0, #0
57e11d54:	1a000003 	bne	57e11d68 <usb_stor_CB_transport+0xcc>
	    ((srb->cmd[0] == SCSI_REQ_SENSE) ||
57e11d58:	e5d43000 	ldrb	r3, [r4]
	if ((result < 0) && !(us->pusb_dev->status & USB_ST_STALLED)) {
		USB_STOR_PRINTF("ERROR %lX\n", us->pusb_dev->status);
		us->transport_reset(us);
		return USB_STOR_TRANSPORT_ERROR;
	}
	if ((us->protocol == US_PR_CBI) &&
57e11d5c:	e3530003 	cmp	r3, #3
57e11d60:	13530012 	cmpne	r3, #18
57e11d64:	0a000046 	beq	57e11e84 <usb_stor_CB_transport+0x1e8>
		/* do not issue an autorequest after request sense */
		USB_STOR_PRINTF("No auto request and good\n");
		return USB_STOR_TRANSPORT_GOOD;
	}
	/* issue an request_sense */
	memset(&psrb->cmd[0], 0, 12);
57e11d68:	e3a01000 	mov	r1, #0
57e11d6c:	e3a0200c 	mov	r2, #12
57e11d70:	e1a0000a 	mov	r0, sl
57e11d74:	eb004940 	bl	57e2427c <memset>
	psrb->cmd[0] = SCSI_REQ_SENSE;
57e11d78:	e3a03003 	mov	r3, #3
57e11d7c:	e5cd3010 	strb	r3, [sp, #16]
	psrb->cmd[1] = srb->lun << 5;
57e11d80:	e5d43082 	ldrb	r3, [r4, #130]	; 0x82
	psrb->cmd[4] = 18;
	psrb->datalen = 18;
	psrb->pdata = &srb->sense_buf[0];
	psrb->cmdlen = 12;
	/* issue the command */
	result = usb_stor_CB_comdat(psrb, us);
57e11d84:	e1a0000a 	mov	r0, sl
		return USB_STOR_TRANSPORT_GOOD;
	}
	/* issue an request_sense */
	memset(&psrb->cmd[0], 0, 12);
	psrb->cmd[0] = SCSI_REQ_SENSE;
	psrb->cmd[1] = srb->lun << 5;
57e11d88:	e1a03283 	lsl	r3, r3, #5
57e11d8c:	e5cd3011 	strb	r3, [sp, #17]
	psrb->cmd[4] = 18;
	psrb->datalen = 18;
	psrb->pdata = &srb->sense_buf[0];
57e11d90:	e59d300c 	ldr	r3, [sp, #12]
	psrb->cmdlen = 12;
	/* issue the command */
	result = usb_stor_CB_comdat(psrb, us);
57e11d94:	e1a01005 	mov	r1, r5
	memset(&psrb->cmd[0], 0, 12);
	psrb->cmd[0] = SCSI_REQ_SENSE;
	psrb->cmd[1] = srb->lun << 5;
	psrb->cmd[4] = 18;
	psrb->datalen = 18;
	psrb->pdata = &srb->sense_buf[0];
57e11d98:	e58d3098 	str	r3, [sp, #152]	; 0x98
	psrb->cmdlen = 12;
57e11d9c:	e3a0300c 	mov	r3, #12
57e11da0:	e5cd3093 	strb	r3, [sp, #147]	; 0x93
	}
	/* issue an request_sense */
	memset(&psrb->cmd[0], 0, 12);
	psrb->cmd[0] = SCSI_REQ_SENSE;
	psrb->cmd[1] = srb->lun << 5;
	psrb->cmd[4] = 18;
57e11da4:	e5cd9014 	strb	r9, [sp, #20]
	psrb->datalen = 18;
57e11da8:	e58d9094 	str	r9, [sp, #148]	; 0x94
	psrb->pdata = &srb->sense_buf[0];
	psrb->cmdlen = 12;
	/* issue the command */
	result = usb_stor_CB_comdat(psrb, us);
57e11dac:	ebfffef9 	bl	57e11998 <usb_stor_CB_comdat>
	USB_STOR_PRINTF("auto request returned %d\n", result);
	/* if this is an CBI Protocol, get IRQ */
	if (us->protocol == US_PR_CBI)
57e11db0:	e5d5300d 	ldrb	r3, [r5, #13]
	psrb->cmd[4] = 18;
	psrb->datalen = 18;
	psrb->pdata = &srb->sense_buf[0];
	psrb->cmdlen = 12;
	/* issue the command */
	result = usb_stor_CB_comdat(psrb, us);
57e11db4:	e1a0b000 	mov	fp, r0
	USB_STOR_PRINTF("auto request returned %d\n", result);
	/* if this is an CBI Protocol, get IRQ */
	if (us->protocol == US_PR_CBI)
57e11db8:	e3530000 	cmp	r3, #0
57e11dbc:	1a000002 	bne	57e11dcc <usb_stor_CB_transport+0x130>
		status = usb_stor_CBI_get_status(psrb, us);
57e11dc0:	e1a0000a 	mov	r0, sl
57e11dc4:	e1a01005 	mov	r1, r5
57e11dc8:	ebffff7e 	bl	57e11bc8 <usb_stor_CBI_get_status.clone.2>

	if ((result < 0) && !(us->pusb_dev->status & USB_ST_STALLED)) {
57e11dcc:	e35b0000 	cmp	fp, #0
57e11dd0:	aa000003 	bge	57e11de4 <usb_stor_CB_transport+0x148>
57e11dd4:	e5953000 	ldr	r3, [r5]
57e11dd8:	e5933614 	ldr	r3, [r3, #1556]	; 0x614
57e11ddc:	e3130002 	tst	r3, #2
57e11de0:	0a000024 	beq	57e11e78 <usb_stor_CB_transport+0x1dc>
	}
	USB_STOR_PRINTF("autorequest returned 0x%02X 0x%02X 0x%02X 0x%02X\n",
			srb->sense_buf[0], srb->sense_buf[2],
			srb->sense_buf[12], srb->sense_buf[13]);
	/* Check the auto request result */
	if ((srb->sense_buf[2] == 0) &&
57e11de4:	e5d43042 	ldrb	r3, [r4, #66]	; 0x42
57e11de8:	e3530000 	cmp	r3, #0
57e11dec:	1a000003 	bne	57e11e00 <usb_stor_CB_transport+0x164>
	    (srb->sense_buf[12] == 0) &&
57e11df0:	e1d404bc 	ldrh	r0, [r4, #76]	; 0x4c
57e11df4:	e3500000 	cmp	r0, #0
57e11df8:	1a000012 	bne	57e11e48 <usb_stor_CB_transport+0x1ac>
57e11dfc:	ea000020 	b	57e11e84 <usb_stor_CB_transport+0x1e8>
		/* ok, no sense */
		return USB_STOR_TRANSPORT_GOOD;
	}

	/* Check the auto request result */
	switch (srb->sense_buf[2]) {
57e11e00:	e3530001 	cmp	r3, #1
57e11e04:	0a00001d 	beq	57e11e80 <usb_stor_CB_transport+0x1e4>
57e11e08:	e3530002 	cmp	r3, #2
57e11e0c:	1a00000d 	bne	57e11e48 <usb_stor_CB_transport+0x1ac>
		/* Recovered Error */
		return USB_STOR_TRANSPORT_GOOD;
		break;
	case 0x02:
		/* Not Ready */
		if (notready++ > USB_TRANSPORT_NOT_READY_RETRY) {
57e11e10:	e356000a 	cmp	r6, #10
57e11e14:	da000007 	ble	57e11e38 <usb_stor_CB_transport+0x19c>
			printf("cmd 0x%02X returned 0x%02X 0x%02X 0x%02X"
57e11e18:	e5d4004c 	ldrb	r0, [r4, #76]	; 0x4c
57e11e1c:	e5d41000 	ldrb	r1, [r4]
57e11e20:	e58d0000 	str	r0, [sp]
57e11e24:	e5d4004d 	ldrb	r0, [r4, #77]	; 0x4d
57e11e28:	e5d42040 	ldrb	r2, [r4, #64]	; 0x40
57e11e2c:	e58d0004 	str	r0, [sp, #4]
57e11e30:	e59f0054 	ldr	r0, [pc, #84]	; 57e11e8c <usb_stor_CB_transport+0x1f0>
57e11e34:	ea00000c 	b	57e11e6c <usb_stor_CB_transport+0x1d0>
			       " 0x%02X (NOT READY)\n", srb->cmd[0],
				srb->sense_buf[0], srb->sense_buf[2],
				srb->sense_buf[12], srb->sense_buf[13]);
			return USB_STOR_TRANSPORT_FAILED;
		} else {
			mdelay(100);
57e11e38:	e3a00064 	mov	r0, #100	; 0x64
		/* Recovered Error */
		return USB_STOR_TRANSPORT_GOOD;
		break;
	case 0x02:
		/* Not Ready */
		if (notready++ > USB_TRANSPORT_NOT_READY_RETRY) {
57e11e3c:	e2866001 	add	r6, r6, #1
			       " 0x%02X (NOT READY)\n", srb->cmd[0],
				srb->sense_buf[0], srb->sense_buf[2],
				srb->sense_buf[12], srb->sense_buf[13]);
			return USB_STOR_TRANSPORT_FAILED;
		} else {
			mdelay(100);
57e11e40:	eb0049c8 	bl	57e24568 <mdelay>
57e11e44:	eaffffa0 	b	57e11ccc <usb_stor_CB_transport+0x30>
			goto do_retry;
		}
		break;
	default:
		if (retry++ > USB_TRANSPORT_UNKNOWN_RETRY) {
57e11e48:	e3570005 	cmp	r7, #5
57e11e4c:	daffff9d 	ble	57e11cc8 <usb_stor_CB_transport+0x2c>
			printf("cmd 0x%02X returned 0x%02X 0x%02X 0x%02X"
57e11e50:	e5d4004c 	ldrb	r0, [r4, #76]	; 0x4c
57e11e54:	e5d41000 	ldrb	r1, [r4]
57e11e58:	e58d0000 	str	r0, [sp]
57e11e5c:	e5d4004d 	ldrb	r0, [r4, #77]	; 0x4d
57e11e60:	e5d42040 	ldrb	r2, [r4, #64]	; 0x40
57e11e64:	e58d0004 	str	r0, [sp, #4]
57e11e68:	e59f0020 	ldr	r0, [pc, #32]	; 57e11e90 <usb_stor_CB_transport+0x1f4>
57e11e6c:	ebffdd76 	bl	57e0944c <printf>
			       " 0x%02X\n", srb->cmd[0], srb->sense_buf[0],
				srb->sense_buf[2], srb->sense_buf[12],
				srb->sense_buf[13]);
			return USB_STOR_TRANSPORT_FAILED;
57e11e70:	e3e00000 	mvn	r0, #0
57e11e74:	ea000002 	b	57e11e84 <usb_stor_CB_transport+0x1e8>
		status = usb_stor_CBI_get_status(psrb, us);

	if ((result < 0) && !(us->pusb_dev->status & USB_ST_STALLED)) {
		USB_STOR_PRINTF(" AUTO REQUEST ERROR %ld\n",
				us->pusb_dev->status);
		return USB_STOR_TRANSPORT_ERROR;
57e11e78:	e3e00001 	mvn	r0, #1
57e11e7c:	ea000000 	b	57e11e84 <usb_stor_CB_transport+0x1e8>

	/* Check the auto request result */
	switch (srb->sense_buf[2]) {
	case 0x01:
		/* Recovered Error */
		return USB_STOR_TRANSPORT_GOOD;
57e11e80:	e3a00000 	mov	r0, #0
		} else
			goto do_retry;
		break;
	}
	return USB_STOR_TRANSPORT_FAILED;
}
57e11e84:	e28dd0d0 	add	sp, sp, #208	; 0xd0
57e11e88:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e11e8c:	57e32e17 	.word	0x57e32e17
57e11e90:	57e32e54 	.word	0x57e32e54

57e11e94 <usb_stor_get_dev>:
void uhci_show_temp_int_td(void);

#ifdef CONFIG_PARTITIONS
block_dev_desc_t *usb_stor_get_dev(int index)
{
	return (index < usb_max_devs) ? &usb_dev_desc[index] : NULL;
57e11e94:	e59f3014 	ldr	r3, [pc, #20]	; 57e11eb0 <usb_stor_get_dev+0x1c>
57e11e98:	e5932304 	ldr	r2, [r3, #772]	; 0x304
57e11e9c:	e1500002 	cmp	r0, r2
57e11ea0:	b3a02070 	movlt	r2, #112	; 0x70
57e11ea4:	b0203092 	mlalt	r0, r2, r0, r3
57e11ea8:	a3a00000 	movge	r0, #0
}
57e11eac:	e12fff1e 	bx	lr
57e11eb0:	57e46e00 	.word	0x57e46e00

57e11eb4 <usb_stor_info>:
/*******************************************************************************
 * show info on storage devices; 'usb start/init' must be invoked earlier
 * as we only retrieve structures populated during devices initialization
 */
int usb_stor_info(void)
{
57e11eb4:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	if (usb_max_devs > 0) {
57e11eb8:	e59f5050 	ldr	r5, [pc, #80]	; 57e11f10 <usb_stor_info+0x5c>
57e11ebc:	e5953304 	ldr	r3, [r5, #772]	; 0x304
57e11ec0:	e3530000 	cmp	r3, #0
57e11ec4:	c3a04000 	movgt	r4, #0
		for (i = 0; i < usb_max_devs; i++) {
			printf("  Device %d: ", i);
			dev_print(&usb_dev_desc[i]);
57e11ec8:	c3a06070 	movgt	r6, #112	; 0x70
 */
int usb_stor_info(void)
{
	int i;

	if (usb_max_devs > 0) {
57e11ecc:	ca000006 	bgt	57e11eec <usb_stor_info+0x38>
57e11ed0:	ea00000a 	b	57e11f00 <usb_stor_info+0x4c>
		for (i = 0; i < usb_max_devs; i++) {
			printf("  Device %d: ", i);
57e11ed4:	e1a01004 	mov	r1, r4
57e11ed8:	e59f0034 	ldr	r0, [pc, #52]	; 57e11f14 <usb_stor_info+0x60>
57e11edc:	ebffdd5a 	bl	57e0944c <printf>
			dev_print(&usb_dev_desc[i]);
57e11ee0:	e0205496 	mla	r0, r6, r4, r5
57e11ee4:	eb000415 	bl	57e12f40 <dev_print>
int usb_stor_info(void)
{
	int i;

	if (usb_max_devs > 0) {
		for (i = 0; i < usb_max_devs; i++) {
57e11ee8:	e2844001 	add	r4, r4, #1
57e11eec:	e5953304 	ldr	r3, [r5, #772]	; 0x304
57e11ef0:	e1540003 	cmp	r4, r3
57e11ef4:	bafffff6 	blt	57e11ed4 <usb_stor_info+0x20>
			printf("  Device %d: ", i);
			dev_print(&usb_dev_desc[i]);
		}
		return 0;
57e11ef8:	e3a00000 	mov	r0, #0
57e11efc:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	printf("No storage devices, perhaps not 'usb start'ed..?\n");
57e11f00:	e59f0010 	ldr	r0, [pc, #16]	; 57e11f18 <usb_stor_info+0x64>
57e11f04:	ebffdd50 	bl	57e0944c <printf>
	return 1;
57e11f08:	e3a00001 	mov	r0, #1
}
57e11f0c:	e8bd8070 	pop	{r4, r5, r6, pc}
57e11f10:	57e46e00 	.word	0x57e46e00
57e11f14:	57e3529b 	.word	0x57e3529b
57e11f18:	57e32e85 	.word	0x57e32e85

57e11f1c <usb_storage_probe>:
}

/* Probe to see if a new device is actually a Storage device */
int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
		      struct us_data *ss)
{
57e11f1c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
		protocol = US_PR_CB;
		subclass = US_SC_UFI;	    /* an assumption */
	}
#endif

	if (dev->descriptor.bDeviceClass != 0 ||
57e11f20:	e5d06104 	ldrb	r6, [r0, #260]	; 0x104
}

/* Probe to see if a new device is actually a Storage device */
int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
		      struct us_data *ss)
{
57e11f24:	e1a05000 	mov	r5, r0
		protocol = US_PR_CB;
		subclass = US_SC_UFI;	    /* an assumption */
	}
#endif

	if (dev->descriptor.bDeviceClass != 0 ||
57e11f28:	e3560000 	cmp	r6, #0
}

/* Probe to see if a new device is actually a Storage device */
int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
		      struct us_data *ss)
{
57e11f2c:	e1a0a001 	mov	sl, r1
57e11f30:	e1a04002 	mov	r4, r2
		protocol = US_PR_CB;
		subclass = US_SC_UFI;	    /* an assumption */
	}
#endif

	if (dev->descriptor.bDeviceClass != 0 ||
57e11f34:	1a000078 	bne	57e1211c <usb_storage_probe+0x200>
			iface->desc.bInterfaceClass != USB_CLASS_MASS_STORAGE ||
57e11f38:	e3a0709c 	mov	r7, #156	; 0x9c
57e11f3c:	e0270791 	mla	r7, r1, r7, r0
		protocol = US_PR_CB;
		subclass = US_SC_UFI;	    /* an assumption */
	}
#endif

	if (dev->descriptor.bDeviceClass != 0 ||
57e11f40:	e5d73121 	ldrb	r3, [r7, #289]	; 0x121
57e11f44:	e3530008 	cmp	r3, #8
57e11f48:	1a000074 	bne	57e12120 <usb_storage_probe+0x204>
			iface->desc.bInterfaceClass != USB_CLASS_MASS_STORAGE ||
			iface->desc.bInterfaceSubClass < US_SC_MIN ||
57e11f4c:	e5d73122 	ldrb	r3, [r7, #290]	; 0x122
		subclass = US_SC_UFI;	    /* an assumption */
	}
#endif

	if (dev->descriptor.bDeviceClass != 0 ||
			iface->desc.bInterfaceClass != USB_CLASS_MASS_STORAGE ||
57e11f50:	e3530000 	cmp	r3, #0
			iface->desc.bInterfaceSubClass < US_SC_MIN ||
			iface->desc.bInterfaceSubClass > US_SC_MAX) {
		/* if it's not a mass storage, we go no further */
		return 0;
57e11f54:	01a06003 	moveq	r6, r3
		subclass = US_SC_UFI;	    /* an assumption */
	}
#endif

	if (dev->descriptor.bDeviceClass != 0 ||
			iface->desc.bInterfaceClass != USB_CLASS_MASS_STORAGE ||
57e11f58:	0a000070 	beq	57e12120 <usb_storage_probe+0x204>
			iface->desc.bInterfaceSubClass < US_SC_MIN ||
57e11f5c:	e3530006 	cmp	r3, #6
57e11f60:	8a00006e 	bhi	57e12120 <usb_storage_probe+0x204>
			iface->desc.bInterfaceSubClass > US_SC_MAX) {
		/* if it's not a mass storage, we go no further */
		return 0;
	}

	memset(ss, 0, sizeof(struct us_data));
57e11f64:	e1a00002 	mov	r0, r2
57e11f68:	e1a01006 	mov	r1, r6
57e11f6c:	e3a02034 	mov	r2, #52	; 0x34
57e11f70:	eb0048c1 	bl	57e2427c <memset>

	/* At this point, we know we've got a live one */
	USB_STOR_PRINTF("\n\nUSB Mass Storage device detected\n");

	/* Initialize the us_data structure with some useful info */
	ss->flags = flags;
57e11f74:	e5846004 	str	r6, [r4, #4]
	ss->ifnum = ifnum;
57e11f78:	e5c4a008 	strb	sl, [r4, #8]
	ss->pusb_dev = dev;
57e11f7c:	e5845000 	str	r5, [r4]
	ss->attention_done = 0;
57e11f80:	e5c4600e 	strb	r6, [r4, #14]
	 */
	if (subclass) {
		ss->subclass = subclass;
		ss->protocol = protocol;
	} else {
		ss->subclass = iface->desc.bInterfaceSubClass;
57e11f84:	e5d73122 	ldrb	r3, [r7, #290]	; 0x122
57e11f88:	e5c4300c 	strb	r3, [r4, #12]
		ss->protocol = iface->desc.bInterfaceProtocol;
57e11f8c:	e5d73123 	ldrb	r3, [r7, #291]	; 0x123
	}

	/* set the handler pointers based on the protocol */
	USB_STOR_PRINTF("Transport: ");
	switch (ss->protocol) {
57e11f90:	e3530001 	cmp	r3, #1
	if (subclass) {
		ss->subclass = subclass;
		ss->protocol = protocol;
	} else {
		ss->subclass = iface->desc.bInterfaceSubClass;
		ss->protocol = iface->desc.bInterfaceProtocol;
57e11f94:	e5c4300d 	strb	r3, [r4, #13]
	}

	/* set the handler pointers based on the protocol */
	USB_STOR_PRINTF("Transport: ");
	switch (ss->protocol) {
57e11f98:	0a000003 	beq	57e11fac <usb_storage_probe+0x90>
57e11f9c:	3a000002 	bcc	57e11fac <usb_storage_probe+0x90>
57e11fa0:	e3530050 	cmp	r3, #80	; 0x50
57e11fa4:	1a00000f 	bne	57e11fe8 <usb_storage_probe+0xcc>
57e11fa8:	ea00000a 	b	57e11fd8 <usb_storage_probe+0xbc>
	case US_PR_CB:
		USB_STOR_PRINTF("Control/Bulk\n");
		ss->transport = usb_stor_CB_transport;
57e11fac:	e59f3174 	ldr	r3, [pc, #372]	; 57e12128 <usb_storage_probe+0x20c>
57e11fb0:	e5843030 	str	r3, [r4, #48]	; 0x30
		ss->transport_reset = usb_stor_CB_reset;
57e11fb4:	e59f3170 	ldr	r3, [pc, #368]	; 57e1212c <usb_storage_probe+0x210>
57e11fb8:	e584302c 	str	r3, [r4, #44]	; 0x2c
	return blkcnt;

}

/* Probe to see if a new device is actually a Storage device */
int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
57e11fbc:	e3a0309c 	mov	r3, #156	; 0x9c
57e11fc0:	e00a0a93 	mul	sl, r3, sl
57e11fc4:	e085200a 	add	r2, r5, sl
57e11fc8:	e2822f47 	add	r2, r2, #284	; 0x11c
57e11fcc:	e3a01000 	mov	r1, #0
	/*
	 * We are expecting a minimum of 2 endpoints - in and out (bulk).
	 * An optional interrupt is OK (necessary for CBI protocol).
	 * We will ignore any others.
	 */
	for (i = 0; i < iface->desc.bNumEndpoints; i++) {
57e11fd0:	e085a00a 	add	sl, r5, sl
57e11fd4:	ea00001a 	b	57e12044 <usb_storage_probe+0x128>
		ss->transport = usb_stor_CB_transport;
		ss->transport_reset = usb_stor_CB_reset;
		break;
	case US_PR_BULK:
		USB_STOR_PRINTF("Bulk/Bulk/Bulk\n");
		ss->transport = usb_stor_BBB_transport;
57e11fd8:	e59f3150 	ldr	r3, [pc, #336]	; 57e12130 <usb_storage_probe+0x214>
57e11fdc:	e5843030 	str	r3, [r4, #48]	; 0x30
		ss->transport_reset = usb_stor_BBB_reset;
57e11fe0:	e59f314c 	ldr	r3, [pc, #332]	; 57e12134 <usb_storage_probe+0x218>
57e11fe4:	eafffff3 	b	57e11fb8 <usb_storage_probe+0x9c>
		break;
	default:
		printf("USB Storage Transport unknown / not yet implemented\n");
57e11fe8:	e59f0148 	ldr	r0, [pc, #328]	; 57e12138 <usb_storage_probe+0x21c>
57e11fec:	ebffdd16 	bl	57e0944c <printf>
		return 0;
57e11ff0:	ea00004a 	b	57e12120 <usb_storage_probe+0x204>
	 * An optional interrupt is OK (necessary for CBI protocol).
	 * We will ignore any others.
	 */
	for (i = 0; i < iface->desc.bNumEndpoints; i++) {
		/* is it an BULK endpoint? */
		if ((iface->ep_desc[i].bmAttributes &
57e11ff4:	e5d2300f 	ldrb	r3, [r2, #15]
57e11ff8:	e2033003 	and	r3, r3, #3
57e11ffc:	e3530002 	cmp	r3, #2
57e12000:	1a000005 	bne	57e1201c <usb_storage_probe+0x100>
		     USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK) {
			if (iface->ep_desc[i].bEndpointAddress & USB_DIR_IN)
57e12004:	e5d2300e 	ldrb	r3, [r2, #14]
57e12008:	e1d200de 	ldrsb	r0, [r2, #14]
57e1200c:	e203300f 	and	r3, r3, #15
57e12010:	e3500000 	cmp	r0, #0
				ss->ep_in = iface->ep_desc[i].bEndpointAddress &
57e12014:	b5c43009 	strblt	r3, [r4, #9]
					USB_ENDPOINT_NUMBER_MASK;
			else
				ss->ep_out =
57e12018:	a5c4300a 	strbge	r3, [r4, #10]
					iface->ep_desc[i].bEndpointAddress &
					USB_ENDPOINT_NUMBER_MASK;
		}

		/* is it an interrupt endpoint? */
		if ((iface->ep_desc[i].bmAttributes &
57e1201c:	e5d2300f 	ldrb	r3, [r2, #15]
	/*
	 * We are expecting a minimum of 2 endpoints - in and out (bulk).
	 * An optional interrupt is OK (necessary for CBI protocol).
	 * We will ignore any others.
	 */
	for (i = 0; i < iface->desc.bNumEndpoints; i++) {
57e12020:	e2811001 	add	r1, r1, #1
					iface->ep_desc[i].bEndpointAddress &
					USB_ENDPOINT_NUMBER_MASK;
		}

		/* is it an interrupt endpoint? */
		if ((iface->ep_desc[i].bmAttributes &
57e12024:	e2033003 	and	r3, r3, #3
57e12028:	e3530003 	cmp	r3, #3
		    USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT) {
			ss->ep_int = iface->ep_desc[i].bEndpointAddress &
57e1202c:	05d2300e 	ldrbeq	r3, [r2, #14]
57e12030:	0203300f 	andeq	r3, r3, #15
57e12034:	05c4300b 	strbeq	r3, [r4, #11]
				USB_ENDPOINT_NUMBER_MASK;
			ss->irqinterval = iface->ep_desc[i].bInterval;
57e12038:	05d23012 	ldrbeq	r3, [r2, #18]
	/*
	 * We are expecting a minimum of 2 endpoints - in and out (bulk).
	 * An optional interrupt is OK (necessary for CBI protocol).
	 * We will ignore any others.
	 */
	for (i = 0; i < iface->desc.bNumEndpoints; i++) {
57e1203c:	e2822009 	add	r2, r2, #9
		/* is it an interrupt endpoint? */
		if ((iface->ep_desc[i].bmAttributes &
		    USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT) {
			ss->ep_int = iface->ep_desc[i].bEndpointAddress &
				USB_ENDPOINT_NUMBER_MASK;
			ss->irqinterval = iface->ep_desc[i].bInterval;
57e12040:	05c43025 	strbeq	r3, [r4, #37]	; 0x25
	/*
	 * We are expecting a minimum of 2 endpoints - in and out (bulk).
	 * An optional interrupt is OK (necessary for CBI protocol).
	 * We will ignore any others.
	 */
	for (i = 0; i < iface->desc.bNumEndpoints; i++) {
57e12044:	e28a3f46 	add	r3, sl, #280	; 0x118
57e12048:	e5d30008 	ldrb	r0, [r3, #8]
57e1204c:	e1510000 	cmp	r1, r0
57e12050:	baffffe7 	blt	57e11ff4 <usb_storage_probe+0xd8>
	}
	USB_STOR_PRINTF("Endpoints In %d Out %d Int %d\n",
		  ss->ep_in, ss->ep_out, ss->ep_int);

	/* Do some basic sanity checks, and bail if we find a problem */
	if (usb_set_interface(dev, iface->desc.bInterfaceNumber, 0) ||
57e12054:	e1a00005 	mov	r0, r5
57e12058:	e5d31006 	ldrb	r1, [r3, #6]
57e1205c:	e3a02000 	mov	r2, #0
57e12060:	ebfff7df 	bl	57e0ffe4 <usb_set_interface>
57e12064:	e3500000 	cmp	r0, #0
57e12068:	1a00002b 	bne	57e1211c <usb_storage_probe+0x200>
57e1206c:	e5d46009 	ldrb	r6, [r4, #9]
57e12070:	e3560000 	cmp	r6, #0
57e12074:	0a000029 	beq	57e12120 <usb_storage_probe+0x204>
	    !ss->ep_in || !ss->ep_out ||
57e12078:	e5d4600a 	ldrb	r6, [r4, #10]
57e1207c:	e3560000 	cmp	r6, #0
57e12080:	0a000026 	beq	57e12120 <usb_storage_probe+0x204>
57e12084:	e5d4300d 	ldrb	r3, [r4, #13]
57e12088:	e3530000 	cmp	r3, #0
57e1208c:	1a000002 	bne	57e1209c <usb_storage_probe+0x180>
	    (ss->protocol == US_PR_CBI && ss->ep_int == 0)) {
57e12090:	e5d4600b 	ldrb	r6, [r4, #11]
57e12094:	e3560000 	cmp	r6, #0
57e12098:	0a000020 	beq	57e12120 <usb_storage_probe+0x204>
	/* set class specific stuff */
	/* We only handle certain protocols.  Currently, these are
	 * the only ones.
	 * The SFF8070 accepts the requests used in u-boot
	 */
	if (ss->subclass != US_SC_UFI && ss->subclass != US_SC_SCSI &&
57e1209c:	e5d4100c 	ldrb	r1, [r4, #12]
57e120a0:	e3510006 	cmp	r1, #6
57e120a4:	13510004 	cmpne	r1, #4
57e120a8:	0a000004 	beq	57e120c0 <usb_storage_probe+0x1a4>
57e120ac:	e3510005 	cmp	r1, #5
57e120b0:	0a000002 	beq	57e120c0 <usb_storage_probe+0x1a4>
	    ss->subclass != US_SC_8070) {
		printf("Sorry, protocol %d not yet supported.\n", ss->subclass);
57e120b4:	e59f0080 	ldr	r0, [pc, #128]	; 57e1213c <usb_storage_probe+0x220>
57e120b8:	ebffdce3 	bl	57e0944c <printf>
57e120bc:	ea000016 	b	57e1211c <usb_storage_probe+0x200>
		return 0;
	}
	if (ss->ep_int) {
57e120c0:	e5d4300b 	ldrb	r3, [r4, #11]
57e120c4:	e3530000 	cmp	r3, #0
57e120c8:	0a000010 	beq	57e12110 <usb_storage_probe+0x1f4>
		/* we had found an interrupt endpoint, prepare irq pipe
		 * set up the IRQ pipe and handler
		 */
		ss->irqinterval = (ss->irqinterval > 0) ? ss->irqinterval : 255;
57e120cc:	e5d42025 	ldrb	r2, [r4, #37]	; 0x25
		ss->irqpipe = usb_rcvintpipe(ss->pusb_dev, ss->ep_int);
		ss->irqmaxp = usb_maxpacket(dev, ss->irqpipe);
57e120d0:	e1a00005 	mov	r0, r5
	}
	if (ss->ep_int) {
		/* we had found an interrupt endpoint, prepare irq pipe
		 * set up the IRQ pipe and handler
		 */
		ss->irqinterval = (ss->irqinterval > 0) ? ss->irqinterval : 255;
57e120d4:	e3520000 	cmp	r2, #0
57e120d8:	03a020ff 	moveq	r2, #255	; 0xff
57e120dc:	e5c42025 	strb	r2, [r4, #37]	; 0x25
		ss->irqpipe = usb_rcvintpipe(ss->pusb_dev, ss->ep_int);
57e120e0:	e5942000 	ldr	r2, [r4]
57e120e4:	e5921068 	ldr	r1, [r2, #104]	; 0x68
57e120e8:	e5922000 	ldr	r2, [r2]
57e120ec:	e3811101 	orr	r1, r1, #1073741824	; 0x40000000
57e120f0:	e3811080 	orr	r1, r1, #128	; 0x80
57e120f4:	e1811402 	orr	r1, r1, r2, lsl #8
57e120f8:	e1811783 	orr	r1, r1, r3, lsl #15
57e120fc:	e5841020 	str	r1, [r4, #32]
		ss->irqmaxp = usb_maxpacket(dev, ss->irqpipe);
57e12100:	ebfff75c 	bl	57e0fe78 <usb_maxpacket>
		dev->irq_handle = usb_stor_irq;
57e12104:	e59f3034 	ldr	r3, [pc, #52]	; 57e12140 <usb_storage_probe+0x224>
		/* we had found an interrupt endpoint, prepare irq pipe
		 * set up the IRQ pipe and handler
		 */
		ss->irqinterval = (ss->irqinterval > 0) ? ss->irqinterval : 255;
		ss->irqpipe = usb_rcvintpipe(ss->pusb_dev, ss->ep_int);
		ss->irqmaxp = usb_maxpacket(dev, ss->irqpipe);
57e12108:	e5c40024 	strb	r0, [r4, #36]	; 0x24
		dev->irq_handle = usb_stor_irq;
57e1210c:	e5853604 	str	r3, [r5, #1540]	; 0x604
	}
	dev->privptr = (void *)ss;
57e12110:	e5854610 	str	r4, [r5, #1552]	; 0x610
	return 1;
57e12114:	e3a06001 	mov	r6, #1
57e12118:	ea000000 	b	57e12120 <usb_storage_probe+0x204>
	/* Do some basic sanity checks, and bail if we find a problem */
	if (usb_set_interface(dev, iface->desc.bInterfaceNumber, 0) ||
	    !ss->ep_in || !ss->ep_out ||
	    (ss->protocol == US_PR_CBI && ss->ep_int == 0)) {
		USB_STOR_PRINTF("Problems with device\n");
		return 0;
57e1211c:	e3a06000 	mov	r6, #0
		ss->irqmaxp = usb_maxpacket(dev, ss->irqpipe);
		dev->irq_handle = usb_stor_irq;
	}
	dev->privptr = (void *)ss;
	return 1;
}
57e12120:	e1a00006 	mov	r0, r6
57e12124:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e12128:	57e11c9c 	.word	0x57e11c9c
57e1212c:	57e111d4 	.word	0x57e111d4
57e12130:	57e1173c 	.word	0x57e1173c
57e12134:	57e11104 	.word	0x57e11104
57e12138:	57e32eb7 	.word	0x57e32eb7
57e1213c:	57e32eec 	.word	0x57e32eec
57e12140:	57e110e8 	.word	0x57e110e8

57e12144 <usb_stor_get_info>:

int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
		      block_dev_desc_t *dev_desc)
{
57e12144:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e12148:	e24ddf42 	sub	sp, sp, #264	; 0x108
	unsigned long *capacity, *blksz;
	ccb *pccb = &usb_ccb;

	pccb->pdata = usb_stor_buf;

	dev_desc->target = dev->devnum;
57e1214c:	e5903000 	ldr	r3, [r0]
	ALLOC_CACHE_ALIGN_BUFFER(unsigned long, cap, 2);
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, usb_stor_buf, 36);
	unsigned long *capacity, *blksz;
	ccb *pccb = &usb_ccb;

	pccb->pdata = usb_stor_buf;
57e12150:	e59f7324 	ldr	r7, [pc, #804]	; 57e1247c <usb_stor_get_info+0x338>
int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
		      block_dev_desc_t *dev_desc)
{
	unsigned char perq, modi;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned long, cap, 2);
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, usb_stor_buf, 36);
57e12154:	e28d6047 	add	r6, sp, #71	; 0x47
57e12158:	e3c6603f 	bic	r6, r6, #63	; 0x3f
	unsigned long *capacity, *blksz;
	ccb *pccb = &usb_ccb;

	pccb->pdata = usb_stor_buf;
57e1215c:	e58762c8 	str	r6, [r7, #712]	; 0x2c8

	dev_desc->target = dev->devnum;
57e12160:	e5c23009 	strb	r3, [r2, #9]
	pccb->lun = dev_desc->lun;
57e12164:	e5d2300a 	ldrb	r3, [r2, #10]
	return 1;
}

int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
		      block_dev_desc_t *dev_desc)
{
57e12168:	e1a05001 	mov	r5, r1
57e1216c:	e1a04002 	mov	r4, r2
	ccb *pccb = &usb_ccb;

	pccb->pdata = usb_stor_buf;

	dev_desc->target = dev->devnum;
	pccb->lun = dev_desc->lun;
57e12170:	e5c732c2 	strb	r3, [r7, #706]	; 0x2c2


static int usb_inquiry(ccb *srb, struct us_data *ss)
{
	int retry, i;
	retry = 5;
57e12174:	e3a0a005 	mov	sl, #5
	do {
		memset(&srb->cmd[0], 0, 12);
57e12178:	e3a0b00c 	mov	fp, #12
		srb->cmd[0] = SCSI_INQUIRY;
		srb->cmd[1] = srb->lun << 5;
		srb->cmd[4] = 36;
57e1217c:	e3a09024 	mov	r9, #36	; 0x24
static int usb_inquiry(ccb *srb, struct us_data *ss)
{
	int retry, i;
	retry = 5;
	do {
		memset(&srb->cmd[0], 0, 12);
57e12180:	e3a01000 	mov	r1, #0
57e12184:	e3a0200c 	mov	r2, #12
57e12188:	e59f02f0 	ldr	r0, [pc, #752]	; 57e12480 <usb_stor_get_info+0x33c>
57e1218c:	eb00483a 	bl	57e2427c <memset>
		srb->cmd[0] = SCSI_INQUIRY;
		srb->cmd[1] = srb->lun << 5;
57e12190:	e5d732c2 	ldrb	r3, [r7, #706]	; 0x2c2
{
	int retry, i;
	retry = 5;
	do {
		memset(&srb->cmd[0], 0, 12);
		srb->cmd[0] = SCSI_INQUIRY;
57e12194:	e3a01012 	mov	r1, #18
		srb->cmd[1] = srb->lun << 5;
57e12198:	e1a03283 	lsl	r3, r3, #5
{
	int retry, i;
	retry = 5;
	do {
		memset(&srb->cmd[0], 0, 12);
		srb->cmd[0] = SCSI_INQUIRY;
57e1219c:	e5c71240 	strb	r1, [r7, #576]	; 0x240
		srb->cmd[1] = srb->lun << 5;
57e121a0:	e5c73241 	strb	r3, [r7, #577]	; 0x241
		srb->cmd[4] = 36;
57e121a4:	e5c79244 	strb	r9, [r7, #580]	; 0x244
		srb->datalen = 36;
		srb->cmdlen = 12;
57e121a8:	e5c7b2c3 	strb	fp, [r7, #707]	; 0x2c3
	do {
		memset(&srb->cmd[0], 0, 12);
		srb->cmd[0] = SCSI_INQUIRY;
		srb->cmd[1] = srb->lun << 5;
		srb->cmd[4] = 36;
		srb->datalen = 36;
57e121ac:	e58792c4 	str	r9, [r7, #708]	; 0x2c4
		srb->cmdlen = 12;
		i = ss->transport(srb, ss);
57e121b0:	e5953030 	ldr	r3, [r5, #48]	; 0x30
57e121b4:	e59f02c4 	ldr	r0, [pc, #708]	; 57e12480 <usb_stor_get_info+0x33c>
57e121b8:	e1a01005 	mov	r1, r5
57e121bc:	e12fff33 	blx	r3
		USB_STOR_PRINTF("inquiry returns %d\n", i);
		if (i == 0)
57e121c0:	e3500000 	cmp	r0, #0
57e121c4:	0a000002 	beq	57e121d4 <usb_stor_get_info+0x90>
			break;
	} while (--retry);
57e121c8:	e25aa001 	subs	sl, sl, #1
57e121cc:	1affffeb 	bne	57e12180 <usb_stor_get_info+0x3c>
57e121d0:	ea000001 	b	57e121dc <usb_stor_get_info+0x98>

	if (!retry) {
57e121d4:	e35a0000 	cmp	sl, #0
57e121d8:	1a000003 	bne	57e121ec <usb_stor_get_info+0xa8>
		printf("error in inquiry\n");
57e121dc:	e59f02a0 	ldr	r0, [pc, #672]	; 57e12484 <usb_stor_get_info+0x340>
57e121e0:	ebffdc99 	bl	57e0944c <printf>
	dev_desc->target = dev->devnum;
	pccb->lun = dev_desc->lun;
	USB_STOR_PRINTF(" address %d\n", dev_desc->target);

	if (usb_inquiry(pccb, ss))
		return -1;
57e121e4:	e3e00000 	mvn	r0, #0
57e121e8:	ea00008f 	b	57e1242c <usb_stor_get_info+0x2e8>

	perq = usb_stor_buf[0];
57e121ec:	e5d61000 	ldrb	r1, [r6]
	modi = usb_stor_buf[1];

	if ((perq & 0x1f) == 0x1f) {
57e121f0:	e201201f 	and	r2, r1, #31
	USB_STOR_PRINTF(" address %d\n", dev_desc->target);

	if (usb_inquiry(pccb, ss))
		return -1;

	perq = usb_stor_buf[0];
57e121f4:	e58d1004 	str	r1, [sp, #4]
	modi = usb_stor_buf[1];

	if ((perq & 0x1f) == 0x1f) {
57e121f8:	e352001f 	cmp	r2, #31

	if (usb_inquiry(pccb, ss))
		return -1;

	perq = usb_stor_buf[0];
	modi = usb_stor_buf[1];
57e121fc:	e5d63001 	ldrb	r3, [r6, #1]

	if ((perq & 0x1f) == 0x1f) {
57e12200:	0a000089 	beq	57e1242c <usb_stor_get_info+0x2e8>
		/* skip unknown devices */
		return 0;
	}
	if ((modi&0x80) == 0x80) {
57e12204:	e3130080 	tst	r3, #128	; 0x80
		/* drive is removable */
		dev_desc->removable = 1;
57e12208:	13a03001 	movne	r3, #1
57e1220c:	15c4300c 	strbne	r3, [r4, #12]
	}
	memcpy(&dev_desc->vendor[0], (const void *) &usb_stor_buf[8], 8);
57e12210:	e2861008 	add	r1, r6, #8
57e12214:	e3a02008 	mov	r2, #8
57e12218:	e2840018 	add	r0, r4, #24
57e1221c:	eb00483a 	bl	57e2430c <memcpy>
	memcpy(&dev_desc->product[0], (const void *) &usb_stor_buf[16], 16);
57e12220:	e2861010 	add	r1, r6, #16
57e12224:	e3a02010 	mov	r2, #16
57e12228:	e2840041 	add	r0, r4, #65	; 0x41
57e1222c:	eb004836 	bl	57e2430c <memcpy>
	memcpy(&dev_desc->revision[0], (const void *) &usb_stor_buf[32], 4);
	dev_desc->vendor[8] = 0;
57e12230:	e3a0a000 	mov	sl, #0
		/* drive is removable */
		dev_desc->removable = 1;
	}
	memcpy(&dev_desc->vendor[0], (const void *) &usb_stor_buf[8], 8);
	memcpy(&dev_desc->product[0], (const void *) &usb_stor_buf[16], 16);
	memcpy(&dev_desc->revision[0], (const void *) &usb_stor_buf[32], 4);
57e12234:	e2861020 	add	r1, r6, #32
57e12238:	e2840056 	add	r0, r4, #86	; 0x56
57e1223c:	e3a02004 	mov	r2, #4
static int usb_test_unit_ready(ccb *srb, struct us_data *ss)
{
	int retries = 10;

	do {
		memset(&srb->cmd[0], 0, 12);
57e12240:	e59f6234 	ldr	r6, [pc, #564]	; 57e1247c <usb_stor_get_info+0x338>
		/* drive is removable */
		dev_desc->removable = 1;
	}
	memcpy(&dev_desc->vendor[0], (const void *) &usb_stor_buf[8], 8);
	memcpy(&dev_desc->product[0], (const void *) &usb_stor_buf[16], 16);
	memcpy(&dev_desc->revision[0], (const void *) &usb_stor_buf[32], 4);
57e12244:	eb004830 	bl	57e2430c <memcpy>
	dev_desc->vendor[8] = 0;
	dev_desc->product[16] = 0;
	dev_desc->revision[4] = 0;
57e12248:	e3a0900b 	mov	r9, #11
		dev_desc->removable = 1;
	}
	memcpy(&dev_desc->vendor[0], (const void *) &usb_stor_buf[8], 8);
	memcpy(&dev_desc->product[0], (const void *) &usb_stor_buf[16], 16);
	memcpy(&dev_desc->revision[0], (const void *) &usb_stor_buf[32], 4);
	dev_desc->vendor[8] = 0;
57e1224c:	e5c4a020 	strb	sl, [r4, #32]
	dev_desc->product[16] = 0;
57e12250:	e5c4a051 	strb	sl, [r4, #81]	; 0x51
	dev_desc->revision[4] = 0;
57e12254:	e5c4a05a 	strb	sl, [r4, #90]	; 0x5a
static int usb_test_unit_ready(ccb *srb, struct us_data *ss)
{
	int retries = 10;

	do {
		memset(&srb->cmd[0], 0, 12);
57e12258:	e3a0b00c 	mov	fp, #12
57e1225c:	e59f7218 	ldr	r7, [pc, #536]	; 57e1247c <usb_stor_get_info+0x338>
57e12260:	e3a01000 	mov	r1, #0
57e12264:	e3a0200c 	mov	r2, #12
57e12268:	e2870d09 	add	r0, r7, #576	; 0x240
57e1226c:	eb004802 	bl	57e2427c <memset>
		srb->cmd[0] = SCSI_TST_U_RDY;
		srb->cmd[1] = srb->lun << 5;
57e12270:	e5d632c2 	ldrb	r3, [r6, #706]	; 0x2c2
{
	int retries = 10;

	do {
		memset(&srb->cmd[0], 0, 12);
		srb->cmd[0] = SCSI_TST_U_RDY;
57e12274:	e5c6a240 	strb	sl, [r6, #576]	; 0x240
		srb->cmd[1] = srb->lun << 5;
57e12278:	e1a03283 	lsl	r3, r3, #5
57e1227c:	e5c63241 	strb	r3, [r6, #577]	; 0x241
		srb->datalen = 0;
		srb->cmdlen = 12;
57e12280:	e5c6b2c3 	strb	fp, [r6, #707]	; 0x2c3

	do {
		memset(&srb->cmd[0], 0, 12);
		srb->cmd[0] = SCSI_TST_U_RDY;
		srb->cmd[1] = srb->lun << 5;
		srb->datalen = 0;
57e12284:	e586a2c4 	str	sl, [r6, #708]	; 0x2c4
		srb->cmdlen = 12;
		if (ss->transport(srb, ss) == USB_STOR_TRANSPORT_GOOD) {
57e12288:	e5953030 	ldr	r3, [r5, #48]	; 0x30
57e1228c:	e2870d09 	add	r0, r7, #576	; 0x240
57e12290:	e1a01005 	mov	r1, r5
57e12294:	e12fff33 	blx	r3
57e12298:	e3500000 	cmp	r0, #0
57e1229c:	1a00000d 	bne	57e122d8 <usb_stor_get_info+0x194>
			ss->flags |= USB_READY;
57e122a0:	e5953004 	ldr	r3, [r5, #4]

int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
		      block_dev_desc_t *dev_desc)
{
	unsigned char perq, modi;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned long, cap, 2);
57e122a4:	e28d60c7 	add	r6, sp, #199	; 0xc7
57e122a8:	e3c6603f 	bic	r6, r6, #63	; 0x3f
		srb->cmd[0] = SCSI_TST_U_RDY;
		srb->cmd[1] = srb->lun << 5;
		srb->datalen = 0;
		srb->cmdlen = 12;
		if (ss->transport(srb, ss) == USB_STOR_TRANSPORT_GOOD) {
			ss->flags |= USB_READY;
57e122ac:	e3833001 	orr	r3, r3, #1
57e122b0:	e5853004 	str	r3, [r5, #4]
			return 1;
		}
		return 0;
	}
	pccb->pdata = (unsigned char *)&cap[0];
	memset(pccb->pdata, 0, 8);
57e122b4:	e1a0100a 	mov	r1, sl
57e122b8:	e1a00006 	mov	r0, r6
57e122bc:	e3a02008 	mov	r2, #8
			dev_desc->type = perq;
			return 1;
		}
		return 0;
	}
	pccb->pdata = (unsigned char *)&cap[0];
57e122c0:	e58762c8 	str	r6, [r7, #712]	; 0x2c8
	memset(pccb->pdata, 0, 8);
57e122c4:	e3a0a004 	mov	sl, #4
57e122c8:	eb0047eb 	bl	57e2427c <memset>
{
	int retry;
	/* XXX retries */
	retry = 3;
	do {
		memset(&srb->cmd[0], 0, 12);
57e122cc:	e3a0900c 	mov	r9, #12
		srb->cmd[0] = SCSI_RD_CAPAC;
57e122d0:	e3a0b025 	mov	fp, #37	; 0x25
57e122d4:	ea000025 	b	57e12370 <usb_stor_get_info+0x22c>

static int usb_request_sense(ccb *srb, struct us_data *ss)
{
	char *ptr;

	ptr = (char *)srb->pdata;
57e122d8:	e596c2c8 	ldr	ip, [r6, #712]	; 0x2c8
	memset(&srb->cmd[0], 0, 12);
57e122dc:	e1a0100a 	mov	r1, sl
57e122e0:	e3a0200c 	mov	r2, #12
57e122e4:	e2870d09 	add	r0, r7, #576	; 0x240
57e122e8:	e58dc000 	str	ip, [sp]
57e122ec:	eb0047e2 	bl	57e2427c <memset>
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
57e122f0:	e5d632c2 	ldrb	r3, [r6, #706]	; 0x2c2
{
	char *ptr;

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
57e122f4:	e3a01003 	mov	r1, #3
	srb->cmd[1] = srb->lun << 5;
57e122f8:	e1a03283 	lsl	r3, r3, #5
57e122fc:	e5c63241 	strb	r3, [r6, #577]	; 0x241
	srb->cmd[4] = 18;
57e12300:	e3a03012 	mov	r3, #18
57e12304:	e5c63244 	strb	r3, [r6, #580]	; 0x244
	srb->datalen = 18;
	srb->pdata = &srb->sense_buf[0];
57e12308:	e59f3178 	ldr	r3, [pc, #376]	; 57e12488 <usb_stor_get_info+0x344>
{
	char *ptr;

	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
57e1230c:	e5c61240 	strb	r1, [r6, #576]	; 0x240
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
	srb->pdata = &srb->sense_buf[0];
	srb->cmdlen = 12;
57e12310:	e5c6b2c3 	strb	fp, [r6, #707]	; 0x2c3
	ptr = (char *)srb->pdata;
	memset(&srb->cmd[0], 0, 12);
	srb->cmd[0] = SCSI_REQ_SENSE;
	srb->cmd[1] = srb->lun << 5;
	srb->cmd[4] = 18;
	srb->datalen = 18;
57e12314:	e3a01012 	mov	r1, #18
57e12318:	e58612c4 	str	r1, [r6, #708]	; 0x2c4
	srb->pdata = &srb->sense_buf[0];
57e1231c:	e58632c8 	str	r3, [r6, #712]	; 0x2c8
	srb->cmdlen = 12;
	ss->transport(srb, ss);
57e12320:	e2870d09 	add	r0, r7, #576	; 0x240
57e12324:	e5953030 	ldr	r3, [r5, #48]	; 0x30
57e12328:	e1a01005 	mov	r1, r5
57e1232c:	e12fff33 	blx	r3
		 * "Not Ready - medium not present"
		 * (the sense Key equals 0x2 and the ASC is 0x3a)
		 * return immediately as the medium being absent won't change
		 * unless there is a user action.
		 */
		if ((srb->sense_buf[2] == 0x02) &&
57e12330:	e5d63282 	ldrb	r3, [r6, #642]	; 0x282
	srb->cmdlen = 12;
	ss->transport(srb, ss);
	USB_STOR_PRINTF("Request Sense returned %02X %02X %02X\n",
			srb->sense_buf[2], srb->sense_buf[12],
			srb->sense_buf[13]);
	srb->pdata = (uchar *)ptr;
57e12334:	e59dc000 	ldr	ip, [sp]
		 * "Not Ready - medium not present"
		 * (the sense Key equals 0x2 and the ASC is 0x3a)
		 * return immediately as the medium being absent won't change
		 * unless there is a user action.
		 */
		if ((srb->sense_buf[2] == 0x02) &&
57e12338:	e3530002 	cmp	r3, #2
	srb->cmdlen = 12;
	ss->transport(srb, ss);
	USB_STOR_PRINTF("Request Sense returned %02X %02X %02X\n",
			srb->sense_buf[2], srb->sense_buf[12],
			srb->sense_buf[13]);
	srb->pdata = (uchar *)ptr;
57e1233c:	e586c2c8 	str	ip, [r6, #712]	; 0x2c8
		 * "Not Ready - medium not present"
		 * (the sense Key equals 0x2 and the ASC is 0x3a)
		 * return immediately as the medium being absent won't change
		 * unless there is a user action.
		 */
		if ((srb->sense_buf[2] == 0x02) &&
57e12340:	1a000002 	bne	57e12350 <usb_stor_get_info+0x20c>
57e12344:	e5d6328c 	ldrb	r3, [r6, #652]	; 0x28c
57e12348:	e353003a 	cmp	r3, #58	; 0x3a
57e1234c:	0a000038 	beq	57e12434 <usb_stor_get_info+0x2f0>
		    (srb->sense_buf[12] == 0x3a))
			return -1;
		mdelay(100);
57e12350:	e3a00064 	mov	r0, #100	; 0x64
57e12354:	eb004883 	bl	57e24568 <mdelay>
	} while (retries--);
57e12358:	e2599001 	subs	r9, r9, #1
57e1235c:	1affffbe 	bne	57e1225c <usb_stor_get_info+0x118>
57e12360:	ea000033 	b	57e12434 <usb_stor_get_info+0x2f0>
		printf("Device NOT ready\n"
		       "   Request Sense returned %02X %02X %02X\n",
		       pccb->sense_buf[2], pccb->sense_buf[12],
		       pccb->sense_buf[13]);
		if (dev_desc->removable == 1) {
			dev_desc->type = perq;
57e12364:	e59d3004 	ldr	r3, [sp, #4]
57e12368:	e5c4300b 	strb	r3, [r4, #11]
			return 1;
57e1236c:	ea00002e 	b	57e1242c <usb_stor_get_info+0x2e8>
{
	int retry;
	/* XXX retries */
	retry = 3;
	do {
		memset(&srb->cmd[0], 0, 12);
57e12370:	e3a01000 	mov	r1, #0
57e12374:	e3a0200c 	mov	r2, #12
57e12378:	e59f0100 	ldr	r0, [pc, #256]	; 57e12480 <usb_stor_get_info+0x33c>
57e1237c:	eb0047be 	bl	57e2427c <memset>
		srb->cmd[0] = SCSI_RD_CAPAC;
		srb->cmd[1] = srb->lun << 5;
57e12380:	e5d732c2 	ldrb	r3, [r7, #706]	; 0x2c2
	int retry;
	/* XXX retries */
	retry = 3;
	do {
		memset(&srb->cmd[0], 0, 12);
		srb->cmd[0] = SCSI_RD_CAPAC;
57e12384:	e5c7b240 	strb	fp, [r7, #576]	; 0x240
		srb->cmd[1] = srb->lun << 5;
57e12388:	e1a03283 	lsl	r3, r3, #5
57e1238c:	e5c73241 	strb	r3, [r7, #577]	; 0x241
		srb->datalen = 8;
		srb->cmdlen = 12;
57e12390:	e5c792c3 	strb	r9, [r7, #707]	; 0x2c3
	retry = 3;
	do {
		memset(&srb->cmd[0], 0, 12);
		srb->cmd[0] = SCSI_RD_CAPAC;
		srb->cmd[1] = srb->lun << 5;
		srb->datalen = 8;
57e12394:	e3a03008 	mov	r3, #8
57e12398:	e58732c4 	str	r3, [r7, #708]	; 0x2c4
		srb->cmdlen = 12;
		if (ss->transport(srb, ss) == USB_STOR_TRANSPORT_GOOD)
57e1239c:	e59f00dc 	ldr	r0, [pc, #220]	; 57e12480 <usb_stor_get_info+0x33c>
57e123a0:	e5953030 	ldr	r3, [r5, #48]	; 0x30
57e123a4:	e1a01005 	mov	r1, r5
57e123a8:	e12fff33 	blx	r3
57e123ac:	e3500000 	cmp	r0, #0
57e123b0:	0a000002 	beq	57e123c0 <usb_stor_get_info+0x27c>
			return 0;
	} while (retry--);
57e123b4:	e25aa001 	subs	sl, sl, #1
57e123b8:	1affffec 	bne	57e12370 <usb_stor_get_info+0x22c>
57e123bc:	ea000027 	b	57e12460 <usb_stor_get_info+0x31c>
	if (usb_read_capacity(pccb, ss) != 0) {
		printf("READ_CAP ERROR\n");
		cap[0] = 2880;
		cap[1] = 0x200;
	}
	ss->flags &= ~USB_READY;
57e123c0:	e5953004 	ldr	r3, [r5, #4]
57e123c4:	e3c33001 	bic	r3, r3, #1
57e123c8:	e5853004 	str	r3, [r5, #4]
			cap[1]);
#if 0
	if (cap[0] > (0x200000 * 10)) /* greater than 10 GByte */
		cap[0] >>= 16;
#endif
	cap[0] = cpu_to_be32(cap[0]);
57e123cc:	e5963000 	ldr	r3, [r6]
57e123d0:	e1a01c03 	lsl	r1, r3, #24
57e123d4:	e2032cff 	and	r2, r3, #65280	; 0xff00
57e123d8:	e1811c23 	orr	r1, r1, r3, lsr #24
57e123dc:	e1811402 	orr	r1, r1, r2, lsl #8
57e123e0:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e123e4:	e1811423 	orr	r1, r1, r3, lsr #8
	cap[1] = cpu_to_be32(cap[1]);
57e123e8:	e5963004 	ldr	r3, [r6, #4]
57e123ec:	e1a02c03 	lsl	r2, r3, #24
57e123f0:	e2030cff 	and	r0, r3, #65280	; 0xff00
57e123f4:	e1822c23 	orr	r2, r2, r3, lsr #24
57e123f8:	e1822400 	orr	r2, r2, r0, lsl #8
57e123fc:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e12400:	e1822423 	orr	r2, r2, r3, lsr #8

	/* this assumes bigendian! */
	cap[0] += 1;
57e12404:	e2813001 	add	r3, r1, #1
	blksz = &cap[1];
	USB_STOR_PRINTF("Capacity = 0x%lx, blocksz = 0x%lx\n",
			*capacity, *blksz);
	dev_desc->lba = *capacity;
	dev_desc->blksz = *blksz;
	dev_desc->type = perq;
57e12408:	e59d1004 	ldr	r1, [sp, #4]
#if 0
	if (cap[0] > (0x200000 * 10)) /* greater than 10 GByte */
		cap[0] >>= 16;
#endif
	cap[0] = cpu_to_be32(cap[0]);
	cap[1] = cpu_to_be32(cap[1]);
57e1240c:	e5862004 	str	r2, [r6, #4]

	/* this assumes bigendian! */
	cap[0] += 1;
57e12410:	e5863000 	str	r3, [r6]
	dev_desc->blksz = *blksz;
	dev_desc->type = perq;
	USB_STOR_PRINTF(" address %d\n", dev_desc->target);
	USB_STOR_PRINTF("partype: %d\n", dev_desc->part_type);

	init_part(dev_desc);
57e12414:	e1a00004 	mov	r0, r4
	cap[0] += 1;
	capacity = &cap[0];
	blksz = &cap[1];
	USB_STOR_PRINTF("Capacity = 0x%lx, blocksz = 0x%lx\n",
			*capacity, *blksz);
	dev_desc->lba = *capacity;
57e12418:	e5843010 	str	r3, [r4, #16]
	dev_desc->blksz = *blksz;
57e1241c:	e5842014 	str	r2, [r4, #20]
	dev_desc->type = perq;
57e12420:	e5c4100b 	strb	r1, [r4, #11]
	USB_STOR_PRINTF(" address %d\n", dev_desc->target);
	USB_STOR_PRINTF("partype: %d\n", dev_desc->part_type);

	init_part(dev_desc);
57e12424:	eb00034d 	bl	57e13160 <init_part>

	USB_STOR_PRINTF("partype: %d\n", dev_desc->part_type);
	return 1;
57e12428:	e3a00001 	mov	r0, #1
}
57e1242c:	e28ddf42 	add	sp, sp, #264	; 0x108
57e12430:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	USB_STOR_PRINTF("ISO Vers %X, Response Data %X\n", usb_stor_buf[2],
			usb_stor_buf[3]);
	if (usb_test_unit_ready(pccb, ss)) {
		printf("Device NOT ready\n"
		       "   Request Sense returned %02X %02X %02X\n",
		       pccb->sense_buf[2], pccb->sense_buf[12],
57e12434:	e59f3040 	ldr	r3, [pc, #64]	; 57e1247c <usb_stor_get_info+0x338>
		      (uchar *)dev_desc->product);
#endif /* CONFIG_USB_BIN_FIXUP */
	USB_STOR_PRINTF("ISO Vers %X, Response Data %X\n", usb_stor_buf[2],
			usb_stor_buf[3]);
	if (usb_test_unit_ready(pccb, ss)) {
		printf("Device NOT ready\n"
57e12438:	e59f004c 	ldr	r0, [pc, #76]	; 57e1248c <usb_stor_get_info+0x348>
57e1243c:	e5d31282 	ldrb	r1, [r3, #642]	; 0x282
57e12440:	e5d3228c 	ldrb	r2, [r3, #652]	; 0x28c
57e12444:	e5d3328d 	ldrb	r3, [r3, #653]	; 0x28d
57e12448:	ebffdbff 	bl	57e0944c <printf>
		       "   Request Sense returned %02X %02X %02X\n",
		       pccb->sense_buf[2], pccb->sense_buf[12],
		       pccb->sense_buf[13]);
		if (dev_desc->removable == 1) {
57e1244c:	e5d4000c 	ldrb	r0, [r4, #12]
57e12450:	e3500001 	cmp	r0, #1
			dev_desc->type = perq;
			return 1;
		}
		return 0;
57e12454:	13a00000 	movne	r0, #0
	if (usb_test_unit_ready(pccb, ss)) {
		printf("Device NOT ready\n"
		       "   Request Sense returned %02X %02X %02X\n",
		       pccb->sense_buf[2], pccb->sense_buf[12],
		       pccb->sense_buf[13]);
		if (dev_desc->removable == 1) {
57e12458:	1afffff3 	bne	57e1242c <usb_stor_get_info+0x2e8>
57e1245c:	eaffffc0 	b	57e12364 <usb_stor_get_info+0x220>
		return 0;
	}
	pccb->pdata = (unsigned char *)&cap[0];
	memset(pccb->pdata, 0, 8);
	if (usb_read_capacity(pccb, ss) != 0) {
		printf("READ_CAP ERROR\n");
57e12460:	e59f0028 	ldr	r0, [pc, #40]	; 57e12490 <usb_stor_get_info+0x34c>
57e12464:	ebffdbf8 	bl	57e0944c <printf>
		cap[0] = 2880;
57e12468:	e3a03d2d 	mov	r3, #2880	; 0xb40
57e1246c:	e5863000 	str	r3, [r6]
		cap[1] = 0x200;
57e12470:	e2433d25 	sub	r3, r3, #2368	; 0x940
57e12474:	e5863004 	str	r3, [r6, #4]
57e12478:	eaffffd0 	b	57e123c0 <usb_stor_get_info+0x27c>
57e1247c:	57e46e00 	.word	0x57e46e00
57e12480:	57e47040 	.word	0x57e47040
57e12484:	57e32f13 	.word	0x57e32f13
57e12488:	57e47080 	.word	0x57e47080
57e1248c:	57e32f25 	.word	0x57e32f25
57e12490:	57e32f60 	.word	0x57e32f60

57e12494 <usb_stor_scan>:
 * scan the usb and reports device info
 * to the user if mode = 1
 * returns current device or -1 if no
 */
int usb_stor_scan(int mode)
{
57e12494:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned char i;
	struct usb_device *dev;

	if (mode == 1)
57e12498:	e3500001 	cmp	r0, #1
 * scan the usb and reports device info
 * to the user if mode = 1
 * returns current device or -1 if no
 */
int usb_stor_scan(int mode)
{
57e1249c:	e24dd0a0 	sub	sp, sp, #160	; 0xa0
	unsigned char i;
	struct usb_device *dev;

	if (mode == 1)
57e124a0:	1a000001 	bne	57e124ac <usb_stor_scan+0x18>
		printf("       scanning usb for storage devices... ");
57e124a4:	e59f01b4 	ldr	r0, [pc, #436]	; 57e12660 <usb_stor_scan+0x1cc>
57e124a8:	ebffdbe7 	bl	57e0944c <printf>

	usb_disable_asynch(1); /* asynch transfer not allowed */
57e124ac:	e3a00001 	mov	r0, #1
57e124b0:	ebfff5a0 	bl	57e0fb38 <usb_disable_asynch>
57e124b4:	e3a06000 	mov	r6, #0

	for (i = 0; i < USB_MAX_STOR_DEV; i++) {
		memset(&usb_dev_desc[i], 0, sizeof(block_dev_desc_t));
57e124b8:	e59f41a4 	ldr	r4, [pc, #420]	; 57e12664 <usb_stor_scan+0x1d0>
		usb_dev_desc[i].if_type = IF_TYPE_USB;
		usb_dev_desc[i].dev = i;
		usb_dev_desc[i].part_type = PART_TYPE_UNKNOWN;
		usb_dev_desc[i].target = 0xff;
		usb_dev_desc[i].type = DEV_TYPE_UNKNOWN;
		usb_dev_desc[i].block_read = usb_stor_read;
57e124bc:	e59fb1a4 	ldr	fp, [pc, #420]	; 57e12668 <usb_stor_scan+0x1d4>
		usb_dev_desc[i].block_write = usb_stor_write;
57e124c0:	e59f51a4 	ldr	r5, [pc, #420]	; 57e1266c <usb_stor_scan+0x1d8>
		printf("       scanning usb for storage devices... ");

	usb_disable_asynch(1); /* asynch transfer not allowed */

	for (i = 0; i < USB_MAX_STOR_DEV; i++) {
		memset(&usb_dev_desc[i], 0, sizeof(block_dev_desc_t));
57e124c4:	e1a09006 	mov	r9, r6
		usb_dev_desc[i].if_type = IF_TYPE_USB;
57e124c8:	e3a0a004 	mov	sl, #4
		usb_dev_desc[i].dev = i;
		usb_dev_desc[i].part_type = PART_TYPE_UNKNOWN;
		usb_dev_desc[i].target = 0xff;
57e124cc:	e3e07000 	mvn	r7, #0
		printf("       scanning usb for storage devices... ");

	usb_disable_asynch(1); /* asynch transfer not allowed */

	for (i = 0; i < USB_MAX_STOR_DEV; i++) {
		memset(&usb_dev_desc[i], 0, sizeof(block_dev_desc_t));
57e124d0:	e1a00004 	mov	r0, r4
57e124d4:	e3a01000 	mov	r1, #0
57e124d8:	e3a02070 	mov	r2, #112	; 0x70
57e124dc:	eb004766 	bl	57e2427c <memset>
		usb_dev_desc[i].if_type = IF_TYPE_USB;
		usb_dev_desc[i].dev = i;
57e124e0:	e5846004 	str	r6, [r4, #4]
		usb_dev_desc[i].part_type = PART_TYPE_UNKNOWN;
		usb_dev_desc[i].target = 0xff;
		usb_dev_desc[i].type = DEV_TYPE_UNKNOWN;
		usb_dev_desc[i].block_read = usb_stor_read;
		usb_dev_desc[i].block_write = usb_stor_write;
57e124e4:	e2866001 	add	r6, r6, #1
	if (mode == 1)
		printf("       scanning usb for storage devices... ");

	usb_disable_asynch(1); /* asynch transfer not allowed */

	for (i = 0; i < USB_MAX_STOR_DEV; i++) {
57e124e8:	e3560005 	cmp	r6, #5
		memset(&usb_dev_desc[i], 0, sizeof(block_dev_desc_t));
		usb_dev_desc[i].if_type = IF_TYPE_USB;
57e124ec:	e584a000 	str	sl, [r4]
		usb_dev_desc[i].dev = i;
		usb_dev_desc[i].part_type = PART_TYPE_UNKNOWN;
57e124f0:	e5c49008 	strb	r9, [r4, #8]
		usb_dev_desc[i].target = 0xff;
57e124f4:	e5c47009 	strb	r7, [r4, #9]
		usb_dev_desc[i].type = DEV_TYPE_UNKNOWN;
57e124f8:	e5c4700b 	strb	r7, [r4, #11]
		usb_dev_desc[i].block_read = usb_stor_read;
57e124fc:	e584b060 	str	fp, [r4, #96]	; 0x60
		usb_dev_desc[i].block_write = usb_stor_write;
57e12500:	e5845064 	str	r5, [r4, #100]	; 0x64

	for (i = 0; i < USB_MAX_STOR_DEV; i++) {
		memset(&usb_dev_desc[i], 0, sizeof(block_dev_desc_t));
		usb_dev_desc[i].if_type = IF_TYPE_USB;
		usb_dev_desc[i].dev = i;
		usb_dev_desc[i].part_type = PART_TYPE_UNKNOWN;
57e12504:	e3a03000 	mov	r3, #0
		usb_dev_desc[i].target = 0xff;
		usb_dev_desc[i].type = DEV_TYPE_UNKNOWN;
		usb_dev_desc[i].block_read = usb_stor_read;
		usb_dev_desc[i].block_write = usb_stor_write;
57e12508:	e2844070 	add	r4, r4, #112	; 0x70
	if (mode == 1)
		printf("       scanning usb for storage devices... ");

	usb_disable_asynch(1); /* asynch transfer not allowed */

	for (i = 0; i < USB_MAX_STOR_DEV; i++) {
57e1250c:	1affffef 	bne	57e124d0 <usb_stor_scan+0x3c>
		usb_dev_desc[i].type = DEV_TYPE_UNKNOWN;
		usb_dev_desc[i].block_read = usb_stor_read;
		usb_dev_desc[i].block_write = usb_stor_write;
	}

	usb_max_devs = 0;
57e12510:	e59f414c 	ldr	r4, [pc, #332]	; 57e12664 <usb_stor_scan+0x1d0>
}

static unsigned int usb_get_max_lun(struct us_data *us)
{
	int len;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, result, 1);
57e12514:	e28db05f 	add	fp, sp, #95	; 0x5f
		usb_dev_desc[i].type = DEV_TYPE_UNKNOWN;
		usb_dev_desc[i].block_read = usb_stor_read;
		usb_dev_desc[i].block_write = usb_stor_write;
	}

	usb_max_devs = 0;
57e12518:	e5843304 	str	r3, [r4, #772]	; 0x304
57e1251c:	e1a05003 	mov	r5, r3
		dev = usb_get_dev_index(i); /* get device */
		USB_STOR_PRINTF("i=%d\n", i);
		if (dev == NULL)
			break; /* no more devices available */

		if (usb_storage_probe(dev, 0, &usb_stor[usb_max_devs])) {
57e12520:	e286602f 	add	r6, r6, #47	; 0x2f
}

static unsigned int usb_get_max_lun(struct us_data *us)
{
	int len;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, result, 1);
57e12524:	e3cbb03f 	bic	fp, fp, #63	; 0x3f
		usb_dev_desc[i].block_write = usb_stor_write;
	}

	usb_max_devs = 0;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
		dev = usb_get_dev_index(i); /* get device */
57e12528:	e1a00005 	mov	r0, r5
57e1252c:	ebfff77a 	bl	57e1031c <usb_get_dev_index>
		USB_STOR_PRINTF("i=%d\n", i);
		if (dev == NULL)
57e12530:	e2502000 	subs	r2, r0, #0
57e12534:	e58d201c 	str	r2, [sp, #28]
57e12538:	0a00003c 	beq	57e12630 <usb_stor_scan+0x19c>
			break; /* no more devices available */

		if (usb_storage_probe(dev, 0, &usb_stor[usb_max_devs])) {
57e1253c:	e5942304 	ldr	r2, [r4, #772]	; 0x304
57e12540:	e59f3128 	ldr	r3, [pc, #296]	; 57e12670 <usb_stor_scan+0x1dc>
57e12544:	e3a01000 	mov	r1, #0
57e12548:	e0223296 	mla	r2, r6, r2, r3
57e1254c:	ebfffe72 	bl	57e11f1c <usb_storage_probe>
57e12550:	e3500000 	cmp	r0, #0
57e12554:	0a00002c 	beq	57e1260c <usb_stor_scan+0x178>
			/* OK, it's a storage device.  Iterate over its LUNs
			 * and populate `usb_dev_desc'.
			 */
			int lun, max_lun, start = usb_max_devs;

			max_lun = usb_get_max_lun(&usb_stor[usb_max_devs]);
57e12558:	e5949304 	ldr	r9, [r4, #772]	; 0x304

static unsigned int usb_get_max_lun(struct us_data *us)
{
	int len;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, result, 1);
	len = usb_control_msg(us->pusb_dev,
57e1255c:	e3a07000 	mov	r7, #0
			      usb_rcvctrlpipe(us->pusb_dev, 0),
57e12560:	e0224996 	mla	r2, r6, r9, r4
57e12564:	e5920308 	ldr	r0, [r2, #776]	; 0x308
57e12568:	e5903068 	ldr	r3, [r0, #104]	; 0x68
57e1256c:	e5901000 	ldr	r1, [r0]

static unsigned int usb_get_max_lun(struct us_data *us)
{
	int len;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, result, 1);
	len = usb_control_msg(us->pusb_dev,
57e12570:	e58d7000 	str	r7, [sp]
57e12574:	e5d22310 	ldrb	r2, [r2, #784]	; 0x310
			      usb_rcvctrlpipe(us->pusb_dev, 0),
57e12578:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000

static unsigned int usb_get_max_lun(struct us_data *us)
{
	int len;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, result, 1);
	len = usb_control_msg(us->pusb_dev,
57e1257c:	e58d2004 	str	r2, [sp, #4]
57e12580:	e3a02001 	mov	r2, #1
			      usb_rcvctrlpipe(us->pusb_dev, 0),
57e12584:	e3833080 	orr	r3, r3, #128	; 0x80

static unsigned int usb_get_max_lun(struct us_data *us)
{
	int len;
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, result, 1);
	len = usb_control_msg(us->pusb_dev,
57e12588:	e58d200c 	str	r2, [sp, #12]
57e1258c:	e3a02f7d 	mov	r2, #500	; 0x1f4
57e12590:	e58d2010 	str	r2, [sp, #16]
57e12594:	e1831401 	orr	r1, r3, r1, lsl #8
57e12598:	e3a020fe 	mov	r2, #254	; 0xfe
57e1259c:	e3a030a1 	mov	r3, #161	; 0xa1
57e125a0:	e58db008 	str	fp, [sp, #8]
57e125a4:	ebfff56c 	bl	57e0fb5c <usb_control_msg>
			max_lun = usb_get_max_lun(&usb_stor[usb_max_devs]);
			for (lun = 0;
			     lun <= max_lun && usb_max_devs < USB_MAX_STOR_DEV;
			     lun++) {
				usb_dev_desc[usb_max_devs].lun = lun;
				if (usb_stor_get_info(dev, &usb_stor[start],
57e125a8:	e59f20c0 	ldr	r2, [pc, #192]	; 57e12670 <usb_stor_scan+0x1dc>
			      0, us->ifnum,
			      result, sizeof(char),
			      USB_CNTL_TIMEOUT * 5);
	USB_STOR_PRINTF("Get Max LUN -> len = %i, result = %i\n",
			len, (int) *result);
	return (len > 0) ? *result : 0;
57e125ac:	e1500007 	cmp	r0, r7
57e125b0:	d1a0a007 	movle	sl, r7
57e125b4:	c5dba000 	ldrbgt	sl, [fp]
			 * and populate `usb_dev_desc'.
			 */
			int lun, max_lun, start = usb_max_devs;

			max_lun = usb_get_max_lun(&usb_stor[usb_max_devs]);
			for (lun = 0;
57e125b8:	e3a07000 	mov	r7, #0
			     lun <= max_lun && usb_max_devs < USB_MAX_STOR_DEV;
			     lun++) {
				usb_dev_desc[usb_max_devs].lun = lun;
57e125bc:	e3a03070 	mov	r3, #112	; 0x70
				if (usb_stor_get_info(dev, &usb_stor[start],
57e125c0:	e0292996 	mla	r9, r6, r9, r2
57e125c4:	ea00000d 	b	57e12600 <usb_stor_scan+0x16c>

			max_lun = usb_get_max_lun(&usb_stor[usb_max_devs]);
			for (lun = 0;
			     lun <= max_lun && usb_max_devs < USB_MAX_STOR_DEV;
			     lun++) {
				usb_dev_desc[usb_max_devs].lun = lun;
57e125c8:	e0224293 	mla	r2, r3, r2, r4
57e125cc:	e5c2700a 	strb	r7, [r2, #10]
				if (usb_stor_get_info(dev, &usb_stor[start],
57e125d0:	e59d001c 	ldr	r0, [sp, #28]
57e125d4:	e1a01009 	mov	r1, r9
57e125d8:	e58d3018 	str	r3, [sp, #24]
57e125dc:	ebfffed8 	bl	57e12144 <usb_stor_get_info>
57e125e0:	e3500001 	cmp	r0, #1
						      &usb_dev_desc[usb_max_devs]) == 1) {
				usb_max_devs++;
57e125e4:	05942304 	ldreq	r2, [r4, #772]	; 0x304
			int lun, max_lun, start = usb_max_devs;

			max_lun = usb_get_max_lun(&usb_stor[usb_max_devs]);
			for (lun = 0;
			     lun <= max_lun && usb_max_devs < USB_MAX_STOR_DEV;
			     lun++) {
57e125e8:	e2877001 	add	r7, r7, #1
				usb_dev_desc[usb_max_devs].lun = lun;
				if (usb_stor_get_info(dev, &usb_stor[start],
						      &usb_dev_desc[usb_max_devs]) == 1) {
				usb_max_devs++;
57e125ec:	02822001 	addeq	r2, r2, #1
57e125f0:	05842304 	streq	r2, [r4, #772]	; 0x304
			 * and populate `usb_dev_desc'.
			 */
			int lun, max_lun, start = usb_max_devs;

			max_lun = usb_get_max_lun(&usb_stor[usb_max_devs]);
			for (lun = 0;
57e125f4:	e157000a 	cmp	r7, sl
			     lun <= max_lun && usb_max_devs < USB_MAX_STOR_DEV;
			     lun++) {
				usb_dev_desc[usb_max_devs].lun = lun;
				if (usb_stor_get_info(dev, &usb_stor[start],
57e125f8:	e59d3018 	ldr	r3, [sp, #24]
			 * and populate `usb_dev_desc'.
			 */
			int lun, max_lun, start = usb_max_devs;

			max_lun = usb_get_max_lun(&usb_stor[usb_max_devs]);
			for (lun = 0;
57e125fc:	ca000002 	bgt	57e1260c <usb_stor_scan+0x178>
			     lun <= max_lun && usb_max_devs < USB_MAX_STOR_DEV;
57e12600:	e5942304 	ldr	r2, [r4, #772]	; 0x304
57e12604:	e3520004 	cmp	r2, #4
57e12608:	daffffee 	ble	57e125c8 <usb_stor_scan+0x134>
				usb_max_devs++;
		}
			}
		}
		/* if storage device */
		if (usb_max_devs == USB_MAX_STOR_DEV) {
57e1260c:	e5941304 	ldr	r1, [r4, #772]	; 0x304
57e12610:	e3510005 	cmp	r1, #5
57e12614:	1a000002 	bne	57e12624 <usb_stor_scan+0x190>
			printf("max USB Storage Device reached: %d stopping\n",
57e12618:	e59f0054 	ldr	r0, [pc, #84]	; 57e12674 <usb_stor_scan+0x1e0>
57e1261c:	ebffdb8a 	bl	57e0944c <printf>
				usb_max_devs);
			break;
57e12620:	ea000002 	b	57e12630 <usb_stor_scan+0x19c>
57e12624:	e2855001 	add	r5, r5, #1
		usb_dev_desc[i].block_read = usb_stor_read;
		usb_dev_desc[i].block_write = usb_stor_write;
	}

	usb_max_devs = 0;
	for (i = 0; i < USB_MAX_DEVICE; i++) {
57e12628:	e3550020 	cmp	r5, #32
57e1262c:	1affffbd 	bne	57e12528 <usb_stor_scan+0x94>
			break;
		}
	} /* for */

	usb_disable_asynch(0); /* asynch transfer allowed */
	printf("%d Storage Device(s) found\n", usb_max_devs);
57e12630:	e59f402c 	ldr	r4, [pc, #44]	; 57e12664 <usb_stor_scan+0x1d0>
				usb_max_devs);
			break;
		}
	} /* for */

	usb_disable_asynch(0); /* asynch transfer allowed */
57e12634:	e3a00000 	mov	r0, #0
57e12638:	ebfff53e 	bl	57e0fb38 <usb_disable_asynch>
	printf("%d Storage Device(s) found\n", usb_max_devs);
57e1263c:	e5941304 	ldr	r1, [r4, #772]	; 0x304
57e12640:	e59f0030 	ldr	r0, [pc, #48]	; 57e12678 <usb_stor_scan+0x1e4>
57e12644:	ebffdb80 	bl	57e0944c <printf>
	if (usb_max_devs > 0)
57e12648:	e5943304 	ldr	r3, [r4, #772]	; 0x304
		return 0;
57e1264c:	e3530000 	cmp	r3, #0
	return -1;
}
57e12650:	d3e00000 	mvnle	r0, #0
57e12654:	c3a00000 	movgt	r0, #0
57e12658:	e28dd0a0 	add	sp, sp, #160	; 0xa0
57e1265c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e12660:	57e32f70 	.word	0x57e32f70
57e12664:	57e46e00 	.word	0x57e46e00
57e12668:	57e114d0 	.word	0x57e114d0
57e1266c:	57e112a8 	.word	0x57e112a8
57e12670:	57e47108 	.word	0x57e47108
57e12674:	57e32f9c 	.word	0x57e32f9c
57e12678:	57e32fc9 	.word	0x57e32fc9

57e1267c <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1>:


#ifndef REDBOOT			/*SB */
typedef int cyg_int32;
static int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
57e1267c:	e92d4070 	push	{r4, r5, r6, lr}
57e12680:	e1a05000 	mov	r5, r0
{
#define DELAY 20
  unsigned long counter = 0;
57e12684:	e3a04000 	mov	r4, #0
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
57e12688:	e59f603c 	ldr	r6, [pc, #60]	; 57e126cc <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1+0x50>
57e1268c:	ea000002 	b	57e1269c <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1+0x20>
    {
      udelay (DELAY);
57e12690:	e3a00014 	mov	r0, #20
57e12694:	eb0047a7 	bl	57e24538 <udelay>
      counter++;
57e12698:	e2844001 	add	r4, r4, #1
static int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
#define DELAY 20
  unsigned long counter = 0;
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
57e1269c:	ebffdb4d 	bl	57e093d8 <tstc>
57e126a0:	e3500000 	cmp	r0, #0
57e126a4:	1a000001 	bne	57e126b0 <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1+0x34>
57e126a8:	e1540006 	cmp	r4, r6
57e126ac:	1afffff7 	bne	57e12690 <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1+0x14>
    {
      udelay (DELAY);
      counter++;
    }
  if (tstc ())
57e126b0:	ebffdb48 	bl	57e093d8 <tstc>
57e126b4:	e3500000 	cmp	r0, #0
57e126b8:	08bd8070 	popeq	{r4, r5, r6, pc}
    {
      *c = getc ();
57e126bc:	ebffdb3c 	bl	57e093b4 <getc>
57e126c0:	e5c50000 	strb	r0, [r5]
      return 1;
57e126c4:	e3a00001 	mov	r0, #1
    }
  return 0;
}
57e126c8:	e8bd8070 	pop	{r4, r5, r6, pc}
57e126cc:	000186a0 	.word	0x000186a0

57e126d0 <xyzModem_flush>:
#endif

/* Wait for the line to go idle */
static void
xyzModem_flush (void)
{
57e126d0:	e92d4013 	push	{r0, r1, r4, lr}
  int res;
  char c;
  while (true)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
57e126d4:	e28d4007 	add	r4, sp, #7
57e126d8:	e1a00004 	mov	r0, r4
57e126dc:	ebffffe6 	bl	57e1267c <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1>
      if (!res)
57e126e0:	e3500000 	cmp	r0, #0
57e126e4:	1afffffb 	bne	57e126d8 <xyzModem_flush+0x8>
	return;
    }
}
57e126e8:	e8bd801c 	pop	{r2, r3, r4, pc}

57e126ec <xyzModem_get_hdr>:

static int
xyzModem_get_hdr (void)
{
57e126ec:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
  hdr_chars = 0;

  if (xyz.tx_ack)
57e126f0:	e59f4228 	ldr	r4, [pc, #552]	; 57e12920 <xyzModem_get_hdr+0x234>
57e126f4:	e5943430 	ldr	r3, [r4, #1072]	; 0x430
57e126f8:	e3530000 	cmp	r3, #0
57e126fc:	0a000003 	beq	57e12710 <xyzModem_get_hdr+0x24>
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e12700:	e3a00006 	mov	r0, #6
57e12704:	ebffdb3c 	bl	57e093fc <putc>
  hdr_chars = 0;

  if (xyz.tx_ack)
    {
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
57e12708:	e3a03000 	mov	r3, #0
57e1270c:	e5843430 	str	r3, [r4, #1072]	; 0x430
    }
}

static int
xyzModem_get_hdr (void)
{
57e12710:	e3a04000 	mov	r4, #0
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
57e12714:	e59f6204 	ldr	r6, [pc, #516]	; 57e12920 <xyzModem_get_hdr+0x234>
    }
}

static int
xyzModem_get_hdr (void)
{
57e12718:	e1a05004 	mov	r5, r4
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
57e1271c:	e28d7007 	add	r7, sp, #7
57e12720:	e1a00007 	mov	r0, r7
57e12724:	ebffffd4 	bl	57e1267c <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1>
      ZM_DEBUG (zm_save (c));
      if (res)
57e12728:	e3500000 	cmp	r0, #0
57e1272c:	0a000023 	beq	57e127c0 <xyzModem_get_hdr+0xd4>
	{
	  hdr_chars++;
	  switch (c)
57e12730:	e5dd3007 	ldrb	r3, [sp, #7]
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  hdr_chars++;
57e12734:	e2844001 	add	r4, r4, #1
	  switch (c)
57e12738:	e3530002 	cmp	r3, #2
57e1273c:	0a00000d 	beq	57e12778 <xyzModem_get_hdr+0x8c>
57e12740:	8a000002 	bhi	57e12750 <xyzModem_get_hdr+0x64>
57e12744:	e3530001 	cmp	r3, #1
57e12748:	1afffff4 	bne	57e12720 <xyzModem_get_hdr+0x34>
57e1274c:	ea000004 	b	57e12764 <xyzModem_get_hdr+0x78>
57e12750:	e3530004 	cmp	r3, #4
57e12754:	0a000013 	beq	57e127a8 <xyzModem_get_hdr+0xbc>
57e12758:	e3530018 	cmp	r3, #24
57e1275c:	1affffef 	bne	57e12720 <xyzModem_get_hdr+0x34>
57e12760:	ea000009 	b	57e1278c <xyzModem_get_hdr+0xa0>
	    {
	    case SOH:
	      xyz.total_SOH++;
57e12764:	e59f31b4 	ldr	r3, [pc, #436]	; 57e12920 <xyzModem_get_hdr+0x234>
57e12768:	e593241c 	ldr	r2, [r3, #1052]	; 0x41c
57e1276c:	e2822001 	add	r2, r2, #1
57e12770:	e583241c 	str	r2, [r3, #1052]	; 0x41c
57e12774:	ea000064 	b	57e1290c <xyzModem_get_hdr+0x220>
	    case STX:
	      if (c == STX)
		xyz.total_STX++;
57e12778:	e59f31a0 	ldr	r3, [pc, #416]	; 57e12920 <xyzModem_get_hdr+0x234>
57e1277c:	e5932420 	ldr	r2, [r3, #1056]	; 0x420
57e12780:	e2822001 	add	r2, r2, #1
57e12784:	e5832420 	str	r2, [r3, #1056]	; 0x420
57e12788:	ea00005f 	b	57e1290c <xyzModem_get_hdr+0x220>
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
57e1278c:	e5963424 	ldr	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
57e12790:	e2855001 	add	r5, r5, #1
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
57e12794:	e2833001 	add	r3, r3, #1
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
57e12798:	e3550003 	cmp	r5, #3
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
57e1279c:	e5863424 	str	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
57e127a0:	1affffde 	bne	57e12720 <xyzModem_get_hdr+0x34>
57e127a4:	ea000054 	b	57e128fc <xyzModem_get_hdr+0x210>
		  /* Wait for multiple CAN to avoid early quits */
		  break;
		}
	    case EOT:
	      /* EOT only supported if no noise */
	      if (hdr_chars == 1)
57e127a8:	e3540001 	cmp	r4, #1
57e127ac:	1affffdb 	bne	57e12720 <xyzModem_get_hdr+0x34>
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e127b0:	e3a00006 	mov	r0, #6
57e127b4:	ebffdb10 	bl	57e093fc <putc>
	      if (hdr_chars == 1)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK on EOT #%d\n", __LINE__));
		  ZM_DEBUG (zm_dump (__LINE__));
		  return xyzModem_eof;
57e127b8:	e3e00003 	mvn	r0, #3
57e127bc:	ea000051 	b	57e12908 <xyzModem_get_hdr+0x21c>
	    }
	}
      else
	{
	  /* Data stream timed out */
	  xyzModem_flush ();	/* Toss any current input */
57e127c0:	ebffffc2 	bl	57e126d0 <xyzModem_flush>
	  ZM_DEBUG (zm_dump (__LINE__));
	  CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
57e127c4:	e59f0158 	ldr	r0, [pc, #344]	; 57e12924 <xyzModem_get_hdr+0x238>
57e127c8:	eb00475a 	bl	57e24538 <udelay>
57e127cc:	ea00004c 	b	57e12904 <xyzModem_get_hdr+0x218>
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.cblk);
57e127d0:	e59f0150 	ldr	r0, [pc, #336]	; 57e12928 <xyzModem_get_hdr+0x23c>
57e127d4:	ebffffa8 	bl	57e1267c <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1>
  ZM_DEBUG (zm_save (xyz.cblk));
  if (!res)
57e127d8:	e3500000 	cmp	r0, #0
57e127dc:	0a000048 	beq	57e12904 <xyzModem_get_hdr+0x218>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
57e127e0:	e28d5008 	add	r5, sp, #8
57e127e4:	e5753001 	ldrb	r3, [r5, #-1]!
57e127e8:	e59f6130 	ldr	r6, [pc, #304]	; 57e12920 <xyzModem_get_hdr+0x234>
57e127ec:	e3530001 	cmp	r3, #1
57e127f0:	13a03b01 	movne	r3, #1024	; 0x400
57e127f4:	03a03080 	moveq	r3, #128	; 0x80
57e127f8:	e5863410 	str	r3, [r6, #1040]	; 0x410
  xyz.bufp = xyz.pkt;
57e127fc:	e2863004 	add	r3, r6, #4
57e12800:	e5863404 	str	r3, [r6, #1028]	; 0x404
  for (i = 0; i < xyz.len; i++)
57e12804:	e3a04000 	mov	r4, #0
57e12808:	ea000007 	b	57e1282c <xyzModem_get_hdr+0x140>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
57e1280c:	e1a00005 	mov	r0, r5
57e12810:	ebffff99 	bl	57e1267c <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1>
      ZM_DEBUG (zm_save (c));
      if (res)
57e12814:	e3500000 	cmp	r0, #0
57e12818:	0a000039 	beq	57e12904 <xyzModem_get_hdr+0x218>
	{
	  xyz.pkt[i] = c;
57e1281c:	e5dd2007 	ldrb	r2, [sp, #7]
	return;
    }
}

static int
xyzModem_get_hdr (void)
57e12820:	e0863004 	add	r3, r6, r4
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  xyz.pkt[i] = c;
57e12824:	e5c32004 	strb	r2, [r3, #4]
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
57e12828:	e2844001 	add	r4, r4, #1
57e1282c:	e5963410 	ldr	r3, [r6, #1040]	; 0x410
57e12830:	e1540003 	cmp	r4, r3
57e12834:	bafffff4 	blt	57e1280c <xyzModem_get_hdr+0x120>
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
	}
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc1);
57e12838:	e59f00ec 	ldr	r0, [pc, #236]	; 57e1292c <xyzModem_get_hdr+0x240>
57e1283c:	ebffff8e 	bl	57e1267c <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1>
  ZM_DEBUG (zm_save (xyz.crc1));
  if (!res)
57e12840:	e3500000 	cmp	r0, #0
57e12844:	0a00002e 	beq	57e12904 <xyzModem_get_hdr+0x218>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  if (xyz.crc_mode)
57e12848:	e59f30d0 	ldr	r3, [pc, #208]	; 57e12920 <xyzModem_get_hdr+0x234>
57e1284c:	e5933428 	ldr	r3, [r3, #1064]	; 0x428
57e12850:	e3530000 	cmp	r3, #0
57e12854:	0a000003 	beq	57e12868 <xyzModem_get_hdr+0x17c>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc2);
57e12858:	e59f00d0 	ldr	r0, [pc, #208]	; 57e12930 <xyzModem_get_hdr+0x244>
57e1285c:	ebffff86 	bl	57e1267c <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1>
      ZM_DEBUG (zm_save (xyz.crc2));
      if (!res)
57e12860:	e3500000 	cmp	r0, #0
57e12864:	0a000026 	beq	57e12904 <xyzModem_get_hdr+0x218>
	  return xyzModem_timeout;
	}
    }
  ZM_DEBUG (zm_dump (__LINE__));
  /* Validate the message */
  if ((xyz.blk ^ xyz.cblk) != (unsigned char) 0xFF)
57e12868:	e59f40b0 	ldr	r4, [pc, #176]	; 57e12920 <xyzModem_get_hdr+0x234>
57e1286c:	e5d42409 	ldrb	r2, [r4, #1033]	; 0x409
57e12870:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
57e12874:	e0223003 	eor	r3, r2, r3
57e12878:	e35300ff 	cmp	r3, #255	; 0xff
57e1287c:	0a000002 	beq	57e1288c <xyzModem_get_hdr+0x1a0>
    {
      ZM_DEBUG (zm_dprintf
		("Framing error - blk: %x/%x/%x\n", xyz.blk, xyz.cblk,
		 (xyz.blk ^ xyz.cblk)));
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
57e12880:	ebffff92 	bl	57e126d0 <xyzModem_flush>
      return xyzModem_frame;
57e12884:	e3e00005 	mvn	r0, #5
57e12888:	ea00001e 	b	57e12908 <xyzModem_get_hdr+0x21c>
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
57e1288c:	e5943428 	ldr	r3, [r4, #1064]	; 0x428
57e12890:	e3530000 	cmp	r3, #0
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
57e12894:	05941410 	ldreq	r1, [r4, #1040]	; 0x410
57e12898:	01a02003 	moveq	r2, r3
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
      return xyzModem_frame;
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
57e1289c:	0a00000d 	beq	57e128d8 <xyzModem_get_hdr+0x1ec>
    {
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
57e128a0:	e2840004 	add	r0, r4, #4
57e128a4:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
57e128a8:	eb003e0c 	bl	57e220e0 <cyg_crc16>
      if (cksum != ((xyz.crc1 << 8) | xyz.crc2))
57e128ac:	e5d4240a 	ldrb	r2, [r4, #1034]	; 0x40a
57e128b0:	e5d4340b 	ldrb	r3, [r4, #1035]	; 0x40b
57e128b4:	e1833402 	orr	r3, r3, r2, lsl #8
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
57e128b8:	e1500003 	cmp	r0, r3
57e128bc:	ea00000b 	b	57e128f0 <xyzModem_get_hdr+0x204>
	return;
    }
}

static int
xyzModem_get_hdr (void)
57e128c0:	e0840002 	add	r0, r4, r2
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
	{
	  cksum += xyz.pkt[i];
57e128c4:	e5d00004 	ldrb	r0, [r0, #4]
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
57e128c8:	e2822001 	add	r2, r2, #1
	{
	  cksum += xyz.pkt[i];
57e128cc:	e0833000 	add	r3, r3, r0
57e128d0:	e1a03803 	lsl	r3, r3, #16
57e128d4:	e1a03823 	lsr	r3, r3, #16
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
57e128d8:	e1520001 	cmp	r2, r1
57e128dc:	bafffff7 	blt	57e128c0 <xyzModem_get_hdr+0x1d4>
	{
	  cksum += xyz.pkt[i];
	}
      if (xyz.crc1 != (cksum & 0xFF))
57e128e0:	e59f2038 	ldr	r2, [pc, #56]	; 57e12920 <xyzModem_get_hdr+0x234>
57e128e4:	e20330ff 	and	r3, r3, #255	; 0xff
57e128e8:	e5d2240a 	ldrb	r2, [r2, #1034]	; 0x40a
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
57e128ec:	e1520003 	cmp	r2, r3
57e128f0:	13e00006 	mvnne	r0, #6
57e128f4:	03a00000 	moveq	r0, #0
57e128f8:	ea000002 	b	57e12908 <xyzModem_get_hdr+0x21c>
	    case CAN:
	      xyz.total_CAN++;
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
		{
		  return xyzModem_cancel;
57e128fc:	e3e00004 	mvn	r0, #4
57e12900:	ea000000 	b	57e12908 <xyzModem_get_hdr+0x21c>
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
57e12904:	e3e00002 	mvn	r0, #2
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
}
57e12908:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	  return xyzModem_timeout;
	}
    }

  /* Header found, now read the data */
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
57e1290c:	e59f0020 	ldr	r0, [pc, #32]	; 57e12934 <xyzModem_get_hdr+0x248>
57e12910:	ebffff59 	bl	57e1267c <CYGACC_COMM_IF_GETC_TIMEOUT.clone.1>
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
57e12914:	e3500000 	cmp	r0, #0
57e12918:	0afffff9 	beq	57e12904 <xyzModem_get_hdr+0x218>
57e1291c:	eaffffab 	b	57e127d0 <xyzModem_get_hdr+0xe4>
57e12920:	57e47240 	.word	0x57e47240
57e12924:	0003d090 	.word	0x0003d090
57e12928:	57e47649 	.word	0x57e47649
57e1292c:	57e4764a 	.word	0x57e4764a
57e12930:	57e4764b 	.word	0x57e4764b
57e12934:	57e47648 	.word	0x57e47648

57e12938 <xyzModem_stream_open>:
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
57e12938:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
57e1293c:	e59f4230 	ldr	r4, [pc, #560]	; 57e12b74 <xyzModem_stream_open+0x23c>
  CYGACC_CALL_IF_SET_CONSOLE_COMM (console_chan);
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
57e12940:	e3a05000 	mov	r5, #0
57e12944:	e28d3008 	add	r3, sp, #8
57e12948:	e5235004 	str	r5, [r3, #-4]!
  xyz.__chan = &dummy;
57e1294c:	e5843000 	str	r3, [r4]
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
57e12950:	e3a03001 	mov	r3, #1
57e12954:	e5843428 	str	r3, [r4, #1064]	; 0x428
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
57e12958:	e5903004 	ldr	r3, [r0, #4]
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
#endif
  xyz.len = 0;
57e1295c:	e5845410 	str	r5, [r4, #1040]	; 0x410
  xyz.crc_mode = true;
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
57e12960:	e5843414 	str	r3, [r4, #1044]	; 0x414
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e12964:	e3a00043 	mov	r0, #67	; 0x43
  int dummy = 0;
  xyz.__chan = &dummy;
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
  xyz.at_eof = false;
57e12968:	e584542c 	str	r5, [r4, #1068]	; 0x42c
  xyz.tx_ack = false;
57e1296c:	e5845430 	str	r5, [r4, #1072]	; 0x430
  xyz.mode = info->mode;
  xyz.total_retries = 0;
57e12970:	e5845418 	str	r5, [r4, #1048]	; 0x418
  xyz.total_SOH = 0;
57e12974:	e584541c 	str	r5, [r4, #1052]	; 0x41c
  xyz.total_STX = 0;
57e12978:	e5845420 	str	r5, [r4, #1056]	; 0x420
  xyz.total_CAN = 0;
57e1297c:	e5845424 	str	r5, [r4, #1060]	; 0x424
#ifdef USE_YMODEM_LENGTH
  xyz.read_length = 0;
57e12980:	e5845438 	str	r5, [r4, #1080]	; 0x438
  xyz.file_length = 0;
57e12984:	e5845434 	str	r5, [r4, #1076]	; 0x434
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
57e12988:	e1a0a001 	mov	sl, r1
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e1298c:	ebffda9a 	bl	57e093fc <putc>
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
57e12990:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
57e12994:	e3530001 	cmp	r3, #1
57e12998:	13a0700a 	movne	r7, #10
57e1299c:	13a06014 	movne	r6, #20
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
57e129a0:	11a09005 	movne	r9, r5
  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
57e129a4:	05c4340c 	strbeq	r3, [r4, #1036]	; 0x40c
      return 0;
57e129a8:	01a00005 	moveq	r0, r5
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
57e129ac:	1a00006b 	bne	57e12b60 <xyzModem_stream_open+0x228>
57e129b0:	ea00006e 	b	57e12b70 <xyzModem_stream_open+0x238>
      return 0;
    }

  while (retries-- > 0)
    {
      stat = xyzModem_get_hdr ();
57e129b4:	ebffff4c 	bl	57e126ec <xyzModem_get_hdr>
      if (stat == 0)
57e129b8:	e2505000 	subs	r5, r0, #0
57e129bc:	1a000055 	bne	57e12b18 <xyzModem_stream_open+0x1e0>
	{
	  /* Y-modem file information header */
	  if (xyz.blk == 0)
57e129c0:	e59f21ac 	ldr	r2, [pc, #428]	; 57e12b74 <xyzModem_stream_open+0x23c>
57e129c4:	e5d23408 	ldrb	r3, [r2, #1032]	; 0x408
57e129c8:	e3530000 	cmp	r3, #0
57e129cc:	1a00004b 	bne	57e12b00 <xyzModem_stream_open+0x1c8>
	    {
#ifdef USE_YMODEM_LENGTH
	      /* skip filename */
	      while (*xyz.bufp++);
57e129d0:	e5923404 	ldr	r3, [r2, #1028]	; 0x404
57e129d4:	e4d31001 	ldrb	r1, [r3], #1
57e129d8:	e3510000 	cmp	r1, #0
57e129dc:	e5823404 	str	r3, [r2, #1028]	; 0x404
57e129e0:	1afffffa 	bne	57e129d0 <xyzModem_stream_open+0x98>
57e129e4:	e1a02003 	mov	r2, r3
  int radix = 10;
  char c;
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
57e129e8:	e5d21000 	ldrb	r1, [r2]
	  /* Y-modem file information header */
	  if (xyz.blk == 0)
	    {
#ifdef USE_YMODEM_LENGTH
	      /* skip filename */
	      while (*xyz.bufp++);
57e129ec:	e1a03002 	mov	r3, r2
  int radix = 10;
  char c;
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
57e129f0:	e3510020 	cmp	r1, #32
57e129f4:	e2822001 	add	r2, r2, #1
57e129f8:	0afffffa 	beq	57e129e8 <xyzModem_stream_open+0xb0>
57e129fc:	e3a00000 	mov	r0, #0
57e12a00:	e3a0c00a 	mov	ip, #10
57e12a04:	e3a02001 	mov	r2, #1
57e12a08:	ea000034 	b	57e12ae0 <xyzModem_stream_open+0x1a8>
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
57e12a0c:	e3520000 	cmp	r2, #0
57e12a10:	0a000009 	beq	57e12a3c <xyzModem_stream_open+0x104>
57e12a14:	e3510030 	cmp	r1, #48	; 0x30
57e12a18:	1a000007 	bne	57e12a3c <xyzModem_stream_open+0x104>
57e12a1c:	e5d32001 	ldrb	r2, [r3, #1]

/* Convert a character to lower case */
__inline__ static char
_tolower (char c)
{
  if ((c >= 'A') && (c <= 'Z'))
57e12a20:	e2421041 	sub	r1, r2, #65	; 0x41
57e12a24:	e3510019 	cmp	r1, #25
    {
      c = (c - 'A') + 'a';
57e12a28:	92822020 	addls	r2, r2, #32
57e12a2c:	920220ff 	andls	r2, r2, #255	; 0xff

  while (*s == ' ')
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
57e12a30:	e3520078 	cmp	r2, #120	; 0x78
	{
	  radix = 16;
	  s += 2;
57e12a34:	02833002 	addeq	r3, r3, #2
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
57e12a38:	03a0c010 	moveq	ip, #16
	  s += 2;
	}
      first = false;
      c = *s++;
57e12a3c:	e5d32000 	ldrb	r2, [r3]

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
57e12a40:	e2424030 	sub	r4, r2, #48	; 0x30
57e12a44:	e20450ff 	and	r5, r4, #255	; 0xff
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
57e12a48:	e2421041 	sub	r1, r2, #65	; 0x41

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
57e12a4c:	e3550009 	cmp	r5, #9
57e12a50:	83a05000 	movhi	r5, #0
57e12a54:	93a05001 	movls	r5, #1
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
57e12a58:	e3510005 	cmp	r1, #5
57e12a5c:	83a01000 	movhi	r1, #0
57e12a60:	93a01001 	movls	r1, #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
57e12a64:	e1916005 	orrs	r6, r1, r5
57e12a68:	1a000003 	bne	57e12a7c <xyzModem_stream_open+0x144>
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
57e12a6c:	e2424061 	sub	r4, r2, #97	; 0x61
57e12a70:	e3540005 	cmp	r4, #5
57e12a74:	9a000006 	bls	57e12a94 <xyzModem_stream_open+0x15c>
57e12a78:	ea000003 	b	57e12a8c <xyzModem_stream_open+0x154>
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
57e12a7c:	e3550000 	cmp	r5, #0
    {
      ret = (c - '0');
57e12a80:	11a01004 	movne	r1, r4
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
57e12a84:	1a00000b 	bne	57e12ab8 <xyzModem_stream_open+0x180>
57e12a88:	ea000001 	b	57e12a94 <xyzModem_stream_open+0x15c>
57e12a8c:	e59f30e4 	ldr	r3, [pc, #228]	; 57e12b78 <xyzModem_stream_open+0x240>
57e12a90:	ea00000c 	b	57e12ac8 <xyzModem_stream_open+0x190>
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
57e12a94:	e2424061 	sub	r4, r2, #97	; 0x61
57e12a98:	e3540005 	cmp	r4, #5
    {
      ret = (c - 'a' + 0x0a);
57e12a9c:	92421057 	subls	r1, r2, #87	; 0x57

  if ((c >= '0') && (c <= '9'))
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
57e12aa0:	9a000002 	bls	57e12ab0 <xyzModem_stream_open+0x178>
    {
      ret = (c - 'a' + 0x0a);
    }
  else if ((c >= 'A') && (c <= 'F'))
57e12aa4:	e3510000 	cmp	r1, #0
57e12aa8:	0a000002 	beq	57e12ab8 <xyzModem_stream_open+0x180>
    {
      ret = (c - 'A' + 0x0A);
57e12aac:	e2421037 	sub	r1, r2, #55	; 0x37
	  radix = 16;
	  s += 2;
	}
      first = false;
      c = *s++;
      if (_is_hex (c) && ((digit = _from_hex (c)) < radix))
57e12ab0:	e151000c 	cmp	r1, ip
57e12ab4:	aafffff4 	bge	57e12a8c <xyzModem_stream_open+0x154>
	{
	  radix = 16;
	  s += 2;
	}
      first = false;
      c = *s++;
57e12ab8:	e2833001 	add	r3, r3, #1
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
57e12abc:	e020109c 	mla	r0, ip, r0, r1
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
	  s += 2;
	}
      first = false;
57e12ac0:	e3a02000 	mov	r2, #0
57e12ac4:	ea000005 	b	57e12ae0 <xyzModem_stream_open+0x1a8>
	{
	  if (delim != (char *) 0)
	    {
	      /* See if this character is one of the delimiters */
	      char *dp = delim;
	      while (*dp && (c != *dp))
57e12ac8:	e5f31001 	ldrb	r1, [r3, #1]!
57e12acc:	e3510000 	cmp	r1, #0
57e12ad0:	0a000007 	beq	57e12af4 <xyzModem_stream_open+0x1bc>
57e12ad4:	e1520001 	cmp	r2, r1
57e12ad8:	1afffffa 	bne	57e12ac8 <xyzModem_stream_open+0x190>
57e12adc:	ea000002 	b	57e12aec <xyzModem_stream_open+0x1b4>
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
    s++;
  while (*s)
57e12ae0:	e5d31000 	ldrb	r1, [r3]
57e12ae4:	e3510000 	cmp	r1, #0
57e12ae8:	1affffc7 	bne	57e12a0c <xyzModem_stream_open+0xd4>
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
57e12aec:	e59f3080 	ldr	r3, [pc, #128]	; 57e12b74 <xyzModem_stream_open+0x23c>
57e12af0:	e5830434 	str	r0, [r3, #1076]	; 0x434
	      while (*xyz.bufp++);
	      /* get the length */
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
57e12af4:	e59f3078 	ldr	r3, [pc, #120]	; 57e12b74 <xyzModem_stream_open+0x23c>
57e12af8:	e3a02001 	mov	r2, #1
57e12afc:	e5832430 	str	r2, [r3, #1072]	; 0x430
	    }
	  xyz.next_blk = 1;
57e12b00:	e59f306c 	ldr	r3, [pc, #108]	; 57e12b74 <xyzModem_stream_open+0x23c>
57e12b04:	e3a02001 	mov	r2, #1
	  xyz.len = 0;
57e12b08:	e3a00000 	mov	r0, #0
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
	    }
	  xyz.next_blk = 1;
57e12b0c:	e5c3240c 	strb	r2, [r3, #1036]	; 0x40c
	  xyz.len = 0;
57e12b10:	e5830410 	str	r0, [r3, #1040]	; 0x410
	  return 0;
57e12b14:	ea000015 	b	57e12b70 <xyzModem_stream_open+0x238>
	}
      else if (stat == xyzModem_timeout)
57e12b18:	e3750003 	cmn	r5, #3
57e12b1c:	1a00000d 	bne	57e12b58 <xyzModem_stream_open+0x220>
	{
	  if (--crc_retries <= 0)
57e12b20:	e2477001 	sub	r7, r7, #1
57e12b24:	e3570000 	cmp	r7, #0
	    xyz.crc_mode = false;
57e12b28:	d5849428 	strle	r9, [r4, #1064]	; 0x428
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
57e12b2c:	e59f0048 	ldr	r0, [pc, #72]	; 57e12b7c <xyzModem_stream_open+0x244>
57e12b30:	eb004680 	bl	57e24538 <udelay>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
57e12b34:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e12b38:	e3500000 	cmp	r0, #0
57e12b3c:	03a00015 	moveq	r0, #21
57e12b40:	13a00043 	movne	r0, #67	; 0x43
57e12b44:	ebffda2c 	bl	57e093fc <putc>
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	  xyz.total_retries++;
57e12b48:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
57e12b4c:	e2833001 	add	r3, r3, #1
57e12b50:	e5843418 	str	r3, [r4, #1048]	; 0x418
57e12b54:	ea000001 	b	57e12b60 <xyzModem_stream_open+0x228>
	  ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	}
      if (stat == xyzModem_cancel)
57e12b58:	e3750005 	cmn	r5, #5
57e12b5c:	0a000001 	beq	57e12b68 <xyzModem_stream_open+0x230>
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
      return 0;
    }

  while (retries-- > 0)
57e12b60:	e2566001 	subs	r6, r6, #1
57e12b64:	2affff92 	bcs	57e129b4 <xyzModem_stream_open+0x7c>
      if (stat == xyzModem_cancel)
	{
	  break;
	}
    }
  *err = stat;
57e12b68:	e58a5000 	str	r5, [sl]
  ZM_DEBUG (zm_flush ());
  return -1;
57e12b6c:	e3e00000 	mvn	r0, #0
}
57e12b70:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
57e12b74:	57e47240 	.word	0x57e47240
57e12b78:	57e35c49 	.word	0x57e35c49
57e12b7c:	0007a120 	.word	0x0007a120

57e12b80 <xyzModem_stream_read>:

int
xyzModem_stream_read (char *buf, int size, int *err)
{
57e12b80:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
57e12b84:	e59f4240 	ldr	r4, [pc, #576]	; 57e12dcc <xyzModem_stream_read+0x24c>
  return -1;
}

int
xyzModem_stream_read (char *buf, int size, int *err)
{
57e12b88:	e1a09000 	mov	r9, r0
57e12b8c:	e1a0a001 	mov	sl, r1
57e12b90:	e58d2004 	str	r2, [sp, #4]
  int stat, total, len;
  int retries;

  total = 0;
57e12b94:	e3a0b000 	mov	fp, #0
  stat = xyzModem_cancel;
57e12b98:	e3e05004 	mvn	r5, #4
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
57e12b9c:	e1a07004 	mov	r7, r4
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
57e12ba0:	ea00007f 	b	57e12da4 <xyzModem_stream_read+0x224>
    {
      if (xyz.len == 0)
57e12ba4:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
57e12ba8:	e3530000 	cmp	r3, #0
57e12bac:	03a06014 	moveq	r6, #20
57e12bb0:	0a00005d 	beq	57e12d2c <xyzModem_stream_read+0x1ac>
57e12bb4:	ea000066 	b	57e12d54 <xyzModem_stream_read+0x1d4>
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
	    {
	      stat = xyzModem_get_hdr ();
57e12bb8:	ebfffecb 	bl	57e126ec <xyzModem_get_hdr>
	      if (stat == 0)
57e12bbc:	e2505000 	subs	r5, r0, #0
57e12bc0:	1a000039 	bne	57e12cac <xyzModem_stream_read+0x12c>
		{
		  if (xyz.blk == xyz.next_blk)
57e12bc4:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
57e12bc8:	e5d4240c 	ldrb	r2, [r4, #1036]	; 0x40c
57e12bcc:	e1530002 	cmp	r3, r2
57e12bd0:	1a00002d 	bne	57e12c8c <xyzModem_stream_read+0x10c>
		    {
		      xyz.tx_ack = true;
57e12bd4:	e3a02001 	mov	r2, #1
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
57e12bd8:	e0833002 	add	r3, r3, r2
	      stat = xyzModem_get_hdr ();
	      if (stat == 0)
		{
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
57e12bdc:	e5872430 	str	r2, [r7, #1072]	; 0x430
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
57e12be0:	e5972414 	ldr	r2, [r7, #1044]	; 0x414
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
57e12be4:	e5c7340c 	strb	r3, [r7, #1036]	; 0x40c

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
57e12be8:	e3520001 	cmp	r2, #1
57e12bec:	0a000002 	beq	57e12bfc <xyzModem_stream_read+0x7c>
57e12bf0:	e5973434 	ldr	r3, [r7, #1076]	; 0x434
57e12bf4:	e3530000 	cmp	r3, #0
57e12bf8:	1a000017 	bne	57e12c5c <xyzModem_stream_read+0xdc>
		      if (1)
			{
#endif
			  /* Data blocks can be padded with ^Z (EOF) characters */
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
57e12bfc:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
57e12c00:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
57e12c04:	e0813003 	add	r3, r1, r3
57e12c08:	e5530001 	ldrb	r0, [r3, #-1]
57e12c0c:	e350001a 	cmp	r0, #26
57e12c10:	1a00000f 	bne	57e12c54 <xyzModem_stream_read+0xd4>
57e12c14:	e5530002 	ldrb	r0, [r3, #-2]
57e12c18:	e350001a 	cmp	r0, #26
57e12c1c:	1a00000c 	bne	57e12c54 <xyzModem_stream_read+0xd4>
			      (xyz.bufp[xyz.len - 2] == EOF) &&
57e12c20:	e5533003 	ldrb	r3, [r3, #-3]
57e12c24:	e353001a 	cmp	r3, #26
57e12c28:	1a000009 	bne	57e12c54 <xyzModem_stream_read+0xd4>
57e12c2c:	ea000001 	b	57e12c38 <xyzModem_stream_read+0xb8>
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
				     && (xyz.bufp[xyz.len - 1] == EOF))
				{
				  xyz.len--;
57e12c30:	e2433001 	sub	r3, r3, #1
57e12c34:	e5843410 	str	r3, [r4, #1040]	; 0x410
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
			      (xyz.bufp[xyz.len - 2] == EOF) &&
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
57e12c38:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
57e12c3c:	e3530000 	cmp	r3, #0
57e12c40:	0a000003 	beq	57e12c54 <xyzModem_stream_read+0xd4>
				     && (xyz.bufp[xyz.len - 1] == EOF))
57e12c44:	e0810003 	add	r0, r1, r3
57e12c48:	e5500001 	ldrb	r0, [r0, #-1]
57e12c4c:	e350001a 	cmp	r0, #26
57e12c50:	0afffff6 	beq	57e12c30 <xyzModem_stream_read+0xb0>
		       * See if accumulated length exceeds that of the file.
		       * If so, reduce size (i.e., cut out pad bytes)
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
57e12c54:	e3520001 	cmp	r2, #1
57e12c58:	0a00003d 	beq	57e12d54 <xyzModem_stream_read+0x1d4>
57e12c5c:	e5942434 	ldr	r2, [r4, #1076]	; 0x434
57e12c60:	e3520000 	cmp	r2, #0
57e12c64:	0a00003a 	beq	57e12d54 <xyzModem_stream_read+0x1d4>
			{
			  xyz.read_length += xyz.len;
57e12c68:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
57e12c6c:	e5943438 	ldr	r3, [r4, #1080]	; 0x438
57e12c70:	e0813003 	add	r3, r1, r3
			  if (xyz.read_length > xyz.file_length)
57e12c74:	e1530002 	cmp	r3, r2
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
57e12c78:	80812002 	addhi	r2, r1, r2
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
			{
			  xyz.read_length += xyz.len;
57e12c7c:	e5843438 	str	r3, [r4, #1080]	; 0x438
			  if (xyz.read_length > xyz.file_length)
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
57e12c80:	80633002 	rsbhi	r3, r3, r2
57e12c84:	85843410 	strhi	r3, [r4, #1040]	; 0x410
57e12c88:	ea000031 	b	57e12d54 <xyzModem_stream_read+0x1d4>
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
57e12c8c:	e2422001 	sub	r2, r2, #1
57e12c90:	e20220ff 	and	r2, r2, #255	; 0xff
57e12c94:	e1530002 	cmp	r3, r2
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
		    }
		  else
		    {
		      stat = xyzModem_sequence;
57e12c98:	13e05007 	mvnne	r5, #7
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
57e12c9c:	1a00001a 	bne	57e12d0c <xyzModem_stream_read+0x18c>
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e12ca0:	e3a00006 	mov	r0, #6
57e12ca4:	ebffd9d4 	bl	57e093fc <putc>
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
		    {
		      /* Just re-ACK this so sender will get on with it */
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
57e12ca8:	ea00001f 	b	57e12d2c <xyzModem_stream_read+0x1ac>
		  else
		    {
		      stat = xyzModem_sequence;
		    }
		}
	      if (stat == xyzModem_cancel)
57e12cac:	e3750005 	cmn	r5, #5
57e12cb0:	0a000021 	beq	57e12d3c <xyzModem_stream_read+0x1bc>
		{
		  break;
		}
	      if (stat == xyzModem_eof)
57e12cb4:	e3750004 	cmn	r5, #4
57e12cb8:	1a000013 	bne	57e12d0c <xyzModem_stream_read+0x18c>
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e12cbc:	e3a00006 	mov	r0, #6
57e12cc0:	ebffd9cd 	bl	57e093fc <putc>
		}
	      if (stat == xyzModem_eof)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
57e12cc4:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
57e12cc8:	e3530002 	cmp	r3, #2
57e12ccc:	1a00000b 	bne	57e12d00 <xyzModem_stream_read+0x180>
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
57e12cd0:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e12cd4:	e3500000 	cmp	r0, #0
57e12cd8:	03a00015 	moveq	r0, #21
57e12cdc:	13a00043 	movne	r0, #67	; 0x43
57e12ce0:	ebffd9c5 	bl	57e093fc <putc>
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
					   (xyz.crc_mode ? 'C' : NAK));
		      xyz.total_retries++;
57e12ce4:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
57e12ce8:	e2833001 	add	r3, r3, #1
57e12cec:	e5843418 	str	r3, [r4, #1048]	; 0x418
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
57e12cf0:	ebfffe7d 	bl	57e126ec <xyzModem_get_hdr>
57e12cf4:	e1a05000 	mov	r5, r0
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e12cf8:	e3a00006 	mov	r0, #6
57e12cfc:	ebffd9be 	bl	57e093fc <putc>
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
57e12d00:	e3a03001 	mov	r3, #1
57e12d04:	e584342c 	str	r3, [r4, #1068]	; 0x42c
		  break;
57e12d08:	ea000009 	b	57e12d34 <xyzModem_stream_read+0x1b4>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
57e12d0c:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e12d10:	e3500000 	cmp	r0, #0
57e12d14:	03a00015 	moveq	r0, #21
57e12d18:	13a00043 	movne	r0, #67	; 0x43
57e12d1c:	ebffd9b6 	bl	57e093fc <putc>
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
57e12d20:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
57e12d24:	e2833001 	add	r3, r3, #1
57e12d28:	e5843418 	str	r3, [r4, #1048]	; 0x418
  while (!xyz.at_eof && (size > 0))
    {
      if (xyz.len == 0)
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
57e12d2c:	e2566001 	subs	r6, r6, #1
57e12d30:	2affffa0 	bcs	57e12bb8 <xyzModem_stream_read+0x38>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
57e12d34:	e3550000 	cmp	r5, #0
57e12d38:	aa000005 	bge	57e12d54 <xyzModem_stream_read+0x1d4>
	    {
	      *err = stat;
57e12d3c:	e59d2004 	ldr	r2, [sp, #4]
	      xyz.len = -1;
57e12d40:	e59f3084 	ldr	r3, [pc, #132]	; 57e12dcc <xyzModem_stream_read+0x24c>
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
	    {
	      *err = stat;
57e12d44:	e5825000 	str	r5, [r2]
	      xyz.len = -1;
57e12d48:	e3e02000 	mvn	r2, #0
57e12d4c:	e5832410 	str	r2, [r3, #1040]	; 0x410
	      return total;
57e12d50:	ea00001b 	b	57e12dc4 <xyzModem_stream_read+0x244>
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
57e12d54:	e594342c 	ldr	r3, [r4, #1068]	; 0x42c
57e12d58:	e3530000 	cmp	r3, #0
57e12d5c:	1a000010 	bne	57e12da4 <xyzModem_stream_read+0x224>
	{
	  len = xyz.len;
57e12d60:	e5946410 	ldr	r6, [r4, #1040]	; 0x410
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
57e12d64:	e1a00009 	mov	r0, r9
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
	{
	  len = xyz.len;
57e12d68:	e15a0006 	cmp	sl, r6
57e12d6c:	b1a0600a 	movlt	r6, sl
57e12d70:	a1a06006 	movge	r6, r6
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
57e12d74:	e1a02006 	mov	r2, r6
57e12d78:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
57e12d7c:	eb004562 	bl	57e2430c <memcpy>
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
57e12d80:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
	{
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
57e12d84:	e066a00a 	rsb	sl, r6, sl
	  buf += len;
	  total += len;
	  xyz.len -= len;
57e12d88:	e0663003 	rsb	r3, r6, r3
57e12d8c:	e5843410 	str	r3, [r4, #1040]	; 0x410
	  xyz.bufp += len;
57e12d90:	e5943404 	ldr	r3, [r4, #1028]	; 0x404
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
	  buf += len;
57e12d94:	e0899006 	add	r9, r9, r6
	  total += len;
57e12d98:	e08bb006 	add	fp, fp, r6
	  xyz.len -= len;
	  xyz.bufp += len;
57e12d9c:	e0836006 	add	r6, r3, r6
57e12da0:	e5846404 	str	r6, [r4, #1028]	; 0x404
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
57e12da4:	e594242c 	ldr	r2, [r4, #1068]	; 0x42c
57e12da8:	e35a0000 	cmp	sl, #0
57e12dac:	d3a03000 	movle	r3, #0
57e12db0:	c3a03001 	movgt	r3, #1
57e12db4:	e3520000 	cmp	r2, #0
57e12db8:	13a03000 	movne	r3, #0
57e12dbc:	e3530000 	cmp	r3, #0
57e12dc0:	1affff77 	bne	57e12ba4 <xyzModem_stream_read+0x24>
	  xyz.len -= len;
	  xyz.bufp += len;
	}
    }
  return total;
}
57e12dc4:	e1a0000b 	mov	r0, fp
57e12dc8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e12dcc:	57e47240 	.word	0x57e47240

57e12dd0 <xyzModem_stream_close>:

void
xyzModem_stream_close (int *err)
{
57e12dd0:	e92d4007 	push	{r0, r1, r2, lr}
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
57e12dd4:	e59f3034 	ldr	r3, [pc, #52]	; 57e12e10 <xyzModem_stream_close+0x40>

void
xyzModem_stream_close (int *err)
{
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
57e12dd8:	e59f1034 	ldr	r1, [pc, #52]	; 57e12e14 <xyzModem_stream_close+0x44>
57e12ddc:	e5932424 	ldr	r2, [r3, #1060]	; 0x424
57e12de0:	e593c428 	ldr	ip, [r3, #1064]	; 0x428
57e12de4:	e58d2000 	str	r2, [sp]
57e12de8:	e5932418 	ldr	r2, [r3, #1048]	; 0x418
57e12dec:	e35c0000 	cmp	ip, #0
57e12df0:	e58d2004 	str	r2, [sp, #4]
57e12df4:	e59f201c 	ldr	r2, [pc, #28]	; 57e12e18 <xyzModem_stream_close+0x48>
57e12df8:	e59f001c 	ldr	r0, [pc, #28]	; 57e12e1c <xyzModem_stream_close+0x4c>
57e12dfc:	11a01002 	movne	r1, r2
57e12e00:	e593241c 	ldr	r2, [r3, #1052]	; 0x41c
57e12e04:	e5933420 	ldr	r3, [r3, #1056]	; 0x420
57e12e08:	ebffd98f 	bl	57e0944c <printf>
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
     xyz.total_CAN, xyz.total_retries);
  ZM_DEBUG (zm_flush ());
}
57e12e0c:	e8bd800e 	pop	{r1, r2, r3, pc}
57e12e10:	57e47240 	.word	0x57e47240
57e12e14:	57e32fe5 	.word	0x57e32fe5
57e12e18:	57e31f54 	.word	0x57e31f54
57e12e1c:	57e32feb 	.word	0x57e32feb

57e12e20 <xyzModem_stream_terminate>:
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
  int c;

  if (abort)
57e12e20:	e3500000 	cmp	r0, #0

/* Need to be able to clean out the input buffer, so have to take the */
/* getc */
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
57e12e24:	e92d4010 	push	{r4, lr}
57e12e28:	e1a04001 	mov	r4, r1
  int c;

  if (abort)
57e12e2c:	0a000018 	beq	57e12e94 <xyzModem_stream_terminate+0x74>
    {
      ZM_DEBUG (zm_dprintf ("!!!! TRANSFER ABORT !!!!\n"));
      switch (xyz.mode)
57e12e30:	e59f4074 	ldr	r4, [pc, #116]	; 57e12eac <xyzModem_stream_terminate+0x8c>
57e12e34:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
57e12e38:	e2433001 	sub	r3, r3, #1
57e12e3c:	e3530001 	cmp	r3, #1
57e12e40:	88bd8010 	pophi	{r4, pc}
}

static void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
57e12e44:	e3a00018 	mov	r0, #24
57e12e48:	ebffd96b 	bl	57e093fc <putc>
57e12e4c:	e3a00018 	mov	r0, #24
57e12e50:	ebffd969 	bl	57e093fc <putc>
57e12e54:	e3a00018 	mov	r0, #24
57e12e58:	ebffd967 	bl	57e093fc <putc>
57e12e5c:	e3a00018 	mov	r0, #24
57e12e60:	ebffd965 	bl	57e093fc <putc>
57e12e64:	e3a00008 	mov	r0, #8
57e12e68:	ebffd963 	bl	57e093fc <putc>
57e12e6c:	e3a00008 	mov	r0, #8
57e12e70:	ebffd961 	bl	57e093fc <putc>
57e12e74:	e3a00008 	mov	r0, #8
57e12e78:	ebffd95f 	bl	57e093fc <putc>
57e12e7c:	e3a00008 	mov	r0, #8
57e12e80:	ebffd95d 	bl	57e093fc <putc>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  /* Now consume the rest of what's waiting on the line. */
	  ZM_DEBUG (zm_dprintf ("Flushing serial line.\n"));
	  xyzModem_flush ();
57e12e84:	ebfffe11 	bl	57e126d0 <xyzModem_flush>
	  xyz.at_eof = true;
57e12e88:	e3a03001 	mov	r3, #1
57e12e8c:	e584342c 	str	r3, [r4, #1068]	; 0x42c
57e12e90:	e8bd8010 	pop	{r4, pc}
       * previous received blocks. Since very few files are an exact multiple
       * of the transfer block size, there will almost always be some gunk here.
       * If we don't eat it now, RedBoot will think the user typed it.
       */
      ZM_DEBUG (zm_dprintf ("Trailing gunk:\n"));
      while ((c = (*getc) ()) > -1);
57e12e94:	e12fff34 	blx	r4
57e12e98:	e3500000 	cmp	r0, #0
57e12e9c:	aafffffc 	bge	57e12e94 <xyzModem_stream_terminate+0x74>
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
57e12ea0:	e59f0008 	ldr	r0, [pc, #8]	; 57e12eb0 <xyzModem_stream_terminate+0x90>
    }
}
57e12ea4:	e8bd4010 	pop	{r4, lr}
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
57e12ea8:	ea0045a2 	b	57e24538 <udelay>
57e12eac:	57e47240 	.word	0x57e47240
57e12eb0:	0003d090 	.word	0x0003d090

57e12eb4 <xyzModem_error>:
    }
}

char *
xyzModem_error (int err)
{
57e12eb4:	e2800008 	add	r0, r0, #8
57e12eb8:	e3500007 	cmp	r0, #7
57e12ebc:	959f3008 	ldrls	r3, [pc, #8]	; 57e12ecc <xyzModem_error+0x18>
57e12ec0:	859f0008 	ldrhi	r0, [pc, #8]	; 57e12ed0 <xyzModem_error+0x1c>
57e12ec4:	97930100 	ldrls	r0, [r3, r0, lsl #2]
      break;
    default:
      return "Unknown error";
      break;
    }
}
57e12ec8:	e12fff1e 	bx	lr
57e12ecc:	57e2c24c 	.word	0x57e2c24c
57e12ed0:	57e3302c 	.word	0x57e3302c

57e12ed4 <get_dev>:

DECLARE_GLOBAL_DATA_PTR;

#ifdef HAVE_BLOCK_DEVICE
block_dev_desc_t *get_dev(const char *ifname, int dev)
{
57e12ed4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
57e12ed8:	e2505000 	subs	r5, r0, #0

DECLARE_GLOBAL_DATA_PTR;

#ifdef HAVE_BLOCK_DEVICE
block_dev_desc_t *get_dev(const char *ifname, int dev)
{
57e12edc:	e1a07001 	mov	r7, r1
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
57e12ee0:	159f4054 	ldrne	r4, [pc, #84]	; 57e12f3c <get_dev+0x68>
57e12ee4:	0a000012 	beq	57e12f34 <get_dev+0x60>
57e12ee8:	ea00000c 	b	57e12f20 <get_dev+0x4c>
		reloc_get_dev = drvr->get_dev;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
57e12eec:	e1a0000a 	mov	r0, sl
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
		name = drvr->name;
		reloc_get_dev = drvr->get_dev;
57e12ef0:	e5146004 	ldr	r6, [r4, #-4]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
57e12ef4:	eb004455 	bl	57e24050 <strlen>
57e12ef8:	e1a0100a 	mov	r1, sl
57e12efc:	e1a02000 	mov	r2, r0
57e12f00:	e1a00005 	mov	r0, r5
57e12f04:	eb004432 	bl	57e23fd4 <strncmp>
57e12f08:	e3500000 	cmp	r0, #0
57e12f0c:	e2844008 	add	r4, r4, #8
57e12f10:	1a000002 	bne	57e12f20 <get_dev+0x4c>
			return reloc_get_dev(dev);
57e12f14:	e1a00007 	mov	r0, r7
57e12f18:	e12fff36 	blx	r6
57e12f1c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	name = drvr->name;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
57e12f20:	e514a008 	ldr	sl, [r4, #-8]
57e12f24:	e35a0000 	cmp	sl, #0
57e12f28:	1affffef 	bne	57e12eec <get_dev+0x18>
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
57e12f2c:	e1a0000a 	mov	r0, sl
57e12f30:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
		return NULL;
57e12f34:	e1a00005 	mov	r0, r5
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
}
57e12f38:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e12f3c:	57e2c274 	.word	0x57e2c274

57e12f40 <dev_print>:
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
57e12f40:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
57e12f44:	e5d0300b 	ldrb	r3, [r0, #11]
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
57e12f48:	e1a04000 	mov	r4, r0
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
57e12f4c:	e35300ff 	cmp	r3, #255	; 0xff
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
57e12f50:	e24dd014 	sub	sp, sp, #20
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
		puts ("not available\n");
57e12f54:	059f01c0 	ldreq	r0, [pc, #448]	; 57e1311c <dev_print+0x1dc>

void dev_print (block_dev_desc_t *dev_desc)
{
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
57e12f58:	0a00006c 	beq	57e13110 <dev_print+0x1d0>
		puts ("not available\n");
		return;
	}

	switch (dev_desc->if_type) {
57e12f5c:	e5941000 	ldr	r1, [r4]
57e12f60:	e3510008 	cmp	r1, #8
57e12f64:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
57e12f68:	ea00001e 	b	57e12fe8 <dev_print+0xa8>
57e12f6c:	57e12fe0 	.word	0x57e12fe0
57e12f70:	57e12fb8 	.word	0x57e12fb8
57e12f74:	57e12f90 	.word	0x57e12f90
57e12f78:	57e12fb8 	.word	0x57e12fb8
57e12f7c:	57e12fc0 	.word	0x57e12fc0
57e12f80:	57e12fd8 	.word	0x57e12fd8
57e12f84:	57e12fc0 	.word	0x57e12fc0
57e12f88:	57e12fc0 	.word	0x57e12fc0
57e12f8c:	57e12fb8 	.word	0x57e12fb8
	case IF_TYPE_SCSI:
		printf ("(%d:%d) Vendor: %s Prod.: %s Rev: %s\n",
57e12f90:	e2843041 	add	r3, r4, #65	; 0x41
57e12f94:	e5d41009 	ldrb	r1, [r4, #9]
57e12f98:	e5d4200a 	ldrb	r2, [r4, #10]
57e12f9c:	e58d3000 	str	r3, [sp]
57e12fa0:	e2843056 	add	r3, r4, #86	; 0x56
57e12fa4:	e58d3004 	str	r3, [sp, #4]
57e12fa8:	e59f0170 	ldr	r0, [pc, #368]	; 57e13120 <dev_print+0x1e0>
57e12fac:	e2843018 	add	r3, r4, #24
57e12fb0:	ebffd925 	bl	57e0944c <printf>
			dev_desc->target,dev_desc->lun,
			dev_desc->vendor,
			dev_desc->product,
			dev_desc->revision);
		break;
57e12fb4:	ea00000f 	b	57e12ff8 <dev_print+0xb8>
	case IF_TYPE_ATAPI:
	case IF_TYPE_IDE:
	case IF_TYPE_SATA:
		printf ("Model: %s Firm: %s Ser#: %s\n",
57e12fb8:	e59f0164 	ldr	r0, [pc, #356]	; 57e13124 <dev_print+0x1e4>
57e12fbc:	ea000000 	b	57e12fc4 <dev_print+0x84>
			dev_desc->product);
		break;
	case IF_TYPE_SD:
	case IF_TYPE_MMC:
	case IF_TYPE_USB:
		printf ("Vendor: %s Rev: %s Prod: %s\n",
57e12fc0:	e59f0160 	ldr	r0, [pc, #352]	; 57e13128 <dev_print+0x1e8>
57e12fc4:	e2841018 	add	r1, r4, #24
57e12fc8:	e2842056 	add	r2, r4, #86	; 0x56
57e12fcc:	e2843041 	add	r3, r4, #65	; 0x41
57e12fd0:	ebffd91d 	bl	57e0944c <printf>
			dev_desc->vendor,
			dev_desc->revision,
			dev_desc->product);
		break;
57e12fd4:	ea000007 	b	57e12ff8 <dev_print+0xb8>
	case IF_TYPE_DOC:
		puts("device type DOC\n");
57e12fd8:	e59f014c 	ldr	r0, [pc, #332]	; 57e1312c <dev_print+0x1ec>
57e12fdc:	ea00004b 	b	57e13110 <dev_print+0x1d0>
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
57e12fe0:	e59f0148 	ldr	r0, [pc, #328]	; 57e13130 <dev_print+0x1f0>
57e12fe4:	ea000049 	b	57e13110 <dev_print+0x1d0>
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
57e12fe8:	e59f0144 	ldr	r0, [pc, #324]	; 57e13134 <dev_print+0x1f4>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
57e12fec:	e28dd014 	add	sp, sp, #20
57e12ff0:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
57e12ff4:	eaffd914 	b	57e0944c <printf>
		return;
	}
	puts ("            Type: ");
57e12ff8:	e59f0138 	ldr	r0, [pc, #312]	; 57e13138 <dev_print+0x1f8>
57e12ffc:	ebffd908 	bl	57e09424 <puts>
	if (dev_desc->removable)
57e13000:	e5d4300c 	ldrb	r3, [r4, #12]
57e13004:	e3530000 	cmp	r3, #0
57e13008:	0a000001 	beq	57e13014 <dev_print+0xd4>
		puts ("Removable ");
57e1300c:	e59f0128 	ldr	r0, [pc, #296]	; 57e1313c <dev_print+0x1fc>
57e13010:	ebffd903 	bl	57e09424 <puts>
	switch (dev_desc->type & 0x1F) {
57e13014:	e5d4100b 	ldrb	r1, [r4, #11]
57e13018:	e201101f 	and	r1, r1, #31
57e1301c:	e3510007 	cmp	r1, #7
57e13020:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
57e13024:	ea000010 	b	57e1306c <dev_print+0x12c>
57e13028:	57e13048 	.word	0x57e13048
57e1302c:	57e13064 	.word	0x57e13064
57e13030:	57e1306c 	.word	0x57e1306c
57e13034:	57e1306c 	.word	0x57e1306c
57e13038:	57e1306c 	.word	0x57e1306c
57e1303c:	57e13050 	.word	0x57e13050
57e13040:	57e1306c 	.word	0x57e1306c
57e13044:	57e1305c 	.word	0x57e1305c
	case DEV_TYPE_HARDDISK:
		puts ("Hard Disk");
57e13048:	e59f00f0 	ldr	r0, [pc, #240]	; 57e13140 <dev_print+0x200>
57e1304c:	ea000000 	b	57e13054 <dev_print+0x114>
		break;
	case DEV_TYPE_CDROM:
		puts ("CD ROM");
57e13050:	e59f00ec 	ldr	r0, [pc, #236]	; 57e13144 <dev_print+0x204>
57e13054:	ebffd8f2 	bl	57e09424 <puts>
		break;
57e13058:	ea000005 	b	57e13074 <dev_print+0x134>
	case DEV_TYPE_OPDISK:
		puts ("Optical Device");
57e1305c:	e59f00e4 	ldr	r0, [pc, #228]	; 57e13148 <dev_print+0x208>
57e13060:	eafffffb 	b	57e13054 <dev_print+0x114>
		break;
	case DEV_TYPE_TAPE:
		puts ("Tape");
57e13064:	e59f00e0 	ldr	r0, [pc, #224]	; 57e1314c <dev_print+0x20c>
57e13068:	eafffff9 	b	57e13054 <dev_print+0x114>
		break;
	default:
		printf ("# %02X #", dev_desc->type & 0x1F);
57e1306c:	e59f00dc 	ldr	r0, [pc, #220]	; 57e13150 <dev_print+0x210>
57e13070:	ebffd8f5 	bl	57e0944c <printf>
		break;
	}
	puts ("\n");
57e13074:	e59f00d8 	ldr	r0, [pc, #216]	; 57e13154 <dev_print+0x214>
57e13078:	ebffd8e9 	bl	57e09424 <puts>
	if (dev_desc->lba > 0L && dev_desc->blksz > 0L) {
57e1307c:	e5947010 	ldr	r7, [r4, #16]
57e13080:	e3570000 	cmp	r7, #0
57e13084:	0a000020 	beq	57e1310c <dev_print+0x1cc>
57e13088:	e5946014 	ldr	r6, [r4, #20]
57e1308c:	e3560000 	cmp	r6, #0
57e13090:	0a00001d 	beq	57e1310c <dev_print+0x1cc>
		ulong mb, mb_quot, mb_rem, gb, gb_quot, gb_rem;
		lbaint_t lba;

		lba = dev_desc->lba;

		lba512 = (lba * (dev_desc->blksz/512));
57e13094:	e1a024a6 	lsr	r2, r6, #9
57e13098:	e0020297 	mul	r2, r7, r2
static lba512_t lba512_muldiv (lba512_t block_count, lba512_t mul_by, lba512_t div_by)
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
57e1309c:	e1a035a2 	lsr	r3, r2, #11
	bc_rem  = block_count - div_by * bc_quot;
57e130a0:	e1a05583 	lsl	r5, r3, #11
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
57e130a4:	e3a0400a 	mov	r4, #10
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
	bc_rem  = block_count - div_by * bc_quot;
57e130a8:	e0655002 	rsb	r5, r5, r2
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
57e130ac:	e0030394 	mul	r3, r4, r3
57e130b0:	e0050594 	mul	r5, r4, r5
57e130b4:	e08355a5 	add	r5, r3, r5, lsr #11

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
57e130b8:	e1a01004 	mov	r1, r4
57e130bc:	e1a00005 	mov	r0, r5
57e130c0:	eb0061ba 	bl	57e2b7b0 <__udivsi3>
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
57e130c4:	e1a09435 	lsr	r9, r5, r4

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
57e130c8:	e1a0a000 	mov	sl, r0
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
57e130cc:	e1a01004 	mov	r1, r4
57e130d0:	e1a00009 	mov	r0, r9
57e130d4:	eb0061b5 	bl	57e2b7b0 <__udivsi3>
		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
		mb_rem	= mb - (10 * mb_quot);
57e130d8:	e0020a94 	mul	r2, r4, sl

		gb = mb / 1024;
		gb_quot	= gb / 10;
		gb_rem	= gb - (10 * gb_quot);
57e130dc:	e0040490 	mul	r4, r0, r4

		mb_quot	= mb / 10;
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
57e130e0:	e1a03000 	mov	r3, r0
		gb_rem	= gb - (10 * gb_quot);
57e130e4:	e0649009 	rsb	r9, r4, r9
			mb_quot, mb_rem,
			gb_quot, gb_rem,
			lba,
			dev_desc->blksz);
#else
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
57e130e8:	e1a0100a 	mov	r1, sl
57e130ec:	e0622005 	rsb	r2, r2, r5
57e130f0:	e59f0060 	ldr	r0, [pc, #96]	; 57e13158 <dev_print+0x218>
57e130f4:	e58d9000 	str	r9, [sp]
57e130f8:	e58d7004 	str	r7, [sp, #4]
57e130fc:	e58d6008 	str	r6, [sp, #8]
57e13100:	ebffd8d1 	bl	57e0944c <printf>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
57e13104:	e28dd014 	add	sp, sp, #20
57e13108:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
57e1310c:	e59f0048 	ldr	r0, [pc, #72]	; 57e1315c <dev_print+0x21c>
	}
}
57e13110:	e28dd014 	add	sp, sp, #20
57e13114:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
57e13118:	eaffd8c1 	b	57e09424 <puts>
57e1311c:	57e33202 	.word	0x57e33202
57e13120:	57e330c4 	.word	0x57e330c4
57e13124:	57e330ea 	.word	0x57e330ea
57e13128:	57e33107 	.word	0x57e33107
57e1312c:	57e33124 	.word	0x57e33124
57e13130:	57e33135 	.word	0x57e33135
57e13134:	57e3314a 	.word	0x57e3314a
57e13138:	57e33165 	.word	0x57e33165
57e1313c:	57e33178 	.word	0x57e33178
57e13140:	57e33183 	.word	0x57e33183
57e13144:	57e3318d 	.word	0x57e3318d
57e13148:	57e33194 	.word	0x57e33194
57e1314c:	57e331a3 	.word	0x57e331a3
57e13150:	57e331a8 	.word	0x57e331a8
57e13154:	57e32390 	.word	0x57e32390
57e13158:	57e331b1 	.word	0x57e331b1
57e1315c:	57e331ec 	.word	0x57e331ec

57e13160 <init_part>:
#endif

#ifdef HAVE_BLOCK_DEVICE

void init_part (block_dev_desc_t * dev_desc)
{
57e13160:	e92d4010 	push	{r4, lr}
57e13164:	e1a04000 	mov	r4, r0
		return;
	}
#endif

#ifdef CONFIG_DOS_PARTITION
	if (test_part_dos(dev_desc) == 0) {
57e13168:	eb000281 	bl	57e13b74 <test_part_dos>
57e1316c:	e3500000 	cmp	r0, #0
		dev_desc->part_type = PART_TYPE_DOS;
57e13170:	03a03002 	moveq	r3, #2
	if (test_part_amiga(dev_desc) == 0) {
	    dev_desc->part_type = PART_TYPE_AMIGA;
	    return;
	}
#endif
	dev_desc->part_type = PART_TYPE_UNKNOWN;
57e13174:	13a03000 	movne	r3, #0
57e13178:	e5c43008 	strb	r3, [r4, #8]
57e1317c:	e8bd8010 	pop	{r4, pc}

57e13180 <print_part>:
}

#endif /* any CONFIG_..._PARTITION */

void print_part (block_dev_desc_t * dev_desc)
{
57e13180:	e92d4010 	push	{r4, lr}

		switch (dev_desc->part_type) {
57e13184:	e5d03008 	ldrb	r3, [r0, #8]
}

#endif /* any CONFIG_..._PARTITION */

void print_part (block_dev_desc_t * dev_desc)
{
57e13188:	e1a04000 	mov	r4, r0

		switch (dev_desc->part_type) {
57e1318c:	e3530002 	cmp	r3, #2
57e13190:	1a000025 	bne	57e1322c <print_part+0xac>
	defined(CONFIG_AMIGA_PARTITION) || \
	defined(CONFIG_EFI_PARTITION)

static void print_part_header (const char *type, block_dev_desc_t * dev_desc)
{
	puts ("\nPartition Map for ");
57e13194:	e59f009c 	ldr	r0, [pc, #156]	; 57e13238 <print_part+0xb8>
57e13198:	ebffd8a1 	bl	57e09424 <puts>
	switch (dev_desc->if_type) {
57e1319c:	e5943000 	ldr	r3, [r4]
57e131a0:	e2433001 	sub	r3, r3, #1
57e131a4:	e3530007 	cmp	r3, #7
57e131a8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e131ac:	ea000015 	b	57e13208 <print_part+0x88>
57e131b0:	57e131d0 	.word	0x57e131d0
57e131b4:	57e131e0 	.word	0x57e131e0
57e131b8:	57e131e8 	.word	0x57e131e8
57e131bc:	57e131f0 	.word	0x57e131f0
57e131c0:	57e131f8 	.word	0x57e131f8
57e131c4:	57e13200 	.word	0x57e13200
57e131c8:	57e13208 	.word	0x57e13208
57e131cc:	57e131d8 	.word	0x57e131d8
	case IF_TYPE_IDE:
		puts ("IDE");
57e131d0:	e59f0064 	ldr	r0, [pc, #100]	; 57e1323c <print_part+0xbc>
57e131d4:	ea00000c 	b	57e1320c <print_part+0x8c>
		break;
	case IF_TYPE_SATA:
		puts ("SATA");
57e131d8:	e59f0060 	ldr	r0, [pc, #96]	; 57e13240 <print_part+0xc0>
57e131dc:	ea00000a 	b	57e1320c <print_part+0x8c>
		break;
	case IF_TYPE_SCSI:
		puts ("SCSI");
57e131e0:	e59f005c 	ldr	r0, [pc, #92]	; 57e13244 <print_part+0xc4>
57e131e4:	ea000008 	b	57e1320c <print_part+0x8c>
		break;
	case IF_TYPE_ATAPI:
		puts ("ATAPI");
57e131e8:	e59f0058 	ldr	r0, [pc, #88]	; 57e13248 <print_part+0xc8>
57e131ec:	ea000006 	b	57e1320c <print_part+0x8c>
		break;
	case IF_TYPE_USB:
		puts ("USB");
57e131f0:	e59f0054 	ldr	r0, [pc, #84]	; 57e1324c <print_part+0xcc>
57e131f4:	ea000004 	b	57e1320c <print_part+0x8c>
		break;
	case IF_TYPE_DOC:
		puts ("DOC");
57e131f8:	e59f0050 	ldr	r0, [pc, #80]	; 57e13250 <print_part+0xd0>
57e131fc:	ea000002 	b	57e1320c <print_part+0x8c>
		break;
	case IF_TYPE_MMC:
		puts ("MMC");
57e13200:	e59f004c 	ldr	r0, [pc, #76]	; 57e13254 <print_part+0xd4>
57e13204:	ea000000 	b	57e1320c <print_part+0x8c>
		break;
	default:
		puts ("UNKNOWN");
57e13208:	e59f0048 	ldr	r0, [pc, #72]	; 57e13258 <print_part+0xd8>
57e1320c:	ebffd884 	bl	57e09424 <puts>
		break;
	}
	printf (" device %d  --   Partition Type: %s\n\n",
57e13210:	e5941004 	ldr	r1, [r4, #4]
57e13214:	e59f2040 	ldr	r2, [pc, #64]	; 57e1325c <print_part+0xdc>
57e13218:	e59f0040 	ldr	r0, [pc, #64]	; 57e13260 <print_part+0xe0>
57e1321c:	ebffd88a 	bl	57e0944c <printf>
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
57e13220:	e1a00004 	mov	r0, r4
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
}
57e13224:	e8bd4010 	pop	{r4, lr}
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
57e13228:	ea000269 	b	57e13bd4 <print_part_dos>
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
57e1322c:	e59f0030 	ldr	r0, [pc, #48]	; 57e13264 <print_part+0xe4>
}
57e13230:	e8bd4010 	pop	{r4, lr}
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
57e13234:	eaffd87a 	b	57e09424 <puts>
57e13238:	57e33211 	.word	0x57e33211
57e1323c:	57e33225 	.word	0x57e33225
57e13240:	57e33229 	.word	0x57e33229
57e13244:	57e31515 	.word	0x57e31515
57e13248:	57e3322e 	.word	0x57e3322e
57e1324c:	57e33234 	.word	0x57e33234
57e13250:	57e33238 	.word	0x57e33238
57e13254:	57e3323c 	.word	0x57e3323c
57e13258:	57e33240 	.word	0x57e33240
57e1325c:	57e3326e 	.word	0x57e3326e
57e13260:	57e33248 	.word	0x57e33248
57e13264:	57e33272 	.word	0x57e33272

57e13268 <get_partition_info>:

#endif /* HAVE_BLOCK_DEVICE */

int get_partition_info(block_dev_desc_t *dev_desc, int part
					, disk_partition_t *info)
{
57e13268:	e92d4008 	push	{r3, lr}
#ifdef CONFIG_PARTITION_UUIDS
	/* The common case is no UUID support */
	info->uuid[0] = 0;
#endif

	switch (dev_desc->part_type) {
57e1326c:	e5d03008 	ldrb	r3, [r0, #8]
57e13270:	e3530002 	cmp	r3, #2
57e13274:	1a000003 	bne	57e13288 <get_partition_info+0x20>
		break;
#endif

#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		if (get_partition_info_dos(dev_desc, part, info) == 0) {
57e13278:	eb000261 	bl	57e13c04 <get_partition_info_dos>
57e1327c:	e3500000 	cmp	r0, #0
	default:
		break;
	}
#endif /* HAVE_BLOCK_DEVICE */

	return -1;
57e13280:	13e00000 	mvnne	r0, #0
57e13284:	e8bd8008 	pop	{r3, pc}
57e13288:	e3e00000 	mvn	r0, #0
}
57e1328c:	e8bd8008 	pop	{r3, pc}

57e13290 <get_device>:

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
57e13290:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
57e13294:	e1a05000 	mov	r5, r0
57e13298:	e1a04001 	mov	r4, r1
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
57e1329c:	e1a00001 	mov	r0, r1
	return -1;
}

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
57e132a0:	e1a06002 	mov	r6, r2
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
57e132a4:	e28d1004 	add	r1, sp, #4
57e132a8:	e3a02010 	mov	r2, #16
57e132ac:	eb00477c 	bl	57e250a4 <simple_strtoul>
	if (*ep) {
57e132b0:	e59d3004 	ldr	r3, [sp, #4]
57e132b4:	e5d33000 	ldrb	r3, [r3]
57e132b8:	e3530000 	cmp	r3, #0
		printf("** Bad device specification %s %s **\n",
57e132bc:	159f0044 	ldrne	r0, [pc, #68]	; 57e13308 <get_device+0x78>
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
	if (*ep) {
57e132c0:	1a00000a 	bne	57e132f0 <get_device+0x60>
	       block_dev_desc_t **dev_desc)
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
57e132c4:	e1a07000 	mov	r7, r0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
57e132c8:	e1a01007 	mov	r1, r7
57e132cc:	e1a00005 	mov	r0, r5
57e132d0:	ebfffeff 	bl	57e12ed4 <get_dev>
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
57e132d4:	e3500000 	cmp	r0, #0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
57e132d8:	e5860000 	str	r0, [r6]
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
57e132dc:	0a000002 	beq	57e132ec <get_device+0x5c>
57e132e0:	e5d0300b 	ldrb	r3, [r0, #11]
57e132e4:	e35300ff 	cmp	r3, #255	; 0xff
57e132e8:	1a000004 	bne	57e13300 <get_device+0x70>
		printf("** Bad device %s %s **\n", ifname, dev_str);
57e132ec:	e59f0018 	ldr	r0, [pc, #24]	; 57e1330c <get_device+0x7c>
57e132f0:	e1a01005 	mov	r1, r5
57e132f4:	e1a02004 	mov	r2, r4
57e132f8:	ebffd853 	bl	57e0944c <printf>
		return -1;
57e132fc:	e3e07000 	mvn	r7, #0
	}

	return dev;
}
57e13300:	e1a00007 	mov	r0, r7
57e13304:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
57e13308:	57e3328e 	.word	0x57e3328e
57e1330c:	57e332b4 	.word	0x57e332b4

57e13310 <get_device_and_partition>:
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
57e13310:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
57e13314:	e2516000 	subs	r6, r1, #0
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
57e13318:	e24dd058 	sub	sp, sp, #88	; 0x58
57e1331c:	e1a09000 	mov	r9, r0
57e13320:	e1a0b002 	mov	fp, r2
57e13324:	e1a05003 	mov	r5, r3
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
57e13328:	0a000008 	beq	57e13350 <get_device_and_partition+0x40>
57e1332c:	e1a00006 	mov	r0, r6
57e13330:	eb004346 	bl	57e24050 <strlen>
57e13334:	e3500000 	cmp	r0, #0
57e13338:	0a000004 	beq	57e13350 <get_device_and_partition+0x40>
	    !strcmp(dev_part_str, "-"))
57e1333c:	e1a00006 	mov	r0, r6
57e13340:	e59f1298 	ldr	r1, [pc, #664]	; 57e135e0 <get_device_and_partition+0x2d0>
57e13344:	eb004316 	bl	57e23fa4 <strcmp>
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
57e13348:	e3500000 	cmp	r0, #0
57e1334c:	1a000007 	bne	57e13370 <get_device_and_partition+0x60>
	    !strcmp(dev_part_str, "-"))
		dev_part_str = getenv("bootdevice");
57e13350:	e59f028c 	ldr	r0, [pc, #652]	; 57e135e4 <get_device_and_partition+0x2d4>
57e13354:	ebffd0e3 	bl	57e076e8 <getenv>

	/* If still no dev_part_str, it's an error */
	if (!dev_part_str) {
57e13358:	e2506000 	subs	r6, r0, #0
57e1335c:	1a000003 	bne	57e13370 <get_device_and_partition+0x60>
		printf("** No device specified **\n");
57e13360:	e59f0280 	ldr	r0, [pc, #640]	; 57e135e8 <get_device_and_partition+0x2d8>
57e13364:	ebffd838 	bl	57e0944c <printf>
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
57e13368:	e1a07006 	mov	r7, r6
57e1336c:	ea000095 	b	57e135c8 <get_device_and_partition+0x2b8>
		printf("** No device specified **\n");
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
57e13370:	e1a00006 	mov	r0, r6
57e13374:	e3a0103a 	mov	r1, #58	; 0x3a
57e13378:	eb004327 	bl	57e2401c <strchr>
	if (part_str) {
57e1337c:	e2504000 	subs	r4, r0, #0
57e13380:	01a0a006 	moveq	sl, r6
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
57e13384:	01a07004 	moveq	r7, r4
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
57e13388:	0a000007 	beq	57e133ac <get_device_and_partition+0x9c>
		dup_str = strdup(dev_part_str);
57e1338c:	e1a00006 	mov	r0, r6
57e13390:	eb00434e 	bl	57e240d0 <strdup>
		dup_str[part_str - dev_part_str] = 0;
57e13394:	e0663004 	rsb	r3, r6, r4
57e13398:	e3a02000 	mov	r2, #0
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
57e1339c:	e1a07000 	mov	r7, r0
		dup_str[part_str - dev_part_str] = 0;
57e133a0:	e7c02003 	strb	r2, [r0, r3]
		dev_str = dup_str;
		part_str++;
57e133a4:	e2844001 	add	r4, r4, #1
	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
		dup_str[part_str - dev_part_str] = 0;
		dev_str = dup_str;
57e133a8:	e1a0a000 	mov	sl, r0
	} else {
		dev_str = dev_part_str;
	}

	/* Look up the device */
	dev = get_device(ifname, dev_str, dev_desc);
57e133ac:	e1a00009 	mov	r0, r9
57e133b0:	e1a0100a 	mov	r1, sl
57e133b4:	e1a0200b 	mov	r2, fp
57e133b8:	ebffffb4 	bl	57e13290 <get_device>
	if (dev < 0)
57e133bc:	e3500000 	cmp	r0, #0
57e133c0:	ba000080 	blt	57e135c8 <get_device_and_partition+0x2b8>
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
57e133c4:	e3540000 	cmp	r4, #0
57e133c8:	0a000018 	beq	57e13430 <get_device_and_partition+0x120>
57e133cc:	e5d43000 	ldrb	r3, [r4]
57e133d0:	e3530000 	cmp	r3, #0
57e133d4:	0a000015 	beq	57e13430 <get_device_and_partition+0x120>
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
57e133d8:	e1a00004 	mov	r0, r4
57e133dc:	e59f1208 	ldr	r1, [pc, #520]	; 57e135ec <get_device_and_partition+0x2dc>
57e133e0:	eb0042ef 	bl	57e23fa4 <strcmp>
57e133e4:	e3500000 	cmp	r0, #0
		part = PART_AUTO;
57e133e8:	03e04000 	mvneq	r4, #0
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
57e133ec:	0a000010 	beq	57e13434 <get_device_and_partition+0x124>
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
57e133f0:	e1a00004 	mov	r0, r4
57e133f4:	e28d1054 	add	r1, sp, #84	; 0x54
57e133f8:	e3a02010 	mov	r2, #16
57e133fc:	eb004728 	bl	57e250a4 <simple_strtoul>
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
57e13400:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
57e13404:	e5d33000 	ldrb	r3, [r3]
57e13408:	e3530000 	cmp	r3, #0
57e1340c:	1a000003 	bne	57e13420 <get_device_and_partition+0x110>
57e13410:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
57e13414:	e1a04000 	mov	r4, r0
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
57e13418:	e1902002 	orrs	r2, r0, r2
57e1341c:	1a000004 	bne	57e13434 <get_device_and_partition+0x124>
			printf("** Bad partition specification %s %s **\n",
57e13420:	e59f01c8 	ldr	r0, [pc, #456]	; 57e135f0 <get_device_and_partition+0x2e0>
57e13424:	e1a01009 	mov	r1, r9
57e13428:	e1a02006 	mov	r2, r6
57e1342c:	ea00000d 	b	57e13468 <get_device_and_partition+0x158>
	if (dev < 0)
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
57e13430:	e3e04001 	mvn	r4, #1

	/*
	 * No partition table on device,
	 * or user requested partition 0 (entire device).
	 */
	if (((*dev_desc)->part_type == PART_TYPE_UNKNOWN) ||
57e13434:	e59b0000 	ldr	r0, [fp]
57e13438:	e5d03008 	ldrb	r3, [r0, #8]
57e1343c:	e3530000 	cmp	r3, #0
57e13440:	13540000 	cmpne	r4, #0
57e13444:	13a03000 	movne	r3, #0
57e13448:	03a03001 	moveq	r3, #1
57e1344c:	1a00001b 	bne	57e134c0 <get_device_and_partition+0x1b0>
	    (part == 0)) {
		if (!(*dev_desc)->lba) {
57e13450:	e5903010 	ldr	r3, [r0, #16]
57e13454:	e3530000 	cmp	r3, #0
57e13458:	1a000004 	bne	57e13470 <get_device_and_partition+0x160>
			printf("** Bad device size - %s %s **\n", ifname,
57e1345c:	e59f0190 	ldr	r0, [pc, #400]	; 57e135f4 <get_device_and_partition+0x2e4>
57e13460:	e1a01009 	mov	r1, r9
57e13464:	e1a0200a 	mov	r2, sl
57e13468:	ebffd7f7 	bl	57e0944c <printf>
57e1346c:	ea000055 	b	57e135c8 <get_device_and_partition+0x2b8>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
57e13470:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
57e13474:	e2726001 	rsbs	r6, r2, #1
57e13478:	33a06000 	movcc	r6, #0
57e1347c:	e3540000 	cmp	r4, #0
57e13480:	c3866001 	orrgt	r6, r6, #1
57e13484:	e3560000 	cmp	r6, #0
			printf("** No partition table - %s %s **\n", ifname,
57e13488:	159f0168 	ldrne	r0, [pc, #360]	; 57e135f8 <get_device_and_partition+0x2e8>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
57e1348c:	1afffff3 	bne	57e13460 <get_device_and_partition+0x150>
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
		info->size = (*dev_desc)->lba;
57e13490:	e5853004 	str	r3, [r5, #4]
		info->blksz = (*dev_desc)->blksz;
57e13494:	e5903014 	ldr	r3, [r0, #20]
			printf("** No partition table - %s %s **\n", ifname,
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
57e13498:	e5856000 	str	r6, [r5]
		info->size = (*dev_desc)->lba;
		info->blksz = (*dev_desc)->blksz;
57e1349c:	e5853008 	str	r3, [r5, #8]
		info->bootable = 0;
57e134a0:	e585604c 	str	r6, [r5, #76]	; 0x4c
		strcpy((char *)info->type, BOOT_PART_TYPE);
57e134a4:	e285002c 	add	r0, r5, #44	; 0x2c
57e134a8:	e59f114c 	ldr	r1, [pc, #332]	; 57e135fc <get_device_and_partition+0x2ec>
57e134ac:	eb00428b 	bl	57e23ee0 <strcpy>
		strcpy((char *)info->name, "Whole Disk");
57e134b0:	e285000c 	add	r0, r5, #12
57e134b4:	e59f1144 	ldr	r1, [pc, #324]	; 57e13600 <get_device_and_partition+0x2f0>
57e134b8:	eb004288 	bl	57e23ee0 <strcpy>
#ifdef CONFIG_PARTITION_UUIDS
		info->uuid[0] = 0;
#endif

		ret = 0;
		goto cleanup;
57e134bc:	ea000042 	b	57e135cc <get_device_and_partition+0x2bc>

	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
57e134c0:	e3740002 	cmn	r4, #2
57e134c4:	0a000005 	beq	57e134e0 <get_device_and_partition+0x1d0>

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
57e134c8:	e3740001 	cmn	r4, #1
57e134cc:	01a04003 	moveq	r4, r3
57e134d0:	03a06001 	moveq	r6, #1
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
				tmpinfo = *info;
57e134d4:	028da004 	addeq	sl, sp, #4

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
57e134d8:	0a00000a 	beq	57e13508 <get_device_and_partition+0x1f8>
57e134dc:	ea000000 	b	57e134e4 <get_device_and_partition+0x1d4>
	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
		part = 1;
57e134e0:	e3a04001 	mov	r4, #1
	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
		ret = get_partition_info(*dev_desc, part, info);
57e134e4:	e1a01004 	mov	r1, r4
57e134e8:	e1a02005 	mov	r2, r5
57e134ec:	ebffff5d 	bl	57e13268 <get_partition_info>
		if (ret) {
57e134f0:	e2506000 	subs	r6, r0, #0
57e134f4:	0a000028 	beq	57e1359c <get_device_and_partition+0x28c>
			printf("** Invalid partition %d **\n", part);
57e134f8:	e1a01004 	mov	r1, r4
57e134fc:	e59f0100 	ldr	r0, [pc, #256]	; 57e13604 <get_device_and_partition+0x2f4>
57e13500:	ebffd7d1 	bl	57e0944c <printf>
			goto cleanup;
57e13504:	ea000030 	b	57e135cc <get_device_and_partition+0x2bc>
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
			ret = get_partition_info(*dev_desc, p, info);
57e13508:	e59b0000 	ldr	r0, [fp]
57e1350c:	e1a01006 	mov	r1, r6
57e13510:	e1a02005 	mov	r2, r5
57e13514:	ebffff53 	bl	57e13268 <get_partition_info>
			if (ret)
57e13518:	e3500000 	cmp	r0, #0
57e1351c:	1a000011 	bne	57e13568 <get_device_and_partition+0x258>

			/*
			 * First valid partition, or new better partition?
			 * If so, save partition ID.
			 */
			if (!part || info->bootable)
57e13520:	e3540000 	cmp	r4, #0
57e13524:	01a04006 	moveq	r4, r6
57e13528:	0a000002 	beq	57e13538 <get_device_and_partition+0x228>
57e1352c:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
57e13530:	e3530000 	cmp	r3, #0
57e13534:	11a04006 	movne	r4, r6
				part = p;

			/* Best possible partition? Stop searching. */
			if (info->bootable)
57e13538:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
57e1353c:	e3530000 	cmp	r3, #0
57e13540:	0a000002 	beq	57e13550 <get_device_and_partition+0x240>
		if (part) {
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
57e13544:	e3560011 	cmp	r6, #17
57e13548:	1a000013 	bne	57e1359c <get_device_and_partition+0x28c>
57e1354c:	ea00000a 	b	57e1357c <get_device_and_partition+0x26c>
			/*
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
57e13550:	e1540006 	cmp	r4, r6
57e13554:	1a000003 	bne	57e13568 <get_device_and_partition+0x258>
				tmpinfo = *info;
57e13558:	e1a0000a 	mov	r0, sl
57e1355c:	e1a01005 	mov	r1, r5
57e13560:	e3a02050 	mov	r2, #80	; 0x50
57e13564:	eb004368 	bl	57e2430c <memcpy>
		/*
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
57e13568:	e2866001 	add	r6, r6, #1
57e1356c:	e3560011 	cmp	r6, #17
57e13570:	1affffe4 	bne	57e13508 <get_device_and_partition+0x1f8>
			 */
			if (part == p)
				tmpinfo = *info;
		}
		/* If we found any acceptable partition */
		if (part) {
57e13574:	e3540000 	cmp	r4, #0
57e13578:	0a000004 	beq	57e13590 <get_device_and_partition+0x280>
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
				*info = tmpinfo;
57e1357c:	e1a00005 	mov	r0, r5
57e13580:	e28d1004 	add	r1, sp, #4
57e13584:	e3a02050 	mov	r2, #80	; 0x50
57e13588:	eb00435f 	bl	57e2430c <memcpy>
57e1358c:	ea000002 	b	57e1359c <get_device_and_partition+0x28c>
		} else {
			printf("** No valid partitions found **\n");
57e13590:	e59f0070 	ldr	r0, [pc, #112]	; 57e13608 <get_device_and_partition+0x2f8>
57e13594:	ebffd7ac 	bl	57e0944c <printf>
57e13598:	ea00000a 	b	57e135c8 <get_device_and_partition+0x2b8>
			ret = -1;
			goto cleanup;
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
57e1359c:	e285502c 	add	r5, r5, #44	; 0x2c
57e135a0:	e1a00005 	mov	r0, r5
57e135a4:	e59f1050 	ldr	r1, [pc, #80]	; 57e135fc <get_device_and_partition+0x2ec>
57e135a8:	e3a02020 	mov	r2, #32
57e135ac:	eb004288 	bl	57e23fd4 <strncmp>
57e135b0:	e3500000 	cmp	r0, #0
			info->type);
		ret  = -1;
		goto cleanup;
	}

	ret = part;
57e135b4:	01a06004 	moveq	r6, r4
			printf("** No valid partitions found **\n");
			ret = -1;
			goto cleanup;
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
57e135b8:	0a000003 	beq	57e135cc <get_device_and_partition+0x2bc>
		printf("** Invalid partition type \"%.32s\""
57e135bc:	e59f0048 	ldr	r0, [pc, #72]	; 57e1360c <get_device_and_partition+0x2fc>
57e135c0:	e1a01005 	mov	r1, r5
57e135c4:	ebffd7a0 	bl	57e0944c <printf>
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
57e135c8:	e3e06000 	mvn	r6, #0

	ret = part;
	goto cleanup;

cleanup:
	free(dup_str);
57e135cc:	e1a00007 	mov	r0, r7
57e135d0:	ebffd8f1 	bl	57e0999c <free>
	return ret;
}
57e135d4:	e1a00006 	mov	r0, r6
57e135d8:	e28dd058 	add	sp, sp, #88	; 0x58
57e135dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e135e0:	57e3155e 	.word	0x57e3155e
57e135e4:	57e306f4 	.word	0x57e306f4
57e135e8:	57e332cc 	.word	0x57e332cc
57e135ec:	57e332e7 	.word	0x57e332e7
57e135f0:	57e332ec 	.word	0x57e332ec
57e135f4:	57e33315 	.word	0x57e33315
57e135f8:	57e33334 	.word	0x57e33334
57e135fc:	57e32a0e 	.word	0x57e32a0e
57e13600:	57e33356 	.word	0x57e33356
57e13604:	57e33361 	.word	0x57e33361
57e13608:	57e3337d 	.word	0x57e3337d
57e1360c:	57e3339e 	.word	0x57e3339e

57e13610 <test_block_type>:
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
57e13610:	e92d4010 	push	{r4, lr}
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
57e13614:	e5d031fe 	ldrb	r3, [r0, #510]	; 0x1fe
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
57e13618:	e1a04000 	mov	r4, r0
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
57e1361c:	e3530055 	cmp	r3, #85	; 0x55
57e13620:	1a00000f 	bne	57e13664 <test_block_type+0x54>
57e13624:	e5d031ff 	ldrb	r3, [r0, #511]	; 0x1ff
57e13628:	e35300aa 	cmp	r3, #170	; 0xaa
57e1362c:	1a00000c 	bne	57e13664 <test_block_type+0x54>
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
57e13630:	e2800036 	add	r0, r0, #54	; 0x36
57e13634:	e59f1038 	ldr	r1, [pc, #56]	; 57e13674 <test_block_type+0x64>
57e13638:	e3a02003 	mov	r2, #3
57e1363c:	eb004264 	bl	57e23fd4 <strncmp>
57e13640:	e3500000 	cmp	r0, #0
57e13644:	0a000008 	beq	57e1366c <test_block_type+0x5c>
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
57e13648:	e2840052 	add	r0, r4, #82	; 0x52
57e1364c:	e59f1024 	ldr	r1, [pc, #36]	; 57e13678 <test_block_type+0x68>
57e13650:	e3a02005 	mov	r2, #5
57e13654:	eb00425e 	bl	57e23fd4 <strncmp>

static int test_block_type(unsigned char *buffer)
{
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
57e13658:	e2700001 	rsbs	r0, r0, #1
57e1365c:	33a00000 	movcc	r0, #0
57e13660:	e8bd8010 	pop	{r4, pc}
57e13664:	e3e00000 	mvn	r0, #0
57e13668:	e8bd8010 	pop	{r4, pc}
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
		return DOS_PBR; /* is PBR */
57e1366c:	e3a00001 	mov	r0, #1
	}
	return DOS_MBR;	    /* Is MBR */
}
57e13670:	e8bd8010 	pop	{r4, pc}
57e13674:	57e333d3 	.word	0x57e333d3
57e13678:	57e333d7 	.word	0x57e333d7

57e1367c <print_partition_extended>:
/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended(block_dev_desc_t *dev_desc,
				     int ext_part_sector, int relative,
				     int part_num, unsigned int disksig)
{
57e1367c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e13680:	e28db01c 	add	fp, sp, #28
57e13684:	e24dd030 	sub	sp, sp, #48	; 0x30
57e13688:	e1a0a003 	mov	sl, r3
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e1368c:	e5903014 	ldr	r3, [r0, #20]
/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended(block_dev_desc_t *dev_desc,
				     int ext_part_sector, int relative,
				     int part_num, unsigned int disksig)
{
57e13690:	e50b2020 	str	r2, [fp, #-32]
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e13694:	e283303f 	add	r3, r3, #63	; 0x3f
57e13698:	e3c3303f 	bic	r3, r3, #63	; 0x3f
57e1369c:	e2833048 	add	r3, r3, #72	; 0x48
57e136a0:	e04dd003 	sub	sp, sp, r3
57e136a4:	e28d4057 	add	r4, sp, #87	; 0x57
57e136a8:	e3c4403f 	bic	r4, r4, #63	; 0x3f
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
57e136ac:	e590c060 	ldr	ip, [r0, #96]	; 0x60
/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended(block_dev_desc_t *dev_desc,
				     int ext_part_sector, int relative,
				     int part_num, unsigned int disksig)
{
57e136b0:	e1a06000 	mov	r6, r0
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
57e136b4:	e3a02001 	mov	r2, #1
57e136b8:	e5900004 	ldr	r0, [r0, #4]
57e136bc:	e1a03004 	mov	r3, r4
/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended(block_dev_desc_t *dev_desc,
				     int ext_part_sector, int relative,
				     int part_num, unsigned int disksig)
{
57e136c0:	e1a07001 	mov	r7, r1
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
57e136c4:	e12fff3c 	blx	ip
57e136c8:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
57e136cc:	159f01e4 	ldrne	r0, [pc, #484]	; 57e138b8 <print_partition_extended+0x23c>
57e136d0:	15961004 	ldrne	r1, [r6, #4]
57e136d4:	11a02007 	movne	r2, r7
57e136d8:	1a000006 	bne	57e136f8 <print_partition_extended+0x7c>
			dev_desc->dev, ext_part_sector);
		return;
	}
	i=test_block_type(buffer);
57e136dc:	e1a00004 	mov	r0, r4
57e136e0:	ebffffca 	bl	57e13610 <test_block_type>
	if (i != DOS_MBR) {
57e136e4:	e3500000 	cmp	r0, #0
57e136e8:	0a000004 	beq	57e13700 <print_partition_extended+0x84>
		printf ("bad MBR sector signature 0x%02x%02x\n",
57e136ec:	e59f01c8 	ldr	r0, [pc, #456]	; 57e138bc <print_partition_extended+0x240>
57e136f0:	e5d411fe 	ldrb	r1, [r4, #510]	; 0x1fe
57e136f4:	e5d421ff 	ldrb	r2, [r4, #511]	; 0x1ff
57e136f8:	ebffd753 	bl	57e0944c <printf>
57e136fc:	ea00006b 	b	57e138b0 <print_partition_extended+0x234>
			buffer[DOS_PART_MAGIC_OFFSET],
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	if (!ext_part_sector)
57e13700:	e3570000 	cmp	r7, #0
57e13704:	1a000008 	bne	57e1372c <print_partition_extended+0xb0>
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e13708:	e5d431ba 	ldrb	r3, [r4, #442]	; 0x1ba

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e1370c:	e5d421bb 	ldrb	r2, [r4, #443]	; 0x1bb
	    (le32[2] << 16) +
57e13710:	e1a03803 	lsl	r3, r3, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13714:	e0833c02 	add	r3, r3, r2, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
57e13718:	e5d421b8 	ldrb	r2, [r4, #440]	; 0x1b8
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e1371c:	e0833002 	add	r3, r3, r2
	    (le32[1] << 8) +
57e13720:	e5d421b9 	ldrb	r2, [r4, #441]	; 0x1b9

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13724:	e0832402 	add	r2, r3, r2, lsl #8
57e13728:	e58b2004 	str	r2, [fp, #4]
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
57e1372c:	e2845f73 	add	r5, r4, #460	; 0x1cc
57e13730:	e2855002 	add	r5, r5, #2
	return 0;
}

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended(block_dev_desc_t *dev_desc,
57e13734:	e2844f83 	add	r4, r4, #524	; 0x20c
			   int part_num, unsigned int disksig)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
	int lba_size  = le32_to_int (p->size4);

	printf("%3d\t%-10d\t%-10d\t%08x-%02x\t%02x%s%s\n",
57e13738:	e59fc180 	ldr	ip, [pc, #384]	; 57e138c0 <print_partition_extended+0x244>
	return 0;
}

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended(block_dev_desc_t *dev_desc,
57e1373c:	e2849002 	add	r9, r4, #2
			   int part_num, unsigned int disksig)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
	int lba_size  = le32_to_int (p->size4);

	printf("%3d\t%-10d\t%-10d\t%08x-%02x\t%02x%s%s\n",
57e13740:	e50b5030 	str	r5, [fp, #-48]	; 0x30
	return 0;
}

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended(block_dev_desc_t *dev_desc,
57e13744:	e1a04005 	mov	r4, r5
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */

		if ((pt->sys_ind != 0) &&
57e13748:	e554100c 	ldrb	r1, [r4, #-12]
57e1374c:	e3510000 	cmp	r1, #0
57e13750:	0a00002c 	beq	57e13808 <print_partition_extended+0x18c>
57e13754:	e3570000 	cmp	r7, #0
57e13758:	0a000004 	beq	57e13770 <print_partition_extended+0xf4>
	   );
}

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
57e1375c:	e3510005 	cmp	r1, #5
57e13760:	1351000f 	cmpne	r1, #15
57e13764:	0a000029 	beq	57e13810 <print_partition_extended+0x194>
	    part_type == 0xf ||
57e13768:	e3510085 	cmp	r1, #133	; 0x85
57e1376c:	0a000027 	beq	57e13810 <print_partition_extended+0x194>
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e13770:	e5542006 	ldrb	r2, [r4, #-6]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13774:	e5543005 	ldrb	r3, [r4, #-5]
	    (le32[2] << 16) +
57e13778:	e1a02802 	lsl	r2, r2, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e1377c:	e0822c03 	add	r2, r2, r3, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
57e13780:	e5543008 	ldrb	r3, [r4, #-8]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13784:	e5540001 	ldrb	r0, [r4, #-1]
	    (le32[2] << 16) +
57e13788:	e0822003 	add	r2, r2, r3
	    (le32[1] << 8) +
57e1378c:	e5543007 	ldrb	r3, [r4, #-7]
	   );
}

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
57e13790:	e3510005 	cmp	r1, #5
57e13794:	1351000f 	cmpne	r1, #15

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13798:	e0822403 	add	r2, r2, r3, lsl #8
	    (le32[2] << 16) +
57e1379c:	e5543002 	ldrb	r3, [r4, #-2]
}

static void print_one_part(dos_partition_t *p, int ext_part_sector,
			   int part_num, unsigned int disksig)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
57e137a0:	e0822007 	add	r2, r2, r7
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e137a4:	e1a03803 	lsl	r3, r3, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e137a8:	e0833c00 	add	r3, r3, r0, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
57e137ac:	e5540004 	ldrb	r0, [r4, #-4]
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e137b0:	e0833000 	add	r3, r3, r0
	    (le32[1] << 8) +
57e137b4:	e5540003 	ldrb	r0, [r4, #-3]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e137b8:	e0833400 	add	r3, r3, r0, lsl #8
			   int part_num, unsigned int disksig)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
	int lba_size  = le32_to_int (p->size4);

	printf("%3d\t%-10d\t%-10d\t%08x-%02x\t%02x%s%s\n",
57e137bc:	059f0100 	ldreq	r0, [pc, #256]	; 57e138c4 <print_partition_extended+0x248>
	   );
}

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
57e137c0:	0a000002 	beq	57e137d0 <print_partition_extended+0x154>
			   int part_num, unsigned int disksig)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
	int lba_size  = le32_to_int (p->size4);

	printf("%3d\t%-10d\t%-10d\t%08x-%02x\t%02x%s%s\n",
57e137c4:	e3510085 	cmp	r1, #133	; 0x85
57e137c8:	e59f00f4 	ldr	r0, [pc, #244]	; 57e138c4 <print_partition_extended+0x248>
57e137cc:	11a0000c 	movne	r0, ip
57e137d0:	e5545010 	ldrb	r5, [r4, #-16]
57e137d4:	e59fe0ec 	ldr	lr, [pc, #236]	; 57e138c8 <print_partition_extended+0x24c>
57e137d8:	e3550080 	cmp	r5, #128	; 0x80
57e137dc:	e59b5004 	ldr	r5, [fp, #4]
57e137e0:	11a0e00c 	movne	lr, ip
57e137e4:	e58d1008 	str	r1, [sp, #8]
57e137e8:	e58d000c 	str	r0, [sp, #12]
57e137ec:	e1a0100a 	mov	r1, sl
57e137f0:	e59f00d4 	ldr	r0, [pc, #212]	; 57e138cc <print_partition_extended+0x250>
57e137f4:	e50bc024 	str	ip, [fp, #-36]	; 0x24
57e137f8:	e58de010 	str	lr, [sp, #16]
57e137fc:	e88d0420 	stm	sp, {r5, sl}
57e13800:	ebffd711 	bl	57e0944c <printf>
57e13804:	e51bc024 	ldr	ip, [fp, #-36]	; 0x24
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part(pt, ext_part_sector, part_num, disksig);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
57e13808:	e3570000 	cmp	r7, #0
57e1380c:	0a000007 	beq	57e13830 <print_partition_extended+0x1b4>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
57e13810:	e554300c 	ldrb	r3, [r4, #-12]
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part(pt, ext_part_sector, part_num, disksig);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
57e13814:	e3530000 	cmp	r3, #0
57e13818:	0a000005 	beq	57e13834 <print_partition_extended+0x1b8>
	   );
}

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
57e1381c:	e3530005 	cmp	r3, #5
57e13820:	1353000f 	cmpne	r3, #15
57e13824:	0a000002 	beq	57e13834 <print_partition_extended+0x1b8>
	    part_type == 0xf ||
57e13828:	e3530085 	cmp	r3, #133	; 0x85
57e1382c:	0a000000 	beq	57e13834 <print_partition_extended+0x1b8>
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
			part_num++;
57e13830:	e28aa001 	add	sl, sl, #1
57e13834:	e2844010 	add	r4, r4, #16
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
57e13838:	e1540009 	cmp	r4, r9
57e1383c:	1affffc1 	bne	57e13748 <print_partition_extended+0xcc>
57e13840:	e51b5030 	ldr	r5, [fp, #-48]	; 0x30
57e13844:	e51b4020 	ldr	r4, [fp, #-32]
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
57e13848:	e555300c 	ldrb	r3, [r5, #-12]
	   );
}

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
57e1384c:	e3530005 	cmp	r3, #5
57e13850:	1353000f 	cmpne	r3, #15
57e13854:	0a000001 	beq	57e13860 <print_partition_extended+0x1e4>
	    part_type == 0xf ||
57e13858:	e3530085 	cmp	r3, #133	; 0x85
57e1385c:	1a000010 	bne	57e138a4 <print_partition_extended+0x228>
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e13860:	e5551006 	ldrb	r1, [r5, #-6]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13864:	e5553005 	ldrb	r3, [r5, #-5]
	    (le32[2] << 16) +
57e13868:	e1a01801 	lsl	r1, r1, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e1386c:	e0811c03 	add	r1, r1, r3, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
57e13870:	e5553008 	ldrb	r3, [r5, #-8]
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;

			print_partition_extended(dev_desc, lba_start,
57e13874:	e3570000 	cmp	r7, #0
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e13878:	e0811003 	add	r1, r1, r3
	    (le32[1] << 8) +
57e1387c:	e5553007 	ldrb	r3, [r5, #-7]
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;

			print_partition_extended(dev_desc, lba_start,
57e13880:	e59be004 	ldr	lr, [fp, #4]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13884:	e0811403 	add	r1, r1, r3, lsl #8

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
57e13888:	e0811004 	add	r1, r1, r4

			print_partition_extended(dev_desc, lba_start,
57e1388c:	e1a00006 	mov	r0, r6
57e13890:	11a02004 	movne	r2, r4
57e13894:	01a02001 	moveq	r2, r1
57e13898:	e1a0300a 	mov	r3, sl
57e1389c:	e58de000 	str	lr, [sp]
57e138a0:	ebffff75 	bl	57e1367c <print_partition_extended>
57e138a4:	e2855010 	add	r5, r5, #16
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
57e138a8:	e1550009 	cmp	r5, r9
57e138ac:	1affffe5 	bne	57e13848 <print_partition_extended+0x1cc>
				part_num, disksig);
		}
	}

	return;
}
57e138b0:	e24bd01c 	sub	sp, fp, #28
57e138b4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e138b8:	57e333e9 	.word	0x57e333e9
57e138bc:	57e33414 	.word	0x57e33414
57e138c0:	57e302de 	.word	0x57e302de
57e138c4:	57e333dd 	.word	0x57e333dd
57e138c8:	57e333e3 	.word	0x57e333e3
57e138cc:	57e33439 	.word	0x57e33439

57e138d0 <get_partition_info_extended.clone.1>:


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
57e138d0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e138d4:	e28db01c 	add	fp, sp, #28
57e138d8:	e24dd008 	sub	sp, sp, #8
57e138dc:	e1a06003 	mov	r6, r3
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e138e0:	e5903014 	ldr	r3, [r0, #20]
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
57e138e4:	e590c060 	ldr	ip, [r0, #96]	; 0x60
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e138e8:	e283303f 	add	r3, r3, #63	; 0x3f
57e138ec:	e3c3303f 	bic	r3, r3, #63	; 0x3f
57e138f0:	e2833048 	add	r3, r3, #72	; 0x48
57e138f4:	e04dd003 	sub	sp, sp, r3
57e138f8:	e28d4047 	add	r4, sp, #71	; 0x47
57e138fc:	e3c4403f 	bic	r4, r4, #63	; 0x3f
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
57e13900:	e1a05000 	mov	r5, r0
57e13904:	e1a09002 	mov	r9, r2
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
57e13908:	e5900004 	ldr	r0, [r0, #4]
57e1390c:	e3a02001 	mov	r2, #1
57e13910:	e1a03004 	mov	r3, r4
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
57e13914:	e1a0a001 	mov	sl, r1
57e13918:	e59b7008 	ldr	r7, [fp, #8]
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
57e1391c:	e12fff3c 	blx	ip
57e13920:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
57e13924:	159f0228 	ldrne	r0, [pc, #552]	; 57e13b54 <get_partition_info_extended.clone.1+0x284>
57e13928:	15951004 	ldrne	r1, [r5, #4]
57e1392c:	11a0200a 	movne	r2, sl
57e13930:	1a000007 	bne	57e13954 <get_partition_info_extended.clone.1+0x84>
			dev_desc->dev, ext_part_sector);
		return -1;
	}
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
57e13934:	e5d411fe 	ldrb	r1, [r4, #510]	; 0x1fe
57e13938:	e3510055 	cmp	r1, #85	; 0x55
57e1393c:	1a000002 	bne	57e1394c <get_partition_info_extended.clone.1+0x7c>
57e13940:	e5d431ff 	ldrb	r3, [r4, #511]	; 0x1ff
57e13944:	e35300aa 	cmp	r3, #170	; 0xaa
57e13948:	0a000003 	beq	57e1395c <get_partition_info_extended.clone.1+0x8c>
		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
		printf ("bad MBR sector signature 0x%02x%02x\n",
57e1394c:	e59f0204 	ldr	r0, [pc, #516]	; 57e13b58 <get_partition_info_extended.clone.1+0x288>
57e13950:	e5d421ff 	ldrb	r2, [r4, #511]	; 0x1ff
57e13954:	ebffd6bc 	bl	57e0944c <printf>
57e13958:	ea000076 	b	57e13b38 <get_partition_info_extended.clone.1+0x268>
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
57e1395c:	e2843f6f 	add	r3, r4, #444	; 0x1bc
57e13960:	e2833002 	add	r3, r3, #2
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
57e13964:	e2844f7b 	add	r4, r4, #492	; 0x1ec
57e13968:	e2841002 	add	r1, r4, #2
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
57e1396c:	e1a04003 	mov	r4, r3
	for (i = 0; i < 4; i++, pt++) {
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
57e13970:	e5d42000 	ldrb	r2, [r4]
57e13974:	e312007f 	tst	r2, #127	; 0x7f
57e13978:	1a000047 	bne	57e13a9c <get_partition_info_extended.clone.1+0x1cc>
		    (pt->sys_ind != 0) &&
57e1397c:	e5d42004 	ldrb	r2, [r4, #4]
57e13980:	e59bc004 	ldr	ip, [fp, #4]
57e13984:	e156000c 	cmp	r6, ip
57e13988:	13a00000 	movne	r0, #0
57e1398c:	03a00001 	moveq	r0, #1
57e13990:	e3520000 	cmp	r2, #0
57e13994:	03a00000 	moveq	r0, #0
57e13998:	e3500000 	cmp	r0, #0
57e1399c:	0a00003e 	beq	57e13a9c <get_partition_info_extended.clone.1+0x1cc>
	   );
}

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
57e139a0:	e3520005 	cmp	r2, #5
57e139a4:	1352000f 	cmpne	r2, #15
57e139a8:	0a00003b 	beq	57e13a9c <get_partition_info_extended.clone.1+0x1cc>
	    part_type == 0xf ||
57e139ac:	e3520085 	cmp	r2, #133	; 0x85
57e139b0:	0a000039 	beq	57e13a9c <get_partition_info_extended.clone.1+0x1cc>
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
57e139b4:	e3a03c02 	mov	r3, #512	; 0x200
57e139b8:	e5873008 	str	r3, [r7, #8]
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e139bc:	e5d4300a 	ldrb	r3, [r4, #10]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e139c0:	e5d4200b 	ldrb	r2, [r4, #11]
	    (le32[2] << 16) +
57e139c4:	e1a03803 	lsl	r3, r3, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e139c8:	e0833c02 	add	r3, r3, r2, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
57e139cc:	e5d42008 	ldrb	r2, [r4, #8]
57e139d0:	e287000c 	add	r0, r7, #12
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e139d4:	e0833002 	add	r3, r3, r2
	    (le32[1] << 8) +
57e139d8:	e5d42009 	ldrb	r2, [r4, #9]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e139dc:	e0833402 	add	r3, r3, r2, lsl #8
		if (((pt->boot_ind & ~0x80) == 0) &&
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
			info->start = ext_part_sector + le32_to_int (pt->start4);
57e139e0:	e083a00a 	add	sl, r3, sl
57e139e4:	e587a000 	str	sl, [r7]
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e139e8:	e5d4300e 	ldrb	r3, [r4, #14]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e139ec:	e5d4200f 	ldrb	r2, [r4, #15]
	    (le32[2] << 16) +
57e139f0:	e1a03803 	lsl	r3, r3, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e139f4:	e0833c02 	add	r3, r3, r2, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
57e139f8:	e5d4200c 	ldrb	r2, [r4, #12]
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e139fc:	e0833002 	add	r3, r3, r2
	    (le32[1] << 8) +
57e13a00:	e5d4200d 	ldrb	r2, [r4, #13]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13a04:	e0833402 	add	r3, r3, r2, lsl #8
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
			info->start = ext_part_sector + le32_to_int (pt->start4);
			info->size  = le32_to_int (pt->size4);
57e13a08:	e5873004 	str	r3, [r7, #4]
			switch(dev_desc->if_type) {
57e13a0c:	e5953000 	ldr	r3, [r5]
57e13a10:	e5952004 	ldr	r2, [r5, #4]
57e13a14:	e2433001 	sub	r3, r3, #1
57e13a18:	e3530007 	cmp	r3, #7
57e13a1c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e13a20:	ea00000f 	b	57e13a64 <get_partition_info_extended.clone.1+0x194>
57e13a24:	57e13a44 	.word	0x57e13a44
57e13a28:	57e13a4c 	.word	0x57e13a4c
57e13a2c:	57e13a44 	.word	0x57e13a44
57e13a30:	57e13a54 	.word	0x57e13a54
57e13a34:	57e13a5c 	.word	0x57e13a5c
57e13a38:	57e13a64 	.word	0x57e13a64
57e13a3c:	57e13a64 	.word	0x57e13a64
57e13a40:	57e13a44 	.word	0x57e13a44
				case IF_TYPE_IDE:
				case IF_TYPE_SATA:
				case IF_TYPE_ATAPI:
					sprintf ((char *)info->name, "hd%c%d",
57e13a44:	e59f1110 	ldr	r1, [pc, #272]	; 57e13b5c <get_partition_info_extended.clone.1+0x28c>
57e13a48:	ea000006 	b	57e13a68 <get_partition_info_extended.clone.1+0x198>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_SCSI:
					sprintf ((char *)info->name, "sd%c%d",
57e13a4c:	e59f110c 	ldr	r1, [pc, #268]	; 57e13b60 <get_partition_info_extended.clone.1+0x290>
57e13a50:	ea000004 	b	57e13a68 <get_partition_info_extended.clone.1+0x198>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_USB:
					sprintf ((char *)info->name, "usbd%c%d",
57e13a54:	e59f1108 	ldr	r1, [pc, #264]	; 57e13b64 <get_partition_info_extended.clone.1+0x294>
57e13a58:	ea000002 	b	57e13a68 <get_partition_info_extended.clone.1+0x198>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_DOC:
					sprintf ((char *)info->name, "docd%c%d",
57e13a5c:	e59f1104 	ldr	r1, [pc, #260]	; 57e13b68 <get_partition_info_extended.clone.1+0x298>
57e13a60:	ea000000 	b	57e13a68 <get_partition_info_extended.clone.1+0x198>
						'a' + dev_desc->dev, part_num);
					break;
				default:
					sprintf ((char *)info->name, "xx%c%d",
57e13a64:	e59f1100 	ldr	r1, [pc, #256]	; 57e13b6c <get_partition_info_extended.clone.1+0x29c>
57e13a68:	e1a03006 	mov	r3, r6
57e13a6c:	e2822061 	add	r2, r2, #97	; 0x61
57e13a70:	eb004634 	bl	57e25348 <sprintf>
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
57e13a74:	e287002c 	add	r0, r7, #44	; 0x2c
57e13a78:	e59f10f0 	ldr	r1, [pc, #240]	; 57e13b70 <get_partition_info_extended.clone.1+0x2a0>
57e13a7c:	eb004631 	bl	57e25348 <sprintf>
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
57e13a80:	e5d43000 	ldrb	r3, [r4]
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
#ifdef CONFIG_PARTITION_UUIDS
			sprintf(info->uuid, "%08x-%02x", disksig, part_num);
#endif
			return 0;
57e13a84:	e3a00000 	mov	r0, #0
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
57e13a88:	e3530080 	cmp	r3, #128	; 0x80
57e13a8c:	13a03000 	movne	r3, #0
57e13a90:	03a03001 	moveq	r3, #1
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
57e13a94:	e587304c 	str	r3, [r7, #76]	; 0x4c
57e13a98:	ea000027 	b	57e13b3c <get_partition_info_extended.clone.1+0x26c>
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
57e13a9c:	e35a0000 	cmp	sl, #0
57e13aa0:	0a000007 	beq	57e13ac4 <get_partition_info_extended.clone.1+0x1f4>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
57e13aa4:	e5d42004 	ldrb	r2, [r4, #4]
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
57e13aa8:	e3520000 	cmp	r2, #0
57e13aac:	0a000005 	beq	57e13ac8 <get_partition_info_extended.clone.1+0x1f8>
	   );
}

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
57e13ab0:	e3520005 	cmp	r2, #5
57e13ab4:	1352000f 	cmpne	r2, #15
57e13ab8:	0a000002 	beq	57e13ac8 <get_partition_info_extended.clone.1+0x1f8>
	    part_type == 0xf ||
57e13abc:	e3520085 	cmp	r2, #133	; 0x85
57e13ac0:	0a000000 	beq	57e13ac8 <get_partition_info_extended.clone.1+0x1f8>
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
			part_num++;
57e13ac4:	e2866001 	add	r6, r6, #1
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
57e13ac8:	e1540001 	cmp	r4, r1
57e13acc:	12844010 	addne	r4, r4, #16
57e13ad0:	1affffa6 	bne	57e13970 <get_partition_info_extended.clone.1+0xa0>
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
57e13ad4:	e5d32004 	ldrb	r2, [r3, #4]
	   );
}

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
57e13ad8:	e3520005 	cmp	r2, #5
57e13adc:	1352000f 	cmpne	r2, #15
57e13ae0:	0a000001 	beq	57e13aec <get_partition_info_extended.clone.1+0x21c>
	    part_type == 0xf ||
57e13ae4:	e3520085 	cmp	r2, #133	; 0x85
57e13ae8:	1a000015 	bne	57e13b44 <get_partition_info_extended.clone.1+0x274>
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e13aec:	e5d3100a 	ldrb	r1, [r3, #10]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13af0:	e5d3200b 	ldrb	r2, [r3, #11]
	    (le32[2] << 16) +
57e13af4:	e1a01801 	lsl	r1, r1, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13af8:	e0811c02 	add	r1, r1, r2, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
57e13afc:	e5d32008 	ldrb	r2, [r3, #8]
57e13b00:	e5d33009 	ldrb	r3, [r3, #9]
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
57e13b04:	e0811002 	add	r1, r1, r2

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
57e13b08:	e0811403 	add	r1, r1, r3, lsl #8
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;

			return get_partition_info_extended (dev_desc, lba_start,
57e13b0c:	e59b3004 	ldr	r3, [fp, #4]
57e13b10:	e35a0000 	cmp	sl, #0

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
57e13b14:	e0811009 	add	r1, r1, r9

			return get_partition_info_extended (dev_desc, lba_start,
57e13b18:	e58d3000 	str	r3, [sp]
57e13b1c:	e1a00005 	mov	r0, r5
57e13b20:	11a02009 	movne	r2, r9
57e13b24:	01a02001 	moveq	r2, r1
57e13b28:	e1a03006 	mov	r3, r6
57e13b2c:	e58d7004 	str	r7, [sp, #4]
57e13b30:	ebffff66 	bl	57e138d0 <get_partition_info_extended.clone.1>
57e13b34:	ea000000 	b	57e13b3c <get_partition_info_extended.clone.1+0x26c>
				 ext_part_sector == 0 ? lba_start : relative,
				 part_num, which_part, info, disksig);
		}
	}
	return -1;
57e13b38:	e3e00000 	mvn	r0, #0
}
57e13b3c:	e24bd01c 	sub	sp, fp, #28
57e13b40:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
57e13b44:	e1530001 	cmp	r3, r1
57e13b48:	0afffffa 	beq	57e13b38 <get_partition_info_extended.clone.1+0x268>
57e13b4c:	e2833010 	add	r3, r3, #16
57e13b50:	eaffffdf 	b	57e13ad4 <get_partition_info_extended.clone.1+0x204>
57e13b54:	57e333e9 	.word	0x57e333e9
57e13b58:	57e33414 	.word	0x57e33414
57e13b5c:	57e3345d 	.word	0x57e3345d
57e13b60:	57e33464 	.word	0x57e33464
57e13b64:	57e3346b 	.word	0x57e3346b
57e13b68:	57e33474 	.word	0x57e33474
57e13b6c:	57e3347d 	.word	0x57e3347d
57e13b70:	57e32a0e 	.word	0x57e32a0e

57e13b74 <test_part_dos>:
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
57e13b74:	e92d4818 	push	{r3, r4, fp, lr}
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e13b78:	e5903014 	ldr	r3, [r0, #20]
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
57e13b7c:	e28db00c 	add	fp, sp, #12
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e13b80:	e283303f 	add	r3, r3, #63	; 0x3f
57e13b84:	e3c3303f 	bic	r3, r3, #63	; 0x3f
57e13b88:	e2833048 	add	r3, r3, #72	; 0x48
57e13b8c:	e04dd003 	sub	sp, sp, r3
57e13b90:	e28d403f 	add	r4, sp, #63	; 0x3f
57e13b94:	e3c4403f 	bic	r4, r4, #63	; 0x3f

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
57e13b98:	e590c060 	ldr	ip, [r0, #96]	; 0x60
57e13b9c:	e3a01000 	mov	r1, #0
57e13ba0:	e5900004 	ldr	r0, [r0, #4]
57e13ba4:	e3a02001 	mov	r2, #1
57e13ba8:	e1a03004 	mov	r3, r4
57e13bac:	e12fff3c 	blx	ip
57e13bb0:	e3500001 	cmp	r0, #1
		return -1;
57e13bb4:	13e00000 	mvnne	r0, #0

int test_part_dos (block_dev_desc_t *dev_desc)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
57e13bb8:	1a000003 	bne	57e13bcc <test_part_dos+0x58>
		return -1;

	if (test_block_type(buffer) != DOS_MBR)
57e13bbc:	e1a00004 	mov	r0, r4
57e13bc0:	ebfffe92 	bl	57e13610 <test_block_type>
57e13bc4:	e3500000 	cmp	r0, #0
		return -1;
57e13bc8:	13e00000 	mvnne	r0, #0

	return 0;
}
57e13bcc:	e24bd00c 	sub	sp, fp, #12
57e13bd0:	e8bd8818 	pop	{r3, r4, fp, pc}

57e13bd4 <print_part_dos>:
	}
	return -1;
}

void print_part_dos (block_dev_desc_t *dev_desc)
{
57e13bd4:	e92d4013 	push	{r0, r1, r4, lr}
57e13bd8:	e1a04000 	mov	r4, r0
	printf("Part\tStart Sector\tNum Sectors\tUUID\t\tType\n");
57e13bdc:	e59f001c 	ldr	r0, [pc, #28]	; 57e13c00 <print_part_dos+0x2c>
57e13be0:	ebffd619 	bl	57e0944c <printf>
	print_partition_extended(dev_desc, 0, 0, 1, 0);
57e13be4:	e3a01000 	mov	r1, #0
57e13be8:	e1a00004 	mov	r0, r4
57e13bec:	e1a02001 	mov	r2, r1
57e13bf0:	e3a03001 	mov	r3, #1
57e13bf4:	e58d1000 	str	r1, [sp]
57e13bf8:	ebfffe9f 	bl	57e1367c <print_partition_extended>
}
57e13bfc:	e8bd801c 	pop	{r2, r3, r4, pc}
57e13c00:	57e33484 	.word	0x57e33484

57e13c04 <get_partition_info_dos>:

int get_partition_info_dos (block_dev_desc_t *dev_desc, int part, disk_partition_t * info)
{
57e13c04:	e92d4007 	push	{r0, r1, r2, lr}
	return get_partition_info_extended(dev_desc, 0, 0, 1, part, info, 0);
57e13c08:	e58d1000 	str	r1, [sp]
57e13c0c:	e3a01000 	mov	r1, #0
57e13c10:	e58d2004 	str	r2, [sp, #4]
57e13c14:	e3a03001 	mov	r3, #1
57e13c18:	e1a02001 	mov	r2, r1
57e13c1c:	ebffff2b 	bl	57e138d0 <get_partition_info_extended.clone.1>
}
57e13c20:	e8bd800e 	pop	{r1, r2, r3, pc}

57e13c24 <sort_array_by_ordering>:
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
57e13c24:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e13c28:	e28db01c 	add	fp, sp, #28
57e13c2c:	e24dd008 	sub	sp, sp, #8
57e13c30:	e50b2020 	str	r2, [fp, #-32]
	int temp[count];
57e13c34:	e1a02101 	lsl	r2, r1, #2
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
57e13c38:	e1a09003 	mov	r9, r3
	int temp[count];
57e13c3c:	e282300e 	add	r3, r2, #14
57e13c40:	e3c33007 	bic	r3, r3, #7
57e13c44:	e04dd003 	sub	sp, sp, r3
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
57e13c48:	e1a04000 	mov	r4, r0
57e13c4c:	e1a05001 	mov	r5, r1
	int dest_count;
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
57e13c50:	e1a0000d 	mov	r0, sp
57e13c54:	e1a01004 	mov	r1, r4
57e13c58:	eb0041ab 	bl	57e2430c <memcpy>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
57e13c5c:	e3a02000 	mov	r2, #0
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
	int temp[count];
57e13c60:	e1a0600d 	mov	r6, sp
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
57e13c64:	e51b0020 	ldr	r0, [fp, #-32]
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;
57e13c68:	e1a03002 	mov	r3, r2

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
57e13c6c:	ea00000d 	b	57e13ca8 <sort_array_by_ordering+0x84>
		if (array_search(temp, count, order[i]) != -1)
57e13c70:	e490c004 	ldr	ip, [r0], #4
57e13c74:	e1a07006 	mov	r7, r6
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
57e13c78:	e3a01000 	mov	r1, #0
57e13c7c:	ea000003 	b	57e13c90 <sort_array_by_ordering+0x6c>
		if (array[i] == key)
57e13c80:	e497a004 	ldr	sl, [r7], #4
57e13c84:	e15a000c 	cmp	sl, ip
57e13c88:	0a000003 	beq	57e13c9c <sort_array_by_ordering+0x78>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
57e13c8c:	e2811001 	add	r1, r1, #1
57e13c90:	e1510005 	cmp	r1, r5
57e13c94:	bafffff9 	blt	57e13c80 <sort_array_by_ordering+0x5c>
57e13c98:	ea000001 	b	57e13ca4 <sort_array_by_ordering+0x80>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
		if (array_search(temp, count, order[i]) != -1)
			dest[dest_count++] = order[i];
57e13c9c:	e784c103 	str	ip, [r4, r3, lsl #2]
57e13ca0:	e2833001 	add	r3, r3, #1
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
57e13ca4:	e2822001 	add	r2, r2, #1
57e13ca8:	e1520009 	cmp	r2, r9
57e13cac:	baffffef 	blt	57e13c70 <sort_array_by_ordering+0x4c>
57e13cb0:	e1a00003 	mov	r0, r3
57e13cb4:	e3a02000 	mov	r2, #0
57e13cb8:	ea00000b 	b	57e13cec <sort_array_by_ordering+0xc8>
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
57e13cbc:	e496c004 	ldr	ip, [r6], #4
57e13cc0:	e51b7020 	ldr	r7, [fp, #-32]
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
57e13cc4:	e3a01000 	mov	r1, #0
57e13cc8:	ea000003 	b	57e13cdc <sort_array_by_ordering+0xb8>
		if (array[i] == key)
57e13ccc:	e497a004 	ldr	sl, [r7], #4
57e13cd0:	e15a000c 	cmp	sl, ip
57e13cd4:	0a000003 	beq	57e13ce8 <sort_array_by_ordering+0xc4>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
57e13cd8:	e2811001 	add	r1, r1, #1
57e13cdc:	e1510009 	cmp	r1, r9
57e13ce0:	bafffff9 	blt	57e13ccc <sort_array_by_ordering+0xa8>
57e13ce4:	ea000004 	b	57e13cfc <sort_array_by_ordering+0xd8>
			dest[dest_count++] = order[i];
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
57e13ce8:	e2822001 	add	r2, r2, #1
57e13cec:	e1520005 	cmp	r2, r5
57e13cf0:	bafffff1 	blt	57e13cbc <sort_array_by_ordering+0x98>
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
	}
	assert(dest_count == count);
	return same;
}
57e13cf4:	e24bd01c 	sub	sp, fp, #28
57e13cf8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
57e13cfc:	e784c103 	str	ip, [r4, r3, lsl #2]
57e13d00:	e2833001 	add	r3, r3, #1
57e13d04:	eafffff7 	b	57e13ce8 <sort_array_by_ordering+0xc4>

57e13d08 <input_tstc>:
	return 0;
}

int input_tstc(struct input_config *config)
{
	if (config->fifo_in == config->fifo_out && config->read_keys) {
57e13d08:	e5902010 	ldr	r2, [r0, #16]
57e13d0c:	e5903014 	ldr	r3, [r0, #20]

	return 0;
}

int input_tstc(struct input_config *config)
{
57e13d10:	e92d4010 	push	{r4, lr}
	if (config->fifo_in == config->fifo_out && config->read_keys) {
57e13d14:	e1520003 	cmp	r2, r3

	return 0;
}

int input_tstc(struct input_config *config)
{
57e13d18:	e1a04000 	mov	r4, r0
	if (config->fifo_in == config->fifo_out && config->read_keys) {
57e13d1c:	1a000005 	bne	57e13d38 <input_tstc+0x30>
57e13d20:	e59030a0 	ldr	r3, [r0, #160]	; 0xa0
57e13d24:	e3530000 	cmp	r3, #0
57e13d28:	0a000002 	beq	57e13d38 <input_tstc+0x30>
		if (!(*config->read_keys)(config))
57e13d2c:	e12fff33 	blx	r3
57e13d30:	e3500000 	cmp	r0, #0
57e13d34:	08bd8010 	popeq	{r4, pc}
			return 0;
	}
	return config->fifo_in != config->fifo_out;
57e13d38:	e5940010 	ldr	r0, [r4, #16]
57e13d3c:	e5943014 	ldr	r3, [r4, #20]
57e13d40:	e0500003 	subs	r0, r0, r3
57e13d44:	13a00001 	movne	r0, #1
}
57e13d48:	e8bd8010 	pop	{r4, pc}

57e13d4c <input_getc>:

int input_getc(struct input_config *config)
{
57e13d4c:	e92d4010 	push	{r4, lr}
57e13d50:	e1a04000 	mov	r4, r0
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
57e13d54:	ea000006 	b	57e13d74 <input_getc+0x28>
		if (config->read_keys)
57e13d58:	e59430a0 	ldr	r3, [r4, #160]	; 0xa0
57e13d5c:	e3530000 	cmp	r3, #0
57e13d60:	0a000003 	beq	57e13d74 <input_getc+0x28>
			err = (*config->read_keys)(config);
57e13d64:	e1a00004 	mov	r0, r4
57e13d68:	e12fff33 	blx	r3
		if (err)
57e13d6c:	e3500000 	cmp	r0, #0
57e13d70:	1a00000b 	bne	57e13da4 <input_getc+0x58>

int input_getc(struct input_config *config)
{
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
57e13d74:	e5943014 	ldr	r3, [r4, #20]
57e13d78:	e5942010 	ldr	r2, [r4, #16]
57e13d7c:	e1520003 	cmp	r2, r3
57e13d80:	0afffff4 	beq	57e13d58 <input_getc+0xc>
			err = (*config->read_keys)(config);
		if (err)
			return -1;
	}

	if (++config->fifo_out == INPUT_BUFFER_LEN)
57e13d84:	e2833001 	add	r3, r3, #1
57e13d88:	e3530010 	cmp	r3, #16
57e13d8c:	e5843014 	str	r3, [r4, #20]
		config->fifo_out = 0;
57e13d90:	03a03000 	moveq	r3, #0
57e13d94:	05843014 	streq	r3, [r4, #20]

	return config->fifo[config->fifo_out];
57e13d98:	e5943014 	ldr	r3, [r4, #20]
57e13d9c:	e7d40003 	ldrb	r0, [r4, r3]
57e13da0:	e8bd8010 	pop	{r4, pc}

	while (config->fifo_in == config->fifo_out) {
		if (config->read_keys)
			err = (*config->read_keys)(config);
		if (err)
			return -1;
57e13da4:	e3e00000 	mvn	r0, #0

	if (++config->fifo_out == INPUT_BUFFER_LEN)
		config->fifo_out = 0;

	return config->fifo[config->fifo_out];
}
57e13da8:	e8bd8010 	pop	{r4, pc}

57e13dac <input_send_keycodes>:
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
57e13dac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e13db0:	e28db01c 	add	fp, sp, #28
57e13db4:	e24dd018 	sub	sp, sp, #24
	char ch[num_keycodes * ANSI_CHAR_MAX];
57e13db8:	e082a082 	add	sl, r2, r2, lsl #1
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
57e13dbc:	e5d0701b 	ldrb	r7, [r0, #27]
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes * ANSI_CHAR_MAX];
57e13dc0:	e28a300e 	add	r3, sl, #14
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
57e13dc4:	e3a09000 	mov	r9, #0
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes * ANSI_CHAR_MAX];
57e13dc8:	e3c33007 	bic	r3, r3, #7
57e13dcc:	e04dd003 	sub	sp, sp, r3
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
57e13dd0:	e1570009 	cmp	r7, r9
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
57e13dd4:	e1a04000 	mov	r4, r0
57e13dd8:	e1a06001 	mov	r6, r1
57e13ddc:	e1a05002 	mov	r5, r2
	char ch[num_keycodes * ANSI_CHAR_MAX];
57e13de0:	e50bd020 	str	sp, [fp, #-32]
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
57e13de4:	e5c09018 	strb	r9, [r0, #24]
int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes * ANSI_CHAR_MAX];
	int count, i, same = 0;
	int is_repeat = 0;
57e13de8:	01a0c007 	moveq	ip, r7
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
57e13dec:	0a00001a 	beq	57e13e5c <input_send_keycodes+0xb0>
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
57e13df0:	e280c01c 	add	ip, r0, #28
57e13df4:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
57e13df8:	e1a00001 	mov	r0, r1
57e13dfc:	e1a01002 	mov	r1, r2
57e13e00:	e1a0200c 	mov	r2, ip
57e13e04:	e50bc034 	str	ip, [fp, #-52]	; 0x34
57e13e08:	ebffff85 	bl	57e13c24 <sort_array_by_ordering>
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
57e13e0c:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
57e13e10:	e1a07000 	mov	r7, r0
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
57e13e14:	e1a01006 	mov	r1, r6
57e13e18:	e1a0000c 	mov	r0, ip
57e13e1c:	e1a02105 	lsl	r2, r5, #2
57e13e20:	eb004139 	bl	57e2430c <memcpy>
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
57e13e24:	e1570005 	cmp	r7, r5
	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
	config->num_prev_keycodes = num_keycodes;
57e13e28:	e584505c 	str	r5, [r4, #92]	; 0x5c
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
57e13e2c:	1a000009 	bne	57e13e58 <input_send_keycodes+0xac>
		 * the caller may not call in again for a while, our
		 * auto-repeat speed is not quite correct. We should
		 * insert another character if we later realise that we
		 * have missed a repeat slot.
		 */
		is_repeat = config->repeat_rate_ms &&
57e13e30:	e59430ac 	ldr	r3, [r4, #172]	; 0xac
57e13e34:	e1530009 	cmp	r3, r9
57e13e38:	0a000098 	beq	57e140a0 <input_send_keycodes+0x2f4>
			(int)get_timer(config->next_repeat_ms) >= 0;
57e13e3c:	e59400a4 	ldr	r0, [r4, #164]	; 0xa4
57e13e40:	ebffb331 	bl	57e00b0c <get_timer>
		 * the caller may not call in again for a while, our
		 * auto-repeat speed is not quite correct. We should
		 * insert another character if we later realise that we
		 * have missed a repeat slot.
		 */
		is_repeat = config->repeat_rate_ms &&
57e13e44:	e1500009 	cmp	r0, r9
57e13e48:	a3a0c001 	movge	ip, #1
			(int)get_timer(config->next_repeat_ms) >= 0;
		if (!is_repeat)
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
57e13e4c:	a1a07009 	movge	r7, r9
		 * the caller may not call in again for a while, our
		 * auto-repeat speed is not quite correct. We should
		 * insert another character if we later realise that we
		 * have missed a repeat slot.
		 */
		is_repeat = config->repeat_rate_ms &&
57e13e50:	aa000001 	bge	57e13e5c <input_send_keycodes+0xb0>
57e13e54:	ea000091 	b	57e140a0 <input_send_keycodes+0x2f4>
int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes * ANSI_CHAR_MAX];
	int count, i, same = 0;
	int is_repeat = 0;
57e13e58:	e1a0c009 	mov	ip, r9
{
	struct input_key_xlate *table;
	int ch_count = 0;
	int i;

	table = &config->table[0];
57e13e5c:	e2840060 	add	r0, r4, #96	; 0x60
57e13e60:	e50b0024 	str	r0, [fp, #-36]	; 0x24
57e13e64:	e50b6028 	str	r6, [fp, #-40]	; 0x28
57e13e68:	e1a03000 	mov	r3, r0

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
57e13e6c:	e3a0e000 	mov	lr, #0
57e13e70:	ea000034 	b	57e13f48 <input_send_keycodes+0x19c>
		int key = keycode[i] & KEY_MASK;
57e13e74:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
57e13e78:	e593900c 	ldr	r9, [r3, #12]

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
		int key = keycode[i] & KEY_MASK;
57e13e7c:	e4921004 	ldr	r1, [r2], #4
57e13e80:	e1a00a01 	lsl	r0, r1, #20
57e13e84:	e50b2028 	str	r2, [fp, #-40]	; 0x28
57e13e88:	e1a02a20 	lsr	r2, r0, #20

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
57e13e8c:	e1520009 	cmp	r2, r9
57e13e90:	aa000003 	bge	57e13ea4 <input_send_keycodes+0xf8>
57e13e94:	e5939008 	ldr	r9, [r3, #8]
57e13e98:	e7d90a20 	ldrb	r0, [r9, r0, lsr #20]
57e13e9c:	e35000ff 	cmp	r0, #255	; 0xff
57e13ea0:	1a000027 	bne	57e13f44 <input_send_keycodes+0x198>
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
57e13ea4:	e5d4301b 	ldrb	r3, [r4, #27]
	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
		int key = keycode[i] & KEY_MASK;

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
			table = process_modifier(config, key,
57e13ea8:	e2011902 	and	r1, r1, #32768	; 0x8000
57e13eac:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
57e13eb0:	e50b3030 	str	r3, [fp, #-48]	; 0x30
57e13eb4:	e1a00004 	mov	r0, r4
	int flip = -1;
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
57e13eb8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
	for (i = 1; i < config->num_tables; i++) {
57e13ebc:	e3a01001 	mov	r1, #1
57e13ec0:	ea000009 	b	57e13eec <input_send_keycodes+0x140>
		struct input_key_xlate *tab = &config->table[i];

		if (key == tab->left_keycode || key == tab->right_keycode)
57e13ec4:	e5909070 	ldr	r9, [r0, #112]	; 0x70
57e13ec8:	e1520009 	cmp	r2, r9
57e13ecc:	0a000002 	beq	57e13edc <input_send_keycodes+0x130>
57e13ed0:	e5909074 	ldr	r9, [r0, #116]	; 0x74
57e13ed4:	e1520009 	cmp	r2, r9
57e13ed8:	1a000001 	bne	57e13ee4 <input_send_keycodes+0x138>

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
		struct input_key_xlate *tab = &config->table[i];
57e13edc:	e2813006 	add	r3, r1, #6
57e13ee0:	e0843203 	add	r3, r4, r3, lsl #4
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
57e13ee4:	e2811001 	add	r1, r1, #1
57e13ee8:	e2800010 	add	r0, r0, #16
57e13eec:	e51b9030 	ldr	r9, [fp, #-48]	; 0x30
57e13ef0:	e1510009 	cmp	r1, r9
57e13ef4:	bafffff2 	blt	57e13ec4 <input_send_keycodes+0x118>
		if (key == tab->left_keycode || key == tab->right_keycode)
			table = tab;
	}

	/* Handle the lighted keys */
	if (!release) {
57e13ef8:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
57e13efc:	e3500000 	cmp	r0, #0
57e13f00:	1a00000f 	bne	57e13f44 <input_send_keycodes+0x198>
57e13f04:	e242203a 	sub	r2, r2, #58	; 0x3a
57e13f08:	e352000c 	cmp	r2, #12
57e13f0c:	8a00000c 	bhi	57e13f44 <input_send_keycodes+0x198>
			flip = FLAG_CAPS_LOCK;
			break;
		}
	}

	if (flip != -1) {
57e13f10:	e59f1190 	ldr	r1, [pc, #400]	; 57e140a8 <input_send_keycodes+0x2fc>
57e13f14:	e7912102 	ldr	r2, [r1, r2, lsl #2]
57e13f18:	e3720001 	cmn	r2, #1
57e13f1c:	0a000008 	beq	57e13f44 <input_send_keycodes+0x198>
		int leds = 0;

		config->leds ^= flip;
		if (config->flags & FLAG_NUM_LOCK)
57e13f20:	e5d41019 	ldrb	r1, [r4, #25]
			leds |= INPUT_LED_NUM;
57e13f24:	e3110001 	tst	r1, #1
57e13f28:	03a02000 	moveq	r2, #0
57e13f2c:	13a02004 	movne	r2, #4
		if (config->flags & FLAG_CAPS_LOCK)
57e13f30:	e3110002 	tst	r1, #2
			leds |= INPUT_LED_CAPS;
57e13f34:	13822002 	orrne	r2, r2, #2
		if (config->flags & FLAG_SCROLL_LOCK)
57e13f38:	e3110004 	tst	r1, #4
			leds |= INPUT_LED_SCROLL;
57e13f3c:	13822001 	orrne	r2, r2, #1
		config->leds = leds;
57e13f40:	e5c4201a 	strb	r2, [r4, #26]
	int i;

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
57e13f44:	e28ee001 	add	lr, lr, #1
57e13f48:	e15e0005 	cmp	lr, r5
57e13f4c:	baffffc8 	blt	57e13e74 <input_send_keycodes+0xc8>

	/* ok, so return keys */
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
57e13f50:	e2472001 	sub	r2, r7, #1
57e13f54:	e0866102 	add	r6, r6, r2, lsl #2
57e13f58:	e3a09000 	mov	r9, #0
57e13f5c:	ea00002b 	b	57e14010 <input_send_keycodes+0x264>
		}
	}

	/* Start conversion by looking for the first new keycode (by same). */
	for (i = same; i < num_keycodes; i++) {
		int key = keycode[i];
57e13f60:	e5b62004 	ldr	r2, [r6, #4]!
		int ch = (key < table->num_entries) ? table->xlate[key] : 0xff;
57e13f64:	e593100c 	ldr	r1, [r3, #12]
57e13f68:	e1520001 	cmp	r2, r1
57e13f6c:	aa000003 	bge	57e13f80 <input_send_keycodes+0x1d4>
57e13f70:	e5931008 	ldr	r1, [r3, #8]
57e13f74:	e7d11002 	ldrb	r1, [r1, r2]

		/*
		 * For a normal key (with an ASCII value), add it; otherwise
		 * translate special key to escape sequence if possible.
		 */
		if (ch != 0xff) {
57e13f78:	e35100ff 	cmp	r1, #255	; 0xff
57e13f7c:	1a000009 	bne	57e13fa8 <input_send_keycodes+0x1fc>
	const char *escape;
	int ch_count;
	int i;

	for (i = ch_count = 0; i < ARRAY_SIZE(kbd_to_ansi364); i++) {
		if (keycode != kbd_to_ansi364[i].kbd_scan_code)
57e13f80:	e3520067 	cmp	r2, #103	; 0x67
57e13f84:	0a00000c 	beq	57e13fbc <input_send_keycodes+0x210>
57e13f88:	e352006c 	cmp	r2, #108	; 0x6c
57e13f8c:	0a00000c 	beq	57e13fc4 <input_send_keycodes+0x218>
57e13f90:	e352006a 	cmp	r2, #106	; 0x6a
57e13f94:	0a00000c 	beq	57e13fcc <input_send_keycodes+0x220>
57e13f98:	e3520069 	cmp	r2, #105	; 0x69
{
	const char *escape;
	int ch_count;
	int i;

	for (i = ch_count = 0; i < ARRAY_SIZE(kbd_to_ansi364); i++) {
57e13f9c:	03a02003 	moveq	r2, #3
		if (keycode != kbd_to_ansi364[i].kbd_scan_code)
57e13fa0:	1a000017 	bne	57e14004 <input_send_keycodes+0x258>
57e13fa4:	ea000009 	b	57e13fd0 <input_send_keycodes+0x224>
		/*
		 * For a normal key (with an ASCII value), add it; otherwise
		 * translate special key to escape sequence if possible.
		 */
		if (ch != 0xff) {
			if (ch_count < max_chars)
57e13fa8:	e159000a 	cmp	r9, sl
				output_ch[ch_count] = (uchar)ch;
57e13fac:	b51b2020 	ldrlt	r2, [fp, #-32]
57e13fb0:	b7c21009 	strblt	r1, [r2, r9]
			ch_count++;
57e13fb4:	e2899001 	add	r9, r9, #1
57e13fb8:	ea000013 	b	57e1400c <input_send_keycodes+0x260>
	const char *escape;
	int ch_count;
	int i;

	for (i = ch_count = 0; i < ARRAY_SIZE(kbd_to_ansi364); i++) {
		if (keycode != kbd_to_ansi364[i].kbd_scan_code)
57e13fbc:	e3a02000 	mov	r2, #0
57e13fc0:	ea000002 	b	57e13fd0 <input_send_keycodes+0x224>
{
	const char *escape;
	int ch_count;
	int i;

	for (i = ch_count = 0; i < ARRAY_SIZE(kbd_to_ansi364); i++) {
57e13fc4:	e3a02001 	mov	r2, #1
57e13fc8:	ea000000 	b	57e13fd0 <input_send_keycodes+0x224>
57e13fcc:	e3a02002 	mov	r2, #2
		if (keycode != kbd_to_ansi364[i].kbd_scan_code)
			continue;
		for (escape = kbd_to_ansi364[i].escape; *escape; escape++) {
57e13fd0:	e59f00d0 	ldr	r0, [pc, #208]	; 57e140a8 <input_send_keycodes+0x2fc>
57e13fd4:	e0802182 	add	r2, r0, r2, lsl #3
57e13fd8:	e592e038 	ldr	lr, [r2, #56]	; 0x38
{
	const char *escape;
	int ch_count;
	int i;

	for (i = ch_count = 0; i < ARRAY_SIZE(kbd_to_ansi364); i++) {
57e13fdc:	e3a02000 	mov	r2, #0
57e13fe0:	ea000003 	b	57e13ff4 <input_send_keycodes+0x248>
		if (keycode != kbd_to_ansi364[i].kbd_scan_code)
			continue;
		for (escape = kbd_to_ansi364[i].escape; *escape; escape++) {
			if (ch_count < max_chars)
57e13fe4:	e152000a 	cmp	r2, sl
				output_ch[ch_count] = *escape;
57e13fe8:	b51b0020 	ldrlt	r0, [fp, #-32]
57e13fec:	b7c01002 	strblt	r1, [r0, r2]
			ch_count++;
57e13ff0:	e2822001 	add	r2, r2, #1
	int i;

	for (i = ch_count = 0; i < ARRAY_SIZE(kbd_to_ansi364); i++) {
		if (keycode != kbd_to_ansi364[i].kbd_scan_code)
			continue;
		for (escape = kbd_to_ansi364[i].escape; *escape; escape++) {
57e13ff4:	e7de1002 	ldrb	r1, [lr, r2]
57e13ff8:	e3510000 	cmp	r1, #0
57e13ffc:	1afffff8 	bne	57e13fe4 <input_send_keycodes+0x238>
57e14000:	ea000000 	b	57e14008 <input_send_keycodes+0x25c>
			ch_count++;
		}
		return ch_count;
	}

	return 0;
57e14004:	e3a02000 	mov	r2, #0
		if (ch != 0xff) {
			if (ch_count < max_chars)
				output_ch[ch_count] = (uchar)ch;
			ch_count++;
		} else {
			ch_count += input_keycode_to_ansi364(config, key,
57e14008:	e0899002 	add	r9, r9, r2
					keycode[i] & KEY_RELEASE);
		}
	}

	/* Start conversion by looking for the first new keycode (by same). */
	for (i = same; i < num_keycodes; i++) {
57e1400c:	e2877001 	add	r7, r7, #1
57e14010:	e1570005 	cmp	r7, r5
57e14014:	baffffd1 	blt	57e13f60 <input_send_keycodes+0x1b4>
	}

	if (ch_count > max_chars) {
		debug("%s: Output char buffer overflow size=%d, need=%d\n",
		      __func__, max_chars, ch_count);
		return -1;
57e14018:	e159000a 	cmp	r9, sl
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, sizeof(ch), is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
57e1401c:	e3a03000 	mov	r3, #0
	}

	if (ch_count > max_chars) {
		debug("%s: Output char buffer overflow size=%d, need=%d\n",
		      __func__, max_chars, ch_count);
		return -1;
57e14020:	c3e09000 	mvngt	r9, #0
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
57e14024:	e1a00003 	mov	r0, r3
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, sizeof(ch), is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
57e14028:	ea000010 	b	57e14070 <input_send_keycodes+0x2c4>
/* Maximum number of output characters that an ANSI sequence expands to */
#define ANSI_CHAR_MAX	3

static int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
57e1402c:	e5942010 	ldr	r2, [r4, #16]
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, sizeof(ch), is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
		input_queue_ascii(config, ch[i]);
57e14030:	e51b1020 	ldr	r1, [fp, #-32]
/* Maximum number of output characters that an ANSI sequence expands to */
#define ANSI_CHAR_MAX	3

static int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
57e14034:	e352000f 	cmp	r2, #15
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, sizeof(ch), is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
		input_queue_ascii(config, ch[i]);
57e14038:	e7d1e003 	ldrb	lr, [r1, r3]
57e1403c:	e5941014 	ldr	r1, [r4, #20]
/* Maximum number of output characters that an ANSI sequence expands to */
#define ANSI_CHAR_MAX	3

static int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
57e14040:	1a000003 	bne	57e14054 <input_send_keycodes+0x2a8>
		if (!config->fifo_out)
57e14044:	e3510000 	cmp	r1, #0
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
57e14048:	15840010 	strne	r0, [r4, #16]
#define ANSI_CHAR_MAX	3

static int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
57e1404c:	1a000004 	bne	57e14064 <input_send_keycodes+0x2b8>
57e14050:	ea000005 	b	57e1406c <input_send_keycodes+0x2c0>
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
57e14054:	e2822001 	add	r2, r2, #1
57e14058:	e1520001 	cmp	r2, r1
57e1405c:	0a000002 	beq	57e1406c <input_send_keycodes+0x2c0>
			return -1; /* buffer full */
		config->fifo_in++;
57e14060:	e5842010 	str	r2, [r4, #16]
	}
	config->fifo[config->fifo_in] = (uchar)ch;
57e14064:	e5942010 	ldr	r2, [r4, #16]
57e14068:	e7c4e002 	strb	lr, [r4, r2]
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, sizeof(ch), is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
57e1406c:	e2833001 	add	r3, r3, #1
57e14070:	e1530009 	cmp	r3, r9
57e14074:	baffffec 	blt	57e1402c <input_send_keycodes+0x280>
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
57e14078:	e35c0000 	cmp	ip, #0
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
57e1407c:	e3a00000 	mov	r0, #0
	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, sizeof(ch), is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
57e14080:	159450ac 	ldrne	r5, [r4, #172]	; 0xac
57e14084:	059450a8 	ldreq	r5, [r4, #168]	; 0xa8
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
57e14088:	ebffb29f 	bl	57e00b0c <get_timer>
57e1408c:	e0800005 	add	r0, r0, r5
57e14090:	e58400a4 	str	r0, [r4, #164]	; 0xa4

	return count;
}
57e14094:	e1a00009 	mov	r0, r9
57e14098:	e24bd01c 	sub	sp, fp, #28
57e1409c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		 * have missed a repeat slot.
		 */
		is_repeat = config->repeat_rate_ms &&
			(int)get_timer(config->next_repeat_ms) >= 0;
		if (!is_repeat)
			return 0;
57e140a0:	e3a09000 	mov	r9, #0
57e140a4:	eafffffa 	b	57e14094 <input_send_keycodes+0x2e8>
57e140a8:	57e2c27c 	.word	0x57e2c27c

57e140ac <input_add_table>:
	return count;
}

int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
57e140ac:	e92d4010 	push	{r4, lr}
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
57e140b0:	e5d0c01b 	ldrb	ip, [r0, #27]
57e140b4:	e35c0004 	cmp	ip, #4
57e140b8:	0a00000b 	beq	57e140ec <input_add_table+0x40>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
57e140bc:	e28c4001 	add	r4, ip, #1
57e140c0:	e5c0401b 	strb	r4, [r0, #27]
	table->left_keycode = left_keycode;
57e140c4:	e28c4006 	add	r4, ip, #6
57e140c8:	e7801204 	str	r1, [r0, r4, lsl #4]
	table->right_keycode = right_keycode;
57e140cc:	e0804204 	add	r4, r0, r4, lsl #4
	table->xlate = xlate;
57e140d0:	e080020c 	add	r0, r0, ip, lsl #4
57e140d4:	e5803068 	str	r3, [r0, #104]	; 0x68
	table->num_entries = num_entries;
57e140d8:	e59d3008 	ldr	r3, [sp, #8]
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
57e140dc:	e5842004 	str	r2, [r4, #4]
	table->xlate = xlate;
	table->num_entries = num_entries;
57e140e0:	e580306c 	str	r3, [r0, #108]	; 0x6c

	return 0;
57e140e4:	e3a00000 	mov	r0, #0
57e140e8:	e8bd8010 	pop	{r4, pc}
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
57e140ec:	e3e00000 	mvn	r0, #0
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;

	return 0;
}
57e140f0:	e8bd8010 	pop	{r4, pc}

57e140f4 <input_set_delays>:

void input_set_delays(struct input_config *config, int repeat_delay_ms,
	       int repeat_rate_ms)
{
	config->repeat_delay_ms = repeat_delay_ms;
57e140f4:	e58010a8 	str	r1, [r0, #168]	; 0xa8
	config->repeat_rate_ms = repeat_rate_ms;
57e140f8:	e58020ac 	str	r2, [r0, #172]	; 0xac
}
57e140fc:	e12fff1e 	bx	lr

57e14100 <input_init>:

int input_init(struct input_config *config, int leds)
{
57e14100:	e92d4038 	push	{r3, r4, r5, lr}
	memset(config, '\0', sizeof(*config));
57e14104:	e3a020b0 	mov	r2, #176	; 0xb0
	config->repeat_delay_ms = repeat_delay_ms;
	config->repeat_rate_ms = repeat_rate_ms;
}

int input_init(struct input_config *config, int leds)
{
57e14108:	e1a04000 	mov	r4, r0
57e1410c:	e1a05001 	mov	r5, r1
	memset(config, '\0', sizeof(*config));
57e14110:	e3a01000 	mov	r1, #0
57e14114:	eb004058 	bl	57e2427c <memset>
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
57e14118:	e5d4301b 	ldrb	r3, [r4, #27]
}

int input_init(struct input_config *config, int leds)
{
	memset(config, '\0', sizeof(*config));
	config->leds = leds;
57e1411c:	e5c4501a 	strb	r5, [r4, #26]
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
57e14120:	e3530004 	cmp	r3, #4
57e14124:	0a00002b 	beq	57e141d8 <input_init+0xd8>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
57e14128:	e2831006 	add	r1, r3, #6
57e1412c:	e3e00000 	mvn	r0, #0
57e14130:	e7840201 	str	r0, [r4, r1, lsl #4]
	table->right_keycode = right_keycode;
57e14134:	e0841201 	add	r1, r4, r1, lsl #4
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
57e14138:	e2832001 	add	r2, r3, #1
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
57e1413c:	e5810004 	str	r0, [r1, #4]
	table->xlate = xlate;
57e14140:	e59f1098 	ldr	r1, [pc, #152]	; 57e141e0 <input_init+0xe0>
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
57e14144:	e20220ff 	and	r2, r2, #255	; 0xff
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
57e14148:	e0843203 	add	r3, r4, r3, lsl #4
57e1414c:	e5831068 	str	r1, [r3, #104]	; 0x68
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
57e14150:	e3520004 	cmp	r2, #4

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
57e14154:	e3a01063 	mov	r1, #99	; 0x63
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
57e14158:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
57e1415c:	e583106c 	str	r1, [r3, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
57e14160:	08bd8038 	popeq	{r3, r4, r5, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
57e14164:	e282c006 	add	ip, r2, #6
57e14168:	e3a0502a 	mov	r5, #42	; 0x2a
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
57e1416c:	e2823001 	add	r3, r2, #1
	table->left_keycode = left_keycode;
57e14170:	e784520c 	str	r5, [r4, ip, lsl #4]
	table->right_keycode = right_keycode;
57e14174:	e084c20c 	add	ip, r4, ip, lsl #4
57e14178:	e285500c 	add	r5, r5, #12
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
57e1417c:	e20330ff 	and	r3, r3, #255	; 0xff
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
57e14180:	e58c5004 	str	r5, [ip, #4]
	table->xlate = xlate;
57e14184:	e59fc058 	ldr	ip, [pc, #88]	; 57e141e4 <input_init+0xe4>
57e14188:	e0842202 	add	r2, r4, r2, lsl #4
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
57e1418c:	e3530004 	cmp	r3, #4
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
57e14190:	e5c4301b 	strb	r3, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
57e14194:	e582c068 	str	ip, [r2, #104]	; 0x68
	table->num_entries = num_entries;
57e14198:	e582106c 	str	r1, [r2, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
57e1419c:	08bd8038 	popeq	{r3, r4, r5, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
57e141a0:	e2832001 	add	r2, r3, #1
57e141a4:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
57e141a8:	e280001e 	add	r0, r0, #30
57e141ac:	e2832006 	add	r2, r3, #6
57e141b0:	e7840202 	str	r0, [r4, r2, lsl #4]
	table->right_keycode = right_keycode;
	table->xlate = xlate;
57e141b4:	e28cc064 	add	ip, ip, #100	; 0x64
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
57e141b8:	e0842202 	add	r2, r4, r2, lsl #4
57e141bc:	e2800044 	add	r0, r0, #68	; 0x44
	table->xlate = xlate;
57e141c0:	e0844203 	add	r4, r4, r3, lsl #4
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
57e141c4:	e5820004 	str	r0, [r2, #4]
	table->xlate = xlate;
57e141c8:	e584c068 	str	ip, [r4, #104]	; 0x68
	table->num_entries = num_entries;
57e141cc:	e584106c 	str	r1, [r4, #108]	; 0x6c
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
	}

	return 0;
57e141d0:	e3a00000 	mov	r0, #0
57e141d4:	e8bd8038 	pop	{r3, r4, r5, pc}
		input_add_table(config, KEY_LEFTSHIFT, KEY_RIGHTSHIFT,
			kbd_shift_xlate, ARRAY_SIZE(kbd_shift_xlate)) ||
		input_add_table(config, KEY_LEFTCTRL, KEY_RIGHTCTRL,
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
57e141d8:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
57e141dc:	e8bd8038 	pop	{r3, r4, r5, pc}
57e141e0:	57e2c2d0 	.word	0x57e2c2d0
57e141e4:	57e36e74 	.word	0x57e36e74

57e141e8 <input_stdio_register>:

int input_stdio_register(struct stdio_dev *dev)
{
57e141e8:	e92d4038 	push	{r3, r4, r5, lr}
57e141ec:	e1a04000 	mov	r4, r0
	int error;

	error = stdio_register(dev);
57e141f0:	ebffedeb 	bl	57e0f9a4 <stdio_register>

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
57e141f4:	e2505000 	subs	r5, r0, #0
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
57e141f8:	13a00000 	movne	r0, #0
	int error;

	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
57e141fc:	18bd8038 	popne	{r3, r4, r5, pc}
57e14200:	e59f0030 	ldr	r0, [pc, #48]	; 57e14238 <input_stdio_register+0x50>
57e14204:	e2844008 	add	r4, r4, #8
57e14208:	ebffcd36 	bl	57e076e8 <getenv>
57e1420c:	e1a01004 	mov	r1, r4
57e14210:	eb003f63 	bl	57e23fa4 <strcmp>
57e14214:	e3500000 	cmp	r0, #0
57e14218:	1a000004 	bne	57e14230 <input_stdio_register+0x48>
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
57e1421c:	e1a01004 	mov	r1, r4
57e14220:	ebffd4dd 	bl	57e0959c <console_assign>
	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
57e14224:	e3500000 	cmp	r0, #0
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
57e14228:	13e00000 	mvnne	r0, #0
57e1422c:	e8bd8038 	pop	{r3, r4, r5, pc}
57e14230:	e1a00005 	mov	r0, r5
}
57e14234:	e8bd8038 	pop	{r3, r4, r5, pc}
57e14238:	57e31de4 	.word	0x57e31de4

57e1423c <flash_make_cmd>:

/*-----------------------------------------------------------------------
 * make a proper sized command based on the port and chip widths
 */
static void flash_make_cmd(flash_info_t *info, u32 cmd, void *cmdbuf)
{
57e1423c:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
57e14240:	e1a04000 	mov	r4, r0
57e14244:	e1a07002 	mov	r7, r2
	int i;
	int cword_offset;
	int cp_offset;
#if defined(__LITTLE_ENDIAN) || defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
	u32 cmd_le = cpu_to_le32(cmd);
57e14248:	e58d1004 	str	r1, [sp, #4]
#endif
	uchar val;
	uchar *cp = (uchar *) cmdbuf;

	for (i = info->portwidth; i > 0; i--){
57e1424c:	e5d050d4 	ldrb	r5, [r0, #212]	; 0xd4
57e14250:	ea00000a 	b	57e14280 <flash_make_cmd+0x44>
		cword_offset = (info->portwidth-i)%info->chipwidth;
57e14254:	e5d460d4 	ldrb	r6, [r4, #212]	; 0xd4
57e14258:	e5d410d5 	ldrb	r1, [r4, #213]	; 0xd5
57e1425c:	e0656006 	rsb	r6, r5, r6
57e14260:	e1a00006 	mov	r0, r6
57e14264:	eb005e5c 	bl	57e2bbdc <__aeabi_idivmod>
#if defined(__LITTLE_ENDIAN) || defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
		cp_offset = info->portwidth - i;
		val = *((uchar*)&cmd_le + cword_offset);
57e14268:	e28d3004 	add	r3, sp, #4
57e1426c:	e7d33001 	ldrb	r3, [r3, r1]
#else
		cp_offset = i - 1;
		val = *((uchar*)&cmd + sizeof(u32) - cword_offset - 1);
#endif
		cp[cp_offset] = (cword_offset >= sizeof(u32)) ? 0x00 : val;
57e14270:	e3510003 	cmp	r1, #3
57e14274:	83a03000 	movhi	r3, #0
57e14278:	e7c73006 	strb	r3, [r7, r6]
	u32 cmd_le = cpu_to_le32(cmd);
#endif
	uchar val;
	uchar *cp = (uchar *) cmdbuf;

	for (i = info->portwidth; i > 0; i--){
57e1427c:	e2455001 	sub	r5, r5, #1
57e14280:	e3550000 	cmp	r5, #0
57e14284:	1afffff2 	bne	57e14254 <flash_make_cmd+0x18>
		cp_offset = i - 1;
		val = *((uchar*)&cmd + sizeof(u32) - cword_offset - 1);
#endif
		cp[cp_offset] = (cword_offset >= sizeof(u32)) ? 0x00 : val;
	}
}
57e14288:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

57e1428c <flash_isequal>:

/*-----------------------------------------------------------------------
 */
static int flash_isequal (flash_info_t * info, flash_sect_t sect,
			  uint offset, uchar cmd)
{
57e1428c:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e14290:	e5d050d4 	ldrb	r5, [r0, #212]	; 0xd4

	return (void *)(info->start[sect] + byte_offset);
57e14294:	e0801101 	add	r1, r0, r1, lsl #2
57e14298:	e591400c 	ldr	r4, [r1, #12]

/*-----------------------------------------------------------------------
 */
static int flash_isequal (flash_info_t * info, flash_sect_t sect,
			  uint offset, uchar cmd)
{
57e1429c:	e1a06000 	mov	r6, r0
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e142a0:	e0050592 	mul	r5, r2, r5
	void *addr;
	cfiword_t cword;
	int retval;

	addr = flash_map (info, sect, offset);
	flash_make_cmd (info, cmd, &cword);
57e142a4:	e1a01003 	mov	r1, r3
57e142a8:	e1a0200d 	mov	r2, sp
57e142ac:	ebffffe2 	bl	57e1423c <flash_make_cmd>

	debug ("is= cmd %x(%c) addr %p ", cmd, cmd, addr);
	switch (info->portwidth) {
57e142b0:	e5d630d4 	ldrb	r3, [r6, #212]	; 0xd4
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;

	return (void *)(info->start[sect] + byte_offset);
57e142b4:	e0857004 	add	r7, r5, r4

	addr = flash_map (info, sect, offset);
	flash_make_cmd (info, cmd, &cword);

	debug ("is= cmd %x(%c) addr %p ", cmd, cmd, addr);
	switch (info->portwidth) {
57e142b8:	e2433001 	sub	r3, r3, #1
57e142bc:	e3530007 	cmp	r3, #7
57e142c0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e142c4:	ea00001b 	b	57e14338 <flash_isequal+0xac>
57e142c8:	57e142e8 	.word	0x57e142e8
57e142cc:	57e142f4 	.word	0x57e142f4
57e142d0:	57e14338 	.word	0x57e14338
57e142d4:	57e14300 	.word	0x57e14300
57e142d8:	57e14338 	.word	0x57e14338
57e142dc:	57e14338 	.word	0x57e14338
57e142e0:	57e14338 	.word	0x57e14338
57e142e4:	57e14318 	.word	0x57e14318
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e142e8:	e7d53004 	ldrb	r3, [r5, r4]

	debug ("is= cmd %x(%c) addr %p ", cmd, cmd, addr);
	switch (info->portwidth) {
	case FLASH_CFI_8BIT:
		debug ("is= %x %x\n", flash_read8(addr), cword.c);
		retval = (flash_read8(addr) == cword.c);
57e142ec:	e5dd0000 	ldrb	r0, [sp]
57e142f0:	ea000004 	b	57e14308 <flash_isequal+0x7c>
	return __raw_readb(addr);
}

static u16 __flash_read16(void *addr)
{
	return __raw_readw(addr);
57e142f4:	e19530b4 	ldrh	r3, [r5, r4]
		debug ("is= %x %x\n", flash_read8(addr), cword.c);
		retval = (flash_read8(addr) == cword.c);
		break;
	case FLASH_CFI_16BIT:
		debug ("is= %4.4x %4.4x\n", flash_read16(addr), cword.w);
		retval = (flash_read16(addr) == cword.w);
57e142f8:	e1dd00b0 	ldrh	r0, [sp]
57e142fc:	ea000001 	b	57e14308 <flash_isequal+0x7c>
	return __raw_readw(addr);
}

static u32 __flash_read32(void *addr)
{
	return __raw_readl(addr);
57e14300:	e7950004 	ldr	r0, [r5, r4]
		debug ("is= %4.4x %4.4x\n", flash_read16(addr), cword.w);
		retval = (flash_read16(addr) == cword.w);
		break;
	case FLASH_CFI_32BIT:
		debug ("is= %8.8x %8.8lx\n", flash_read32(addr), cword.l);
		retval = (flash_read32(addr) == cword.l);
57e14304:	e59d3000 	ldr	r3, [sp]
57e14308:	e1500003 	cmp	r0, r3
57e1430c:	13a00000 	movne	r0, #0
57e14310:	03a00001 	moveq	r0, #1
		break;
57e14314:	ea000008 	b	57e1433c <flash_isequal+0xb0>
}

static u64 __flash_read64(void *addr)
{
	/* No architectures currently implement __raw_readq() */
	return *(volatile u64 *)addr;
57e14318:	e8970006 	ldm	r7, {r1, r2}
			print_longlong (str1, flash_read64(addr));
			print_longlong (str2, cword.ll);
			debug ("is= %s %s\n", str1, str2);
		}
#endif
		retval = (flash_read64(addr) == cword.ll);
57e1431c:	e89d0018 	ldm	sp, {r3, r4}
57e14320:	e0233001 	eor	r3, r3, r1
57e14324:	e0244002 	eor	r4, r4, r2
57e14328:	e1932004 	orrs	r2, r3, r4
57e1432c:	13a00000 	movne	r0, #0
57e14330:	03a00001 	moveq	r0, #1
		break;
57e14334:	ea000000 	b	57e1433c <flash_isequal+0xb0>
	default:
		retval = 0;
57e14338:	e3a00000 	mov	r0, #0
		break;
	}
	flash_unmap(info, sect, offset, addr);

	return retval;
}
57e1433c:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

57e14340 <flash_isset>:

/*-----------------------------------------------------------------------
 */
static int flash_isset (flash_info_t * info, flash_sect_t sect,
			uint offset, uchar cmd)
{
57e14340:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e14344:	e5d050d4 	ldrb	r5, [r0, #212]	; 0xd4

	return (void *)(info->start[sect] + byte_offset);
57e14348:	e0801101 	add	r1, r0, r1, lsl #2
57e1434c:	e591400c 	ldr	r4, [r1, #12]

/*-----------------------------------------------------------------------
 */
static int flash_isset (flash_info_t * info, flash_sect_t sect,
			uint offset, uchar cmd)
{
57e14350:	e1a06000 	mov	r6, r0
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e14354:	e0050592 	mul	r5, r2, r5
	void *addr;
	cfiword_t cword;
	int retval;

	addr = flash_map (info, sect, offset);
	flash_make_cmd (info, cmd, &cword);
57e14358:	e1a01003 	mov	r1, r3
57e1435c:	e1a0200d 	mov	r2, sp
57e14360:	ebffffb5 	bl	57e1423c <flash_make_cmd>
	switch (info->portwidth) {
57e14364:	e5d630d4 	ldrb	r3, [r6, #212]	; 0xd4
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;

	return (void *)(info->start[sect] + byte_offset);
57e14368:	e0857004 	add	r7, r5, r4
	cfiword_t cword;
	int retval;

	addr = flash_map (info, sect, offset);
	flash_make_cmd (info, cmd, &cword);
	switch (info->portwidth) {
57e1436c:	e2433001 	sub	r3, r3, #1
57e14370:	e3530007 	cmp	r3, #7
57e14374:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e14378:	ea00001c 	b	57e143f0 <flash_isset+0xb0>
57e1437c:	57e1439c 	.word	0x57e1439c
57e14380:	57e143a8 	.word	0x57e143a8
57e14384:	57e143f0 	.word	0x57e143f0
57e14388:	57e143b4 	.word	0x57e143b4
57e1438c:	57e143f0 	.word	0x57e143f0
57e14390:	57e143f0 	.word	0x57e143f0
57e14394:	57e143f0 	.word	0x57e143f0
57e14398:	57e143d0 	.word	0x57e143d0
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e1439c:	e7d50004 	ldrb	r0, [r5, r4]

	addr = flash_map (info, sect, offset);
	flash_make_cmd (info, cmd, &cword);
	switch (info->portwidth) {
	case FLASH_CFI_8BIT:
		retval = ((flash_read8(addr) & cword.c) == cword.c);
57e143a0:	e5dd3000 	ldrb	r3, [sp]
57e143a4:	ea000004 	b	57e143bc <flash_isset+0x7c>
	return __raw_readb(addr);
}

static u16 __flash_read16(void *addr)
{
	return __raw_readw(addr);
57e143a8:	e19500b4 	ldrh	r0, [r5, r4]
	switch (info->portwidth) {
	case FLASH_CFI_8BIT:
		retval = ((flash_read8(addr) & cword.c) == cword.c);
		break;
	case FLASH_CFI_16BIT:
		retval = ((flash_read16(addr) & cword.w) == cword.w);
57e143ac:	e1dd30b0 	ldrh	r3, [sp]
57e143b0:	ea000001 	b	57e143bc <flash_isset+0x7c>
	return __raw_readw(addr);
}

static u32 __flash_read32(void *addr)
{
	return __raw_readl(addr);
57e143b4:	e7950004 	ldr	r0, [r5, r4]
		break;
	case FLASH_CFI_16BIT:
		retval = ((flash_read16(addr) & cword.w) == cword.w);
		break;
	case FLASH_CFI_32BIT:
		retval = ((flash_read32(addr) & cword.l) == cword.l);
57e143b8:	e59d3000 	ldr	r3, [sp]
57e143bc:	e0000003 	and	r0, r0, r3
57e143c0:	e1500003 	cmp	r0, r3
57e143c4:	13a00000 	movne	r0, #0
57e143c8:	03a00001 	moveq	r0, #1
		break;
57e143cc:	ea000008 	b	57e143f4 <flash_isset+0xb4>
	case FLASH_CFI_64BIT:
		retval = ((flash_read64(addr) & cword.ll) == cword.ll);
57e143d0:	e89d0006 	ldm	sp, {r1, r2}
}

static u64 __flash_read64(void *addr)
{
	/* No architectures currently implement __raw_readq() */
	return *(volatile u64 *)addr;
57e143d4:	e8970018 	ldm	r7, {r3, r4}
		break;
	case FLASH_CFI_32BIT:
		retval = ((flash_read32(addr) & cword.l) == cword.l);
		break;
	case FLASH_CFI_64BIT:
		retval = ((flash_read64(addr) & cword.ll) == cword.ll);
57e143d8:	e1c13003 	bic	r3, r1, r3
57e143dc:	e1c24004 	bic	r4, r2, r4
57e143e0:	e1932004 	orrs	r2, r3, r4
57e143e4:	13a00000 	movne	r0, #0
57e143e8:	03a00001 	moveq	r0, #1
		break;
57e143ec:	ea000000 	b	57e143f4 <flash_isset+0xb4>
	default:
		retval = 0;
57e143f0:	e3a00000 	mov	r0, #0
		break;
	}
	flash_unmap(info, sect, offset, addr);

	return retval;
}
57e143f4:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

57e143f8 <find_sector>:
 */
static flash_sect_t find_sector (flash_info_t * info, ulong addr)
{
	static flash_sect_t saved_sector; /* previously found sector */
	static flash_info_t *saved_info; /* previously used flash bank */
	flash_sect_t sector = saved_sector;
57e143f8:	e59f2078 	ldr	r2, [pc, #120]	; 57e14478 <find_sector+0x80>
/*
 * Loop through the sector table starting from the previously found sector.
 * Searches forwards or backwards, dependent on the passed address.
 */
static flash_sect_t find_sector (flash_info_t * info, ulong addr)
{
57e143fc:	e1a03000 	mov	r3, r0
	static flash_sect_t saved_sector; /* previously found sector */
	static flash_info_t *saved_info; /* previously used flash bank */
	flash_sect_t sector = saved_sector;
57e14400:	e8920005 	ldm	r2, {r0, r2}

	if ((info != saved_info) || (sector >= info->sector_count))
57e14404:	e1530002 	cmp	r3, r2
		sector = 0;
57e14408:	13a00000 	movne	r0, #0
{
	static flash_sect_t saved_sector; /* previously found sector */
	static flash_info_t *saved_info; /* previously used flash bank */
	flash_sect_t sector = saved_sector;

	if ((info != saved_info) || (sector >= info->sector_count))
57e1440c:	1a000002 	bne	57e1441c <find_sector+0x24>
57e14410:	e1d320b4 	ldrh	r2, [r3, #4]
		sector = 0;
57e14414:	e1500002 	cmp	r0, r2
57e14418:	23a00000 	movcs	r0, #0

/*
 * Loop through the sector table starting from the previously found sector.
 * Searches forwards or backwards, dependent on the passed address.
 */
static flash_sect_t find_sector (flash_info_t * info, ulong addr)
57e1441c:	e0832100 	add	r2, r3, r0, lsl #2
57e14420:	e2822008 	add	r2, r2, #8
57e14424:	ea000000 	b	57e1442c <find_sector+0x34>
	if ((info != saved_info) || (sector >= info->sector_count))
		sector = 0;

	while ((info->start[sector] < addr)
			&& (sector < info->sector_count - 1))
		sector++;
57e14428:	e2800001 	add	r0, r0, #1
	flash_sect_t sector = saved_sector;

	if ((info != saved_info) || (sector >= info->sector_count))
		sector = 0;

	while ((info->start[sector] < addr)
57e1442c:	e5b2c004 	ldr	ip, [r2, #4]!
57e14430:	e15c0001 	cmp	ip, r1
57e14434:	3a000002 	bcc	57e14444 <find_sector+0x4c>

/*
 * Loop through the sector table starting from the previously found sector.
 * Searches forwards or backwards, dependent on the passed address.
 */
static flash_sect_t find_sector (flash_info_t * info, ulong addr)
57e14438:	e0832100 	add	r2, r3, r0, lsl #2
57e1443c:	e2822010 	add	r2, r2, #16
57e14440:	ea000005 	b	57e1445c <find_sector+0x64>

	if ((info != saved_info) || (sector >= info->sector_count))
		sector = 0;

	while ((info->start[sector] < addr)
			&& (sector < info->sector_count - 1))
57e14444:	e1d3c0b4 	ldrh	ip, [r3, #4]
57e14448:	e24cc001 	sub	ip, ip, #1
57e1444c:	e150000c 	cmp	r0, ip
57e14450:	3afffff4 	bcc	57e14428 <find_sector+0x30>
57e14454:	eafffff7 	b	57e14438 <find_sector+0x40>
	while ((info->start[sector] > addr) && (sector > 0))
		/*
		 * also decrements the sector in case of an overshot
		 * in the first loop
		 */
		sector--;
57e14458:	e2400001 	sub	r0, r0, #1
		sector = 0;

	while ((info->start[sector] < addr)
			&& (sector < info->sector_count - 1))
		sector++;
	while ((info->start[sector] > addr) && (sector > 0))
57e1445c:	e532c004 	ldr	ip, [r2, #-4]!
57e14460:	e3500000 	cmp	r0, #0
57e14464:	115c0001 	cmpne	ip, r1
57e14468:	8afffffa 	bhi	57e14458 <find_sector+0x60>
		 * also decrements the sector in case of an overshot
		 * in the first loop
		 */
		sector--;

	saved_sector = sector;
57e1446c:	e59f2004 	ldr	r2, [pc, #4]	; 57e14478 <find_sector+0x80>
57e14470:	e8820009 	stm	r2, {r0, r3}
	saved_info = info;
	return sector;
}
57e14474:	e12fff1e 	bx	lr
57e14478:	57e4767c 	.word	0x57e4767c

57e1447c <cfi_reverse_geometry>:
static void cfi_reverse_geometry(struct cfi_qry *qry)
{
	unsigned int i, j;
	u32 tmp;

	for (i = 0, j = qry->num_erase_regions - 1; i < j; i++, j--) {
57e1447c:	e5d0c01c 	ldrb	ip, [r0, #28]
 * Reverse the order of the erase regions in the CFI QRY structure.
 * This is needed for chips that are either a) correctly detected as
 * top-boot, or b) buggy.
 */
static void cfi_reverse_geometry(struct cfi_qry *qry)
{
57e14480:	e92d4070 	push	{r4, r5, r6, lr}
	unsigned int i, j;
	u32 tmp;

	for (i = 0, j = qry->num_erase_regions - 1; i < j; i++, j--) {
57e14484:	e24cc001 	sub	ip, ip, #1
57e14488:	e3a01000 	mov	r1, #0
57e1448c:	ea000021 	b	57e14518 <cfi_reverse_geometry+0x9c>
		tmp = qry->erase_region_info[i];
57e14490:	e2812006 	add	r2, r1, #6
57e14494:	e0802102 	add	r2, r0, r2, lsl #2
57e14498:	e5d23005 	ldrb	r3, [r2, #5]
57e1449c:	e5d24006 	ldrb	r4, [r2, #6]
static void cfi_reverse_geometry(struct cfi_qry *qry)
{
	unsigned int i, j;
	u32 tmp;

	for (i = 0, j = qry->num_erase_regions - 1; i < j; i++, j--) {
57e144a0:	e2811001 	add	r1, r1, #1
		tmp = qry->erase_region_info[i];
57e144a4:	e1834404 	orr	r4, r3, r4, lsl #8
57e144a8:	e5d23007 	ldrb	r3, [r2, #7]
57e144ac:	e1844803 	orr	r4, r4, r3, lsl #16
57e144b0:	e5d23008 	ldrb	r3, [r2, #8]
57e144b4:	e1844c03 	orr	r4, r4, r3, lsl #24
		qry->erase_region_info[i] = qry->erase_region_info[j];
57e144b8:	e28c3006 	add	r3, ip, #6
57e144bc:	e0803103 	add	r3, r0, r3, lsl #2
57e144c0:	e5d36006 	ldrb	r6, [r3, #6]
57e144c4:	e5d35005 	ldrb	r5, [r3, #5]
static void cfi_reverse_geometry(struct cfi_qry *qry)
{
	unsigned int i, j;
	u32 tmp;

	for (i = 0, j = qry->num_erase_regions - 1; i < j; i++, j--) {
57e144c8:	e24cc001 	sub	ip, ip, #1
		tmp = qry->erase_region_info[i];
		qry->erase_region_info[i] = qry->erase_region_info[j];
57e144cc:	e1855406 	orr	r5, r5, r6, lsl #8
57e144d0:	e5d36007 	ldrb	r6, [r3, #7]
57e144d4:	e1855806 	orr	r5, r5, r6, lsl #16
57e144d8:	e5d36008 	ldrb	r6, [r3, #8]
57e144dc:	e1855c06 	orr	r5, r5, r6, lsl #24
57e144e0:	e1a06425 	lsr	r6, r5, #8
57e144e4:	e5c25005 	strb	r5, [r2, #5]
57e144e8:	e5c26006 	strb	r6, [r2, #6]
57e144ec:	e1a06825 	lsr	r6, r5, #16
57e144f0:	e1a05c25 	lsr	r5, r5, #24
57e144f4:	e5c26007 	strb	r6, [r2, #7]
57e144f8:	e5c25008 	strb	r5, [r2, #8]
		qry->erase_region_info[j] = tmp;
57e144fc:	e1a02424 	lsr	r2, r4, #8
57e14500:	e5c34005 	strb	r4, [r3, #5]
57e14504:	e5c32006 	strb	r2, [r3, #6]
57e14508:	e1a02824 	lsr	r2, r4, #16
57e1450c:	e1a04c24 	lsr	r4, r4, #24
57e14510:	e5c32007 	strb	r2, [r3, #7]
57e14514:	e5c34008 	strb	r4, [r3, #8]
static void cfi_reverse_geometry(struct cfi_qry *qry)
{
	unsigned int i, j;
	u32 tmp;

	for (i = 0, j = qry->num_erase_regions - 1; i < j; i++, j--) {
57e14518:	e151000c 	cmp	r1, ip
57e1451c:	3affffdb 	bcc	57e14490 <cfi_reverse_geometry+0x14>
		tmp = qry->erase_region_info[i];
		qry->erase_region_info[i] = qry->erase_region_info[j];
		qry->erase_region_info[j] = tmp;
	}
}
57e14520:	e8bd8070 	pop	{r4, r5, r6, pc}

57e14524 <flash_add_byte.clone.6>:
	unsigned short	w;
	unsigned int	l;
	unsigned long long ll;
#endif

	switch (info->portwidth) {
57e14524:	e2400001 	sub	r0, r0, #1
	return ERR_OK;
}

/*-----------------------------------------------------------------------
 */
static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c)
57e14528:	e92d4810 	push	{r4, fp, lr}
	unsigned short	w;
	unsigned int	l;
	unsigned long long ll;
#endif

	switch (info->portwidth) {
57e1452c:	e3500007 	cmp	r0, #7
57e14530:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
57e14534:	ea00001f 	b	57e145b8 <flash_add_byte.clone.6+0x94>
57e14538:	57e14558 	.word	0x57e14558
57e1453c:	57e14560 	.word	0x57e14560
57e14540:	57e145b8 	.word	0x57e145b8
57e14544:	57e14574 	.word	0x57e14574
57e14548:	57e145b8 	.word	0x57e145b8
57e1454c:	57e145b8 	.word	0x57e145b8
57e14550:	57e145b8 	.word	0x57e145b8
57e14554:	57e14588 	.word	0x57e14588
	case FLASH_CFI_8BIT:
		cword->c = c;
57e14558:	e5c12000 	strb	r2, [r1]
57e1455c:	e8bd8810 	pop	{r4, fp, pc}
		break;
	case FLASH_CFI_16BIT:
#if defined(__LITTLE_ENDIAN) && !defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
		w = c;
		w <<= 8;
		cword->w = (cword->w >> 8) | w;
57e14560:	e1d130b0 	ldrh	r3, [r1]
57e14564:	e1a03423 	lsr	r3, r3, #8
57e14568:	e1832402 	orr	r2, r3, r2, lsl #8
57e1456c:	e1c120b0 	strh	r2, [r1]
57e14570:	e8bd8810 	pop	{r4, fp, pc}
		break;
	case FLASH_CFI_32BIT:
#if defined(__LITTLE_ENDIAN) && !defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
		l = c;
		l <<= 24;
		cword->l = (cword->l >> 8) | l;
57e14574:	e5913000 	ldr	r3, [r1]
57e14578:	e1a03423 	lsr	r3, r3, #8
57e1457c:	e1832c02 	orr	r2, r3, r2, lsl #24
57e14580:	e5812000 	str	r2, [r1]
57e14584:	e8bd8810 	pop	{r4, fp, pc}
#endif
		break;
	case FLASH_CFI_64BIT:
#if defined(__LITTLE_ENDIAN) && !defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
		ll = c;
		ll <<= 56;
57e14588:	e1a02c02 	lsl	r2, r2, #24
		cword->ll = (cword->ll >> 8) | ll;
57e1458c:	e5910000 	ldr	r0, [r1]
#endif
		break;
	case FLASH_CFI_64BIT:
#if defined(__LITTLE_ENDIAN) && !defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
		ll = c;
		ll <<= 56;
57e14590:	e1a0c002 	mov	ip, r2
57e14594:	e3a03000 	mov	r3, #0
		cword->ll = (cword->ll >> 8) | ll;
57e14598:	e5912004 	ldr	r2, [r1, #4]
#endif
		break;
	case FLASH_CFI_64BIT:
#if defined(__LITTLE_ENDIAN) && !defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
		ll = c;
		ll <<= 56;
57e1459c:	e1a0b003 	mov	fp, r3
		cword->ll = (cword->ll >> 8) | ll;
57e145a0:	e1a03420 	lsr	r3, r0, #8
57e145a4:	e1833c02 	orr	r3, r3, r2, lsl #24
57e145a8:	e1a04422 	lsr	r4, r2, #8
57e145ac:	e183300b 	orr	r3, r3, fp
57e145b0:	e184400c 	orr	r4, r4, ip
57e145b4:	e8810018 	stm	r1, {r3, r4}
57e145b8:	e8bd8810 	pop	{r4, fp, pc}

57e145bc <cfi_flash_bank_addr>:
#endif

static phys_addr_t __cfi_flash_bank_addr(int i)
{
	return ((phys_addr_t [])CONFIG_SYS_FLASH_BANKS_LIST)[i];
}
57e145bc:	e3a00201 	mov	r0, #268435456	; 0x10000000
57e145c0:	e12fff1e 	bx	lr

57e145c4 <cfi_flash_bank_size>:
#ifdef CONFIG_SYS_FLASH_BANKS_SIZES
	return ((unsigned long [])CONFIG_SYS_FLASH_BANKS_SIZES)[i];
#else
	return 0;
#endif
}
57e145c4:	e3a00000 	mov	r0, #0
57e145c8:	e12fff1e 	bx	lr

57e145cc <flash_sector_size>:
}
#endif

unsigned long flash_sector_size(flash_info_t *info, flash_sect_t sect)
{
	if (sect != (info->sector_count - 1))
57e145cc:	e1d030b4 	ldrh	r3, [r0, #4]
57e145d0:	e2432001 	sub	r2, r3, #1
57e145d4:	e1510002 	cmp	r1, r2
57e145d8:	0a000004 	beq	57e145f0 <flash_sector_size+0x24>
		return info->start[sect + 1] - info->start[sect];
57e145dc:	e0803101 	add	r3, r0, r1, lsl #2
57e145e0:	e5932010 	ldr	r2, [r3, #16]
57e145e4:	e593300c 	ldr	r3, [r3, #12]
57e145e8:	e0630002 	rsb	r0, r3, r2
57e145ec:	e12fff1e 	bx	lr
	else
		return info->start[0] + info->size - info->start[sect];
57e145f0:	e5901000 	ldr	r1, [r0]
57e145f4:	e590200c 	ldr	r2, [r0, #12]
57e145f8:	e0800103 	add	r0, r0, r3, lsl #2
57e145fc:	e5903008 	ldr	r3, [r0, #8]
57e14600:	e0812002 	add	r2, r1, r2
57e14604:	e0630002 	rsb	r0, r3, r2
}
57e14608:	e12fff1e 	bx	lr

57e1460c <flash_write_cmd>:
/*
 * Write a proper sized command to the correct address
 */
void flash_write_cmd (flash_info_t * info, flash_sect_t sect,
		      uint offset, u32 cmd)
{
57e1460c:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e14610:	e5d050d4 	ldrb	r5, [r0, #212]	; 0xd4

	return (void *)(info->start[sect] + byte_offset);
57e14614:	e0801101 	add	r1, r0, r1, lsl #2
57e14618:	e591400c 	ldr	r4, [r1, #12]
/*
 * Write a proper sized command to the correct address
 */
void flash_write_cmd (flash_info_t * info, flash_sect_t sect,
		      uint offset, u32 cmd)
{
57e1461c:	e1a06000 	mov	r6, r0
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e14620:	e0050592 	mul	r5, r2, r5

	void *addr;
	cfiword_t cword;

	addr = flash_map (info, sect, offset);
	flash_make_cmd (info, cmd, &cword);
57e14624:	e1a01003 	mov	r1, r3
57e14628:	e1a0200d 	mov	r2, sp
57e1462c:	ebffff02 	bl	57e1423c <flash_make_cmd>
	switch (info->portwidth) {
57e14630:	e5d630d4 	ldrb	r3, [r6, #212]	; 0xd4
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;

	return (void *)(info->start[sect] + byte_offset);
57e14634:	e0857004 	add	r7, r5, r4
	void *addr;
	cfiword_t cword;

	addr = flash_map (info, sect, offset);
	flash_make_cmd (info, cmd, &cword);
	switch (info->portwidth) {
57e14638:	e2433001 	sub	r3, r3, #1
57e1463c:	e3530007 	cmp	r3, #7
57e14640:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e14644:	ea000012 	b	57e14694 <flash_write_cmd+0x88>
57e14648:	57e14668 	.word	0x57e14668
57e1464c:	57e14674 	.word	0x57e14674
57e14650:	57e14694 	.word	0x57e14694
57e14654:	57e14680 	.word	0x57e14680
57e14658:	57e14694 	.word	0x57e14694
57e1465c:	57e14694 	.word	0x57e14694
57e14660:	57e14694 	.word	0x57e14694
57e14664:	57e1468c 	.word	0x57e1468c
	case FLASH_CFI_8BIT:
		debug ("fwc addr %p cmd %x %x 8bit x %d bit\n", addr, cmd,
		       cword.c, info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
		flash_write8(cword.c, addr);
57e14668:	e5dd3000 	ldrb	r3, [sp]
unsigned long cfi_flash_bank_size(int i)
	__attribute__((weak, alias("__cfi_flash_bank_size")));

static void __flash_write8(u8 value, void *addr)
{
	__raw_writeb(value, addr);
57e1466c:	e7c53004 	strb	r3, [r5, r4]
57e14670:	ea000007 	b	57e14694 <flash_write_cmd+0x88>
		break;
	case FLASH_CFI_16BIT:
		debug ("fwc addr %p cmd %x %4.4x 16bit x %d bit\n", addr,
		       cmd, cword.w,
		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
		flash_write16(cword.w, addr);
57e14674:	e1dd30b0 	ldrh	r3, [sp]
	__raw_writeb(value, addr);
}

static void __flash_write16(u16 value, void *addr)
{
	__raw_writew(value, addr);
57e14678:	e18530b4 	strh	r3, [r5, r4]
57e1467c:	ea000004 	b	57e14694 <flash_write_cmd+0x88>
		break;
	case FLASH_CFI_32BIT:
		debug ("fwc addr %p cmd %x %8.8lx 32bit x %d bit\n", addr,
		       cmd, cword.l,
		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
		flash_write32(cword.l, addr);
57e14680:	e59d3000 	ldr	r3, [sp]
	__raw_writew(value, addr);
}

static void __flash_write32(u32 value, void *addr)
{
	__raw_writel(value, addr);
57e14684:	e7853004 	str	r3, [r5, r4]
57e14688:	ea000001 	b	57e14694 <flash_write_cmd+0x88>
			debug ("fwrite addr %p cmd %x %s 64 bit x %d bit\n",
			       addr, cmd, str,
			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
		}
#endif
		flash_write64(cword.ll, addr);
57e1468c:	e89d0018 	ldm	sp, {r3, r4}
}

static void __flash_write64(u64 value, void *addr)
{
	/* No architectures currently implement __raw_writeq() */
	*(volatile u64 *)addr = value;
57e14690:	e8870018 	stm	r7, {r3, r4}

	/* Ensure all the instructions are fully finished */
	sync();

	flash_unmap(info, sect, offset, addr);
}
57e14694:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

57e14698 <cmdset_intel_read_jedec_ids>:
 * Note: assume cfi->vendor, cfi->portwidth and cfi->chipwidth are correct
 *
 */
static void cmdset_intel_read_jedec_ids(flash_info_t *info)
{
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e14698:	e3a01000 	mov	r1, #0
 *
 * Note: assume cfi->vendor, cfi->portwidth and cfi->chipwidth are correct
 *
 */
static void cmdset_intel_read_jedec_ids(flash_info_t *info)
{
57e1469c:	e92d4010 	push	{r4, lr}
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e146a0:	e1a02001 	mov	r2, r1
57e146a4:	e3a030ff 	mov	r3, #255	; 0xff
 *
 * Note: assume cfi->vendor, cfi->portwidth and cfi->chipwidth are correct
 *
 */
static void cmdset_intel_read_jedec_ids(flash_info_t *info)
{
57e146a8:	e1a04000 	mov	r4, r0
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e146ac:	ebffffd6 	bl	57e1460c <flash_write_cmd>
	udelay(1);
57e146b0:	e3a00001 	mov	r0, #1
57e146b4:	eb003f9f 	bl	57e24538 <udelay>
	flash_write_cmd(info, 0, 0, FLASH_CMD_READ_ID);
57e146b8:	e3a01000 	mov	r1, #0
57e146bc:	e1a02001 	mov	r2, r1
57e146c0:	e1a00004 	mov	r0, r4
57e146c4:	e3a03090 	mov	r3, #144	; 0x90
57e146c8:	ebffffcf 	bl	57e1460c <flash_write_cmd>
	udelay(1000); /* some flash are slow to respond */
57e146cc:	e3a00ffa 	mov	r0, #1000	; 0x3e8
57e146d0:	eb003f98 	bl	57e24538 <udelay>
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;

	return (void *)(info->start[sect] + byte_offset);
57e146d4:	e594300c 	ldr	r3, [r4, #12]
	info->manufacturer_id = flash_read_uchar (info,
					FLASH_OFFSET_MANUFACTURER_ID);
	info->device_id = (info->chipwidth == FLASH_CFI_16BIT) ?
			flash_read_word (info, FLASH_OFFSET_DEVICE_ID) :
			flash_read_uchar (info, FLASH_OFFSET_DEVICE_ID);
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e146d8:	e3a01000 	mov	r1, #0
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e146dc:	e5d32000 	ldrb	r2, [r3]
	info->manufacturer_id = flash_read_uchar (info,
					FLASH_OFFSET_MANUFACTURER_ID);
	info->device_id = (info->chipwidth == FLASH_CFI_16BIT) ?
			flash_read_word (info, FLASH_OFFSET_DEVICE_ID) :
			flash_read_uchar (info, FLASH_OFFSET_DEVICE_ID);
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e146e0:	e1a00004 	mov	r0, r4
{
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
	udelay(1);
	flash_write_cmd(info, 0, 0, FLASH_CMD_READ_ID);
	udelay(1000); /* some flash are slow to respond */
	info->manufacturer_id = flash_read_uchar (info,
57e146e4:	e1c42ebe 	strh	r2, [r4, #238]	; 0xee
					FLASH_OFFSET_MANUFACTURER_ID);
	info->device_id = (info->chipwidth == FLASH_CFI_16BIT) ?
57e146e8:	e5d420d5 	ldrb	r2, [r4, #213]	; 0xd5
57e146ec:	e3520002 	cmp	r2, #2
57e146f0:	e5d420d4 	ldrb	r2, [r4, #212]	; 0xd4
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e146f4:	17d23003 	ldrbne	r3, [r2, r3]
}

static u16 __flash_read16(void *addr)
{
	return __raw_readw(addr);
57e146f8:	019230b3 	ldrheq	r3, [r2, r3]
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e146fc:	120330ff 	andne	r3, r3, #255	; 0xff
	udelay(1);
	flash_write_cmd(info, 0, 0, FLASH_CMD_READ_ID);
	udelay(1000); /* some flash are slow to respond */
	info->manufacturer_id = flash_read_uchar (info,
					FLASH_OFFSET_MANUFACTURER_ID);
	info->device_id = (info->chipwidth == FLASH_CFI_16BIT) ?
57e14700:	e1c43fb0 	strh	r3, [r4, #240]	; 0xf0
			flash_read_word (info, FLASH_OFFSET_DEVICE_ID) :
			flash_read_uchar (info, FLASH_OFFSET_DEVICE_ID);
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e14704:	e1a02001 	mov	r2, r1
57e14708:	e3a030ff 	mov	r3, #255	; 0xff
}
57e1470c:	e8bd4010 	pop	{r4, lr}
	info->manufacturer_id = flash_read_uchar (info,
					FLASH_OFFSET_MANUFACTURER_ID);
	info->device_id = (info->chipwidth == FLASH_CFI_16BIT) ?
			flash_read_word (info, FLASH_OFFSET_DEVICE_ID) :
			flash_read_uchar (info, FLASH_OFFSET_DEVICE_ID);
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e14710:	eaffffbd 	b	57e1460c <flash_write_cmd>

57e14714 <flash_unlock_seq>:

	flash_unmap(info, sect, offset, addr);
}

static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect)
{
57e14714:	e92d4070 	push	{r4, r5, r6, lr}
	flash_write_cmd (info, sect, info->addr_unlock1, AMD_CMD_UNLOCK_START);
57e14718:	e59020fc 	ldr	r2, [r0, #252]	; 0xfc
57e1471c:	e3a030aa 	mov	r3, #170	; 0xaa

	flash_unmap(info, sect, offset, addr);
}

static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect)
{
57e14720:	e1a04000 	mov	r4, r0
57e14724:	e1a05001 	mov	r5, r1
	flash_write_cmd (info, sect, info->addr_unlock1, AMD_CMD_UNLOCK_START);
57e14728:	ebffffb7 	bl	57e1460c <flash_write_cmd>
	flash_write_cmd (info, sect, info->addr_unlock2, AMD_CMD_UNLOCK_ACK);
57e1472c:	e5942100 	ldr	r2, [r4, #256]	; 0x100
57e14730:	e1a00004 	mov	r0, r4
57e14734:	e1a01005 	mov	r1, r5
57e14738:	e3a03055 	mov	r3, #85	; 0x55
}
57e1473c:	e8bd4070 	pop	{r4, r5, r6, lr}
}

static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect)
{
	flash_write_cmd (info, sect, info->addr_unlock1, AMD_CMD_UNLOCK_START);
	flash_write_cmd (info, sect, info->addr_unlock2, AMD_CMD_UNLOCK_ACK);
57e14740:	eaffffb1 	b	57e1460c <flash_write_cmd>

57e14744 <cmdset_amd_read_jedec_ids>:
static void cmdset_amd_read_jedec_ids(flash_info_t *info)
{
	ushort bankId = 0;
	uchar  manuId;

	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
57e14744:	e3a01000 	mov	r1, #0

	return 0;
}

static void cmdset_amd_read_jedec_ids(flash_info_t *info)
{
57e14748:	e92d4010 	push	{r4, lr}
	ushort bankId = 0;
	uchar  manuId;

	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
57e1474c:	e1a02001 	mov	r2, r1

	return 0;
}

static void cmdset_amd_read_jedec_ids(flash_info_t *info)
{
57e14750:	e1a04000 	mov	r4, r0
	ushort bankId = 0;
	uchar  manuId;

	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
57e14754:	e3a030f0 	mov	r3, #240	; 0xf0
57e14758:	ebffffab 	bl	57e1460c <flash_write_cmd>
	flash_unlock_seq(info, 0);
57e1475c:	e1a00004 	mov	r0, r4
57e14760:	e3a01000 	mov	r1, #0
57e14764:	ebffffea 	bl	57e14714 <flash_unlock_seq>
	flash_write_cmd(info, 0, info->addr_unlock1, FLASH_CMD_READ_ID);
57e14768:	e3a01000 	mov	r1, #0
57e1476c:	e59420fc 	ldr	r2, [r4, #252]	; 0xfc
57e14770:	e3a03090 	mov	r3, #144	; 0x90
57e14774:	e1a00004 	mov	r0, r4
57e14778:	ebffffa3 	bl	57e1460c <flash_write_cmd>
	udelay(1000); /* some flash are slow to respond */
57e1477c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
57e14780:	eb003f6c 	bl	57e24538 <udelay>
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;

	return (void *)(info->start[sect] + byte_offset);
57e14784:	e594300c 	ldr	r3, [r4, #12]
	return 0;
}

static void cmdset_amd_read_jedec_ids(flash_info_t *info)
{
	ushort bankId = 0;
57e14788:	e3a02000 	mov	r2, #0
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e1478c:	e5d31000 	ldrb	r1, [r3]
	flash_write_cmd(info, 0, info->addr_unlock1, FLASH_CMD_READ_ID);
	udelay(1000); /* some flash are slow to respond */

	manuId = flash_read_uchar (info, FLASH_OFFSET_MANUFACTURER_ID);
	/* JEDEC JEP106Z specifies ID codes up to bank 7 */
	while (manuId == FLASH_CONTINUATION_CODE && bankId < 0x800) {
57e14790:	e59f00bc 	ldr	r0, [pc, #188]	; 57e14854 <cmdset_amd_read_jedec_ids+0x110>
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e14794:	e20110ff 	and	r1, r1, #255	; 0xff
	flash_write_cmd(info, 0, info->addr_unlock1, FLASH_CMD_READ_ID);
	udelay(1000); /* some flash are slow to respond */

	manuId = flash_read_uchar (info, FLASH_OFFSET_MANUFACTURER_ID);
	/* JEDEC JEP106Z specifies ID codes up to bank 7 */
	while (manuId == FLASH_CONTINUATION_CODE && bankId < 0x800) {
57e14798:	ea000006 	b	57e147b8 <cmdset_amd_read_jedec_ids+0x74>
		bankId += 0x100;
57e1479c:	e2822c01 	add	r2, r2, #256	; 0x100
57e147a0:	e1a02802 	lsl	r2, r2, #16
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e147a4:	e5d410d4 	ldrb	r1, [r4, #212]	; 0xd4
	udelay(1000); /* some flash are slow to respond */

	manuId = flash_read_uchar (info, FLASH_OFFSET_MANUFACTURER_ID);
	/* JEDEC JEP106Z specifies ID codes up to bank 7 */
	while (manuId == FLASH_CONTINUATION_CODE && bankId < 0x800) {
		bankId += 0x100;
57e147a8:	e1a02822 	lsr	r2, r2, #16
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e147ac:	e0010192 	mul	r1, r2, r1
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e147b0:	e7d11003 	ldrb	r1, [r1, r3]
57e147b4:	e20110ff 	and	r1, r1, #255	; 0xff
	flash_write_cmd(info, 0, info->addr_unlock1, FLASH_CMD_READ_ID);
	udelay(1000); /* some flash are slow to respond */

	manuId = flash_read_uchar (info, FLASH_OFFSET_MANUFACTURER_ID);
	/* JEDEC JEP106Z specifies ID codes up to bank 7 */
	while (manuId == FLASH_CONTINUATION_CODE && bankId < 0x800) {
57e147b8:	e1520000 	cmp	r2, r0
57e147bc:	9351007f 	cmpls	r1, #127	; 0x7f
57e147c0:	0afffff5 	beq	57e1479c <cmdset_amd_read_jedec_ids+0x58>
		manuId = flash_read_uchar (info,
			bankId | FLASH_OFFSET_MANUFACTURER_ID);
	}
	info->manufacturer_id = manuId;

	switch (info->chipwidth){
57e147c4:	e5d420d5 	ldrb	r2, [r4, #213]	; 0xd5
	while (manuId == FLASH_CONTINUATION_CODE && bankId < 0x800) {
		bankId += 0x100;
		manuId = flash_read_uchar (info,
			bankId | FLASH_OFFSET_MANUFACTURER_ID);
	}
	info->manufacturer_id = manuId;
57e147c8:	e1c41ebe 	strh	r1, [r4, #238]	; 0xee

	switch (info->chipwidth){
57e147cc:	e3520001 	cmp	r2, #1
57e147d0:	0a000002 	beq	57e147e0 <cmdset_amd_read_jedec_ids+0x9c>
57e147d4:	e3520002 	cmp	r2, #2
57e147d8:	1a000015 	bne	57e14834 <cmdset_amd_read_jedec_ids+0xf0>
57e147dc:	ea000004 	b	57e147f4 <cmdset_amd_read_jedec_ids+0xb0>
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e147e0:	e5d420d4 	ldrb	r2, [r4, #212]	; 0xd4
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e147e4:	e7d21003 	ldrb	r1, [r2, r3]
57e147e8:	e20110ff 	and	r1, r1, #255	; 0xff
	}
	info->manufacturer_id = manuId;

	switch (info->chipwidth){
	case FLASH_CFI_8BIT:
		info->device_id = flash_read_uchar (info,
57e147ec:	e1c41fb0 	strh	r1, [r4, #240]	; 0xf0
57e147f0:	ea000003 	b	57e14804 <cmdset_amd_read_jedec_ids+0xc0>
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e147f4:	e5d420d4 	ldrb	r2, [r4, #212]	; 0xd4
	return __raw_readb(addr);
}

static u16 __flash_read16(void *addr)
{
	return __raw_readw(addr);
57e147f8:	e19210b3 	ldrh	r1, [r2, r3]
			info->device_id2 |= flash_read_uchar (info,
						FLASH_OFFSET_DEVICE_ID3);
		}
		break;
	case FLASH_CFI_16BIT:
		info->device_id = flash_read_word (info,
57e147fc:	e1c41fb0 	strh	r1, [r4, #240]	; 0xf0
						FLASH_OFFSET_DEVICE_ID);
		if ((info->device_id & 0xff) == 0x7E) {
57e14800:	e20110ff 	and	r1, r1, #255	; 0xff
57e14804:	e351007e 	cmp	r1, #126	; 0x7e
57e14808:	1a000009 	bne	57e14834 <cmdset_amd_read_jedec_ids+0xf0>
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e1480c:	e3a0100e 	mov	r1, #14
57e14810:	e0010192 	mul	r1, r2, r1
57e14814:	e3a0000f 	mov	r0, #15
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e14818:	e7d11003 	ldrb	r1, [r1, r3]
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e1481c:	e0020290 	mul	r2, r0, r2
						FLASH_OFFSET_DEVICE_ID);
		if ((info->device_id & 0xff) == 0x7E) {
			/* AMD 3-byte (expanded) device ids */
			info->device_id2 = flash_read_uchar (info,
						FLASH_OFFSET_DEVICE_ID2);
			info->device_id2 <<= 8;
57e14820:	e1a01401 	lsl	r1, r1, #8
57e14824:	e1c41fb2 	strh	r1, [r4, #242]	; 0xf2
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e14828:	e7d23003 	ldrb	r3, [r2, r3]
		if ((info->device_id & 0xff) == 0x7E) {
			/* AMD 3-byte (expanded) device ids */
			info->device_id2 = flash_read_uchar (info,
						FLASH_OFFSET_DEVICE_ID2);
			info->device_id2 <<= 8;
			info->device_id2 |= flash_read_uchar (info,
57e1482c:	e1811003 	orr	r1, r1, r3
57e14830:	e1c41fb2 	strh	r1, [r4, #242]	; 0xf2
		}
		break;
	default:
		break;
	}
	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
57e14834:	e3a01000 	mov	r1, #0
57e14838:	e1a00004 	mov	r0, r4
57e1483c:	e1a02001 	mov	r2, r1
57e14840:	e3a030f0 	mov	r3, #240	; 0xf0
57e14844:	ebffff70 	bl	57e1460c <flash_write_cmd>
	udelay(1);
57e14848:	e3a00001 	mov	r0, #1
}
57e1484c:	e8bd4010 	pop	{r4, lr}
		break;
	default:
		break;
	}
	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
	udelay(1);
57e14850:	ea003f38 	b	57e24538 <udelay>
57e14854:	000007ff 	.word	0x000007ff

57e14858 <flash_full_status_check>:
 *
 * This routine sets the flash to read-array mode.
 */
static int flash_full_status_check (flash_info_t * info, flash_sect_t sector,
				    ulong tout, char *prompt)
{
57e14858:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e1485c:	e1a04000 	mov	r4, r0

	/* Wait for command completion */
#ifdef CONFIG_SYS_LOW_RES_TIMER
	reset_timer();
#endif
	start = get_timer (0);
57e14860:	e3a00000 	mov	r0, #0
 *
 * This routine sets the flash to read-array mode.
 */
static int flash_full_status_check (flash_info_t * info, flash_sect_t sector,
				    ulong tout, char *prompt)
{
57e14864:	e1a05001 	mov	r5, r1
57e14868:	e1a0a002 	mov	sl, r2
57e1486c:	e1a07003 	mov	r7, r3

	/* Wait for command completion */
#ifdef CONFIG_SYS_LOW_RES_TIMER
	reset_timer();
#endif
	start = get_timer (0);
57e14870:	ebffb0a5 	bl	57e00b0c <get_timer>
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;

	return (void *)(info->start[sect] + byte_offset);
57e14874:	e2856002 	add	r6, r5, #2

	/* Wait for command completion */
#ifdef CONFIG_SYS_LOW_RES_TIMER
	reset_timer();
#endif
	start = get_timer (0);
57e14878:	e1a0b000 	mov	fp, r0
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;

	return (void *)(info->start[sect] + byte_offset);
57e1487c:	e0846106 	add	r6, r4, r6, lsl #2
57e14880:	ea00001c 	b	57e148f8 <flash_full_status_check+0xa0>
	reset_timer();
#endif
	start = get_timer (0);
	WATCHDOG_RESET();
	while (flash_is_busy (info, sector)) {
		if (get_timer (start) > tout) {
57e14884:	e1a0000b 	mov	r0, fp
57e14888:	ebffb09f 	bl	57e00b0c <get_timer>
57e1488c:	e150000a 	cmp	r0, sl
57e14890:	9a000016 	bls	57e148f0 <flash_full_status_check+0x98>
			printf ("Flash %s timeout at address %lx data %lx\n",
57e14894:	e0843105 	add	r3, r4, r5, lsl #2
57e14898:	e593200c 	ldr	r2, [r3, #12]
		debug ("addr[%x] = 0x%x\n", x, flash_read8(addr + x));
	}
#endif
#if defined(__LITTLE_ENDIAN) || defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
	retval = ((flash_read8(addr) << 16) |
		  (flash_read8(addr + info->portwidth) << 24) |
57e1489c:	e5d410d4 	ldrb	r1, [r4, #212]	; 0xd4
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e148a0:	e5d2e000 	ldrb	lr, [r2]
57e148a4:	e7d20001 	ldrb	r0, [r2, r1]
57e148a8:	e7d23081 	ldrb	r3, [r2, r1, lsl #1]
#endif
#if defined(__LITTLE_ENDIAN) || defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
	retval = ((flash_read8(addr) << 16) |
		  (flash_read8(addr + info->portwidth) << 24) |
		  (flash_read8(addr + 2 * info->portwidth)) |
		  (flash_read8(addr + 3 * info->portwidth) << 8));
57e148ac:	e0811081 	add	r1, r1, r1, lsl #1
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e148b0:	e7d2c001 	ldrb	ip, [r2, r1]
	for (x = 0; x < 4 * info->portwidth; x++) {
		debug ("addr[%x] = 0x%x\n", x, flash_read8(addr + x));
	}
#endif
#if defined(__LITTLE_ENDIAN) || defined(CONFIG_SYS_WRITE_SWAPPED_DATA)
	retval = ((flash_read8(addr) << 16) |
57e148b4:	e183380e 	orr	r3, r3, lr, lsl #16
		  (flash_read8(addr + info->portwidth) << 24) |
57e148b8:	e1833c00 	orr	r3, r3, r0, lsl #24
#endif
	start = get_timer (0);
	WATCHDOG_RESET();
	while (flash_is_busy (info, sector)) {
		if (get_timer (start) > tout) {
			printf ("Flash %s timeout at address %lx data %lx\n",
57e148bc:	e183340c 	orr	r3, r3, ip, lsl #8
57e148c0:	e1a01007 	mov	r1, r7
57e148c4:	e59f026c 	ldr	r0, [pc, #620]	; 57e14b38 <flash_full_status_check+0x2e0>
57e148c8:	ebffd2df 	bl	57e0944c <printf>
				prompt, info->start[sector],
				flash_read_long (info, sector, 0));
			flash_write_cmd (info, sector, 0, info->cmd_reset);
57e148cc:	e1a00004 	mov	r0, r4
57e148d0:	e1a01005 	mov	r1, r5
57e148d4:	e3a02000 	mov	r2, #0
57e148d8:	e1d43eb6 	ldrh	r3, [r4, #230]	; 0xe6
57e148dc:	ebffff4a 	bl	57e1460c <flash_write_cmd>
			udelay(1);
57e148e0:	e3a00001 	mov	r0, #1
57e148e4:	eb003f13 	bl	57e24538 <udelay>
			return ERR_TIMOUT;
57e148e8:	e3a06001 	mov	r6, #1
57e148ec:	ea000042 	b	57e149fc <flash_full_status_check+0x1a4>
		}
		udelay (1);		/* also triggers watchdog */
57e148f0:	e3a00001 	mov	r0, #1
57e148f4:	eb003f0f 	bl	57e24538 <udelay>
 */
static int flash_is_busy (flash_info_t * info, flash_sect_t sect)
{
	int retval;

	switch (info->vendor) {
57e148f8:	e1d43eb4 	ldrh	r3, [r4, #228]	; 0xe4
57e148fc:	e3530003 	cmp	r3, #3
57e14900:	0a00000c 	beq	57e14938 <flash_full_status_check+0xe0>
57e14904:	8a000003 	bhi	57e14918 <flash_full_status_check+0xc0>
57e14908:	e3530001 	cmp	r3, #1
57e1490c:	0a000009 	beq	57e14938 <flash_full_status_check+0xe0>
57e14910:	e3530002 	cmp	r3, #2
57e14914:	ea000005 	b	57e14930 <flash_full_status_check+0xd8>
57e14918:	e3530c02 	cmp	r3, #512	; 0x200
57e1491c:	0a000005 	beq	57e14938 <flash_full_status_check+0xe0>
57e14920:	e59f2214 	ldr	r2, [pc, #532]	; 57e14b3c <flash_full_status_check+0x2e4>
57e14924:	e1530002 	cmp	r3, r2
57e14928:	0a00000a 	beq	57e14958 <flash_full_status_check+0x100>
57e1492c:	e3530004 	cmp	r3, #4
57e14930:	1a00007e 	bne	57e14b30 <flash_full_status_check+0x2d8>
57e14934:	ea000007 	b	57e14958 <flash_full_status_check+0x100>
	case CFI_CMDSET_INTEL_PROG_REGIONS:
	case CFI_CMDSET_INTEL_STANDARD:
	case CFI_CMDSET_INTEL_EXTENDED:
		retval = !flash_isset (info, sect, 0, FLASH_STATUS_DONE);
57e14938:	e1a00004 	mov	r0, r4
57e1493c:	e1a01005 	mov	r1, r5
57e14940:	e3a02000 	mov	r2, #0
57e14944:	e3a03080 	mov	r3, #128	; 0x80
57e14948:	ebfffe7c 	bl	57e14340 <flash_isset>
57e1494c:	e2700001 	rsbs	r0, r0, #1
57e14950:	33a00000 	movcc	r0, #0
57e14954:	ea000025 	b	57e149f0 <flash_full_status_check+0x198>
	void *addr;
	cfiword_t cword;
	int retval;

	addr = flash_map (info, sect, offset);
	flash_make_cmd (info, cmd, &cword);
57e14958:	e1a00004 	mov	r0, r4
57e1495c:	e3a01040 	mov	r1, #64	; 0x40
57e14960:	e1a0200d 	mov	r2, sp
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;

	return (void *)(info->start[sect] + byte_offset);
57e14964:	e5969004 	ldr	r9, [r6, #4]
	void *addr;
	cfiword_t cword;
	int retval;

	addr = flash_map (info, sect, offset);
	flash_make_cmd (info, cmd, &cword);
57e14968:	ebfffe33 	bl	57e1423c <flash_make_cmd>
	switch (info->portwidth) {
57e1496c:	e5d430d4 	ldrb	r3, [r4, #212]	; 0xd4
57e14970:	e2433001 	sub	r3, r3, #1
57e14974:	e3530007 	cmp	r3, #7
57e14978:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e1497c:	ea00006b 	b	57e14b30 <flash_full_status_check+0x2d8>
57e14980:	57e149a0 	.word	0x57e149a0
57e14984:	57e149ac 	.word	0x57e149ac
57e14988:	57e14b30 	.word	0x57e14b30
57e1498c:	57e149c0 	.word	0x57e149c0
57e14990:	57e14b30 	.word	0x57e14b30
57e14994:	57e14b30 	.word	0x57e14b30
57e14998:	57e14b30 	.word	0x57e14b30
57e1499c:	57e149cc 	.word	0x57e149cc
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e149a0:	e5d90000 	ldrb	r0, [r9]
57e149a4:	e5d93000 	ldrb	r3, [r9]
57e149a8:	ea000001 	b	57e149b4 <flash_full_status_check+0x15c>
}

static u16 __flash_read16(void *addr)
{
	return __raw_readw(addr);
57e149ac:	e1d900b0 	ldrh	r0, [r9]
57e149b0:	e1d930b0 	ldrh	r3, [r9]
	switch (info->portwidth) {
	case FLASH_CFI_8BIT:
		retval = flash_read8(addr) != flash_read8(addr);
		break;
	case FLASH_CFI_16BIT:
		retval = flash_read16(addr) != flash_read16(addr);
57e149b4:	e0500003 	subs	r0, r0, r3
57e149b8:	13a00001 	movne	r0, #1
57e149bc:	ea00000b 	b	57e149f0 <flash_full_status_check+0x198>
	return __raw_readw(addr);
}

static u32 __flash_read32(void *addr)
{
	return __raw_readl(addr);
57e149c0:	e5990000 	ldr	r0, [r9]
57e149c4:	e5993000 	ldr	r3, [r9]
57e149c8:	eafffff9 	b	57e149b4 <flash_full_status_check+0x15c>
57e149cc:	e5992000 	ldr	r2, [r9]
57e149d0:	e5993000 	ldr	r3, [r9]
		break;
	case FLASH_CFI_32BIT:
		retval = flash_read32(addr) != flash_read32(addr);
		break;
	case FLASH_CFI_64BIT:
		retval = ( (flash_read32( addr ) != flash_read32( addr )) ||
57e149d4:	e1520003 	cmp	r2, r3
57e149d8:	1affffa9 	bne	57e14884 <flash_full_status_check+0x2c>
	return __raw_readw(addr);
}

static u32 __flash_read32(void *addr)
{
	return __raw_readl(addr);
57e149dc:	e5992004 	ldr	r2, [r9, #4]
57e149e0:	e5993004 	ldr	r3, [r9, #4]
		break;
	case FLASH_CFI_32BIT:
		retval = flash_read32(addr) != flash_read32(addr);
		break;
	case FLASH_CFI_64BIT:
		retval = ( (flash_read32( addr ) != flash_read32( addr )) ||
57e149e4:	e1520003 	cmp	r2, r3
57e149e8:	1affffa5 	bne	57e14884 <flash_full_status_check+0x2c>
57e149ec:	ea00004f 	b	57e14b30 <flash_full_status_check+0x2d8>
#ifdef CONFIG_SYS_LOW_RES_TIMER
	reset_timer();
#endif
	start = get_timer (0);
	WATCHDOG_RESET();
	while (flash_is_busy (info, sector)) {
57e149f0:	e3500000 	cmp	r0, #0
57e149f4:	1affffa2 	bne	57e14884 <flash_full_status_check+0x2c>
			udelay(1);
			return ERR_TIMOUT;
		}
		udelay (1);		/* also triggers watchdog */
	}
	return ERR_OK;
57e149f8:	e1a06000 	mov	r6, r0
				    ulong tout, char *prompt)
{
	int retcode;

	retcode = flash_status_check (info, sector, tout, prompt);
	switch (info->vendor) {
57e149fc:	e1d43eb4 	ldrh	r3, [r4, #228]	; 0xe4
57e14a00:	e3530003 	cmp	r3, #3
57e14a04:	0a000003 	beq	57e14a18 <flash_full_status_check+0x1c0>
57e14a08:	e3530c02 	cmp	r3, #512	; 0x200
57e14a0c:	0a000001 	beq	57e14a18 <flash_full_status_check+0x1c0>
57e14a10:	e3530001 	cmp	r3, #1
57e14a14:	1a000043 	bne	57e14b28 <flash_full_status_check+0x2d0>
	case CFI_CMDSET_INTEL_PROG_REGIONS:
	case CFI_CMDSET_INTEL_EXTENDED:
	case CFI_CMDSET_INTEL_STANDARD:
		if ((retcode != ERR_OK)
57e14a18:	e3560000 	cmp	r6, #0
57e14a1c:	0a00003a 	beq	57e14b0c <flash_full_status_check+0x2b4>
		    && !flash_isequal (info, sector, 0, FLASH_STATUS_DONE)) {
57e14a20:	e1a00004 	mov	r0, r4
57e14a24:	e1a01005 	mov	r1, r5
57e14a28:	e3a02000 	mov	r2, #0
57e14a2c:	e3a03080 	mov	r3, #128	; 0x80
57e14a30:	ebfffe15 	bl	57e1428c <flash_isequal>
57e14a34:	e2506000 	subs	r6, r0, #0
57e14a38:	13a06001 	movne	r6, #1
57e14a3c:	1a000032 	bne	57e14b0c <flash_full_status_check+0x2b4>
			retcode = ERR_INVAL;
			printf ("Flash %s error at address %lx\n", prompt,
57e14a40:	e0843105 	add	r3, r4, r5, lsl #2
57e14a44:	e593200c 	ldr	r2, [r3, #12]
57e14a48:	e1a01007 	mov	r1, r7
57e14a4c:	e59f00ec 	ldr	r0, [pc, #236]	; 57e14b40 <flash_full_status_check+0x2e8>
57e14a50:	ebffd27d 	bl	57e0944c <printf>
				info->start[sector]);
			if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS |
57e14a54:	e1a02006 	mov	r2, r6
57e14a58:	e1a00004 	mov	r0, r4
57e14a5c:	e1a01005 	mov	r1, r5
57e14a60:	e3a03030 	mov	r3, #48	; 0x30
57e14a64:	ebfffe35 	bl	57e14340 <flash_isset>
57e14a68:	e2502000 	subs	r2, r0, #0
					 FLASH_STATUS_PSLBS)) {
				puts ("Command Sequence Error.\n");
57e14a6c:	159f00d0 	ldrne	r0, [pc, #208]	; 57e14b44 <flash_full_status_check+0x2ec>
		if ((retcode != ERR_OK)
		    && !flash_isequal (info, sector, 0, FLASH_STATUS_DONE)) {
			retcode = ERR_INVAL;
			printf ("Flash %s error at address %lx\n", prompt,
				info->start[sector]);
			if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS |
57e14a70:	1a000010 	bne	57e14ab8 <flash_full_status_check+0x260>
					 FLASH_STATUS_PSLBS)) {
				puts ("Command Sequence Error.\n");
			} else if (flash_isset (info, sector, 0,
57e14a74:	e1a00004 	mov	r0, r4
57e14a78:	e1a01005 	mov	r1, r5
57e14a7c:	e3a03020 	mov	r3, #32
57e14a80:	ebfffe2e 	bl	57e14340 <flash_isset>
57e14a84:	e2502000 	subs	r2, r0, #0
57e14a88:	0a000003 	beq	57e14a9c <flash_full_status_check+0x244>
						FLASH_STATUS_ECLBS)) {
				puts ("Block Erase Error.\n");
57e14a8c:	e59f00b4 	ldr	r0, [pc, #180]	; 57e14b48 <flash_full_status_check+0x2f0>
57e14a90:	ebffd263 	bl	57e09424 <puts>
				retcode = ERR_NOT_ERASED;
57e14a94:	e3a06002 	mov	r6, #2
57e14a98:	ea000008 	b	57e14ac0 <flash_full_status_check+0x268>
			} else if (flash_isset (info, sector, 0,
57e14a9c:	e1a00004 	mov	r0, r4
57e14aa0:	e1a01005 	mov	r1, r5
57e14aa4:	e3a03010 	mov	r3, #16
57e14aa8:	ebfffe24 	bl	57e14340 <flash_isset>
57e14aac:	e3500000 	cmp	r0, #0
57e14ab0:	0a000001 	beq	57e14abc <flash_full_status_check+0x264>
						FLASH_STATUS_PSLBS)) {
				puts ("Locking Error\n");
57e14ab4:	e59f0090 	ldr	r0, [pc, #144]	; 57e14b4c <flash_full_status_check+0x2f4>
57e14ab8:	ebffd259 	bl	57e09424 <puts>
	case CFI_CMDSET_INTEL_PROG_REGIONS:
	case CFI_CMDSET_INTEL_EXTENDED:
	case CFI_CMDSET_INTEL_STANDARD:
		if ((retcode != ERR_OK)
		    && !flash_isequal (info, sector, 0, FLASH_STATUS_DONE)) {
			retcode = ERR_INVAL;
57e14abc:	e3a06008 	mov	r6, #8
				retcode = ERR_NOT_ERASED;
			} else if (flash_isset (info, sector, 0,
						FLASH_STATUS_PSLBS)) {
				puts ("Locking Error\n");
			}
			if (flash_isset (info, sector, 0, FLASH_STATUS_DPS)) {
57e14ac0:	e1a00004 	mov	r0, r4
57e14ac4:	e1a01005 	mov	r1, r5
57e14ac8:	e3a02000 	mov	r2, #0
57e14acc:	e3a03002 	mov	r3, #2
57e14ad0:	ebfffe1a 	bl	57e14340 <flash_isset>
57e14ad4:	e3500000 	cmp	r0, #0
57e14ad8:	0a000002 	beq	57e14ae8 <flash_full_status_check+0x290>
				puts ("Block locked.\n");
57e14adc:	e59f006c 	ldr	r0, [pc, #108]	; 57e14b50 <flash_full_status_check+0x2f8>
57e14ae0:	ebffd24f 	bl	57e09424 <puts>
				retcode = ERR_PROTECTED;
57e14ae4:	e3a06004 	mov	r6, #4
			}
			if (flash_isset (info, sector, 0, FLASH_STATUS_VPENS))
57e14ae8:	e1a00004 	mov	r0, r4
57e14aec:	e1a01005 	mov	r1, r5
57e14af0:	e3a02000 	mov	r2, #0
57e14af4:	e3a03008 	mov	r3, #8
57e14af8:	ebfffe10 	bl	57e14340 <flash_isset>
57e14afc:	e3500000 	cmp	r0, #0
57e14b00:	0a000001 	beq	57e14b0c <flash_full_status_check+0x2b4>
				puts ("Vpp Low Error.\n");
57e14b04:	e59f0048 	ldr	r0, [pc, #72]	; 57e14b54 <flash_full_status_check+0x2fc>
57e14b08:	ebffd245 	bl	57e09424 <puts>
		}
		flash_write_cmd (info, sector, 0, info->cmd_reset);
57e14b0c:	e1a00004 	mov	r0, r4
57e14b10:	e1a01005 	mov	r1, r5
57e14b14:	e3a02000 	mov	r2, #0
57e14b18:	e1d43eb6 	ldrh	r3, [r4, #230]	; 0xe6
57e14b1c:	ebfffeba 	bl	57e1460c <flash_write_cmd>
		udelay(1);
57e14b20:	e3a00001 	mov	r0, #1
57e14b24:	eb003e83 	bl	57e24538 <udelay>
		break;
	default:
		break;
	}
	return retcode;
}
57e14b28:	e1a00006 	mov	r0, r6
57e14b2c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
			udelay(1);
			return ERR_TIMOUT;
		}
		udelay (1);		/* also triggers watchdog */
	}
	return ERR_OK;
57e14b30:	e3a06000 	mov	r6, #0
57e14b34:	eaffffb0 	b	57e149fc <flash_full_status_check+0x1a4>
57e14b38:	57e334be 	.word	0x57e334be
57e14b3c:	0000fff0 	.word	0x0000fff0
57e14b40:	57e334e8 	.word	0x57e334e8
57e14b44:	57e33507 	.word	0x57e33507
57e14b48:	57e33520 	.word	0x57e33520
57e14b4c:	57e33534 	.word	0x57e33534
57e14b50:	57e33543 	.word	0x57e33543
57e14b54:	57e33552 	.word	0x57e33552

57e14b58 <flash_write_cfiword>:

/*-----------------------------------------------------------------------
 */
static int flash_write_cfiword (flash_info_t * info, ulong dest,
				cfiword_t cword)
{
57e14b58:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e14b5c:	e1a0a003 	mov	sl, r3
	int flag;
	flash_sect_t sect = 0;
	char sect_found = 0;

	/* Check if Flash is (sufficiently) erased */
	switch (info->portwidth) {
57e14b60:	e5d030d4 	ldrb	r3, [r0, #212]	; 0xd4

/*-----------------------------------------------------------------------
 */
static int flash_write_cfiword (flash_info_t * info, ulong dest,
				cfiword_t cword)
{
57e14b64:	e1a04000 	mov	r4, r0
	int flag;
	flash_sect_t sect = 0;
	char sect_found = 0;

	/* Check if Flash is (sufficiently) erased */
	switch (info->portwidth) {
57e14b68:	e2433001 	sub	r3, r3, #1

/*-----------------------------------------------------------------------
 */
static int flash_write_cfiword (flash_info_t * info, ulong dest,
				cfiword_t cword)
{
57e14b6c:	e1a05001 	mov	r5, r1
57e14b70:	e1a06002 	mov	r6, r2
	int flag;
	flash_sect_t sect = 0;
	char sect_found = 0;

	/* Check if Flash is (sufficiently) erased */
	switch (info->portwidth) {
57e14b74:	e3530007 	cmp	r3, #7
57e14b78:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e14b7c:	ea00007f 	b	57e14d80 <flash_write_cfiword+0x228>
57e14b80:	57e14ba0 	.word	0x57e14ba0
57e14b84:	57e14bac 	.word	0x57e14bac
57e14b88:	57e14d80 	.word	0x57e14d80
57e14b8c:	57e14bcc 	.word	0x57e14bcc
57e14b90:	57e14d80 	.word	0x57e14d80
57e14b94:	57e14d80 	.word	0x57e14d80
57e14b98:	57e14d80 	.word	0x57e14d80
57e14b9c:	57e14be4 	.word	0x57e14be4
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e14ba0:	e5d13000 	ldrb	r3, [r1]
	char sect_found = 0;

	/* Check if Flash is (sufficiently) erased */
	switch (info->portwidth) {
	case FLASH_CFI_8BIT:
		flag = ((flash_read8(dstaddr) & cword.c) == cword.c);
57e14ba4:	e20220ff 	and	r2, r2, #255	; 0xff
57e14ba8:	ea000002 	b	57e14bb8 <flash_write_cfiword+0x60>
		break;
	case FLASH_CFI_16BIT:
		flag = ((flash_read16(dstaddr) & cword.w) == cword.w);
57e14bac:	e1a02802 	lsl	r2, r2, #16
	return __raw_readb(addr);
}

static u16 __flash_read16(void *addr)
{
	return __raw_readw(addr);
57e14bb0:	e1d130b0 	ldrh	r3, [r1]
	switch (info->portwidth) {
	case FLASH_CFI_8BIT:
		flag = ((flash_read8(dstaddr) & cword.c) == cword.c);
		break;
	case FLASH_CFI_16BIT:
		flag = ((flash_read16(dstaddr) & cword.w) == cword.w);
57e14bb4:	e1a02822 	lsr	r2, r2, #16
57e14bb8:	e0033002 	and	r3, r3, r2
57e14bbc:	e1530002 	cmp	r3, r2
57e14bc0:	13a03000 	movne	r3, #0
57e14bc4:	03a03001 	moveq	r3, #1
		break;
57e14bc8:	ea00000b 	b	57e14bfc <flash_write_cfiword+0xa4>
	return __raw_readw(addr);
}

static u32 __flash_read32(void *addr)
{
	return __raw_readl(addr);
57e14bcc:	e5913000 	ldr	r3, [r1]
		break;
	case FLASH_CFI_16BIT:
		flag = ((flash_read16(dstaddr) & cword.w) == cword.w);
		break;
	case FLASH_CFI_32BIT:
		flag = ((flash_read32(dstaddr) & cword.l) == cword.l);
57e14bd0:	e0033002 	and	r3, r3, r2
57e14bd4:	e1530002 	cmp	r3, r2
57e14bd8:	13a03000 	movne	r3, #0
57e14bdc:	03a03001 	moveq	r3, #1
		break;
57e14be0:	ea000005 	b	57e14bfc <flash_write_cfiword+0xa4>
}

static u64 __flash_read64(void *addr)
{
	/* No architectures currently implement __raw_readq() */
	return *(volatile u64 *)addr;
57e14be4:	e891000c 	ldm	r1, {r2, r3}
		break;
	case FLASH_CFI_32BIT:
		flag = ((flash_read32(dstaddr) & cword.l) == cword.l);
		break;
	case FLASH_CFI_64BIT:
		flag = ((flash_read64(dstaddr) & cword.ll) == cword.ll);
57e14be8:	e1ca3003 	bic	r3, sl, r3
57e14bec:	e1c62002 	bic	r2, r6, r2
57e14bf0:	e1921003 	orrs	r1, r2, r3
57e14bf4:	13a03000 	movne	r3, #0
57e14bf8:	03a03001 	moveq	r3, #1
		break;
	default:
		flag = 0;
		break;
	}
	if (!flag)
57e14bfc:	e3530000 	cmp	r3, #0
57e14c00:	0a00005e 	beq	57e14d80 <flash_write_cfiword+0x228>
		return ERR_NOT_ERASED;

	/* Disable interrupts which might cause a timeout here */
	flag = disable_interrupts ();
57e14c04:	ebffb146 	bl	57e01124 <disable_interrupts>

	switch (info->vendor) {
57e14c08:	e1d43eb4 	ldrh	r3, [r4, #228]	; 0xe4
	}
	if (!flag)
		return ERR_NOT_ERASED;

	/* Disable interrupts which might cause a timeout here */
	flag = disable_interrupts ();
57e14c0c:	e1a09000 	mov	r9, r0

	switch (info->vendor) {
57e14c10:	e3530003 	cmp	r3, #3
57e14c14:	0a00000c 	beq	57e14c4c <flash_write_cfiword+0xf4>
57e14c18:	8a000003 	bhi	57e14c2c <flash_write_cfiword+0xd4>
57e14c1c:	e3530001 	cmp	r3, #1
57e14c20:	0a000009 	beq	57e14c4c <flash_write_cfiword+0xf4>
57e14c24:	e3530002 	cmp	r3, #2
57e14c28:	ea000005 	b	57e14c44 <flash_write_cfiword+0xec>
57e14c2c:	e3530c02 	cmp	r3, #512	; 0x200
57e14c30:	0a000005 	beq	57e14c4c <flash_write_cfiword+0xf4>
57e14c34:	e59f214c 	ldr	r2, [pc, #332]	; 57e14d88 <flash_write_cfiword+0x230>
57e14c38:	e1530002 	cmp	r3, r2
57e14c3c:	0a000017 	beq	57e14ca0 <flash_write_cfiword+0x148>
57e14c40:	e3530004 	cmp	r3, #4
57e14c44:	1a000023 	bne	57e14cd8 <flash_write_cfiword+0x180>
57e14c48:	ea00000a 	b	57e14c78 <flash_write_cfiword+0x120>
	case CFI_CMDSET_INTEL_PROG_REGIONS:
	case CFI_CMDSET_INTEL_EXTENDED:
	case CFI_CMDSET_INTEL_STANDARD:
		flash_write_cmd (info, 0, 0, FLASH_CMD_CLEAR_STATUS);
57e14c4c:	e3a01000 	mov	r1, #0
57e14c50:	e1a00004 	mov	r0, r4
57e14c54:	e1a02001 	mov	r2, r1
57e14c58:	e3a03050 	mov	r3, #80	; 0x50
57e14c5c:	ebfffe6a 	bl	57e1460c <flash_write_cmd>
		flash_write_cmd (info, 0, 0, FLASH_CMD_WRITE);
57e14c60:	e3a01000 	mov	r1, #0
57e14c64:	e1a00004 	mov	r0, r4
57e14c68:	e1a02001 	mov	r2, r1
57e14c6c:	e3a03040 	mov	r3, #64	; 0x40
57e14c70:	ebfffe65 	bl	57e1460c <flash_write_cmd>
57e14c74:	ea000017 	b	57e14cd8 <flash_write_cfiword+0x180>
		break;
	case CFI_CMDSET_AMD_EXTENDED:
	case CFI_CMDSET_AMD_STANDARD:
		sect = find_sector(info, dest);
57e14c78:	e1a01005 	mov	r1, r5
57e14c7c:	e1a00004 	mov	r0, r4
57e14c80:	ebfffddc 	bl	57e143f8 <find_sector>
57e14c84:	e1a07000 	mov	r7, r0
		flash_unlock_seq (info, sect);
57e14c88:	e1a01007 	mov	r1, r7
57e14c8c:	e1a00004 	mov	r0, r4
57e14c90:	ebfffe9f 	bl	57e14714 <flash_unlock_seq>
		flash_write_cmd (info, sect, info->addr_unlock1, AMD_CMD_WRITE);
57e14c94:	e1a00004 	mov	r0, r4
57e14c98:	e1a01007 	mov	r1, r7
57e14c9c:	ea000008 	b	57e14cc4 <flash_write_cfiword+0x16c>
		sect_found = 1;
		break;
#ifdef CONFIG_FLASH_CFI_LEGACY
	case CFI_CMDSET_AMD_LEGACY:
		sect = find_sector(info, dest);
57e14ca0:	e1a01005 	mov	r1, r5
57e14ca4:	e1a00004 	mov	r0, r4
57e14ca8:	ebfffdd2 	bl	57e143f8 <find_sector>
		flash_unlock_seq (info, 0);
57e14cac:	e3a01000 	mov	r1, #0
		flash_write_cmd (info, sect, info->addr_unlock1, AMD_CMD_WRITE);
		sect_found = 1;
		break;
#ifdef CONFIG_FLASH_CFI_LEGACY
	case CFI_CMDSET_AMD_LEGACY:
		sect = find_sector(info, dest);
57e14cb0:	e1a07000 	mov	r7, r0
		flash_unlock_seq (info, 0);
57e14cb4:	e1a00004 	mov	r0, r4
57e14cb8:	ebfffe95 	bl	57e14714 <flash_unlock_seq>
		flash_write_cmd (info, 0, info->addr_unlock1, AMD_CMD_WRITE);
57e14cbc:	e1a00004 	mov	r0, r4
57e14cc0:	e3a01000 	mov	r1, #0
57e14cc4:	e59420fc 	ldr	r2, [r4, #252]	; 0xfc
57e14cc8:	e3a030a0 	mov	r3, #160	; 0xa0
57e14ccc:	ebfffe4e 	bl	57e1460c <flash_write_cmd>
		sect_found = 1;
57e14cd0:	e3a0b001 	mov	fp, #1
		break;
57e14cd4:	ea000001 	b	57e14ce0 <flash_write_cfiword+0x188>
				cfiword_t cword)
{
	void *dstaddr = (void *)dest;
	int flag;
	flash_sect_t sect = 0;
	char sect_found = 0;
57e14cd8:	e3a0b000 	mov	fp, #0
static int flash_write_cfiword (flash_info_t * info, ulong dest,
				cfiword_t cword)
{
	void *dstaddr = (void *)dest;
	int flag;
	flash_sect_t sect = 0;
57e14cdc:	e1a0700b 	mov	r7, fp
		sect_found = 1;
		break;
#endif
	}

	switch (info->portwidth) {
57e14ce0:	e5d430d4 	ldrb	r3, [r4, #212]	; 0xd4
57e14ce4:	e2433001 	sub	r3, r3, #1
57e14ce8:	e3530007 	cmp	r3, #7
57e14cec:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e14cf0:	ea000013 	b	57e14d44 <flash_write_cfiword+0x1ec>
57e14cf4:	57e14d14 	.word	0x57e14d14
57e14cf8:	57e14d20 	.word	0x57e14d20
57e14cfc:	57e14d44 	.word	0x57e14d44
57e14d00:	57e14d30 	.word	0x57e14d30
57e14d04:	57e14d44 	.word	0x57e14d44
57e14d08:	57e14d44 	.word	0x57e14d44
57e14d0c:	57e14d44 	.word	0x57e14d44
57e14d10:	57e14d38 	.word	0x57e14d38
	case FLASH_CFI_8BIT:
		flash_write8(cword.c, dstaddr);
57e14d14:	e20660ff 	and	r6, r6, #255	; 0xff
unsigned long cfi_flash_bank_size(int i)
	__attribute__((weak, alias("__cfi_flash_bank_size")));

static void __flash_write8(u8 value, void *addr)
{
	__raw_writeb(value, addr);
57e14d18:	e5c56000 	strb	r6, [r5]
57e14d1c:	ea000008 	b	57e14d44 <flash_write_cfiword+0x1ec>
	switch (info->portwidth) {
	case FLASH_CFI_8BIT:
		flash_write8(cword.c, dstaddr);
		break;
	case FLASH_CFI_16BIT:
		flash_write16(cword.w, dstaddr);
57e14d20:	e1a06806 	lsl	r6, r6, #16
57e14d24:	e1a06826 	lsr	r6, r6, #16
	__raw_writeb(value, addr);
}

static void __flash_write16(u16 value, void *addr)
{
	__raw_writew(value, addr);
57e14d28:	e1c560b0 	strh	r6, [r5]
57e14d2c:	ea000004 	b	57e14d44 <flash_write_cfiword+0x1ec>
}

static void __flash_write32(u32 value, void *addr)
{
	__raw_writel(value, addr);
57e14d30:	e5856000 	str	r6, [r5]
57e14d34:	ea000002 	b	57e14d44 <flash_write_cfiword+0x1ec>
		break;
	case FLASH_CFI_32BIT:
		flash_write32(cword.l, dstaddr);
		break;
	case FLASH_CFI_64BIT:
		flash_write64(cword.ll, dstaddr);
57e14d38:	e1a02006 	mov	r2, r6
57e14d3c:	e1a0300a 	mov	r3, sl
}

static void __flash_write64(u64 value, void *addr)
{
	/* No architectures currently implement __raw_writeq() */
	*(volatile u64 *)addr = value;
57e14d40:	e885000c 	stm	r5, {r2, r3}
		flash_write64(cword.ll, dstaddr);
		break;
	}

	/* re-enable interrupts if necessary */
	if (flag)
57e14d44:	e3590000 	cmp	r9, #0
57e14d48:	0a000000 	beq	57e14d50 <flash_write_cfiword+0x1f8>
		enable_interrupts ();
57e14d4c:	ebffb0f3 	bl	57e01120 <enable_interrupts>

	if (!sect_found)
57e14d50:	e35b0000 	cmp	fp, #0
57e14d54:	1a000003 	bne	57e14d68 <flash_write_cfiword+0x210>
		sect = find_sector (info, dest);
57e14d58:	e1a00004 	mov	r0, r4
57e14d5c:	e1a01005 	mov	r1, r5
57e14d60:	ebfffda4 	bl	57e143f8 <find_sector>
57e14d64:	e1a07000 	mov	r7, r0

	if (use_flash_status_poll(info))
		return flash_status_poll(info, &cword, dstaddr,
					 info->write_tout, "write");
	else
		return flash_full_status_check(info, sect,
57e14d68:	e59420dc 	ldr	r2, [r4, #220]	; 0xdc
57e14d6c:	e59f3018 	ldr	r3, [pc, #24]	; 57e14d8c <flash_write_cfiword+0x234>
57e14d70:	e1a00004 	mov	r0, r4
57e14d74:	e1a01007 	mov	r1, r7
					       info->write_tout, "write");
}
57e14d78:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}

	if (use_flash_status_poll(info))
		return flash_status_poll(info, &cword, dstaddr,
					 info->write_tout, "write");
	else
		return flash_full_status_check(info, sect,
57e14d7c:	eafffeb5 	b	57e14858 <flash_full_status_check>
					       info->write_tout, "write");
}
57e14d80:	e3a00002 	mov	r0, #2
57e14d84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e14d88:	0000fff0 	.word	0x0000fff0
57e14d8c:	57e308c1 	.word	0x57e308c1

57e14d90 <flash_erase>:
	int rcode = 0;
	int prot;
	flash_sect_t sect;
	int st;

	if (info->flash_id != FLASH_MAN_CFI) {
57e14d90:	e5903008 	ldr	r3, [r0, #8]


/*-----------------------------------------------------------------------
 */
int flash_erase (flash_info_t * info, int s_first, int s_last)
{
57e14d94:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int rcode = 0;
	int prot;
	flash_sect_t sect;
	int st;

	if (info->flash_id != FLASH_MAN_CFI) {
57e14d98:	e3530401 	cmp	r3, #16777216	; 0x1000000


/*-----------------------------------------------------------------------
 */
int flash_erase (flash_info_t * info, int s_first, int s_last)
{
57e14d9c:	e1a04000 	mov	r4, r0
57e14da0:	e1a05001 	mov	r5, r1
57e14da4:	e1a0a002 	mov	sl, r2
	int prot;
	flash_sect_t sect;
	int st;

	if (info->flash_id != FLASH_MAN_CFI) {
		puts ("Can't erase unknown flash type - aborted\n");
57e14da8:	159f01d8 	ldrne	r0, [pc, #472]	; 57e14f88 <flash_erase+0x1f8>
	int rcode = 0;
	int prot;
	flash_sect_t sect;
	int st;

	if (info->flash_id != FLASH_MAN_CFI) {
57e14dac:	1a000005 	bne	57e14dc8 <flash_erase+0x38>
		puts ("Can't erase unknown flash type - aborted\n");
		return 1;
	}
	if ((s_first < 0) || (s_first > s_last)) {
57e14db0:	e1a01fa1 	lsr	r1, r1, #31
57e14db4:	e1550002 	cmp	r5, r2
57e14db8:	c3811001 	orrgt	r1, r1, #1
57e14dbc:	e3510000 	cmp	r1, #0
57e14dc0:	0a000003 	beq	57e14dd4 <flash_erase+0x44>
		puts ("- no sectors to erase\n");
57e14dc4:	e59f01c0 	ldr	r0, [pc, #448]	; 57e14f8c <flash_erase+0x1fc>
57e14dc8:	ebffd195 	bl	57e09424 <puts>
		return 1;
57e14dcc:	e3a07001 	mov	r7, #1
57e14dd0:	ea00006a 	b	57e14f80 <flash_erase+0x1f0>
#endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */


/*-----------------------------------------------------------------------
 */
int flash_erase (flash_info_t * info, int s_first, int s_last)
57e14dd4:	e0849005 	add	r9, r4, r5
57e14dd8:	e28990ab 	add	r9, r9, #171	; 0xab
		puts ("- no sectors to erase\n");
		return 1;
	}

	prot = 0;
	for (sect = s_first; sect <= s_last; ++sect) {
57e14ddc:	e1a02009 	mov	r2, r9
57e14de0:	e1a03005 	mov	r3, r5
57e14de4:	ea000003 	b	57e14df8 <flash_erase+0x68>
		if (info->protect[sect]) {
57e14de8:	e5f20001 	ldrb	r0, [r2, #1]!
		puts ("- no sectors to erase\n");
		return 1;
	}

	prot = 0;
	for (sect = s_first; sect <= s_last; ++sect) {
57e14dec:	e2833001 	add	r3, r3, #1
		if (info->protect[sect]) {
57e14df0:	e3500000 	cmp	r0, #0
			prot++;
57e14df4:	12811001 	addne	r1, r1, #1
		puts ("- no sectors to erase\n");
		return 1;
	}

	prot = 0;
	for (sect = s_first; sect <= s_last; ++sect) {
57e14df8:	e153000a 	cmp	r3, sl
57e14dfc:	9afffff9 	bls	57e14de8 <flash_erase+0x58>
		if (info->protect[sect]) {
			prot++;
		}
	}
	if (prot) {
57e14e00:	e3510000 	cmp	r1, #0
57e14e04:	0a000002 	beq	57e14e14 <flash_erase+0x84>
		printf ("- Warning: %d protected sectors will not be erased!\n",
57e14e08:	e59f0180 	ldr	r0, [pc, #384]	; 57e14f90 <flash_erase+0x200>
57e14e0c:	ebffd18e 	bl	57e0944c <printf>
57e14e10:	ea000001 	b	57e14e1c <flash_erase+0x8c>
			prot);
	} else if (flash_verbose) {
		putc ('\n');
57e14e14:	e3a0000a 	mov	r0, #10
57e14e18:	ebffd177 	bl	57e093fc <putc>

/*-----------------------------------------------------------------------
 */
int flash_erase (flash_info_t * info, int s_first, int s_last)
{
	int rcode = 0;
57e14e1c:	e3a07000 	mov	r7, #0
				if (flash_verbose)
					putc(',');
				continue;
			}
#endif
			switch (info->vendor) {
57e14e20:	e59fb16c 	ldr	fp, [pc, #364]	; 57e14f94 <flash_erase+0x204>
	} else if (flash_verbose) {
		putc ('\n');
	}


	for (sect = s_first; sect <= s_last; sect++) {
57e14e24:	ea000051 	b	57e14f70 <flash_erase+0x1e0>
		if (ctrlc()) {
57e14e28:	ebffd1ac 	bl	57e094e0 <ctrlc>
57e14e2c:	e3500000 	cmp	r0, #0
57e14e30:	0a000002 	beq	57e14e40 <flash_erase+0xb0>
			printf("\n");
57e14e34:	e59f015c 	ldr	r0, [pc, #348]	; 57e14f98 <flash_erase+0x208>
57e14e38:	ebffd183 	bl	57e0944c <printf>
57e14e3c:	eaffffe2 	b	57e14dcc <flash_erase+0x3c>
			return 1;
		}

		if (info->protect[sect] == 0) { /* not protected */
57e14e40:	e5f96001 	ldrb	r6, [r9, #1]!
57e14e44:	e3560000 	cmp	r6, #0
57e14e48:	1a000047 	bne	57e14f6c <flash_erase+0x1dc>
				if (flash_verbose)
					putc(',');
				continue;
			}
#endif
			switch (info->vendor) {
57e14e4c:	e1d43eb4 	ldrh	r3, [r4, #228]	; 0xe4
57e14e50:	e3530003 	cmp	r3, #3
57e14e54:	0a00000b 	beq	57e14e88 <flash_erase+0xf8>
57e14e58:	8a000003 	bhi	57e14e6c <flash_erase+0xdc>
57e14e5c:	e3530001 	cmp	r3, #1
57e14e60:	0a000008 	beq	57e14e88 <flash_erase+0xf8>
57e14e64:	e3530002 	cmp	r3, #2
57e14e68:	ea000004 	b	57e14e80 <flash_erase+0xf0>
57e14e6c:	e3530c02 	cmp	r3, #512	; 0x200
57e14e70:	0a000004 	beq	57e14e88 <flash_erase+0xf8>
57e14e74:	e153000b 	cmp	r3, fp
57e14e78:	0a000021 	beq	57e14f04 <flash_erase+0x174>
57e14e7c:	e3530004 	cmp	r3, #4
57e14e80:	1a00002f 	bne	57e14f44 <flash_erase+0x1b4>
57e14e84:	ea00000e 	b	57e14ec4 <flash_erase+0x134>
			case CFI_CMDSET_INTEL_PROG_REGIONS:
			case CFI_CMDSET_INTEL_STANDARD:
			case CFI_CMDSET_INTEL_EXTENDED:
				flash_write_cmd (info, sect, 0,
57e14e88:	e1a00004 	mov	r0, r4
57e14e8c:	e1a01005 	mov	r1, r5
57e14e90:	e3a02000 	mov	r2, #0
57e14e94:	e3a03050 	mov	r3, #80	; 0x50
57e14e98:	ebfffddb 	bl	57e1460c <flash_write_cmd>
						 FLASH_CMD_CLEAR_STATUS);
				flash_write_cmd (info, sect, 0,
57e14e9c:	e1a00004 	mov	r0, r4
57e14ea0:	e1a01005 	mov	r1, r5
57e14ea4:	e3a02000 	mov	r2, #0
57e14ea8:	e3a03020 	mov	r3, #32
57e14eac:	ebfffdd6 	bl	57e1460c <flash_write_cmd>
						 FLASH_CMD_BLOCK_ERASE);
				flash_write_cmd (info, sect, 0,
57e14eb0:	e1a00004 	mov	r0, r4
57e14eb4:	e1a01005 	mov	r1, r5
57e14eb8:	e3a02000 	mov	r2, #0
57e14ebc:	e3a030d0 	mov	r3, #208	; 0xd0
57e14ec0:	ea00001e 	b	57e14f40 <flash_erase+0x1b0>
						 FLASH_CMD_ERASE_CONFIRM);
				break;
			case CFI_CMDSET_AMD_STANDARD:
			case CFI_CMDSET_AMD_EXTENDED:
				flash_unlock_seq (info, sect);
57e14ec4:	e1a00004 	mov	r0, r4
57e14ec8:	e1a01005 	mov	r1, r5
57e14ecc:	ebfffe10 	bl	57e14714 <flash_unlock_seq>
				flash_write_cmd (info, sect,
57e14ed0:	e59420fc 	ldr	r2, [r4, #252]	; 0xfc
57e14ed4:	e3a03080 	mov	r3, #128	; 0x80
57e14ed8:	e1a00004 	mov	r0, r4
57e14edc:	e1a01005 	mov	r1, r5
57e14ee0:	ebfffdc9 	bl	57e1460c <flash_write_cmd>
						info->addr_unlock1,
						AMD_CMD_ERASE_START);
				flash_unlock_seq (info, sect);
57e14ee4:	e1a00004 	mov	r0, r4
57e14ee8:	e1a01005 	mov	r1, r5
57e14eec:	ebfffe08 	bl	57e14714 <flash_unlock_seq>
				flash_write_cmd (info, sect, 0,
57e14ef0:	e1a00004 	mov	r0, r4
57e14ef4:	e1a01005 	mov	r1, r5
57e14ef8:	e3a02000 	mov	r2, #0
57e14efc:	e5d430e8 	ldrb	r3, [r4, #232]	; 0xe8
57e14f00:	ea00000e 	b	57e14f40 <flash_erase+0x1b0>
						 info->cmd_erase_sector);
				break;
#ifdef CONFIG_FLASH_CFI_LEGACY
			case CFI_CMDSET_AMD_LEGACY:
				flash_unlock_seq (info, 0);
57e14f04:	e1a00004 	mov	r0, r4
57e14f08:	e1a01006 	mov	r1, r6
57e14f0c:	ebfffe00 	bl	57e14714 <flash_unlock_seq>
				flash_write_cmd (info, 0, info->addr_unlock1,
57e14f10:	e59420fc 	ldr	r2, [r4, #252]	; 0xfc
57e14f14:	e3a03080 	mov	r3, #128	; 0x80
57e14f18:	e1a00004 	mov	r0, r4
57e14f1c:	e1a01006 	mov	r1, r6
57e14f20:	ebfffdb9 	bl	57e1460c <flash_write_cmd>
						AMD_CMD_ERASE_START);
				flash_unlock_seq (info, 0);
57e14f24:	e1a00004 	mov	r0, r4
57e14f28:	e1a01006 	mov	r1, r6
57e14f2c:	ebfffdf8 	bl	57e14714 <flash_unlock_seq>
				flash_write_cmd (info, sect, 0,
57e14f30:	e1a00004 	mov	r0, r4
57e14f34:	e1a01005 	mov	r1, r5
57e14f38:	e1a02006 	mov	r2, r6
57e14f3c:	e3a03030 	mov	r3, #48	; 0x30
57e14f40:	ebfffdb1 	bl	57e1460c <flash_write_cmd>
				dest = flash_map(info, sect, 0);
				st = flash_status_poll(info, &cword, dest,
						       info->erase_blk_tout, "erase");
				flash_unmap(info, sect, 0, dest);
			} else
				st = flash_full_status_check(info, sect,
57e14f44:	e1a00004 	mov	r0, r4
57e14f48:	e1a01005 	mov	r1, r5
57e14f4c:	e59420d8 	ldr	r2, [r4, #216]	; 0xd8
57e14f50:	e59f3044 	ldr	r3, [pc, #68]	; 57e14f9c <flash_erase+0x20c>
57e14f54:	ebfffe3f 	bl	57e14858 <flash_full_status_check>
							     info->erase_blk_tout,
							     "erase");
			if (st)
57e14f58:	e3500000 	cmp	r0, #0
				rcode = 1;
57e14f5c:	13a07001 	movne	r7, #1
				flash_unmap(info, sect, 0, dest);
			} else
				st = flash_full_status_check(info, sect,
							     info->erase_blk_tout,
							     "erase");
			if (st)
57e14f60:	1a000001 	bne	57e14f6c <flash_erase+0x1dc>
				rcode = 1;
			else if (flash_verbose)
				putc ('.');
57e14f64:	e280002e 	add	r0, r0, #46	; 0x2e
57e14f68:	ebffd123 	bl	57e093fc <putc>
	} else if (flash_verbose) {
		putc ('\n');
	}


	for (sect = s_first; sect <= s_last; sect++) {
57e14f6c:	e2855001 	add	r5, r5, #1
57e14f70:	e155000a 	cmp	r5, sl
57e14f74:	9affffab 	bls	57e14e28 <flash_erase+0x98>
				putc ('.');
		}
	}

	if (flash_verbose)
		puts (" done\n");
57e14f78:	e59f0020 	ldr	r0, [pc, #32]	; 57e14fa0 <flash_erase+0x210>
57e14f7c:	ebffd128 	bl	57e09424 <puts>

	return rcode;
}
57e14f80:	e1a00007 	mov	r0, r7
57e14f84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e14f88:	57e33562 	.word	0x57e33562
57e14f8c:	57e3358c 	.word	0x57e3358c
57e14f90:	57e335a3 	.word	0x57e335a3
57e14f94:	0000fff0 	.word	0x0000fff0
57e14f98:	57e32390 	.word	0x57e32390
57e14f9c:	57e2f9cf 	.word	0x57e2f9cf
57e14fa0:	57e335d8 	.word	0x57e335d8

57e14fa4 <flash_print_info>:

void flash_print_info (flash_info_t * info)
{
	int i;

	if (info->flash_id != FLASH_MAN_CFI) {
57e14fa4:	e5903008 	ldr	r3, [r0, #8]
	return 1;			/* erased */
}
#endif /* CONFIG_SYS_FLASH_EMPTY_INFO */

void flash_print_info (flash_info_t * info)
{
57e14fa8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
	int i;

	if (info->flash_id != FLASH_MAN_CFI) {
57e14fac:	e3530401 	cmp	r3, #16777216	; 0x1000000
	return 1;			/* erased */
}
#endif /* CONFIG_SYS_FLASH_EMPTY_INFO */

void flash_print_info (flash_info_t * info)
{
57e14fb0:	e1a04000 	mov	r4, r0
	int i;

	if (info->flash_id != FLASH_MAN_CFI) {
57e14fb4:	0a000002 	beq	57e14fc4 <flash_print_info+0x20>
		puts ("missing or unknown FLASH type\n");
57e14fb8:	e59f01e0 	ldr	r0, [pc, #480]	; 57e151a0 <flash_print_info+0x1fc>
			info->protect[i] ? "RO" : "  ");
#endif
	}
	putc ('\n');
	return;
}
57e14fbc:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
void flash_print_info (flash_info_t * info)
{
	int i;

	if (info->flash_id != FLASH_MAN_CFI) {
		puts ("missing or unknown FLASH type\n");
57e14fc0:	eaffd117 	b	57e09424 <puts>
		return;
	}

	printf ("%s flash (%d x %d)",
57e14fc4:	e5d020d4 	ldrb	r2, [r0, #212]	; 0xd4
57e14fc8:	e5d030d5 	ldrb	r3, [r0, #213]	; 0xd5
57e14fcc:	e5941104 	ldr	r1, [r4, #260]	; 0x104
57e14fd0:	e1a03183 	lsl	r3, r3, #3
57e14fd4:	e1a02182 	lsl	r2, r2, #3
57e14fd8:	e59f01c4 	ldr	r0, [pc, #452]	; 57e151a4 <flash_print_info+0x200>
57e14fdc:	ebffd11a 	bl	57e0944c <printf>
		info->name,
		(info->portwidth << 3), (info->chipwidth << 3));
	if (info->size < 1024*1024)
57e14fe0:	e5941000 	ldr	r1, [r4]
57e14fe4:	e1d420b4 	ldrh	r2, [r4, #4]
57e14fe8:	e3510601 	cmp	r1, #1048576	; 0x100000
		printf ("  Size: %ld kB in %d Sectors\n",
57e14fec:	31a01521 	lsrcc	r1, r1, #10
			info->size >> 10, info->sector_count);
	else
		printf ("  Size: %ld MB in %d Sectors\n",
57e14ff0:	21a01a21 	lsrcs	r1, r1, #20

	printf ("%s flash (%d x %d)",
		info->name,
		(info->portwidth << 3), (info->chipwidth << 3));
	if (info->size < 1024*1024)
		printf ("  Size: %ld kB in %d Sectors\n",
57e14ff4:	359f01ac 	ldrcc	r0, [pc, #428]	; 57e151a8 <flash_print_info+0x204>
			info->size >> 10, info->sector_count);
	else
		printf ("  Size: %ld MB in %d Sectors\n",
57e14ff8:	259f01ac 	ldrcs	r0, [pc, #428]	; 57e151ac <flash_print_info+0x208>
57e14ffc:	ebffd112 	bl	57e0944c <printf>
			info->size >> 20, info->sector_count);
	printf ("  ");
57e15000:	e59f01a8 	ldr	r0, [pc, #424]	; 57e151b0 <flash_print_info+0x20c>
57e15004:	ebffd110 	bl	57e0944c <printf>
	switch (info->vendor) {
57e15008:	e1d41eb4 	ldrh	r1, [r4, #228]	; 0xe4
57e1500c:	e3510003 	cmp	r1, #3
57e15010:	0a00000f 	beq	57e15054 <flash_print_info+0xb0>
57e15014:	8a000004 	bhi	57e1502c <flash_print_info+0x88>
57e15018:	e3510001 	cmp	r1, #1
57e1501c:	0a00000f 	beq	57e15060 <flash_print_info+0xbc>
57e15020:	e3510002 	cmp	r1, #2
57e15024:	1a000015 	bne	57e15080 <flash_print_info+0xdc>
57e15028:	ea00000e 	b	57e15068 <flash_print_info+0xc4>
57e1502c:	e3510c02 	cmp	r1, #512	; 0x200
57e15030:	0a000005 	beq	57e1504c <flash_print_info+0xa8>
57e15034:	e59f3178 	ldr	r3, [pc, #376]	; 57e151b4 <flash_print_info+0x210>
57e15038:	e1510003 	cmp	r1, r3
57e1503c:	0a00000d 	beq	57e15078 <flash_print_info+0xd4>
57e15040:	e3510004 	cmp	r1, #4
57e15044:	1a00000d 	bne	57e15080 <flash_print_info+0xdc>
57e15048:	ea000008 	b	57e15070 <flash_print_info+0xcc>
		case CFI_CMDSET_INTEL_PROG_REGIONS:
			printf ("Intel Prog Regions");
57e1504c:	e59f0164 	ldr	r0, [pc, #356]	; 57e151b8 <flash_print_info+0x214>
57e15050:	ea000000 	b	57e15058 <flash_print_info+0xb4>
			break;
		case CFI_CMDSET_INTEL_STANDARD:
			printf ("Intel Standard");
57e15054:	e59f0160 	ldr	r0, [pc, #352]	; 57e151bc <flash_print_info+0x218>
57e15058:	ebffd0fb 	bl	57e0944c <printf>
			break;
57e1505c:	ea000009 	b	57e15088 <flash_print_info+0xe4>
		case CFI_CMDSET_INTEL_EXTENDED:
			printf ("Intel Extended");
57e15060:	e59f0158 	ldr	r0, [pc, #344]	; 57e151c0 <flash_print_info+0x21c>
57e15064:	eafffffb 	b	57e15058 <flash_print_info+0xb4>
			break;
		case CFI_CMDSET_AMD_STANDARD:
			printf ("AMD Standard");
57e15068:	e59f0154 	ldr	r0, [pc, #340]	; 57e151c4 <flash_print_info+0x220>
57e1506c:	eafffff9 	b	57e15058 <flash_print_info+0xb4>
			break;
		case CFI_CMDSET_AMD_EXTENDED:
			printf ("AMD Extended");
57e15070:	e59f0150 	ldr	r0, [pc, #336]	; 57e151c8 <flash_print_info+0x224>
57e15074:	eafffff7 	b	57e15058 <flash_print_info+0xb4>
			break;
#ifdef CONFIG_FLASH_CFI_LEGACY
		case CFI_CMDSET_AMD_LEGACY:
			printf ("AMD Legacy");
57e15078:	e59f014c 	ldr	r0, [pc, #332]	; 57e151cc <flash_print_info+0x228>
57e1507c:	eafffff5 	b	57e15058 <flash_print_info+0xb4>
			break;
#endif
		default:
			printf ("Unknown (%d)", info->vendor);
57e15080:	e59f0148 	ldr	r0, [pc, #328]	; 57e151d0 <flash_print_info+0x22c>
57e15084:	ebffd0f0 	bl	57e0944c <printf>
			break;
	}
	printf (" command set, Manufacturer ID: 0x%02X, Device ID: 0x",
57e15088:	e1d41ebe 	ldrh	r1, [r4, #238]	; 0xee
57e1508c:	e59f0140 	ldr	r0, [pc, #320]	; 57e151d4 <flash_print_info+0x230>
57e15090:	ebffd0ed 	bl	57e0944c <printf>
		info->manufacturer_id);
	printf (info->chipwidth == FLASH_CFI_16BIT ? "%04X" : "%02X",
57e15094:	e5d400d5 	ldrb	r0, [r4, #213]	; 0xd5
57e15098:	e59f6138 	ldr	r6, [pc, #312]	; 57e151d8 <flash_print_info+0x234>
57e1509c:	e59f5138 	ldr	r5, [pc, #312]	; 57e151dc <flash_print_info+0x238>
57e150a0:	e3500002 	cmp	r0, #2
57e150a4:	11a00006 	movne	r0, r6
57e150a8:	01a00005 	moveq	r0, r5
57e150ac:	e1d41fb0 	ldrh	r1, [r4, #240]	; 0xf0
57e150b0:	ebffd0e5 	bl	57e0944c <printf>
		info->device_id);
	if ((info->device_id & 0xff) == 0x7E) {
57e150b4:	e5d430f0 	ldrb	r3, [r4, #240]	; 0xf0
57e150b8:	e353007e 	cmp	r3, #126	; 0x7e
57e150bc:	1a000005 	bne	57e150d8 <flash_print_info+0x134>
		printf(info->chipwidth == FLASH_CFI_16BIT ? "%04X" : "%02X",
57e150c0:	e5d400d5 	ldrb	r0, [r4, #213]	; 0xd5
57e150c4:	e1d41fb2 	ldrh	r1, [r4, #242]	; 0xf2
57e150c8:	e3500002 	cmp	r0, #2
57e150cc:	11a00006 	movne	r0, r6
57e150d0:	01a00005 	moveq	r0, r5
57e150d4:	ebffd0dc 	bl	57e0944c <printf>
		info->device_id2);
	}
	if ((info->vendor == CFI_CMDSET_AMD_STANDARD) && (info->legacy_unlock))
57e150d8:	e1d43eb4 	ldrh	r3, [r4, #228]	; 0xe4
57e150dc:	e3530002 	cmp	r3, #2
57e150e0:	1a000004 	bne	57e150f8 <flash_print_info+0x154>
57e150e4:	e1d43ebc 	ldrh	r3, [r4, #236]	; 0xec
57e150e8:	e3530000 	cmp	r3, #0
57e150ec:	0a000001 	beq	57e150f8 <flash_print_info+0x154>
		printf("\n  Advanced Sector Protection (PPB) enabled");
57e150f0:	e59f00e8 	ldr	r0, [pc, #232]	; 57e151e0 <flash_print_info+0x23c>
57e150f4:	ebffd0d4 	bl	57e0944c <printf>
	printf ("\n  Erase timeout: %ld ms, write timeout: %ld ms\n",
57e150f8:	e59420dc 	ldr	r2, [r4, #220]	; 0xdc
57e150fc:	e59f00e0 	ldr	r0, [pc, #224]	; 57e151e4 <flash_print_info+0x240>
57e15100:	e59410d8 	ldr	r1, [r4, #216]	; 0xd8
57e15104:	ebffd0d0 	bl	57e0944c <printf>
		info->erase_blk_tout,
		info->write_tout);
	if (info->buffer_size > 1) {
57e15108:	e1d42db6 	ldrh	r2, [r4, #214]	; 0xd6
57e1510c:	e3520001 	cmp	r2, #1
57e15110:	9a000002 	bls	57e15120 <flash_print_info+0x17c>
		printf ("  Buffer write timeout: %ld ms, "
57e15114:	e59f00cc 	ldr	r0, [pc, #204]	; 57e151e8 <flash_print_info+0x244>
57e15118:	e59410e0 	ldr	r1, [r4, #224]	; 0xe0
57e1511c:	ebffd0ca 	bl	57e0944c <printf>
			"buffer size: %d bytes\n",
		info->buffer_write_tout,
		info->buffer_size);
	}

	puts ("\n  Sector Start Addresses:");
57e15120:	e59f00c4 	ldr	r0, [pc, #196]	; 57e151ec <flash_print_info+0x248>
57e15124:	ebffd0be 	bl	57e09424 <puts>

	return 1;			/* erased */
}
#endif /* CONFIG_SYS_FLASH_EMPTY_INFO */

void flash_print_info (flash_info_t * info)
57e15128:	e2847008 	add	r7, r4, #8
57e1512c:	e28460ab 	add	r6, r4, #171	; 0xab
		info->buffer_write_tout,
		info->buffer_size);
	}

	puts ("\n  Sector Start Addresses:");
	for (i = 0; i < info->sector_count; ++i) {
57e15130:	e3a05000 	mov	r5, #0
		printf ("  %08lX %c %s ",
			info->start[i],
			sector_erased(info, i) ? 'E' : ' ',
			info->protect[i] ? "RO" : "  ");
#else	/* ! CONFIG_SYS_FLASH_EMPTY_INFO */
		printf ("  %08lX   %s ",
57e15134:	e59fa074 	ldr	sl, [pc, #116]	; 57e151b0 <flash_print_info+0x20c>
57e15138:	e59f90b0 	ldr	r9, [pc, #176]	; 57e151f0 <flash_print_info+0x24c>
		info->buffer_write_tout,
		info->buffer_size);
	}

	puts ("\n  Sector Start Addresses:");
	for (i = 0; i < info->sector_count; ++i) {
57e1513c:	ea000011 	b	57e15188 <flash_print_info+0x1e4>
		if (ctrlc())
57e15140:	ebffd0e6 	bl	57e094e0 <ctrlc>
57e15144:	e3500000 	cmp	r0, #0
57e15148:	1a000011 	bne	57e15194 <flash_print_info+0x1f0>
			break;
		if ((i % 5) == 0)
57e1514c:	e1a00005 	mov	r0, r5
57e15150:	e3a01005 	mov	r1, #5
57e15154:	eb005aa0 	bl	57e2bbdc <__aeabi_idivmod>
57e15158:	e3510000 	cmp	r1, #0
57e1515c:	1a000001 	bne	57e15168 <flash_print_info+0x1c4>
			putc('\n');
57e15160:	e3a0000a 	mov	r0, #10
57e15164:	ebffd0a4 	bl	57e093fc <putc>
		printf ("  %08lX %c %s ",
			info->start[i],
			sector_erased(info, i) ? 'E' : ' ',
			info->protect[i] ? "RO" : "  ");
#else	/* ! CONFIG_SYS_FLASH_EMPTY_INFO */
		printf ("  %08lX   %s ",
57e15168:	e5f62001 	ldrb	r2, [r6, #1]!
57e1516c:	e59f0080 	ldr	r0, [pc, #128]	; 57e151f4 <flash_print_info+0x250>
57e15170:	e3520000 	cmp	r2, #0
57e15174:	e5b71004 	ldr	r1, [r7, #4]!
57e15178:	01a0200a 	moveq	r2, sl
57e1517c:	11a02009 	movne	r2, r9
57e15180:	ebffd0b1 	bl	57e0944c <printf>
		info->buffer_write_tout,
		info->buffer_size);
	}

	puts ("\n  Sector Start Addresses:");
	for (i = 0; i < info->sector_count; ++i) {
57e15184:	e2855001 	add	r5, r5, #1
57e15188:	e1d430b4 	ldrh	r3, [r4, #4]
57e1518c:	e1550003 	cmp	r5, r3
57e15190:	baffffea 	blt	57e15140 <flash_print_info+0x19c>
		printf ("  %08lX   %s ",
			info->start[i],
			info->protect[i] ? "RO" : "  ");
#endif
	}
	putc ('\n');
57e15194:	e3a0000a 	mov	r0, #10
	return;
}
57e15198:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
		printf ("  %08lX   %s ",
			info->start[i],
			info->protect[i] ? "RO" : "  ");
#endif
	}
	putc ('\n');
57e1519c:	eaffd096 	b	57e093fc <putc>
57e151a0:	57e2f91b 	.word	0x57e2f91b
57e151a4:	57e335ec 	.word	0x57e335ec
57e151a8:	57e335ff 	.word	0x57e335ff
57e151ac:	57e3361d 	.word	0x57e3361d
57e151b0:	57e3509a 	.word	0x57e3509a
57e151b4:	0000fff0 	.word	0x0000fff0
57e151b8:	57e3363b 	.word	0x57e3363b
57e151bc:	57e3364e 	.word	0x57e3364e
57e151c0:	57e3365d 	.word	0x57e3365d
57e151c4:	57e3366c 	.word	0x57e3366c
57e151c8:	57e33679 	.word	0x57e33679
57e151cc:	57e33686 	.word	0x57e33686
57e151d0:	57e33691 	.word	0x57e33691
57e151d4:	57e3369e 	.word	0x57e3369e
57e151d8:	57e335e4 	.word	0x57e335e4
57e151dc:	57e335df 	.word	0x57e335df
57e151e0:	57e336d3 	.word	0x57e336d3
57e151e4:	57e336ff 	.word	0x57e336ff
57e151e8:	57e33730 	.word	0x57e33730
57e151ec:	57e33767 	.word	0x57e33767
57e151f0:	57e335e9 	.word	0x57e335e9
57e151f4:	57e33782 	.word	0x57e33782

57e151f8 <write_buff>:
 * 0 - OK
 * 1 - write timeout
 * 2 - Flash not erased
 */
int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
{
57e151f8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
			CONFIG_FLASH_SHOW_PROGRESS);
	}
#endif

	/* get lower aligned address */
	wp = (addr & ~(info->portwidth - 1));
57e151fc:	e5d0b0d4 	ldrb	fp, [r0, #212]	; 0xd4
 * 0 - OK
 * 1 - write timeout
 * 2 - Flash not erased
 */
int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
{
57e15200:	e1a04000 	mov	r4, r0
			CONFIG_FLASH_SHOW_PROGRESS);
	}
#endif

	/* get lower aligned address */
	wp = (addr & ~(info->portwidth - 1));
57e15204:	e26bb000 	rsb	fp, fp, #0
57e15208:	e002700b 	and	r7, r2, fp

	/* handle unaligned start */
	if ((aln = addr - wp) != 0) {
57e1520c:	e1d2b00b 	bics	fp, r2, fp
		cword.l = 0;
57e15210:	13a05000 	movne	r5, #0
57e15214:	128d9008 	addne	r9, sp, #8
 * 0 - OK
 * 1 - write timeout
 * 2 - Flash not erased
 */
int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
{
57e15218:	e1a0a001 	mov	sl, r1
57e1521c:	e1a06003 	mov	r6, r3
	/* get lower aligned address */
	wp = (addr & ~(info->portwidth - 1));

	/* handle unaligned start */
	if ((aln = addr - wp) != 0) {
		cword.l = 0;
57e15220:	15295008 	strne	r5, [r9, #-8]!

	/* get lower aligned address */
	wp = (addr & ~(info->portwidth - 1));

	/* handle unaligned start */
	if ((aln = addr - wp) != 0) {
57e15224:	1a000005 	bne	57e15240 <write_buff+0x48>
57e15228:	ea000040 	b	57e15330 <write_buff+0x138>
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e1522c:	e7d52007 	ldrb	r2, [r5, r7]
	/* handle unaligned start */
	if ((aln = addr - wp) != 0) {
		cword.l = 0;
		p = (uchar *)wp;
		for (i = 0; i < aln; ++i)
			flash_add_byte (info, &cword, flash_read8(p + i));
57e15230:	e5d400d4 	ldrb	r0, [r4, #212]	; 0xd4
57e15234:	e1a0100d 	mov	r1, sp
57e15238:	ebfffcb9 	bl	57e14524 <flash_add_byte.clone.6>

	/* handle unaligned start */
	if ((aln = addr - wp) != 0) {
		cword.l = 0;
		p = (uchar *)wp;
		for (i = 0; i < aln; ++i)
57e1523c:	e2855001 	add	r5, r5, #1
57e15240:	e155000b 	cmp	r5, fp
57e15244:	bafffff8 	blt	57e1522c <write_buff+0x34>
57e15248:	ea000005 	b	57e15264 <write_buff+0x6c>
			flash_add_byte (info, &cword, flash_read8(p + i));

		for (; (i < info->portwidth) && (cnt > 0); i++) {
			flash_add_byte (info, &cword, *src++);
57e1524c:	e1a0100d 	mov	r1, sp
57e15250:	e4da2001 	ldrb	r2, [sl], #1
57e15254:	ebfffcb2 	bl	57e14524 <flash_add_byte.clone.6>
			cnt--;
57e15258:	e2466001 	sub	r6, r6, #1
		cword.l = 0;
		p = (uchar *)wp;
		for (i = 0; i < aln; ++i)
			flash_add_byte (info, &cword, flash_read8(p + i));

		for (; (i < info->portwidth) && (cnt > 0); i++) {
57e1525c:	e2855001 	add	r5, r5, #1
57e15260:	ea000000 	b	57e15268 <write_buff+0x70>
			flash_add_byte (info, &cword, *src++);
57e15264:	e1a0900d 	mov	r9, sp
		cword.l = 0;
		p = (uchar *)wp;
		for (i = 0; i < aln; ++i)
			flash_add_byte (info, &cword, flash_read8(p + i));

		for (; (i < info->portwidth) && (cnt > 0); i++) {
57e15268:	e5d400d4 	ldrb	r0, [r4, #212]	; 0xd4
57e1526c:	e3560000 	cmp	r6, #0
57e15270:	11550000 	cmpne	r5, r0
57e15274:	bafffff4 	blt	57e1524c <write_buff+0x54>
			flash_add_byte (info, &cword, *src++);
			cnt--;
		}
		for (; (cnt == 0) && (i < info->portwidth); ++i)
57e15278:	e3560000 	cmp	r6, #0
57e1527c:	1a000009 	bne	57e152a8 <write_buff+0xb0>
57e15280:	ea000004 	b	57e15298 <write_buff+0xa0>
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e15284:	e7d52007 	ldrb	r2, [r5, r7]
		for (; (i < info->portwidth) && (cnt > 0); i++) {
			flash_add_byte (info, &cword, *src++);
			cnt--;
		}
		for (; (cnt == 0) && (i < info->portwidth); ++i)
			flash_add_byte (info, &cword, flash_read8(p + i));
57e15288:	e1a0100d 	mov	r1, sp
57e1528c:	ebfffca4 	bl	57e14524 <flash_add_byte.clone.6>

		for (; (i < info->portwidth) && (cnt > 0); i++) {
			flash_add_byte (info, &cword, *src++);
			cnt--;
		}
		for (; (cnt == 0) && (i < info->portwidth); ++i)
57e15290:	e2855001 	add	r5, r5, #1
57e15294:	ea000000 	b	57e1529c <write_buff+0xa4>
			flash_add_byte (info, &cword, flash_read8(p + i));
57e15298:	e1a0900d 	mov	r9, sp

		for (; (i < info->portwidth) && (cnt > 0); i++) {
			flash_add_byte (info, &cword, *src++);
			cnt--;
		}
		for (; (cnt == 0) && (i < info->portwidth); ++i)
57e1529c:	e5d400d4 	ldrb	r0, [r4, #212]	; 0xd4
57e152a0:	e1550000 	cmp	r5, r0
57e152a4:	bafffff6 	blt	57e15284 <write_buff+0x8c>
			flash_add_byte (info, &cword, flash_read8(p + i));

		rc = flash_write_cfiword (info, wp, cword);
57e152a8:	e1a01007 	mov	r1, r7
57e152ac:	e1a00004 	mov	r0, r4
57e152b0:	e89d000c 	ldm	sp, {r2, r3}
57e152b4:	ebfffe27 	bl	57e14b58 <flash_write_cfiword>
		if (rc != 0)
57e152b8:	e3500000 	cmp	r0, #0
			return rc;

		wp += i;
57e152bc:	00877005 	addeq	r7, r7, r5
		}
		for (; (cnt == 0) && (i < info->portwidth); ++i)
			flash_add_byte (info, &cword, flash_read8(p + i));

		rc = flash_write_cfiword (info, wp, cword);
		if (rc != 0)
57e152c0:	0a00001a 	beq	57e15330 <write_buff+0x138>
57e152c4:	ea00003e 	b	57e153c4 <write_buff+0x1cc>
		if ((cnt & 0xFFFF) < buffered_size && ctrlc())
			return ERR_ABORTED;
	}
#else
	while (cnt >= info->portwidth) {
		cword.l = 0;
57e152c8:	e58d9000 	str	r9, [sp]
		for (i = 0; i < info->portwidth; i++) {
57e152cc:	e1a05009 	mov	r5, r9
57e152d0:	ea000003 	b	57e152e4 <write_buff+0xec>
			flash_add_byte (info, &cword, *src++);
57e152d4:	e1a0100b 	mov	r1, fp
57e152d8:	e4da2001 	ldrb	r2, [sl], #1
57e152dc:	ebfffc90 	bl	57e14524 <flash_add_byte.clone.6>
			return ERR_ABORTED;
	}
#else
	while (cnt >= info->portwidth) {
		cword.l = 0;
		for (i = 0; i < info->portwidth; i++) {
57e152e0:	e2855001 	add	r5, r5, #1
57e152e4:	e5d400d4 	ldrb	r0, [r4, #212]	; 0xd4
57e152e8:	e1550000 	cmp	r5, r0
57e152ec:	bafffff8 	blt	57e152d4 <write_buff+0xdc>
			flash_add_byte (info, &cword, *src++);
		}
		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
57e152f0:	e1a00004 	mov	r0, r4
57e152f4:	e1a01007 	mov	r1, r7
57e152f8:	e89d000c 	ldm	sp, {r2, r3}
57e152fc:	ebfffe15 	bl	57e14b58 <flash_write_cfiword>
57e15300:	e3500000 	cmp	r0, #0
57e15304:	1a00002e 	bne	57e153c4 <write_buff+0x1cc>
			return rc;
		wp += info->portwidth;
57e15308:	e5d450d4 	ldrb	r5, [r4, #212]	; 0xd4
		cnt -= info->portwidth;
57e1530c:	e0656006 	rsb	r6, r5, r6
		FLASH_SHOW_PROGRESS(scale, dots, digit, info->portwidth);
		/* Only check every once in a while */
		if ((cnt & 0xFFFF) < info->portwidth && ctrlc())
57e15310:	e1a03806 	lsl	r3, r6, #16
57e15314:	e1550823 	cmp	r5, r3, lsr #16
57e15318:	9a000002 	bls	57e15328 <write_buff+0x130>
57e1531c:	ebffd06f 	bl	57e094e0 <ctrlc>
57e15320:	e3500000 	cmp	r0, #0
57e15324:	1a000023 	bne	57e153b8 <write_buff+0x1c0>
		for (i = 0; i < info->portwidth; i++) {
			flash_add_byte (info, &cword, *src++);
		}
		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
			return rc;
		wp += info->portwidth;
57e15328:	e0877005 	add	r7, r7, r5
57e1532c:	ea000001 	b	57e15338 <write_buff+0x140>
		if ((cnt & 0xFFFF) < buffered_size && ctrlc())
			return ERR_ABORTED;
	}
#else
	while (cnt >= info->portwidth) {
		cword.l = 0;
57e15330:	e3a09000 	mov	r9, #0
		for (i = 0; i < info->portwidth; i++) {
			flash_add_byte (info, &cword, *src++);
57e15334:	e1a0b00d 	mov	fp, sp
		/* Only check every once in a while */
		if ((cnt & 0xFFFF) < buffered_size && ctrlc())
			return ERR_ABORTED;
	}
#else
	while (cnt >= info->portwidth) {
57e15338:	e5d430d4 	ldrb	r3, [r4, #212]	; 0xd4
57e1533c:	e1560003 	cmp	r6, r3
57e15340:	2affffe0 	bcs	57e152c8 <write_buff+0xd0>
		if ((cnt & 0xFFFF) < info->portwidth && ctrlc())
			return ERR_ABORTED;
	}
#endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */

	if (cnt == 0) {
57e15344:	e3560000 	cmp	r6, #0
	}

	/*
	 * handle unaligned tail bytes
	 */
	cword.l = 0;
57e15348:	13a05000 	movne	r5, #0
57e1534c:	128d9008 	addne	r9, sp, #8
57e15350:	15295008 	strne	r5, [r9, #-8]!
		if ((cnt & 0xFFFF) < info->portwidth && ctrlc())
			return ERR_ABORTED;
	}
#endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */

	if (cnt == 0) {
57e15354:	1a000004 	bne	57e1536c <write_buff+0x174>
57e15358:	ea000018 	b	57e153c0 <write_buff+0x1c8>
	 * handle unaligned tail bytes
	 */
	cword.l = 0;
	p = (uchar *)wp;
	for (i = 0; (i < info->portwidth) && (cnt > 0); ++i) {
		flash_add_byte (info, &cword, *src++);
57e1535c:	e7da2005 	ldrb	r2, [sl, r5]
57e15360:	e1a0100d 	mov	r1, sp
57e15364:	ebfffc6e 	bl	57e14524 <flash_add_byte.clone.6>
	/*
	 * handle unaligned tail bytes
	 */
	cword.l = 0;
	p = (uchar *)wp;
	for (i = 0; (i < info->portwidth) && (cnt > 0); ++i) {
57e15368:	e2855001 	add	r5, r5, #1
57e1536c:	e5d400d4 	ldrb	r0, [r4, #212]	; 0xd4
57e15370:	e1560005 	cmp	r6, r5
57e15374:	11550000 	cmpne	r5, r0
57e15378:	bafffff7 	blt	57e1535c <write_buff+0x164>
57e1537c:	ea000004 	b	57e15394 <write_buff+0x19c>
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e15380:	e7d52007 	ldrb	r2, [r5, r7]
	for (i = 0; (i < info->portwidth) && (cnt > 0); ++i) {
		flash_add_byte (info, &cword, *src++);
		--cnt;
	}
	for (; i < info->portwidth; ++i)
		flash_add_byte (info, &cword, flash_read8(p + i));
57e15384:	e1a0100d 	mov	r1, sp
57e15388:	ebfffc65 	bl	57e14524 <flash_add_byte.clone.6>
	p = (uchar *)wp;
	for (i = 0; (i < info->portwidth) && (cnt > 0); ++i) {
		flash_add_byte (info, &cword, *src++);
		--cnt;
	}
	for (; i < info->portwidth; ++i)
57e1538c:	e2855001 	add	r5, r5, #1
57e15390:	ea000000 	b	57e15398 <write_buff+0x1a0>
		flash_add_byte (info, &cword, flash_read8(p + i));
57e15394:	e1a0600d 	mov	r6, sp
	p = (uchar *)wp;
	for (i = 0; (i < info->portwidth) && (cnt > 0); ++i) {
		flash_add_byte (info, &cword, *src++);
		--cnt;
	}
	for (; i < info->portwidth; ++i)
57e15398:	e5d400d4 	ldrb	r0, [r4, #212]	; 0xd4
57e1539c:	e1550000 	cmp	r5, r0
57e153a0:	bafffff6 	blt	57e15380 <write_buff+0x188>
		flash_add_byte (info, &cword, flash_read8(p + i));

	return flash_write_cfiword (info, wp, cword);
57e153a4:	e1a00004 	mov	r0, r4
57e153a8:	e1a01007 	mov	r1, r7
57e153ac:	e89d000c 	ldm	sp, {r2, r3}
57e153b0:	ebfffde8 	bl	57e14b58 <flash_write_cfiword>
57e153b4:	ea000002 	b	57e153c4 <write_buff+0x1cc>
		wp += info->portwidth;
		cnt -= info->portwidth;
		FLASH_SHOW_PROGRESS(scale, dots, digit, info->portwidth);
		/* Only check every once in a while */
		if ((cnt & 0xFFFF) < info->portwidth && ctrlc())
			return ERR_ABORTED;
57e153b8:	e3a00c01 	mov	r0, #256	; 0x100
57e153bc:	ea000000 	b	57e153c4 <write_buff+0x1cc>
	}
#endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */

	if (cnt == 0) {
		return (0);
57e153c0:	e1a00006 	mov	r0, r6
	}
	for (; i < info->portwidth; ++i)
		flash_add_byte (info, &cword, flash_read8(p + i));

	return flash_write_cfiword (info, wp, cword);
}
57e153c4:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

57e153c8 <flash_cmd_reset>:
	/*
	 * We do not yet know what kind of commandset to use, so we issue
	 * the reset command in both Intel and AMD variants, in the hope
	 * that AMD flash roms ignore the Intel command.
	 */
	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
57e153c8:	e3a01000 	mov	r1, #0
	for (i = 0; i < len; i++)
		p[i] = flash_read_uchar(info, start + i);
}

static void __flash_cmd_reset(flash_info_t *info)
{
57e153cc:	e92d4010 	push	{r4, lr}
	/*
	 * We do not yet know what kind of commandset to use, so we issue
	 * the reset command in both Intel and AMD variants, in the hope
	 * that AMD flash roms ignore the Intel command.
	 */
	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
57e153d0:	e1a02001 	mov	r2, r1
57e153d4:	e3a030f0 	mov	r3, #240	; 0xf0
	for (i = 0; i < len; i++)
		p[i] = flash_read_uchar(info, start + i);
}

static void __flash_cmd_reset(flash_info_t *info)
{
57e153d8:	e1a04000 	mov	r4, r0
	/*
	 * We do not yet know what kind of commandset to use, so we issue
	 * the reset command in both Intel and AMD variants, in the hope
	 * that AMD flash roms ignore the Intel command.
	 */
	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
57e153dc:	ebfffc8a 	bl	57e1460c <flash_write_cmd>
	udelay(1);
57e153e0:	e3a00001 	mov	r0, #1
57e153e4:	eb003c53 	bl	57e24538 <udelay>
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e153e8:	e3a01000 	mov	r1, #0
57e153ec:	e1a00004 	mov	r0, r4
57e153f0:	e1a02001 	mov	r2, r1
57e153f4:	e3a030ff 	mov	r3, #255	; 0xff
}
57e153f8:	e8bd4010 	pop	{r4, lr}
	 * the reset command in both Intel and AMD variants, in the hope
	 * that AMD flash roms ignore the Intel command.
	 */
	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
	udelay(1);
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e153fc:	eafffc82 	b	57e1460c <flash_write_cmd>

57e15400 <flash_get_size>:
/*
 * The following code cannot be run from FLASH!
 *
 */
ulong flash_get_size (phys_addr_t base, int banknum)
{
57e15400:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	flash_info_t *info = &flash_info[banknum];
57e15404:	e3a07f42 	mov	r7, #264	; 0x108
57e15408:	e0070791 	mul	r7, r1, r7
57e1540c:	e59f67b8 	ldr	r6, [pc, #1976]	; 57e15bcc <flash_get_size+0x7cc>
/*
 * The following code cannot be run from FLASH!
 *
 */
ulong flash_get_size (phys_addr_t base, int banknum)
{
57e15410:	e24dd058 	sub	sp, sp, #88	; 0x58
	flash_info_t *info = &flash_info[banknum];
57e15414:	e2865008 	add	r5, r6, #8
/*
 * The following code cannot be run from FLASH!
 *
 */
ulong flash_get_size (phys_addr_t base, int banknum)
{
57e15418:	e58d0008 	str	r0, [sp, #8]
57e1541c:	e1a04001 	mov	r4, r1
	flash_info_t *info = &flash_info[banknum];
57e15420:	e0855007 	add	r5, r5, r7
	int erase_region_size;
	int erase_region_count;
	struct cfi_qry qry;
	unsigned long max_size;

	memset(&qry, 0, sizeof(qry));
57e15424:	e3a01000 	mov	r1, #0

	info->ext_addr = 0;
57e15428:	e0867007 	add	r7, r6, r7
	int erase_region_size;
	int erase_region_count;
	struct cfi_qry qry;
	unsigned long max_size;

	memset(&qry, 0, sizeof(qry));
57e1542c:	e28d0028 	add	r0, sp, #40	; 0x28
57e15430:	e3a0202d 	mov	r2, #45	; 0x2d
57e15434:	eb003b90 	bl	57e2427c <memset>

	info->ext_addr = 0;
57e15438:	e28730f8 	add	r3, r7, #248	; 0xf8
57e1543c:	e3a00000 	mov	r0, #0
	info->cfi_version = 0;
#ifdef CONFIG_SYS_FLASH_PROTECTION
	info->legacy_unlock = 0;
#endif

	info->start[0] = (ulong)map_physmem(base, info->portwidth, MAP_NOCACHE);
57e15440:	e59d1008 	ldr	r1, [sp, #8]
	struct cfi_qry qry;
	unsigned long max_size;

	memset(&qry, 0, sizeof(qry));

	info->ext_addr = 0;
57e15444:	e1c300b4 	strh	r0, [r3, #4]
	info->cfi_version = 0;
57e15448:	e1c300b6 	strh	r0, [r3, #6]

static int flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
{
	debug ("flash detect cfi\n");

	for (info->portwidth = CONFIG_SYS_FLASH_CFI_WIDTH;
57e1544c:	e3a03002 	mov	r3, #2
	info->cfi_version = 0;
#ifdef CONFIG_SYS_FLASH_PROTECTION
	info->legacy_unlock = 0;
#endif

	info->start[0] = (ulong)map_physmem(base, info->portwidth, MAP_NOCACHE);
57e15450:	e5871014 	str	r1, [r7, #20]

static int flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
{
	debug ("flash detect cfi\n");

	for (info->portwidth = CONFIG_SYS_FLASH_CFI_WIDTH;
57e15454:	e5c730dc 	strb	r3, [r7, #220]	; 0xdc

/*
 * The following code cannot be run from FLASH!
 *
 */
ulong flash_get_size (phys_addr_t base, int banknum)
57e15458:	e59f9770 	ldr	r9, [pc, #1904]	; 57e15bd0 <flash_get_size+0x7d0>
57e1545c:	e1a06004 	mov	r6, r4
57e15460:	ea000060 	b	57e155e8 <flash_get_size+0x1e8>
{
	debug ("flash detect cfi\n");

	for (info->portwidth = CONFIG_SYS_FLASH_CFI_WIDTH;
	     info->portwidth <= FLASH_CFI_64BIT; info->portwidth <<= 1) {
		for (info->chipwidth = FLASH_CFI_BY8;
57e15464:	e3a02001 	mov	r2, #1
57e15468:	ea0001d0 	b	57e15bb0 <flash_get_size+0x7b0>
static int __flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
{
	int cfi_offset;

	/* Issue FLASH reset command */
	flash_cmd_reset(info);
57e1546c:	e1a00005 	mov	r0, r5
57e15470:	ebffffd4 	bl	57e153c8 <flash_cmd_reset>
57e15474:	e59f4758 	ldr	r4, [pc, #1880]	; 57e15bd4 <flash_get_size+0x7d4>
57e15478:	ea000055 	b	57e155d4 <flash_get_size+0x1d4>

	for (cfi_offset=0;
	     cfi_offset < sizeof(flash_offset_cfi) / sizeof(uint);
	     cfi_offset++) {
		flash_write_cmd (info, 0, flash_offset_cfi[cfi_offset],
57e1547c:	e5b4a004 	ldr	sl, [r4, #4]!
57e15480:	e1a00005 	mov	r0, r5
57e15484:	e3a01000 	mov	r1, #0
57e15488:	e1a0200a 	mov	r2, sl
57e1548c:	e3a03098 	mov	r3, #152	; 0x98
57e15490:	ebfffc5d 	bl	57e1460c <flash_write_cmd>
				 FLASH_CMD_CFI);
		if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
57e15494:	e1a00005 	mov	r0, r5
57e15498:	e3a01000 	mov	r1, #0
57e1549c:	e3a02010 	mov	r2, #16
57e154a0:	e3a03051 	mov	r3, #81	; 0x51
57e154a4:	ebfffb78 	bl	57e1428c <flash_isequal>
57e154a8:	e3500000 	cmp	r0, #0
57e154ac:	0a000048 	beq	57e155d4 <flash_get_size+0x1d4>
		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 1, 'R')
57e154b0:	e1a00005 	mov	r0, r5
57e154b4:	e3a01000 	mov	r1, #0
57e154b8:	e3a02011 	mov	r2, #17
57e154bc:	e3a03052 	mov	r3, #82	; 0x52
57e154c0:	ebfffb71 	bl	57e1428c <flash_isequal>
57e154c4:	e3500000 	cmp	r0, #0
57e154c8:	0a000041 	beq	57e155d4 <flash_get_size+0x1d4>
		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 2, 'Y')) {
57e154cc:	e1a00005 	mov	r0, r5
57e154d0:	e3a01000 	mov	r1, #0
57e154d4:	e3a02012 	mov	r2, #18
57e154d8:	e3a03059 	mov	r3, #89	; 0x59
57e154dc:	ebfffb6a 	bl	57e1428c <flash_isequal>
57e154e0:	e3500000 	cmp	r0, #0
57e154e4:	0a00003a 	beq	57e155d4 <flash_get_size+0x1d4>
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e154e8:	e59f36dc 	ldr	r3, [pc, #1756]	; 57e15bcc <flash_get_size+0x7cc>
57e154ec:	e3a02f42 	mov	r2, #264	; 0x108
57e154f0:	e0233692 	mla	r3, r2, r6, r3
57e154f4:	e5d300dc 	ldrb	r0, [r3, #220]	; 0xdc
57e154f8:	e5932014 	ldr	r2, [r3, #20]
57e154fc:	e1a04006 	mov	r4, r6
57e15500:	e0822200 	add	r2, r2, r0, lsl #4
57e15504:	e28d3027 	add	r3, sp, #39	; 0x27

/*
 * The following code cannot be run from FLASH!
 *
 */
ulong flash_get_size (phys_addr_t base, int banknum)
57e15508:	e28d1054 	add	r1, sp, #84	; 0x54
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e1550c:	e6d2c000 	ldrb	ip, [r2], r0
{
	u8 *p = buf;
	unsigned int i;

	for (i = 0; i < len; i++)
		p[i] = flash_read_uchar(info, start + i);
57e15510:	e5e3c001 	strb	ip, [r3, #1]!
		unsigned int start, size_t len)
{
	u8 *p = buf;
	unsigned int i;

	for (i = 0; i < len; i++)
57e15514:	e1530001 	cmp	r3, r1
57e15518:	1afffffb 	bne	57e1550c <flash_get_size+0x10c>
		if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 1, 'R')
		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 2, 'Y')) {
			flash_read_cfi(info, qry, FLASH_OFFSET_CFI_RESP,
					sizeof(struct cfi_qry));
			info->interface	= le16_to_cpu(qry->interface_desc);
57e1551c:	e59f36a8 	ldr	r3, [pc, #1704]	; 57e15bcc <flash_get_size+0x7cc>
57e15520:	e3a01f42 	mov	r1, #264	; 0x108
57e15524:	e0233491 	mla	r3, r1, r4, r3

			info->cfi_offset = flash_offset_cfi[cfi_offset];
57e15528:	e2831c01 	add	r1, r3, #256	; 0x100
		if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 1, 'R')
		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 2, 'Y')) {
			flash_read_cfi(info, qry, FLASH_OFFSET_CFI_RESP,
					sizeof(struct cfi_qry));
			info->interface	= le16_to_cpu(qry->interface_desc);
57e1552c:	e1dd24b0 	ldrh	r2, [sp, #64]	; 0x40

			info->cfi_offset = flash_offset_cfi[cfi_offset];
57e15530:	e1c1a0b0 	strh	sl, [r1]
			debug ("port %d bits chip %d bits\n",
			       info->portwidth << CFI_FLASH_SHIFT_WIDTH,
			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);

			/* calculate command offsets as in the Linux driver */
			info->addr_unlock1 = 0x555;
57e15534:	e59f169c 	ldr	r1, [pc, #1692]	; 57e15bd8 <flash_get_size+0x7d8>
		if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 1, 'R')
		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 2, 'Y')) {
			flash_read_cfi(info, qry, FLASH_OFFSET_CFI_RESP,
					sizeof(struct cfi_qry));
			info->interface	= le16_to_cpu(qry->interface_desc);
57e15538:	e1c32fb2 	strh	r2, [r3, #242]	; 0xf2
			debug ("port %d bits chip %d bits\n",
			       info->portwidth << CFI_FLASH_SHIFT_WIDTH,
			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);

			/* calculate command offsets as in the Linux driver */
			info->addr_unlock1 = 0x555;
57e1553c:	e5831104 	str	r1, [r3, #260]	; 0x104
			info->addr_unlock2 = 0x2aa;
57e15540:	e59f1694 	ldr	r1, [pc, #1684]	; 57e15bdc <flash_get_size+0x7dc>
57e15544:	e5831108 	str	r1, [r3, #264]	; 0x108
			/*
			 * modify the unlock address if we are
			 * in compatibility mode
			 */
			if (	/* x8/x16 in x8 mode */
				((info->chipwidth == FLASH_CFI_BY8) &&
57e15548:	e5d330dd 	ldrb	r3, [r3, #221]	; 0xdd

			/*
			 * modify the unlock address if we are
			 * in compatibility mode
			 */
			if (	/* x8/x16 in x8 mode */
57e1554c:	e3530001 	cmp	r3, #1
57e15550:	1a000001 	bne	57e1555c <flash_get_size+0x15c>
				((info->chipwidth == FLASH_CFI_BY8) &&
57e15554:	e3520002 	cmp	r2, #2
57e15558:	ea000002 	b	57e15568 <flash_get_size+0x168>
					(info->interface == FLASH_CFI_X8X16)) ||
57e1555c:	e3530002 	cmp	r3, #2
57e15560:	1a000008 	bne	57e15588 <flash_get_size+0x188>
				/* x16/x32 in x16 mode */
				((info->chipwidth == FLASH_CFI_BY16) &&
57e15564:	e3520005 	cmp	r2, #5
57e15568:	1a000006 	bne	57e15588 <flash_get_size+0x188>
					(info->interface == FLASH_CFI_X16X32)))
			{
				info->addr_unlock1 = 0xaaa;
57e1556c:	e59f3658 	ldr	r3, [pc, #1624]	; 57e15bcc <flash_get_size+0x7cc>
57e15570:	e3a02f42 	mov	r2, #264	; 0x108
57e15574:	e0233492 	mla	r3, r2, r4, r3
57e15578:	e59f2660 	ldr	r2, [pc, #1632]	; 57e15be0 <flash_get_size+0x7e0>
57e1557c:	e5832104 	str	r2, [r3, #260]	; 0x104
				info->addr_unlock2 = 0x555;
57e15580:	e59f2650 	ldr	r2, [pc, #1616]	; 57e15bd8 <flash_get_size+0x7d8>
57e15584:	e5832108 	str	r2, [r3, #264]	; 0x108
			}

			info->name = "CFI conformant";
57e15588:	e59f363c 	ldr	r3, [pc, #1596]	; 57e15bcc <flash_get_size+0x7cc>
57e1558c:	e3a02f42 	mov	r2, #264	; 0x108
57e15590:	e0233492 	mla	r3, r2, r4, r3
57e15594:	e59f2648 	ldr	r2, [pc, #1608]	; 57e15be4 <flash_get_size+0x7e4>
	info->start[0] = (ulong)map_physmem(base, info->portwidth, MAP_NOCACHE);

	if (flash_detect_cfi (info, &qry)) {
		info->vendor = le16_to_cpu(qry.p_id);
		info->ext_addr = le16_to_cpu(qry.p_adr);
		num_erase_regions = qry.num_erase_regions;
57e15598:	e5dd0044 	ldrb	r0, [sp, #68]	; 0x44
			{
				info->addr_unlock1 = 0xaaa;
				info->addr_unlock2 = 0x555;
			}

			info->name = "CFI conformant";
57e1559c:	e583210c 	str	r2, [r3, #268]	; 0x10c
#endif

	info->start[0] = (ulong)map_physmem(base, info->portwidth, MAP_NOCACHE);

	if (flash_detect_cfi (info, &qry)) {
		info->vendor = le16_to_cpu(qry.p_id);
57e155a0:	e5dd102c 	ldrb	r1, [sp, #44]	; 0x2c
57e155a4:	e5dd202b 	ldrb	r2, [sp, #43]	; 0x2b
		info->ext_addr = le16_to_cpu(qry.p_adr);
		num_erase_regions = qry.num_erase_regions;
57e155a8:	e58d000c 	str	r0, [sp, #12]
#endif

	info->start[0] = (ulong)map_physmem(base, info->portwidth, MAP_NOCACHE);

	if (flash_detect_cfi (info, &qry)) {
		info->vendor = le16_to_cpu(qry.p_id);
57e155ac:	e1822401 	orr	r2, r2, r1, lsl #8
57e155b0:	e1c32ebc 	strh	r2, [r3, #236]	; 0xec
		info->ext_addr = le16_to_cpu(qry.p_adr);
57e155b4:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
57e155b8:	e28320f8 	add	r2, r3, #248	; 0xf8
57e155bc:	e1a01401 	lsl	r1, r1, #8
57e155c0:	e1a01821 	lsr	r1, r1, #16
		num_erase_regions = qry.num_erase_regions;

		if (info->ext_addr) {
57e155c4:	e3510000 	cmp	r1, #0

	info->start[0] = (ulong)map_physmem(base, info->portwidth, MAP_NOCACHE);

	if (flash_detect_cfi (info, &qry)) {
		info->vendor = le16_to_cpu(qry.p_id);
		info->ext_addr = le16_to_cpu(qry.p_adr);
57e155c8:	e1c210b4 	strh	r1, [r2, #4]
		num_erase_regions = qry.num_erase_regions;

		if (info->ext_addr) {
57e155cc:	1a00000b 	bne	57e15600 <flash_get_size+0x200>
57e155d0:	ea000017 	b	57e15634 <flash_get_size+0x234>
	int cfi_offset;

	/* Issue FLASH reset command */
	flash_cmd_reset(info);

	for (cfi_offset=0;
57e155d4:	e1540009 	cmp	r4, r9
57e155d8:	1affffa7 	bne	57e1547c <flash_get_size+0x7c>
57e155dc:	ea000170 	b	57e15ba4 <flash_get_size+0x7a4>
static int flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
{
	debug ("flash detect cfi\n");

	for (info->portwidth = CONFIG_SYS_FLASH_CFI_WIDTH;
	     info->portwidth <= FLASH_CFI_64BIT; info->portwidth <<= 1) {
57e155e0:	e1a02082 	lsl	r2, r2, #1
57e155e4:	e5c32004 	strb	r2, [r3, #4]
57e155e8:	e28730d8 	add	r3, r7, #216	; 0xd8

static int flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
{
	debug ("flash detect cfi\n");

	for (info->portwidth = CONFIG_SYS_FLASH_CFI_WIDTH;
57e155ec:	e5d32004 	ldrb	r2, [r3, #4]
57e155f0:	e3520008 	cmp	r2, #8
57e155f4:	9affff9a 	bls	57e15464 <flash_get_size+0x64>
57e155f8:	e1a04006 	mov	r4, r6
57e155fc:	ea000162 	b	57e15b8c <flash_get_size+0x78c>
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e15600:	e5d3c0dc 	ldrb	ip, [r3, #220]	; 0xdc
		info->ext_addr = le16_to_cpu(qry.p_adr);
		num_erase_regions = qry.num_erase_regions;

		if (info->ext_addr) {
			info->cfi_version = (ushort) flash_read_uchar (info,
						info->ext_addr + 3) << 8;
57e15604:	e2811003 	add	r1, r1, #3
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e15608:	e001019c 	mul	r1, ip, r1

	return (void *)(info->start[sect] + byte_offset);
57e1560c:	e5930014 	ldr	r0, [r3, #20]
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e15610:	e7d13000 	ldrb	r3, [r1, r0]

		if (info->ext_addr) {
			info->cfi_version = (ushort) flash_read_uchar (info,
						info->ext_addr + 3) << 8;
			info->cfi_version |= (ushort) flash_read_uchar (info,
						info->ext_addr + 4);
57e15614:	e1d210b4 	ldrh	r1, [r2, #4]
		info->vendor = le16_to_cpu(qry.p_id);
		info->ext_addr = le16_to_cpu(qry.p_adr);
		num_erase_regions = qry.num_erase_regions;

		if (info->ext_addr) {
			info->cfi_version = (ushort) flash_read_uchar (info,
57e15618:	e1a03403 	lsl	r3, r3, #8
						info->ext_addr + 3) << 8;
			info->cfi_version |= (ushort) flash_read_uchar (info,
						info->ext_addr + 4);
57e1561c:	e2811004 	add	r1, r1, #4
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e15620:	e00c0c91 	mul	ip, r1, ip
		info->vendor = le16_to_cpu(qry.p_id);
		info->ext_addr = le16_to_cpu(qry.p_adr);
		num_erase_regions = qry.num_erase_regions;

		if (info->ext_addr) {
			info->cfi_version = (ushort) flash_read_uchar (info,
57e15624:	e1c230b6 	strh	r3, [r2, #6]
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e15628:	e7dc1000 	ldrb	r1, [ip, r0]
		num_erase_regions = qry.num_erase_regions;

		if (info->ext_addr) {
			info->cfi_version = (ushort) flash_read_uchar (info,
						info->ext_addr + 3) << 8;
			info->cfi_version |= (ushort) flash_read_uchar (info,
57e1562c:	e1833001 	orr	r3, r3, r1
57e15630:	e1c230b6 	strh	r3, [r2, #6]

#ifdef DEBUG
		flash_printqry (&qry);
#endif

		switch (info->vendor) {
57e15634:	e59f3590 	ldr	r3, [pc, #1424]	; 57e15bcc <flash_get_size+0x7cc>
57e15638:	e3a02f42 	mov	r2, #264	; 0x108
57e1563c:	e0233492 	mla	r3, r2, r4, r3
57e15640:	e1d31ebc 	ldrh	r1, [r3, #236]	; 0xec
57e15644:	e3510003 	cmp	r1, #3
57e15648:	0a000009 	beq	57e15674 <flash_get_size+0x274>
57e1564c:	8a000004 	bhi	57e15664 <flash_get_size+0x264>
57e15650:	e3510001 	cmp	r1, #1
57e15654:	0a000006 	beq	57e15674 <flash_get_size+0x274>
57e15658:	e3510002 	cmp	r1, #2
57e1565c:	1a000022 	bne	57e156ec <flash_get_size+0x2ec>
57e15660:	ea00000b 	b	57e15694 <flash_get_size+0x294>
57e15664:	e3510004 	cmp	r1, #4
57e15668:	0a000009 	beq	57e15694 <flash_get_size+0x294>
57e1566c:	e3510c02 	cmp	r1, #512	; 0x200
57e15670:	1a00001d 	bne	57e156ec <flash_get_size+0x2ec>
	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
}

static int cmdset_intel_init(flash_info_t *info, struct cfi_qry *qry)
{
	info->cmd_reset = FLASH_CMD_RESET;
57e15674:	e59f3550 	ldr	r3, [pc, #1360]	; 57e15bcc <flash_get_size+0x7cc>
57e15678:	e3a06f42 	mov	r6, #264	; 0x108
57e1567c:	e0263694 	mla	r6, r4, r6, r3
57e15680:	e3a010ff 	mov	r1, #255	; 0xff
57e15684:	e1c61ebe 	strh	r1, [r6, #238]	; 0xee

	cmdset_intel_read_jedec_ids(info);
57e15688:	e1a00005 	mov	r0, r5
57e1568c:	ebfffc01 	bl	57e14698 <cmdset_intel_read_jedec_ids>
57e15690:	ea000008 	b	57e156b8 <flash_get_size+0x2b8>
	udelay(1);
}

static int cmdset_amd_init(flash_info_t *info, struct cfi_qry *qry)
{
	info->cmd_reset = AMD_CMD_RESET;
57e15694:	e59f3530 	ldr	r3, [pc, #1328]	; 57e15bcc <flash_get_size+0x7cc>
57e15698:	e3a06f42 	mov	r6, #264	; 0x108
57e1569c:	e0263694 	mla	r6, r4, r6, r3
57e156a0:	e3a020f0 	mov	r2, #240	; 0xf0
	info->cmd_erase_sector = AMD_CMD_ERASE_SECTOR;
57e156a4:	e3a03030 	mov	r3, #48	; 0x30
	udelay(1);
}

static int cmdset_amd_init(flash_info_t *info, struct cfi_qry *qry)
{
	info->cmd_reset = AMD_CMD_RESET;
57e156a8:	e1c62ebe 	strh	r2, [r6, #238]	; 0xee
	info->cmd_erase_sector = AMD_CMD_ERASE_SECTOR;
57e156ac:	e5c630f0 	strb	r3, [r6, #240]	; 0xf0

	cmdset_amd_read_jedec_ids(info);
57e156b0:	e1a00005 	mov	r0, r5
57e156b4:	ebfffc22 	bl	57e14744 <cmdset_amd_read_jedec_ids>
	flash_write_cmd(info, 0, info->cfi_offset, FLASH_CMD_CFI);
57e156b8:	e2866c01 	add	r6, r6, #256	; 0x100
57e156bc:	e1d620b0 	ldrh	r2, [r6]
57e156c0:	e3a03098 	mov	r3, #152	; 0x98
57e156c4:	e1a00005 	mov	r0, r5
57e156c8:	e3a01000 	mov	r1, #0
57e156cc:	ebfffbce 	bl	57e1460c <flash_write_cmd>
			flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
			return 0;
		}

		/* Do manufacturer-specific fixups */
		switch (info->manufacturer_id) {
57e156d0:	e59f34f4 	ldr	r3, [pc, #1268]	; 57e15bcc <flash_get_size+0x7cc>
57e156d4:	e3a02f42 	mov	r2, #264	; 0x108
57e156d8:	e0233492 	mla	r3, r2, r4, r3
57e156dc:	e1d32fb6 	ldrh	r2, [r3, #246]	; 0xf6
57e156e0:	e3520020 	cmp	r2, #32
57e156e4:	1a000009 	bne	57e15710 <flash_get_size+0x310>
57e156e8:	ea000036 	b	57e157c8 <flash_get_size+0x3c8>
		case CFI_CMDSET_AMD_STANDARD:
		case CFI_CMDSET_AMD_EXTENDED:
			cmdset_amd_init(info, &qry);
			break;
		default:
			printf("CFI: Unknown command set 0x%x\n",
57e156ec:	e59f04f4 	ldr	r0, [pc, #1268]	; 57e15be8 <flash_get_size+0x7e8>
57e156f0:	ebffcf55 	bl	57e0944c <printf>
			/*
			 * Unfortunately, this means we don't know how
			 * to get the chip back to Read mode. Might
			 * as well try an Intel-style reset...
			 */
			flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
57e156f4:	e3a01000 	mov	r1, #0
57e156f8:	e1a00005 	mov	r0, r5
57e156fc:	e1a02001 	mov	r2, r1
57e15700:	e3a030ff 	mov	r3, #255	; 0xff
57e15704:	ebfffbc0 	bl	57e1460c <flash_write_cmd>
			return 0;
57e15708:	e3a00000 	mov	r0, #0
57e1570c:	ea000122 	b	57e15b9c <flash_get_size+0x79c>
		}

		/* Do manufacturer-specific fixups */
		switch (info->manufacturer_id) {
57e15710:	8a000004 	bhi	57e15728 <flash_get_size+0x328>
57e15714:	e3520001 	cmp	r2, #1
57e15718:	0a000007 	beq	57e1573c <flash_get_size+0x33c>
57e1571c:	e352001f 	cmp	r2, #31
57e15720:	1a00004b 	bne	57e15854 <flash_get_size+0x454>
57e15724:	ea000013 	b	57e15778 <flash_get_size+0x378>
57e15728:	e3520037 	cmp	r2, #55	; 0x37
57e1572c:	0a000002 	beq	57e1573c <flash_get_size+0x33c>
57e15730:	e35200bf 	cmp	r2, #191	; 0xbf
57e15734:	1a000046 	bne	57e15854 <flash_get_size+0x454>
57e15738:	ea00003e 	b	57e15838 <flash_get_size+0x438>
 * reversal, etc. here.
 */
static void flash_fixup_amd(flash_info_t *info, struct cfi_qry *qry)
{
	/* check if flash geometry needs reversal */
	if (qry->num_erase_regions > 1) {
57e1573c:	e5dd3044 	ldrb	r3, [sp, #68]	; 0x44
57e15740:	e3530001 	cmp	r3, #1
57e15744:	9a000042 	bls	57e15854 <flash_get_size+0x454>
		/* reverse geometry if top boot part */
		if (info->cfi_version < 0x3131) {
57e15748:	e59f347c 	ldr	r3, [pc, #1148]	; 57e15bcc <flash_get_size+0x7cc>
57e1574c:	e3a02f42 	mov	r2, #264	; 0x108
57e15750:	e0233492 	mla	r3, r2, r4, r3
57e15754:	e28320f8 	add	r2, r3, #248	; 0xf8
57e15758:	e1d200b6 	ldrh	r0, [r2, #6]
57e1575c:	e59f1488 	ldr	r1, [pc, #1160]	; 57e15bec <flash_get_size+0x7ec>
57e15760:	e1500001 	cmp	r0, r1
57e15764:	8a000028 	bhi	57e1580c <flash_get_size+0x40c>
			/* CFI < 1.1, try to guess from device id */
			if ((info->device_id & 0x80) != 0)
57e15768:	e1d33fb8 	ldrh	r3, [r3, #248]	; 0xf8
57e1576c:	e3130080 	tst	r3, #128	; 0x80
57e15770:	0a000037 	beq	57e15854 <flash_get_size+0x454>
57e15774:	ea00002c 	b	57e1582c <flash_get_size+0x42c>
static void flash_fixup_atmel(flash_info_t *info, struct cfi_qry *qry)
{
	int reverse_geometry = 0;

	/* Check the "top boot" bit in the PRI */
	if (info->ext_addr && !(flash_read_uchar(info, info->ext_addr + 6) & 1))
57e15778:	e1d32fbc 	ldrh	r2, [r3, #252]	; 0xfc
57e1577c:	e3520000 	cmp	r2, #0
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e15780:	15d310dc 	ldrbne	r1, [r3, #220]	; 0xdc
static void flash_fixup_atmel(flash_info_t *info, struct cfi_qry *qry)
{
	int reverse_geometry = 0;

	/* Check the "top boot" bit in the PRI */
	if (info->ext_addr && !(flash_read_uchar(info, info->ext_addr + 6) & 1))
57e15784:	12822006 	addne	r2, r2, #6
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e15788:	10020291 	mulne	r2, r1, r2

	return (void *)(info->start[sect] + byte_offset);
57e1578c:	15931014 	ldrne	r1, [r3, #20]
	}
}

static void flash_fixup_atmel(flash_info_t *info, struct cfi_qry *qry)
{
	int reverse_geometry = 0;
57e15790:	01a03002 	moveq	r3, r2
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e15794:	17d23001 	ldrbne	r3, [r2, r1]

	/* AT49BV6416(T) list the erase regions in the wrong order.
	 * However, the device ID is identical with the non-broken
	 * AT49BV642D they differ in the high byte.
	 */
	if (info->device_id == 0xd6 || info->device_id == 0xd2)
57e15798:	e59f242c 	ldr	r2, [pc, #1068]	; 57e15bcc <flash_get_size+0x7cc>
57e1579c:	e3a01f42 	mov	r1, #264	; 0x108
57e157a0:	e0222491 	mla	r2, r1, r4, r2
57e157a4:	e1d22fb8 	ldrh	r2, [r2, #248]	; 0xf8
static void flash_fixup_atmel(flash_info_t *info, struct cfi_qry *qry)
{
	int reverse_geometry = 0;

	/* Check the "top boot" bit in the PRI */
	if (info->ext_addr && !(flash_read_uchar(info, info->ext_addr + 6) & 1))
57e157a8:	12033001 	andne	r3, r3, #1
	}
}

static void flash_fixup_atmel(flash_info_t *info, struct cfi_qry *qry)
{
	int reverse_geometry = 0;
57e157ac:	12233001 	eorne	r3, r3, #1

	/* AT49BV6416(T) list the erase regions in the wrong order.
	 * However, the device ID is identical with the non-broken
	 * AT49BV642D they differ in the high byte.
	 */
	if (info->device_id == 0xd6 || info->device_id == 0xd2)
57e157b0:	e35200d6 	cmp	r2, #214	; 0xd6
57e157b4:	135200d2 	cmpne	r2, #210	; 0xd2
		reverse_geometry = !reverse_geometry;
57e157b8:	02233001 	eoreq	r3, r3, #1

	if (reverse_geometry)
57e157bc:	e3530000 	cmp	r3, #0
57e157c0:	0a000023 	beq	57e15854 <flash_get_size+0x454>
57e157c4:	ea000018 	b	57e1582c <flash_get_size+0x42c>
}

static void flash_fixup_stm(flash_info_t *info, struct cfi_qry *qry)
{
	/* check if flash geometry needs reversal */
	if (qry->num_erase_regions > 1) {
57e157c8:	e5dd2044 	ldrb	r2, [sp, #68]	; 0x44
57e157cc:	e3520001 	cmp	r2, #1
57e157d0:	9a00001f 	bls	57e15854 <flash_get_size+0x454>
		/* reverse geometry if top boot part */
		if (info->cfi_version < 0x3131) {
57e157d4:	e28320f8 	add	r2, r3, #248	; 0xf8
57e157d8:	e1d200b6 	ldrh	r0, [r2, #6]
57e157dc:	e59f1408 	ldr	r1, [pc, #1032]	; 57e15bec <flash_get_size+0x7ec>
57e157e0:	e1500001 	cmp	r0, r1
57e157e4:	8a000008 	bhi	57e1580c <flash_get_size+0x40c>
			/* CFI < 1.1, guess by device id */
			if (info->device_id == 0x22CA || /* M29W320DT */
57e157e8:	e1d33fb8 	ldrh	r3, [r3, #248]	; 0xf8
57e157ec:	e59f23fc 	ldr	r2, [pc, #1020]	; 57e15bf0 <flash_get_size+0x7f0>
57e157f0:	e59f13fc 	ldr	r1, [pc, #1020]	; 57e15bf4 <flash_get_size+0x7f4>
57e157f4:	e1530002 	cmp	r3, r2
57e157f8:	11530001 	cmpne	r3, r1
57e157fc:	0a00000a 	beq	57e1582c <flash_get_size+0x42c>
			    info->device_id == 0x2256 || /* M29W320ET */
57e15800:	e282200d 	add	r2, r2, #13
57e15804:	e1530002 	cmp	r3, r2
57e15808:	ea000006 	b	57e15828 <flash_get_size+0x428>
			    info->device_id == 0x22D7) { /* M29W800DT */
				cfi_reverse_geometry(qry);
			}
		} else if (flash_read_uchar(info, info->ext_addr + 0xf) == 3) {
57e1580c:	e1d220b4 	ldrh	r2, [r2, #4]
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e15810:	e5d310dc 	ldrb	r1, [r3, #220]	; 0xdc
			if (info->device_id == 0x22CA || /* M29W320DT */
			    info->device_id == 0x2256 || /* M29W320ET */
			    info->device_id == 0x22D7) { /* M29W800DT */
				cfi_reverse_geometry(qry);
			}
		} else if (flash_read_uchar(info, info->ext_addr + 0xf) == 3) {
57e15814:	e282200f 	add	r2, r2, #15
 * create an address based on the offset and the port width
 */
static inline void *
flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
{
	unsigned int byte_offset = offset * info->portwidth;
57e15818:	e0020291 	mul	r2, r1, r2

	return (void *)(info->start[sect] + byte_offset);
57e1581c:	e5933014 	ldr	r3, [r3, #20]
	*(volatile u64 *)addr = value;
}

static u8 __flash_read8(void *addr)
{
	return __raw_readb(addr);
57e15820:	e7d23003 	ldrb	r3, [r2, r3]
			if (info->device_id == 0x22CA || /* M29W320DT */
			    info->device_id == 0x2256 || /* M29W320ET */
			    info->device_id == 0x22D7) { /* M29W800DT */
				cfi_reverse_geometry(qry);
			}
		} else if (flash_read_uchar(info, info->ext_addr + 0xf) == 3) {
57e15824:	e3530003 	cmp	r3, #3
57e15828:	1a000009 	bne	57e15854 <flash_get_size+0x454>
			/* CFI >= 1.1, deduct from top/bottom flag */
			/* note: ext_addr is valid since cfi_version > 0 */
			cfi_reverse_geometry(qry);
57e1582c:	e28d0028 	add	r0, sp, #40	; 0x28
57e15830:	ebfffb11 	bl	57e1447c <cfi_reverse_geometry>
57e15834:	ea000006 	b	57e15854 <flash_get_size+0x454>
	 * 64KB sector (SST call it block)  needs 0x30 to be erased.
	 * 4KB  sector (SST call it sector) needs 0x50 to be erased.
	 * Since CFI query detect the 4KB number of sectors, users expects
	 * a sector granularity of 4KB, and it is here set.
	 */
	if (info->device_id == 0x5D23 || /* SST39VF3201B */
57e15838:	e1d32fb8 	ldrh	r2, [r3, #248]	; 0xf8
57e1583c:	e59f13b4 	ldr	r1, [pc, #948]	; 57e15bf8 <flash_get_size+0x7f8>
57e15840:	e59f03b4 	ldr	r0, [pc, #948]	; 57e15bfc <flash_get_size+0x7fc>
57e15844:	e1520001 	cmp	r2, r1
57e15848:	11520000 	cmpne	r2, r0
	    info->device_id == 0x5C23) { /* SST39VF3202B */
		/* set sector granularity to 4KB */
		info->cmd_erase_sector=0x50;
57e1584c:	03a02050 	moveq	r2, #80	; 0x50
57e15850:	05c320f0 	strbeq	r2, [r3, #240]	; 0xf0
		debug ("manufacturer id is 0x%x\n", info->manufacturer_id);
		debug ("device id is 0x%x\n", info->device_id);
		debug ("device id2 is 0x%x\n", info->device_id2);
		debug ("cfi version is 0x%04x\n", info->cfi_version);

		size_ratio = info->portwidth / info->chipwidth;
57e15854:	e59f3370 	ldr	r3, [pc, #880]	; 57e15bcc <flash_get_size+0x7cc>
57e15858:	e3a07f42 	mov	r7, #264	; 0x108
57e1585c:	e0273794 	mla	r7, r4, r7, r3
57e15860:	e28730d8 	add	r3, r7, #216	; 0xd8
57e15864:	e5d36005 	ldrb	r6, [r3, #5]
57e15868:	e5d30004 	ldrb	r0, [r3, #4]
57e1586c:	e1a01006 	mov	r1, r6
57e15870:	eb0057ce 	bl	57e2b7b0 <__udivsi3>
		/* if the chip is x8/x16 reduce the ratio by half */
		if ((info->interface == FLASH_CFI_X8X16)
57e15874:	e1d73fb2 	ldrh	r3, [r7, #242]	; 0xf2
		debug ("manufacturer id is 0x%x\n", info->manufacturer_id);
		debug ("device id is 0x%x\n", info->device_id);
		debug ("device id2 is 0x%x\n", info->device_id2);
		debug ("cfi version is 0x%04x\n", info->cfi_version);

		size_ratio = info->portwidth / info->chipwidth;
57e15878:	e20000ff 	and	r0, r0, #255	; 0xff
		/* if the chip is x8/x16 reduce the ratio by half */
		if ((info->interface == FLASH_CFI_X8X16)
57e1587c:	e3530002 	cmp	r3, #2
		debug ("manufacturer id is 0x%x\n", info->manufacturer_id);
		debug ("device id is 0x%x\n", info->device_id);
		debug ("device id2 is 0x%x\n", info->device_id2);
		debug ("cfi version is 0x%04x\n", info->cfi_version);

		size_ratio = info->portwidth / info->chipwidth;
57e15880:	e58d0000 	str	r0, [sp]
		/* if the chip is x8/x16 reduce the ratio by half */
		if ((info->interface == FLASH_CFI_X8X16)
57e15884:	1a000002 	bne	57e15894 <flash_get_size+0x494>
		    && (info->chipwidth == FLASH_CFI_BY8)) {
57e15888:	e3560001 	cmp	r6, #1
			size_ratio >>= 1;
57e1588c:	01a000c0 	asreq	r0, r0, #1
57e15890:	058d0000 	streq	r0, [sp]
		debug ("size_ratio %d port %d bits chip %d bits\n",
		       size_ratio, info->portwidth << CFI_FLASH_SHIFT_WIDTH,
		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
		info->size = 1 << qry.dev_size;
		/* multiply the size by the number of chips */
		info->size *= size_ratio;
57e15894:	e59f3330 	ldr	r3, [pc, #816]	; 57e15bcc <flash_get_size+0x7cc>
57e15898:	e3a06f42 	mov	r6, #264	; 0x108
57e1589c:	e0263694 	mla	r6, r4, r6, r3
			size_ratio >>= 1;
		}
		debug ("size_ratio %d port %d bits chip %d bits\n",
		       size_ratio, info->portwidth << CFI_FLASH_SHIFT_WIDTH,
		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
		info->size = 1 << qry.dev_size;
57e158a0:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
57e158a4:	e3a02001 	mov	r2, #1
57e158a8:	e1a03312 	lsl	r3, r2, r3
		/* multiply the size by the number of chips */
		info->size *= size_ratio;
57e158ac:	e59d0000 	ldr	r0, [sp]
57e158b0:	e0030390 	mul	r3, r0, r3
		max_size = cfi_flash_bank_size(banknum);
57e158b4:	e1a00004 	mov	r0, r4
		debug ("size_ratio %d port %d bits chip %d bits\n",
		       size_ratio, info->portwidth << CFI_FLASH_SHIFT_WIDTH,
		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
		info->size = 1 << qry.dev_size;
		/* multiply the size by the number of chips */
		info->size *= size_ratio;
57e158b8:	e5863008 	str	r3, [r6, #8]
		max_size = cfi_flash_bank_size(banknum);
57e158bc:	ebfffb40 	bl	57e145c4 <cfi_flash_bank_size>
		if (max_size && (info->size > max_size)) {
57e158c0:	e3500000 	cmp	r0, #0
57e158c4:	0a000002 	beq	57e158d4 <flash_get_size+0x4d4>
57e158c8:	e5963008 	ldr	r3, [r6, #8]
57e158cc:	e1530000 	cmp	r3, r0
			debug("[truncated from %ldMiB]", info->size >> 20);
			info->size = max_size;
57e158d0:	85860008 	strhi	r0, [r6, #8]

/*
 * The following code cannot be run from FLASH!
 *
 */
ulong flash_get_size (phys_addr_t base, int banknum)
57e158d4:	e3a03f42 	mov	r3, #264	; 0x108
57e158d8:	e0020493 	mul	r2, r3, r4
57e158dc:	e3a03042 	mov	r3, #66	; 0x42
57e158e0:	e0000493 	mul	r0, r3, r4
			tmp >>= 16;
			erase_region_size =
				(tmp & 0xffff) ? ((tmp & 0xffff) * 256) : 128;
			debug ("erase_region_count = %d erase_region_size = %d\n",
				erase_region_count, erase_region_size);
			for (j = 0; j < erase_region_count; j++) {
57e158e4:	e59d1008 	ldr	r1, [sp, #8]
				if (sector - base >= info->size)
57e158e8:	e59fa2dc 	ldr	sl, [pc, #732]	; 57e15bcc <flash_get_size+0x7cc>
			tmp >>= 16;
			erase_region_size =
				(tmp & 0xffff) ? ((tmp & 0xffff) * 256) : 128;
			debug ("erase_region_count = %d erase_region_size = %d\n",
				erase_region_count, erase_region_size);
			for (j = 0; j < erase_region_count; j++) {
57e158ec:	e3a06000 	mov	r6, #0
57e158f0:	e58d1004 	str	r1, [sp, #4]
57e158f4:	e1a09006 	mov	r9, r6

/*
 * The following code cannot be run from FLASH!
 *
 */
ulong flash_get_size (phys_addr_t base, int banknum)
57e158f8:	e58d2018 	str	r2, [sp, #24]
57e158fc:	e58d0024 	str	r0, [sp, #36]	; 0x24
			erase_region_size =
				(tmp & 0xffff) ? ((tmp & 0xffff) * 256) : 128;
			debug ("erase_region_count = %d erase_region_size = %d\n",
				erase_region_count, erase_region_size);
			for (j = 0; j < erase_region_count; j++) {
				if (sector - base >= info->size)
57e15900:	e08aa002 	add	sl, sl, r2
57e15904:	e58d401c 	str	r4, [sp, #28]
57e15908:	ea000069 	b	57e15ab4 <flash_get_size+0x6b4>
		}
		debug ("found %d erase regions\n", num_erase_regions);
		sect_cnt = 0;
		sector = base;
		for (i = 0; i < num_erase_regions; i++) {
			if (i > NUM_ERASE_REGIONS) {
57e1590c:	e3590005 	cmp	r9, #5
57e15910:	1a000005 	bne	57e1592c <flash_get_size+0x52c>
				printf ("%d erase regions found, only %d used\n",
57e15914:	e59d100c 	ldr	r1, [sp, #12]
57e15918:	e3a02004 	mov	r2, #4
57e1591c:	e59f02dc 	ldr	r0, [pc, #732]	; 57e15c00 <flash_get_size+0x800>
57e15920:	e59d401c 	ldr	r4, [sp, #28]
57e15924:	ebffcec8 	bl	57e0944c <printf>
					num_erase_regions, NUM_ERASE_REGIONS);
				break;
57e15928:	ea000065 	b	57e15ac4 <flash_get_size+0x6c4>
			}

			tmp = le32_to_cpu(qry.erase_region_info[i]);
57e1592c:	e28d1058 	add	r1, sp, #88	; 0x58
57e15930:	e2892006 	add	r2, r9, #6
57e15934:	e0812102 	add	r2, r1, r2, lsl #2
57e15938:	e5523028 	ldrb	r3, [r2, #-40]	; 0x28
57e1593c:	e512102c 	ldr	r1, [r2, #-44]	; 0x2c
57e15940:	e1a03c03 	lsl	r3, r3, #24
57e15944:	e1833421 	orr	r3, r3, r1, lsr #8
			debug("erase region %u: 0x%08lx\n", i, tmp);

			erase_region_count = (tmp & 0xffff) + 1;
57e15948:	e1a02803 	lsl	r2, r3, #16
				}
				info->start[sect_cnt] =
					(ulong)map_physmem(sector,
							   info->portwidth,
							   MAP_NOCACHE);
				sector += (erase_region_size * size_ratio);
57e1594c:	e59d0000 	ldr	r0, [sp]
			tmp = le32_to_cpu(qry.erase_region_info[i]);
			debug("erase region %u: 0x%08lx\n", i, tmp);

			erase_region_count = (tmp & 0xffff) + 1;
			tmp >>= 16;
			erase_region_size =
57e15950:	e1b03823 	lsrs	r3, r3, #16
			}

			tmp = le32_to_cpu(qry.erase_region_info[i]);
			debug("erase region %u: 0x%08lx\n", i, tmp);

			erase_region_count = (tmp & 0xffff) + 1;
57e15954:	e1a02822 	lsr	r2, r2, #16
57e15958:	e2822001 	add	r2, r2, #1
			tmp >>= 16;
			erase_region_size =
				(tmp & 0xffff) ? ((tmp & 0xffff) * 256) : 128;
57e1595c:	11a03403 	lslne	r3, r3, #8
			tmp = le32_to_cpu(qry.erase_region_info[i]);
			debug("erase region %u: 0x%08lx\n", i, tmp);

			erase_region_count = (tmp & 0xffff) + 1;
			tmp >>= 16;
			erase_region_size =
57e15960:	03a03080 	moveq	r3, #128	; 0x80
			}

			tmp = le32_to_cpu(qry.erase_region_info[i]);
			debug("erase region %u: 0x%08lx\n", i, tmp);

			erase_region_count = (tmp & 0xffff) + 1;
57e15964:	e58d2020 	str	r2, [sp, #32]
				}
				info->start[sect_cnt] =
					(ulong)map_physmem(sector,
							   info->portwidth,
							   MAP_NOCACHE);
				sector += (erase_region_size * size_ratio);
57e15968:	e0020390 	mul	r2, r0, r3
57e1596c:	e59d1004 	ldr	r1, [sp, #4]
57e15970:	e58d2010 	str	r2, [sp, #16]
57e15974:	e59d2008 	ldr	r2, [sp, #8]

/*
 * The following code cannot be run from FLASH!
 *
 */
ulong flash_get_size (phys_addr_t base, int banknum)
57e15978:	e59d3018 	ldr	r3, [sp, #24]
				}
				info->start[sect_cnt] =
					(ulong)map_physmem(sector,
							   info->portwidth,
							   MAP_NOCACHE);
				sector += (erase_region_size * size_ratio);
57e1597c:	e062b001 	rsb	fp, r2, r1

/*
 * The following code cannot be run from FLASH!
 *
 */
ulong flash_get_size (phys_addr_t base, int banknum)
57e15980:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
57e15984:	e59f0278 	ldr	r0, [pc, #632]	; 57e15c04 <flash_get_size+0x804>
57e15988:	e0864003 	add	r4, r6, r3
57e1598c:	e0863001 	add	r3, r6, r1
57e15990:	e0803103 	add	r3, r0, r3, lsl #2
57e15994:	e0804004 	add	r4, r0, r4
57e15998:	e2833008 	add	r3, r3, #8
57e1599c:	e28440ac 	add	r4, r4, #172	; 0xac
57e159a0:	e58d3014 	str	r3, [sp, #20]
			tmp >>= 16;
			erase_region_size =
				(tmp & 0xffff) ? ((tmp & 0xffff) * 256) : 128;
			debug ("erase_region_count = %d erase_region_size = %d\n",
				erase_region_count, erase_region_size);
			for (j = 0; j < erase_region_count; j++) {
57e159a4:	e3a07000 	mov	r7, #0
				if (sector - base >= info->size)
57e159a8:	e59a3008 	ldr	r3, [sl, #8]
57e159ac:	e15b0003 	cmp	fp, r3
57e159b0:	2a00003e 	bcs	57e15ab0 <flash_get_size+0x6b0>
					break;
				if (sect_cnt >= CONFIG_SYS_MAX_FLASH_SECT) {
57e159b4:	e3560027 	cmp	r6, #39	; 0x27
57e159b8:	9a000002 	bls	57e159c8 <flash_get_size+0x5c8>
					printf("ERROR: too many flash sectors\n");
57e159bc:	e59f0244 	ldr	r0, [pc, #580]	; 57e15c08 <flash_get_size+0x808>
57e159c0:	ebffcea1 	bl	57e0944c <printf>
					break;
57e159c4:	ea000039 	b	57e15ab0 <flash_get_size+0x6b0>
				}
				info->start[sect_cnt] =
57e159c8:	e59d3014 	ldr	r3, [sp, #20]
57e159cc:	e59d2004 	ldr	r2, [sp, #4]
					(ulong)map_physmem(sector,
							   info->portwidth,
							   MAP_NOCACHE);
				sector += (erase_region_size * size_ratio);
57e159d0:	e59d0010 	ldr	r0, [sp, #16]
					break;
				if (sect_cnt >= CONFIG_SYS_MAX_FLASH_SECT) {
					printf("ERROR: too many flash sectors\n");
					break;
				}
				info->start[sect_cnt] =
57e159d4:	e5a32004 	str	r2, [r3, #4]!
57e159d8:	e58d3014 	str	r3, [sp, #20]

				/*
				 * Only read protection status from
				 * supported devices (intel...)
				 */
				switch (info->vendor) {
57e159dc:	e1da3ebc 	ldrh	r3, [sl, #236]	; 0xec
				}
				info->start[sect_cnt] =
					(ulong)map_physmem(sector,
							   info->portwidth,
							   MAP_NOCACHE);
				sector += (erase_region_size * size_ratio);
57e159e0:	e0822000 	add	r2, r2, r0

				/*
				 * Only read protection status from
				 * supported devices (intel...)
				 */
				switch (info->vendor) {
57e159e4:	e3530003 	cmp	r3, #3
				}
				info->start[sect_cnt] =
					(ulong)map_physmem(sector,
							   info->portwidth,
							   MAP_NOCACHE);
				sector += (erase_region_size * size_ratio);
57e159e8:	e58d2004 	str	r2, [sp, #4]

				/*
				 * Only read protection status from
				 * supported devices (intel...)
				 */
				switch (info->vendor) {
57e159ec:	0a000009 	beq	57e15a18 <flash_get_size+0x618>
57e159f0:	8a000004 	bhi	57e15a08 <flash_get_size+0x608>
57e159f4:	e3530001 	cmp	r3, #1
57e159f8:	0a000006 	beq	57e15a18 <flash_get_size+0x618>
57e159fc:	e3530002 	cmp	r3, #2
57e15a00:	1a000020 	bne	57e15a88 <flash_get_size+0x688>
57e15a04:	ea000007 	b	57e15a28 <flash_get_size+0x628>
57e15a08:	e3530004 	cmp	r3, #4
57e15a0c:	0a000005 	beq	57e15a28 <flash_get_size+0x628>
57e15a10:	e3530c02 	cmp	r3, #512	; 0x200
57e15a14:	1a00001b 	bne	57e15a88 <flash_get_size+0x688>
					/*
					 * Set flash to read-id mode. Otherwise
					 * reading protected status is not
					 * guaranteed.
					 */
					flash_write_cmd(info, sect_cnt, 0,
57e15a18:	e1a00005 	mov	r0, r5
57e15a1c:	e1a01006 	mov	r1, r6
57e15a20:	e3a02000 	mov	r2, #0
57e15a24:	ea00000e 	b	57e15a64 <flash_get_size+0x664>
							     FLASH_OFFSET_PROTECT,
							     FLASH_STATUS_PROTECT);
					break;
				case CFI_CMDSET_AMD_EXTENDED:
				case CFI_CMDSET_AMD_STANDARD:
					if (!info->legacy_unlock) {
57e15a28:	e1da3fb4 	ldrh	r3, [sl, #244]	; 0xf4
57e15a2c:	e3530000 	cmp	r3, #0
						/* default: not protected */
						info->protect[sect_cnt] = 0;
57e15a30:	05c43000 	strbeq	r3, [r4]
							     FLASH_OFFSET_PROTECT,
							     FLASH_STATUS_PROTECT);
					break;
				case CFI_CMDSET_AMD_EXTENDED:
				case CFI_CMDSET_AMD_STANDARD:
					if (!info->legacy_unlock) {
57e15a34:	0a000015 	beq	57e15a90 <flash_get_size+0x690>
						info->protect[sect_cnt] = 0;
						break;
					}

					/* Read protection (PPB) from sector */
					flash_write_cmd(info, 0, 0,
57e15a38:	e3a01000 	mov	r1, #0
57e15a3c:	e1a02001 	mov	r2, r1
57e15a40:	e1a00005 	mov	r0, r5
57e15a44:	e1da3ebe 	ldrh	r3, [sl, #238]	; 0xee
57e15a48:	ebfffaef 	bl	57e1460c <flash_write_cmd>
							info->cmd_reset);
					flash_unlock_seq(info, 0);
57e15a4c:	e1a00005 	mov	r0, r5
57e15a50:	e3a01000 	mov	r1, #0
57e15a54:	ebfffb2e 	bl	57e14714 <flash_unlock_seq>
					flash_write_cmd(info, 0,
57e15a58:	e59a2104 	ldr	r2, [sl, #260]	; 0x104
57e15a5c:	e1a00005 	mov	r0, r5
57e15a60:	e3a01000 	mov	r1, #0
57e15a64:	e3a03090 	mov	r3, #144	; 0x90
57e15a68:	ebfffae7 	bl	57e1460c <flash_write_cmd>
							info->addr_unlock1,
							FLASH_CMD_READ_ID);
					info->protect[sect_cnt] =
						flash_isset(
57e15a6c:	e1a00005 	mov	r0, r5
57e15a70:	e1a01006 	mov	r1, r6
57e15a74:	e3a02002 	mov	r2, #2
57e15a78:	e3a03001 	mov	r3, #1
57e15a7c:	ebfffa2f 	bl	57e14340 <flash_isset>
							info->cmd_reset);
					flash_unlock_seq(info, 0);
					flash_write_cmd(info, 0,
							info->addr_unlock1,
							FLASH_CMD_READ_ID);
					info->protect[sect_cnt] =
57e15a80:	e5c40000 	strb	r0, [r4]
						flash_isset(
							info, sect_cnt,
							FLASH_OFFSET_PROTECT,
							FLASH_STATUS_PROTECT);
					break;
57e15a84:	ea000001 	b	57e15a90 <flash_get_size+0x690>
				default:
					/* default: not protected */
					info->protect[sect_cnt] = 0;
57e15a88:	e3a01000 	mov	r1, #0
57e15a8c:	e5c41000 	strb	r1, [r4]
			tmp >>= 16;
			erase_region_size =
				(tmp & 0xffff) ? ((tmp & 0xffff) * 256) : 128;
			debug ("erase_region_count = %d erase_region_size = %d\n",
				erase_region_count, erase_region_size);
			for (j = 0; j < erase_region_count; j++) {
57e15a90:	e59d3020 	ldr	r3, [sp, #32]
57e15a94:	e2877001 	add	r7, r7, #1
57e15a98:	e59d2010 	ldr	r2, [sp, #16]
57e15a9c:	e1570003 	cmp	r7, r3
				default:
					/* default: not protected */
					info->protect[sect_cnt] = 0;
				}

				sect_cnt++;
57e15aa0:	e2866001 	add	r6, r6, #1
			tmp >>= 16;
			erase_region_size =
				(tmp & 0xffff) ? ((tmp & 0xffff) * 256) : 128;
			debug ("erase_region_count = %d erase_region_size = %d\n",
				erase_region_count, erase_region_size);
			for (j = 0; j < erase_region_count; j++) {
57e15aa4:	e08bb002 	add	fp, fp, r2
57e15aa8:	e2844001 	add	r4, r4, #1
57e15aac:	baffffbd 	blt	57e159a8 <flash_get_size+0x5a8>
			info->size = max_size;
		}
		debug ("found %d erase regions\n", num_erase_regions);
		sect_cnt = 0;
		sector = base;
		for (i = 0; i < num_erase_regions; i++) {
57e15ab0:	e2899001 	add	r9, r9, #1
57e15ab4:	e59d000c 	ldr	r0, [sp, #12]
57e15ab8:	e1590000 	cmp	r9, r0
57e15abc:	baffff92 	blt	57e1590c <flash_get_size+0x50c>
57e15ac0:	e59d401c 	ldr	r4, [sp, #28]

				sect_cnt++;
			}
		}

		info->sector_count = sect_cnt;
57e15ac4:	e59f3100 	ldr	r3, [pc, #256]	; 57e15bcc <flash_get_size+0x7cc>
57e15ac8:	e3a07f42 	mov	r7, #264	; 0x108
57e15acc:	e0273794 	mla	r7, r4, r7, r3
57e15ad0:	e1c760bc 	strh	r6, [r7, #12]
		info->buffer_size = 1 << le16_to_cpu(qry.max_buf_write_size);
57e15ad4:	e1dd34b2 	ldrh	r3, [sp, #66]	; 0x42
57e15ad8:	e3a0a001 	mov	sl, #1
57e15adc:	e1a0331a 	lsl	r3, sl, r3
57e15ae0:	e28760d8 	add	r6, r7, #216	; 0xd8
57e15ae4:	e1c630b6 	strh	r3, [r6, #6]
		tmp = 1 << qry.block_erase_timeout_typ;
57e15ae8:	e5dd3039 	ldrb	r3, [sp, #57]	; 0x39
		info->erase_blk_tout = tmp *
57e15aec:	e5dd203d 	ldrb	r2, [sp, #61]	; 0x3d
			}
		}

		info->sector_count = sect_cnt;
		info->buffer_size = 1 << le16_to_cpu(qry.max_buf_write_size);
		tmp = 1 << qry.block_erase_timeout_typ;
57e15af0:	e1a0331a 	lsl	r3, sl, r3
		info->erase_blk_tout = tmp *
			(1 << qry.block_erase_timeout_max);
		tmp = (1 << qry.buf_write_timeout_typ) *
57e15af4:	e5dd0038 	ldrb	r0, [sp, #56]	; 0x38
		}

		info->sector_count = sect_cnt;
		info->buffer_size = 1 << le16_to_cpu(qry.max_buf_write_size);
		tmp = 1 << qry.block_erase_timeout_typ;
		info->erase_blk_tout = tmp *
57e15af8:	e1a03213 	lsl	r3, r3, r2
			(1 << qry.block_erase_timeout_max);
		tmp = (1 << qry.buf_write_timeout_typ) *
57e15afc:	e1a0001a 	lsl	r0, sl, r0
		}

		info->sector_count = sect_cnt;
		info->buffer_size = 1 << le16_to_cpu(qry.max_buf_write_size);
		tmp = 1 << qry.block_erase_timeout_typ;
		info->erase_blk_tout = tmp *
57e15b00:	e58730e0 	str	r3, [r7, #224]	; 0xe0
			(1 << qry.block_erase_timeout_max);
		tmp = (1 << qry.buf_write_timeout_typ) *
57e15b04:	e5dd303c 	ldrb	r3, [sp, #60]	; 0x3c
			(1 << qry.buf_write_timeout_max);

		/* round up when converting to ms */
		info->buffer_write_tout = (tmp + 999) / 1000;
57e15b08:	e3a01ffa 	mov	r1, #1000	; 0x3e8
		info->sector_count = sect_cnt;
		info->buffer_size = 1 << le16_to_cpu(qry.max_buf_write_size);
		tmp = 1 << qry.block_erase_timeout_typ;
		info->erase_blk_tout = tmp *
			(1 << qry.block_erase_timeout_max);
		tmp = (1 << qry.buf_write_timeout_typ) *
57e15b0c:	e1a00310 	lsl	r0, r0, r3
			(1 << qry.buf_write_timeout_max);

		/* round up when converting to ms */
		info->buffer_write_tout = (tmp + 999) / 1000;
57e15b10:	e2800ff9 	add	r0, r0, #996	; 0x3e4
57e15b14:	e2800003 	add	r0, r0, #3
57e15b18:	eb005724 	bl	57e2b7b0 <__udivsi3>
57e15b1c:	e58700e8 	str	r0, [r7, #232]	; 0xe8
		tmp = (1 << qry.word_write_timeout_typ) *
57e15b20:	e5dd0037 	ldrb	r0, [sp, #55]	; 0x37
57e15b24:	e5dd303b 	ldrb	r3, [sp, #59]	; 0x3b
57e15b28:	e1a0001a 	lsl	r0, sl, r0
57e15b2c:	e1a00310 	lsl	r0, r0, r3
			(1 << qry.word_write_timeout_max);
		/* round up when converting to ms */
		info->write_tout = (tmp + 999) / 1000;
57e15b30:	e2800ff9 	add	r0, r0, #996	; 0x3e4
57e15b34:	e2800003 	add	r0, r0, #3
57e15b38:	e3a01ffa 	mov	r1, #1000	; 0x3e8
57e15b3c:	eb00571b 	bl	57e2b7b0 <__udivsi3>
		info->flash_id = FLASH_MAN_CFI;
57e15b40:	e3a03401 	mov	r3, #16777216	; 0x1000000
57e15b44:	e5873010 	str	r3, [r7, #16]
		if ((info->interface == FLASH_CFI_X8X16) &&
57e15b48:	e1d73fb2 	ldrh	r3, [r7, #242]	; 0xf2
		/* round up when converting to ms */
		info->buffer_write_tout = (tmp + 999) / 1000;
		tmp = (1 << qry.word_write_timeout_typ) *
			(1 << qry.word_write_timeout_max);
		/* round up when converting to ms */
		info->write_tout = (tmp + 999) / 1000;
57e15b4c:	e58700e4 	str	r0, [r7, #228]	; 0xe4
		info->flash_id = FLASH_MAN_CFI;
		if ((info->interface == FLASH_CFI_X8X16) &&
57e15b50:	e3530002 	cmp	r3, #2
57e15b54:	1a000004 	bne	57e15b6c <flash_get_size+0x76c>
57e15b58:	e5d63005 	ldrb	r3, [r6, #5]
57e15b5c:	e153000a 	cmp	r3, sl
		    (info->chipwidth == FLASH_CFI_BY8)) {
			/* XXX - Need to test on x8/x16 in parallel. */
			info->portwidth >>= 1;
57e15b60:	05d63004 	ldrbeq	r3, [r6, #4]
57e15b64:	01a03a33 	lsreq	r3, r3, sl
57e15b68:	05c63004 	strbeq	r3, [r6, #4]
		}

		flash_write_cmd (info, 0, 0, info->cmd_reset);
57e15b6c:	e59f3058 	ldr	r3, [pc, #88]	; 57e15bcc <flash_get_size+0x7cc>
57e15b70:	e3a02f42 	mov	r2, #264	; 0x108
57e15b74:	e0233492 	mla	r3, r2, r4, r3
57e15b78:	e3a01000 	mov	r1, #0
57e15b7c:	e1a00005 	mov	r0, r5
57e15b80:	e1a02001 	mov	r2, r1
57e15b84:	e1d33ebe 	ldrh	r3, [r3, #238]	; 0xee
57e15b88:	ebfffa9f 	bl	57e1460c <flash_write_cmd>
	}

	return (info->size);
57e15b8c:	e59f3038 	ldr	r3, [pc, #56]	; 57e15bcc <flash_get_size+0x7cc>
57e15b90:	e3a02f42 	mov	r2, #264	; 0x108
57e15b94:	e0243492 	mla	r4, r2, r4, r3
57e15b98:	e5940008 	ldr	r0, [r4, #8]
}
57e15b9c:	e28dd058 	add	sp, sp, #88	; 0x58
57e15ba0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

	for (info->portwidth = CONFIG_SYS_FLASH_CFI_WIDTH;
	     info->portwidth <= FLASH_CFI_64BIT; info->portwidth <<= 1) {
		for (info->chipwidth = FLASH_CFI_BY8;
		     info->chipwidth <= info->portwidth;
		     info->chipwidth <<= 1)
57e15ba4:	e28730d8 	add	r3, r7, #216	; 0xd8
57e15ba8:	e5d32005 	ldrb	r2, [r3, #5]
57e15bac:	e1a02082 	lsl	r2, r2, #1
57e15bb0:	e5c32005 	strb	r2, [r3, #5]
	debug ("flash detect cfi\n");

	for (info->portwidth = CONFIG_SYS_FLASH_CFI_WIDTH;
	     info->portwidth <= FLASH_CFI_64BIT; info->portwidth <<= 1) {
		for (info->chipwidth = FLASH_CFI_BY8;
		     info->chipwidth <= info->portwidth;
57e15bb4:	e28730d8 	add	r3, r7, #216	; 0xd8
57e15bb8:	e5d32004 	ldrb	r2, [r3, #4]
{
	debug ("flash detect cfi\n");

	for (info->portwidth = CONFIG_SYS_FLASH_CFI_WIDTH;
	     info->portwidth <= FLASH_CFI_64BIT; info->portwidth <<= 1) {
		for (info->chipwidth = FLASH_CFI_BY8;
57e15bbc:	e5d31005 	ldrb	r1, [r3, #5]
57e15bc0:	e1510002 	cmp	r1, r2
57e15bc4:	9afffe28 	bls	57e1546c <flash_get_size+0x6c>
57e15bc8:	eafffe84 	b	57e155e0 <flash_get_size+0x1e0>
57e15bcc:	57e4767c 	.word	0x57e4767c
57e15bd0:	57e2c338 	.word	0x57e2c338
57e15bd4:	57e2c330 	.word	0x57e2c330
57e15bd8:	00000555 	.word	0x00000555
57e15bdc:	000002aa 	.word	0x000002aa
57e15be0:	00000aaa 	.word	0x00000aaa
57e15be4:	57e33790 	.word	0x57e33790
57e15be8:	57e3379f 	.word	0x57e3379f
57e15bec:	00003130 	.word	0x00003130
57e15bf0:	000022ca 	.word	0x000022ca
57e15bf4:	00002256 	.word	0x00002256
57e15bf8:	00005d23 	.word	0x00005d23
57e15bfc:	00005c23 	.word	0x00005c23
57e15c00:	57e337be 	.word	0x57e337be
57e15c04:	57e47684 	.word	0x57e47684
57e15c08:	57e337e4 	.word	0x57e337e4

57e15c0c <flash_protect_default>:
			       apl[i].start,
			       apl[i].start + apl[i].size - 1,
			       flash_get_info(apl[i].start));
	}
#endif
}
57e15c0c:	e12fff1e 	bx	lr

57e15c10 <flash_init>:

unsigned long flash_init (void)
{
57e15c10:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	getenv_f("unlock", s, sizeof(s));
#endif

	/* Init: no FLASHes known */
	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; ++i) {
		flash_info[i].flash_id = FLASH_UNKNOWN;
57e15c14:	e59f31b4 	ldr	r3, [pc, #436]	; 57e15dd0 <flash_init+0x1c0>
57e15c18:	e59f41b4 	ldr	r4, [pc, #436]	; 57e15dd4 <flash_init+0x1c4>

		/* Optionally write flash configuration register */
		cfi_flash_set_config_reg(cfi_flash_bank_addr(i),
57e15c1c:	e3a00000 	mov	r0, #0
	getenv_f("unlock", s, sizeof(s));
#endif

	/* Init: no FLASHes known */
	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; ++i) {
		flash_info[i].flash_id = FLASH_UNKNOWN;
57e15c20:	e5843010 	str	r3, [r4, #16]

		/* Optionally write flash configuration register */
		cfi_flash_set_config_reg(cfi_flash_bank_addr(i),
57e15c24:	ebfffa64 	bl	57e145bc <cfi_flash_bank_addr>
					 cfi_flash_config_reg(i));

		if (!flash_detect_legacy(cfi_flash_bank_addr(i), i))
57e15c28:	e3a00000 	mov	r0, #0
57e15c2c:	ebfffa62 	bl	57e145bc <cfi_flash_bank_addr>
 */
static int flash_detect_legacy(phys_addr_t base, int banknum)
{
	flash_info_t *info = &flash_info[banknum];

	if (board_flash_get_legacy(base, banknum, info)) {
57e15c30:	e3a01000 	mov	r1, #0
57e15c34:	e2842008 	add	r2, r4, #8

		/* Optionally write flash configuration register */
		cfi_flash_set_config_reg(cfi_flash_bank_addr(i),
					 cfi_flash_config_reg(i));

		if (!flash_detect_legacy(cfi_flash_bank_addr(i), i))
57e15c38:	e1a05000 	mov	r5, r0
 */
static int flash_detect_legacy(phys_addr_t base, int banknum)
{
	flash_info_t *info = &flash_info[banknum];

	if (board_flash_get_legacy(base, banknum, info)) {
57e15c3c:	eb0056c5 	bl	57e2b758 <board_flash_get_legacy>
57e15c40:	e2506000 	subs	r6, r0, #0
57e15c44:	0a000051 	beq	57e15d90 <flash_init+0x180>
		/* board code may have filled info completely. If not, we
		   use JEDEC ID probing. */
		if (!info->vendor) {
57e15c48:	e1d43ebc 	ldrh	r3, [r4, #236]	; 0xec
57e15c4c:	e3530000 	cmp	r3, #0
57e15c50:	1a000033 	bne	57e15d24 <flash_init+0x114>
			int modes[] = {
57e15c54:	e59f217c 	ldr	r2, [pc, #380]	; 57e15dd8 <flash_init+0x1c8>
57e15c58:	e1a0300d 	mov	r3, sp
57e15c5c:	e8920003 	ldm	r2, {r0, r1}
57e15c60:	e24d6004 	sub	r6, sp, #4
57e15c64:	e8830003 	stm	r3, {r0, r1}
			       flash_get_info(apl[i].start));
	}
#endif
}

unsigned long flash_init (void)
57e15c68:	e28d9004 	add	r9, sp, #4
				if (info->portwidth == FLASH_CFI_8BIT
					&& info->interface == FLASH_CFI_X8X16) {
					info->addr_unlock1 = 0x2AAA;
					info->addr_unlock2 = 0x5555;
				} else {
					info->addr_unlock1 = 0x5555;
57e15c6c:	e59fa168 	ldr	sl, [pc, #360]	; 57e15ddc <flash_init+0x1cc>
					info->addr_unlock2 = 0x2AAA;
57e15c70:	e59f7168 	ldr	r7, [pc, #360]	; 57e15de0 <flash_init+0x1d0>
57e15c74:	ea000028 	b	57e15d1c <flash_init+0x10c>
				CFI_CMDSET_INTEL_STANDARD
			};
			int i;

			for (i = 0; i < sizeof(modes) / sizeof(modes[0]); i++) {
				info->vendor = modes[i];
57e15c78:	e5b63004 	ldr	r3, [r6, #4]!
				info->start[0] =
					(ulong)map_physmem(base,
							   info->portwidth,
							   MAP_NOCACHE);
				if (info->portwidth == FLASH_CFI_8BIT
57e15c7c:	e5d420dc 	ldrb	r2, [r4, #220]	; 0xdc
				CFI_CMDSET_INTEL_STANDARD
			};
			int i;

			for (i = 0; i < sizeof(modes) / sizeof(modes[0]); i++) {
				info->vendor = modes[i];
57e15c80:	e1a03803 	lsl	r3, r3, #16
57e15c84:	e1a03823 	lsr	r3, r3, #16
				info->start[0] =
					(ulong)map_physmem(base,
							   info->portwidth,
							   MAP_NOCACHE);
				if (info->portwidth == FLASH_CFI_8BIT
57e15c88:	e3520001 	cmp	r2, #1
				CFI_CMDSET_INTEL_STANDARD
			};
			int i;

			for (i = 0; i < sizeof(modes) / sizeof(modes[0]); i++) {
				info->vendor = modes[i];
57e15c8c:	e1c43ebc 	strh	r3, [r4, #236]	; 0xec
				info->start[0] =
57e15c90:	e5845014 	str	r5, [r4, #20]
					(ulong)map_physmem(base,
							   info->portwidth,
							   MAP_NOCACHE);
				if (info->portwidth == FLASH_CFI_8BIT
57e15c94:	1a000004 	bne	57e15cac <flash_init+0x9c>
					&& info->interface == FLASH_CFI_X8X16) {
57e15c98:	e1d42fb2 	ldrh	r2, [r4, #242]	; 0xf2
57e15c9c:	e3520002 	cmp	r2, #2
					info->addr_unlock1 = 0x2AAA;
57e15ca0:	05847104 	streq	r7, [r4, #260]	; 0x104
					info->addr_unlock2 = 0x5555;
57e15ca4:	0584a108 	streq	sl, [r4, #264]	; 0x108
				info->start[0] =
					(ulong)map_physmem(base,
							   info->portwidth,
							   MAP_NOCACHE);
				if (info->portwidth == FLASH_CFI_8BIT
					&& info->interface == FLASH_CFI_X8X16) {
57e15ca8:	0a000001 	beq	57e15cb4 <flash_init+0xa4>
					info->addr_unlock1 = 0x2AAA;
					info->addr_unlock2 = 0x5555;
				} else {
					info->addr_unlock1 = 0x5555;
57e15cac:	e584a104 	str	sl, [r4, #260]	; 0x104
					info->addr_unlock2 = 0x2AAA;
57e15cb0:	e5847108 	str	r7, [r4, #264]	; 0x108
}

#ifdef CONFIG_FLASH_CFI_LEGACY
static void flash_read_jedec_ids (flash_info_t * info)
{
	info->manufacturer_id = 0;
57e15cb4:	e3a02000 	mov	r2, #0
	info->device_id       = 0;
	info->device_id2      = 0;

	switch (info->vendor) {
57e15cb8:	e3530003 	cmp	r3, #3
}

#ifdef CONFIG_FLASH_CFI_LEGACY
static void flash_read_jedec_ids (flash_info_t * info)
{
	info->manufacturer_id = 0;
57e15cbc:	e1c42fb6 	strh	r2, [r4, #246]	; 0xf6
	info->device_id       = 0;
57e15cc0:	e1c42fb8 	strh	r2, [r4, #248]	; 0xf8
	info->device_id2      = 0;
57e15cc4:	e1c42fba 	strh	r2, [r4, #250]	; 0xfa

	switch (info->vendor) {
57e15cc8:	0a000009 	beq	57e15cf4 <flash_init+0xe4>
57e15ccc:	8a000004 	bhi	57e15ce4 <flash_init+0xd4>
57e15cd0:	e3530001 	cmp	r3, #1
57e15cd4:	0a000006 	beq	57e15cf4 <flash_init+0xe4>
57e15cd8:	e3530002 	cmp	r3, #2
57e15cdc:	1a000009 	bne	57e15d08 <flash_init+0xf8>
57e15ce0:	ea000006 	b	57e15d00 <flash_init+0xf0>
57e15ce4:	e3530004 	cmp	r3, #4
57e15ce8:	0a000004 	beq	57e15d00 <flash_init+0xf0>
57e15cec:	e3530c02 	cmp	r3, #512	; 0x200
57e15cf0:	1a000004 	bne	57e15d08 <flash_init+0xf8>
	case CFI_CMDSET_INTEL_PROG_REGIONS:
	case CFI_CMDSET_INTEL_STANDARD:
	case CFI_CMDSET_INTEL_EXTENDED:
		cmdset_intel_read_jedec_ids(info);
57e15cf4:	e59f00e8 	ldr	r0, [pc, #232]	; 57e15de4 <flash_init+0x1d4>
57e15cf8:	ebfffa66 	bl	57e14698 <cmdset_intel_read_jedec_ids>
57e15cfc:	ea000001 	b	57e15d08 <flash_init+0xf8>
		break;
	case CFI_CMDSET_AMD_STANDARD:
	case CFI_CMDSET_AMD_EXTENDED:
		cmdset_amd_read_jedec_ids(info);
57e15d00:	e59f00dc 	ldr	r0, [pc, #220]	; 57e15de4 <flash_init+0x1d4>
57e15d04:	ebfffa8e 	bl	57e14744 <cmdset_amd_read_jedec_ids>
				flash_read_jedec_ids(info);
				debug("JEDEC PROBE: ID %x %x %x\n",
						info->manufacturer_id,
						info->device_id,
						info->device_id2);
				if (jedec_flash_match(info, info->start[0]))
57e15d08:	e59f00d4 	ldr	r0, [pc, #212]	; 57e15de4 <flash_init+0x1d4>
57e15d0c:	e5941014 	ldr	r1, [r4, #20]
57e15d10:	eb000036 	bl	57e15df0 <jedec_flash_match>
57e15d14:	e3500000 	cmp	r0, #0
57e15d18:	1a000001 	bne	57e15d24 <flash_init+0x114>
				CFI_CMDSET_AMD_STANDARD,
				CFI_CMDSET_INTEL_STANDARD
			};
			int i;

			for (i = 0; i < sizeof(modes) / sizeof(modes[0]); i++) {
57e15d1c:	e1560009 	cmp	r6, r9
57e15d20:	1affffd4 	bne	57e15c78 <flash_init+0x68>
					unmap_physmem((void *)info->start[0],
						      MAP_NOCACHE);
			}
		}

		switch(info->vendor) {
57e15d24:	e59f30a8 	ldr	r3, [pc, #168]	; 57e15dd4 <flash_init+0x1c4>
57e15d28:	e1d33ebc 	ldrh	r3, [r3, #236]	; 0xec
57e15d2c:	e3530003 	cmp	r3, #3
57e15d30:	0a00000c 	beq	57e15d68 <flash_init+0x158>
57e15d34:	8a000003 	bhi	57e15d48 <flash_init+0x138>
57e15d38:	e3530001 	cmp	r3, #1
57e15d3c:	0a000009 	beq	57e15d68 <flash_init+0x158>
57e15d40:	e3530002 	cmp	r3, #2
57e15d44:	ea000005 	b	57e15d60 <flash_init+0x150>
57e15d48:	e3530c02 	cmp	r3, #512	; 0x200
57e15d4c:	0a000005 	beq	57e15d68 <flash_init+0x158>
57e15d50:	e59f2090 	ldr	r2, [pc, #144]	; 57e15de8 <flash_init+0x1d8>
57e15d54:	e1530002 	cmp	r3, r2
57e15d58:	0a000005 	beq	57e15d74 <flash_init+0x164>
57e15d5c:	e3530004 	cmp	r3, #4
57e15d60:	1a000006 	bne	57e15d80 <flash_init+0x170>
57e15d64:	ea000002 	b	57e15d74 <flash_init+0x164>
		case CFI_CMDSET_INTEL_PROG_REGIONS:
		case CFI_CMDSET_INTEL_STANDARD:
		case CFI_CMDSET_INTEL_EXTENDED:
			info->cmd_reset = FLASH_CMD_RESET;
57e15d68:	e59f3064 	ldr	r3, [pc, #100]	; 57e15dd4 <flash_init+0x1c4>
57e15d6c:	e3a020ff 	mov	r2, #255	; 0xff
57e15d70:	ea000001 	b	57e15d7c <flash_init+0x16c>
			break;
		case CFI_CMDSET_AMD_STANDARD:
		case CFI_CMDSET_AMD_EXTENDED:
		case CFI_CMDSET_AMD_LEGACY:
			info->cmd_reset = AMD_CMD_RESET;
57e15d74:	e59f3058 	ldr	r3, [pc, #88]	; 57e15dd4 <flash_init+0x1c4>
57e15d78:	e3a020f0 	mov	r2, #240	; 0xf0
57e15d7c:	e1c32ebe 	strh	r2, [r3, #238]	; 0xee
			break;
		}
		info->flash_id = FLASH_MAN_CFI;
57e15d80:	e59f304c 	ldr	r3, [pc, #76]	; 57e15dd4 <flash_init+0x1c4>
57e15d84:	e3a02401 	mov	r2, #16777216	; 0x1000000
57e15d88:	e5832010 	str	r2, [r3, #16]
57e15d8c:	ea000002 	b	57e15d9c <flash_init+0x18c>
		/* Optionally write flash configuration register */
		cfi_flash_set_config_reg(cfi_flash_bank_addr(i),
					 cfi_flash_config_reg(i));

		if (!flash_detect_legacy(cfi_flash_bank_addr(i), i))
			flash_get_size(cfi_flash_bank_addr(i), i);
57e15d90:	ebfffa09 	bl	57e145bc <cfi_flash_bank_addr>
57e15d94:	e1a01006 	mov	r1, r6
57e15d98:	ebfffd98 	bl	57e15400 <flash_get_size>
		size += flash_info[i].size;
57e15d9c:	e59f3030 	ldr	r3, [pc, #48]	; 57e15dd4 <flash_init+0x1c4>
		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
57e15da0:	e5932010 	ldr	r2, [r3, #16]
		cfi_flash_set_config_reg(cfi_flash_bank_addr(i),
					 cfi_flash_config_reg(i));

		if (!flash_detect_legacy(cfi_flash_bank_addr(i), i))
			flash_get_size(cfi_flash_bank_addr(i), i);
		size += flash_info[i].size;
57e15da4:	e5934008 	ldr	r4, [r3, #8]
		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
57e15da8:	e59f3020 	ldr	r3, [pc, #32]	; 57e15dd0 <flash_init+0x1c0>
57e15dac:	e1520003 	cmp	r2, r3
57e15db0:	1a000004 	bne	57e15dc8 <flash_init+0x1b8>
#ifndef CONFIG_SYS_FLASH_QUIET_TEST
			printf ("## Unknown flash on Bank %d "
57e15db4:	e59f0030 	ldr	r0, [pc, #48]	; 57e15dec <flash_init+0x1dc>
57e15db8:	e3a01001 	mov	r1, #1
57e15dbc:	e1a02004 	mov	r2, r4
57e15dc0:	e1a03a24 	lsr	r3, r4, #20
57e15dc4:	ebffcda0 	bl	57e0944c <printf>
#ifdef CONFIG_FLASH_CFI_MTD
	cfi_mtd_init();
#endif

	return (size);
}
57e15dc8:	e1a00004 	mov	r0, r4
57e15dcc:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
57e15dd0:	0000ffff 	.word	0x0000ffff
57e15dd4:	57e4767c 	.word	0x57e4767c
57e15dd8:	57e2c33c 	.word	0x57e2c33c
57e15ddc:	00005555 	.word	0x00005555
57e15de0:	00002aaa 	.word	0x00002aaa
57e15de4:	57e47684 	.word	0x57e47684
57e15de8:	0000fff0 	.word	0x0000fff0
57e15dec:	57e33803 	.word	0x57e33803

57e15df0 <jedec_flash_match>:

/*-----------------------------------------------------------------------
 * match jedec ids against table. If a match is found, fill flash_info entry
 */
int jedec_flash_match(flash_info_t *info, ulong base)
{
57e15df0:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int ret = 0;
	int i;
	ulong mask = 0xFFFF;
	if (info->chipwidth == 1)
57e15df4:	e5d0a0d5 	ldrb	sl, [r0, #213]	; 0xd5
		mask = 0xFF;

	for (i = 0; i < ARRAY_SIZE(jedec_table); i++) {
57e15df8:	e3a03000 	mov	r3, #0
 */
int jedec_flash_match(flash_info_t *info, ulong base)
{
	int ret = 0;
	int i;
	ulong mask = 0xFFFF;
57e15dfc:	e35a0001 	cmp	sl, #1

/*-----------------------------------------------------------------------
 * match jedec ids against table. If a match is found, fill flash_info entry
 */
int jedec_flash_match(flash_info_t *info, ulong base)
{
57e15e00:	e1a05001 	mov	r5, r1
	int ret = 0;
	int i;
	ulong mask = 0xFFFF;
57e15e04:	e59f2178 	ldr	r2, [pc, #376]	; 57e15f84 <jedec_flash_match+0x194>

/*-----------------------------------------------------------------------
 * match jedec ids against table. If a match is found, fill flash_info entry
 */
int jedec_flash_match(flash_info_t *info, ulong base)
{
57e15e08:	e1a04000 	mov	r4, r0
	int ret = 0;
	int i;
	ulong mask = 0xFFFF;
57e15e0c:	03a020ff 	moveq	r2, #255	; 0xff
	if (info->chipwidth == 1)
		mask = 0xFF;

	for (i = 0; i < ARRAY_SIZE(jedec_table); i++) {
57e15e10:	e1a07003 	mov	r7, r3
		if ((jedec_table[i].mfr_id & mask) == (info->manufacturer_id & mask) &&
57e15e14:	e59f116c 	ldr	r1, [pc, #364]	; 57e15f88 <jedec_flash_match+0x198>
	int i;
	ulong mask = 0xFFFF;
	if (info->chipwidth == 1)
		mask = 0xFF;

	for (i = 0; i < ARRAY_SIZE(jedec_table); i++) {
57e15e18:	ea000055 	b	57e15f74 <jedec_flash_match+0x184>
		if ((jedec_table[i].mfr_id & mask) == (info->manufacturer_id & mask) &&
57e15e1c:	e1d4cebe 	ldrh	ip, [r4, #238]	; 0xee
57e15e20:	e19100b3 	ldrh	r0, [r1, r3]
57e15e24:	e02c0000 	eor	r0, ip, r0
57e15e28:	e1120000 	tst	r2, r0
57e15e2c:	1a00004e 	bne	57e15f6c <jedec_flash_match+0x17c>
}

/*-----------------------------------------------------------------------
 * match jedec ids against table. If a match is found, fill flash_info entry
 */
int jedec_flash_match(flash_info_t *info, ulong base)
57e15e30:	e0810003 	add	r0, r1, r3
	if (info->chipwidth == 1)
		mask = 0xFF;

	for (i = 0; i < ARRAY_SIZE(jedec_table); i++) {
		if ((jedec_table[i].mfr_id & mask) == (info->manufacturer_id & mask) &&
		    (jedec_table[i].dev_id & mask) == (info->device_id & mask)) {
57e15e34:	e1d4bfb0 	ldrh	fp, [r4, #240]	; 0xf0
57e15e38:	e1d000b2 	ldrh	r0, [r0, #2]
57e15e3c:	e02bb000 	eor	fp, fp, r0
	ulong mask = 0xFFFF;
	if (info->chipwidth == 1)
		mask = 0xFF;

	for (i = 0; i < ARRAY_SIZE(jedec_table); i++) {
		if ((jedec_table[i].mfr_id & mask) == (info->manufacturer_id & mask) &&
57e15e40:	e012b00b 	ands	fp, r2, fp
57e15e44:	1a000048 	bne	57e15f6c <jedec_flash_match+0x17c>
	int sect_cnt;
	int size_ratio;
	int total_size;
	enum uaddr uaddr_idx;

	size_ratio = info->portwidth / info->chipwidth;
57e15e48:	e1a0100a 	mov	r1, sl
57e15e4c:	e5d400d4 	ldrb	r0, [r4, #212]	; 0xd4
57e15e50:	eb005656 	bl	57e2b7b0 <__udivsi3>

	debug("Found JEDEC Flash: %s\n", jedec_entry->name);
	info->vendor = jedec_entry->CmdSet;
57e15e54:	e59f312c 	ldr	r3, [pc, #300]	; 57e15f88 <jedec_flash_match+0x198>
57e15e58:	e3a02030 	mov	r2, #48	; 0x30
57e15e5c:	e0233792 	mla	r3, r2, r7, r3
57e15e60:	e1d311b0 	ldrh	r1, [r3, #16]
	/* copy unlock addresses from device table to CFI info struct. This
	   is just here because the addresses are in the table anyway - if
	   the flash is not detected due to wrong unlock addresses,
	   flash_detect_legacy would have to try all of them before we even
	   get here. */
	switch(info->chipwidth) {
57e15e64:	e35a0002 	cmp	sl, #2
	enum uaddr uaddr_idx;

	size_ratio = info->portwidth / info->chipwidth;

	debug("Found JEDEC Flash: %s\n", jedec_entry->name);
	info->vendor = jedec_entry->CmdSet;
57e15e68:	e1c41eb4 	strh	r1, [r4, #228]	; 0xe4
	/* Todo: do we need device-specific timeouts? */
	info->erase_blk_tout = 30000;
57e15e6c:	e59f1118 	ldr	r1, [pc, #280]	; 57e15f8c <jedec_flash_match+0x19c>
	int sect_cnt;
	int size_ratio;
	int total_size;
	enum uaddr uaddr_idx;

	size_ratio = info->portwidth / info->chipwidth;
57e15e70:	e20090ff 	and	r9, r0, #255	; 0xff

	debug("Found JEDEC Flash: %s\n", jedec_entry->name);
	info->vendor = jedec_entry->CmdSet;
	/* Todo: do we need device-specific timeouts? */
	info->erase_blk_tout = 30000;
57e15e74:	e58410d8 	str	r1, [r4, #216]	; 0xd8
	info->buffer_write_tout = 1000;
57e15e78:	e3a01ffa 	mov	r1, #1000	; 0x3e8
57e15e7c:	e58410e0 	str	r1, [r4, #224]	; 0xe0
	info->write_tout = 100;
57e15e80:	e2411fe1 	sub	r1, r1, #900	; 0x384
57e15e84:	e58410dc 	str	r1, [r4, #220]	; 0xdc
	info->name = jedec_entry->name;
57e15e88:	e5931004 	ldr	r1, [r3, #4]
	enum uaddr uaddr_idx;

	size_ratio = info->portwidth / info->chipwidth;

	debug("Found JEDEC Flash: %s\n", jedec_entry->name);
	info->vendor = jedec_entry->CmdSet;
57e15e8c:	e2832010 	add	r2, r3, #16
	/* Todo: do we need device-specific timeouts? */
	info->erase_blk_tout = 30000;
	info->buffer_write_tout = 1000;
	info->write_tout = 100;
	info->name = jedec_entry->name;
57e15e90:	e5841104 	str	r1, [r4, #260]	; 0x104
	switch(info->chipwidth) {
	case FLASH_CFI_8BIT:
		uaddr_idx = jedec_entry->uaddr[0];
		break;
	case FLASH_CFI_16BIT:
		uaddr_idx = jedec_entry->uaddr[1];
57e15e94:	05d3b015 	ldrbeq	fp, [r3, #21]
	/* copy unlock addresses from device table to CFI info struct. This
	   is just here because the addresses are in the table anyway - if
	   the flash is not detected due to wrong unlock addresses,
	   flash_detect_legacy would have to try all of them before we even
	   get here. */
	switch(info->chipwidth) {
57e15e98:	0a000004 	beq	57e15eb0 <jedec_flash_match+0xc0>
57e15e9c:	e35a0004 	cmp	sl, #4
		break;
	case FLASH_CFI_16BIT:
		uaddr_idx = jedec_entry->uaddr[1];
		break;
	case FLASH_CFI_32BIT:
		uaddr_idx = jedec_entry->uaddr[2];
57e15ea0:	05d3b016 	ldrbeq	fp, [r3, #22]
	/* copy unlock addresses from device table to CFI info struct. This
	   is just here because the addresses are in the table anyway - if
	   the flash is not detected due to wrong unlock addresses,
	   flash_detect_legacy would have to try all of them before we even
	   get here. */
	switch(info->chipwidth) {
57e15ea4:	0a000001 	beq	57e15eb0 <jedec_flash_match+0xc0>
57e15ea8:	e35a0001 	cmp	sl, #1
	case FLASH_CFI_8BIT:
		uaddr_idx = jedec_entry->uaddr[0];
57e15eac:	05d2b004 	ldrbeq	fp, [r2, #4]
		uaddr_idx = MTD_UADDR_NOT_SUPPORTED;
		break;
	}

	debug("unlock address index %d\n", uaddr_idx);
	info->addr_unlock1 = unlock_addrs[uaddr_idx].addr1;
57e15eb0:	e59f30d0 	ldr	r3, [pc, #208]	; 57e15f88 <jedec_flash_match+0x198>
	info->addr_unlock2 = unlock_addrs[uaddr_idx].addr2;
	debug("unlock addresses are 0x%lx/0x%lx\n",
		info->addr_unlock1, info->addr_unlock2);

	sect_cnt = 0;
	total_size = 0;
57e15eb4:	e3a06000 	mov	r6, #0
		uaddr_idx = MTD_UADDR_NOT_SUPPORTED;
		break;
	}

	debug("unlock address index %d\n", uaddr_idx);
	info->addr_unlock1 = unlock_addrs[uaddr_idx].addr1;
57e15eb8:	e083b18b 	add	fp, r3, fp, lsl #3
57e15ebc:	e59b20c0 	ldr	r2, [fp, #192]	; 0xc0
	debug("unlock addresses are 0x%lx/0x%lx\n",
		info->addr_unlock1, info->addr_unlock2);

	sect_cnt = 0;
	total_size = 0;
	for (i = 0; i < jedec_entry->NumEraseRegions; i++) {
57e15ec0:	e1a0a006 	mov	sl, r6
		uaddr_idx = MTD_UADDR_NOT_SUPPORTED;
		break;
	}

	debug("unlock address index %d\n", uaddr_idx);
	info->addr_unlock1 = unlock_addrs[uaddr_idx].addr1;
57e15ec4:	e58420fc 	str	r2, [r4, #252]	; 0xfc
	info->addr_unlock2 = unlock_addrs[uaddr_idx].addr2;
57e15ec8:	e59b20c4 	ldr	r2, [fp, #196]	; 0xc4
57e15ecc:	e5842100 	str	r2, [r4, #256]	; 0x100
}

/*-----------------------------------------------------------------------
 * match jedec ids against table. If a match is found, fill flash_info entry
 */
int jedec_flash_match(flash_info_t *info, ulong base)
57e15ed0:	e3a02030 	mov	r2, #48	; 0x30
57e15ed4:	e0020297 	mul	r2, r7, r2
57e15ed8:	e282b014 	add	fp, r2, #20
57e15edc:	e083b00b 	add	fp, r3, fp
	debug("unlock addresses are 0x%lx/0x%lx\n",
		info->addr_unlock1, info->addr_unlock2);

	sect_cnt = 0;
	total_size = 0;
	for (i = 0; i < jedec_entry->NumEraseRegions; i++) {
57e15ee0:	e0833002 	add	r3, r3, r2
	info->addr_unlock1 = unlock_addrs[uaddr_idx].addr1;
	info->addr_unlock2 = unlock_addrs[uaddr_idx].addr2;
	debug("unlock addresses are 0x%lx/0x%lx\n",
		info->addr_unlock1, info->addr_unlock2);

	sect_cnt = 0;
57e15ee4:	e1a07006 	mov	r7, r6
	total_size = 0;
	for (i = 0; i < jedec_entry->NumEraseRegions; i++) {
57e15ee8:	e593c00c 	ldr	ip, [r3, #12]
57e15eec:	ea000017 	b	57e15f50 <jedec_flash_match+0x160>
		ulong erase_region_size = jedec_entry->regions[i] >> 8;
57e15ef0:	e5bb1004 	ldr	r1, [fp, #4]!
}

/*-----------------------------------------------------------------------
 * match jedec ids against table. If a match is found, fill flash_info entry
 */
int jedec_flash_match(flash_info_t *info, ulong base)
57e15ef4:	e0842107 	add	r2, r4, r7, lsl #2
		info->addr_unlock1, info->addr_unlock2);

	sect_cnt = 0;
	total_size = 0;
	for (i = 0; i < jedec_entry->NumEraseRegions; i++) {
		ulong erase_region_size = jedec_entry->regions[i] >> 8;
57e15ef8:	e1a00421 	lsr	r0, r1, #8
		ulong erase_region_count = (jedec_entry->regions[i] & 0xff) + 1;
57e15efc:	e20110ff 	and	r1, r1, #255	; 0xff
57e15f00:	e2811001 	add	r1, r1, #1

		total_size += erase_region_size * erase_region_count;
57e15f04:	e0266190 	mla	r6, r0, r1, r6
}

/*-----------------------------------------------------------------------
 * match jedec ids against table. If a match is found, fill flash_info entry
 */
int jedec_flash_match(flash_info_t *info, ulong base)
57e15f08:	e2822008 	add	r2, r2, #8
			if (sect_cnt >= CONFIG_SYS_MAX_FLASH_SECT) {
				printf("ERROR: too many flash sectors\n");
				break;
			}
			info->start[sect_cnt] = base;
			base += (erase_region_size * size_ratio);
57e15f0c:	e0000099 	mul	r0, r9, r0
		ulong erase_region_count = (jedec_entry->regions[i] & 0xff) + 1;

		total_size += erase_region_size * erase_region_count;
		debug("erase_region_count = %ld erase_region_size = %ld\n",
		       erase_region_count, erase_region_size);
		for (j = 0; j < erase_region_count; j++) {
57e15f10:	e3a03000 	mov	r3, #0
57e15f14:	ea00000a 	b	57e15f44 <jedec_flash_match+0x154>
			if (sect_cnt >= CONFIG_SYS_MAX_FLASH_SECT) {
57e15f18:	e3570027 	cmp	r7, #39	; 0x27
57e15f1c:	da000004 	ble	57e15f34 <jedec_flash_match+0x144>
				printf("ERROR: too many flash sectors\n");
57e15f20:	e59f0068 	ldr	r0, [pc, #104]	; 57e15f90 <jedec_flash_match+0x1a0>
57e15f24:	e58dc004 	str	ip, [sp, #4]
57e15f28:	ebffcd47 	bl	57e0944c <printf>
57e15f2c:	e59dc004 	ldr	ip, [sp, #4]
57e15f30:	ea000005 	b	57e15f4c <jedec_flash_match+0x15c>
				break;
			}
			info->start[sect_cnt] = base;
57e15f34:	e5a25004 	str	r5, [r2, #4]!
			base += (erase_region_size * size_ratio);
			sect_cnt++;
57e15f38:	e2877001 	add	r7, r7, #1
			if (sect_cnt >= CONFIG_SYS_MAX_FLASH_SECT) {
				printf("ERROR: too many flash sectors\n");
				break;
			}
			info->start[sect_cnt] = base;
			base += (erase_region_size * size_ratio);
57e15f3c:	e0855000 	add	r5, r5, r0
		ulong erase_region_count = (jedec_entry->regions[i] & 0xff) + 1;

		total_size += erase_region_size * erase_region_count;
		debug("erase_region_count = %ld erase_region_size = %ld\n",
		       erase_region_count, erase_region_size);
		for (j = 0; j < erase_region_count; j++) {
57e15f40:	e2833001 	add	r3, r3, #1
57e15f44:	e1530001 	cmp	r3, r1
57e15f48:	3afffff2 	bcc	57e15f18 <jedec_flash_match+0x128>
	debug("unlock addresses are 0x%lx/0x%lx\n",
		info->addr_unlock1, info->addr_unlock2);

	sect_cnt = 0;
	total_size = 0;
	for (i = 0; i < jedec_entry->NumEraseRegions; i++) {
57e15f4c:	e28aa001 	add	sl, sl, #1
57e15f50:	e15a000c 	cmp	sl, ip
57e15f54:	baffffe5 	blt	57e15ef0 <jedec_flash_match+0x100>
			base += (erase_region_size * size_ratio);
			sect_cnt++;
		}
	}
	info->sector_count = sect_cnt;
	info->size = total_size * size_ratio;
57e15f58:	e0060699 	mul	r6, r9, r6
			info->start[sect_cnt] = base;
			base += (erase_region_size * size_ratio);
			sect_cnt++;
		}
	}
	info->sector_count = sect_cnt;
57e15f5c:	e1c470b4 	strh	r7, [r4, #4]
	info->size = total_size * size_ratio;
57e15f60:	e5846000 	str	r6, [r4]

	for (i = 0; i < ARRAY_SIZE(jedec_table); i++) {
		if ((jedec_table[i].mfr_id & mask) == (info->manufacturer_id & mask) &&
		    (jedec_table[i].dev_id & mask) == (info->device_id & mask)) {
			fill_info(info, &jedec_table[i], base);
			ret = 1;
57e15f64:	e3a00001 	mov	r0, #1
			break;
57e15f68:	ea000004 	b	57e15f80 <jedec_flash_match+0x190>
	int i;
	ulong mask = 0xFFFF;
	if (info->chipwidth == 1)
		mask = 0xFF;

	for (i = 0; i < ARRAY_SIZE(jedec_table); i++) {
57e15f6c:	e2877001 	add	r7, r7, #1
57e15f70:	e2833030 	add	r3, r3, #48	; 0x30
57e15f74:	e3570004 	cmp	r7, #4
57e15f78:	1affffa7 	bne	57e15e1c <jedec_flash_match+0x2c>
/*-----------------------------------------------------------------------
 * match jedec ids against table. If a match is found, fill flash_info entry
 */
int jedec_flash_match(flash_info_t *info, ulong base)
{
	int ret = 0;
57e15f7c:	e3a00000 	mov	r0, #0
			ret = 1;
			break;
		}
	}
	return ret;
}
57e15f80:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e15f84:	0000ffff 	.word	0x0000ffff
57e15f88:	57e2c344 	.word	0x57e2c344
57e15f8c:	00007530 	.word	0x00007530
57e15f90:	57e337e4 	.word	0x57e337e4

57e15f94 <nand_register>:

static unsigned long total_nand_size; /* in kiB */

/* Register an initialized NAND mtd device with the U-Boot NAND command. */
int nand_register(int devnum)
{
57e15f94:	e92d4070 	push	{r4, r5, r6, lr}
	struct mtd_info *mtd;

	if (devnum >= CONFIG_SYS_MAX_NAND_DEVICE)
57e15f98:	e2504000 	subs	r4, r0, #0
		return -EINVAL;
57e15f9c:	c3e00015 	mvngt	r0, #21
/* Register an initialized NAND mtd device with the U-Boot NAND command. */
int nand_register(int devnum)
{
	struct mtd_info *mtd;

	if (devnum >= CONFIG_SYS_MAX_NAND_DEVICE)
57e15fa0:	c8bd8070 	popgt	{r4, r5, r6, pc}
		return -EINVAL;

	mtd = &nand_info[devnum];

	sprintf(dev_name[devnum], "nand%d", devnum);
57e15fa4:	e59f5054 	ldr	r5, [pc, #84]	; 57e16000 <nand_register+0x6c>
57e15fa8:	e1a02004 	mov	r2, r4
57e15fac:	e0856184 	add	r6, r5, r4, lsl #3
57e15fb0:	e1a00006 	mov	r0, r6
57e15fb4:	e59f1048 	ldr	r1, [pc, #72]	; 57e16004 <nand_register+0x70>
57e15fb8:	eb003ce2 	bl	57e25348 <sprintf>
	mtd->name = dev_name[devnum];
57e15fbc:	e3a030a8 	mov	r3, #168	; 0xa8
57e15fc0:	e0235394 	mla	r3, r4, r3, r5
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	add_mtd_device(mtd);
#endif

	total_nand_size += mtd->size / 1024;
57e15fc4:	e5932014 	ldr	r2, [r3, #20]
		return -EINVAL;

	mtd = &nand_info[devnum];

	sprintf(dev_name[devnum], "nand%d", devnum);
	mtd->name = dev_name[devnum];
57e15fc8:	e5836028 	str	r6, [r3, #40]	; 0x28
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	add_mtd_device(mtd);
#endif

	total_nand_size += mtd->size / 1024;
57e15fcc:	e5933010 	ldr	r3, [r3, #16]
57e15fd0:	e1a03523 	lsr	r3, r3, #10
57e15fd4:	e1833b02 	orr	r3, r3, r2, lsl #22
57e15fd8:	e59520b0 	ldr	r2, [r5, #176]	; 0xb0
57e15fdc:	e0823003 	add	r3, r2, r3
57e15fe0:	e58530b0 	str	r3, [r5, #176]	; 0xb0

	if (nand_curr_device == -1)
57e15fe4:	e59f301c 	ldr	r3, [pc, #28]	; 57e16008 <nand_register+0x74>
57e15fe8:	e5932000 	ldr	r2, [r3]
57e15fec:	e3720001 	cmn	r2, #1
		nand_curr_device = devnum;
57e15ff0:	05834000 	streq	r4, [r3]

	return 0;
57e15ff4:	03a00000 	moveq	r0, #0
57e15ff8:	13a00000 	movne	r0, #0
}
57e15ffc:	e8bd8070 	pop	{r4, r5, r6, pc}
57e16000:	57e47790 	.word	0x57e47790
57e16004:	57e3387c 	.word	0x57e3387c
57e16008:	57e36f3c 	.word	0x57e36f3c

57e1600c <nand_init>:
	nand_register(i);
}
#endif

void nand_init(void)
{
57e1600c:	e92d4010 	push	{r4, lr}
	int maxchips = CONFIG_SYS_NAND_MAX_CHIPS;

	if (maxchips < 1)
		maxchips = 1;

	mtd->priv = nand;
57e16010:	e59f404c 	ldr	r4, [pc, #76]	; 57e16064 <nand_init+0x58>
	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
57e16014:	e59f304c 	ldr	r3, [pc, #76]	; 57e16068 <nand_init+0x5c>
	int maxchips = CONFIG_SYS_NAND_MAX_CHIPS;

	if (maxchips < 1)
		maxchips = 1;

	mtd->priv = nand;
57e16018:	e28400b8 	add	r0, r4, #184	; 0xb8
57e1601c:	e584009c 	str	r0, [r4, #156]	; 0x9c
	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
57e16020:	e58430bc 	str	r3, [r4, #188]	; 0xbc
57e16024:	e58430b8 	str	r3, [r4, #184]	; 0xb8

	if (board_nand_init(nand))
57e16028:	eb0019af 	bl	57e1c6ec <board_nand_init>
57e1602c:	e3500000 	cmp	r0, #0
57e16030:	1a000005 	bne	57e1604c <nand_init+0x40>
		return;

	if (nand_scan(mtd, maxchips))
57e16034:	e2840008 	add	r0, r4, #8
57e16038:	e3a01001 	mov	r1, #1
57e1603c:	eb00191b 	bl	57e1c4b0 <nand_scan>
57e16040:	e3500000 	cmp	r0, #0
57e16044:	1a000000 	bne	57e1604c <nand_init+0x40>
		return;

	nand_register(i);
57e16048:	ebffffd1 	bl	57e15f94 <nand_register>

	for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++)
		nand_init_chip(i);
#endif

	printf("%lu MiB\n", total_nand_size / 1024);
57e1604c:	e59f3010 	ldr	r3, [pc, #16]	; 57e16064 <nand_init+0x58>
57e16050:	e59f0014 	ldr	r0, [pc, #20]	; 57e1606c <nand_init+0x60>
57e16054:	e59310b0 	ldr	r1, [r3, #176]	; 0xb0
57e16058:	e1a01521 	lsr	r1, r1, #10
	/*
	 * Select the chip in the board/cpu specific driver
	 */
	board_nand_select_device(nand_info[nand_curr_device].priv, nand_curr_device);
#endif
}
57e1605c:	e8bd4010 	pop	{r4, lr}

	for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++)
		nand_init_chip(i);
#endif

	printf("%lu MiB\n", total_nand_size / 1024);
57e16060:	eaffccf9 	b	57e0944c <printf>
57e16064:	57e47790 	.word	0x57e47790
57e16068:	70200010 	.word	0x70200010
57e1606c:	57e33883 	.word	0x57e33883

57e16070 <scan_read_raw_oob>:
/*
 * Scan read raw data from flash
 */
static int scan_read_raw_oob(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
			 size_t len)
{
57e16070:	e92d4cf0 	push	{r4, r5, r6, r7, sl, fp, lr}
57e16074:	e1a0b003 	mov	fp, r3
57e16078:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct mtd_oob_ops ops;
	int res;

	ops.mode = MTD_OOB_RAW;
57e1607c:	e3a03002 	mov	r3, #2
57e16080:	e58d3008 	str	r3, [sp, #8]
	ops.ooboffs = 0;
57e16084:	e3a03000 	mov	r3, #0
57e16088:	e58d301c 	str	r3, [sp, #28]
	ops.ooblen = mtd->oobsize;
57e1608c:	e5903018 	ldr	r3, [r0, #24]
/*
 * Scan read raw data from flash
 */
static int scan_read_raw_oob(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
			 size_t len)
{
57e16090:	e1a04000 	mov	r4, r0
57e16094:	e1a06001 	mov	r6, r1
57e16098:	e1a0a002 	mov	sl, r2
57e1609c:	e59d5048 	ldr	r5, [sp, #72]	; 0x48
	struct mtd_oob_ops ops;
	int res;

	ops.mode = MTD_OOB_RAW;
	ops.ooboffs = 0;
	ops.ooblen = mtd->oobsize;
57e160a0:	e58d3014 	str	r3, [sp, #20]
57e160a4:	e28d7008 	add	r7, sp, #8


	while (len > 0) {
57e160a8:	ea00001d 	b	57e16124 <scan_read_raw_oob+0xb4>
		if (len <= mtd->writesize) {
57e160ac:	e5943014 	ldr	r3, [r4, #20]
57e160b0:	e594104c 	ldr	r1, [r4, #76]	; 0x4c
57e160b4:	e1550003 	cmp	r5, r3
57e160b8:	8a000009 	bhi	57e160e4 <scan_read_raw_oob+0x74>
			ops.oobbuf = buf + len;
57e160bc:	e0863005 	add	r3, r6, r5
57e160c0:	e58d3024 	str	r3, [sp, #36]	; 0x24
			ops.datbuf = buf;
57e160c4:	e58d6020 	str	r6, [sp, #32]
			ops.len = len;
57e160c8:	e58d500c 	str	r5, [sp, #12]
			return mtd->read_oob(mtd, offs, &ops);
57e160cc:	e58d7000 	str	r7, [sp]
57e160d0:	e1a00004 	mov	r0, r4
57e160d4:	e1a0200a 	mov	r2, sl
57e160d8:	e1a0300b 	mov	r3, fp
57e160dc:	e12fff31 	blx	r1
57e160e0:	ea000012 	b	57e16130 <scan_read_raw_oob+0xc0>
		} else {
			ops.oobbuf = buf + mtd->writesize;
57e160e4:	e0862003 	add	r2, r6, r3
57e160e8:	e58d2024 	str	r2, [sp, #36]	; 0x24
			ops.datbuf = buf;
			ops.len = mtd->writesize;
57e160ec:	e58d300c 	str	r3, [sp, #12]
			ops.datbuf = buf;
			ops.len = len;
			return mtd->read_oob(mtd, offs, &ops);
		} else {
			ops.oobbuf = buf + mtd->writesize;
			ops.datbuf = buf;
57e160f0:	e58d6020 	str	r6, [sp, #32]
			ops.len = mtd->writesize;
			res = mtd->read_oob(mtd, offs, &ops);
57e160f4:	e58d7000 	str	r7, [sp]
57e160f8:	e1a00004 	mov	r0, r4
57e160fc:	e1a0200a 	mov	r2, sl
57e16100:	e1a0300b 	mov	r3, fp
57e16104:	e12fff31 	blx	r1

			if (res)
57e16108:	e3500000 	cmp	r0, #0
57e1610c:	1a000007 	bne	57e16130 <scan_read_raw_oob+0xc0>
				return res;
		}

		buf += mtd->oobsize + mtd->writesize;
57e16110:	e5943014 	ldr	r3, [r4, #20]
57e16114:	e5942018 	ldr	r2, [r4, #24]
		len -= mtd->writesize;
57e16118:	e0635005 	rsb	r5, r3, r5

			if (res)
				return res;
		}

		buf += mtd->oobsize + mtd->writesize;
57e1611c:	e0832002 	add	r2, r3, r2
57e16120:	e0866002 	add	r6, r6, r2
	ops.mode = MTD_OOB_RAW;
	ops.ooboffs = 0;
	ops.ooblen = mtd->oobsize;


	while (len > 0) {
57e16124:	e3550000 	cmp	r5, #0
57e16128:	1affffdf 	bne	57e160ac <scan_read_raw_oob+0x3c>
		}

		buf += mtd->oobsize + mtd->writesize;
		len -= mtd->writesize;
	}
	return 0;
57e1612c:	e1a00005 	mov	r0, r5
}
57e16130:	e28dd02c 	add	sp, sp, #44	; 0x2c
57e16134:	e8bd8cf0 	pop	{r4, r5, r6, r7, sl, fp, pc}

57e16138 <scan_read_raw>:

static int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
			 size_t len, struct nand_bbt_descr *td)
{
57e16138:	e92d40f0 	push	{r4, r5, r6, r7, lr}
57e1613c:	e24dd01c 	sub	sp, sp, #28
57e16140:	e59d4034 	ldr	r4, [sp, #52]	; 0x34
57e16144:	e1a05001 	mov	r5, r1
	if (td->options & NAND_BBT_NO_OOB)
57e16148:	e594e000 	ldr	lr, [r4]
	return 0;
}

static int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
			 size_t len, struct nand_bbt_descr *td)
{
57e1614c:	e1a06002 	mov	r6, r2
	if (td->options & NAND_BBT_NO_OOB)
57e16150:	e31e0501 	tst	lr, #4194304	; 0x400000
	return 0;
}

static int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
			 size_t len, struct nand_bbt_descr *td)
{
57e16154:	e1a07003 	mov	r7, r3
	if (td->options & NAND_BBT_NO_OOB)
57e16158:	0a00000a 	beq	57e16188 <scan_read_raw+0x50>
			 struct nand_bbt_descr *td)
{
	size_t retlen;
	size_t len;

	len = td->len;
57e1615c:	e5943014 	ldr	r3, [r4, #20]
	if (td->options & NAND_BBT_VERSION)
57e16160:	e31e0c01 	tst	lr, #256	; 0x100
		len++;
57e16164:	12833001 	addne	r3, r3, #1

	return mtd->read(mtd, offs, len, &retlen, buf);
57e16168:	e58d3000 	str	r3, [sp]
57e1616c:	e28d3014 	add	r3, sp, #20
57e16170:	e58d3004 	str	r3, [sp, #4]
57e16174:	e58d1008 	str	r1, [sp, #8]
57e16178:	e5901040 	ldr	r1, [r0, #64]	; 0x40
57e1617c:	e1a03007 	mov	r3, r7
57e16180:	e12fff31 	blx	r1

static int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
			 size_t len, struct nand_bbt_descr *td)
{
	if (td->options & NAND_BBT_NO_OOB)
		return scan_read_raw_data(mtd, buf, offs, td);
57e16184:	ea000002 	b	57e16194 <scan_read_raw+0x5c>
	else
		return scan_read_raw_oob(mtd, buf, offs, len);
57e16188:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
57e1618c:	e58dc000 	str	ip, [sp]
57e16190:	ebffffb6 	bl	57e16070 <scan_read_raw_oob>
}
57e16194:	e28dd01c 	add	sp, sp, #28
57e16198:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

57e1619c <read_bbt>:
 * Read the bad block table starting from page.
 *
 */
static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
		struct nand_bbt_descr *td, int offs)
{
57e1619c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e161a0:	e24dd038 	sub	sp, sp, #56	; 0x38
57e161a4:	e1a04000 	mov	r4, r0
57e161a8:	e59d0058 	ldr	r0, [sp, #88]	; 0x58
57e161ac:	e58d1024 	str	r1, [sp, #36]	; 0x24
	int res, i, j, act = 0;
	struct nand_chip *this = mtd->priv;
	size_t retlen, len, totlen;
	loff_t from;
	int bits = td->options & NAND_BBT_NRBITS_MSK;
57e161b0:	e5901000 	ldr	r1, [r0]
 */
static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
		struct nand_bbt_descr *td, int offs)
{
	int res, i, j, act = 0;
	struct nand_chip *this = mtd->priv;
57e161b4:	e5946094 	ldr	r6, [r4, #148]	; 0x94
	size_t retlen, len, totlen;
	loff_t from;
	int bits = td->options & NAND_BBT_NRBITS_MSK;
57e161b8:	e201c00f 	and	ip, r1, #15
57e161bc:	e58dc018 	str	ip, [sp, #24]
	uint8_t msk = (uint8_t) ((1 << bits) - 1);
57e161c0:	e59de018 	ldr	lr, [sp, #24]
57e161c4:	e3e0c000 	mvn	ip, #0
57e161c8:	e1e0ce1c 	mvn	ip, ip, lsl lr
	u32 marker_len;
	int reserved_block_code = td->reserved_block_code;

	totlen = (num * bits) >> 3;
57e161cc:	e003039e 	mul	r3, lr, r3
	int res, i, j, act = 0;
	struct nand_chip *this = mtd->priv;
	size_t retlen, len, totlen;
	loff_t from;
	int bits = td->options & NAND_BBT_NRBITS_MSK;
	uint8_t msk = (uint8_t) ((1 << bits) - 1);
57e161d0:	e20cc0ff 	and	ip, ip, #255	; 0xff
57e161d4:	e58dc01c 	str	ip, [sp, #28]
	u32 marker_len;
	int reserved_block_code = td->reserved_block_code;
57e161d8:	e590c01c 	ldr	ip, [r0, #28]
 */
static u32 add_marker_len(struct nand_bbt_descr *td)
{
	u32 len;

	if (!(td->options & NAND_BBT_NO_OOB))
57e161dc:	e211a501 	ands	sl, r1, #4194304	; 0x400000
	size_t retlen, len, totlen;
	loff_t from;
	int bits = td->options & NAND_BBT_NRBITS_MSK;
	uint8_t msk = (uint8_t) ((1 << bits) - 1);
	u32 marker_len;
	int reserved_block_code = td->reserved_block_code;
57e161e0:	e58dc020 	str	ip, [sp, #32]

	totlen = (num * bits) >> 3;
57e161e4:	e1a091c3 	asr	r9, r3, #3
 */
static u32 add_marker_len(struct nand_bbt_descr *td)
{
	u32 len;

	if (!(td->options & NAND_BBT_NO_OOB))
57e161e8:	0a000002 	beq	57e161f8 <read_bbt+0x5c>
		return 0;

	len = td->len;
57e161ec:	e590a014 	ldr	sl, [r0, #20]
	if (td->options & NAND_BBT_VERSION)
57e161f0:	e3110c01 	tst	r1, #256	; 0x100
		len++;
57e161f4:	128aa001 	addne	sl, sl, #1
	u32 marker_len;
	int reserved_block_code = td->reserved_block_code;

	totlen = (num * bits) >> 3;
	marker_len = add_marker_len(td);
	from = ((loff_t) page) << this->page_shift;
57e161f8:	e1a00002 	mov	r0, r2
57e161fc:	e1a01fc0 	asr	r1, r0, #31
57e16200:	e5962054 	ldr	r2, [r6, #84]	; 0x54
57e16204:	eb00568a 	bl	57e2bc34 <__ashldi3>
57e16208:	e58d0010 	str	r0, [sp, #16]
57e1620c:	e58d1014 	str	r1, [sp, #20]
				uint8_t tmp = (dat >> j) & msk;
				if (tmp == msk)
					continue;
				if (reserved_block_code && (tmp == reserved_block_code)) {
					printk(KERN_DEBUG "nand_read_bbt: Reserved block at 0x%012llx\n",
					       (loff_t)((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
57e16210:	e59d105c 	ldr	r1, [sp, #92]	; 0x5c
 *
 */
static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
		struct nand_bbt_descr *td, int offs)
{
	int res, i, j, act = 0;
57e16214:	e3a07000 	mov	r7, #0
				uint8_t tmp = (dat >> j) & msk;
				if (tmp == msk)
					continue;
				if (reserved_block_code && (tmp == reserved_block_code)) {
					printk(KERN_DEBUG "nand_read_bbt: Reserved block at 0x%012llx\n",
					       (loff_t)((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
57e16218:	e1a01101 	lsl	r1, r1, #2
57e1621c:	e58d1028 	str	r1, [sp, #40]	; 0x28

	totlen = (num * bits) >> 3;
	marker_len = add_marker_len(td);
	from = ((loff_t) page) << this->page_shift;

	while (totlen) {
57e16220:	ea00006c 	b	57e163d8 <read_bbt+0x23c>
		len = min(totlen, (size_t) (1 << this->bbt_erase_shift));
57e16224:	e596505c 	ldr	r5, [r6, #92]	; 0x5c
57e16228:	e3a02001 	mov	r2, #1
57e1622c:	e1a05512 	lsl	r5, r2, r5
57e16230:	e1590005 	cmp	r9, r5
57e16234:	31a05009 	movcc	r5, r9
		if (marker_len) {
57e16238:	e35a0000 	cmp	sl, #0
57e1623c:	0a000006 	beq	57e1625c <read_bbt+0xc0>
			/*
			 * In case the BBT marker is not in the OOB area it
			 * will be just in the first page.
			 */
			len -= marker_len;
			from += marker_len;
57e16240:	e28d2010 	add	r2, sp, #16
57e16244:	e8920006 	ldm	r2, {r1, r2}
57e16248:	e091100a 	adds	r1, r1, sl
57e1624c:	e2a22000 	adc	r2, r2, #0
57e16250:	e58d1010 	str	r1, [sp, #16]
57e16254:	e58d2014 	str	r2, [sp, #20]
		if (marker_len) {
			/*
			 * In case the BBT marker is not in the OOB area it
			 * will be just in the first page.
			 */
			len -= marker_len;
57e16258:	e06a5005 	rsb	r5, sl, r5
			from += marker_len;
			marker_len = 0;
		}
		res = mtd->read(mtd, from, len, &retlen, buf);
57e1625c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
57e16260:	e28d3034 	add	r3, sp, #52	; 0x34
57e16264:	e58d3004 	str	r3, [sp, #4]
57e16268:	e58d2008 	str	r2, [sp, #8]
57e1626c:	e58d5000 	str	r5, [sp]
57e16270:	e5941040 	ldr	r1, [r4, #64]	; 0x40
57e16274:	e1a00004 	mov	r0, r4
57e16278:	e28d3010 	add	r3, sp, #16
57e1627c:	e893000c 	ldm	r3, {r2, r3}
57e16280:	e12fff31 	blx	r1
		if (res < 0) {
57e16284:	e250a000 	subs	sl, r0, #0
57e16288:	aa000007 	bge	57e162ac <read_bbt+0x110>
			if (retlen != len) {
57e1628c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e16290:	e1530005 	cmp	r3, r5
57e16294:	0a000002 	beq	57e162a4 <read_bbt+0x108>
				printk(KERN_INFO "nand_bbt: Error reading bad block table\n");
57e16298:	e59f0150 	ldr	r0, [pc, #336]	; 57e163f0 <read_bbt+0x254>
57e1629c:	ebffcc6a 	bl	57e0944c <printf>
				return res;
57e162a0:	ea00004f 	b	57e163e4 <read_bbt+0x248>
			}
			printk(KERN_WARNING "nand_bbt: ECC error while reading bad block table\n");
57e162a4:	e59f0148 	ldr	r0, [pc, #328]	; 57e163f4 <read_bbt+0x258>
57e162a8:	ebffcc67 	bl	57e0944c <printf>
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
			uint8_t dat = buf[i];
			for (j = 0; j < 8; j += bits, act += 2) {
57e162ac:	e3a0b000 	mov	fp, #0
57e162b0:	e1a0a005 	mov	sl, r5
57e162b4:	ea00003c 	b	57e163ac <read_bbt+0x210>
			printk(KERN_WARNING "nand_bbt: ECC error while reading bad block table\n");
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
			uint8_t dat = buf[i];
57e162b8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
			for (j = 0; j < 8; j += bits, act += 2) {
57e162bc:	e3a05000 	mov	r5, #0
			printk(KERN_WARNING "nand_bbt: ECC error while reading bad block table\n");
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
			uint8_t dat = buf[i];
57e162c0:	e7d3c00b 	ldrb	ip, [r3, fp]
			for (j = 0; j < 8; j += bits, act += 2) {
57e162c4:	e58db02c 	str	fp, [sp, #44]	; 0x2c
57e162c8:	e1a0b00a 	mov	fp, sl
57e162cc:	e1a0a00c 	mov	sl, ip
				uint8_t tmp = (dat >> j) & msk;
57e162d0:	e59dc01c 	ldr	ip, [sp, #28]
57e162d4:	e00c355a 	and	r3, ip, sl, asr r5
				if (tmp == msk)
57e162d8:	e153000c 	cmp	r3, ip
57e162dc:	0a00002a 	beq	57e1638c <read_bbt+0x1f0>
					continue;
				if (reserved_block_code && (tmp == reserved_block_code)) {
57e162e0:	e59d1020 	ldr	r1, [sp, #32]
57e162e4:	e3510000 	cmp	r1, #0
57e162e8:	0a000016 	beq	57e16348 <read_bbt+0x1ac>
57e162ec:	e1530001 	cmp	r3, r1
57e162f0:	1a000014 	bne	57e16348 <read_bbt+0x1ac>
					printk(KERN_DEBUG "nand_read_bbt: Reserved block at 0x%012llx\n",
					       (loff_t)((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
57e162f4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
57e162f8:	e08200c7 	add	r0, r2, r7, asr #1
			for (j = 0; j < 8; j += bits, act += 2) {
				uint8_t tmp = (dat >> j) & msk;
				if (tmp == msk)
					continue;
				if (reserved_block_code && (tmp == reserved_block_code)) {
					printk(KERN_DEBUG "nand_read_bbt: Reserved block at 0x%012llx\n",
57e162fc:	e1a01fc0 	asr	r1, r0, #31
57e16300:	e596205c 	ldr	r2, [r6, #92]	; 0x5c
57e16304:	eb00564a 	bl	57e2bc34 <__ashldi3>
57e16308:	e1a02000 	mov	r2, r0
57e1630c:	e1a03001 	mov	r3, r1
57e16310:	e59f00e0 	ldr	r0, [pc, #224]	; 57e163f8 <read_bbt+0x25c>
57e16314:	ebffcc4c 	bl	57e0944c <printf>
					       (loff_t)((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
					this->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);
57e16318:	e59dc05c 	ldr	ip, [sp, #92]	; 0x5c
57e1631c:	e5960110 	ldr	r0, [r6, #272]	; 0x110
57e16320:	e08c31c7 	add	r3, ip, r7, asr #3
57e16324:	e7d02003 	ldrb	r2, [r0, r3]
57e16328:	e2071006 	and	r1, r7, #6
57e1632c:	e3a0c002 	mov	ip, #2
57e16330:	e182211c 	orr	r2, r2, ip, lsl r1
57e16334:	e7c02003 	strb	r2, [r0, r3]
					mtd->ecc_stats.bbtblocks++;
57e16338:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
57e1633c:	e2833001 	add	r3, r3, #1
57e16340:	e584308c 	str	r3, [r4, #140]	; 0x8c
					continue;
57e16344:	ea000010 	b	57e1638c <read_bbt+0x1f0>
				MTDDEBUG(MTD_DEBUG_LEVEL0, "nand_read_bbt: " \
					"Bad block at 0x%012llx\n",
					(loff_t)((offs << 2) + (act >> 1))
					<< this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
57e16348:	e3530000 	cmp	r3, #0
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
57e1634c:	059d105c 	ldreq	r1, [sp, #92]	; 0x5c
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
57e16350:	159d105c 	ldrne	r1, [sp, #92]	; 0x5c
57e16354:	e1a021c7 	asr	r2, r7, #3
57e16358:	e5963110 	ldr	r3, [r6, #272]	; 0x110
					"Bad block at 0x%012llx\n",
					(loff_t)((offs << 2) + (act >> 1))
					<< this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
57e1635c:	00822001 	addeq	r2, r2, r1
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
57e16360:	10822001 	addne	r2, r2, r1
					"Bad block at 0x%012llx\n",
					(loff_t)((offs << 2) + (act >> 1))
					<< this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
57e16364:	07d31002 	ldrbeq	r1, [r3, r2]
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
57e16368:	17d31002 	ldrbne	r1, [r3, r2]
57e1636c:	e2070006 	and	r0, r7, #6
					"Bad block at 0x%012llx\n",
					(loff_t)((offs << 2) + (act >> 1))
					<< this->bbt_erase_shift);
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
57e16370:	03a0c003 	moveq	ip, #3
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
57e16374:	13a0c001 	movne	ip, #1
57e16378:	e181101c 	orr	r1, r1, ip, lsl r0
57e1637c:	e7c31002 	strb	r1, [r3, r2]
				mtd->ecc_stats.badblocks++;
57e16380:	e5943088 	ldr	r3, [r4, #136]	; 0x88
57e16384:	e2833001 	add	r3, r3, #1
57e16388:	e5843088 	str	r3, [r4, #136]	; 0x88
 * @offs:	offset in the memory table
 *
 * Read the bad block table starting from page.
 *
 */
static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
57e1638c:	e59d1018 	ldr	r1, [sp, #24]
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
			uint8_t dat = buf[i];
			for (j = 0; j < 8; j += bits, act += 2) {
57e16390:	e2877002 	add	r7, r7, #2
 * @offs:	offset in the memory table
 *
 * Read the bad block table starting from page.
 *
 */
static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
57e16394:	e0855001 	add	r5, r5, r1
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
			uint8_t dat = buf[i];
			for (j = 0; j < 8; j += bits, act += 2) {
57e16398:	e3550007 	cmp	r5, #7
57e1639c:	daffffcb 	ble	57e162d0 <read_bbt+0x134>
57e163a0:	e1a0a00b 	mov	sl, fp
57e163a4:	e59db02c 	ldr	fp, [sp, #44]	; 0x2c
			}
			printk(KERN_WARNING "nand_bbt: ECC error while reading bad block table\n");
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
57e163a8:	e28bb001 	add	fp, fp, #1
57e163ac:	e15b000a 	cmp	fp, sl
57e163b0:	3affffc0 	bcc	57e162b8 <read_bbt+0x11c>
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
				mtd->ecc_stats.badblocks++;
			}
		}
		totlen -= len;
		from += len;
57e163b4:	e28d3010 	add	r3, sp, #16
57e163b8:	e893000c 	ldm	r3, {r2, r3}
57e163bc:	e092200a 	adds	r2, r2, sl
57e163c0:	e2a33000 	adc	r3, r3, #0
57e163c4:	e58d2010 	str	r2, [sp, #16]
57e163c8:	e58d3014 	str	r3, [sp, #20]
57e163cc:	e1a0500a 	mov	r5, sl
				else
					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
				mtd->ecc_stats.badblocks++;
			}
		}
		totlen -= len;
57e163d0:	e06a9009 	rsb	r9, sl, r9
		from += len;
57e163d4:	e3a0a000 	mov	sl, #0

	totlen = (num * bits) >> 3;
	marker_len = add_marker_len(td);
	from = ((loff_t) page) << this->page_shift;

	while (totlen) {
57e163d8:	e3590000 	cmp	r9, #0
57e163dc:	1affff90 	bne	57e16224 <read_bbt+0x88>
			}
		}
		totlen -= len;
		from += len;
	}
	return 0;
57e163e0:	e1a0a009 	mov	sl, r9
}
57e163e4:	e1a0000a 	mov	r0, sl
57e163e8:	e28dd038 	add	sp, sp, #56	; 0x38
57e163ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e163f0:	57e3388c 	.word	0x57e3388c
57e163f4:	57e338b5 	.word	0x57e338b5
57e163f8:	57e338e8 	.word	0x57e338e8

57e163fc <read_abs_bbt>:
 *
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
{
57e163fc:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
	int res = 0, i;

	if (td->options & NAND_BBT_PERCHIP) {
57e16400:	e5926000 	ldr	r6, [r2]
 *
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
{
57e16404:	e1a0a000 	mov	sl, r0
	struct nand_chip *this = mtd->priv;
	int res = 0, i;

	if (td->options & NAND_BBT_PERCHIP) {
57e16408:	e2166080 	ands	r6, r6, #128	; 0x80
57e1640c:	13a07000 	movne	r7, #0
 *
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
{
57e16410:	e1a0b001 	mov	fp, r1
57e16414:	e1a05002 	mov	r5, r2
57e16418:	e1a09003 	mov	r9, r3
	struct nand_chip *this = mtd->priv;
57e1641c:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int res = 0, i;

	if (td->options & NAND_BBT_PERCHIP) {
57e16420:	11a06007 	movne	r6, r7
57e16424:	1a000019 	bne	57e16490 <read_abs_bbt+0x94>
57e16428:	ea00001d 	b	57e164a4 <read_abs_bbt+0xa8>
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
			if (chip == -1 || chip == i)
57e1642c:	e3790001 	cmn	r9, #1
57e16430:	11590006 	cmpne	r9, r6
57e16434:	1a00000e 	bne	57e16474 <read_abs_bbt+0x78>
				res = read_bbt(mtd, buf, td->pages[i],
					this->chipsize >> this->bbt_erase_shift,
57e16438:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
57e1643c:	e2841068 	add	r1, r4, #104	; 0x68
57e16440:	e8910003 	ldm	r1, {r0, r1}
 *		Applies only if NAND_BBT_PERCHIP option is set
 *
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
57e16444:	e085c106 	add	ip, r5, r6, lsl #2
	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
			if (chip == -1 || chip == i)
				res = read_bbt(mtd, buf, td->pages[i],
					this->chipsize >> this->bbt_erase_shift,
57e16448:	e58dc00c 	str	ip, [sp, #12]
57e1644c:	eb0055ea 	bl	57e2bbfc <__lshrdi3>

	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
			if (chip == -1 || chip == i)
				res = read_bbt(mtd, buf, td->pages[i],
57e16450:	e59dc00c 	ldr	ip, [sp, #12]
57e16454:	e88d00a0 	stm	sp, {r5, r7}
					this->chipsize >> this->bbt_erase_shift,
57e16458:	e1a03000 	mov	r3, r0

	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
			if (chip == -1 || chip == i)
				res = read_bbt(mtd, buf, td->pages[i],
57e1645c:	e1a0100b 	mov	r1, fp
57e16460:	e1a0000a 	mov	r0, sl
57e16464:	e59c2004 	ldr	r2, [ip, #4]
57e16468:	ebffff4b 	bl	57e1619c <read_bbt>
					this->chipsize >> this->bbt_erase_shift,
					td, offs);
			if (res)
57e1646c:	e3500000 	cmp	r0, #0
57e16470:	1a000015 	bne	57e164cc <read_abs_bbt+0xd0>
				return res;
			offs += this->chipsize >> (this->bbt_erase_shift + 2);
57e16474:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
57e16478:	e2841068 	add	r1, r4, #104	; 0x68
57e1647c:	e8910003 	ldm	r1, {r0, r1}
57e16480:	e2822002 	add	r2, r2, #2
57e16484:	eb0055dc 	bl	57e2bbfc <__lshrdi3>
	struct nand_chip *this = mtd->priv;
	int res = 0, i;

	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
57e16488:	e2866001 	add	r6, r6, #1
				res = read_bbt(mtd, buf, td->pages[i],
					this->chipsize >> this->bbt_erase_shift,
					td, offs);
			if (res)
				return res;
			offs += this->chipsize >> (this->bbt_erase_shift + 2);
57e1648c:	e0877000 	add	r7, r7, r0
	struct nand_chip *this = mtd->priv;
	int res = 0, i;

	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < this->numchips; i++) {
57e16490:	e5943064 	ldr	r3, [r4, #100]	; 0x64
57e16494:	e1560003 	cmp	r6, r3
57e16498:	baffffe3 	blt	57e1642c <read_abs_bbt+0x30>
		res = read_bbt(mtd, buf, td->pages[0],
				mtd->size >> this->bbt_erase_shift, td, 0);
		if (res)
			return res;
	}
	return 0;
57e1649c:	e3a00000 	mov	r0, #0
57e164a0:	ea000009 	b	57e164cc <read_abs_bbt+0xd0>
				return res;
			offs += this->chipsize >> (this->bbt_erase_shift + 2);
		}
	} else {
		res = read_bbt(mtd, buf, td->pages[0],
				mtd->size >> this->bbt_erase_shift, td, 0);
57e164a4:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
57e164a8:	e2801008 	add	r1, r0, #8
57e164ac:	e8910003 	ldm	r1, {r0, r1}
57e164b0:	eb0055d1 	bl	57e2bbfc <__lshrdi3>
			if (res)
				return res;
			offs += this->chipsize >> (this->bbt_erase_shift + 2);
		}
	} else {
		res = read_bbt(mtd, buf, td->pages[0],
57e164b4:	e1a0100b 	mov	r1, fp
				mtd->size >> this->bbt_erase_shift, td, 0);
57e164b8:	e1a03000 	mov	r3, r0
			if (res)
				return res;
			offs += this->chipsize >> (this->bbt_erase_shift + 2);
		}
	} else {
		res = read_bbt(mtd, buf, td->pages[0],
57e164bc:	e5952004 	ldr	r2, [r5, #4]
57e164c0:	e1a0000a 	mov	r0, sl
57e164c4:	e88d0060 	stm	sp, {r5, r6}
57e164c8:	ebffff33 	bl	57e1619c <read_bbt>
				mtd->size >> this->bbt_erase_shift, td, 0);
		if (res)
			return res;
	}
	return 0;
}
57e164cc:	e28dd010 	add	sp, sp, #16
57e164d0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e164d4 <write_bbt>:
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
		     int chipsel)
{
57e164d4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e164d8:	e1a04000 	mov	r4, r0
57e164dc:	e24ddc01 	sub	sp, sp, #256	; 0x100
57e164e0:	e58d3064 	str	r3, [sp, #100]	; 0x64
	uint8_t rcode = td->reserved_block_code;
	size_t retlen, len = 0;
	loff_t to;
	struct mtd_oob_ops ops;

	ops.ooblen = mtd->oobsize;
57e164e4:	e5943018 	ldr	r3, [r4, #24]
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
		     int chipsel)
{
	struct nand_chip *this = mtd->priv;
57e164e8:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	struct erase_info einfo;
	int i, j, res, chip = 0;
	int bits, startblock, dir, page, offs, numblocks, sft, sftmsk;
	int nrchips, bbtoffs, pageoffs, ooboffs;
	uint8_t msk[4];
	uint8_t rcode = td->reserved_block_code;
57e164ec:	e5d2001c 	ldrb	r0, [r2, #28]
	size_t retlen, len = 0;
	loff_t to;
	struct mtd_oob_ops ops;

	ops.ooblen = mtd->oobsize;
	ops.ooboffs = 0;
57e164f0:	e3a0a000 	mov	sl, #0
	uint8_t rcode = td->reserved_block_code;
	size_t retlen, len = 0;
	loff_t to;
	struct mtd_oob_ops ops;

	ops.ooblen = mtd->oobsize;
57e164f4:	e58d30e4 	str	r3, [sp, #228]	; 0xe4
	ops.mode = MTD_OOB_PLACE;

	if (!rcode)
		rcode = 0xff;
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e164f8:	e5923000 	ldr	r3, [r2]
	ops.ooboffs = 0;
	ops.datbuf = NULL;
	ops.mode = MTD_OOB_PLACE;

	if (!rcode)
		rcode = 0xff;
57e164fc:	e150000a 	cmp	r0, sl
57e16500:	03a000ff 	moveq	r0, #255	; 0xff
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e16504:	e2133080 	ands	r3, r3, #128	; 0x80
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
		     int chipsel)
{
57e16508:	e1a07001 	mov	r7, r1
57e1650c:	e1a05002 	mov	r5, r2
57e16510:	e59db120 	ldr	fp, [sp, #288]	; 0x120
	size_t retlen, len = 0;
	loff_t to;
	struct mtd_oob_ops ops;

	ops.ooblen = mtd->oobsize;
	ops.ooboffs = 0;
57e16514:	e58da0ec 	str	sl, [sp, #236]	; 0xec
	ops.datbuf = NULL;
57e16518:	e58da0f0 	str	sl, [sp, #240]	; 0xf0
	ops.mode = MTD_OOB_PLACE;
57e1651c:	e58da0d8 	str	sl, [sp, #216]	; 0xd8

	if (!rcode)
		rcode = 0xff;
57e16520:	e58d0040 	str	r0, [sp, #64]	; 0x40
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e16524:	0a000020 	beq	57e165ac <write_bbt+0xd8>
		numblocks = (int)(this->chipsize >> this->bbt_erase_shift);
57e16528:	e2861068 	add	r1, r6, #104	; 0x68
57e1652c:	e8910003 	ldm	r1, {r0, r1}
57e16530:	e596205c 	ldr	r2, [r6, #92]	; 0x5c
57e16534:	eb0055b0 	bl	57e2bbfc <__lshrdi3>
		/* Full device write or specific chip ? */
		if (chipsel == -1) {
57e16538:	e37b0001 	cmn	fp, #1
			nrchips = this->numchips;
57e1653c:	05961064 	ldreq	r1, [r6, #100]	; 0x64
		} else {
			nrchips = chipsel + 1;
57e16540:	128b1001 	addne	r1, fp, #1

	if (!rcode)
		rcode = 0xff;
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
		numblocks = (int)(this->chipsize >> this->bbt_erase_shift);
57e16544:	e1a09000 	mov	r9, r0
		/* Full device write or specific chip ? */
		if (chipsel == -1) {
			nrchips = this->numchips;
		} else {
			nrchips = chipsel + 1;
57e16548:	158d104c 	strne	r1, [sp, #76]	; 0x4c
57e1654c:	11a0a00b 	movne	sl, fp
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
		numblocks = (int)(this->chipsize >> this->bbt_erase_shift);
		/* Full device write or specific chip ? */
		if (chipsel == -1) {
			nrchips = this->numchips;
57e16550:	058d104c 	streq	r1, [sp, #76]	; 0x4c
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
57e16554:	e59dc064 	ldr	ip, [sp, #100]	; 0x64
			msk[3] = 0xff;
			break;
		default: return -EINVAL;
		}

		bbtoffs = chip * (numblocks >> 2);
57e16558:	e1a02149 	asr	r2, r9, #2
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
57e1655c:	e1a0310a 	lsl	r3, sl, #2
			msk[3] = 0xff;
			break;
		default: return -EINVAL;
		}

		bbtoffs = chip * (numblocks >> 2);
57e16560:	e58d2060 	str	r2, [sp, #96]	; 0x60
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
57e16564:	e0852003 	add	r2, r5, r3
57e16568:	e08c3003 	add	r3, ip, r3
57e1656c:	e2833004 	add	r3, r3, #4
57e16570:	e59db060 	ldr	fp, [sp, #96]	; 0x60
57e16574:	e58d3054 	str	r3, [sp, #84]	; 0x54
57e16578:	e28a3001 	add	r3, sl, #1
57e1657c:	e0030399 	mul	r3, r9, r3
57e16580:	e00b0b9a 	mul	fp, sl, fp
57e16584:	e0000a99 	mul	r0, r9, sl
57e16588:	e2822004 	add	r2, r2, #4
57e1658c:	e2433001 	sub	r3, r3, #1
57e16590:	e58d2044 	str	r2, [sp, #68]	; 0x44
57e16594:	e58db050 	str	fp, [sp, #80]	; 0x50
57e16598:	e58d3058 	str	r3, [sp, #88]	; 0x58
57e1659c:	e58d005c 	str	r0, [sp, #92]	; 0x5c
57e165a0:	e58da03c 	str	sl, [sp, #60]	; 0x3c
57e165a4:	e58d9068 	str	r9, [sp, #104]	; 0x68
57e165a8:	ea000172 	b	57e16b78 <write_bbt+0x6a4>
		} else {
			nrchips = chipsel + 1;
			chip = chipsel;
		}
	} else {
		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
57e165ac:	e596205c 	ldr	r2, [r6, #92]	; 0x5c
57e165b0:	e2841008 	add	r1, r4, #8
57e165b4:	e8910003 	ldm	r1, {r0, r1}
57e165b8:	e58d3020 	str	r3, [sp, #32]
57e165bc:	eb00558e 	bl	57e2bbfc <__lshrdi3>
		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
		     int chipsel)
{
	struct nand_chip *this = mtd->priv;
	struct erase_info einfo;
	int i, j, res, chip = 0;
57e165c0:	e59d3020 	ldr	r3, [sp, #32]
			nrchips = chipsel + 1;
			chip = chipsel;
		}
	} else {
		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
57e165c4:	e3a02001 	mov	r2, #1
		} else {
			nrchips = chipsel + 1;
			chip = chipsel;
		}
	} else {
		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
57e165c8:	e1a09000 	mov	r9, r0
		nrchips = 1;
57e165cc:	e58d204c 	str	r2, [sp, #76]	; 0x4c
		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
		     int chipsel)
{
	struct nand_chip *this = mtd->priv;
	struct erase_info einfo;
	int i, j, res, chip = 0;
57e165d0:	e1a0a003 	mov	sl, r3
57e165d4:	eaffffde 	b	57e16554 <write_bbt+0x80>

		/* There was already a version of the table, reuse the page
		 * This applies for absolute placement too, as we have the
		 * page nr. in td->pages.
		 */
		if (td->pages[chip] != -1) {
57e165d8:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
57e165dc:	e5933000 	ldr	r3, [r3]
57e165e0:	e3730001 	cmn	r3, #1
57e165e4:	e58d3034 	str	r3, [sp, #52]	; 0x34
57e165e8:	1a000028 	bne	57e16690 <write_bbt+0x1bc>
			goto write;
		}

		/* Automatic placement of the bad block table */
		/* Search direction top -> down ? */
		if (td->options & NAND_BBT_LASTBLOCK) {
57e165ec:	e5953000 	ldr	r3, [r5]
		} else {
			startblock = chip * numblocks;
			dir = 1;
		}

		for (i = 0; i < td->maxblocks; i++) {
57e165f0:	e595a018 	ldr	sl, [r5, #24]
			goto write;
		}

		/* Automatic placement of the bad block table */
		/* Search direction top -> down ? */
		if (td->options & NAND_BBT_LASTBLOCK) {
57e165f4:	e3130010 	tst	r3, #16
57e165f8:	159d3058 	ldrne	r3, [sp, #88]	; 0x58
			startblock = numblocks * (chip + 1) - 1;
			dir = -1;
57e165fc:	159d1034 	ldrne	r1, [sp, #52]	; 0x34
			goto write;
		}

		/* Automatic placement of the bad block table */
		/* Search direction top -> down ? */
		if (td->options & NAND_BBT_LASTBLOCK) {
57e16600:	059d305c 	ldreq	r3, [sp, #92]	; 0x5c
			startblock = numblocks * (chip + 1) - 1;
			dir = -1;
		} else {
			startblock = chip * numblocks;
			dir = 1;
57e16604:	03a01001 	moveq	r1, #1
		}

		for (i = 0; i < td->maxblocks; i++) {
57e16608:	e3a02000 	mov	r2, #0
57e1660c:	e59db068 	ldr	fp, [sp, #104]	; 0x68
57e16610:	e59d9054 	ldr	r9, [sp, #84]	; 0x54
57e16614:	ea000015 	b	57e16670 <write_bbt+0x19c>
			int block = startblock + dir * i;
			/* Check, if the block is bad */
			switch ((this->bbt[block >> 2] >>
57e16618:	e5960110 	ldr	r0, [r6, #272]	; 0x110
57e1661c:	e7d0c143 	ldrb	ip, [r0, r3, asr #2]
				 (2 * (block & 0x03))) & 0x03) {
57e16620:	e2030003 	and	r0, r3, #3
57e16624:	e1a00080 	lsl	r0, r0, #1
		}

		for (i = 0; i < td->maxblocks; i++) {
			int block = startblock + dir * i;
			/* Check, if the block is bad */
			switch ((this->bbt[block >> 2] >>
57e16628:	e1a0005c 	asr	r0, ip, r0
				 (2 * (block & 0x03))) & 0x03) {
57e1662c:	e2000003 	and	r0, r0, #3
		}

		for (i = 0; i < td->maxblocks; i++) {
			int block = startblock + dir * i;
			/* Check, if the block is bad */
			switch ((this->bbt[block >> 2] >>
57e16630:	e3500001 	cmp	r0, #1
57e16634:	0a00000b 	beq	57e16668 <write_bbt+0x194>
57e16638:	e3500003 	cmp	r0, #3
57e1663c:	0a000009 	beq	57e16668 <write_bbt+0x194>
			case 0x01:
			case 0x03:
				continue;
			}
			page = block <<
				(this->bbt_erase_shift - this->page_shift);
57e16640:	e596c05c 	ldr	ip, [r6, #92]	; 0x5c
57e16644:	e5960054 	ldr	r0, [r6, #84]	; 0x54
57e16648:	e060000c 	rsb	r0, r0, ip
				 (2 * (block & 0x03))) & 0x03) {
			case 0x01:
			case 0x03:
				continue;
			}
			page = block <<
57e1664c:	e1a0c013 	lsl	ip, r3, r0
				(this->bbt_erase_shift - this->page_shift);
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip] != page)
57e16650:	e59d0064 	ldr	r0, [sp, #100]	; 0x64
57e16654:	e3500000 	cmp	r0, #0
57e16658:	0a00000a 	beq	57e16688 <write_bbt+0x1b4>
57e1665c:	e5990000 	ldr	r0, [r9]
57e16660:	e150000c 	cmp	r0, ip
57e16664:	1a000007 	bne	57e16688 <write_bbt+0x1b4>
		} else {
			startblock = chip * numblocks;
			dir = 1;
		}

		for (i = 0; i < td->maxblocks; i++) {
57e16668:	e2822001 	add	r2, r2, #1
57e1666c:	e0833001 	add	r3, r3, r1
57e16670:	e152000a 	cmp	r2, sl
57e16674:	baffffe7 	blt	57e16618 <write_bbt+0x144>
				(this->bbt_erase_shift - this->page_shift);
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip] != page)
				goto write;
		}
		printk(KERN_ERR "No space left to write bad block table\n");
57e16678:	e59f0534 	ldr	r0, [pc, #1332]	; 57e16bb4 <write_bbt+0x6e0>
57e1667c:	ebffcb72 	bl	57e0944c <printf>
		return -ENOSPC;
57e16680:	e3e0b01b 	mvn	fp, #27
57e16684:	ea000147 	b	57e16ba8 <write_bbt+0x6d4>
57e16688:	e58dc034 	str	ip, [sp, #52]	; 0x34
57e1668c:	e58db068 	str	fp, [sp, #104]	; 0x68
	write:

		/* Set up shift count and masks for the flash table */
		bits = td->options & NAND_BBT_NRBITS_MSK;
		msk[2] = ~rcode;
57e16690:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
		printk(KERN_ERR "No space left to write bad block table\n");
		return -ENOSPC;
	write:

		/* Set up shift count and masks for the flash table */
		bits = td->options & NAND_BBT_NRBITS_MSK;
57e16694:	e5959000 	ldr	r9, [r5]
		msk[2] = ~rcode;
57e16698:	e1e03001 	mvn	r3, r1
57e1669c:	e5cd30fe 	strb	r3, [sp, #254]	; 0xfe
		printk(KERN_ERR "No space left to write bad block table\n");
		return -ENOSPC;
	write:

		/* Set up shift count and masks for the flash table */
		bits = td->options & NAND_BBT_NRBITS_MSK;
57e166a0:	e209300f 	and	r3, r9, #15
		msk[2] = ~rcode;
		switch (bits) {
57e166a4:	e2433001 	sub	r3, r3, #1
57e166a8:	e3530007 	cmp	r3, #7
57e166ac:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e166b0:	ea00013b 	b	57e16ba4 <write_bbt+0x6d0>
57e166b4:	57e166d4 	.word	0x57e166d4
57e166b8:	57e166fc 	.word	0x57e166fc
57e166bc:	57e16ba4 	.word	0x57e16ba4
57e166c0:	57e16728 	.word	0x57e16728
57e166c4:	57e16ba4 	.word	0x57e16ba4
57e166c8:	57e16ba4 	.word	0x57e16ba4
57e166cc:	57e16ba4 	.word	0x57e16ba4
57e166d0:	57e16754 	.word	0x57e16754
		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;
57e166d4:	e3a03001 	mov	r3, #1
57e166d8:	e3a02000 	mov	r2, #0
57e166dc:	e3a0a007 	mov	sl, #7
57e166e0:	e3a0b003 	mov	fp, #3
57e166e4:	e5cd20fc 	strb	r2, [sp, #252]	; 0xfc
57e166e8:	e5cd30fd 	strb	r3, [sp, #253]	; 0xfd
			msk[3] = 0x01;
57e166ec:	e5cd30ff 	strb	r3, [sp, #255]	; 0xff

		/* Set up shift count and masks for the flash table */
		bits = td->options & NAND_BBT_NRBITS_MSK;
		msk[2] = ~rcode;
		switch (bits) {
		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;
57e166f0:	e58da038 	str	sl, [sp, #56]	; 0x38
57e166f4:	e58db024 	str	fp, [sp, #36]	; 0x24
			msk[3] = 0x01;
			break;
57e166f8:	ea00001e 	b	57e16778 <write_bbt+0x2a4>
		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
57e166fc:	e3a0c000 	mov	ip, #0
57e16700:	e3a0e001 	mov	lr, #1
			msk[3] = 0x03;
57e16704:	e3a03003 	mov	r3, #3
		msk[2] = ~rcode;
		switch (bits) {
		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;
			msk[3] = 0x01;
			break;
		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
57e16708:	e3a00006 	mov	r0, #6
57e1670c:	e3a01002 	mov	r1, #2
57e16710:	e5cdc0fc 	strb	ip, [sp, #252]	; 0xfc
57e16714:	e5cde0fd 	strb	lr, [sp, #253]	; 0xfd
			msk[3] = 0x03;
57e16718:	e5cd30ff 	strb	r3, [sp, #255]	; 0xff
		msk[2] = ~rcode;
		switch (bits) {
		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;
			msk[3] = 0x01;
			break;
		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
57e1671c:	e58d0038 	str	r0, [sp, #56]	; 0x38
57e16720:	e58d1024 	str	r1, [sp, #36]	; 0x24
			msk[3] = 0x03;
			break;
57e16724:	ea000013 	b	57e16778 <write_bbt+0x2a4>
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
57e16728:	e3a0300c 	mov	r3, #12
57e1672c:	e5cd30fd 	strb	r3, [sp, #253]	; 0xfd
			msk[3] = 0x0f;
57e16730:	e2833003 	add	r3, r3, #3
			msk[3] = 0x01;
			break;
		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
			msk[3] = 0x03;
			break;
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
57e16734:	e3a02000 	mov	r2, #0
			msk[3] = 0x0f;
57e16738:	e5cd30ff 	strb	r3, [sp, #255]	; 0xff
			msk[3] = 0x01;
			break;
		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
			msk[3] = 0x03;
			break;
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
57e1673c:	e3a0a001 	mov	sl, #1
57e16740:	e3a03004 	mov	r3, #4
57e16744:	e5cd20fc 	strb	r2, [sp, #252]	; 0xfc
57e16748:	e58d3038 	str	r3, [sp, #56]	; 0x38
57e1674c:	e58da024 	str	sl, [sp, #36]	; 0x24
			msk[3] = 0x0f;
			break;
57e16750:	ea000008 	b	57e16778 <write_bbt+0x2a4>
		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;
57e16754:	e3a0300f 	mov	r3, #15
57e16758:	e3a0c000 	mov	ip, #0
57e1675c:	e3a0b000 	mov	fp, #0
57e16760:	e5cd30fd 	strb	r3, [sp, #253]	; 0xfd
			msk[3] = 0xff;
57e16764:	e3e03000 	mvn	r3, #0
			msk[3] = 0x03;
			break;
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
			msk[3] = 0x0f;
			break;
		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;
57e16768:	e5cdb0fc 	strb	fp, [sp, #252]	; 0xfc
			msk[3] = 0xff;
57e1676c:	e5cd30ff 	strb	r3, [sp, #255]	; 0xff
			msk[3] = 0x03;
			break;
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
			msk[3] = 0x0f;
			break;
		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;
57e16770:	e58dc038 	str	ip, [sp, #56]	; 0x38
57e16774:	e58dc024 	str	ip, [sp, #36]	; 0x24
		default: return -EINVAL;
		}

		bbtoffs = chip * (numblocks >> 2);

		to = ((loff_t) page) << this->page_shift;
57e16778:	e59de034 	ldr	lr, [sp, #52]	; 0x34
57e1677c:	e596a054 	ldr	sl, [r6, #84]	; 0x54
57e16780:	e1a0000e 	mov	r0, lr
57e16784:	e1a01fc0 	asr	r1, r0, #31
57e16788:	e1a0200a 	mov	r2, sl
57e1678c:	eb005528 	bl	57e2bc34 <__ashldi3>

		/* Must we save the block contents ? */
		if (td->options & NAND_BBT_SAVECONTENT) {
57e16790:	e3190a02 	tst	r9, #8192	; 0x2000
		default: return -EINVAL;
		}

		bbtoffs = chip * (numblocks >> 2);

		to = ((loff_t) page) << this->page_shift;
57e16794:	e1a02000 	mov	r2, r0
57e16798:	e1a03001 	mov	r3, r1
57e1679c:	e58d2028 	str	r2, [sp, #40]	; 0x28
57e167a0:	e58d302c 	str	r3, [sp, #44]	; 0x2c

		/* Must we save the block contents ? */
		if (td->options & NAND_BBT_SAVECONTENT) {
57e167a4:	0a00004c 	beq	57e168dc <write_bbt+0x408>
			/* Make it block aligned */
			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
57e167a8:	e596c05c 	ldr	ip, [r6, #92]	; 0x5c
57e167ac:	e3a00001 	mov	r0, #1
57e167b0:	e1a0cc10 	lsl	ip, r0, ip
57e167b4:	e24c1001 	sub	r1, ip, #1
57e167b8:	e1c29001 	bic	r9, r2, r1
57e167bc:	e1c3afc1 	bic	sl, r3, r1, asr #31
57e167c0:	e58d9028 	str	r9, [sp, #40]	; 0x28
57e167c4:	e58da02c 	str	sl, [sp, #44]	; 0x2c
			len = 1 << this->bbt_erase_shift;
			res = mtd->read(mtd, to, len, &retlen, buf);
57e167c8:	e28d3028 	add	r3, sp, #40	; 0x28
57e167cc:	e893000c 	ldm	r3, {r2, r3}
57e167d0:	e28da0f8 	add	sl, sp, #248	; 0xf8
57e167d4:	e58dc000 	str	ip, [sp]
57e167d8:	e58dc01c 	str	ip, [sp, #28]
57e167dc:	e58da004 	str	sl, [sp, #4]
57e167e0:	e58d7008 	str	r7, [sp, #8]
57e167e4:	e5941040 	ldr	r1, [r4, #64]	; 0x40
57e167e8:	e1a00004 	mov	r0, r4

		/* Must we save the block contents ? */
		if (td->options & NAND_BBT_SAVECONTENT) {
			/* Make it block aligned */
			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
			len = 1 << this->bbt_erase_shift;
57e167ec:	e1a0900c 	mov	r9, ip
			res = mtd->read(mtd, to, len, &retlen, buf);
57e167f0:	e12fff31 	blx	r1
			if (res < 0) {
57e167f4:	e3500000 	cmp	r0, #0
57e167f8:	e59dc01c 	ldr	ip, [sp, #28]
57e167fc:	aa00000a 	bge	57e1682c <write_bbt+0x358>
				if (retlen != len) {
57e16800:	e59d30f8 	ldr	r3, [sp, #248]	; 0xf8
57e16804:	e153000c 	cmp	r3, ip
57e16808:	0a000003 	beq	57e1681c <write_bbt+0x348>
57e1680c:	e1a0b000 	mov	fp, r0
					printk(KERN_INFO "nand_bbt: Error "
57e16810:	e59f03a0 	ldr	r0, [pc, #928]	; 57e16bb8 <write_bbt+0x6e4>
57e16814:	ebffcb0c 	bl	57e0944c <printf>
					       "reading block for writing "
					       "the bad block table\n");
					return res;
57e16818:	ea0000e2 	b	57e16ba8 <write_bbt+0x6d4>
				}
				printk(KERN_WARNING "nand_bbt: ECC error "
57e1681c:	e59f0398 	ldr	r0, [pc, #920]	; 57e16bbc <write_bbt+0x6e8>
57e16820:	e58dc01c 	str	ip, [sp, #28]
57e16824:	ebffcb08 	bl	57e0944c <printf>
57e16828:	e59dc01c 	ldr	ip, [sp, #28]
				       "while reading block for writing "
				       "bad block table\n");
			}
			/* Read oob data */
			ops.ooblen = (len >> this->page_shift) * mtd->oobsize;
57e1682c:	e5963054 	ldr	r3, [r6, #84]	; 0x54
57e16830:	e5942018 	ldr	r2, [r4, #24]
57e16834:	e1a0333c 	lsr	r3, ip, r3
57e16838:	e0030392 	mul	r3, r2, r3
			ops.oobbuf = &buf[len];
			res = mtd->read_oob(mtd, to + mtd->writesize, &ops);
57e1683c:	e5942014 	ldr	r2, [r4, #20]
57e16840:	e28db0d8 	add	fp, sp, #216	; 0xd8
57e16844:	e58db000 	str	fp, [sp]
57e16848:	e28db028 	add	fp, sp, #40	; 0x28
57e1684c:	e89b0c00 	ldm	fp, {sl, fp}
57e16850:	e09aa002 	adds	sl, sl, r2
57e16854:	e2abb000 	adc	fp, fp, #0
				printk(KERN_WARNING "nand_bbt: ECC error "
				       "while reading block for writing "
				       "bad block table\n");
			}
			/* Read oob data */
			ops.ooblen = (len >> this->page_shift) * mtd->oobsize;
57e16858:	e58d30e4 	str	r3, [sp, #228]	; 0xe4
			ops.oobbuf = &buf[len];
57e1685c:	e087300c 	add	r3, r7, ip
57e16860:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
			res = mtd->read_oob(mtd, to + mtd->writesize, &ops);
57e16864:	e594104c 	ldr	r1, [r4, #76]	; 0x4c
57e16868:	e1a00004 	mov	r0, r4
57e1686c:	e1a0200a 	mov	r2, sl
57e16870:	e1a0300b 	mov	r3, fp
57e16874:	e58dc01c 	str	ip, [sp, #28]
57e16878:	e12fff31 	blx	r1
			if (res < 0 || ops.oobretlen != ops.ooblen)
57e1687c:	e3500000 	cmp	r0, #0
57e16880:	ba0000c2 	blt	57e16b90 <write_bbt+0x6bc>
57e16884:	e59d20e4 	ldr	r2, [sp, #228]	; 0xe4
57e16888:	e59d30e8 	ldr	r3, [sp, #232]	; 0xe8
57e1688c:	e1530002 	cmp	r3, r2
57e16890:	1a0000be 	bne	57e16b90 <write_bbt+0x6bc>
				goto outerr;

			/* Calc the byte offset in the buffer */
			pageoffs = page - (int)(to >> this->page_shift);
57e16894:	e596a054 	ldr	sl, [r6, #84]	; 0x54
57e16898:	e28d1028 	add	r1, sp, #40	; 0x28
57e1689c:	e8910003 	ldm	r1, {r0, r1}
57e168a0:	e1a0200a 	mov	r2, sl
57e168a4:	eb0054db 	bl	57e2bc18 <__ashrdi3>
57e168a8:	e59de034 	ldr	lr, [sp, #52]	; 0x34
			offs = pageoffs << this->page_shift;
			/* Preset the bbt area with 0xff */
			memset(&buf[offs], 0xff, (size_t) (numblocks >> sft));
57e168ac:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
			res = mtd->read_oob(mtd, to + mtd->writesize, &ops);
			if (res < 0 || ops.oobretlen != ops.ooblen)
				goto outerr;

			/* Calc the byte offset in the buffer */
			pageoffs = page - (int)(to >> this->page_shift);
57e168b0:	e060b00e 	rsb	fp, r0, lr
			offs = pageoffs << this->page_shift;
57e168b4:	e1a0aa1b 	lsl	sl, fp, sl
			/* Preset the bbt area with 0xff */
			memset(&buf[offs], 0xff, (size_t) (numblocks >> sft));
57e168b8:	e59de024 	ldr	lr, [sp, #36]	; 0x24
57e168bc:	e087000a 	add	r0, r7, sl
57e168c0:	e1a02e53 	asr	r2, r3, lr
57e168c4:	e3a010ff 	mov	r1, #255	; 0xff
57e168c8:	eb00366b 	bl	57e2427c <memset>
			ooboffs = len + (pageoffs * mtd->oobsize);
57e168cc:	e5943018 	ldr	r3, [r4, #24]
57e168d0:	e59dc01c 	ldr	ip, [sp, #28]
57e168d4:	e02ccb93 	mla	ip, r3, fp, ip
57e168d8:	ea00002e 	b	57e16998 <write_bbt+0x4c4>

		} else if (td->options & NAND_BBT_NO_OOB) {
57e168dc:	e2193501 	ands	r3, r9, #4194304	; 0x400000
57e168e0:	0a000014 	beq	57e16938 <write_bbt+0x464>
				offs++;
			/* Calc length */
			len = (size_t) (numblocks >> sft);
			len += offs;
			/* Make it page aligned ! */
			len = ALIGN(len, mtd->writesize);
57e168e4:	e5943014 	ldr	r3, [r4, #20]
57e168e8:	e59d0068 	ldr	r0, [sp, #104]	; 0x68
57e168ec:	e59d1024 	ldr	r1, [sp, #36]	; 0x24

		} else if (td->options & NAND_BBT_NO_OOB) {
			ooboffs = 0;
			offs = td->len;
			/* the version byte */
			if (td->options & NAND_BBT_VERSION)
57e168f0:	e3190c01 	tst	r9, #256	; 0x100
				offs++;
			/* Calc length */
			len = (size_t) (numblocks >> sft);
			len += offs;
57e168f4:	e2439001 	sub	r9, r3, #1
			/* Make it page aligned ! */
			len = ALIGN(len, mtd->writesize);
57e168f8:	e0899150 	add	r9, r9, r0, asr r1
			memset(&buf[offs], 0xff, (size_t) (numblocks >> sft));
			ooboffs = len + (pageoffs * mtd->oobsize);

		} else if (td->options & NAND_BBT_NO_OOB) {
			ooboffs = 0;
			offs = td->len;
57e168fc:	e595a014 	ldr	sl, [r5, #20]
				offs++;
			/* Calc length */
			len = (size_t) (numblocks >> sft);
			len += offs;
			/* Make it page aligned ! */
			len = ALIGN(len, mtd->writesize);
57e16900:	e2633000 	rsb	r3, r3, #0
		} else if (td->options & NAND_BBT_NO_OOB) {
			ooboffs = 0;
			offs = td->len;
			/* the version byte */
			if (td->options & NAND_BBT_VERSION)
				offs++;
57e16904:	128aa001 	addne	sl, sl, #1
			/* Calc length */
			len = (size_t) (numblocks >> sft);
			len += offs;
			/* Make it page aligned ! */
			len = ALIGN(len, mtd->writesize);
57e16908:	e089900a 	add	r9, r9, sl
57e1690c:	e0099003 	and	r9, r9, r3
			/* Preset the buffer with 0xff */
			memset(buf, 0xff, len);
57e16910:	e3a010ff 	mov	r1, #255	; 0xff
57e16914:	e1a02009 	mov	r2, r9
57e16918:	e1a00007 	mov	r0, r7
57e1691c:	eb003656 	bl	57e2427c <memset>
			/* Pattern is located at the begin of first page */
			memcpy(buf, td->pattern, td->len);
57e16920:	e1a00007 	mov	r0, r7
57e16924:	e5951020 	ldr	r1, [r5, #32]
57e16928:	e5952014 	ldr	r2, [r5, #20]
57e1692c:	eb003676 	bl	57e2430c <memcpy>
			/* Preset the bbt area with 0xff */
			memset(&buf[offs], 0xff, (size_t) (numblocks >> sft));
			ooboffs = len + (pageoffs * mtd->oobsize);

		} else if (td->options & NAND_BBT_NO_OOB) {
			ooboffs = 0;
57e16930:	e3a0c000 	mov	ip, #0
57e16934:	ea000017 	b	57e16998 <write_bbt+0x4c4>
			memcpy(buf, td->pattern, td->len);
		} else {
			/* Calc length */
			len = (size_t) (numblocks >> sft);
			/* Make it page aligned ! */
			len = ALIGN(len, mtd->writesize);
57e16938:	e5942014 	ldr	r2, [r4, #20]
57e1693c:	e59d9068 	ldr	r9, [sp, #104]	; 0x68
57e16940:	e59db024 	ldr	fp, [sp, #36]	; 0x24
57e16944:	e2421001 	sub	r1, r2, #1
57e16948:	e0811b59 	add	r1, r1, r9, asr fp
57e1694c:	e2629000 	rsb	r9, r2, #0
57e16950:	e0019009 	and	r9, r1, r9
			/* Preset the buffer with 0xff */
			memset(buf, 0xff, len +
			       (len >> this->page_shift)* mtd->oobsize);
57e16954:	e1a0aa39 	lsr	sl, r9, sl
57e16958:	e5942018 	ldr	r2, [r4, #24]
			/* Calc length */
			len = (size_t) (numblocks >> sft);
			/* Make it page aligned ! */
			len = ALIGN(len, mtd->writesize);
			/* Preset the buffer with 0xff */
			memset(buf, 0xff, len +
57e1695c:	e3a010ff 	mov	r1, #255	; 0xff
57e16960:	e022929a 	mla	r2, sl, r2, r9
57e16964:	e1a00007 	mov	r0, r7
57e16968:	e58d3020 	str	r3, [sp, #32]
57e1696c:	eb003642 	bl	57e2427c <memset>
			       (len >> this->page_shift)* mtd->oobsize);
			offs = 0;
			ooboffs = len;
			/* Pattern is located in oob area of first page */
			memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);
57e16970:	e5950008 	ldr	r0, [r5, #8]
57e16974:	e5951020 	ldr	r1, [r5, #32]
57e16978:	e0890000 	add	r0, r9, r0
57e1697c:	e0870000 	add	r0, r7, r0
57e16980:	e5952014 	ldr	r2, [r5, #20]
57e16984:	e58d901c 	str	r9, [sp, #28]
57e16988:	eb00365f 	bl	57e2430c <memcpy>
			/* Make it page aligned ! */
			len = ALIGN(len, mtd->writesize);
			/* Preset the buffer with 0xff */
			memset(buf, 0xff, len +
			       (len >> this->page_shift)* mtd->oobsize);
			offs = 0;
57e1698c:	e59d3020 	ldr	r3, [sp, #32]
57e16990:	e59dc01c 	ldr	ip, [sp, #28]
57e16994:	e1a0a003 	mov	sl, r3
			ooboffs = len;
			/* Pattern is located in oob area of first page */
			memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);
		}

		if (td->options & NAND_BBT_VERSION)
57e16998:	e5953000 	ldr	r3, [r5]
57e1699c:	e3130c01 	tst	r3, #256	; 0x100
57e169a0:	0a000023 	beq	57e16a34 <write_bbt+0x560>
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
57e169a4:	e59de03c 	ldr	lr, [sp, #60]	; 0x3c
			/* Pattern is located in oob area of first page */
			memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);
		}

		if (td->options & NAND_BBT_VERSION)
			buf[ooboffs + td->veroffs] = td->version[chip];
57e169a8:	e595200c 	ldr	r2, [r5, #12]
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
57e169ac:	e085300e 	add	r3, r5, lr
			/* Pattern is located in oob area of first page */
			memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);
		}

		if (td->options & NAND_BBT_VERSION)
			buf[ooboffs + td->veroffs] = td->version[chip];
57e169b0:	e5d33010 	ldrb	r3, [r3, #16]
57e169b4:	e087c00c 	add	ip, r7, ip
57e169b8:	e7cc3002 	strb	r3, [ip, r2]
57e169bc:	ea00001c 	b	57e16a34 <write_bbt+0x560>

		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
57e169c0:	e5962110 	ldr	r2, [r6, #272]	; 0x110
57e169c4:	e59d0050 	ldr	r0, [sp, #80]	; 0x50
57e169c8:	e0822000 	add	r2, r2, r0
57e169cc:	e7d21143 	ldrb	r1, [r2, r3, asr #2]
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
57e169d0:	e2832004 	add	r2, r3, #4
57e169d4:	e58d2048 	str	r2, [sp, #72]	; 0x48
57e169d8:	e58d3014 	str	r3, [sp, #20]
57e169dc:	e1a02003 	mov	r2, r3
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &=
57e169e0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
					~(msk[dat & 0x03] << sftcnt);
57e169e4:	e201c003 	and	ip, r1, #3
57e169e8:	e28dec01 	add	lr, sp, #256	; 0x100
57e169ec:	e08ec00c 	add	ip, lr, ip
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &=
57e169f0:	e08a0352 	add	r0, sl, r2, asr r3
					~(msk[dat & 0x03] << sftcnt);
57e169f4:	e55ce004 	ldrb	lr, [ip, #-4]
		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
57e169f8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
57e169fc:	e59dc06c 	ldr	ip, [sp, #108]	; 0x6c
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &=
					~(msk[dat & 0x03] << sftcnt);
				dat >>= 2;
57e16a00:	e1a01121 	lsr	r1, r1, #2
		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
57e16a04:	e0033c12 	and	r3, r3, r2, lsl ip
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &=
57e16a08:	e7d7c000 	ldrb	ip, [r7, r0]

		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
57e16a0c:	e2822001 	add	r2, r2, #1
				int sftcnt = (i << (3 - sft)) & sftmsk;
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &=
57e16a10:	e1ccc31e 	bic	ip, ip, lr, lsl r3

		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
57e16a14:	e59de048 	ldr	lr, [sp, #72]	; 0x48
				int sftcnt = (i << (3 - sft)) & sftmsk;
57e16a18:	e58d3068 	str	r3, [sp, #104]	; 0x68

		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
57e16a1c:	e152000e 	cmp	r2, lr
				int sftcnt = (i << (3 - sft)) & sftmsk;
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &=
57e16a20:	e7c7c000 	strb	ip, [r7, r0]

		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
57e16a24:	1affffed 	bne	57e169e0 <write_bbt+0x50c>
57e16a28:	e59d3014 	ldr	r3, [sp, #20]
57e16a2c:	e2833004 	add	r3, r3, #4
57e16a30:	ea000004 	b	57e16a48 <write_bbt+0x574>
				int sftcnt = (i << (3 - sft)) & sftmsk;
57e16a34:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
57e16a38:	e59db068 	ldr	fp, [sp, #104]	; 0x68
57e16a3c:	e2600003 	rsb	r0, r0, #3
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
57e16a40:	e3a03000 	mov	r3, #0
		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			uint8_t dat;
			dat = this->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
57e16a44:	e58d006c 	str	r0, [sp, #108]	; 0x6c

		if (td->options & NAND_BBT_VERSION)
			buf[ooboffs + td->veroffs] = td->version[chip];

		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
57e16a48:	e153000b 	cmp	r3, fp
57e16a4c:	baffffdb 	blt	57e169c0 <write_bbt+0x4ec>
					~(msk[dat & 0x03] << sftcnt);
				dat >>= 2;
			}
		}

		memset(&einfo, 0, sizeof(einfo));
57e16a50:	e3a01000 	mov	r1, #0
57e16a54:	e3a02048 	mov	r2, #72	; 0x48
57e16a58:	e28d0070 	add	r0, sp, #112	; 0x70
57e16a5c:	e58db068 	str	fp, [sp, #104]	; 0x68
57e16a60:	eb003605 	bl	57e2427c <memset>
		einfo.mtd = mtd;
		einfo.addr = to;
		einfo.len = 1 << this->bbt_erase_shift;
57e16a64:	e596205c 	ldr	r2, [r6, #92]	; 0x5c
57e16a68:	e3a03001 	mov	r3, #1
57e16a6c:	e1a02213 	lsl	r2, r3, r2
			}
		}

		memset(&einfo, 0, sizeof(einfo));
		einfo.mtd = mtd;
		einfo.addr = to;
57e16a70:	e59da028 	ldr	sl, [sp, #40]	; 0x28
		einfo.len = 1 << this->bbt_erase_shift;
57e16a74:	e1a03fc2 	asr	r3, r2, #31
			}
		}

		memset(&einfo, 0, sizeof(einfo));
		einfo.mtd = mtd;
		einfo.addr = to;
57e16a78:	e59db02c 	ldr	fp, [sp, #44]	; 0x2c
		einfo.len = 1 << this->bbt_erase_shift;
57e16a7c:	e58d2080 	str	r2, [sp, #128]	; 0x80
57e16a80:	e58d3084 	str	r3, [sp, #132]	; 0x84
		res = nand_erase_nand(mtd, &einfo, 1);
57e16a84:	e1a00004 	mov	r0, r4
57e16a88:	e28d1070 	add	r1, sp, #112	; 0x70
57e16a8c:	e3a02001 	mov	r2, #1
				dat >>= 2;
			}
		}

		memset(&einfo, 0, sizeof(einfo));
		einfo.mtd = mtd;
57e16a90:	e58d4070 	str	r4, [sp, #112]	; 0x70
		einfo.addr = to;
57e16a94:	e58da078 	str	sl, [sp, #120]	; 0x78
57e16a98:	e58db07c 	str	fp, [sp, #124]	; 0x7c
		einfo.len = 1 << this->bbt_erase_shift;
		res = nand_erase_nand(mtd, &einfo, 1);
57e16a9c:	eb00121c 	bl	57e1b314 <nand_erase_nand>
		if (res < 0)
57e16aa0:	e3500000 	cmp	r0, #0
57e16aa4:	ba000039 	blt	57e16b90 <write_bbt+0x6bc>
			goto outerr;

		res = scan_write_bbt(mtd, to, len, buf,
				td->options & NAND_BBT_NO_OOB ? NULL :
57e16aa8:	e5953000 	ldr	r3, [r5]
{
	struct mtd_oob_ops ops;

	ops.mode = MTD_OOB_PLACE;
	ops.ooboffs = 0;
	ops.ooblen = mtd->oobsize;
57e16aac:	e5942018 	ldr	r2, [r4, #24]
		einfo.len = 1 << this->bbt_erase_shift;
		res = nand_erase_nand(mtd, &einfo, 1);
		if (res < 0)
			goto outerr;

		res = scan_write_bbt(mtd, to, len, buf,
57e16ab0:	e3130501 	tst	r3, #4194304	; 0x400000
57e16ab4:	00873009 	addeq	r3, r7, r9
57e16ab8:	13a03000 	movne	r3, #0
static int scan_write_bbt(struct mtd_info *mtd, loff_t offs, size_t len,
			  uint8_t *buf, uint8_t *oob)
{
	struct mtd_oob_ops ops;

	ops.mode = MTD_OOB_PLACE;
57e16abc:	e3a0c000 	mov	ip, #0
	ops.ooblen = mtd->oobsize;
	ops.datbuf = buf;
	ops.oobbuf = oob;
	ops.len = len;

	return mtd->write_oob(mtd, offs, &ops);
57e16ac0:	e28de0b8 	add	lr, sp, #184	; 0xb8
static int scan_write_bbt(struct mtd_info *mtd, loff_t offs, size_t len,
			  uint8_t *buf, uint8_t *oob)
{
	struct mtd_oob_ops ops;

	ops.mode = MTD_OOB_PLACE;
57e16ac4:	e58dc0b8 	str	ip, [sp, #184]	; 0xb8
	ops.ooboffs = 0;
57e16ac8:	e58dc0cc 	str	ip, [sp, #204]	; 0xcc
	ops.ooblen = mtd->oobsize;
57e16acc:	e58d20c4 	str	r2, [sp, #196]	; 0xc4
	ops.datbuf = buf;
	ops.oobbuf = oob;
57e16ad0:	e58d30d4 	str	r3, [sp, #212]	; 0xd4
	ops.len = len;
57e16ad4:	e58d90bc 	str	r9, [sp, #188]	; 0xbc

	return mtd->write_oob(mtd, offs, &ops);
57e16ad8:	e28d3028 	add	r3, sp, #40	; 0x28
57e16adc:	e893000c 	ldm	r3, {r2, r3}
57e16ae0:	e58de000 	str	lr, [sp]
57e16ae4:	e5941050 	ldr	r1, [r4, #80]	; 0x50
	struct mtd_oob_ops ops;

	ops.mode = MTD_OOB_PLACE;
	ops.ooboffs = 0;
	ops.ooblen = mtd->oobsize;
	ops.datbuf = buf;
57e16ae8:	e58d70d0 	str	r7, [sp, #208]	; 0xd0
	ops.oobbuf = oob;
	ops.len = len;

	return mtd->write_oob(mtd, offs, &ops);
57e16aec:	e1a00004 	mov	r0, r4
57e16af0:	e12fff31 	blx	r1
57e16af4:	e59d1044 	ldr	r1, [sp, #68]	; 0x44
57e16af8:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
57e16afc:	e2811004 	add	r1, r1, #4
57e16b00:	e59d9054 	ldr	r9, [sp, #84]	; 0x54
57e16b04:	e59dc058 	ldr	ip, [sp, #88]	; 0x58
57e16b08:	e59de068 	ldr	lr, [sp, #104]	; 0x68
57e16b0c:	e58d1044 	str	r1, [sp, #68]	; 0x44
57e16b10:	e59d3060 	ldr	r3, [sp, #96]	; 0x60
57e16b14:	e59d105c 	ldr	r1, [sp, #92]	; 0x5c
57e16b18:	e0822003 	add	r2, r2, r3
57e16b1c:	e2899004 	add	r9, r9, #4
57e16b20:	e08cc00e 	add	ip, ip, lr
57e16b24:	e081100e 	add	r1, r1, lr
			goto outerr;

		res = scan_write_bbt(mtd, to, len, buf,
				td->options & NAND_BBT_NO_OOB ? NULL :
				&buf[len]);
		if (res < 0)
57e16b28:	e3500000 	cmp	r0, #0
	ops.ooblen = mtd->oobsize;
	ops.datbuf = buf;
	ops.oobbuf = oob;
	ops.len = len;

	return mtd->write_oob(mtd, offs, &ops);
57e16b2c:	e58d2050 	str	r2, [sp, #80]	; 0x50
57e16b30:	e58d9054 	str	r9, [sp, #84]	; 0x54
57e16b34:	e58dc058 	str	ip, [sp, #88]	; 0x58
57e16b38:	e58d105c 	str	r1, [sp, #92]	; 0x5c
			goto outerr;

		res = scan_write_bbt(mtd, to, len, buf,
				td->options & NAND_BBT_NO_OOB ? NULL :
				&buf[len]);
		if (res < 0)
57e16b3c:	ba000013 	blt	57e16b90 <write_bbt+0x6bc>
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
57e16b40:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
				td->options & NAND_BBT_NO_OOB ? NULL :
				&buf[len]);
		if (res < 0)
			goto outerr;

		printk(KERN_DEBUG "Bad block table written to 0x%012llx, version "
57e16b44:	e59f0074 	ldr	r0, [pc, #116]	; 57e16bc0 <write_bbt+0x6ec>
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
57e16b48:	e0853002 	add	r3, r5, r2
				td->options & NAND_BBT_NO_OOB ? NULL :
				&buf[len]);
		if (res < 0)
			goto outerr;

		printk(KERN_DEBUG "Bad block table written to 0x%012llx, version "
57e16b4c:	e5d33010 	ldrb	r3, [r3, #16]
57e16b50:	e1a0200a 	mov	r2, sl
57e16b54:	e58d3000 	str	r3, [sp]
57e16b58:	e1a0300b 	mov	r3, fp
57e16b5c:	ebffca3a 	bl	57e0944c <printf>
		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
57e16b60:	e59da03c 	ldr	sl, [sp, #60]	; 0x3c

		printk(KERN_DEBUG "Bad block table written to 0x%012llx, version "
		       "0x%02X\n", (unsigned long long)to, td->version[chip]);

		/* Mark it as used */
		td->pages[chip] = page;
57e16b64:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
57e16b68:	e59d9044 	ldr	r9, [sp, #68]	; 0x44
		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
57e16b6c:	e28aa001 	add	sl, sl, #1

		printk(KERN_DEBUG "Bad block table written to 0x%012llx, version "
		       "0x%02X\n", (unsigned long long)to, td->version[chip]);

		/* Mark it as used */
		td->pages[chip] = page;
57e16b70:	e5093004 	str	r3, [r9, #-4]
		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
		nrchips = 1;
	}

	/* Loop through the chips */
	for (; chip < nrchips; chip++) {
57e16b74:	e58da03c 	str	sl, [sp, #60]	; 0x3c
57e16b78:	e59db03c 	ldr	fp, [sp, #60]	; 0x3c
57e16b7c:	e59dc04c 	ldr	ip, [sp, #76]	; 0x4c
57e16b80:	e15b000c 	cmp	fp, ip
57e16b84:	bafffe93 	blt	57e165d8 <write_bbt+0x104>
		       "0x%02X\n", (unsigned long long)to, td->version[chip]);

		/* Mark it as used */
		td->pages[chip] = page;
	}
	return 0;
57e16b88:	e3a0b000 	mov	fp, #0
57e16b8c:	ea000005 	b	57e16ba8 <write_bbt+0x6d4>
57e16b90:	e1a0b000 	mov	fp, r0

 outerr:
	printk(KERN_WARNING
57e16b94:	e1a0100b 	mov	r1, fp
57e16b98:	e59f0024 	ldr	r0, [pc, #36]	; 57e16bc4 <write_bbt+0x6f0>
57e16b9c:	ebffca2a 	bl	57e0944c <printf>
	       "nand_bbt: Error while writing bad block table %d\n", res);
	return res;
57e16ba0:	ea000000 	b	57e16ba8 <write_bbt+0x6d4>
			msk[3] = 0x0f;
			break;
		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;
			msk[3] = 0xff;
			break;
		default: return -EINVAL;
57e16ba4:	e3e0b015 	mvn	fp, #21

 outerr:
	printk(KERN_WARNING
	       "nand_bbt: Error while writing bad block table %d\n", res);
	return res;
}
57e16ba8:	e1a0000b 	mov	r0, fp
57e16bac:	e28ddc01 	add	sp, sp, #256	; 0x100
57e16bb0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e16bb4:	57e33914 	.word	0x57e33914
57e16bb8:	57e3393c 	.word	0x57e3393c
57e16bbc:	57e3397b 	.word	0x57e3397b
57e16bc0:	57e339c0 	.word	0x57e339c0
57e16bc4:	57e339f6 	.word	0x57e339f6

57e16bc8 <verify_bbt_descr>:
	struct nand_chip *this = mtd->priv;
	u32 pattern_len;
	u32 bits;
	u32 table_size;

	if (!bd)
57e16bc8:	e3510000 	cmp	r1, #0
 *
 * This functions performs a few sanity checks on the bad block description
 * table.
 */
static void verify_bbt_descr(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
57e16bcc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct nand_chip *this = mtd->priv;
57e16bd0:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	u32 pattern_len;
	u32 bits;
	u32 table_size;

	if (!bd)
57e16bd4:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;

	pattern_len = bd->len;
	bits = bd->options & NAND_BBT_NRBITS_MSK;

	BUG_ON((this->options & NAND_USE_FLASH_BBT_NO_OOB) &&
57e16bd8:	e594c050 	ldr	ip, [r4, #80]	; 0x50
	u32 table_size;

	if (!bd)
		return;

	pattern_len = bd->len;
57e16bdc:	e5912014 	ldr	r2, [r1, #20]
	bits = bd->options & NAND_BBT_NRBITS_MSK;

	BUG_ON((this->options & NAND_USE_FLASH_BBT_NO_OOB) &&
57e16be0:	e20cc881 	and	ip, ip, #8454144	; 0x810000
57e16be4:	e35c0502 	cmp	ip, #8388608	; 0x800000

	if (!bd)
		return;

	pattern_len = bd->len;
	bits = bd->options & NAND_BBT_NRBITS_MSK;
57e16be8:	e5913000 	ldr	r3, [r1]

	BUG_ON((this->options & NAND_USE_FLASH_BBT_NO_OOB) &&
57e16bec:	059f0104 	ldreq	r0, [pc, #260]	; 57e16cf8 <verify_bbt_descr+0x130>
57e16bf0:	059f1104 	ldreq	r1, [pc, #260]	; 57e16cfc <verify_bbt_descr+0x134>
57e16bf4:	059f2104 	ldreq	r2, [pc, #260]	; 57e16d00 <verify_bbt_descr+0x138>
57e16bf8:	0a000004 	beq	57e16c10 <verify_bbt_descr+0x48>
			!(this->options & NAND_USE_FLASH_BBT));
	BUG_ON(!bits);
57e16bfc:	e213700f 	ands	r7, r3, #15
57e16c00:	1a000006 	bne	57e16c20 <verify_bbt_descr+0x58>
57e16c04:	e59f00ec 	ldr	r0, [pc, #236]	; 57e16cf8 <verify_bbt_descr+0x130>
57e16c08:	e59f10ec 	ldr	r1, [pc, #236]	; 57e16cfc <verify_bbt_descr+0x134>
57e16c0c:	e59f20f0 	ldr	r2, [pc, #240]	; 57e16d04 <verify_bbt_descr+0x13c>
57e16c10:	e59f30f0 	ldr	r3, [pc, #240]	; 57e16d08 <verify_bbt_descr+0x140>
57e16c14:	ebffca0c 	bl	57e0944c <printf>
57e16c18:	e59f00ec 	ldr	r0, [pc, #236]	; 57e16d0c <verify_bbt_descr+0x144>
57e16c1c:	eb0039d2 	bl	57e2536c <panic>

	if (bd->options & NAND_BBT_VERSION)
57e16c20:	e213ec01 	ands	lr, r3, #256	; 0x100
	u32 table_size;

	if (!bd)
		return;

	pattern_len = bd->len;
57e16c24:	e1a05002 	mov	r5, r2
	BUG_ON((this->options & NAND_USE_FLASH_BBT_NO_OOB) &&
			!(this->options & NAND_USE_FLASH_BBT));
	BUG_ON(!bits);

	if (bd->options & NAND_BBT_VERSION)
		pattern_len++;
57e16c28:	12825001 	addne	r5, r2, #1

	if (bd->options & NAND_BBT_NO_OOB) {
57e16c2c:	e2136501 	ands	r6, r3, #4194304	; 0x400000
57e16c30:	0a00001d 	beq	57e16cac <verify_bbt_descr+0xe4>
		BUG_ON(!(this->options & NAND_USE_FLASH_BBT));
57e16c34:	e594c050 	ldr	ip, [r4, #80]	; 0x50
57e16c38:	e31c0801 	tst	ip, #65536	; 0x10000
57e16c3c:	059f00b4 	ldreq	r0, [pc, #180]	; 57e16cf8 <verify_bbt_descr+0x130>
57e16c40:	059f10b4 	ldreq	r1, [pc, #180]	; 57e16cfc <verify_bbt_descr+0x134>
57e16c44:	059f20c4 	ldreq	r2, [pc, #196]	; 57e16d10 <verify_bbt_descr+0x148>
57e16c48:	0afffff0 	beq	57e16c10 <verify_bbt_descr+0x48>
		BUG_ON(!(this->options & NAND_USE_FLASH_BBT_NO_OOB));
57e16c4c:	e31c0502 	tst	ip, #8388608	; 0x800000
57e16c50:	059f00a0 	ldreq	r0, [pc, #160]	; 57e16cf8 <verify_bbt_descr+0x130>
57e16c54:	059f10a0 	ldreq	r1, [pc, #160]	; 57e16cfc <verify_bbt_descr+0x134>
57e16c58:	059f20b4 	ldreq	r2, [pc, #180]	; 57e16d14 <verify_bbt_descr+0x14c>
57e16c5c:	0affffeb 	beq	57e16c10 <verify_bbt_descr+0x48>
		BUG_ON(bd->offs);
57e16c60:	e591c008 	ldr	ip, [r1, #8]
57e16c64:	e35c0000 	cmp	ip, #0
57e16c68:	159f0088 	ldrne	r0, [pc, #136]	; 57e16cf8 <verify_bbt_descr+0x130>
57e16c6c:	159f1088 	ldrne	r1, [pc, #136]	; 57e16cfc <verify_bbt_descr+0x134>
57e16c70:	159f20a0 	ldrne	r2, [pc, #160]	; 57e16d18 <verify_bbt_descr+0x150>
57e16c74:	1affffe5 	bne	57e16c10 <verify_bbt_descr+0x48>
		if (bd->options & NAND_BBT_VERSION)
57e16c78:	e35e0000 	cmp	lr, #0
57e16c7c:	0a000005 	beq	57e16c98 <verify_bbt_descr+0xd0>
			BUG_ON(bd->veroffs != bd->len);
57e16c80:	e591100c 	ldr	r1, [r1, #12]
57e16c84:	e1510002 	cmp	r1, r2
57e16c88:	159f0068 	ldrne	r0, [pc, #104]	; 57e16cf8 <verify_bbt_descr+0x130>
57e16c8c:	159f1068 	ldrne	r1, [pc, #104]	; 57e16cfc <verify_bbt_descr+0x134>
57e16c90:	159f2084 	ldrne	r2, [pc, #132]	; 57e16d1c <verify_bbt_descr+0x154>
57e16c94:	1affffdd 	bne	57e16c10 <verify_bbt_descr+0x48>
		BUG_ON(bd->options & NAND_BBT_SAVECONTENT);
57e16c98:	e3130a02 	tst	r3, #8192	; 0x2000
57e16c9c:	159f0054 	ldrne	r0, [pc, #84]	; 57e16cf8 <verify_bbt_descr+0x130>
57e16ca0:	159f1054 	ldrne	r1, [pc, #84]	; 57e16cfc <verify_bbt_descr+0x134>
57e16ca4:	159f2074 	ldrne	r2, [pc, #116]	; 57e16d20 <verify_bbt_descr+0x158>
57e16ca8:	1affffd8 	bne	57e16c10 <verify_bbt_descr+0x48>
	}

	if (bd->options & NAND_BBT_PERCHIP)
57e16cac:	e3130080 	tst	r3, #128	; 0x80
		table_size = this->chipsize >> this->bbt_erase_shift;
57e16cb0:	12841068 	addne	r1, r4, #104	; 0x68
57e16cb4:	18910003 	ldmne	r1, {r0, r1}
	else
		table_size = mtd->size >> this->bbt_erase_shift;
57e16cb8:	02801008 	addeq	r1, r0, #8
57e16cbc:	08910003 	ldmeq	r1, {r0, r1}
57e16cc0:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
57e16cc4:	eb0053cc 	bl	57e2bbfc <__lshrdi3>
	table_size >>= 3;
57e16cc8:	e1a001a0 	lsr	r0, r0, #3
	table_size *= bits;
57e16ccc:	e0070790 	mul	r7, r0, r7
	if (bd->options & NAND_BBT_NO_OOB)
57e16cd0:	e3560000 	cmp	r6, #0
		table_size += pattern_len;
	BUG_ON(table_size > (1 << this->bbt_erase_shift));
57e16cd4:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
	else
		table_size = mtd->size >> this->bbt_erase_shift;
	table_size >>= 3;
	table_size *= bits;
	if (bd->options & NAND_BBT_NO_OOB)
		table_size += pattern_len;
57e16cd8:	10877005 	addne	r7, r7, r5
	BUG_ON(table_size > (1 << this->bbt_erase_shift));
57e16cdc:	e3a02001 	mov	r2, #1
57e16ce0:	e1570312 	cmp	r7, r2, lsl r3
57e16ce4:	98bd80f8 	popls	{r3, r4, r5, r6, r7, pc}
57e16ce8:	e59f0008 	ldr	r0, [pc, #8]	; 57e16cf8 <verify_bbt_descr+0x130>
57e16cec:	e59f1008 	ldr	r1, [pc, #8]	; 57e16cfc <verify_bbt_descr+0x134>
57e16cf0:	e59f202c 	ldr	r2, [pc, #44]	; 57e16d24 <verify_bbt_descr+0x15c>
57e16cf4:	eaffffc5 	b	57e16c10 <verify_bbt_descr+0x48>
57e16cf8:	57e33a28 	.word	0x57e33a28
57e16cfc:	57e33a45 	.word	0x57e33a45
57e16d00:	0000045b 	.word	0x0000045b
57e16d04:	0000045c 	.word	0x0000045c
57e16d08:	57e2c43c 	.word	0x57e2c43c
57e16d0c:	57e33a50 	.word	0x57e33a50
57e16d10:	00000462 	.word	0x00000462
57e16d14:	00000463 	.word	0x00000463
57e16d18:	00000464 	.word	0x00000464
57e16d1c:	00000466 	.word	0x00000466
57e16d20:	00000467 	.word	0x00000467
57e16d24:	00000472 	.word	0x00000472

57e16d28 <check_pattern>:
 * If the SCAN_EMPTY option is set then check, if all bytes except the
 * pattern area contain 0xff
 *
*/
static int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
{
57e16d28:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	int i, end = 0;
	uint8_t *p = buf;

	if (td->options & NAND_BBT_NO_OOB)
57e16d2c:	e5934000 	ldr	r4, [r3]
 * If the SCAN_EMPTY option is set then check, if all bytes except the
 * pattern area contain 0xff
 *
*/
static int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
{
57e16d30:	e1a0c000 	mov	ip, r0
	int i, end = 0;
	uint8_t *p = buf;

	if (td->options & NAND_BBT_NO_OOB)
57e16d34:	e2145501 	ands	r5, r4, #4194304	; 0x400000
57e16d38:	0a000005 	beq	57e16d54 <check_pattern+0x2c>

static int check_pattern_no_oob(uint8_t *buf, struct nand_bbt_descr *td)
{
	int ret;

	ret = memcmp(buf, td->pattern, td->len);
57e16d3c:	e5931020 	ldr	r1, [r3, #32]
57e16d40:	e5932014 	ldr	r2, [r3, #20]
57e16d44:	eb0035a3 	bl	57e243d8 <memcmp>
	if (!ret)
		return ret;
	return -1;
57e16d48:	e3500000 	cmp	r0, #0
57e16d4c:	13e00000 	mvnne	r0, #0
57e16d50:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	uint8_t *p = buf;

	if (td->options & NAND_BBT_NO_OOB)
		return check_pattern_no_oob(buf, td);

	end = paglen + td->offs;
57e16d54:	e5936008 	ldr	r6, [r3, #8]
	if (td->options & NAND_BBT_SCANEMPTY) {
57e16d58:	e2140b02 	ands	r0, r4, #2048	; 0x800
	uint8_t *p = buf;

	if (td->options & NAND_BBT_NO_OOB)
		return check_pattern_no_oob(buf, td);

	end = paglen + td->offs;
57e16d5c:	e0822006 	add	r2, r2, r6
	if (td->options & NAND_BBT_SCANEMPTY) {
57e16d60:	0a000006 	beq	57e16d80 <check_pattern+0x58>
57e16d64:	ea000003 	b	57e16d78 <check_pattern+0x50>
		for (i = 0; i < end; i++) {
			if (p[i] != 0xff)
57e16d68:	e7dc7005 	ldrb	r7, [ip, r5]
57e16d6c:	e35700ff 	cmp	r7, #255	; 0xff
57e16d70:	1a000038 	bne	57e16e58 <check_pattern+0x130>
	if (td->options & NAND_BBT_NO_OOB)
		return check_pattern_no_oob(buf, td);

	end = paglen + td->offs;
	if (td->options & NAND_BBT_SCANEMPTY) {
		for (i = 0; i < end; i++) {
57e16d74:	e2855001 	add	r5, r5, #1
57e16d78:	e1550002 	cmp	r5, r2
57e16d7c:	bafffff9 	blt	57e16d68 <check_pattern+0x40>
			if (p[i] != 0xff)
				return -1;
		}
	}
	p += end;
57e16d80:	e08cc002 	add	ip, ip, r2

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
57e16d84:	e5935014 	ldr	r5, [r3, #20]
57e16d88:	e3a07000 	mov	r7, #0
57e16d8c:	ea000005 	b	57e16da8 <check_pattern+0x80>
		if (p[i] != td->pattern[i])
57e16d90:	e593a020 	ldr	sl, [r3, #32]
57e16d94:	e7dc9007 	ldrb	r9, [ip, r7]
57e16d98:	e7daa007 	ldrb	sl, [sl, r7]
57e16d9c:	e159000a 	cmp	r9, sl
57e16da0:	1a00002c 	bne	57e16e58 <check_pattern+0x130>
		}
	}
	p += end;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
57e16da4:	e2877001 	add	r7, r7, #1
57e16da8:	e1570005 	cmp	r7, r5
57e16dac:	bafffff7 	blt	57e16d90 <check_pattern+0x68>
		if (p[i] != td->pattern[i])
			return -1;
	}

	/* Check both positions 1 and 6 for pattern? */
	if (td->options & NAND_BBT_SCANBYTE1AND6) {
57e16db0:	e3140601 	tst	r4, #1048576	; 0x100000
57e16db4:	0a00001a 	beq	57e16e24 <check_pattern+0xfc>
		if (td->options & NAND_BBT_SCANEMPTY) {
57e16db8:	e3500000 	cmp	r0, #0
57e16dbc:	e2666005 	rsb	r6, r6, #5
			p += td->len;
57e16dc0:	108c7005 	addne	r7, ip, r5
			end += NAND_SMALL_BADBLOCK_POS - td->offs;
			/* Check region between positions 1 and 6 */
			for (i = 0; i < NAND_SMALL_BADBLOCK_POS - td->offs - td->len;
57e16dc4:	13a04000 	movne	r4, #0
57e16dc8:	1065a006 	rsbne	sl, r5, r6
			return -1;
	}

	/* Check both positions 1 and 6 for pattern? */
	if (td->options & NAND_BBT_SCANBYTE1AND6) {
		if (td->options & NAND_BBT_SCANEMPTY) {
57e16dcc:	1a000004 	bne	57e16de4 <check_pattern+0xbc>
57e16dd0:	ea000008 	b	57e16df8 <check_pattern+0xd0>
			p += td->len;
			end += NAND_SMALL_BADBLOCK_POS - td->offs;
			/* Check region between positions 1 and 6 */
			for (i = 0; i < NAND_SMALL_BADBLOCK_POS - td->offs - td->len;
					i++) {
				if (*p++ != 0xff)
57e16dd4:	e4d7c001 	ldrb	ip, [r7], #1
57e16dd8:	e35c00ff 	cmp	ip, #255	; 0xff
57e16ddc:	1a00001d 	bne	57e16e58 <check_pattern+0x130>
		if (td->options & NAND_BBT_SCANEMPTY) {
			p += td->len;
			end += NAND_SMALL_BADBLOCK_POS - td->offs;
			/* Check region between positions 1 and 6 */
			for (i = 0; i < NAND_SMALL_BADBLOCK_POS - td->offs - td->len;
					i++) {
57e16de0:	e2844001 	add	r4, r4, #1
	if (td->options & NAND_BBT_SCANBYTE1AND6) {
		if (td->options & NAND_BBT_SCANEMPTY) {
			p += td->len;
			end += NAND_SMALL_BADBLOCK_POS - td->offs;
			/* Check region between positions 1 and 6 */
			for (i = 0; i < NAND_SMALL_BADBLOCK_POS - td->offs - td->len;
57e16de4:	e154000a 	cmp	r4, sl
					i++) {
57e16de8:	e1a0c007 	mov	ip, r7
	if (td->options & NAND_BBT_SCANBYTE1AND6) {
		if (td->options & NAND_BBT_SCANEMPTY) {
			p += td->len;
			end += NAND_SMALL_BADBLOCK_POS - td->offs;
			/* Check region between positions 1 and 6 */
			for (i = 0; i < NAND_SMALL_BADBLOCK_POS - td->offs - td->len;
57e16dec:	bafffff8 	blt	57e16dd4 <check_pattern+0xac>

	/* Check both positions 1 and 6 for pattern? */
	if (td->options & NAND_BBT_SCANBYTE1AND6) {
		if (td->options & NAND_BBT_SCANEMPTY) {
			p += td->len;
			end += NAND_SMALL_BADBLOCK_POS - td->offs;
57e16df0:	e0822006 	add	r2, r2, r6
57e16df4:	ea000000 	b	57e16dfc <check_pattern+0xd4>
				if (*p++ != 0xff)
					return -1;
			}
		}
		else {
			p += NAND_SMALL_BADBLOCK_POS - td->offs;
57e16df8:	e08cc006 	add	ip, ip, r6
		}
		/* Compare the pattern */
		for (i = 0; i < td->len; i++) {
57e16dfc:	e3a04000 	mov	r4, #0
57e16e00:	ea000005 	b	57e16e1c <check_pattern+0xf4>
			if (p[i] != td->pattern[i])
57e16e04:	e5936020 	ldr	r6, [r3, #32]
57e16e08:	e7dc7004 	ldrb	r7, [ip, r4]
57e16e0c:	e7d66004 	ldrb	r6, [r6, r4]
57e16e10:	e1570006 	cmp	r7, r6
57e16e14:	1a00000f 	bne	57e16e58 <check_pattern+0x130>
		}
		else {
			p += NAND_SMALL_BADBLOCK_POS - td->offs;
		}
		/* Compare the pattern */
		for (i = 0; i < td->len; i++) {
57e16e18:	e2844001 	add	r4, r4, #1
57e16e1c:	e1540005 	cmp	r4, r5
57e16e20:	bafffff7 	blt	57e16e04 <check_pattern+0xdc>
			if (p[i] != td->pattern[i])
				return -1;
		}
	}

	if (td->options & NAND_BBT_SCANEMPTY) {
57e16e24:	e3500000 	cmp	r0, #0
		p += td->len;
57e16e28:	108cc005 	addne	ip, ip, r5
		end += td->len;
		for (i = end; i < len; i++) {
57e16e2c:	10822005 	addne	r2, r2, r5
			if (p[i] != td->pattern[i])
				return -1;
		}
	}

	if (td->options & NAND_BBT_SCANEMPTY) {
57e16e30:	1a000004 	bne	57e16e48 <check_pattern+0x120>
57e16e34:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		p += td->len;
		end += td->len;
		for (i = end; i < len; i++) {
			if (*p++ != 0xff)
57e16e38:	e4dc3001 	ldrb	r3, [ip], #1
57e16e3c:	e35300ff 	cmp	r3, #255	; 0xff
57e16e40:	1a000006 	bne	57e16e60 <check_pattern+0x138>
	}

	if (td->options & NAND_BBT_SCANEMPTY) {
		p += td->len;
		end += td->len;
		for (i = end; i < len; i++) {
57e16e44:	e2822001 	add	r2, r2, #1
57e16e48:	e1520001 	cmp	r2, r1
57e16e4c:	bafffff9 	blt	57e16e38 <check_pattern+0x110>
			if (*p++ != 0xff)
				return -1;
		}
	}
	return 0;
57e16e50:	e3a00000 	mov	r0, #0
57e16e54:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			p += NAND_SMALL_BADBLOCK_POS - td->offs;
		}
		/* Compare the pattern */
		for (i = 0; i < td->len; i++) {
			if (p[i] != td->pattern[i])
				return -1;
57e16e58:	e3e00000 	mvn	r0, #0
57e16e5c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	if (td->options & NAND_BBT_SCANEMPTY) {
		p += td->len;
		end += td->len;
		for (i = end; i < len; i++) {
			if (*p++ != 0xff)
				return -1;
57e16e60:	e3e00000 	mvn	r0, #0
		}
	}
	return 0;
}
57e16e64:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

57e16e68 <create_bbt>:
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *bd, int chip)
{
57e16e68:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e16e6c:	e1a07003 	mov	r7, r3
	loff_t from;
	size_t readlen;

	MTDDEBUG(MTD_DEBUG_LEVEL0, "Scanning device for bad blocks\n");

	if (bd->options & NAND_BBT_SCANALLPAGES)
57e16e70:	e5923000 	ldr	r3, [r2]
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *bd, int chip)
{
57e16e74:	e24dd048 	sub	sp, sp, #72	; 0x48
	loff_t from;
	size_t readlen;

	MTDDEBUG(MTD_DEBUG_LEVEL0, "Scanning device for bad blocks\n");

	if (bd->options & NAND_BBT_SCANALLPAGES)
57e16e78:	e3130b01 	tst	r3, #1024	; 0x400
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
	struct nand_bbt_descr *bd, int chip)
{
57e16e7c:	e1a04000 	mov	r4, r0
57e16e80:	e1a0a001 	mov	sl, r1
57e16e84:	e1a06002 	mov	r6, r2
	struct nand_chip *this = mtd->priv;
57e16e88:	e5905094 	ldr	r5, [r0, #148]	; 0x94
	loff_t from;
	size_t readlen;

	MTDDEBUG(MTD_DEBUG_LEVEL0, "Scanning device for bad blocks\n");

	if (bd->options & NAND_BBT_SCANALLPAGES)
57e16e8c:	0a000005 	beq	57e16ea8 <create_bbt+0x40>
		len = 1 << (this->bbt_erase_shift - this->page_shift);
57e16e90:	e5952054 	ldr	r2, [r5, #84]	; 0x54
57e16e94:	e595905c 	ldr	r9, [r5, #92]	; 0x5c
57e16e98:	e0629009 	rsb	r9, r2, r9
57e16e9c:	e3a02001 	mov	r2, #1
57e16ea0:	e1a09912 	lsl	r9, r2, r9
57e16ea4:	ea000002 	b	57e16eb4 <create_bbt+0x4c>
	else if (bd->options & NAND_BBT_SCAN2NDPAGE)
		len = 2;
57e16ea8:	e3130901 	tst	r3, #16384	; 0x4000
57e16eac:	03a09001 	moveq	r9, #1
57e16eb0:	13a09002 	movne	r9, #2
	else
		len = 1;

	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
57e16eb4:	e2133b02 	ands	r3, r3, #2048	; 0x800
		/* We need only read few bytes from the OOB area */
		scanlen = 0;
		readlen = bd->len;
	} else {
		/* Full page content should be read */
		scanlen = mtd->writesize + mtd->oobsize;
57e16eb8:	15943014 	ldrne	r3, [r4, #20]
57e16ebc:	15942018 	ldrne	r2, [r4, #24]
		readlen = len * mtd->writesize;
57e16ec0:	10010993 	mulne	r1, r3, r9
		len = 1;

	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
		/* We need only read few bytes from the OOB area */
		scanlen = 0;
		readlen = bd->len;
57e16ec4:	05960014 	ldreq	r0, [r6, #20]
	} else {
		/* Full page content should be read */
		scanlen = mtd->writesize + mtd->oobsize;
57e16ec8:	10832002 	addne	r2, r3, r2
		len = 1;

	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
		/* We need only read few bytes from the OOB area */
		scanlen = 0;
		readlen = bd->len;
57e16ecc:	058d0020 	streq	r0, [sp, #32]
	else
		len = 1;

	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
		/* We need only read few bytes from the OOB area */
		scanlen = 0;
57e16ed0:	058d301c 	streq	r3, [sp, #28]
		readlen = bd->len;
	} else {
		/* Full page content should be read */
		scanlen = mtd->writesize + mtd->oobsize;
57e16ed4:	158d201c 	strne	r2, [sp, #28]
		readlen = len * mtd->writesize;
57e16ed8:	158d1020 	strne	r1, [sp, #32]
	}

	if (chip == -1) {
57e16edc:	e3770001 	cmn	r7, #1
57e16ee0:	1a00000b 	bne	57e16f14 <create_bbt+0xac>
		/* Note that numblocks is 2 * (real numblocks) here, see i+=2
		 * below as it makes shifting and masking less painful */
		numblocks = mtd->size >> (this->bbt_erase_shift - 1);
57e16ee4:	e595205c 	ldr	r2, [r5, #92]	; 0x5c
57e16ee8:	e2841008 	add	r1, r4, #8
57e16eec:	e8910003 	ldm	r1, {r0, r1}
57e16ef0:	e2422001 	sub	r2, r2, #1
57e16ef4:	eb005340 	bl	57e2bbfc <__lshrdi3>
		startblock = 0;
		from = 0;
57e16ef8:	e3a02000 	mov	r2, #0
57e16efc:	e3a03000 	mov	r3, #0
	}

	if (chip == -1) {
		/* Note that numblocks is 2 * (real numblocks) here, see i+=2
		 * below as it makes shifting and masking less painful */
		numblocks = mtd->size >> (this->bbt_erase_shift - 1);
57e16f00:	e58d0018 	str	r0, [sp, #24]
		startblock = 0;
		from = 0;
57e16f04:	e58d2008 	str	r2, [sp, #8]
57e16f08:	e58d300c 	str	r3, [sp, #12]

	if (chip == -1) {
		/* Note that numblocks is 2 * (real numblocks) here, see i+=2
		 * below as it makes shifting and masking less painful */
		numblocks = mtd->size >> (this->bbt_erase_shift - 1);
		startblock = 0;
57e16f0c:	e2877001 	add	r7, r7, #1
57e16f10:	ea000016 	b	57e16f70 <create_bbt+0x108>
		from = 0;
	} else {
		if (chip >= this->numchips) {
57e16f14:	e5952064 	ldr	r2, [r5, #100]	; 0x64
57e16f18:	e1570002 	cmp	r7, r2
57e16f1c:	ba000004 	blt	57e16f34 <create_bbt+0xcc>
			printk(KERN_WARNING "create_bbt(): chipnr (%d) > available chips (%d)\n",
57e16f20:	e59f0290 	ldr	r0, [pc, #656]	; 57e171b8 <create_bbt+0x350>
57e16f24:	e2871001 	add	r1, r7, #1
57e16f28:	ebffc947 	bl	57e0944c <printf>
			       chip + 1, this->numchips);
			return -EINVAL;
57e16f2c:	e3e00015 	mvn	r0, #21
57e16f30:	ea000095 	b	57e1718c <create_bbt+0x324>
		}
		numblocks = this->chipsize >> (this->bbt_erase_shift - 1);
57e16f34:	e595b05c 	ldr	fp, [r5, #92]	; 0x5c
57e16f38:	e2851068 	add	r1, r5, #104	; 0x68
57e16f3c:	e8910003 	ldm	r1, {r0, r1}
57e16f40:	e24bb001 	sub	fp, fp, #1
57e16f44:	e1a0200b 	mov	r2, fp
57e16f48:	eb00532b 	bl	57e2bbfc <__lshrdi3>
		startblock = chip * numblocks;
57e16f4c:	e0070790 	mul	r7, r0, r7
		numblocks += startblock;
57e16f50:	e0870000 	add	r0, r7, r0
57e16f54:	e58d0018 	str	r0, [sp, #24]
		from = (loff_t)startblock << (this->bbt_erase_shift - 1);
57e16f58:	e1a0200b 	mov	r2, fp
57e16f5c:	e1a00007 	mov	r0, r7
57e16f60:	e1a01fc0 	asr	r1, r0, #31
57e16f64:	eb005332 	bl	57e2bc34 <__ashldi3>
57e16f68:	e58d0008 	str	r0, [sp, #8]
57e16f6c:	e58d100c 	str	r1, [sp, #12]
	}

	if (this->options & NAND_BBT_SCANLASTPAGE)
57e16f70:	e5953050 	ldr	r3, [r5, #80]	; 0x50
57e16f74:	e3130902 	tst	r3, #32768	; 0x8000
57e16f78:	0a00007f 	beq	57e1717c <create_bbt+0x314>
		from += mtd->erasesize - (mtd->writesize * len);
57e16f7c:	e5943014 	ldr	r3, [r4, #20]
57e16f80:	e5942010 	ldr	r2, [r4, #16]
57e16f84:	e0030399 	mul	r3, r9, r3
57e16f88:	e28d1008 	add	r1, sp, #8
57e16f8c:	e8910003 	ldm	r1, {r0, r1}
57e16f90:	e0633002 	rsb	r3, r3, r2
57e16f94:	e0900003 	adds	r0, r0, r3
57e16f98:	e2a11000 	adc	r1, r1, #0
57e16f9c:	ea000074 	b	57e17174 <create_bbt+0x30c>

	for (i = startblock; i < numblocks;) {
		int ret;

		BUG_ON(bd->options & NAND_BBT_NO_OOB);
57e16fa0:	e596b000 	ldr	fp, [r6]
57e16fa4:	e31b0501 	tst	fp, #4194304	; 0x400000
57e16fa8:	0a000006 	beq	57e16fc8 <create_bbt+0x160>
57e16fac:	e59f0208 	ldr	r0, [pc, #520]	; 57e171bc <create_bbt+0x354>
57e16fb0:	e59f1208 	ldr	r1, [pc, #520]	; 57e171c0 <create_bbt+0x358>
57e16fb4:	e3a02f8b 	mov	r2, #556	; 0x22c
57e16fb8:	e59f3204 	ldr	r3, [pc, #516]	; 57e171c4 <create_bbt+0x35c>
57e16fbc:	ebffc922 	bl	57e0944c <printf>
57e16fc0:	e59f0200 	ldr	r0, [pc, #512]	; 57e171c8 <create_bbt+0x360>
57e16fc4:	eb0038e8 	bl	57e2536c <panic>

		if (bd->options & NAND_BBT_SCANALLPAGES)
57e16fc8:	e21bbb01 	ands	fp, fp, #1024	; 0x400
57e16fcc:	0a00001e 	beq	57e1704c <create_bbt+0x1e4>
			   loff_t offs, uint8_t *buf, size_t readlen,
			   int scanlen, int len)
{
	int ret, j;

	ret = scan_read_raw_oob(mtd, buf, offs, readlen);
57e16fd0:	e59d1020 	ldr	r1, [sp, #32]
57e16fd4:	e1a00004 	mov	r0, r4
57e16fd8:	e58d1000 	str	r1, [sp]
57e16fdc:	e28d3008 	add	r3, sp, #8
57e16fe0:	e893000c 	ldm	r3, {r2, r3}
57e16fe4:	e1a0100a 	mov	r1, sl
57e16fe8:	ebfffc20 	bl	57e16070 <scan_read_raw_oob>
	if (ret)
57e16fec:	e3500000 	cmp	r0, #0
57e16ff0:	1a000047 	bne	57e17114 <create_bbt+0x2ac>
57e16ff4:	e58d7010 	str	r7, [sp, #16]
57e16ff8:	e58d5024 	str	r5, [sp, #36]	; 0x24
57e16ffc:	e1a07006 	mov	r7, r6
57e17000:	e1a0b00a 	mov	fp, sl
57e17004:	e1a05000 	mov	r5, r0
57e17008:	e59d601c 	ldr	r6, [sp, #28]
57e1700c:	ea000008 	b	57e17034 <create_bbt+0x1cc>
		return ret;

	for (j = 0; j < len; j++, buf += scanlen) {
		if (check_pattern(buf, scanlen, mtd->writesize, bd))
57e17010:	e1a0000b 	mov	r0, fp
57e17014:	e1a01006 	mov	r1, r6
57e17018:	e5942014 	ldr	r2, [r4, #20]
57e1701c:	e1a03007 	mov	r3, r7
57e17020:	ebffff40 	bl	57e16d28 <check_pattern>
57e17024:	e3500000 	cmp	r0, #0
57e17028:	1a00003d 	bne	57e17124 <create_bbt+0x2bc>

	ret = scan_read_raw_oob(mtd, buf, offs, readlen);
	if (ret)
		return ret;

	for (j = 0; j < len; j++, buf += scanlen) {
57e1702c:	e2855001 	add	r5, r5, #1
 *		Applies only if NAND_BBT_PERCHIP option is set
 *
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
57e17030:	e08bb006 	add	fp, fp, r6

	ret = scan_read_raw_oob(mtd, buf, offs, readlen);
	if (ret)
		return ret;

	for (j = 0; j < len; j++, buf += scanlen) {
57e17034:	e1550009 	cmp	r5, r9
57e17038:	bafffff4 	blt	57e17010 <create_bbt+0x1a8>
57e1703c:	e1a06007 	mov	r6, r7
57e17040:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
57e17044:	e59d7010 	ldr	r7, [sp, #16]
57e17048:	ea000041 	b	57e17154 <create_bbt+0x2ec>
			   loff_t offs, uint8_t *buf, int len)
{
	struct mtd_oob_ops ops;
	int j, ret;

	ops.ooblen = mtd->oobsize;
57e1704c:	e5943018 	ldr	r3, [r4, #24]
	ops.oobbuf = buf;
57e17050:	e58da044 	str	sl, [sp, #68]	; 0x44
			   loff_t offs, uint8_t *buf, int len)
{
	struct mtd_oob_ops ops;
	int j, ret;

	ops.ooblen = mtd->oobsize;
57e17054:	e58d3034 	str	r3, [sp, #52]	; 0x34
	ops.oobbuf = buf;
	ops.ooboffs = 0;
57e17058:	e58db03c 	str	fp, [sp, #60]	; 0x3c
	ops.datbuf = NULL;
	ops.mode = MTD_OOB_PLACE;
57e1705c:	e28d3008 	add	r3, sp, #8
57e17060:	e893000c 	ldm	r3, {r2, r3}
	int j, ret;

	ops.ooblen = mtd->oobsize;
	ops.oobbuf = buf;
	ops.ooboffs = 0;
	ops.datbuf = NULL;
57e17064:	e58db040 	str	fp, [sp, #64]	; 0x40
	ops.mode = MTD_OOB_PLACE;
57e17068:	e58db028 	str	fp, [sp, #40]	; 0x28
57e1706c:	e58d2010 	str	r2, [sp, #16]
57e17070:	e58d3014 	str	r3, [sp, #20]
57e17074:	ea000023 	b	57e17108 <create_bbt+0x2a0>
		/*
		 * Read the full oob until read_oob is fixed to
		 * handle single byte reads for 16 bit
		 * buswidth
		 */
		ret = mtd->read_oob(mtd, offs, &ops);
57e17078:	e28d3028 	add	r3, sp, #40	; 0x28
57e1707c:	e58d3000 	str	r3, [sp]
57e17080:	e594104c 	ldr	r1, [r4, #76]	; 0x4c
57e17084:	e1a00004 	mov	r0, r4
57e17088:	e28d3010 	add	r3, sp, #16
57e1708c:	e893000c 	ldm	r3, {r2, r3}
57e17090:	e12fff31 	blx	r1
		if (ret)
57e17094:	e3500000 	cmp	r0, #0
57e17098:	1a00001d 	bne	57e17114 <create_bbt+0x2ac>
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
57e1709c:	e5961014 	ldr	r1, [r6, #20]
57e170a0:	ea000007 	b	57e170c4 <create_bbt+0x25c>
		if (p[td->offs + i] != td->pattern[i])
57e170a4:	e5963008 	ldr	r3, [r6, #8]
57e170a8:	e596c020 	ldr	ip, [r6, #32]
57e170ac:	e08a2000 	add	r2, sl, r0
57e170b0:	e7d23003 	ldrb	r3, [r2, r3]
57e170b4:	e7dc2000 	ldrb	r2, [ip, r0]
57e170b8:	e1530002 	cmp	r3, r2
57e170bc:	1a00001b 	bne	57e17130 <create_bbt+0x2c8>
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
57e170c0:	e2800001 	add	r0, r0, #1
57e170c4:	e1500001 	cmp	r0, r1
57e170c8:	bafffff5 	blt	57e170a4 <create_bbt+0x23c>
		if (p[td->offs + i] != td->pattern[i])
			return -1;
	}
	/* Need to check location 1 AND 6? */
	if (td->options & NAND_BBT_SCANBYTE1AND6) {
57e170cc:	e5963000 	ldr	r3, [r6]
57e170d0:	e3130601 	tst	r3, #1048576	; 0x100000
 *		Applies only if NAND_BBT_PERCHIP option is set
 *
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
57e170d4:	128a2004 	addne	r2, sl, #4
57e170d8:	13a03000 	movne	r3, #0
	for (i = 0; i < td->len; i++) {
		if (p[td->offs + i] != td->pattern[i])
			return -1;
	}
	/* Need to check location 1 AND 6? */
	if (td->options & NAND_BBT_SCANBYTE1AND6) {
57e170dc:	1a000006 	bne	57e170fc <create_bbt+0x294>
57e170e0:	ea00002b 	b	57e17194 <create_bbt+0x32c>
		for (i = 0; i < td->len; i++) {
			if (p[NAND_SMALL_BADBLOCK_POS + i] != td->pattern[i])
57e170e4:	e5960020 	ldr	r0, [r6, #32]
57e170e8:	e5f2c001 	ldrb	ip, [r2, #1]!
57e170ec:	e7d00003 	ldrb	r0, [r0, r3]
57e170f0:	e15c0000 	cmp	ip, r0
57e170f4:	1a00000d 	bne	57e17130 <create_bbt+0x2c8>
		if (p[td->offs + i] != td->pattern[i])
			return -1;
	}
	/* Need to check location 1 AND 6? */
	if (td->options & NAND_BBT_SCANBYTE1AND6) {
		for (i = 0; i < td->len; i++) {
57e170f8:	e2833001 	add	r3, r3, #1
57e170fc:	e1530001 	cmp	r3, r1
57e17100:	bafffff7 	blt	57e170e4 <create_bbt+0x27c>
57e17104:	ea000022 	b	57e17194 <create_bbt+0x32c>
	ops.oobbuf = buf;
	ops.ooboffs = 0;
	ops.datbuf = NULL;
	ops.mode = MTD_OOB_PLACE;

	for (j = 0; j < len; j++) {
57e17108:	e15b0009 	cmp	fp, r9
57e1710c:	baffffd9 	blt	57e17078 <create_bbt+0x210>
57e17110:	ea00000f 	b	57e17154 <create_bbt+0x2ec>
			ret = scan_block_full(mtd, bd, from, buf, readlen,
					      scanlen, len);
		else
			ret = scan_block_fast(mtd, bd, from, buf, len);

		if (ret < 0)
57e17114:	e3500000 	cmp	r0, #0
57e17118:	ba00001b 	blt	57e1718c <create_bbt+0x324>
			return ret;

		if (ret) {
57e1711c:	0a00000c 	beq	57e17154 <create_bbt+0x2ec>
57e17120:	ea000002 	b	57e17130 <create_bbt+0x2c8>
57e17124:	e1a06007 	mov	r6, r7
57e17128:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
57e1712c:	e59d7010 	ldr	r7, [sp, #16]
			this->bbt[i >> 3] |= 0x03 << (i & 0x6);
57e17130:	e5953110 	ldr	r3, [r5, #272]	; 0x110
57e17134:	e2071006 	and	r1, r7, #6
57e17138:	e7d321c7 	ldrb	r2, [r3, r7, asr #3]
57e1713c:	e3a00003 	mov	r0, #3
57e17140:	e1822110 	orr	r2, r2, r0, lsl r1
57e17144:	e7c321c7 	strb	r2, [r3, r7, asr #3]
			MTDDEBUG(MTD_DEBUG_LEVEL0,
				  "Bad eraseblock %d at 0x%012llx\n",
				  i >> 1, (unsigned long long)from);
			mtd->ecc_stats.badblocks++;
57e17148:	e5943088 	ldr	r3, [r4, #136]	; 0x88
57e1714c:	e2833001 	add	r3, r3, #1
57e17150:	e5843088 	str	r3, [r4, #136]	; 0x88
		}

		i += 2;
		from += (1 << this->bbt_erase_shift);
57e17154:	e595305c 	ldr	r3, [r5, #92]	; 0x5c
57e17158:	e3a01001 	mov	r1, #1
57e1715c:	e1a03311 	lsl	r3, r1, r3
57e17160:	e28d1008 	add	r1, sp, #8
57e17164:	e8910003 	ldm	r1, {r0, r1}
57e17168:	e0900003 	adds	r0, r0, r3
				  "Bad eraseblock %d at 0x%012llx\n",
				  i >> 1, (unsigned long long)from);
			mtd->ecc_stats.badblocks++;
		}

		i += 2;
57e1716c:	e2877002 	add	r7, r7, #2
		from += (1 << this->bbt_erase_shift);
57e17170:	e0a11fc3 	adc	r1, r1, r3, asr #31
57e17174:	e58d0008 	str	r0, [sp, #8]
57e17178:	e58d100c 	str	r1, [sp, #12]
	}

	if (this->options & NAND_BBT_SCANLASTPAGE)
		from += mtd->erasesize - (mtd->writesize * len);

	for (i = startblock; i < numblocks;) {
57e1717c:	e59d1018 	ldr	r1, [sp, #24]
57e17180:	e1570001 	cmp	r7, r1
57e17184:	baffff85 	blt	57e16fa0 <create_bbt+0x138>
		}

		i += 2;
		from += (1 << this->bbt_erase_shift);
	}
	return 0;
57e17188:	e3a00000 	mov	r0, #0
}
57e1718c:	e28dd048 	add	sp, sp, #72	; 0x48
57e17190:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			return ret;

		if (check_short_pattern(buf, bd))
			return 1;

		offs += mtd->writesize;
57e17194:	e5943014 	ldr	r3, [r4, #20]
57e17198:	e28d1010 	add	r1, sp, #16
57e1719c:	e8910003 	ldm	r1, {r0, r1}
57e171a0:	e0900003 	adds	r0, r0, r3
57e171a4:	e2a11000 	adc	r1, r1, #0
57e171a8:	e58d0010 	str	r0, [sp, #16]
57e171ac:	e58d1014 	str	r1, [sp, #20]
	ops.oobbuf = buf;
	ops.ooboffs = 0;
	ops.datbuf = NULL;
	ops.mode = MTD_OOB_PLACE;

	for (j = 0; j < len; j++) {
57e171b0:	e28bb001 	add	fp, fp, #1
57e171b4:	eaffffd3 	b	57e17108 <create_bbt+0x2a0>
57e171b8:	57e33a55 	.word	0x57e33a55
57e171bc:	57e33a28 	.word	0x57e33a28
57e171c0:	57e33a45 	.word	0x57e33a45
57e171c4:	57e2c450 	.word	0x57e2c450
57e171c8:	57e33a50 	.word	0x57e33a50

57e171cc <search_bbt>:
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
57e171cc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
	int i, chips;
	int startblock, block, dir;
	int scanlen = mtd->writesize + mtd->oobsize;
57e171d0:	e5903014 	ldr	r3, [r0, #20]
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
57e171d4:	e1a04002 	mov	r4, r2
	struct nand_chip *this = mtd->priv;
	int i, chips;
	int startblock, block, dir;
	int scanlen = mtd->writesize + mtd->oobsize;
57e171d8:	e5902018 	ldr	r2, [r0, #24]
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
	struct nand_chip *this = mtd->priv;
57e171dc:	e5906094 	ldr	r6, [r0, #148]	; 0x94
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
57e171e0:	e24dd028 	sub	sp, sp, #40	; 0x28
	struct nand_chip *this = mtd->priv;
	int i, chips;
	int startblock, block, dir;
	int scanlen = mtd->writesize + mtd->oobsize;
57e171e4:	e0823003 	add	r3, r2, r3
57e171e8:	e58d301c 	str	r3, [sp, #28]
	int bbtblocks;
	int blocktopage = this->bbt_erase_shift - this->page_shift;
57e171ec:	e596a05c 	ldr	sl, [r6, #92]	; 0x5c
57e171f0:	e5963054 	ldr	r3, [r6, #84]	; 0x54

	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
57e171f4:	e5949000 	ldr	r9, [r4]
	struct nand_chip *this = mtd->priv;
	int i, chips;
	int startblock, block, dir;
	int scanlen = mtd->writesize + mtd->oobsize;
	int bbtblocks;
	int blocktopage = this->bbt_erase_shift - this->page_shift;
57e171f8:	e063300a 	rsb	r3, r3, sl

	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
57e171fc:	e2197010 	ands	r7, r9, #16
	struct nand_chip *this = mtd->priv;
	int i, chips;
	int startblock, block, dir;
	int scanlen = mtd->writesize + mtd->oobsize;
	int bbtblocks;
	int blocktopage = this->bbt_erase_shift - this->page_shift;
57e17200:	e58d3020 	str	r3, [sp, #32]
	if (td->options & NAND_BBT_LASTBLOCK) {
		startblock = (mtd->size >> this->bbt_erase_shift) - 1;
		dir = -1;
	} else {
		startblock = 0;
		dir = 1;
57e17204:	03a03001 	moveq	r3, #1
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
{
57e17208:	e1a05000 	mov	r5, r0
57e1720c:	e58d1010 	str	r1, [sp, #16]
	if (td->options & NAND_BBT_LASTBLOCK) {
		startblock = (mtd->size >> this->bbt_erase_shift) - 1;
		dir = -1;
	} else {
		startblock = 0;
		dir = 1;
57e17210:	058d3014 	streq	r3, [sp, #20]
	int scanlen = mtd->writesize + mtd->oobsize;
	int bbtblocks;
	int blocktopage = this->bbt_erase_shift - this->page_shift;

	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
57e17214:	0a000006 	beq	57e17234 <search_bbt+0x68>
		startblock = (mtd->size >> this->bbt_erase_shift) - 1;
57e17218:	e1a0200a 	mov	r2, sl
57e1721c:	e2801008 	add	r1, r0, #8
57e17220:	e8910003 	ldm	r1, {r0, r1}
57e17224:	eb005274 	bl	57e2bbfc <__lshrdi3>
		dir = -1;
57e17228:	e3e02000 	mvn	r2, #0
	int bbtblocks;
	int blocktopage = this->bbt_erase_shift - this->page_shift;

	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
		startblock = (mtd->size >> this->bbt_erase_shift) - 1;
57e1722c:	e2407001 	sub	r7, r0, #1
		dir = -1;
57e17230:	e58d2014 	str	r2, [sp, #20]
		startblock = 0;
		dir = 1;
	}

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e17234:	e3190080 	tst	r9, #128	; 0x80
		chips = this->numchips;
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
		startblock &= bbtblocks - 1;
	} else {
		chips = 1;
57e17238:	03a03001 	moveq	r3, #1
57e1723c:	058d300c 	streq	r3, [sp, #12]
		startblock = 0;
		dir = 1;
	}

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e17240:	0a000007 	beq	57e17264 <search_bbt+0x98>
		chips = this->numchips;
57e17244:	e5962064 	ldr	r2, [r6, #100]	; 0x64
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
57e17248:	e2861068 	add	r1, r6, #104	; 0x68
57e1724c:	e8910003 	ldm	r1, {r0, r1}
		dir = 1;
	}

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
57e17250:	e58d200c 	str	r2, [sp, #12]
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
57e17254:	e1a0200a 	mov	r2, sl
57e17258:	eb005267 	bl	57e2bbfc <__lshrdi3>
		startblock &= bbtblocks - 1;
57e1725c:	e2400001 	sub	r0, r0, #1
57e17260:	e0077000 	and	r7, r7, r0
 * This is necessary to provide support for certain DOC devices.
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
57e17264:	e284b010 	add	fp, r4, #16

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		bbtblocks = this->chipsize >> this->bbt_erase_shift;
		startblock &= bbtblocks - 1;
57e17268:	e58d4024 	str	r4, [sp, #36]	; 0x24
	} else {
		chips = 1;
		bbtblocks = mtd->size >> this->bbt_erase_shift;
	}

	for (i = 0; i < chips; i++) {
57e1726c:	e3a09000 	mov	r9, #0
57e17270:	e1a0a004 	mov	sl, r4
57e17274:	ea000041 	b	57e17380 <search_bbt+0x1b4>
		/* Reset version information */
		td->version[i] = 0;
		td->pages[i] = -1;
57e17278:	e3e03000 	mvn	r3, #0
57e1727c:	e5aa3004 	str	r3, [sl, #4]!
		bbtblocks = mtd->size >> this->bbt_erase_shift;
	}

	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
57e17280:	e3a02000 	mov	r2, #0
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {
57e17284:	e3a0c000 	mov	ip, #0
		bbtblocks = mtd->size >> this->bbt_erase_shift;
	}

	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
57e17288:	e4cb2001 	strb	r2, [fp], #1
57e1728c:	e58d9018 	str	r9, [sp, #24]
57e17290:	e1a0900a 	mov	r9, sl
57e17294:	e1a0a007 	mov	sl, r7
57e17298:	e1a07006 	mov	r7, r6
57e1729c:	e1a0600c 	mov	r6, ip
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {
57e172a0:	ea000029 	b	57e1734c <search_bbt+0x180>

			int actblock = startblock + dir * block;
57e172a4:	e59d2014 	ldr	r2, [sp, #20]
57e172a8:	e02ca692 	mla	ip, r2, r6, sl
			loff_t offs = (loff_t)actblock << this->bbt_erase_shift;
57e172ac:	e597205c 	ldr	r2, [r7, #92]	; 0x5c
57e172b0:	e1a0000c 	mov	r0, ip
57e172b4:	e1a01fc0 	asr	r1, r0, #31
57e172b8:	e58dc008 	str	ip, [sp, #8]
57e172bc:	eb00525c 	bl	57e2bc34 <__ashldi3>
57e172c0:	e1a03001 	mov	r3, r1

			/* Read first page */
			scan_read_raw(mtd, buf, offs, mtd->writesize, td);
57e172c4:	e5951014 	ldr	r1, [r5, #20]
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {

			int actblock = startblock + dir * block;
			loff_t offs = (loff_t)actblock << this->bbt_erase_shift;
57e172c8:	e1a02000 	mov	r2, r0

			/* Read first page */
			scan_read_raw(mtd, buf, offs, mtd->writesize, td);
57e172cc:	e58d1000 	str	r1, [sp]
57e172d0:	e1a00005 	mov	r0, r5
57e172d4:	e59d1010 	ldr	r1, [sp, #16]
57e172d8:	e58d4004 	str	r4, [sp, #4]
57e172dc:	ebfffb95 	bl	57e16138 <scan_read_raw>
			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
57e172e0:	e59d0010 	ldr	r0, [sp, #16]
57e172e4:	e59d101c 	ldr	r1, [sp, #28]
57e172e8:	e5952014 	ldr	r2, [r5, #20]
57e172ec:	e1a03004 	mov	r3, r4
57e172f0:	ebfffe8c 	bl	57e16d28 <check_pattern>
57e172f4:	e3500000 	cmp	r0, #0
57e172f8:	e59dc008 	ldr	ip, [sp, #8]
57e172fc:	1a000011 	bne	57e17348 <search_bbt+0x17c>
				td->pages[i] = actblock << blocktopage;
57e17300:	e59d2020 	ldr	r2, [sp, #32]
57e17304:	e1a06007 	mov	r6, r7
57e17308:	e1a0321c 	lsl	r3, ip, r2
				if (td->options & NAND_BBT_VERSION) {
57e1730c:	e5942000 	ldr	r2, [r4]
57e17310:	e1a0700a 	mov	r7, sl
57e17314:	e3120c01 	tst	r2, #256	; 0x100
57e17318:	e1a0a009 	mov	sl, r9
57e1731c:	e59d9018 	ldr	r9, [sp, #24]
			loff_t offs = (loff_t)actblock << this->bbt_erase_shift;

			/* Read first page */
			scan_read_raw(mtd, buf, offs, mtd->writesize, td);
			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
				td->pages[i] = actblock << blocktopage;
57e17320:	e58a3000 	str	r3, [sl]
				if (td->options & NAND_BBT_VERSION) {
57e17324:	0a00000f 	beq	57e17368 <search_bbt+0x19c>

static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	u32 ver_offs = td->veroffs;

	if (!(td->options & NAND_BBT_NO_OOB))
57e17328:	e3120501 	tst	r2, #4194304	; 0x400000
		ver_offs += mtd->writesize;
57e1732c:	05952014 	ldreq	r2, [r5, #20]
	return mtd->write_oob(mtd, offs, &ops);
}

static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	u32 ver_offs = td->veroffs;
57e17330:	e594300c 	ldr	r3, [r4, #12]

	if (!(td->options & NAND_BBT_NO_OOB))
		ver_offs += mtd->writesize;
57e17334:	00833002 	addeq	r3, r3, r2
			scan_read_raw(mtd, buf, offs, mtd->writesize, td);
			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
				td->pages[i] = actblock << blocktopage;
				if (td->options & NAND_BBT_VERSION) {
					offs = bbt_get_ver_offs(mtd, td);
					td->version[i] = buf[offs];
57e17338:	e59d2010 	ldr	r2, [sp, #16]
57e1733c:	e7d23003 	ldrb	r3, [r2, r3]
57e17340:	e54b3001 	strb	r3, [fp, #-1]
57e17344:	ea000007 	b	57e17368 <search_bbt+0x19c>
	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {
57e17348:	e2866001 	add	r6, r6, #1
57e1734c:	e5943018 	ldr	r3, [r4, #24]
57e17350:	e1560003 	cmp	r6, r3
57e17354:	baffffd2 	blt	57e172a4 <search_bbt+0xd8>
57e17358:	e1a06007 	mov	r6, r7
57e1735c:	e1a0700a 	mov	r7, sl
57e17360:	e1a0a009 	mov	sl, r9
57e17364:	e59d9018 	ldr	r9, [sp, #24]
					td->version[i] = buf[offs];
				}
				break;
			}
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
57e17368:	e2861068 	add	r1, r6, #104	; 0x68
57e1736c:	e8910003 	ldm	r1, {r0, r1}
57e17370:	e596205c 	ldr	r2, [r6, #92]	; 0x5c
57e17374:	eb005220 	bl	57e2bbfc <__lshrdi3>
	} else {
		chips = 1;
		bbtblocks = mtd->size >> this->bbt_erase_shift;
	}

	for (i = 0; i < chips; i++) {
57e17378:	e2899001 	add	r9, r9, #1
					td->version[i] = buf[offs];
				}
				break;
			}
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
57e1737c:	e0877000 	add	r7, r7, r0
	} else {
		chips = 1;
		bbtblocks = mtd->size >> this->bbt_erase_shift;
	}

	for (i = 0; i < chips; i++) {
57e17380:	e59d300c 	ldr	r3, [sp, #12]
57e17384:	e1590003 	cmp	r9, r3
57e17388:	baffffba 	blt	57e17278 <search_bbt+0xac>
57e1738c:	e3a04000 	mov	r4, #0
57e17390:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
57e17394:	ea000006 	b	57e173b4 <search_bbt+0x1e8>
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
	}
	/* Check, if we found a bbt for each requested chip */
	for (i = 0; i < chips; i++) {
		if (td->pages[i] == -1)
57e17398:	e5b53004 	ldr	r3, [r5, #4]!
57e1739c:	e3730001 	cmn	r3, #1
57e173a0:	1a000002 	bne	57e173b0 <search_bbt+0x1e4>
			printk(KERN_WARNING "Bad block table not found for chip %d\n", i);
57e173a4:	e59f0020 	ldr	r0, [pc, #32]	; 57e173cc <search_bbt+0x200>
57e173a8:	e1a01004 	mov	r1, r4
57e173ac:	ebffc826 	bl	57e0944c <printf>
			}
		}
		startblock += this->chipsize >> this->bbt_erase_shift;
	}
	/* Check, if we found a bbt for each requested chip */
	for (i = 0; i < chips; i++) {
57e173b0:	e2844001 	add	r4, r4, #1
57e173b4:	e59d200c 	ldr	r2, [sp, #12]
57e173b8:	e1540002 	cmp	r4, r2
57e173bc:	bafffff5 	blt	57e17398 <search_bbt+0x1cc>
			MTDDEBUG(MTD_DEBUG_LEVEL0, "Bad block table found " \
				"at page %d, version 0x%02X\n", td->pages[i],
				td->version[i]);
	}
	return 0;
}
57e173c0:	e3a00000 	mov	r0, #0
57e173c4:	e28dd028 	add	sp, sp, #40	; 0x28
57e173c8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e173cc:	57e33a87 	.word	0x57e33a87

57e173d0 <nand_update_bbt>:
 * @offs:	the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_bbt(struct mtd_info *mtd, loff_t offs)
{
57e173d0:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
57e173d4:	e5907094 	ldr	r7, [r0, #148]	; 0x94
 * @offs:	the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_bbt(struct mtd_info *mtd, loff_t offs)
{
57e173d8:	e1a06000 	mov	r6, r0
	struct nand_chip *this = mtd->priv;
	int len, res = 0, writeops = 0;
	int chip, chipsel;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
57e173dc:	e5975114 	ldr	r5, [r7, #276]	; 0x114
	struct nand_bbt_descr *md = this->bbt_md;

	if (!this->bbt || !td)
57e173e0:	e5971110 	ldr	r1, [r7, #272]	; 0x110
	struct nand_chip *this = mtd->priv;
	int len, res = 0, writeops = 0;
	int chip, chipsel;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;
57e173e4:	e5974118 	ldr	r4, [r7, #280]	; 0x118

	if (!this->bbt || !td)
57e173e8:	e3510000 	cmp	r1, #0
57e173ec:	13550000 	cmpne	r5, #0
		return -EINVAL;
57e173f0:	03e09015 	mvneq	r9, #21
	int chip, chipsel;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	if (!this->bbt || !td)
57e173f4:	0a000040 	beq	57e174fc <nand_update_bbt+0x12c>
		return -EINVAL;

	/* Allocate a temporary buffer for one eraseblock incl. oob */
	len = (1 << this->bbt_erase_shift);
57e173f8:	e597105c 	ldr	r1, [r7, #92]	; 0x5c
57e173fc:	e3a00001 	mov	r0, #1
57e17400:	e1a01110 	lsl	r1, r0, r1
	len += (len >> this->page_shift) * mtd->oobsize;
57e17404:	e5970054 	ldr	r0, [r7, #84]	; 0x54
57e17408:	e596c018 	ldr	ip, [r6, #24]
57e1740c:	e1a00051 	asr	r0, r1, r0
	buf = kmalloc(len, GFP_KERNEL);
57e17410:	e020109c 	mla	r0, ip, r0, r1
57e17414:	e58d200c 	str	r2, [sp, #12]
57e17418:	e58d3008 	str	r3, [sp, #8]
57e1741c:	ebffc9e8 	bl	57e09bc4 <malloc>
	if (!buf) {
57e17420:	e250a000 	subs	sl, r0, #0
57e17424:	e59d200c 	ldr	r2, [sp, #12]
57e17428:	e59d3008 	ldr	r3, [sp, #8]
57e1742c:	1a000003 	bne	57e17440 <nand_update_bbt+0x70>
		printk(KERN_ERR "nand_update_bbt: Out of memory\n");
57e17430:	e59f00d0 	ldr	r0, [pc, #208]	; 57e17508 <nand_update_bbt+0x138>
57e17434:	ebffc804 	bl	57e0944c <printf>
		return -ENOMEM;
57e17438:	e3e0900b 	mvn	r9, #11
57e1743c:	ea00002e 	b	57e174fc <nand_update_bbt+0x12c>
	}

	writeops = md != NULL ? 0x03 : 0x01;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e17440:	e5959000 	ldr	r9, [r5]
	if (!buf) {
		printk(KERN_ERR "nand_update_bbt: Out of memory\n");
		return -ENOMEM;
	}

	writeops = md != NULL ? 0x03 : 0x01;
57e17444:	e3540000 	cmp	r4, #0
57e17448:	03a0b001 	moveq	fp, #1
57e1744c:	13a0b003 	movne	fp, #3

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e17450:	e2190080 	ands	r0, r9, #128	; 0x80
		chip = (int)(offs >> this->chip_shift);
		chipsel = chip;
	} else {
		chip = 0;
		chipsel = -1;
57e17454:	03e07000 	mvneq	r7, #0
	}

	writeops = md != NULL ? 0x03 : 0x01;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e17458:	0a000004 	beq	57e17470 <nand_update_bbt+0xa0>
		chip = (int)(offs >> this->chip_shift);
57e1745c:	e1a00002 	mov	r0, r2
57e17460:	e1a01003 	mov	r1, r3
57e17464:	e5972060 	ldr	r2, [r7, #96]	; 0x60
57e17468:	eb0051ea 	bl	57e2bc18 <__ashrdi3>
		chipsel = chip;
57e1746c:	e1a07000 	mov	r7, r0
	} else {
		chip = 0;
		chipsel = -1;
	}

	td->version[chip]++;
57e17470:	e0853000 	add	r3, r5, r0
57e17474:	e5d32010 	ldrb	r2, [r3, #16]
	if (md)
57e17478:	e3540000 	cmp	r4, #0
	} else {
		chip = 0;
		chipsel = -1;
	}

	td->version[chip]++;
57e1747c:	e2822001 	add	r2, r2, #1
57e17480:	e5c32010 	strb	r2, [r3, #16]
	if (md)
		md->version[chip]++;
57e17484:	10840000 	addne	r0, r4, r0
57e17488:	15d03010 	ldrbne	r3, [r0, #16]
57e1748c:	12833001 	addne	r3, r3, #1
57e17490:	15c03010 	strbne	r3, [r0, #16]

	/* Write the bad block table to the device ? */
	if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
57e17494:	e2199a01 	ands	r9, r9, #4096	; 0x1000
57e17498:	0a000007 	beq	57e174bc <nand_update_bbt+0xec>
		res = write_bbt(mtd, buf, td, md, chipsel);
57e1749c:	e1a00006 	mov	r0, r6
57e174a0:	e1a0100a 	mov	r1, sl
57e174a4:	e1a02005 	mov	r2, r5
57e174a8:	e1a03004 	mov	r3, r4
57e174ac:	e58d7000 	str	r7, [sp]
57e174b0:	ebfffc07 	bl	57e164d4 <write_bbt>
		if (res < 0)
57e174b4:	e2509000 	subs	r9, r0, #0
57e174b8:	ba00000d 	blt	57e174f4 <nand_update_bbt+0x124>
			goto out;
	}
	/* Write the mirror bad block table to the device ? */
	if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
57e174bc:	e2543000 	subs	r3, r4, #0
57e174c0:	13a03001 	movne	r3, #1
57e174c4:	e01330ab 	ands	r3, r3, fp, lsr #1
57e174c8:	0a000009 	beq	57e174f4 <nand_update_bbt+0x124>
57e174cc:	e5943000 	ldr	r3, [r4]
57e174d0:	e3130a01 	tst	r3, #4096	; 0x1000
57e174d4:	0a000006 	beq	57e174f4 <nand_update_bbt+0x124>
		res = write_bbt(mtd, buf, md, td, chipsel);
57e174d8:	e1a00006 	mov	r0, r6
57e174dc:	e1a0100a 	mov	r1, sl
57e174e0:	e1a02004 	mov	r2, r4
57e174e4:	e1a03005 	mov	r3, r5
57e174e8:	e58d7000 	str	r7, [sp]
57e174ec:	ebfffbf8 	bl	57e164d4 <write_bbt>
57e174f0:	e1a09000 	mov	r9, r0
	}

 out:
	kfree(buf);
57e174f4:	e1a0000a 	mov	r0, sl
57e174f8:	ebffc927 	bl	57e0999c <free>
	return res;
}
57e174fc:	e1a00009 	mov	r0, r9
57e17500:	e28dd010 	add	sp, sp, #16
57e17504:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e17508:	57e33aae 	.word	0x57e33aae

57e1750c <mark_bbt_region>:
	struct nand_chip *this = mtd->priv;
	int i, j, chips, block, nrblocks, update;
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e1750c:	e5913000 	ldr	r3, [r1]
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
57e17510:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
	int i, j, chips, block, nrblocks, update;
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e17514:	e3130080 	tst	r3, #128	; 0x80
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
57e17518:	e1a07000 	mov	r7, r0
57e1751c:	e1a05001 	mov	r5, r1
	struct nand_chip *this = mtd->priv;
57e17520:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int i, j, chips, block, nrblocks, update;
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
57e17524:	0a000006 	beq	57e17544 <mark_bbt_region+0x38>
		chips = this->numchips;
		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
57e17528:	e2841068 	add	r1, r4, #104	; 0x68
57e1752c:	e8910003 	ldm	r1, {r0, r1}
57e17530:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
57e17534:	eb0051b0 	bl	57e2bbfc <__lshrdi3>
	int i, j, chips, block, nrblocks, update;
	uint8_t oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
57e17538:	e594b064 	ldr	fp, [r4, #100]	; 0x64
		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
57e1753c:	e1a09000 	mov	r9, r0
57e17540:	ea000005 	b	57e1755c <mark_bbt_region+0x50>
	} else {
		chips = 1;
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
57e17544:	e2801008 	add	r1, r0, #8
57e17548:	e8910003 	ldm	r1, {r0, r1}
57e1754c:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
57e17550:	eb0051a9 	bl	57e2bbfc <__lshrdi3>
	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = this->numchips;
		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
	} else {
		chips = 1;
57e17554:	e3a0b001 	mov	fp, #1
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
57e17558:	e1a09000 	mov	r9, r0
	}

	for (i = 0; i < chips; i++) {
57e1755c:	e3a06000 	mov	r6, #0
57e17560:	e1a0a006 	mov	sl, r6
57e17564:	ea000044 	b	57e1767c <mark_bbt_region+0x170>
		if ((td->options & NAND_BBT_ABSPAGE) ||
57e17568:	e5952000 	ldr	r2, [r5]
57e1756c:	e59f3114 	ldr	r3, [pc, #276]	; 57e17688 <mark_bbt_region+0x17c>
57e17570:	e0023003 	and	r3, r2, r3
57e17574:	e3530a01 	cmp	r3, #4096	; 0x1000
57e17578:	0a000015 	beq	57e175d4 <mark_bbt_region+0xc8>
 *
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)
57e1757c:	e085310a 	add	r3, r5, sl, lsl #2
	}

	for (i = 0; i < chips; i++) {
		if ((td->options & NAND_BBT_ABSPAGE) ||
		    !(td->options & NAND_BBT_WRITE)) {
			if (td->pages[i] == -1)
57e17580:	e5933004 	ldr	r3, [r3, #4]
57e17584:	e3730001 	cmn	r3, #1
57e17588:	0a000039 	beq	57e17674 <mark_bbt_region+0x168>
				continue;
			block = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);
57e1758c:	e5942054 	ldr	r2, [r4, #84]	; 0x54
57e17590:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
			block <<= 1;
			oldval = this->bbt[(block >> 3)];
57e17594:	e5941110 	ldr	r1, [r4, #272]	; 0x110
	for (i = 0; i < chips; i++) {
		if ((td->options & NAND_BBT_ABSPAGE) ||
		    !(td->options & NAND_BBT_WRITE)) {
			if (td->pages[i] == -1)
				continue;
			block = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);
57e17598:	e0620000 	rsb	r0, r2, r0
57e1759c:	e1a00053 	asr	r0, r3, r0
			block <<= 1;
57e175a0:	e1a00080 	lsl	r0, r0, #1
			oldval = this->bbt[(block >> 3)];
57e175a4:	e7d121c0 	ldrb	r2, [r1, r0, asr #3]
			newval = oldval | (0x2 << (block & 0x06));
57e175a8:	e2003006 	and	r3, r0, #6
57e175ac:	e3a0c002 	mov	ip, #2
57e175b0:	e182331c 	orr	r3, r2, ip, lsl r3
57e175b4:	e20330ff 	and	r3, r3, #255	; 0xff
			this->bbt[(block >> 3)] = newval;
			if ((oldval != newval) && td->reserved_block_code)
57e175b8:	e1520003 	cmp	r2, r3
				continue;
			block = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);
			block <<= 1;
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			this->bbt[(block >> 3)] = newval;
57e175bc:	e7c131c0 	strb	r3, [r1, r0, asr #3]
			if ((oldval != newval) && td->reserved_block_code)
57e175c0:	0a00002b 	beq	57e17674 <mark_bbt_region+0x168>
57e175c4:	e595301c 	ldr	r3, [r5, #28]
57e175c8:	e3530000 	cmp	r3, #0
57e175cc:	0a000028 	beq	57e17674 <mark_bbt_region+0x168>
57e175d0:	ea00001f 	b	57e17654 <mark_bbt_region+0x148>
				nand_update_bbt(mtd, (loff_t)block << (this->bbt_erase_shift - 1));
			continue;
		}
		update = 0;
		if (td->options & NAND_BBT_LASTBLOCK)
57e175d4:	e3120010 	tst	r2, #16
			block = ((i + 1) * nrblocks) - td->maxblocks;
57e175d8:	15953018 	ldrne	r3, [r5, #24]
 *
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)
57e175dc:	10860009 	addne	r0, r6, r9
				nand_update_bbt(mtd, (loff_t)block << (this->bbt_erase_shift - 1));
			continue;
		}
		update = 0;
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
57e175e0:	10630000 	rsbne	r0, r3, r0
57e175e4:	01a00006 	moveq	r0, r6
			this->bbt[(block >> 3)] = newval;
			if ((oldval != newval) && td->reserved_block_code)
				nand_update_bbt(mtd, (loff_t)block << (this->bbt_erase_shift - 1));
			continue;
		}
		update = 0;
57e175e8:	e3a03000 	mov	r3, #0
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
57e175ec:	e1a00080 	lsl	r0, r0, #1
		for (j = 0; j < td->maxblocks; j++) {
57e175f0:	e1a02003 	mov	r2, r3
57e175f4:	e58d6004 	str	r6, [sp, #4]
57e175f8:	ea00000b 	b	57e1762c <mark_bbt_region+0x120>
			oldval = this->bbt[(block >> 3)];
57e175fc:	e5941110 	ldr	r1, [r4, #272]	; 0x110
			newval = oldval | (0x2 << (block & 0x06));
57e17600:	e3a06002 	mov	r6, #2
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
			oldval = this->bbt[(block >> 3)];
57e17604:	e7d1c1c0 	ldrb	ip, [r1, r0, asr #3]
			newval = oldval | (0x2 << (block & 0x06));
57e17608:	e2001006 	and	r1, r0, #6
57e1760c:	e18c1116 	orr	r1, ip, r6, lsl r1
			this->bbt[(block >> 3)] = newval;
57e17610:	e5946110 	ldr	r6, [r4, #272]	; 0x110
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
57e17614:	e20110ff 	and	r1, r1, #255	; 0xff
			this->bbt[(block >> 3)] = newval;
			if (oldval != newval)
				update = 1;
57e17618:	e15c0001 	cmp	ip, r1
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
			oldval = this->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			this->bbt[(block >> 3)] = newval;
57e1761c:	e7c611c0 	strb	r1, [r6, r0, asr #3]
			if (oldval != newval)
				update = 1;
57e17620:	13a03001 	movne	r3, #1
			block += 2;
57e17624:	e2800002 	add	r0, r0, #2
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
57e17628:	e2822001 	add	r2, r2, #1
57e1762c:	e5951018 	ldr	r1, [r5, #24]
57e17630:	e1520001 	cmp	r2, r1
57e17634:	bafffff0 	blt	57e175fc <mark_bbt_region+0xf0>
			block += 2;
		}
		/* If we want reserved blocks to be recorded to flash, and some
		   new ones have been marked, then we need to update the stored
		   bbts.  This should only happen once. */
		if (update && td->reserved_block_code)
57e17638:	e3530000 	cmp	r3, #0
57e1763c:	e59d6004 	ldr	r6, [sp, #4]
57e17640:	0a00000b 	beq	57e17674 <mark_bbt_region+0x168>
57e17644:	e595301c 	ldr	r3, [r5, #28]
57e17648:	e3530000 	cmp	r3, #0
57e1764c:	0a000008 	beq	57e17674 <mark_bbt_region+0x168>
			nand_update_bbt(mtd, (loff_t)(block - 2) << (this->bbt_erase_shift - 1));
57e17650:	e2400002 	sub	r0, r0, #2
57e17654:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
57e17658:	e1a01fc0 	asr	r1, r0, #31
57e1765c:	e2422001 	sub	r2, r2, #1
57e17660:	eb005173 	bl	57e2bc34 <__ashldi3>
57e17664:	e1a02000 	mov	r2, r0
57e17668:	e1a03001 	mov	r3, r1
57e1766c:	e1a00007 	mov	r0, r7
57e17670:	ebffff56 	bl	57e173d0 <nand_update_bbt>
	} else {
		chips = 1;
		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
	}

	for (i = 0; i < chips; i++) {
57e17674:	e28aa001 	add	sl, sl, #1
57e17678:	e0866009 	add	r6, r6, r9
57e1767c:	e15a000b 	cmp	sl, fp
57e17680:	baffffb8 	blt	57e17568 <mark_bbt_region+0x5c>
		   new ones have been marked, then we need to update the stored
		   bbts.  This should only happen once. */
		if (update && td->reserved_block_code)
			nand_update_bbt(mtd, (loff_t)(block - 2) << (this->bbt_erase_shift - 1));
	}
}
57e17684:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e17688:	00001020 	.word	0x00001020

57e1768c <nand_scan_bbt>:
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
57e1768c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct nand_chip *this = mtd->priv;
57e17690:	e5907094 	ldr	r7, [r0, #148]	; 0x94
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
57e17694:	e24dd030 	sub	sp, sp, #48	; 0x30
	int len, res = 0;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	len = mtd->size >> (this->bbt_erase_shift + 2);
57e17698:	e597205c 	ldr	r2, [r7, #92]	; 0x5c
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
57e1769c:	e58d1020 	str	r1, [sp, #32]
	int len, res = 0;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	len = mtd->size >> (this->bbt_erase_shift + 2);
57e176a0:	e2822002 	add	r2, r2, #2
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
57e176a4:	e1a04000 	mov	r4, r0
	int len, res = 0;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	len = mtd->size >> (this->bbt_erase_shift + 2);
57e176a8:	e2801008 	add	r1, r0, #8
57e176ac:	e8910003 	ldm	r1, {r0, r1}
57e176b0:	eb005151 	bl	57e2bbfc <__lshrdi3>
	/* Allocate memory (2bit per block) and clear the memory bad block table */
	this->bbt = kzalloc(len, GFP_KERNEL);
57e176b4:	e3a01001 	mov	r1, #1
int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct nand_chip *this = mtd->priv;
	int len, res = 0;
	uint8_t *buf;
	struct nand_bbt_descr *td = this->bbt_td;
57e176b8:	e5975114 	ldr	r5, [r7, #276]	; 0x114
	struct nand_bbt_descr *md = this->bbt_md;
57e176bc:	e5976118 	ldr	r6, [r7, #280]	; 0x118

	len = mtd->size >> (this->bbt_erase_shift + 2);
	/* Allocate memory (2bit per block) and clear the memory bad block table */
	this->bbt = kzalloc(len, GFP_KERNEL);
57e176c0:	ebffcaad 	bl	57e0a17c <calloc>
	if (!this->bbt) {
57e176c4:	e3500000 	cmp	r0, #0
	struct nand_bbt_descr *td = this->bbt_td;
	struct nand_bbt_descr *md = this->bbt_md;

	len = mtd->size >> (this->bbt_erase_shift + 2);
	/* Allocate memory (2bit per block) and clear the memory bad block table */
	this->bbt = kzalloc(len, GFP_KERNEL);
57e176c8:	e5870110 	str	r0, [r7, #272]	; 0x110
	if (!this->bbt) {
57e176cc:	1a000002 	bne	57e176dc <nand_scan_bbt+0x50>
		printk(KERN_ERR "nand_scan_bbt: Out of memory\n");
57e176d0:	e59f049c 	ldr	r0, [pc, #1180]	; 57e17b74 <nand_scan_bbt+0x4e8>
57e176d4:	ebffc75c 	bl	57e0944c <printf>
57e176d8:	ea000029 	b	57e17784 <nand_scan_bbt+0xf8>
	}

	/* If no primary table decriptor is given, scan the device
	 * to build a memory based bad block table
	 */
	if (!td) {
57e176dc:	e3550000 	cmp	r5, #0
57e176e0:	1a000012 	bne	57e17730 <nand_scan_bbt+0xa4>
*/
static inline int nand_memory_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct nand_chip *this = mtd->priv;

	bd->options &= ~NAND_BBT_SCANEMPTY;
57e176e4:	e59d0020 	ldr	r0, [sp, #32]
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
*/
static inline int nand_memory_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct nand_chip *this = mtd->priv;
57e176e8:	e5943094 	ldr	r3, [r4, #148]	; 0x94

	bd->options &= ~NAND_BBT_SCANEMPTY;
57e176ec:	e5902000 	ldr	r2, [r0]
	return create_bbt(mtd, this->buffers->databuf, bd, -1);
57e176f0:	e59310e8 	ldr	r1, [r3, #232]	; 0xe8
*/
static inline int nand_memory_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct nand_chip *this = mtd->priv;

	bd->options &= ~NAND_BBT_SCANEMPTY;
57e176f4:	e3c22b02 	bic	r2, r2, #2048	; 0x800
57e176f8:	e5802000 	str	r2, [r0]
	return create_bbt(mtd, this->buffers->databuf, bd, -1);
57e176fc:	e2811d12 	add	r1, r1, #1152	; 0x480
57e17700:	e1a00004 	mov	r0, r4
57e17704:	e59d2020 	ldr	r2, [sp, #32]
57e17708:	e3e03000 	mvn	r3, #0
57e1770c:	ebfffdd5 	bl	57e16e68 <create_bbt>

	/* If no primary table decriptor is given, scan the device
	 * to build a memory based bad block table
	 */
	if (!td) {
		if ((res = nand_memory_bbt(mtd, bd))) {
57e17710:	e2509000 	subs	r9, r0, #0
57e17714:	0a00010f 	beq	57e17b58 <nand_scan_bbt+0x4cc>
			printk(KERN_ERR "nand_bbt: Can't scan flash and build the RAM-based BBT\n");
57e17718:	e59f0458 	ldr	r0, [pc, #1112]	; 57e17b78 <nand_scan_bbt+0x4ec>
57e1771c:	ebffc74a 	bl	57e0944c <printf>
			kfree(this->bbt);
57e17720:	e5970110 	ldr	r0, [r7, #272]	; 0x110
57e17724:	ebffc89c 	bl	57e0999c <free>
			this->bbt = NULL;
57e17728:	e5875110 	str	r5, [r7, #272]	; 0x110
57e1772c:	ea000109 	b	57e17b58 <nand_scan_bbt+0x4cc>
		}
		return res;
	}
	verify_bbt_descr(mtd, td);
57e17730:	e1a00004 	mov	r0, r4
57e17734:	e1a01005 	mov	r1, r5
57e17738:	ebfffd22 	bl	57e16bc8 <verify_bbt_descr>
	verify_bbt_descr(mtd, md);
57e1773c:	e1a00004 	mov	r0, r4
57e17740:	e1a01006 	mov	r1, r6
57e17744:	ebfffd1f 	bl	57e16bc8 <verify_bbt_descr>

	/* Allocate a temporary buffer for one eraseblock incl. oob */
	len = (1 << this->bbt_erase_shift);
57e17748:	e597305c 	ldr	r3, [r7, #92]	; 0x5c
57e1774c:	e3a02001 	mov	r2, #1
57e17750:	e1a03312 	lsl	r3, r2, r3
	len += (len >> this->page_shift) * mtd->oobsize;
57e17754:	e5972054 	ldr	r2, [r7, #84]	; 0x54
57e17758:	e5940018 	ldr	r0, [r4, #24]
57e1775c:	e1a02253 	asr	r2, r3, r2
	buf = vmalloc(len);
57e17760:	e0203092 	mla	r0, r2, r0, r3
57e17764:	ebffc916 	bl	57e09bc4 <malloc>
	if (!buf) {
57e17768:	e250a000 	subs	sl, r0, #0
57e1776c:	1a000006 	bne	57e1778c <nand_scan_bbt+0x100>
		printk(KERN_ERR "nand_bbt: Out of memory\n");
57e17770:	e59f0404 	ldr	r0, [pc, #1028]	; 57e17b7c <nand_scan_bbt+0x4f0>
57e17774:	ebffc734 	bl	57e0944c <printf>
		kfree(this->bbt);
57e17778:	e5970110 	ldr	r0, [r7, #272]	; 0x110
57e1777c:	ebffc886 	bl	57e0999c <free>
		this->bbt = NULL;
57e17780:	e587a110 	str	sl, [r7, #272]	; 0x110
		return -ENOMEM;
57e17784:	e3e0900b 	mvn	r9, #11
57e17788:	ea0000f2 	b	57e17b58 <nand_scan_bbt+0x4cc>
	}

	/* Is the bbt at a given page ? */
	if (td->options & NAND_BBT_ABSPAGE) {
57e1778c:	e5953000 	ldr	r3, [r5]
57e17790:	e3130020 	tst	r3, #32
57e17794:	0a000034 	beq	57e1786c <nand_scan_bbt+0x1e0>
			 struct nand_bbt_descr *td, struct nand_bbt_descr *md)
{
	struct nand_chip *this = mtd->priv;

	/* Read the primary version, if available */
	if (td->options & NAND_BBT_VERSION) {
57e17798:	e3130c01 	tst	r3, #256	; 0x100
 *
*/
static int read_abs_bbts(struct mtd_info *mtd, uint8_t *buf,
			 struct nand_bbt_descr *td, struct nand_bbt_descr *md)
{
	struct nand_chip *this = mtd->priv;
57e1779c:	e5947094 	ldr	r7, [r4, #148]	; 0x94

	/* Read the primary version, if available */
	if (td->options & NAND_BBT_VERSION) {
57e177a0:	0a000015 	beq	57e177fc <nand_scan_bbt+0x170>
		scan_read_raw(mtd, buf, (loff_t)td->pages[0] << this->page_shift,
57e177a4:	e5950004 	ldr	r0, [r5, #4]
57e177a8:	e5972054 	ldr	r2, [r7, #84]	; 0x54
57e177ac:	e1a01fc0 	asr	r1, r0, #31
57e177b0:	eb00511f 	bl	57e2bc34 <__ashldi3>
57e177b4:	e1a03001 	mov	r3, r1
57e177b8:	e5941014 	ldr	r1, [r4, #20]
57e177bc:	e1a02000 	mov	r2, r0
57e177c0:	e58d1000 	str	r1, [sp]
57e177c4:	e1a00004 	mov	r0, r4
57e177c8:	e1a0100a 	mov	r1, sl
57e177cc:	e58d5004 	str	r5, [sp, #4]
57e177d0:	ebfffa58 	bl	57e16138 <scan_read_raw>

static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	u32 ver_offs = td->veroffs;

	if (!(td->options & NAND_BBT_NO_OOB))
57e177d4:	e5952000 	ldr	r2, [r5]
	return mtd->write_oob(mtd, offs, &ops);
}

static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	u32 ver_offs = td->veroffs;
57e177d8:	e595300c 	ldr	r3, [r5, #12]

	if (!(td->options & NAND_BBT_NO_OOB))
57e177dc:	e3120501 	tst	r2, #4194304	; 0x400000
		ver_offs += mtd->writesize;
57e177e0:	05942014 	ldreq	r2, [r4, #20]
	/* Read the primary version, if available */
	if (td->options & NAND_BBT_VERSION) {
		scan_read_raw(mtd, buf, (loff_t)td->pages[0] << this->page_shift,
			      mtd->writesize, td);
		td->version[0] = buf[bbt_get_ver_offs(mtd, td)];
		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
57e177e4:	e59f0394 	ldr	r0, [pc, #916]	; 57e17b80 <nand_scan_bbt+0x4f4>
static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	u32 ver_offs = td->veroffs;

	if (!(td->options & NAND_BBT_NO_OOB))
		ver_offs += mtd->writesize;
57e177e8:	00833002 	addeq	r3, r3, r2

	/* Read the primary version, if available */
	if (td->options & NAND_BBT_VERSION) {
		scan_read_raw(mtd, buf, (loff_t)td->pages[0] << this->page_shift,
			      mtd->writesize, td);
		td->version[0] = buf[bbt_get_ver_offs(mtd, td)];
57e177ec:	e7da2003 	ldrb	r2, [sl, r3]
		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
57e177f0:	e5951004 	ldr	r1, [r5, #4]

	/* Read the primary version, if available */
	if (td->options & NAND_BBT_VERSION) {
		scan_read_raw(mtd, buf, (loff_t)td->pages[0] << this->page_shift,
			      mtd->writesize, td);
		td->version[0] = buf[bbt_get_ver_offs(mtd, td)];
57e177f4:	e5c52010 	strb	r2, [r5, #16]
		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
57e177f8:	ebffc713 	bl	57e0944c <printf>
		       td->pages[0], td->version[0]);
	}

	/* Read the mirror version, if available */
	if (md && (md->options & NAND_BBT_VERSION)) {
57e177fc:	e3560000 	cmp	r6, #0
57e17800:	0a000023 	beq	57e17894 <nand_scan_bbt+0x208>
57e17804:	e5963000 	ldr	r3, [r6]
57e17808:	e3130c01 	tst	r3, #256	; 0x100
57e1780c:	0a000020 	beq	57e17894 <nand_scan_bbt+0x208>
		scan_read_raw(mtd, buf, (loff_t)md->pages[0] << this->page_shift,
57e17810:	e5960004 	ldr	r0, [r6, #4]
57e17814:	e5972054 	ldr	r2, [r7, #84]	; 0x54
57e17818:	e1a01fc0 	asr	r1, r0, #31
57e1781c:	eb005104 	bl	57e2bc34 <__ashldi3>
57e17820:	e1a03001 	mov	r3, r1
57e17824:	e5941014 	ldr	r1, [r4, #20]
57e17828:	e1a02000 	mov	r2, r0
57e1782c:	e58d1000 	str	r1, [sp]
57e17830:	e1a00004 	mov	r0, r4
57e17834:	e1a0100a 	mov	r1, sl
57e17838:	e58d5004 	str	r5, [sp, #4]
57e1783c:	ebfffa3d 	bl	57e16138 <scan_read_raw>

static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	u32 ver_offs = td->veroffs;

	if (!(td->options & NAND_BBT_NO_OOB))
57e17840:	e5962000 	ldr	r2, [r6]
	return mtd->write_oob(mtd, offs, &ops);
}

static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	u32 ver_offs = td->veroffs;
57e17844:	e596300c 	ldr	r3, [r6, #12]

	if (!(td->options & NAND_BBT_NO_OOB))
57e17848:	e3120501 	tst	r2, #4194304	; 0x400000
		ver_offs += mtd->writesize;
57e1784c:	05942014 	ldreq	r2, [r4, #20]
	/* Read the mirror version, if available */
	if (md && (md->options & NAND_BBT_VERSION)) {
		scan_read_raw(mtd, buf, (loff_t)md->pages[0] << this->page_shift,
			      mtd->writesize, td);
		md->version[0] = buf[bbt_get_ver_offs(mtd, md)];
		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
57e17850:	e5961004 	ldr	r1, [r6, #4]
static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
{
	u32 ver_offs = td->veroffs;

	if (!(td->options & NAND_BBT_NO_OOB))
		ver_offs += mtd->writesize;
57e17854:	00833002 	addeq	r3, r3, r2

	/* Read the mirror version, if available */
	if (md && (md->options & NAND_BBT_VERSION)) {
		scan_read_raw(mtd, buf, (loff_t)md->pages[0] << this->page_shift,
			      mtd->writesize, td);
		md->version[0] = buf[bbt_get_ver_offs(mtd, md)];
57e17858:	e7da2003 	ldrb	r2, [sl, r3]
		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
57e1785c:	e59f031c 	ldr	r0, [pc, #796]	; 57e17b80 <nand_scan_bbt+0x4f4>

	/* Read the mirror version, if available */
	if (md && (md->options & NAND_BBT_VERSION)) {
		scan_read_raw(mtd, buf, (loff_t)md->pages[0] << this->page_shift,
			      mtd->writesize, td);
		md->version[0] = buf[bbt_get_ver_offs(mtd, md)];
57e17860:	e5c62010 	strb	r2, [r6, #16]
		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
57e17864:	ebffc6f8 	bl	57e0944c <printf>
57e17868:	ea000009 	b	57e17894 <nand_scan_bbt+0x208>
 * Search and read the bad block table(s)
*/
static int search_read_bbts(struct mtd_info *mtd, uint8_t * buf, struct nand_bbt_descr *td, struct nand_bbt_descr *md)
{
	/* Search the primary table */
	search_bbt(mtd, buf, td);
57e1786c:	e1a00004 	mov	r0, r4
57e17870:	e1a0100a 	mov	r1, sl
57e17874:	e1a02005 	mov	r2, r5
57e17878:	ebfffe53 	bl	57e171cc <search_bbt>

	/* Search the mirror table */
	if (md)
57e1787c:	e3560000 	cmp	r6, #0
57e17880:	0a000003 	beq	57e17894 <nand_scan_bbt+0x208>
		search_bbt(mtd, buf, md);
57e17884:	e1a00004 	mov	r0, r4
57e17888:	e1a0100a 	mov	r1, sl
57e1788c:	e1a02006 	mov	r2, r6
57e17890:	ebfffe4d 	bl	57e171cc <search_bbt>
 * version nr. of one table is less than the other
*/
static int check_create(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)
{
	int i, chips, writeops, chipsel, res;
	struct nand_chip *this = mtd->priv;
57e17894:	e5941094 	ldr	r1, [r4, #148]	; 0x94
57e17898:	e3a00000 	mov	r0, #0
	struct nand_bbt_descr *td = this->bbt_td;
57e1789c:	e591c114 	ldr	ip, [r1, #276]	; 0x114
	struct nand_bbt_descr *md = this->bbt_md;
57e178a0:	e5917118 	ldr	r7, [r1, #280]	; 0x118
	struct nand_bbt_descr *rd, *rd2;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP)
57e178a4:	e59c3000 	ldr	r3, [ip]
57e178a8:	e58d5024 	str	r5, [sp, #36]	; 0x24
57e178ac:	e3130080 	tst	r3, #128	; 0x80
		chips = this->numchips;
57e178b0:	15912064 	ldrne	r2, [r1, #100]	; 0x64
	else
		chips = 1;
57e178b4:	03a03001 	moveq	r3, #1
57e178b8:	e1a0b00a 	mov	fp, sl
 * version nr. of one table is less than the other
*/
static int check_create(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)
{
	int i, chips, writeops, chipsel, res;
	struct nand_chip *this = mtd->priv;
57e178bc:	e58d1018 	str	r1, [sp, #24]
	struct nand_bbt_descr *md = this->bbt_md;
	struct nand_bbt_descr *rd, *rd2;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP)
		chips = this->numchips;
57e178c0:	158d202c 	strne	r2, [sp, #44]	; 0x2c
	else
		chips = 1;
57e178c4:	058d302c 	streq	r3, [sp, #44]	; 0x2c
	struct nand_bbt_descr *md = this->bbt_md;
	struct nand_bbt_descr *rd, *rd2;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP)
		chips = this->numchips;
57e178c8:	e58d700c 	str	r7, [sp, #12]
57e178cc:	e58dc010 	str	ip, [sp, #16]
57e178d0:	e58d0014 	str	r0, [sp, #20]
	else
		chips = 1;

	for (i = 0; i < chips; i++) {
57e178d4:	e58d001c 	str	r0, [sp, #28]
57e178d8:	e58d6028 	str	r6, [sp, #40]	; 0x28
57e178dc:	e1a0500c 	mov	r5, ip
57e178e0:	e1a0a004 	mov	sl, r4
57e178e4:	ea000082 	b	57e17af4 <nand_scan_bbt+0x468>
		writeops = 0;
		rd = NULL;
		rd2 = NULL;
		/* Per chip or per device ? */
		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
57e178e8:	e59d1014 	ldr	r1, [sp, #20]
57e178ec:	e1a02005 	mov	r2, r5
57e178f0:	e6923001 	ldr	r3, [r2], r1
57e178f4:	e59d901c 	ldr	r9, [sp, #28]
57e178f8:	e3130080 	tst	r3, #128	; 0x80
57e178fc:	03e09000 	mvneq	r9, #0
		/* Mirrored table available ? */
		if (md) {
57e17900:	e3570000 	cmp	r7, #0
57e17904:	0a000027 	beq	57e179a8 <nand_scan_bbt+0x31c>
			if (td->pages[i] == -1 && md->pages[i] == -1) {
57e17908:	e5922004 	ldr	r2, [r2, #4]
57e1790c:	e3720001 	cmn	r2, #1
57e17910:	e0872001 	add	r2, r7, r1
57e17914:	1a000007 	bne	57e17938 <nand_scan_bbt+0x2ac>
57e17918:	e5922004 	ldr	r2, [r2, #4]
57e1791c:	e3720001 	cmn	r2, #1
57e17920:	0a000025 	beq	57e179bc <nand_scan_bbt+0x330>
				goto create;
			}

			if (td->pages[i] == -1) {
				rd = md;
				td->version[i] = md->version[i];
57e17924:	e59d200c 	ldr	r2, [sp, #12]
57e17928:	e59d0010 	ldr	r0, [sp, #16]
57e1792c:	e5d23010 	ldrb	r3, [r2, #16]
57e17930:	e5c03010 	strb	r3, [r0, #16]
57e17934:	ea00008a 	b	57e17b64 <nand_scan_bbt+0x4d8>
				writeops = 1;
				goto writecheck;
			}

			if (md->pages[i] == -1) {
57e17938:	e5922004 	ldr	r2, [r2, #4]
57e1793c:	e59d1010 	ldr	r1, [sp, #16]
57e17940:	e3720001 	cmn	r2, #1
				rd = td;
				md->version[i] = td->version[i];
57e17944:	059d300c 	ldreq	r3, [sp, #12]
57e17948:	e5d12010 	ldrb	r2, [r1, #16]
57e1794c:	05c32010 	strbeq	r2, [r3, #16]
				td->version[i] = md->version[i];
				writeops = 1;
				goto writecheck;
			}

			if (md->pages[i] == -1) {
57e17950:	0a00000e 	beq	57e17990 <nand_scan_bbt+0x304>
				md->version[i] = td->version[i];
				writeops = 2;
				goto writecheck;
			}

			if (td->version[i] == md->version[i]) {
57e17954:	e59d000c 	ldr	r0, [sp, #12]
57e17958:	e5d01010 	ldrb	r1, [r0, #16]
57e1795c:	e1520001 	cmp	r2, r1
57e17960:	1a000004 	bne	57e17978 <nand_scan_bbt+0x2ec>
				rd = td;
				if (!(td->options & NAND_BBT_VERSION))
57e17964:	e2134c01 	ands	r4, r3, #256	; 0x100
		chips = 1;

	for (i = 0; i < chips; i++) {
		writeops = 0;
		rd = NULL;
		rd2 = NULL;
57e17968:	13a06000 	movne	r6, #0
		chips = this->numchips;
	else
		chips = 1;

	for (i = 0; i < chips; i++) {
		writeops = 0;
57e1796c:	11a04006 	movne	r4, r6
				goto writecheck;
			}

			if (td->version[i] == md->version[i]) {
				rd = td;
				if (!(td->options & NAND_BBT_VERSION))
57e17970:	1a000028 	bne	57e17a18 <nand_scan_bbt+0x38c>
57e17974:	ea000023 	b	57e17a08 <nand_scan_bbt+0x37c>
					rd2 = md;
				goto writecheck;
			}

			if (((int8_t) (td->version[i] - md->version[i])) > 0) {
57e17978:	e0613002 	rsb	r3, r1, r2
57e1797c:	e1a03c03 	lsl	r3, r3, #24
57e17980:	e3530000 	cmp	r3, #0
57e17984:	da000004 	ble	57e1799c <nand_scan_bbt+0x310>
				rd = td;
				md->version[i] = td->version[i];
57e17988:	e59d100c 	ldr	r1, [sp, #12]
57e1798c:	e5c12010 	strb	r2, [r1, #16]
		chips = 1;

	for (i = 0; i < chips; i++) {
		writeops = 0;
		rd = NULL;
		rd2 = NULL;
57e17990:	e3a06000 	mov	r6, #0
			}

			if (((int8_t) (td->version[i] - md->version[i])) > 0) {
				rd = td;
				md->version[i] = td->version[i];
				writeops = 2;
57e17994:	e3a04002 	mov	r4, #2
57e17998:	ea00001e 	b	57e17a18 <nand_scan_bbt+0x38c>
			} else {
				rd = md;
				td->version[i] = md->version[i];
57e1799c:	e59d2010 	ldr	r2, [sp, #16]
57e179a0:	e5c21010 	strb	r1, [r2, #16]
57e179a4:	ea00006e 	b	57e17b64 <nand_scan_bbt+0x4d8>
			}

			goto writecheck;

		} else {
			if (td->pages[i] == -1) {
57e179a8:	e5922004 	ldr	r2, [r2, #4]
57e179ac:	e3720001 	cmn	r2, #1
				writeops = 0x01;
57e179b0:	03a04001 	moveq	r4, #1
			}

			goto writecheck;

		} else {
			if (td->pages[i] == -1) {
57e179b4:	1a000015 	bne	57e17a10 <nand_scan_bbt+0x384>
57e179b8:	ea000000 	b	57e179c0 <nand_scan_bbt+0x334>
		/* Per chip or per device ? */
		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
		/* Mirrored table available ? */
		if (md) {
			if (td->pages[i] == -1 && md->pages[i] == -1) {
				writeops = 0x03;
57e179bc:	e3a04003 	mov	r4, #3
			rd = td;
			goto writecheck;
		}
	create:
		/* Create the bad block table by scanning the device ? */
		if (!(td->options & NAND_BBT_CREATE))
57e179c0:	e3130c02 	tst	r3, #512	; 0x200
57e179c4:	0a00003f 	beq	57e17ac8 <nand_scan_bbt+0x43c>
			continue;

		/* Create the table in memory by scanning the chip(s) */
		if (!(this->options & NAND_CREATE_EMPTY_BBT))
57e179c8:	e59d0018 	ldr	r0, [sp, #24]
57e179cc:	e5903050 	ldr	r3, [r0, #80]	; 0x50
57e179d0:	e3130401 	tst	r3, #16777216	; 0x1000000
57e179d4:	1a000004 	bne	57e179ec <nand_scan_bbt+0x360>
			create_bbt(mtd, buf, bd, chipsel);
57e179d8:	e1a0000a 	mov	r0, sl
57e179dc:	e1a0100b 	mov	r1, fp
57e179e0:	e59d2020 	ldr	r2, [sp, #32]
57e179e4:	e1a03009 	mov	r3, r9
57e179e8:	ebfffd1e 	bl	57e16e68 <create_bbt>

		td->version[i] = 1;
57e179ec:	e59d2010 	ldr	r2, [sp, #16]
57e179f0:	e3a01001 	mov	r1, #1
57e179f4:	e5c21010 	strb	r1, [r2, #16]
		if (md)
57e179f8:	e3570000 	cmp	r7, #0
			md->version[i] = 1;
57e179fc:	159d300c 	ldrne	r3, [sp, #12]
57e17a00:	15c31010 	strbne	r1, [r3, #16]
57e17a04:	ea00000f 	b	57e17a48 <nand_scan_bbt+0x3bc>
				goto writecheck;
			}

			if (td->version[i] == md->version[i]) {
				rd = td;
				if (!(td->options & NAND_BBT_VERSION))
57e17a08:	e1a06007 	mov	r6, r7
57e17a0c:	ea000001 	b	57e17a18 <nand_scan_bbt+0x38c>
		chips = 1;

	for (i = 0; i < chips; i++) {
		writeops = 0;
		rd = NULL;
		rd2 = NULL;
57e17a10:	e1a06007 	mov	r6, r7
		chips = this->numchips;
	else
		chips = 1;

	for (i = 0; i < chips; i++) {
		writeops = 0;
57e17a14:	e1a04007 	mov	r4, r7
57e17a18:	e1a02005 	mov	r2, r5
		if (md)
			md->version[i] = 1;
	writecheck:
		/* read back first ? */
		if (rd)
			read_abs_bbt(mtd, buf, rd, chipsel);
57e17a1c:	e1a0000a 	mov	r0, sl
57e17a20:	e1a0100b 	mov	r1, fp
57e17a24:	e1a03009 	mov	r3, r9
57e17a28:	ebfffa73 	bl	57e163fc <read_abs_bbt>
		/* If they weren't versioned, read both. */
		if (rd2)
57e17a2c:	e3560000 	cmp	r6, #0
57e17a30:	0a000004 	beq	57e17a48 <nand_scan_bbt+0x3bc>
			read_abs_bbt(mtd, buf, rd2, chipsel);
57e17a34:	e1a0000a 	mov	r0, sl
57e17a38:	e1a0100b 	mov	r1, fp
57e17a3c:	e1a02006 	mov	r2, r6
57e17a40:	e1a03009 	mov	r3, r9
57e17a44:	ebfffa6c 	bl	57e163fc <read_abs_bbt>

		/* Write the bad block table to the device ? */
		if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
57e17a48:	e3140001 	tst	r4, #1
57e17a4c:	0a00000a 	beq	57e17a7c <nand_scan_bbt+0x3f0>
57e17a50:	e5953000 	ldr	r3, [r5]
57e17a54:	e3130a01 	tst	r3, #4096	; 0x1000
57e17a58:	0a000007 	beq	57e17a7c <nand_scan_bbt+0x3f0>
			res = write_bbt(mtd, buf, td, md, chipsel);
57e17a5c:	e1a0000a 	mov	r0, sl
57e17a60:	e1a0100b 	mov	r1, fp
57e17a64:	e1a02005 	mov	r2, r5
57e17a68:	e1a03007 	mov	r3, r7
57e17a6c:	e58d9000 	str	r9, [sp]
57e17a70:	ebfffa97 	bl	57e164d4 <write_bbt>
			if (res < 0)
57e17a74:	e3500000 	cmp	r0, #0
57e17a78:	ba000027 	blt	57e17b1c <nand_scan_bbt+0x490>
				return res;
		}

		/* Write the mirror bad block table to the device ? */
		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
57e17a7c:	e3140002 	tst	r4, #2
57e17a80:	03a03000 	moveq	r3, #0
57e17a84:	13a03001 	movne	r3, #1
57e17a88:	e3570000 	cmp	r7, #0
57e17a8c:	03a03000 	moveq	r3, #0
57e17a90:	12033001 	andne	r3, r3, #1
57e17a94:	e3530000 	cmp	r3, #0
57e17a98:	0a00000a 	beq	57e17ac8 <nand_scan_bbt+0x43c>
57e17a9c:	e5973000 	ldr	r3, [r7]
57e17aa0:	e3130a01 	tst	r3, #4096	; 0x1000
57e17aa4:	0a000007 	beq	57e17ac8 <nand_scan_bbt+0x43c>
			res = write_bbt(mtd, buf, md, td, chipsel);
57e17aa8:	e1a0000a 	mov	r0, sl
57e17aac:	e1a0100b 	mov	r1, fp
57e17ab0:	e1a02007 	mov	r2, r7
57e17ab4:	e1a03005 	mov	r3, r5
57e17ab8:	e58d9000 	str	r9, [sp]
57e17abc:	ebfffa84 	bl	57e164d4 <write_bbt>
			if (res < 0)
57e17ac0:	e3500000 	cmp	r0, #0
57e17ac4:	ba000014 	blt	57e17b1c <nand_scan_bbt+0x490>
	if (td->options & NAND_BBT_PERCHIP)
		chips = this->numchips;
	else
		chips = 1;

	for (i = 0; i < chips; i++) {
57e17ac8:	e59d001c 	ldr	r0, [sp, #28]
57e17acc:	e28d100c 	add	r1, sp, #12
57e17ad0:	e891000e 	ldm	r1, {r1, r2, r3}
57e17ad4:	e2800001 	add	r0, r0, #1
57e17ad8:	e2811001 	add	r1, r1, #1
57e17adc:	e2822001 	add	r2, r2, #1
57e17ae0:	e2833004 	add	r3, r3, #4
57e17ae4:	e58d001c 	str	r0, [sp, #28]
57e17ae8:	e58d100c 	str	r1, [sp, #12]
57e17aec:	e58d2010 	str	r2, [sp, #16]
57e17af0:	e58d3014 	str	r3, [sp, #20]
57e17af4:	e59d001c 	ldr	r0, [sp, #28]
57e17af8:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
57e17afc:	e1500001 	cmp	r0, r1
57e17b00:	baffff78 	blt	57e178e8 <nand_scan_bbt+0x25c>
57e17b04:	e1a0400a 	mov	r4, sl
57e17b08:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
57e17b0c:	e59d6028 	ldr	r6, [sp, #40]	; 0x28
57e17b10:	e1a0a00b 	mov	sl, fp
			res = write_bbt(mtd, buf, md, td, chipsel);
			if (res < 0)
				return res;
		}
	}
	return 0;
57e17b14:	e3a09000 	mov	r9, #0
57e17b18:	ea000004 	b	57e17b30 <nand_scan_bbt+0x4a4>
57e17b1c:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
57e17b20:	e59d6028 	ldr	r6, [sp, #40]	; 0x28
57e17b24:	e1a0400a 	mov	r4, sl
57e17b28:	e1a09000 	mov	r9, r0
57e17b2c:	e1a0a00b 	mov	sl, fp

	if (res)
		res = check_create(mtd, buf, bd);

	/* Prevent the bbt regions from erasing / writing */
	mark_bbt_region(mtd, td);
57e17b30:	e1a00004 	mov	r0, r4
57e17b34:	e1a01005 	mov	r1, r5
57e17b38:	ebfffe73 	bl	57e1750c <mark_bbt_region>
	if (md)
57e17b3c:	e3560000 	cmp	r6, #0
57e17b40:	0a000002 	beq	57e17b50 <nand_scan_bbt+0x4c4>
		mark_bbt_region(mtd, md);
57e17b44:	e1a00004 	mov	r0, r4
57e17b48:	e1a01006 	mov	r1, r6
57e17b4c:	ebfffe6e 	bl	57e1750c <mark_bbt_region>

	vfree(buf);
57e17b50:	e1a0000a 	mov	r0, sl
57e17b54:	ebffc790 	bl	57e0999c <free>
	return res;
}
57e17b58:	e1a00009 	mov	r0, r9
57e17b5c:	e28dd030 	add	sp, sp, #48	; 0x30
57e17b60:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e17b64:	e1a02007 	mov	r2, r7
57e17b68:	e3a04001 	mov	r4, #1
57e17b6c:	e3a06000 	mov	r6, #0
57e17b70:	eaffffa9 	b	57e17a1c <nand_scan_bbt+0x390>
57e17b74:	57e33ace 	.word	0x57e33ace
57e17b78:	57e33aec 	.word	0x57e33aec
57e17b7c:	57e33b24 	.word	0x57e33b24
57e17b80:	57e33b3d 	.word	0x57e33b3d

57e17b84 <nand_default_bbt>:
 * This function selects the default bad block table
 * support for the device and calls the nand_scan_bbt function
 *
*/
int nand_default_bbt(struct mtd_info *mtd)
{
57e17b84:	e92d4070 	push	{r4, r5, r6, lr}
	struct nand_chip *this = mtd->priv;
57e17b88:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * This function selects the default bad block table
 * support for the device and calls the nand_scan_bbt function
 *
*/
int nand_default_bbt(struct mtd_info *mtd)
{
57e17b8c:	e1a05000 	mov	r5, r0
	 * _good_ blocks. Erasing those blocks leads to loss
	 * of the good / bad information, so we _must_ store
	 * this information in a good / bad table during
	 * startup
	 */
	if (this->options & NAND_IS_AND) {
57e17b90:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e17b94:	e3130020 	tst	r3, #32
57e17b98:	0a000009 	beq	57e17bc4 <nand_default_bbt+0x40>
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
57e17b9c:	e5942114 	ldr	r2, [r4, #276]	; 0x114
			this->bbt_td = &bbt_main_descr;
			this->bbt_md = &bbt_mirror_descr;
		}
		this->options |= NAND_USE_FLASH_BBT;
57e17ba0:	e3833801 	orr	r3, r3, #65536	; 0x10000
	 * this information in a good / bad table during
	 * startup
	 */
	if (this->options & NAND_IS_AND) {
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
57e17ba4:	e3520000 	cmp	r2, #0
			this->bbt_td = &bbt_main_descr;
57e17ba8:	059f20b8 	ldreq	r2, [pc, #184]	; 57e17c68 <nand_default_bbt+0xe4>
			this->bbt_md = &bbt_mirror_descr;
		}
		this->options |= NAND_USE_FLASH_BBT;
57e17bac:	e5843050 	str	r3, [r4, #80]	; 0x50
	 * startup
	 */
	if (this->options & NAND_IS_AND) {
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
			this->bbt_td = &bbt_main_descr;
57e17bb0:	05842114 	streq	r2, [r4, #276]	; 0x114
			this->bbt_md = &bbt_mirror_descr;
57e17bb4:	02822024 	addeq	r2, r2, #36	; 0x24
57e17bb8:	05842118 	streq	r2, [r4, #280]	; 0x118
		}
		this->options |= NAND_USE_FLASH_BBT;
		return nand_scan_bbt(mtd, &agand_flashbased);
57e17bbc:	e59f10a8 	ldr	r1, [pc, #168]	; 57e17c6c <nand_default_bbt+0xe8>
57e17bc0:	ea000026 	b	57e17c60 <nand_default_bbt+0xdc>
	}

	/* Is a flash based bad block table requested ? */
	if (this->options & NAND_USE_FLASH_BBT) {
57e17bc4:	e2132801 	ands	r2, r3, #65536	; 0x10000
				this->bbt_td = &bbt_main_descr;
				this->bbt_md = &bbt_mirror_descr;
			}
		}
	} else {
		this->bbt_td = NULL;
57e17bc8:	05842114 	streq	r2, [r4, #276]	; 0x114
		this->bbt_md = NULL;
57e17bcc:	05842118 	streq	r2, [r4, #280]	; 0x118
		this->options |= NAND_USE_FLASH_BBT;
		return nand_scan_bbt(mtd, &agand_flashbased);
	}

	/* Is a flash based bad block table requested ? */
	if (this->options & NAND_USE_FLASH_BBT) {
57e17bd0:	0a000008 	beq	57e17bf8 <nand_default_bbt+0x74>
		/* Use the default pattern descriptors */
		if (!this->bbt_td) {
57e17bd4:	e5942114 	ldr	r2, [r4, #276]	; 0x114
57e17bd8:	e3520000 	cmp	r2, #0
57e17bdc:	1a000005 	bne	57e17bf8 <nand_default_bbt+0x74>
			if (this->options & NAND_USE_FLASH_BBT_NO_OOB) {
57e17be0:	e3130502 	tst	r3, #8388608	; 0x800000
				this->bbt_td = &bbt_main_no_bbt_descr;
57e17be4:	159f3084 	ldrne	r3, [pc, #132]	; 57e17c70 <nand_default_bbt+0xec>
				this->bbt_md = &bbt_mirror_no_bbt_descr;
			} else {
				this->bbt_td = &bbt_main_descr;
57e17be8:	059f3078 	ldreq	r3, [pc, #120]	; 57e17c68 <nand_default_bbt+0xe4>
57e17bec:	e5843114 	str	r3, [r4, #276]	; 0x114
				this->bbt_md = &bbt_mirror_descr;
57e17bf0:	e2833024 	add	r3, r3, #36	; 0x24
57e17bf4:	e5843118 	str	r3, [r4, #280]	; 0x118
	} else {
		this->bbt_td = NULL;
		this->bbt_md = NULL;
	}

	if (!this->badblock_pattern)
57e17bf8:	e594311c 	ldr	r3, [r4, #284]	; 0x11c
57e17bfc:	e3530000 	cmp	r3, #0
57e17c00:	1a000014 	bne	57e17c58 <nand_default_bbt+0xd4>
	struct nand_bbt_descr *bd;
	if (this->badblock_pattern) {
		printk(KERN_WARNING "BBT descr already allocated; not replacing.\n");
		return -EINVAL;
	}
	bd = kzalloc(sizeof(*bd), GFP_KERNEL);
57e17c04:	e3a00024 	mov	r0, #36	; 0x24
57e17c08:	e3a01001 	mov	r1, #1
57e17c0c:	ebffc95a 	bl	57e0a17c <calloc>
	if (!bd) {
57e17c10:	e3500000 	cmp	r0, #0
57e17c14:	1a000002 	bne	57e17c24 <nand_default_bbt+0xa0>
		printk(KERN_ERR "nand_create_default_bbt_descr: Out of memory\n");
57e17c18:	e59f0054 	ldr	r0, [pc, #84]	; 57e17c74 <nand_default_bbt+0xf0>
57e17c1c:	ebffc60a 	bl	57e0944c <printf>
57e17c20:	ea00000c 	b	57e17c58 <nand_default_bbt+0xd4>
		return -ENOMEM;
	}
	bd->options = this->options & BBT_SCAN_OPTIONS;
57e17c24:	e5943050 	ldr	r3, [r4, #80]	; 0x50
	bd->offs = this->badblockpos;
57e17c28:	e5941080 	ldr	r1, [r4, #128]	; 0x80
	bd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;
57e17c2c:	e3130002 	tst	r3, #2
	bd = kzalloc(sizeof(*bd), GFP_KERNEL);
	if (!bd) {
		printk(KERN_ERR "nand_create_default_bbt_descr: Out of memory\n");
		return -ENOMEM;
	}
	bd->options = this->options & BBT_SCAN_OPTIONS;
57e17c30:	e2032943 	and	r2, r3, #1097728	; 0x10c000
	bd->offs = this->badblockpos;
	bd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;
57e17c34:	03a03001 	moveq	r3, #1
57e17c38:	13a03002 	movne	r3, #2
57e17c3c:	e5803014 	str	r3, [r0, #20]
	bd->pattern = scan_ff_pattern;
57e17c40:	e59f3030 	ldr	r3, [pc, #48]	; 57e17c78 <nand_default_bbt+0xf4>
	if (!bd) {
		printk(KERN_ERR "nand_create_default_bbt_descr: Out of memory\n");
		return -ENOMEM;
	}
	bd->options = this->options & BBT_SCAN_OPTIONS;
	bd->offs = this->badblockpos;
57e17c44:	e5801008 	str	r1, [r0, #8]
	bd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;
	bd->pattern = scan_ff_pattern;
57e17c48:	e5803020 	str	r3, [r0, #32]
	bd->options |= NAND_BBT_DYNAMICSTRUCT;
57e17c4c:	e3823602 	orr	r3, r2, #2097152	; 0x200000
57e17c50:	e5803000 	str	r3, [r0]
	this->badblock_pattern = bd;
57e17c54:	e584011c 	str	r0, [r4, #284]	; 0x11c
	}

	if (!this->badblock_pattern)
		nand_create_default_bbt_descr(this);

	return nand_scan_bbt(mtd, this->badblock_pattern);
57e17c58:	e594111c 	ldr	r1, [r4, #284]	; 0x11c
57e17c5c:	e1a00005 	mov	r0, r5
}
57e17c60:	e8bd4070 	pop	{r4, r5, r6, lr}
	}

	if (!this->badblock_pattern)
		nand_create_default_bbt_descr(this);

	return nand_scan_bbt(mtd, this->badblock_pattern);
57e17c64:	eafffe88 	b	57e1768c <nand_scan_bbt>
57e17c68:	57e36f40 	.word	0x57e36f40
57e17c6c:	57e36f88 	.word	0x57e36f88
57e17c70:	57e36fac 	.word	0x57e36fac
57e17c74:	57e33b69 	.word	0x57e33b69
57e17c78:	57e36ff4 	.word	0x57e36ff4

57e17c7c <nand_isbad_bbt>:
 * @offs:	offset in the device
 * @allowbbt:	allow access to bad block table region
 *
*/
int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
{
57e17c7c:	e92d4010 	push	{r4, lr}
	struct nand_chip *this = mtd->priv;
57e17c80:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int block;
	uint8_t res;

	/* Get block number * 2 */
	block = (int)(offs >> (this->bbt_erase_shift - 1));
57e17c84:	e1a01003 	mov	r1, r3
57e17c88:	e594c05c 	ldr	ip, [r4, #92]	; 0x5c
57e17c8c:	e1a00002 	mov	r0, r2
57e17c90:	e24c2001 	sub	r2, ip, #1
57e17c94:	eb004fdf 	bl	57e2bc18 <__ashrdi3>
	res = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;
57e17c98:	e5943110 	ldr	r3, [r4, #272]	; 0x110
57e17c9c:	e7d331c0 	ldrb	r3, [r3, r0, asr #3]
57e17ca0:	e2000006 	and	r0, r0, #6
57e17ca4:	e1a00053 	asr	r0, r3, r0

	MTDDEBUG(MTD_DEBUG_LEVEL2, "nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\n",
	      (unsigned int)offs, block >> 1, res);

	switch ((int)res) {
57e17ca8:	e2100003 	ands	r0, r0, #3
57e17cac:	08bd8010 	popeq	{r4, pc}
57e17cb0:	e3500002 	cmp	r0, #2
57e17cb4:	1a000003 	bne	57e17cc8 <nand_isbad_bbt+0x4c>
	case 0x00:
		return 0;
	case 0x01:
		return 1;
	case 0x02:
		return allowbbt ? 0 : 1;
57e17cb8:	e59d0008 	ldr	r0, [sp, #8]
57e17cbc:	e2700001 	rsbs	r0, r0, #1
57e17cc0:	33a00000 	movcc	r0, #0
57e17cc4:	e8bd8010 	pop	{r4, pc}

	switch ((int)res) {
	case 0x00:
		return 0;
	case 0x01:
		return 1;
57e17cc8:	e3a00001 	mov	r0, #1
	case 0x02:
		return allowbbt ? 0 : 1;
	}
	return 1;
}
57e17ccc:	e8bd8010 	pop	{r4, pc}

57e17cd0 <check_skip_len>:
 * @return 0 if the image fits and there are no bad blocks
 *         1 if the image fits, but there are bad blocks
 *        -1 if the image does not fit
 */
static int check_skip_len(nand_info_t *nand, loff_t offset, size_t length)
{
57e17cd0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	size_t len_excl_bad = 0;
	int ret = 0;
57e17cd4:	e3a07000 	mov	r7, #0
 * @return 0 if the image fits and there are no bad blocks
 *         1 if the image fits, but there are bad blocks
 *        -1 if the image does not fit
 */
static int check_skip_len(nand_info_t *nand, loff_t offset, size_t length)
{
57e17cd8:	e1a06000 	mov	r6, r0
57e17cdc:	e1a04002 	mov	r4, r2
57e17ce0:	e1a05003 	mov	r5, r3
	size_t len_excl_bad = 0;
57e17ce4:	e1a0a007 	mov	sl, r7
	int ret = 0;

	while (len_excl_bad < length) {
57e17ce8:	ea000015 	b	57e17d44 <check_skip_len+0x74>
		size_t block_len, block_off;
		loff_t block_start;

		if (offset >= nand->size)
57e17cec:	e596300c 	ldr	r3, [r6, #12]
57e17cf0:	e1530005 	cmp	r3, r5
57e17cf4:	8a000003 	bhi	57e17d08 <check_skip_len+0x38>
57e17cf8:	1a000015 	bne	57e17d54 <check_skip_len+0x84>
57e17cfc:	e5963008 	ldr	r3, [r6, #8]
57e17d00:	e1530004 	cmp	r3, r4
57e17d04:	9a000012 	bls	57e17d54 <check_skip_len+0x84>
			return -1;

		block_start = offset & ~(loff_t)(nand->erasesize - 1);
57e17d08:	e5963010 	ldr	r3, [r6, #16]
57e17d0c:	e5961078 	ldr	r1, [r6, #120]	; 0x78
57e17d10:	e2432001 	sub	r2, r3, #1
		block_off = offset & (nand->erasesize - 1);
57e17d14:	e0029004 	and	r9, r2, r4
57e17d18:	e1c4b002 	bic	fp, r4, r2
		block_len = nand->erasesize - block_off;
57e17d1c:	e0699003 	rsb	r9, r9, r3
57e17d20:	e1a00006 	mov	r0, r6
57e17d24:	e1a03005 	mov	r3, r5
57e17d28:	e1a0200b 	mov	r2, fp
57e17d2c:	e12fff31 	blx	r1

		if (!nand_block_isbad(nand, block_start))
57e17d30:	e3500000 	cmp	r0, #0
			len_excl_bad += block_len;
57e17d34:	008aa009 	addeq	sl, sl, r9
		else
			ret = 1;
57e17d38:	13a07001 	movne	r7, #1

		offset += block_len;
57e17d3c:	e0944009 	adds	r4, r4, r9
57e17d40:	e2a55000 	adc	r5, r5, #0
static int check_skip_len(nand_info_t *nand, loff_t offset, size_t length)
{
	size_t len_excl_bad = 0;
	int ret = 0;

	while (len_excl_bad < length) {
57e17d44:	e59dc020 	ldr	ip, [sp, #32]
57e17d48:	e15a000c 	cmp	sl, ip
57e17d4c:	3affffe6 	bcc	57e17cec <check_skip_len+0x1c>
57e17d50:	ea000000 	b	57e17d58 <check_skip_len+0x88>
		size_t block_len, block_off;
		loff_t block_start;

		if (offset >= nand->size)
			return -1;
57e17d54:	e3e07000 	mvn	r7, #0

		offset += block_len;
	}

	return ret;
}
57e17d58:	e1a00007 	mov	r0, r7
57e17d5c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e17d60 <nand_erase_opts>:
 *
 * This code is ported from flash_eraseall.c from Linux mtd utils by
 * Arcom Control System Ltd.
 */
int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
{
57e17d60:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e17d64:	e1a05001 	mov	r5, r1
	int percent_complete = -1;
	const char *mtd_device = meminfo->name;
	struct mtd_oob_ops oob_opts;
	struct nand_chip *chip = meminfo->priv;

	if ((opts->offset & (meminfo->erasesize - 1)) != 0) {
57e17d68:	e5901010 	ldr	r1, [r0, #16]
	erase_info_t erase;
	unsigned long erase_length, erased_length; /* in blocks */
	int bbtest = 1;
	int result;
	int percent_complete = -1;
	const char *mtd_device = meminfo->name;
57e17d6c:	e5903020 	ldr	r3, [r0, #32]
 *
 * This code is ported from flash_eraseall.c from Linux mtd utils by
 * Arcom Control System Ltd.
 */
int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
{
57e17d70:	e24dd098 	sub	sp, sp, #152	; 0x98
	int percent_complete = -1;
	const char *mtd_device = meminfo->name;
	struct mtd_oob_ops oob_opts;
	struct nand_chip *chip = meminfo->priv;

	if ((opts->offset & (meminfo->erasesize - 1)) != 0) {
57e17d74:	e2411001 	sub	r1, r1, #1
	erase_info_t erase;
	unsigned long erase_length, erased_length; /* in blocks */
	int bbtest = 1;
	int result;
	int percent_complete = -1;
	const char *mtd_device = meminfo->name;
57e17d78:	e58d3010 	str	r3, [sp, #16]
	struct mtd_oob_ops oob_opts;
	struct nand_chip *chip = meminfo->priv;

	if ((opts->offset & (meminfo->erasesize - 1)) != 0) {
57e17d7c:	e2853008 	add	r3, r5, #8
57e17d80:	e893000c 	ldm	r3, {r2, r3}
57e17d84:	e3a03000 	mov	r3, #0
57e17d88:	e0022001 	and	r2, r2, r1
57e17d8c:	e1927003 	orrs	r7, r2, r3
 *
 * This code is ported from flash_eraseall.c from Linux mtd utils by
 * Arcom Control System Ltd.
 */
int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
{
57e17d90:	e1a04000 	mov	r4, r0
	int bbtest = 1;
	int result;
	int percent_complete = -1;
	const char *mtd_device = meminfo->name;
	struct mtd_oob_ops oob_opts;
	struct nand_chip *chip = meminfo->priv;
57e17d94:	e5906094 	ldr	r6, [r0, #148]	; 0x94

	if ((opts->offset & (meminfo->erasesize - 1)) != 0) {
57e17d98:	0a000002 	beq	57e17da8 <nand_erase_opts+0x48>
		printf("Attempt to erase non block-aligned data\n");
57e17d9c:	e59f02cc 	ldr	r0, [pc, #716]	; 57e18070 <nand_erase_opts+0x310>
57e17da0:	ebffc5a9 	bl	57e0944c <printf>
57e17da4:	ea000051 	b	57e17ef0 <nand_erase_opts+0x190>
		return -1;
	}

	memset(&erase, 0, sizeof(erase));
57e17da8:	e1a01007 	mov	r1, r7
57e17dac:	e3a02048 	mov	r2, #72	; 0x48
57e17db0:	e28d0018 	add	r0, sp, #24
57e17db4:	eb003130 	bl	57e2427c <memset>
	memset(&oob_opts, 0, sizeof(oob_opts));
57e17db8:	e1a01007 	mov	r1, r7
57e17dbc:	e3a02020 	mov	r2, #32
57e17dc0:	e28d0064 	add	r0, sp, #100	; 0x64
57e17dc4:	eb00312c 	bl	57e2427c <memset>

	erase.mtd = meminfo;
	erase.len  = meminfo->erasesize;
	erase.addr = opts->offset;
57e17dc8:	e2853008 	add	r3, r5, #8
57e17dcc:	e893000c 	ldm	r3, {r2, r3}
	erase_length = lldiv(opts->length + meminfo->erasesize - 1,
57e17dd0:	e8950c00 	ldm	r5, {sl, fp}

	memset(&erase, 0, sizeof(erase));
	memset(&oob_opts, 0, sizeof(oob_opts));

	erase.mtd = meminfo;
	erase.len  = meminfo->erasesize;
57e17dd4:	e5941010 	ldr	r1, [r4, #16]
	erase.addr = opts->offset;
57e17dd8:	e58d2020 	str	r2, [sp, #32]
57e17ddc:	e58d3024 	str	r3, [sp, #36]	; 0x24
	erase_length = lldiv(opts->length + meminfo->erasesize - 1,
57e17de0:	e3e02000 	mvn	r2, #0
57e17de4:	e09aa002 	adds	sl, sl, r2
57e17de8:	e3e03000 	mvn	r3, #0
57e17dec:	e0abb003 	adc	fp, fp, r3
57e17df0:	e09aa001 	adds	sl, sl, r1
57e17df4:	e2abb000 	adc	fp, fp, #0
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
	do_div(__res, divisor);
57e17df8:	e35b0000 	cmp	fp, #0
	}

	memset(&erase, 0, sizeof(erase));
	memset(&oob_opts, 0, sizeof(oob_opts));

	erase.mtd = meminfo;
57e17dfc:	e58d4018 	str	r4, [sp, #24]
	erase.len  = meminfo->erasesize;
57e17e00:	e58d1028 	str	r1, [sp, #40]	; 0x28
57e17e04:	e58d702c 	str	r7, [sp, #44]	; 0x2c
/* Wrapper for do_div(). Doesn't modify dividend and returns
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
57e17e08:	e58da090 	str	sl, [sp, #144]	; 0x90
57e17e0c:	e58db094 	str	fp, [sp, #148]	; 0x94
	do_div(__res, divisor);
57e17e10:	1a000004 	bne	57e17e28 <nand_erase_opts+0xc8>
57e17e14:	e1a0000a 	mov	r0, sl
57e17e18:	eb004e64 	bl	57e2b7b0 <__udivsi3>
57e17e1c:	e58db094 	str	fp, [sp, #148]	; 0x94
57e17e20:	e58d0090 	str	r0, [sp, #144]	; 0x90
57e17e24:	ea000001 	b	57e17e30 <nand_erase_opts+0xd0>
57e17e28:	e28d0090 	add	r0, sp, #144	; 0x90
57e17e2c:	eb0029b6 	bl	57e2250c <__div64_32>
	erase.addr = opts->offset;
	erase_length = lldiv(opts->length + meminfo->erasesize - 1,
			     meminfo->erasesize);

	cleanmarker.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
57e17e30:	e59f323c 	ldr	r3, [pc, #572]	; 57e18074 <nand_erase_opts+0x314>
	memset(&oob_opts, 0, sizeof(oob_opts));

	erase.mtd = meminfo;
	erase.len  = meminfo->erasesize;
	erase.addr = opts->offset;
	erase_length = lldiv(opts->length + meminfo->erasesize - 1,
57e17e34:	e59d9090 	ldr	r9, [sp, #144]	; 0x90
			     meminfo->erasesize);

	cleanmarker.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
57e17e38:	e1cd38b4 	strh	r3, [sp, #132]	; 0x84
	cleanmarker.nodetype = cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER);
57e17e3c:	e59f3234 	ldr	r3, [pc, #564]	; 57e18078 <nand_erase_opts+0x318>
57e17e40:	e1cd38b6 	strh	r3, [sp, #134]	; 0x86
	cleanmarker.totlen = cpu_to_je32(8);
57e17e44:	e3a03008 	mov	r3, #8
57e17e48:	e58d3088 	str	r3, [sp, #136]	; 0x88

	/* scrub option allows to erase badblock. To prevent internal
	 * check from erase() method, set block check method to dummy
	 * and disable bad block table while erasing.
	 */
	if (opts->scrub) {
57e17e4c:	e5953018 	ldr	r3, [r5, #24]
57e17e50:	e3530000 	cmp	r3, #0
57e17e54:	0a000006 	beq	57e17e74 <nand_erase_opts+0x114>
		erase.scrub = opts->scrub;
		/*
		 * We don't need the bad block table anymore...
		 * after scrub, there are no bad blocks left!
		 */
		if (chip->bbt) {
57e17e58:	e5960110 	ldr	r0, [r6, #272]	; 0x110
	/* scrub option allows to erase badblock. To prevent internal
	 * check from erase() method, set block check method to dummy
	 * and disable bad block table while erasing.
	 */
	if (opts->scrub) {
		erase.scrub = opts->scrub;
57e17e5c:	e58d3058 	str	r3, [sp, #88]	; 0x58
		/*
		 * We don't need the bad block table anymore...
		 * after scrub, there are no bad blocks left!
		 */
		if (chip->bbt) {
57e17e60:	e3500000 	cmp	r0, #0
57e17e64:	0a000000 	beq	57e17e6c <nand_erase_opts+0x10c>
			kfree(chip->bbt);
57e17e68:	ebffc6cb 	bl	57e0999c <free>
		}
		chip->bbt = NULL;
57e17e6c:	e3a03000 	mov	r3, #0
57e17e70:	e5863110 	str	r3, [r6, #272]	; 0x110

				printf("\rErasing at 0x%llx -- %3d%% complete.",
				       erase.addr, percent);

				if (opts->jffs2 && result == 0)
					printf(" Cleanmarker written at 0x%llx.",
57e17e74:	e3e03000 	mvn	r3, #0
57e17e78:	e58d300c 	str	r3, [sp, #12]
			chip->ops.datbuf = NULL;
			chip->ops.oobbuf = (uint8_t *)&cleanmarker;
			chip->ops.ooboffs = 0;
			chip->ops.mode = MTD_OOB_AUTO;

			result = meminfo->write_oob(meminfo,
57e17e7c:	e28630f0 	add	r3, r6, #240	; 0xf0

				printf("\rErasing at 0x%llx -- %3d%% complete.",
				       erase.addr, percent);

				if (opts->jffs2 && result == 0)
					printf(" Cleanmarker written at 0x%llx.",
57e17e80:	e3a07000 	mov	r7, #0
			chip->ops.datbuf = NULL;
			chip->ops.oobbuf = (uint8_t *)&cleanmarker;
			chip->ops.ooboffs = 0;
			chip->ops.mode = MTD_OOB_AUTO;

			result = meminfo->write_oob(meminfo,
57e17e84:	e58d3014 	str	r3, [sp, #20]
57e17e88:	ea000068 	b	57e18030 <nand_erase_opts+0x2d0>
	     erased_length < erase_length;
	     erase.addr += meminfo->erasesize) {

		WATCHDOG_RESET();

		if (!opts->scrub && bbtest) {
57e17e8c:	e5953018 	ldr	r3, [r5, #24]
57e17e90:	e3530000 	cmp	r3, #0
57e17e94:	1a000017 	bne	57e17ef8 <nand_erase_opts+0x198>
			int ret = meminfo->block_isbad(meminfo, erase.addr);
57e17e98:	e28d3020 	add	r3, sp, #32
57e17e9c:	e893000c 	ldm	r3, {r2, r3}
57e17ea0:	e5941078 	ldr	r1, [r4, #120]	; 0x78
57e17ea4:	e1a00004 	mov	r0, r4
57e17ea8:	e12fff31 	blx	r1
			if (ret > 0) {
57e17eac:	e2502000 	subs	r2, r0, #0
57e17eb0:	da00000a 	ble	57e17ee0 <nand_erase_opts+0x180>
				if (!opts->quiet)
57e17eb4:	e5953010 	ldr	r3, [r5, #16]
57e17eb8:	e3530000 	cmp	r3, #0
57e17ebc:	1a000003 	bne	57e17ed0 <nand_erase_opts+0x170>
					printf("\rSkipping bad block at  "
57e17ec0:	e59f01b4 	ldr	r0, [pc, #436]	; 57e1807c <nand_erase_opts+0x31c>
57e17ec4:	e28d3020 	add	r3, sp, #32
57e17ec8:	e893000c 	ldm	r3, {r2, r3}
57e17ecc:	ebffc55e 	bl	57e0944c <printf>
					       "0x%08llx                 "
					       "                         \n",
					       erase.addr);

				if (!opts->spread)
57e17ed0:	e595301c 	ldr	r3, [r5, #28]
57e17ed4:	e3530000 	cmp	r3, #0
					erased_length++;
57e17ed8:	02877001 	addeq	r7, r7, #1
57e17edc:	ea00004c 	b	57e18014 <nand_erase_opts+0x2b4>

				continue;

			} else if (ret < 0) {
57e17ee0:	0a000004 	beq	57e17ef8 <nand_erase_opts+0x198>
				printf("\n%s: MTD get bad block failed: %d\n",
57e17ee4:	e59f0194 	ldr	r0, [pc, #404]	; 57e18080 <nand_erase_opts+0x320>
57e17ee8:	e59d1010 	ldr	r1, [sp, #16]
57e17eec:	ebffc556 	bl	57e0944c <printf>
				       mtd_device,
				       ret);
				return -1;
57e17ef0:	e3e00000 	mvn	r0, #0
57e17ef4:	ea00005b 	b	57e18068 <nand_erase_opts+0x308>
			}
		}

		erased_length++;

		result = meminfo->erase(meminfo, &erase);
57e17ef8:	e5943034 	ldr	r3, [r4, #52]	; 0x34
57e17efc:	e1a00004 	mov	r0, r4
57e17f00:	e28d1018 	add	r1, sp, #24
57e17f04:	e12fff33 	blx	r3
		if (result != 0) {
57e17f08:	e2502000 	subs	r2, r0, #0
				       ret);
				return -1;
			}
		}

		erased_length++;
57e17f0c:	e2877001 	add	r7, r7, #1

		result = meminfo->erase(meminfo, &erase);
		if (result != 0) {
			printf("\n%s: MTD Erase failure: %d\n",
57e17f10:	159f016c 	ldrne	r0, [pc, #364]	; 57e18084 <nand_erase_opts+0x324>
		}

		erased_length++;

		result = meminfo->erase(meminfo, &erase);
		if (result != 0) {
57e17f14:	1a000018 	bne	57e17f7c <nand_erase_opts+0x21c>
			       mtd_device, result);
			continue;
		}

		/* format for JFFS2 ? */
		if (opts->jffs2 && chip->ecc.layout->oobavail >= 8) {
57e17f18:	e5953014 	ldr	r3, [r5, #20]
57e17f1c:	e3530000 	cmp	r3, #0
57e17f20:	0a000018 	beq	57e17f88 <nand_erase_opts+0x228>
57e17f24:	e59630b8 	ldr	r3, [r6, #184]	; 0xb8
57e17f28:	e5933204 	ldr	r3, [r3, #516]	; 0x204
57e17f2c:	e3530007 	cmp	r3, #7
57e17f30:	9a000014 	bls	57e17f88 <nand_erase_opts+0x228>
			chip->ops.ooblen = 8;
57e17f34:	e3a03008 	mov	r3, #8
57e17f38:	e58630fc 	str	r3, [r6, #252]	; 0xfc
			chip->ops.datbuf = NULL;
			chip->ops.oobbuf = (uint8_t *)&cleanmarker;
57e17f3c:	e28d3084 	add	r3, sp, #132	; 0x84
57e17f40:	e586310c 	str	r3, [r6, #268]	; 0x10c
			chip->ops.ooboffs = 0;
			chip->ops.mode = MTD_OOB_AUTO;
57e17f44:	e3a03001 	mov	r3, #1
57e17f48:	e58630f0 	str	r3, [r6, #240]	; 0xf0

			result = meminfo->write_oob(meminfo,
57e17f4c:	e59d3014 	ldr	r3, [sp, #20]
		}

		/* format for JFFS2 ? */
		if (opts->jffs2 && chip->ecc.layout->oobavail >= 8) {
			chip->ops.ooblen = 8;
			chip->ops.datbuf = NULL;
57e17f50:	e5862108 	str	r2, [r6, #264]	; 0x108
			chip->ops.oobbuf = (uint8_t *)&cleanmarker;
			chip->ops.ooboffs = 0;
57e17f54:	e5862104 	str	r2, [r6, #260]	; 0x104
			chip->ops.mode = MTD_OOB_AUTO;

			result = meminfo->write_oob(meminfo,
57e17f58:	e5941050 	ldr	r1, [r4, #80]	; 0x50
57e17f5c:	e58d3000 	str	r3, [sp]
57e17f60:	e1a00004 	mov	r0, r4
57e17f64:	e28d3020 	add	r3, sp, #32
57e17f68:	e893000c 	ldm	r3, {r2, r3}
57e17f6c:	e12fff31 	blx	r1
			                            erase.addr,
			                            &chip->ops);
			if (result != 0) {
57e17f70:	e2502000 	subs	r2, r0, #0
57e17f74:	0a000003 	beq	57e17f88 <nand_erase_opts+0x228>
				printf("\n%s: MTD writeoob failure: %d\n",
57e17f78:	e59f0108 	ldr	r0, [pc, #264]	; 57e18088 <nand_erase_opts+0x328>
57e17f7c:	e59d1010 	ldr	r1, [sp, #16]
57e17f80:	ebffc531 	bl	57e0944c <printf>
				       mtd_device, result);
				continue;
57e17f84:	ea000022 	b	57e18014 <nand_erase_opts+0x2b4>
			}
		}

		if (!opts->quiet) {
57e17f88:	e5953010 	ldr	r3, [r5, #16]
57e17f8c:	e3530000 	cmp	r3, #0
57e17f90:	1a00001f 	bne	57e18014 <nand_erase_opts+0x2b4>
			unsigned long long n = erased_length * 100ULL;
57e17f94:	e2833064 	add	r3, r3, #100	; 0x64
57e17f98:	e08ba397 	umull	sl, fp, r7, r3
			int percent;

			do_div(n, erase_length);
57e17f9c:	e35b0000 	cmp	fp, #0
				continue;
			}
		}

		if (!opts->quiet) {
			unsigned long long n = erased_length * 100ULL;
57e17fa0:	e58da090 	str	sl, [sp, #144]	; 0x90
57e17fa4:	e58db094 	str	fp, [sp, #148]	; 0x94
			int percent;

			do_div(n, erase_length);
57e17fa8:	1a000005 	bne	57e17fc4 <nand_erase_opts+0x264>
57e17fac:	e1a0000a 	mov	r0, sl
57e17fb0:	e1a01009 	mov	r1, r9
57e17fb4:	eb004dfd 	bl	57e2b7b0 <__udivsi3>
57e17fb8:	e58db094 	str	fp, [sp, #148]	; 0x94
57e17fbc:	e58d0090 	str	r0, [sp, #144]	; 0x90
57e17fc0:	ea000002 	b	57e17fd0 <nand_erase_opts+0x270>
57e17fc4:	e28d0090 	add	r0, sp, #144	; 0x90
57e17fc8:	e1a01009 	mov	r1, r9
57e17fcc:	eb00294e 	bl	57e2250c <__div64_32>
			percent = (int)n;
57e17fd0:	e59da090 	ldr	sl, [sp, #144]	; 0x90

			/* output progress message only at whole percent
			 * steps to reduce the number of messages printed
			 * on (slow) serial consoles
			 */
			if (percent != percent_complete) {
57e17fd4:	e59d300c 	ldr	r3, [sp, #12]
57e17fd8:	e15a0003 	cmp	sl, r3
57e17fdc:	0a00000c 	beq	57e18014 <nand_erase_opts+0x2b4>
				percent_complete = percent;

				printf("\rErasing at 0x%llx -- %3d%% complete.",
57e17fe0:	e28d3020 	add	r3, sp, #32
57e17fe4:	e893000c 	ldm	r3, {r2, r3}
57e17fe8:	e59f009c 	ldr	r0, [pc, #156]	; 57e1808c <nand_erase_opts+0x32c>
57e17fec:	e58da000 	str	sl, [sp]
57e17ff0:	ebffc515 	bl	57e0944c <printf>
				       erase.addr, percent);

				if (opts->jffs2 && result == 0)
57e17ff4:	e5953014 	ldr	r3, [r5, #20]
57e17ff8:	e3530000 	cmp	r3, #0
57e17ffc:	0a000003 	beq	57e18010 <nand_erase_opts+0x2b0>
					printf(" Cleanmarker written at 0x%llx.",
57e18000:	e59f0088 	ldr	r0, [pc, #136]	; 57e18090 <nand_erase_opts+0x330>
57e18004:	e28d3020 	add	r3, sp, #32
57e18008:	e893000c 	ldm	r3, {r2, r3}
57e1800c:	ebffc50e 	bl	57e0944c <printf>
				percent_complete = percent;

				printf("\rErasing at 0x%llx -- %3d%% complete.",
				       erase.addr, percent);

				if (opts->jffs2 && result == 0)
57e18010:	e58da00c 	str	sl, [sp, #12]
		chip->bbt = NULL;
	}

	for (erased_length = 0;
	     erased_length < erase_length;
	     erase.addr += meminfo->erasesize) {
57e18014:	e5941010 	ldr	r1, [r4, #16]
57e18018:	e28d3020 	add	r3, sp, #32
57e1801c:	e893000c 	ldm	r3, {r2, r3}
57e18020:	e0922001 	adds	r2, r2, r1
57e18024:	e2a33000 	adc	r3, r3, #0
57e18028:	e58d2020 	str	r2, [sp, #32]
57e1802c:	e58d3024 	str	r3, [sp, #36]	; 0x24
			kfree(chip->bbt);
		}
		chip->bbt = NULL;
	}

	for (erased_length = 0;
57e18030:	e1570009 	cmp	r7, r9
57e18034:	3affff94 	bcc	57e17e8c <nand_erase_opts+0x12c>
					printf(" Cleanmarker written at 0x%llx.",
					       erase.addr);
			}
		}
	}
	if (!opts->quiet)
57e18038:	e5953010 	ldr	r3, [r5, #16]
57e1803c:	e3530000 	cmp	r3, #0
57e18040:	1a000001 	bne	57e1804c <nand_erase_opts+0x2ec>
		printf("\n");
57e18044:	e59f0048 	ldr	r0, [pc, #72]	; 57e18094 <nand_erase_opts+0x334>
57e18048:	ebffc4ff 	bl	57e0944c <printf>

	if (opts->scrub)
57e1804c:	e5950018 	ldr	r0, [r5, #24]
57e18050:	e3500000 	cmp	r0, #0
57e18054:	0a000003 	beq	57e18068 <nand_erase_opts+0x308>
		chip->scan_bbt(meminfo);
57e18058:	e5963040 	ldr	r3, [r6, #64]	; 0x40
57e1805c:	e1a00004 	mov	r0, r4
57e18060:	e12fff33 	blx	r3

	return 0;
57e18064:	e3a00000 	mov	r0, #0
}
57e18068:	e28dd098 	add	sp, sp, #152	; 0x98
57e1806c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e18070:	57e34070 	.word	0x57e34070
57e18074:	00001985 	.word	0x00001985
57e18078:	00002003 	.word	0x00002003
57e1807c:	57e34099 	.word	0x57e34099
57e18080:	57e340e5 	.word	0x57e340e5
57e18084:	57e34108 	.word	0x57e34108
57e18088:	57e34124 	.word	0x57e34124
57e1808c:	57e34143 	.word	0x57e34143
57e18090:	57e34169 	.word	0x57e34169
57e18094:	57e32390 	.word	0x57e32390

57e18098 <nand_write_skip_bad>:
 * @param flags		flags modifying the behaviour of the write to NAND
 * @return		0 in case of success
 */
int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
			u_char *buffer, int flags)
{
57e18098:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1809c:	e24dd038 	sub	sp, sp, #56	; 0x38
57e180a0:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
			return -EINVAL;
		}
	} else
#endif
	{
		blocksize = nand->erasesize;
57e180a4:	e5906010 	ldr	r6, [r0, #16]
 */
int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
			u_char *buffer, int flags)
{
	int rval = 0, blocksize;
	size_t left_to_write = *length;
57e180a8:	e5951000 	ldr	r1, [r5]
	 * However, starting at an unaligned offset makes the
	 * semantics of bad block skipping ambiguous (really,
	 * you should only start a block skipping access at a
	 * partition boundary).  So don't try to handle that.
	 */
	if ((offset & (nand->writesize - 1)) != 0) {
57e180ac:	e3a07000 	mov	r7, #0
 */
int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
			u_char *buffer, int flags)
{
	int rval = 0, blocksize;
	size_t left_to_write = *length;
57e180b0:	e58d1014 	str	r1, [sp, #20]
	 * However, starting at an unaligned offset makes the
	 * semantics of bad block skipping ambiguous (really,
	 * you should only start a block skipping access at a
	 * partition boundary).  So don't try to handle that.
	 */
	if ((offset & (nand->writesize - 1)) != 0) {
57e180b4:	e5901014 	ldr	r1, [r0, #20]
			return -EINVAL;
		}
	} else
#endif
	{
		blocksize = nand->erasesize;
57e180b8:	e58d602c 	str	r6, [sp, #44]	; 0x2c
	 * However, starting at an unaligned offset makes the
	 * semantics of bad block skipping ambiguous (really,
	 * you should only start a block skipping access at a
	 * partition boundary).  So don't try to handle that.
	 */
	if ((offset & (nand->writesize - 1)) != 0) {
57e180bc:	e2411001 	sub	r1, r1, #1
57e180c0:	e0026001 	and	r6, r2, r1
57e180c4:	e58d6020 	str	r6, [sp, #32]
57e180c8:	e58d7024 	str	r7, [sp, #36]	; 0x24
57e180cc:	e59dc020 	ldr	ip, [sp, #32]
 * @param flags		flags modifying the behaviour of the write to NAND
 * @return		0 in case of success
 */
int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
			u_char *buffer, int flags)
{
57e180d0:	e1a04000 	mov	r4, r0
	 * However, starting at an unaligned offset makes the
	 * semantics of bad block skipping ambiguous (really,
	 * you should only start a block skipping access at a
	 * partition boundary).  So don't try to handle that.
	 */
	if ((offset & (nand->writesize - 1)) != 0) {
57e180d4:	e19c6007 	orrs	r6, ip, r7
 * @param flags		flags modifying the behaviour of the write to NAND
 * @return		0 in case of success
 */
int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
			u_char *buffer, int flags)
{
57e180d8:	e1a0a002 	mov	sl, r2
57e180dc:	e1a0b003 	mov	fp, r3
57e180e0:	e59d905c 	ldr	r9, [sp, #92]	; 0x5c
	 * However, starting at an unaligned offset makes the
	 * semantics of bad block skipping ambiguous (really,
	 * you should only start a block skipping access at a
	 * partition boundary).  So don't try to handle that.
	 */
	if ((offset & (nand->writesize - 1)) != 0) {
57e180e4:	0a000004 	beq	57e180fc <nand_write_skip_bad+0x64>
		printf("Attempt to write non page-aligned data\n");
57e180e8:	e59f01bc 	ldr	r0, [pc, #444]	; 57e182ac <nand_write_skip_bad+0x214>
57e180ec:	ebffc4d6 	bl	57e0944c <printf>
		*length = 0;
57e180f0:	e3a03000 	mov	r3, #0
57e180f4:	e5853000 	str	r3, [r5]
57e180f8:	ea000007 	b	57e1811c <nand_write_skip_bad+0x84>
		return -EINVAL;
	}

	need_skip = check_skip_len(nand, offset, *length);
57e180fc:	e59d1014 	ldr	r1, [sp, #20]
57e18100:	e58d1000 	str	r1, [sp]
57e18104:	ebfffef1 	bl	57e17cd0 <check_skip_len>
	if (need_skip < 0) {
57e18108:	e3500000 	cmp	r0, #0
57e1810c:	aa000004 	bge	57e18124 <nand_write_skip_bad+0x8c>
		printf("Attempt to write outside the flash area\n");
57e18110:	e59f0198 	ldr	r0, [pc, #408]	; 57e182b0 <nand_write_skip_bad+0x218>
57e18114:	ebffc4cc 	bl	57e0944c <printf>
		*length = 0;
57e18118:	e5856000 	str	r6, [r5]
		return -EINVAL;
57e1811c:	e3e06015 	mvn	r6, #21
57e18120:	ea00005e 	b	57e182a0 <nand_write_skip_bad+0x208>
	}

	if (!need_skip && !(flags & WITH_DROP_FFS)) {
57e18124:	1a000056 	bne	57e18284 <nand_write_skip_bad+0x1ec>
57e18128:	e59d2060 	ldr	r2, [sp, #96]	; 0x60
57e1812c:	e212c002 	ands	ip, r2, #2
57e18130:	1a000053 	bne	57e18284 <nand_write_skip_bad+0x1ec>
	return info->read(info, ofs, *len, (size_t *)len, buf);
}

static inline int nand_write(nand_info_t *info, loff_t ofs, size_t *len, u_char *buf)
{
	return info->write(info, ofs, *len, (size_t *)len, buf);
57e18134:	e5953000 	ldr	r3, [r5]
57e18138:	e5941044 	ldr	r1, [r4, #68]	; 0x44
57e1813c:	e58d3000 	str	r3, [sp]
57e18140:	e58dc01c 	str	ip, [sp, #28]
57e18144:	e98d0220 	stmib	sp, {r5, r9}
57e18148:	e1a00004 	mov	r0, r4
57e1814c:	e1a0200a 	mov	r2, sl
57e18150:	e1a0300b 	mov	r3, fp
57e18154:	e12fff31 	blx	r1
		rval = nand_write(nand, offset, length, buffer);
		if (rval == 0)
57e18158:	e2506000 	subs	r6, r0, #0
57e1815c:	e59dc01c 	ldr	ip, [sp, #28]
57e18160:	0a00004e 	beq	57e182a0 <nand_write_skip_bad+0x208>
			return 0;

		*length = 0;
57e18164:	e585c000 	str	ip, [r5]
		printf("NAND write to offset %llx failed %d\n",
57e18168:	e1a0200a 	mov	r2, sl
57e1816c:	e1a0300b 	mov	r3, fp
57e18170:	e59f013c 	ldr	r0, [pc, #316]	; 57e182b4 <nand_write_skip_bad+0x21c>
57e18174:	e58d6000 	str	r6, [sp]
57e18178:	ebffc4b3 	bl	57e0944c <printf>
			offset, rval);
		return rval;
57e1817c:	ea000047 	b	57e182a0 <nand_write_skip_bad+0x208>
	}

	while (left_to_write > 0) {
		size_t block_offset = offset & (nand->erasesize - 1);
57e18180:	e5942010 	ldr	r2, [r4, #16]
}

static inline int nand_block_isbad(nand_info_t *info, loff_t ofs)
{
	return info->block_isbad(info, ofs);
57e18184:	e3a06000 	mov	r6, #0
57e18188:	e2425001 	sub	r5, r2, #1
57e1818c:	e005500a 	and	r5, r5, sl
		size_t write_size, truncated_write_size;

		WATCHDOG_RESET();

		if (nand_block_isbad(nand, offset & ~(nand->erasesize - 1))) {
57e18190:	e2622000 	rsb	r2, r2, #0
			offset, rval);
		return rval;
	}

	while (left_to_write > 0) {
		size_t block_offset = offset & (nand->erasesize - 1);
57e18194:	e58d5020 	str	r5, [sp, #32]
57e18198:	e00a5002 	and	r5, sl, r2
57e1819c:	e5941078 	ldr	r1, [r4, #120]	; 0x78
57e181a0:	e1a00004 	mov	r0, r4
57e181a4:	e1a02005 	mov	r2, r5
57e181a8:	e1a03006 	mov	r3, r6
57e181ac:	e12fff31 	blx	r1
		size_t write_size, truncated_write_size;

		WATCHDOG_RESET();

		if (nand_block_isbad(nand, offset & ~(nand->erasesize - 1))) {
57e181b0:	e3500000 	cmp	r0, #0
57e181b4:	0a00000d 	beq	57e181f0 <nand_write_skip_bad+0x158>
			printf("Skip bad block 0x%08llx\n",
				offset & ~(nand->erasesize - 1));
57e181b8:	e5942010 	ldr	r2, [r4, #16]
		size_t write_size, truncated_write_size;

		WATCHDOG_RESET();

		if (nand_block_isbad(nand, offset & ~(nand->erasesize - 1))) {
			printf("Skip bad block 0x%08llx\n",
57e181bc:	e3a06000 	mov	r6, #0
				offset & ~(nand->erasesize - 1));
57e181c0:	e2622000 	rsb	r2, r2, #0
		size_t write_size, truncated_write_size;

		WATCHDOG_RESET();

		if (nand_block_isbad(nand, offset & ~(nand->erasesize - 1))) {
			printf("Skip bad block 0x%08llx\n",
57e181c4:	e00a5002 	and	r5, sl, r2
57e181c8:	e1a03006 	mov	r3, r6
57e181cc:	e1a02005 	mov	r2, r5
57e181d0:	e59f00e0 	ldr	r0, [pc, #224]	; 57e182b8 <nand_write_skip_bad+0x220>
57e181d4:	ebffc49c 	bl	57e0944c <printf>
				offset & ~(nand->erasesize - 1));
			offset += nand->erasesize - block_offset;
57e181d8:	e5943010 	ldr	r3, [r4, #16]
57e181dc:	e59d6020 	ldr	r6, [sp, #32]
57e181e0:	e0665003 	rsb	r5, r6, r3
57e181e4:	e09aa005 	adds	sl, sl, r5
57e181e8:	e2abb000 	adc	fp, fp, #0
			continue;
57e181ec:	ea000027 	b	57e18290 <nand_write_skip_bad+0x1f8>
		}

		if (left_to_write < (blocksize - block_offset))
57e181f0:	e59d1020 	ldr	r1, [sp, #32]
57e181f4:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
	return info->read(info, ofs, *len, (size_t *)len, buf);
}

static inline int nand_write(nand_info_t *info, loff_t ofs, size_t *len, u_char *buf)
{
	return info->write(info, ofs, *len, (size_t *)len, buf);
57e181f8:	e59d3014 	ldr	r3, [sp, #20]
57e181fc:	e061500c 	rsb	r5, r1, ip

		if (nand_block_isbad(nand, offset & ~(nand->erasesize - 1))) {
			printf("Skip bad block 0x%08llx\n",
				offset & ~(nand->erasesize - 1));
			offset += nand->erasesize - block_offset;
			continue;
57e18200:	e1550007 	cmp	r5, r7
57e18204:	21a05007 	movcs	r5, r7
57e18208:	e28d2034 	add	r2, sp, #52	; 0x34
57e1820c:	e98d000c 	stmib	sp, {r2, r3}
57e18210:	e1a0200a 	mov	r2, sl
57e18214:	e1a0300b 	mov	r3, fp
			}
		}
		else
#endif
		{
			truncated_write_size = write_size;
57e18218:	e58d5034 	str	r5, [sp, #52]	; 0x34
57e1821c:	e58d5000 	str	r5, [sp]
57e18220:	e5941044 	ldr	r1, [r4, #68]	; 0x44
57e18224:	e1a00004 	mov	r0, r4
57e18228:	e12fff31 	blx	r1
						&write_size);
#endif

			rval = nand_write(nand, offset, &truncated_write_size,
					p_buffer);
			offset += write_size;
57e1822c:	e09aa005 	adds	sl, sl, r5
57e18230:	e2abb000 	adc	fp, fp, #0
			p_buffer += write_size;
		}

		if (rval != 0) {
57e18234:	e3500000 	cmp	r0, #0
57e18238:	0a00000c 	beq	57e18270 <nand_write_skip_bad+0x1d8>
			printf("NAND write to offset %llx failed %d\n",
57e1823c:	e58d0000 	str	r0, [sp]
57e18240:	e1a0300b 	mov	r3, fp
57e18244:	e1a06000 	mov	r6, r0
57e18248:	e1a0200a 	mov	r2, sl
57e1824c:	e59f0060 	ldr	r0, [pc, #96]	; 57e182b4 <nand_write_skip_bad+0x21c>
57e18250:	e58d7014 	str	r7, [sp, #20]
57e18254:	ebffc47c 	bl	57e0944c <printf>
				offset, rval);
			*length -= left_to_write;
57e18258:	e5993000 	ldr	r3, [r9]
57e1825c:	e59dc014 	ldr	ip, [sp, #20]
57e18260:	e1a05009 	mov	r5, r9
57e18264:	e06c7003 	rsb	r7, ip, r3
57e18268:	e5897000 	str	r7, [r9]
			return rval;
57e1826c:	ea00000b 	b	57e182a0 <nand_write_skip_bad+0x208>
#endif

			rval = nand_write(nand, offset, &truncated_write_size,
					p_buffer);
			offset += write_size;
			p_buffer += write_size;
57e18270:	e59d1014 	ldr	r1, [sp, #20]
				offset, rval);
			*length -= left_to_write;
			return rval;
		}

		left_to_write -= write_size;
57e18274:	e0657007 	rsb	r7, r5, r7
#endif

			rval = nand_write(nand, offset, &truncated_write_size,
					p_buffer);
			offset += write_size;
			p_buffer += write_size;
57e18278:	e0811005 	add	r1, r1, r5
57e1827c:	e58d1014 	str	r1, [sp, #20]
57e18280:	ea000002 	b	57e18290 <nand_write_skip_bad+0x1f8>
			if (flags & WITH_DROP_FFS)
				truncated_write_size = drop_ffs(nand, p_buffer,
						&write_size);
#endif

			rval = nand_write(nand, offset, &truncated_write_size,
57e18284:	e59d7014 	ldr	r7, [sp, #20]
57e18288:	e58d9014 	str	r9, [sp, #20]
57e1828c:	e1a09005 	mov	r9, r5
		printf("NAND write to offset %llx failed %d\n",
			offset, rval);
		return rval;
	}

	while (left_to_write > 0) {
57e18290:	e3570000 	cmp	r7, #0
57e18294:	1affffb9 	bne	57e18180 <nand_write_skip_bad+0xe8>
57e18298:	e58d7014 	str	r7, [sp, #20]
		}

		left_to_write -= write_size;
	}

	return 0;
57e1829c:	e1a06007 	mov	r6, r7
}
57e182a0:	e1a00006 	mov	r0, r6
57e182a4:	e28dd038 	add	sp, sp, #56	; 0x38
57e182a8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e182ac:	57e34189 	.word	0x57e34189
57e182b0:	57e341b1 	.word	0x57e341b1
57e182b4:	57e341da 	.word	0x57e341da
57e182b8:	57e341ff 	.word	0x57e341ff

57e182bc <nand_read_skip_bad>:
 * @param buffer buffer to write to
 * @return 0 in case of success
 */
int nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
		       u_char *buffer)
{
57e182bc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int rval;
	size_t left_to_read = *length;
	u_char *p_buffer = buffer;
	int need_skip;

	if ((offset & (nand->writesize - 1)) != 0) {
57e182c0:	e5901014 	ldr	r1, [r0, #20]
 * @param buffer buffer to write to
 * @return 0 in case of success
 */
int nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
		       u_char *buffer)
{
57e182c4:	e24dd030 	sub	sp, sp, #48	; 0x30
	int rval;
	size_t left_to_read = *length;
	u_char *p_buffer = buffer;
	int need_skip;

	if ((offset & (nand->writesize - 1)) != 0) {
57e182c8:	e2411001 	sub	r1, r1, #1
57e182cc:	e002a001 	and	sl, r2, r1
57e182d0:	e3a0b000 	mov	fp, #0
 * @param buffer buffer to write to
 * @return 0 in case of success
 */
int nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
		       u_char *buffer)
{
57e182d4:	e59d6050 	ldr	r6, [sp, #80]	; 0x50
	int rval;
	size_t left_to_read = *length;
	u_char *p_buffer = buffer;
	int need_skip;

	if ((offset & (nand->writesize - 1)) != 0) {
57e182d8:	e19a400b 	orrs	r4, sl, fp
 */
int nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
		       u_char *buffer)
{
	int rval;
	size_t left_to_read = *length;
57e182dc:	e5967000 	ldr	r7, [r6]
 * @param buffer buffer to write to
 * @return 0 in case of success
 */
int nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
		       u_char *buffer)
{
57e182e0:	e1a05000 	mov	r5, r0
57e182e4:	e58d2010 	str	r2, [sp, #16]
57e182e8:	e58d3014 	str	r3, [sp, #20]
57e182ec:	e59dc054 	ldr	ip, [sp, #84]	; 0x54
	int rval;
	size_t left_to_read = *length;
	u_char *p_buffer = buffer;
	int need_skip;

	if ((offset & (nand->writesize - 1)) != 0) {
57e182f0:	e58da020 	str	sl, [sp, #32]
57e182f4:	e58db024 	str	fp, [sp, #36]	; 0x24
57e182f8:	0a000004 	beq	57e18310 <nand_read_skip_bad+0x54>
		printf("Attempt to read non page-aligned data\n");
57e182fc:	e59f01c4 	ldr	r0, [pc, #452]	; 57e184c8 <nand_read_skip_bad+0x20c>
57e18300:	ebffc451 	bl	57e0944c <printf>
		*length = 0;
57e18304:	e3a03000 	mov	r3, #0
57e18308:	e5863000 	str	r3, [r6]
57e1830c:	ea000008 	b	57e18334 <nand_read_skip_bad+0x78>
		return -EINVAL;
	}

	need_skip = check_skip_len(nand, offset, *length);
57e18310:	e58dc01c 	str	ip, [sp, #28]
57e18314:	e58d7000 	str	r7, [sp]
57e18318:	ebfffe6c 	bl	57e17cd0 <check_skip_len>
	if (need_skip < 0) {
57e1831c:	e2509000 	subs	r9, r0, #0
57e18320:	e59dc01c 	ldr	ip, [sp, #28]
57e18324:	aa000004 	bge	57e1833c <nand_read_skip_bad+0x80>
		printf("Attempt to read outside the flash area\n");
57e18328:	e59f019c 	ldr	r0, [pc, #412]	; 57e184cc <nand_read_skip_bad+0x210>
57e1832c:	ebffc446 	bl	57e0944c <printf>
		*length = 0;
57e18330:	e5864000 	str	r4, [r6]
		return -EINVAL;
57e18334:	e3e04015 	mvn	r4, #21
57e18338:	ea00005f 	b	57e184bc <nand_read_skip_bad+0x200>
	}

	if (!need_skip) {
57e1833c:	11a0900c 	movne	r9, ip
57e18340:	1a00005a 	bne	57e184b0 <nand_read_skip_bad+0x1f4>
extern int nand_curr_device;
extern nand_info_t nand_info[];

static inline int nand_read(nand_info_t *info, loff_t ofs, size_t *len, u_char *buf)
{
	return info->read(info, ofs, *len, (size_t *)len, buf);
57e18344:	e5963000 	ldr	r3, [r6]
57e18348:	e5951040 	ldr	r1, [r5, #64]	; 0x40
57e1834c:	e88d0048 	stm	sp, {r3, r6}
57e18350:	e28d3010 	add	r3, sp, #16
57e18354:	e893000c 	ldm	r3, {r2, r3}
57e18358:	e58dc008 	str	ip, [sp, #8]
57e1835c:	e1a00005 	mov	r0, r5
57e18360:	e12fff31 	blx	r1
		rval = nand_read(nand, offset, length, buffer);
		if (!rval || rval == -EUCLEAN)
57e18364:	e3700075 	cmn	r0, #117	; 0x75
57e18368:	13500000 	cmpne	r0, #0
57e1836c:	e1a04000 	mov	r4, r0
57e18370:	13a03000 	movne	r3, #0
57e18374:	03a03001 	moveq	r3, #1
			return 0;
57e18378:	01a04009 	moveq	r4, r9
		return -EINVAL;
	}

	if (!need_skip) {
		rval = nand_read(nand, offset, length, buffer);
		if (!rval || rval == -EUCLEAN)
57e1837c:	0a00004e 	beq	57e184bc <nand_read_skip_bad+0x200>
			return 0;

		*length = 0;
57e18380:	e5863000 	str	r3, [r6]
		printf("NAND read from offset %llx failed %d\n",
57e18384:	e59f0144 	ldr	r0, [pc, #324]	; 57e184d0 <nand_read_skip_bad+0x214>
57e18388:	e28d3010 	add	r3, sp, #16
57e1838c:	e893000c 	ldm	r3, {r2, r3}
57e18390:	e58d4000 	str	r4, [sp]
57e18394:	ebffc42c 	bl	57e0944c <printf>
			offset, rval);
		return rval;
57e18398:	ea000047 	b	57e184bc <nand_read_skip_bad+0x200>
	}

	while (left_to_read > 0) {
		size_t block_offset = offset & (nand->erasesize - 1);
57e1839c:	e5952010 	ldr	r2, [r5, #16]
57e183a0:	e59db010 	ldr	fp, [sp, #16]
57e183a4:	e2424001 	sub	r4, r2, #1
		size_t read_length;

		WATCHDOG_RESET();

		if (nand_block_isbad(nand, offset & ~(nand->erasesize - 1))) {
57e183a8:	e2622000 	rsb	r2, r2, #0
			offset, rval);
		return rval;
	}

	while (left_to_read > 0) {
		size_t block_offset = offset & (nand->erasesize - 1);
57e183ac:	e004400b 	and	r4, r4, fp
	return info->write(info, ofs, *len, (size_t *)len, buf);
}

static inline int nand_block_isbad(nand_info_t *info, loff_t ofs)
{
	return info->block_isbad(info, ofs);
57e183b0:	e28db010 	add	fp, sp, #16
57e183b4:	e89b0c00 	ldm	fp, {sl, fp}
57e183b8:	e3a0b000 	mov	fp, #0
57e183bc:	e00aa002 	and	sl, sl, r2
57e183c0:	e1a0200a 	mov	r2, sl
57e183c4:	e5951078 	ldr	r1, [r5, #120]	; 0x78
57e183c8:	e1a00005 	mov	r0, r5
57e183cc:	e1a0300b 	mov	r3, fp
57e183d0:	e12fff31 	blx	r1
		size_t read_length;

		WATCHDOG_RESET();

		if (nand_block_isbad(nand, offset & ~(nand->erasesize - 1))) {
57e183d4:	e3500000 	cmp	r0, #0
57e183d8:	e5952010 	ldr	r2, [r5, #16]
57e183dc:	0a000011 	beq	57e18428 <nand_read_skip_bad+0x16c>
			printf("Skipping bad block 0x%08llx\n",
				offset & ~(nand->erasesize - 1));
57e183e0:	e2622000 	rsb	r2, r2, #0
		size_t read_length;

		WATCHDOG_RESET();

		if (nand_block_isbad(nand, offset & ~(nand->erasesize - 1))) {
			printf("Skipping bad block 0x%08llx\n",
57e183e4:	e28db010 	add	fp, sp, #16
57e183e8:	e89b0c00 	ldm	fp, {sl, fp}
57e183ec:	e3a0b000 	mov	fp, #0
57e183f0:	e00aa002 	and	sl, sl, r2
57e183f4:	e1a0200a 	mov	r2, sl
57e183f8:	e1a0300b 	mov	r3, fp
57e183fc:	e59f00d0 	ldr	r0, [pc, #208]	; 57e184d4 <nand_read_skip_bad+0x218>
57e18400:	ebffc411 	bl	57e0944c <printf>
				offset & ~(nand->erasesize - 1));
			offset += nand->erasesize - block_offset;
57e18404:	e28d2010 	add	r2, sp, #16
57e18408:	e8920006 	ldm	r2, {r1, r2}
57e1840c:	e5953010 	ldr	r3, [r5, #16]
57e18410:	e0644003 	rsb	r4, r4, r3
57e18414:	e0911004 	adds	r1, r1, r4
57e18418:	e2a22000 	adc	r2, r2, #0
57e1841c:	e58d1010 	str	r1, [sp, #16]
57e18420:	e58d2014 	str	r2, [sp, #20]
			continue;
57e18424:	ea000021 	b	57e184b0 <nand_read_skip_bad+0x1f4>
		}

		if (left_to_read < (nand->erasesize - block_offset))
57e18428:	e0644002 	rsb	r4, r4, r2
			read_length = left_to_read;
57e1842c:	e1570004 	cmp	r7, r4
57e18430:	31a04007 	movcc	r4, r7
extern int nand_curr_device;
extern nand_info_t nand_info[];

static inline int nand_read(nand_info_t *info, loff_t ofs, size_t *len, u_char *buf)
{
	return info->read(info, ofs, *len, (size_t *)len, buf);
57e18434:	e28d202c 	add	r2, sp, #44	; 0x2c
57e18438:	e58d402c 	str	r4, [sp, #44]	; 0x2c
57e1843c:	e58d4000 	str	r4, [sp]
57e18440:	e98d0204 	stmib	sp, {r2, r9}
57e18444:	e5951040 	ldr	r1, [r5, #64]	; 0x40
57e18448:	e1a00005 	mov	r0, r5
57e1844c:	e28d3010 	add	r3, sp, #16
57e18450:	e893000c 	ldm	r3, {r2, r3}
57e18454:	e12fff31 	blx	r1
		else
			read_length = nand->erasesize - block_offset;

		rval = nand_read(nand, offset, &read_length, p_buffer);
		if (rval && rval != -EUCLEAN) {
57e18458:	e3500000 	cmp	r0, #0
57e1845c:	13700075 	cmnne	r0, #117	; 0x75
57e18460:	e1a04000 	mov	r4, r0
57e18464:	0a000008 	beq	57e1848c <nand_read_skip_bad+0x1d0>
			printf("NAND read from offset %llx failed %d\n",
57e18468:	e58d0000 	str	r0, [sp]
57e1846c:	e28d3010 	add	r3, sp, #16
57e18470:	e893000c 	ldm	r3, {r2, r3}
57e18474:	e59f0054 	ldr	r0, [pc, #84]	; 57e184d0 <nand_read_skip_bad+0x214>
57e18478:	ebffc3f3 	bl	57e0944c <printf>
				offset, rval);
			*length -= left_to_read;
57e1847c:	e5963000 	ldr	r3, [r6]
57e18480:	e0677003 	rsb	r7, r7, r3
57e18484:	e5867000 	str	r7, [r6]
			return rval;
57e18488:	ea00000b 	b	57e184bc <nand_read_skip_bad+0x200>
		}

		left_to_read -= read_length;
57e1848c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
		offset       += read_length;
57e18490:	e28db010 	add	fp, sp, #16
57e18494:	e89b0c00 	ldm	fp, {sl, fp}
57e18498:	e09aa003 	adds	sl, sl, r3
57e1849c:	e2abb000 	adc	fp, fp, #0
57e184a0:	e58da010 	str	sl, [sp, #16]
57e184a4:	e58db014 	str	fp, [sp, #20]
				offset, rval);
			*length -= left_to_read;
			return rval;
		}

		left_to_read -= read_length;
57e184a8:	e0637007 	rsb	r7, r3, r7
		offset       += read_length;
		p_buffer     += read_length;
57e184ac:	e0899003 	add	r9, r9, r3
		printf("NAND read from offset %llx failed %d\n",
			offset, rval);
		return rval;
	}

	while (left_to_read > 0) {
57e184b0:	e3570000 	cmp	r7, #0
57e184b4:	1affffb8 	bne	57e1839c <nand_read_skip_bad+0xe0>
		left_to_read -= read_length;
		offset       += read_length;
		p_buffer     += read_length;
	}

	return 0;
57e184b8:	e1a04007 	mov	r4, r7
}
57e184bc:	e1a00004 	mov	r0, r4
57e184c0:	e28dd030 	add	sp, sp, #48	; 0x30
57e184c4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e184c8:	57e34218 	.word	0x57e34218
57e184cc:	57e3423f 	.word	0x57e3423f
57e184d0:	57e34267 	.word	0x57e34267
57e184d4:	57e3428d 	.word	0x57e3428d

57e184d8 <nand_calculate_ecc>:

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
57e184d8:	e3a0c000 	mov	ip, #0
 * @dat:	raw data
 * @ecc_code:	buffer for ECC
 */
int nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
		       u_char *ecc_code)
{
57e184dc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	reg1 = reg2 = reg3 = 0;

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[*dat++];
57e184e0:	e59f60dc 	ldr	r6, [pc, #220]	; 57e185c4 <nand_calculate_ecc+0xec>
{
	uint8_t idx, reg1, reg2, reg3, tmp1, tmp2;
	int i;

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;
57e184e4:	e1a0300c 	mov	r3, ip
57e184e8:	e1a0000c 	mov	r0, ip
57e184ec:	e1a0400c 	mov	r4, ip

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[*dat++];
57e184f0:	e7d1500c 	ldrb	r5, [r1, ip]
57e184f4:	e7d65005 	ldrb	r5, [r6, r5]
		reg1 ^= (idx & 0x3f);

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
57e184f8:	e3150040 	tst	r5, #64	; 0x40

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[*dat++];
		reg1 ^= (idx & 0x3f);
57e184fc:	e205703f 	and	r7, r5, #63	; 0x3f

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (uint8_t) i;
			reg2 ^= ~((uint8_t) i);
57e18500:	11e0500c 	mvnne	r5, ip
		idx = nand_ecc_precalc_table[*dat++];
		reg1 ^= (idx & 0x3f);

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (uint8_t) i;
57e18504:	1023300c 	eorne	r3, r3, ip
			reg2 ^= ~((uint8_t) i);
57e18508:	10250000 	eorne	r0, r5, r0

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
57e1850c:	e28cc001 	add	ip, ip, #1
		idx = nand_ecc_precalc_table[*dat++];
		reg1 ^= (idx & 0x3f);

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (uint8_t) i;
57e18510:	120330ff 	andne	r3, r3, #255	; 0xff
			reg2 ^= ~((uint8_t) i);
57e18514:	120000ff 	andne	r0, r0, #255	; 0xff

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
57e18518:	e35c0c01 	cmp	ip, #256	; 0x100
		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[*dat++];
		reg1 ^= (idx & 0x3f);
57e1851c:	e0244007 	eor	r4, r4, r7

	/* Initialize variables */
	reg1 = reg2 = reg3 = 0;

	/* Build up column parity */
	for(i = 0; i < 256; i++) {
57e18520:	1afffff2 	bne	57e184f0 <nand_calculate_ecc+0x18>
		}
	}

	/* Create non-inverted ECC code from line parity */
	tmp1  = (reg3 & 0x80) >> 0; /* B7 -> B7 */
	tmp1 |= (reg2 & 0x80) >> 1; /* B7 -> B6 */
57e18524:	e200c080 	and	ip, r0, #128	; 0x80
	tmp1 |= (reg3 & 0x40) >> 1; /* B6 -> B5 */
57e18528:	e2031040 	and	r1, r3, #64	; 0x40
		}
	}

	/* Create non-inverted ECC code from line parity */
	tmp1  = (reg3 & 0x80) >> 0; /* B7 -> B7 */
	tmp1 |= (reg2 & 0x80) >> 1; /* B7 -> B6 */
57e1852c:	e18c1001 	orr	r1, ip, r1
			reg2 ^= ~((uint8_t) i);
		}
	}

	/* Create non-inverted ECC code from line parity */
	tmp1  = (reg3 & 0x80) >> 0; /* B7 -> B7 */
57e18530:	e3c3c07f 	bic	ip, r3, #127	; 0x7f
	tmp1 |= (reg2 & 0x80) >> 1; /* B7 -> B6 */
	tmp1 |= (reg3 & 0x40) >> 1; /* B6 -> B5 */
57e18534:	e18c10a1 	orr	r1, ip, r1, lsr #1
	tmp1 |= (reg2 & 0x40) >> 2; /* B6 -> B4 */
57e18538:	e200c040 	and	ip, r0, #64	; 0x40
57e1853c:	e181112c 	orr	r1, r1, ip, lsr #2
	tmp1 |= (reg3 & 0x20) >> 2; /* B5 -> B3 */
57e18540:	e203c020 	and	ip, r3, #32
57e18544:	e181112c 	orr	r1, r1, ip, lsr #2
	tmp1 |= (reg2 & 0x20) >> 3; /* B5 -> B2 */
57e18548:	e200c020 	and	ip, r0, #32
57e1854c:	e18111ac 	orr	r1, r1, ip, lsr #3
	tmp1 |= (reg3 & 0x10) >> 3; /* B4 -> B1 */
57e18550:	e203c010 	and	ip, r3, #16
57e18554:	e18111ac 	orr	r1, r1, ip, lsr #3
	tmp1 |= (reg2 & 0x10) >> 4; /* B4 -> B0 */
57e18558:	e200c010 	and	ip, r0, #16

	tmp2  = (reg3 & 0x08) << 4; /* B3 -> B7 */
57e1855c:	e2035008 	and	r5, r3, #8
	tmp1 |= (reg3 & 0x40) >> 1; /* B6 -> B5 */
	tmp1 |= (reg2 & 0x40) >> 2; /* B6 -> B4 */
	tmp1 |= (reg3 & 0x20) >> 2; /* B5 -> B3 */
	tmp1 |= (reg2 & 0x20) >> 3; /* B5 -> B2 */
	tmp1 |= (reg3 & 0x10) >> 3; /* B4 -> B1 */
	tmp1 |= (reg2 & 0x10) >> 4; /* B4 -> B0 */
57e18560:	e181122c 	orr	r1, r1, ip, lsr #4
	tmp2 |= (reg3 & 0x04) << 3; /* B2 -> B5 */
	tmp2 |= (reg2 & 0x04) << 2; /* B2 -> B4 */
	tmp2 |= (reg3 & 0x02) << 2; /* B1 -> B3 */
	tmp2 |= (reg2 & 0x02) << 1; /* B1 -> B2 */
	tmp2 |= (reg3 & 0x01) << 1; /* B0 -> B1 */
	tmp2 |= (reg2 & 0x01) << 0; /* B7 -> B0 */
57e18564:	e200c001 	and	ip, r0, #1
	tmp1 |= (reg2 & 0x20) >> 3; /* B5 -> B2 */
	tmp1 |= (reg3 & 0x10) >> 3; /* B4 -> B1 */
	tmp1 |= (reg2 & 0x10) >> 4; /* B4 -> B0 */

	tmp2  = (reg3 & 0x08) << 4; /* B3 -> B7 */
	tmp2 |= (reg2 & 0x08) << 3; /* B3 -> B6 */
57e18568:	e18cc205 	orr	ip, ip, r5, lsl #4
57e1856c:	e2005008 	and	r5, r0, #8
	tmp2 |= (reg3 & 0x04) << 3; /* B2 -> B5 */
57e18570:	e18cc185 	orr	ip, ip, r5, lsl #3
57e18574:	e2035004 	and	r5, r3, #4
	tmp2 |= (reg2 & 0x04) << 2; /* B2 -> B4 */
57e18578:	e18cc185 	orr	ip, ip, r5, lsl #3
57e1857c:	e2005004 	and	r5, r0, #4
	tmp2 |= (reg3 & 0x02) << 2; /* B1 -> B3 */
57e18580:	e18cc105 	orr	ip, ip, r5, lsl #2
57e18584:	e2035002 	and	r5, r3, #2
	tmp2 |= (reg2 & 0x02) << 1; /* B1 -> B2 */
57e18588:	e18cc105 	orr	ip, ip, r5, lsl #2
57e1858c:	e2000002 	and	r0, r0, #2
	tmp2 |= (reg3 & 0x01) << 1; /* B0 -> B1 */
57e18590:	e18c0080 	orr	r0, ip, r0, lsl #1
57e18594:	e2033001 	and	r3, r3, #1
	ecc_code[1] = ~tmp1;
#else
	ecc_code[0] = ~tmp1;
	ecc_code[1] = ~tmp2;
#endif
	ecc_code[2] = ((~reg1) << 2) | 0x03;
57e18598:	e1e04004 	mvn	r4, r4
	tmp2 |= (reg3 & 0x04) << 3; /* B2 -> B5 */
	tmp2 |= (reg2 & 0x04) << 2; /* B2 -> B4 */
	tmp2 |= (reg3 & 0x02) << 2; /* B1 -> B3 */
	tmp2 |= (reg2 & 0x02) << 1; /* B1 -> B2 */
	tmp2 |= (reg3 & 0x01) << 1; /* B0 -> B1 */
	tmp2 |= (reg2 & 0x01) << 0; /* B7 -> B0 */
57e1859c:	e1803083 	orr	r3, r0, r3, lsl #1
	ecc_code[1] = ~tmp1;
#else
	ecc_code[0] = ~tmp1;
	ecc_code[1] = ~tmp2;
#endif
	ecc_code[2] = ((~reg1) << 2) | 0x03;
57e185a0:	e1a04104 	lsl	r4, r4, #2
	/* Calculate final ECC code */
#ifdef CONFIG_MTD_NAND_ECC_SMC
	ecc_code[0] = ~tmp2;
	ecc_code[1] = ~tmp1;
#else
	ecc_code[0] = ~tmp1;
57e185a4:	e1e01001 	mvn	r1, r1
	ecc_code[1] = ~tmp2;
57e185a8:	e1e03003 	mvn	r3, r3
#endif
	ecc_code[2] = ((~reg1) << 2) | 0x03;
57e185ac:	e3844003 	orr	r4, r4, #3
	/* Calculate final ECC code */
#ifdef CONFIG_MTD_NAND_ECC_SMC
	ecc_code[0] = ~tmp2;
	ecc_code[1] = ~tmp1;
#else
	ecc_code[0] = ~tmp1;
57e185b0:	e5c21000 	strb	r1, [r2]
	ecc_code[1] = ~tmp2;
57e185b4:	e5c23001 	strb	r3, [r2, #1]
#endif
	ecc_code[2] = ((~reg1) << 2) | 0x03;
57e185b8:	e5c24002 	strb	r4, [r2, #2]

	return 0;
}
57e185bc:	e3a00000 	mov	r0, #0
57e185c0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
57e185c4:	57e2cb6c 	.word	0x57e2cb6c

57e185c8 <nand_correct_data>:
 *
 * Detect and correct a 1 bit error for 256 byte block
 */
int nand_correct_data(struct mtd_info *mtd, u_char *dat,
		      u_char *read_ecc, u_char *calc_ecc)
{
57e185c8:	e92d4070 	push	{r4, r5, r6, lr}
#ifdef CONFIG_MTD_NAND_ECC_SMC
	s0 = calc_ecc[0] ^ read_ecc[0];
	s1 = calc_ecc[1] ^ read_ecc[1];
	s2 = calc_ecc[2] ^ read_ecc[2];
#else
	s1 = calc_ecc[0] ^ read_ecc[0];
57e185cc:	e5d35000 	ldrb	r5, [r3]
57e185d0:	e5d20000 	ldrb	r0, [r2]
	s0 = calc_ecc[1] ^ read_ecc[1];
57e185d4:	e5d34001 	ldrb	r4, [r3, #1]
#ifdef CONFIG_MTD_NAND_ECC_SMC
	s0 = calc_ecc[0] ^ read_ecc[0];
	s1 = calc_ecc[1] ^ read_ecc[1];
	s2 = calc_ecc[2] ^ read_ecc[2];
#else
	s1 = calc_ecc[0] ^ read_ecc[0];
57e185d8:	e0255000 	eor	r5, r5, r0
	s0 = calc_ecc[1] ^ read_ecc[1];
57e185dc:	e5d20001 	ldrb	r0, [r2, #1]
#ifdef CONFIG_MTD_NAND_ECC_SMC
	s0 = calc_ecc[0] ^ read_ecc[0];
	s1 = calc_ecc[1] ^ read_ecc[1];
	s2 = calc_ecc[2] ^ read_ecc[2];
#else
	s1 = calc_ecc[0] ^ read_ecc[0];
57e185e0:	e205c0ff 	and	ip, r5, #255	; 0xff
	s0 = calc_ecc[1] ^ read_ecc[1];
57e185e4:	e0244000 	eor	r4, r4, r0
	s2 = calc_ecc[2] ^ read_ecc[2];
57e185e8:	e5d30002 	ldrb	r0, [r3, #2]
57e185ec:	e5d23002 	ldrb	r3, [r2, #2]
57e185f0:	e0203003 	eor	r3, r0, r3
#endif
	if ((s0 | s1 | s2) == 0)
57e185f4:	e1840003 	orr	r0, r4, r3
57e185f8:	e19c0000 	orrs	r0, ip, r0
57e185fc:	08bd8070 	popeq	{r4, r5, r6, pc}
		return 0;

	/* Check for a single bit error */
	if( ((s0 ^ (s0 >> 1)) & 0x55) == 0x55 &&
57e18600:	e1a020a4 	lsr	r2, r4, #1
57e18604:	e0220004 	eor	r0, r2, r4
57e18608:	e2000055 	and	r0, r0, #85	; 0x55
57e1860c:	e3500055 	cmp	r0, #85	; 0x55
57e18610:	1a000028 	bne	57e186b8 <nand_correct_data+0xf0>
	    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
57e18614:	e02c00ac 	eor	r0, ip, ip, lsr #1
57e18618:	e2000055 	and	r0, r0, #85	; 0x55
#endif
	if ((s0 | s1 | s2) == 0)
		return 0;

	/* Check for a single bit error */
	if( ((s0 ^ (s0 >> 1)) & 0x55) == 0x55 &&
57e1861c:	e3500055 	cmp	r0, #85	; 0x55
57e18620:	1a000024 	bne	57e186b8 <nand_correct_data+0xf0>
	    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {
57e18624:	e02300a3 	eor	r0, r3, r3, lsr #1
57e18628:	e2000054 	and	r0, r0, #84	; 0x54
	if ((s0 | s1 | s2) == 0)
		return 0;

	/* Check for a single bit error */
	if( ((s0 ^ (s0 >> 1)) & 0x55) == 0x55 &&
	    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
57e1862c:	e3500054 	cmp	r0, #84	; 0x54
57e18630:	1a000020 	bne	57e186b8 <nand_correct_data+0xf0>
	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {

		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
57e18634:	e1a0608c 	lsl	r6, ip, #1
		byteoffs |= (s1 << 2) & 0x20;
57e18638:	e1a0010c 	lsl	r0, ip, #2
	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {

		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
57e1863c:	e2066040 	and	r6, r6, #64	; 0x40
		byteoffs |= (s1 << 2) & 0x20;
57e18640:	e2000020 	and	r0, r0, #32
	    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {

		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
57e18644:	e2055080 	and	r5, r5, #128	; 0x80
		byteoffs |= (s1 << 1) & 0x40;
57e18648:	e1860000 	orr	r0, r6, r0
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;
57e1864c:	e1a0c18c 	lsl	ip, ip, #3
57e18650:	e20cc010 	and	ip, ip, #16

		uint32_t byteoffs, bitnum;

		byteoffs = (s1 << 0) & 0x80;
		byteoffs |= (s1 << 1) & 0x40;
		byteoffs |= (s1 << 2) & 0x20;
57e18654:	e1800005 	orr	r0, r0, r5
		byteoffs |= (s1 << 3) & 0x10;
57e18658:	e180000c 	orr	r0, r0, ip

		byteoffs |= (s0 >> 4) & 0x08;
57e1865c:	e1a0c224 	lsr	ip, r4, #4
57e18660:	e20cc008 	and	ip, ip, #8
57e18664:	e180000c 	orr	r0, r0, ip
		byteoffs |= (s0 >> 3) & 0x04;
57e18668:	e1a0c1a4 	lsr	ip, r4, #3
57e1866c:	e20cc004 	and	ip, ip, #4
		byteoffs |= (s0 >> 2) & 0x02;
57e18670:	e1a04124 	lsr	r4, r4, #2
		byteoffs |= (s1 << 1) & 0x40;
		byteoffs |= (s1 << 2) & 0x20;
		byteoffs |= (s1 << 3) & 0x10;

		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
57e18674:	e180000c 	orr	r0, r0, ip
		byteoffs |= (s0 >> 2) & 0x02;
57e18678:	e2044002 	and	r4, r4, #2
57e1867c:	e1804004 	orr	r4, r0, r4
		byteoffs |= (s0 >> 1) & 0x01;

		bitnum = (s2 >> 5) & 0x04;
57e18680:	e1a0c2a3 	lsr	ip, r3, #5
		bitnum |= (s2 >> 4) & 0x02;
57e18684:	e1a00223 	lsr	r0, r3, #4
		byteoffs |= (s1 << 3) & 0x10;

		byteoffs |= (s0 >> 4) & 0x08;
		byteoffs |= (s0 >> 3) & 0x04;
		byteoffs |= (s0 >> 2) & 0x02;
		byteoffs |= (s0 >> 1) & 0x01;
57e18688:	e2022001 	and	r2, r2, #1
57e1868c:	e1844002 	orr	r4, r4, r2

		bitnum = (s2 >> 5) & 0x04;
57e18690:	e20cc004 	and	ip, ip, #4
		bitnum |= (s2 >> 4) & 0x02;
57e18694:	e2000002 	and	r0, r0, #2
57e18698:	e180000c 	orr	r0, r0, ip
		bitnum |= (s2 >> 3) & 0x01;

		dat[byteoffs] ^= (1 << bitnum);
57e1869c:	e7d12004 	ldrb	r2, [r1, r4]
		byteoffs |= (s0 >> 2) & 0x02;
		byteoffs |= (s0 >> 1) & 0x01;

		bitnum = (s2 >> 5) & 0x04;
		bitnum |= (s2 >> 4) & 0x02;
		bitnum |= (s2 >> 3) & 0x01;
57e186a0:	e1a03e03 	lsl	r3, r3, #28
57e186a4:	e1803fa3 	orr	r3, r0, r3, lsr #31

		dat[byteoffs] ^= (1 << bitnum);
57e186a8:	e3a00001 	mov	r0, #1
57e186ac:	e0223310 	eor	r3, r2, r0, lsl r3
57e186b0:	e7c13004 	strb	r3, [r1, r4]

		return 1;
57e186b4:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	if(countbits(s0 | ((uint32_t)s1 << 8) | ((uint32_t)s2 <<16)) == 1)
57e186b8:	e184c40c 	orr	ip, r4, ip, lsl #8
57e186bc:	e18c3803 	orr	r3, ip, r3, lsl #16
}
#endif /* CONFIG_NAND_SPL */

static inline int countbits(uint32_t byte)
{
	int res = 0;
57e186c0:	e3a00000 	mov	r0, #0
57e186c4:	ea000002 	b	57e186d4 <nand_correct_data+0x10c>

	for (;byte; byte >>= 1)
		res += byte & 0x01;
57e186c8:	e2032001 	and	r2, r3, #1
57e186cc:	e0820000 	add	r0, r2, r0

static inline int countbits(uint32_t byte)
{
	int res = 0;

	for (;byte; byte >>= 1)
57e186d0:	e1a030a3 	lsr	r3, r3, #1
57e186d4:	e3530000 	cmp	r3, #0
57e186d8:	1afffffa 	bne	57e186c8 <nand_correct_data+0x100>

		return 1;
	}

	if(countbits(s0 | ((uint32_t)s1 << 8) | ((uint32_t)s2 <<16)) == 1)
		return 1;
57e186dc:	e3500001 	cmp	r0, #1
57e186e0:	13e00049 	mvnne	r0, #73	; 0x49

	return -EBADMSG;
}
57e186e4:	e8bd8070 	pop	{r4, r5, r6, pc}

57e186e8 <generic_ffs>:

static inline int generic_ffs(int x)
{
	int r = 1;

	if (!x)
57e186e8:	e2503000 	subs	r3, r0, #0
57e186ec:	0a00000f 	beq	57e18730 <generic_ffs+0x48>
		return 0;
	if (!(x & 0xffff)) {
57e186f0:	e1b02803 	lsls	r2, r3, #16
		x >>= 16;
57e186f4:	01a03843 	asreq	r3, r3, #16
		r += 16;
57e186f8:	03a00011 	moveq	r0, #17
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
	int r = 1;
57e186fc:	13a00001 	movne	r0, #1
		return 0;
	if (!(x & 0xffff)) {
		x >>= 16;
		r += 16;
	}
	if (!(x & 0xff)) {
57e18700:	e31300ff 	tst	r3, #255	; 0xff
		x >>= 8;
57e18704:	01a03443 	asreq	r3, r3, #8
		r += 8;
57e18708:	02800008 	addeq	r0, r0, #8
	}
	if (!(x & 0xf)) {
57e1870c:	e313000f 	tst	r3, #15
		x >>= 4;
57e18710:	01a03243 	asreq	r3, r3, #4
		r += 4;
57e18714:	02800004 	addeq	r0, r0, #4
	}
	if (!(x & 3)) {
57e18718:	e3130003 	tst	r3, #3
		x >>= 2;
57e1871c:	01a03143 	asreq	r3, r3, #2
		r += 2;
57e18720:	02800002 	addeq	r0, r0, #2
	}
	if (!(x & 1)) {
57e18724:	e3130001 	tst	r3, #1
		x >>= 1;
		r += 1;
57e18728:	02800001 	addeq	r0, r0, #1
57e1872c:	e12fff1e 	bx	lr
static inline int generic_ffs(int x)
{
	int r = 1;

	if (!x)
		return 0;
57e18730:	e1a00003 	mov	r0, r3
	if (!(x & 1)) {
		x >>= 1;
		r += 1;
	}
	return r;
}
57e18734:	e12fff1e 	bx	lr

57e18738 <nand_bch_calculate_ecc>:
static inline int
nand_bch_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
		       u_char *ecc_code)
{
	return -1;
}
57e18738:	e3e00000 	mvn	r0, #0
57e1873c:	e12fff1e 	bx	lr

57e18740 <nand_bch_correct_data>:
static inline int
nand_bch_correct_data(struct mtd_info *mtd, unsigned char *buf,
		      unsigned char *read_ecc, unsigned char *calc_ecc)
{
	return -1;
}
57e18740:	e3e00000 	mvn	r0, #0
57e18744:	e12fff1e 	bx	lr

57e18748 <nand_release_device>:
 * @mtd:	MTD device structure
 *
 * Deselect, release chip lock and wake up anyone waiting on the device
 */
static void nand_release_device(struct mtd_info *mtd)
{
57e18748:	e92d4008 	push	{r3, lr}
	struct nand_chip *chip = mtd->priv;

	/* De-select the NAND device */
	chip->select_chip(mtd, -1);
57e1874c:	e5903094 	ldr	r3, [r0, #148]	; 0x94
57e18750:	e3e01000 	mvn	r1, #0
57e18754:	e593301c 	ldr	r3, [r3, #28]
57e18758:	e12fff33 	blx	r3
}
57e1875c:	e8bd8008 	pop	{r3, pc}

57e18760 <nand_read_byte>:
 * Default read function for 8bit buswith
 */
uint8_t nand_read_byte(struct mtd_info *mtd)
{
	struct nand_chip *chip = mtd->priv;
	return readb(chip->IO_ADDR_R);
57e18760:	e5903094 	ldr	r3, [r0, #148]	; 0x94
57e18764:	e5933000 	ldr	r3, [r3]
57e18768:	e5d30000 	ldrb	r0, [r3]
57e1876c:	e20000ff 	and	r0, r0, #255	; 0xff
}
57e18770:	e12fff1e 	bx	lr

57e18774 <nand_read_byte16>:
 * endianess conversion
 */
static uint8_t nand_read_byte16(struct mtd_info *mtd)
{
	struct nand_chip *chip = mtd->priv;
	return (uint8_t) cpu_to_le16(readw(chip->IO_ADDR_R));
57e18774:	e5903094 	ldr	r3, [r0, #148]	; 0x94
57e18778:	e5933000 	ldr	r3, [r3]
57e1877c:	e1d300b0 	ldrh	r0, [r3]
57e18780:	e20000ff 	and	r0, r0, #255	; 0xff
}
57e18784:	e12fff1e 	bx	lr

57e18788 <nand_read_word>:
 * endianess conversion
 */
static u16 nand_read_word(struct mtd_info *mtd)
{
	struct nand_chip *chip = mtd->priv;
	return readw(chip->IO_ADDR_R);
57e18788:	e5903094 	ldr	r3, [r0, #148]	; 0x94
57e1878c:	e5933000 	ldr	r3, [r3]
57e18790:	e1d300b0 	ldrh	r0, [r3]
}
57e18794:	e12fff1e 	bx	lr

57e18798 <nand_write_buf>:
 * @len:	number of bytes to write
 *
 * Default write function for 8bit buswith
 */
void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
{
57e18798:	e92d4010 	push	{r4, lr}
	int i;
	struct nand_chip *chip = mtd->priv;
57e1879c:	e5900094 	ldr	r0, [r0, #148]	; 0x94

	for (i = 0; i < len; i++)
57e187a0:	e3a03000 	mov	r3, #0
57e187a4:	ea000003 	b	57e187b8 <nand_write_buf+0x20>
		writeb(buf[i], chip->IO_ADDR_W);
57e187a8:	e7d14003 	ldrb	r4, [r1, r3]
57e187ac:	e590c004 	ldr	ip, [r0, #4]
void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
{
	int i;
	struct nand_chip *chip = mtd->priv;

	for (i = 0; i < len; i++)
57e187b0:	e2833001 	add	r3, r3, #1
		writeb(buf[i], chip->IO_ADDR_W);
57e187b4:	e5cc4000 	strb	r4, [ip]
void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
{
	int i;
	struct nand_chip *chip = mtd->priv;

	for (i = 0; i < len; i++)
57e187b8:	e1530002 	cmp	r3, r2
57e187bc:	bafffff9 	blt	57e187a8 <nand_write_buf+0x10>
		writeb(buf[i], chip->IO_ADDR_W);
}
57e187c0:	e8bd8010 	pop	{r4, pc}

57e187c4 <nand_read_buf>:
 * Default read function for 8bit buswith
 */
void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
{
	int i;
	struct nand_chip *chip = mtd->priv;
57e187c4:	e5900094 	ldr	r0, [r0, #148]	; 0x94

	for (i = 0; i < len; i++)
57e187c8:	e3a03000 	mov	r3, #0
57e187cc:	ea000004 	b	57e187e4 <nand_read_buf+0x20>
		buf[i] = readb(chip->IO_ADDR_R);
57e187d0:	e590c000 	ldr	ip, [r0]
57e187d4:	e5dcc000 	ldrb	ip, [ip]
57e187d8:	e20cc0ff 	and	ip, ip, #255	; 0xff
57e187dc:	e7c1c003 	strb	ip, [r1, r3]
void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
{
	int i;
	struct nand_chip *chip = mtd->priv;

	for (i = 0; i < len; i++)
57e187e0:	e2833001 	add	r3, r3, #1
57e187e4:	e1530002 	cmp	r3, r2
57e187e8:	bafffff8 	blt	57e187d0 <nand_read_buf+0xc>
		buf[i] = readb(chip->IO_ADDR_R);
}
57e187ec:	e12fff1e 	bx	lr

57e187f0 <nand_verify_buf>:
 * @len:	number of bytes to compare
 *
 * Default verify function for 8bit buswith
 */
static int nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
{
57e187f0:	e92d4010 	push	{r4, lr}
	int i;
	struct nand_chip *chip = mtd->priv;
57e187f4:	e5900094 	ldr	r0, [r0, #148]	; 0x94

	for (i = 0; i < len; i++)
57e187f8:	e3a03000 	mov	r3, #0
57e187fc:	ea000006 	b	57e1881c <nand_verify_buf+0x2c>
		if (buf[i] != readb(chip->IO_ADDR_R))
57e18800:	e590c000 	ldr	ip, [r0]
57e18804:	e7d14003 	ldrb	r4, [r1, r3]
57e18808:	e5dcc000 	ldrb	ip, [ip]
57e1880c:	e20cc0ff 	and	ip, ip, #255	; 0xff
57e18810:	e154000c 	cmp	r4, ip
57e18814:	1a000004 	bne	57e1882c <nand_verify_buf+0x3c>
static int nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
{
	int i;
	struct nand_chip *chip = mtd->priv;

	for (i = 0; i < len; i++)
57e18818:	e2833001 	add	r3, r3, #1
57e1881c:	e1530002 	cmp	r3, r2
57e18820:	bafffff6 	blt	57e18800 <nand_verify_buf+0x10>
		if (buf[i] != readb(chip->IO_ADDR_R))
			return -EFAULT;
	return 0;
57e18824:	e3a00000 	mov	r0, #0
57e18828:	e8bd8010 	pop	{r4, pc}
	int i;
	struct nand_chip *chip = mtd->priv;

	for (i = 0; i < len; i++)
		if (buf[i] != readb(chip->IO_ADDR_R))
			return -EFAULT;
57e1882c:	e3e0000d 	mvn	r0, #13
	return 0;
}
57e18830:	e8bd8010 	pop	{r4, pc}

57e18834 <nand_write_buf16>:
 * Default write function for 16bit buswith
 */
void nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
{
	int i;
	struct nand_chip *chip = mtd->priv;
57e18834:	e5903094 	ldr	r3, [r0, #148]	; 0x94
 * @len:	number of bytes to write
 *
 * Default write function for 16bit buswith
 */
void nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
{
57e18838:	e92d4010 	push	{r4, lr}
	int i;
	struct nand_chip *chip = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;
57e1883c:	e1a020c2 	asr	r2, r2, #1

	for (i = 0; i < len; i++)
57e18840:	e3a00000 	mov	r0, #0
57e18844:	ea000003 	b	57e18858 <nand_write_buf16+0x24>
		writew(p[i], chip->IO_ADDR_W);
57e18848:	e0d140b2 	ldrh	r4, [r1], #2
57e1884c:	e593c004 	ldr	ip, [r3, #4]
	int i;
	struct nand_chip *chip = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i = 0; i < len; i++)
57e18850:	e2800001 	add	r0, r0, #1
		writew(p[i], chip->IO_ADDR_W);
57e18854:	e1cc40b0 	strh	r4, [ip]
	int i;
	struct nand_chip *chip = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i = 0; i < len; i++)
57e18858:	e1500002 	cmp	r0, r2
57e1885c:	bafffff9 	blt	57e18848 <nand_write_buf16+0x14>
		writew(p[i], chip->IO_ADDR_W);

}
57e18860:	e8bd8010 	pop	{r4, pc}

57e18864 <nand_read_buf16>:
 * Default read function for 16bit buswith
 */
void nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len)
{
	int i;
	struct nand_chip *chip = mtd->priv;
57e18864:	e5903094 	ldr	r3, [r0, #148]	; 0x94
	u16 *p = (u16 *) buf;
	len >>= 1;
57e18868:	e1a020c2 	asr	r2, r2, #1

	for (i = 0; i < len; i++)
57e1886c:	e3a00000 	mov	r0, #0
57e18870:	ea000003 	b	57e18884 <nand_read_buf16+0x20>
		p[i] = readw(chip->IO_ADDR_R);
57e18874:	e593c000 	ldr	ip, [r3]
57e18878:	e1dcc0b0 	ldrh	ip, [ip]
57e1887c:	e0c1c0b2 	strh	ip, [r1], #2
	int i;
	struct nand_chip *chip = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i = 0; i < len; i++)
57e18880:	e2800001 	add	r0, r0, #1
57e18884:	e1500002 	cmp	r0, r2
57e18888:	bafffff9 	blt	57e18874 <nand_read_buf16+0x10>
		p[i] = readw(chip->IO_ADDR_R);
}
57e1888c:	e12fff1e 	bx	lr

57e18890 <nand_verify_buf16>:
 * Default verify function for 16bit buswith
 */
static int nand_verify_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
{
	int i;
	struct nand_chip *chip = mtd->priv;
57e18890:	e5903094 	ldr	r3, [r0, #148]	; 0x94
 * @len:	number of bytes to compare
 *
 * Default verify function for 16bit buswith
 */
static int nand_verify_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
{
57e18894:	e92d4010 	push	{r4, lr}
	int i;
	struct nand_chip *chip = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;
57e18898:	e1a020c2 	asr	r2, r2, #1

	for (i = 0; i < len; i++)
57e1889c:	e3a00000 	mov	r0, #0
57e188a0:	ea000005 	b	57e188bc <nand_verify_buf16+0x2c>
		if (p[i] != readw(chip->IO_ADDR_R))
57e188a4:	e593c000 	ldr	ip, [r3]
57e188a8:	e0d140b2 	ldrh	r4, [r1], #2
57e188ac:	e1dcc0b0 	ldrh	ip, [ip]
57e188b0:	e154000c 	cmp	r4, ip
57e188b4:	1a000004 	bne	57e188cc <nand_verify_buf16+0x3c>
	int i;
	struct nand_chip *chip = mtd->priv;
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i = 0; i < len; i++)
57e188b8:	e2800001 	add	r0, r0, #1
57e188bc:	e1500002 	cmp	r0, r2
57e188c0:	bafffff7 	blt	57e188a4 <nand_verify_buf16+0x14>
		if (p[i] != readw(chip->IO_ADDR_R))
			return -EFAULT;

	return 0;
57e188c4:	e3a00000 	mov	r0, #0
57e188c8:	e8bd8010 	pop	{r4, pc}
	u16 *p = (u16 *) buf;
	len >>= 1;

	for (i = 0; i < len; i++)
		if (p[i] != readw(chip->IO_ADDR_R))
			return -EFAULT;
57e188cc:	e3e0000d 	mvn	r0, #13

	return 0;
}
57e188d0:	e8bd8010 	pop	{r4, pc}

57e188d4 <nand_check_wp>:
 * Check, if the device is write protected
 *
 * The function expects, that the device is already selected
 */
static int nand_check_wp(struct mtd_info *mtd)
{
57e188d4:	e92d4038 	push	{r3, r4, r5, lr}
	struct nand_chip *chip = mtd->priv;
57e188d8:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * Check, if the device is write protected
 *
 * The function expects, that the device is already selected
 */
static int nand_check_wp(struct mtd_info *mtd)
{
57e188dc:	e1a05000 	mov	r5, r0
	struct nand_chip *chip = mtd->priv;

	/* broken xD cards report WP despite being writable */
	if (chip->options & NAND_BROKEN_XD)
57e188e0:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e188e4:	e3130b01 	tst	r3, #1024	; 0x400
57e188e8:	1a00000b 	bne	57e1891c <nand_check_wp+0x48>
		return 0;

	/* Check the WP bit */
	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
57e188ec:	e3e02000 	mvn	r2, #0
57e188f0:	e1a03002 	mov	r3, r2
57e188f4:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e188f8:	e3a01070 	mov	r1, #112	; 0x70
57e188fc:	e12fff3c 	blx	ip
	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
57e18900:	e5943008 	ldr	r3, [r4, #8]
57e18904:	e1a00005 	mov	r0, r5
57e18908:	e12fff33 	blx	r3
57e1890c:	e1a00c00 	lsl	r0, r0, #24
57e18910:	e1e00000 	mvn	r0, r0
57e18914:	e1a00fa0 	lsr	r0, r0, #31
57e18918:	e8bd8038 	pop	{r3, r4, r5, pc}
{
	struct nand_chip *chip = mtd->priv;

	/* broken xD cards report WP despite being writable */
	if (chip->options & NAND_BROKEN_XD)
		return 0;
57e1891c:	e3a00000 	mov	r0, #0

	/* Check the WP bit */
	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
}
57e18920:	e8bd8038 	pop	{r3, r4, r5, pc}

57e18924 <nand_read_page_raw>:
 *
 * Not for syndrome calculating ecc controllers, which use a special oob layout
 */
static int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
			      uint8_t *buf, int page)
{
57e18924:	e92d4038 	push	{r3, r4, r5, lr}
57e18928:	e1a05000 	mov	r5, r0
57e1892c:	e1a04001 	mov	r4, r1
	chip->read_buf(mtd, buf, mtd->writesize);
57e18930:	e5913014 	ldr	r3, [r1, #20]
57e18934:	e1a01002 	mov	r1, r2
57e18938:	e5902014 	ldr	r2, [r0, #20]
57e1893c:	e12fff33 	blx	r3
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
57e18940:	e1a00005 	mov	r0, r5
57e18944:	e5943014 	ldr	r3, [r4, #20]
57e18948:	e5941090 	ldr	r1, [r4, #144]	; 0x90
57e1894c:	e5952018 	ldr	r2, [r5, #24]
57e18950:	e12fff33 	blx	r3
	return 0;
}
57e18954:	e3a00000 	mov	r0, #0
57e18958:	e8bd8038 	pop	{r3, r4, r5, pc}

57e1895c <nand_read_page_raw_syndrome>:
 * We need a special oob layout and handling even when OOB isn't used.
 */
static int nand_read_page_raw_syndrome(struct mtd_info *mtd,
					struct nand_chip *chip,
					uint8_t *buf, int page)
{
57e1895c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e18960:	e1a06000 	mov	r6, r0
57e18964:	e1a04001 	mov	r4, r1
57e18968:	e1a07002 	mov	r7, r2
	int eccsize = chip->ecc.size;
57e1896c:	e59190a4 	ldr	r9, [r1, #164]	; 0xa4
	int eccbytes = chip->ecc.bytes;
57e18970:	e591b0a8 	ldr	fp, [r1, #168]	; 0xa8
	uint8_t *oob = chip->oob_poi;
57e18974:	e5915090 	ldr	r5, [r1, #144]	; 0x90
	int steps, size;

	for (steps = chip->ecc.steps; steps > 0; steps--) {
57e18978:	e591a0a0 	ldr	sl, [r1, #160]	; 0xa0
57e1897c:	ea00001e 	b	57e189fc <nand_read_page_raw_syndrome+0xa0>
		chip->read_buf(mtd, buf, eccsize);
57e18980:	e1a01007 	mov	r1, r7
57e18984:	e1a02009 	mov	r2, r9
57e18988:	e5943014 	ldr	r3, [r4, #20]
57e1898c:	e1a00006 	mov	r0, r6
57e18990:	e12fff33 	blx	r3
		buf += eccsize;

		if (chip->ecc.prepad) {
57e18994:	e59420b0 	ldr	r2, [r4, #176]	; 0xb0
 * @buf:	buffer to store read data
 * @page:	page number to read
 *
 * We need a special oob layout and handling even when OOB isn't used.
 */
static int nand_read_page_raw_syndrome(struct mtd_info *mtd,
57e18998:	e0877009 	add	r7, r7, r9

	for (steps = chip->ecc.steps; steps > 0; steps--) {
		chip->read_buf(mtd, buf, eccsize);
		buf += eccsize;

		if (chip->ecc.prepad) {
57e1899c:	e3520000 	cmp	r2, #0
57e189a0:	0a000005 	beq	57e189bc <nand_read_page_raw_syndrome+0x60>
			chip->read_buf(mtd, oob, chip->ecc.prepad);
57e189a4:	e5943014 	ldr	r3, [r4, #20]
57e189a8:	e1a01005 	mov	r1, r5
57e189ac:	e1a00006 	mov	r0, r6
57e189b0:	e12fff33 	blx	r3
			oob += chip->ecc.prepad;
57e189b4:	e59430b0 	ldr	r3, [r4, #176]	; 0xb0
57e189b8:	e0855003 	add	r5, r5, r3
		}

		chip->read_buf(mtd, oob, eccbytes);
57e189bc:	e1a01005 	mov	r1, r5
57e189c0:	e1a0200b 	mov	r2, fp
57e189c4:	e5943014 	ldr	r3, [r4, #20]
57e189c8:	e1a00006 	mov	r0, r6
57e189cc:	e12fff33 	blx	r3
		oob += eccbytes;

		if (chip->ecc.postpad) {
57e189d0:	e59420b4 	ldr	r2, [r4, #180]	; 0xb4
			chip->read_buf(mtd, oob, chip->ecc.prepad);
			oob += chip->ecc.prepad;
		}

		chip->read_buf(mtd, oob, eccbytes);
		oob += eccbytes;
57e189d4:	e085500b 	add	r5, r5, fp

		if (chip->ecc.postpad) {
57e189d8:	e3520000 	cmp	r2, #0
57e189dc:	0a000005 	beq	57e189f8 <nand_read_page_raw_syndrome+0x9c>
			chip->read_buf(mtd, oob, chip->ecc.postpad);
57e189e0:	e5943014 	ldr	r3, [r4, #20]
57e189e4:	e1a01005 	mov	r1, r5
57e189e8:	e1a00006 	mov	r0, r6
57e189ec:	e12fff33 	blx	r3
			oob += chip->ecc.postpad;
57e189f0:	e59430b4 	ldr	r3, [r4, #180]	; 0xb4
57e189f4:	e0855003 	add	r5, r5, r3
	int eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	uint8_t *oob = chip->oob_poi;
	int steps, size;

	for (steps = chip->ecc.steps; steps > 0; steps--) {
57e189f8:	e24aa001 	sub	sl, sl, #1
57e189fc:	e35a0000 	cmp	sl, #0
57e18a00:	caffffde 	bgt	57e18980 <nand_read_page_raw_syndrome+0x24>
			chip->read_buf(mtd, oob, chip->ecc.postpad);
			oob += chip->ecc.postpad;
		}
	}

	size = mtd->oobsize - (oob - chip->oob_poi);
57e18a04:	e5942090 	ldr	r2, [r4, #144]	; 0x90
57e18a08:	e5963018 	ldr	r3, [r6, #24]
57e18a0c:	e0652002 	rsb	r2, r5, r2
	if (size)
57e18a10:	e0922003 	adds	r2, r2, r3
57e18a14:	0a000003 	beq	57e18a28 <nand_read_page_raw_syndrome+0xcc>
		chip->read_buf(mtd, oob, size);
57e18a18:	e5943014 	ldr	r3, [r4, #20]
57e18a1c:	e1a00006 	mov	r0, r6
57e18a20:	e1a01005 	mov	r1, r5
57e18a24:	e12fff33 	blx	r3

	return 0;
}
57e18a28:	e3a00000 	mov	r0, #0
57e18a2c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e18a30 <nand_read_page_swecc>:
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
				uint8_t *buf, int page)
{
57e18a30:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int i, eccsize = chip->ecc.size;
57e18a34:	e591c0a4 	ldr	ip, [r1, #164]	; 0xa4
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
				uint8_t *buf, int page)
{
57e18a38:	e1a0b002 	mov	fp, r2
	int i, eccsize = chip->ecc.size;
57e18a3c:	e58dc004 	str	ip, [sp, #4]
	int eccbytes = chip->ecc.bytes;
57e18a40:	e591c0a8 	ldr	ip, [r1, #168]	; 0xa8
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
				uint8_t *buf, int page)
{
57e18a44:	e1a05000 	mov	r5, r0
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
57e18a48:	e58dc008 	str	ip, [sp, #8]
	int eccsteps = chip->ecc.steps;
	uint8_t *p = buf;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e18a4c:	e591c0b8 	ldr	ip, [r1, #184]	; 0xb8
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
				uint8_t *buf, int page)
{
57e18a50:	e1a04001 	mov	r4, r1
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *p = buf;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e18a54:	e58dc00c 	str	ip, [sp, #12]

	chip->ecc.read_page_raw(mtd, chip, buf, page);
57e18a58:	e591c0cc 	ldr	ip, [r1, #204]	; 0xcc
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
				uint8_t *buf, int page)
{
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
57e18a5c:	e59160a0 	ldr	r6, [r1, #160]	; 0xa0
	uint8_t *p = buf;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
57e18a60:	e59190e8 	ldr	r9, [r1, #232]	; 0xe8
				uint8_t *buf, int page)
{
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *p = buf;
57e18a64:	e1a0700b 	mov	r7, fp
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	chip->ecc.read_page_raw(mtd, chip, buf, page);
57e18a68:	e12fff3c 	blx	ip

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
57e18a6c:	e3a0a000 	mov	sl, #0
57e18a70:	ea000009 	b	57e18a9c <nand_read_page_swecc+0x6c>
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
57e18a74:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
57e18a78:	e1a01007 	mov	r1, r7
57e18a7c:	e089200a 	add	r2, r9, sl
57e18a80:	e1a00005 	mov	r0, r5
57e18a84:	e12fff33 	blx	r3
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18a88:	e59d3008 	ldr	r3, [sp, #8]
57e18a8c:	e59dc004 	ldr	ip, [sp, #4]
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	chip->ecc.read_page_raw(mtd, chip, buf, page);

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
57e18a90:	e2466001 	sub	r6, r6, #1
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18a94:	e08aa003 	add	sl, sl, r3
57e18a98:	e087700c 	add	r7, r7, ip
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	chip->ecc.read_page_raw(mtd, chip, buf, page);

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
57e18a9c:	e3560000 	cmp	r6, #0
57e18aa0:	1afffff3 	bne	57e18a74 <nand_read_page_swecc+0x44>
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18aa4:	e2893f8f 	add	r3, r9, #572	; 0x23c
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	chip->ecc.read_page_raw(mtd, chip, buf, page);

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
57e18aa8:	e59d200c 	ldr	r2, [sp, #12]
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18aac:	e2833003 	add	r3, r3, #3
57e18ab0:	ea000004 	b	57e18ac8 <nand_read_page_swecc+0x98>

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);

	for (i = 0; i < chip->ecc.total; i++)
		ecc_code[i] = chip->oob_poi[eccpos[i]];
57e18ab4:	e5b21004 	ldr	r1, [r2, #4]!
57e18ab8:	e5940090 	ldr	r0, [r4, #144]	; 0x90
	chip->ecc.read_page_raw(mtd, chip, buf, page);

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);

	for (i = 0; i < chip->ecc.total; i++)
57e18abc:	e2866001 	add	r6, r6, #1
		ecc_code[i] = chip->oob_poi[eccpos[i]];
57e18ac0:	e7d01001 	ldrb	r1, [r0, r1]
57e18ac4:	e5e31001 	strb	r1, [r3, #1]!
	chip->ecc.read_page_raw(mtd, chip, buf, page);

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);

	for (i = 0; i < chip->ecc.total; i++)
57e18ac8:	e59410ac 	ldr	r1, [r4, #172]	; 0xac
57e18acc:	e1560001 	cmp	r6, r1
57e18ad0:	bafffff7 	blt	57e18ab4 <nand_read_page_swecc+0x84>
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	eccsteps = chip->ecc.steps;
57e18ad4:	e59470a0 	ldr	r7, [r4, #160]	; 0xa0
	p = buf;
57e18ad8:	e1a0a00b 	mov	sl, fp

	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e18adc:	e3a06000 	mov	r6, #0
57e18ae0:	ea000012 	b	57e18b30 <nand_read_page_swecc+0x100>
		int stat;

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
57e18ae4:	e2862d09 	add	r2, r6, #576	; 0x240
57e18ae8:	e0893006 	add	r3, r9, r6
57e18aec:	e594c0c8 	ldr	ip, [r4, #200]	; 0xc8
57e18af0:	e1a0100a 	mov	r1, sl
57e18af4:	e1a00005 	mov	r0, r5
57e18af8:	e0892002 	add	r2, r9, r2
57e18afc:	e12fff3c 	blx	ip
		if (stat < 0)
57e18b00:	e3500000 	cmp	r0, #0
			mtd->ecc_stats.failed++;
57e18b04:	b5953084 	ldrlt	r3, [r5, #132]	; 0x84
		else
			mtd->ecc_stats.corrected += stat;
57e18b08:	a5953080 	ldrge	r3, [r5, #128]	; 0x80
	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
		int stat;

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
		if (stat < 0)
			mtd->ecc_stats.failed++;
57e18b0c:	b2833001 	addlt	r3, r3, #1
		else
			mtd->ecc_stats.corrected += stat;
57e18b10:	a0830000 	addge	r0, r3, r0
	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
		int stat;

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
		if (stat < 0)
			mtd->ecc_stats.failed++;
57e18b14:	b5853084 	strlt	r3, [r5, #132]	; 0x84
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18b18:	e59dc004 	ldr	ip, [sp, #4]
57e18b1c:	e59d3008 	ldr	r3, [sp, #8]

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
		if (stat < 0)
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;
57e18b20:	a5850080 	strge	r0, [r5, #128]	; 0x80
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	eccsteps = chip->ecc.steps;
	p = buf;

	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e18b24:	e2477001 	sub	r7, r7, #1
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	buffer to store read data
 * @page:	page number to read
 */
static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18b28:	e0866003 	add	r6, r6, r3
57e18b2c:	e08aa00c 	add	sl, sl, ip
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	eccsteps = chip->ecc.steps;
	p = buf;

	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e18b30:	e3570000 	cmp	r7, #0
57e18b34:	1affffea 	bne	57e18ae4 <nand_read_page_swecc+0xb4>
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;
	}
	return 0;
}
57e18b38:	e1a00007 	mov	r0, r7
57e18b3c:	e28dd010 	add	sp, sp, #16
57e18b40:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e18b44 <nand_read_subpage>:
 * @readlen:	data length
 * @bufpoi:	buffer to store read data
 */
static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,
			uint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)
{
57e18b44:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
57e18b48:	e1a09003 	mov	r9, r3
	int start_step, end_step, num_steps;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
	uint8_t *p;
	int data_col_addr, i, gaps = 0;
	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
57e18b4c:	e5913050 	ldr	r3, [r1, #80]	; 0x50
	int index = 0;

	/* Column address wihin the page aligned to ECC size (256bytes). */
	start_step = data_offs / chip->ecc.size;
57e18b50:	e59170a4 	ldr	r7, [r1, #164]	; 0xa4
	int start_step, end_step, num_steps;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
	uint8_t *p;
	int data_col_addr, i, gaps = 0;
	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
57e18b54:	e3130002 	tst	r3, #2
 * @readlen:	data length
 * @bufpoi:	buffer to store read data
 */
static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,
			uint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)
{
57e18b58:	e1a05000 	mov	r5, r0
	int start_step, end_step, num_steps;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
	uint8_t *p;
	int data_col_addr, i, gaps = 0;
	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
57e18b5c:	03a00001 	moveq	r0, #1
57e18b60:	13a00002 	movne	r0, #2
 * @readlen:	data length
 * @bufpoi:	buffer to store read data
 */
static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,
			uint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)
{
57e18b64:	e1a04001 	mov	r4, r1
	int start_step, end_step, num_steps;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e18b68:	e591b0b8 	ldr	fp, [r1, #184]	; 0xb8
	uint8_t *p;
	int data_col_addr, i, gaps = 0;
	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
57e18b6c:	e58d000c 	str	r0, [sp, #12]
	int index = 0;

	/* Column address wihin the page aligned to ECC size (256bytes). */
	start_step = data_offs / chip->ecc.size;
57e18b70:	e1a01007 	mov	r1, r7
57e18b74:	e1a00002 	mov	r0, r2
 * @readlen:	data length
 * @bufpoi:	buffer to store read data
 */
static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,
			uint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)
{
57e18b78:	e1a0a002 	mov	sl, r2
	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
	int index = 0;

	/* Column address wihin the page aligned to ECC size (256bytes). */
	start_step = data_offs / chip->ecc.size;
57e18b7c:	eb004b0b 	bl	57e2b7b0 <__udivsi3>
	end_step = (data_offs + readlen - 1) / chip->ecc.size;
	num_steps = end_step - start_step + 1;
57e18b80:	e2603001 	rsb	r3, r0, #1
	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
	int index = 0;

	/* Column address wihin the page aligned to ECC size (256bytes). */
	start_step = data_offs / chip->ecc.size;
57e18b84:	e1a06000 	mov	r6, r0
	end_step = (data_offs + readlen - 1) / chip->ecc.size;
57e18b88:	e24a0001 	sub	r0, sl, #1
57e18b8c:	e0800009 	add	r0, r0, r9
57e18b90:	e1a01007 	mov	r1, r7
57e18b94:	e58d3000 	str	r3, [sp]
57e18b98:	eb004b04 	bl	57e2b7b0 <__udivsi3>
	num_steps = end_step - start_step + 1;
57e18b9c:	e59d3000 	ldr	r3, [sp]

	/* Data size aligned to ECC ecc.size*/
	datafrag_len = num_steps * chip->ecc.size;
	eccfrag_len = num_steps * chip->ecc.bytes;
57e18ba0:	e59490a8 	ldr	r9, [r4, #168]	; 0xa8
	int index = 0;

	/* Column address wihin the page aligned to ECC size (256bytes). */
	start_step = data_offs / chip->ecc.size;
	end_step = (data_offs + readlen - 1) / chip->ecc.size;
	num_steps = end_step - start_step + 1;
57e18ba4:	e0833000 	add	r3, r3, r0

	/* Data size aligned to ECC ecc.size*/
	datafrag_len = num_steps * chip->ecc.size;
57e18ba8:	e1a0a003 	mov	sl, r3
57e18bac:	e00a0a97 	mul	sl, r7, sl
	eccfrag_len = num_steps * chip->ecc.bytes;

	data_col_addr = start_step * chip->ecc.size;
	/* If we read not a page aligned data */
	if (data_col_addr != 0)
57e18bb0:	e0170796 	muls	r7, r6, r7
	int index = 0;

	/* Column address wihin the page aligned to ECC size (256bytes). */
	start_step = data_offs / chip->ecc.size;
	end_step = (data_offs + readlen - 1) / chip->ecc.size;
	num_steps = end_step - start_step + 1;
57e18bb4:	e58d3008 	str	r3, [sp, #8]

	/* Data size aligned to ECC ecc.size*/
	datafrag_len = num_steps * chip->ecc.size;
	eccfrag_len = num_steps * chip->ecc.bytes;
57e18bb8:	e0090993 	mul	r9, r3, r9

	data_col_addr = start_step * chip->ecc.size;
	/* If we read not a page aligned data */
	if (data_col_addr != 0)
57e18bbc:	0a000005 	beq	57e18bd8 <nand_read_subpage+0x94>
		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);
57e18bc0:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e18bc4:	e1a00005 	mov	r0, r5
57e18bc8:	e3a01005 	mov	r1, #5
57e18bcc:	e1a02007 	mov	r2, r7
57e18bd0:	e3e03000 	mvn	r3, #0
57e18bd4:	e12fff3c 	blx	ip

	p = bufpoi + data_col_addr;
57e18bd8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
	chip->read_buf(mtd, p, datafrag_len);
57e18bdc:	e1a0200a 	mov	r2, sl
	data_col_addr = start_step * chip->ecc.size;
	/* If we read not a page aligned data */
	if (data_col_addr != 0)
		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);

	p = bufpoi + data_col_addr;
57e18be0:	e0833007 	add	r3, r3, r7
57e18be4:	e58d3004 	str	r3, [sp, #4]
	chip->read_buf(mtd, p, datafrag_len);
57e18be8:	e1a00005 	mov	r0, r5
57e18bec:	e5943014 	ldr	r3, [r4, #20]
57e18bf0:	e59d1004 	ldr	r1, [sp, #4]
57e18bf4:	e12fff33 	blx	r3

	/* Calculate  ECC */
	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)
57e18bf8:	e3a07000 	mov	r7, #0
	data_col_addr = start_step * chip->ecc.size;
	/* If we read not a page aligned data */
	if (data_col_addr != 0)
		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);

	p = bufpoi + data_col_addr;
57e18bfc:	e59da004 	ldr	sl, [sp, #4]
	chip->read_buf(mtd, p, datafrag_len);

	/* Calculate  ECC */
	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)
57e18c00:	ea000009 	b	57e18c2c <nand_read_subpage+0xe8>
		chip->ecc.calculate(mtd, p, &chip->buffers->ecccalc[i]);
57e18c04:	e59420e8 	ldr	r2, [r4, #232]	; 0xe8
57e18c08:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
57e18c0c:	e1a0100a 	mov	r1, sl
57e18c10:	e0822007 	add	r2, r2, r7
57e18c14:	e1a00005 	mov	r0, r5
57e18c18:	e12fff33 	blx	r3

	p = bufpoi + data_col_addr;
	chip->read_buf(mtd, p, datafrag_len);

	/* Calculate  ECC */
	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)
57e18c1c:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
57e18c20:	e0877003 	add	r7, r7, r3
57e18c24:	e59430a4 	ldr	r3, [r4, #164]	; 0xa4
57e18c28:	e08aa003 	add	sl, sl, r3
57e18c2c:	e1570009 	cmp	r7, r9
57e18c30:	bafffff3 	blt	57e18c04 <nand_read_subpage+0xc0>
57e18c34:	e3a03000 	mov	r3, #0
		chip->ecc.calculate(mtd, p, &chip->buffers->ecccalc[i]);

	/* The performance is faster if to position offsets
	   according to ecc.pos. Let make sure here that
	   there are no gaps in ecc positions */
	for (i = 0; i < eccfrag_len - 1; i++) {
57e18c38:	e2491001 	sub	r1, r9, #1
57e18c3c:	ea000008 	b	57e18c64 <nand_read_subpage+0x120>
		if (eccpos[i + start_step * chip->ecc.bytes] + 1 !=
57e18c40:	e0223296 	mla	r2, r6, r2, r3
57e18c44:	e08b0102 	add	r0, fp, r2, lsl #2
57e18c48:	e5900004 	ldr	r0, [r0, #4]
			eccpos[i + start_step * chip->ecc.bytes + 1]) {
57e18c4c:	e08b2102 	add	r2, fp, r2, lsl #2

	/* The performance is faster if to position offsets
	   according to ecc.pos. Let make sure here that
	   there are no gaps in ecc positions */
	for (i = 0; i < eccfrag_len - 1; i++) {
		if (eccpos[i + start_step * chip->ecc.bytes] + 1 !=
57e18c50:	e5922008 	ldr	r2, [r2, #8]
57e18c54:	e2800001 	add	r0, r0, #1
57e18c58:	e1500002 	cmp	r0, r2
57e18c5c:	1a000004 	bne	57e18c74 <nand_read_subpage+0x130>
		chip->ecc.calculate(mtd, p, &chip->buffers->ecccalc[i]);

	/* The performance is faster if to position offsets
	   according to ecc.pos. Let make sure here that
	   there are no gaps in ecc positions */
	for (i = 0; i < eccfrag_len - 1; i++) {
57e18c60:	e2833001 	add	r3, r3, #1
57e18c64:	e1530001 	cmp	r3, r1
57e18c68:	e59420a8 	ldr	r2, [r4, #168]	; 0xa8
57e18c6c:	bafffff3 	blt	57e18c40 <nand_read_subpage+0xfc>
57e18c70:	ea000047 	b	57e18d94 <nand_read_subpage+0x250>
			gaps = 1;
			break;
		}
	}
	if (gaps) {
		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);
57e18c74:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e18c78:	e1a00005 	mov	r0, r5
57e18c7c:	e3a01005 	mov	r1, #5
57e18c80:	e5952014 	ldr	r2, [r5, #20]
57e18c84:	e3e03000 	mvn	r3, #0
57e18c88:	e12fff3c 	blx	ip
		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
57e18c8c:	e5943014 	ldr	r3, [r4, #20]
57e18c90:	e1a00005 	mov	r0, r5
57e18c94:	e5941090 	ldr	r1, [r4, #144]	; 0x90
57e18c98:	e5952018 	ldr	r2, [r5, #24]
57e18c9c:	e12fff33 	blx	r3
	uint32_t *eccpos = chip->ecc.layout->eccpos;
	uint8_t *p;
	int data_col_addr, i, gaps = 0;
	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
	int index = 0;
57e18ca0:	e3a06000 	mov	r6, #0
57e18ca4:	ea000013 	b	57e18cf8 <nand_read_subpage+0x1b4>
		index = start_step * chip->ecc.bytes;

		aligned_pos = eccpos[index] & ~(busw - 1);
		aligned_len = eccfrag_len;
		if (eccpos[index] & (busw - 1))
			aligned_len++;
57e18ca8:	e2897001 	add	r7, r9, #1
		if (eccpos[index + (num_steps * chip->ecc.bytes)] & (busw - 1))
57e18cac:	e59d1008 	ldr	r1, [sp, #8]
			aligned_len++;

		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
57e18cb0:	e1a00005 	mov	r0, r5

		aligned_pos = eccpos[index] & ~(busw - 1);
		aligned_len = eccfrag_len;
		if (eccpos[index] & (busw - 1))
			aligned_len++;
		if (eccpos[index + (num_steps * chip->ecc.bytes)] & (busw - 1))
57e18cb4:	e0226291 	mla	r2, r1, r2, r6
57e18cb8:	e08b2102 	add	r2, fp, r2, lsl #2
57e18cbc:	e5922004 	ldr	r2, [r2, #4]
			aligned_len++;

		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
57e18cc0:	e3a01005 	mov	r1, #5

		aligned_pos = eccpos[index] & ~(busw - 1);
		aligned_len = eccfrag_len;
		if (eccpos[index] & (busw - 1))
			aligned_len++;
		if (eccpos[index + (num_steps * chip->ecc.bytes)] & (busw - 1))
57e18cc4:	e1130002 	tst	r3, r2
			aligned_len++;

		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
					mtd->writesize + aligned_pos, -1);
57e18cc8:	e5952014 	ldr	r2, [r5, #20]
		if (eccpos[index] & (busw - 1))
			aligned_len++;
		if (eccpos[index + (num_steps * chip->ecc.bytes)] & (busw - 1))
			aligned_len++;

		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
57e18ccc:	e3e03000 	mvn	r3, #0
57e18cd0:	e08a2002 	add	r2, sl, r2
57e18cd4:	e594c034 	ldr	ip, [r4, #52]	; 0x34
		aligned_pos = eccpos[index] & ~(busw - 1);
		aligned_len = eccfrag_len;
		if (eccpos[index] & (busw - 1))
			aligned_len++;
		if (eccpos[index + (num_steps * chip->ecc.bytes)] & (busw - 1))
			aligned_len++;
57e18cd8:	12877001 	addne	r7, r7, #1

		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
57e18cdc:	e12fff3c 	blx	ip
					mtd->writesize + aligned_pos, -1);
		chip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);
57e18ce0:	e5941090 	ldr	r1, [r4, #144]	; 0x90
57e18ce4:	e5943014 	ldr	r3, [r4, #20]
57e18ce8:	e1a00005 	mov	r0, r5
57e18cec:	e081100a 	add	r1, r1, sl
57e18cf0:	e1a02007 	mov	r2, r7
57e18cf4:	e12fff33 	blx	r3
 * @chip:	nand chip info structure
 * @data_offs:	offset of requested data within the page
 * @readlen:	data length
 * @bufpoi:	buffer to store read data
 */
static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,
57e18cf8:	e08b6106 	add	r6, fp, r6, lsl #2
		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
					mtd->writesize + aligned_pos, -1);
		chip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);
	}

	for (i = 0; i < eccfrag_len; i++)
57e18cfc:	e3a03000 	mov	r3, #0
57e18d00:	ea000006 	b	57e18d20 <nand_read_subpage+0x1dc>
		chip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + index]];
57e18d04:	e5940090 	ldr	r0, [r4, #144]	; 0x90
57e18d08:	e5b61004 	ldr	r1, [r6, #4]!
57e18d0c:	e59420e8 	ldr	r2, [r4, #232]	; 0xe8
57e18d10:	e7d01001 	ldrb	r1, [r0, r1]
57e18d14:	e0822003 	add	r2, r2, r3
57e18d18:	e5c21240 	strb	r1, [r2, #576]	; 0x240
		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
					mtd->writesize + aligned_pos, -1);
		chip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);
	}

	for (i = 0; i < eccfrag_len; i++)
57e18d1c:	e2833001 	add	r3, r3, #1
57e18d20:	e1530009 	cmp	r3, r9
57e18d24:	bafffff6 	blt	57e18d04 <nand_read_subpage+0x1c0>
57e18d28:	e3a06000 	mov	r6, #0
57e18d2c:	e59d7004 	ldr	r7, [sp, #4]
57e18d30:	ea000012 	b	57e18d80 <nand_read_subpage+0x23c>
	p = bufpoi + data_col_addr;
	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
		int stat;

		stat = chip->ecc.correct(mtd, p,
			&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
57e18d34:	e59430e8 	ldr	r3, [r4, #232]	; 0xe8

	p = bufpoi + data_col_addr;
	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
		int stat;

		stat = chip->ecc.correct(mtd, p,
57e18d38:	e2862d09 	add	r2, r6, #576	; 0x240
57e18d3c:	e1a01007 	mov	r1, r7
57e18d40:	e0832002 	add	r2, r3, r2
57e18d44:	e594c0c8 	ldr	ip, [r4, #200]	; 0xc8
57e18d48:	e0833006 	add	r3, r3, r6
57e18d4c:	e1a00005 	mov	r0, r5
57e18d50:	e12fff3c 	blx	ip
			&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
		if (stat < 0)
57e18d54:	e3500000 	cmp	r0, #0
			mtd->ecc_stats.failed++;
57e18d58:	b5953084 	ldrlt	r3, [r5, #132]	; 0x84
		else
			mtd->ecc_stats.corrected += stat;
57e18d5c:	a5953080 	ldrge	r3, [r5, #128]	; 0x80
		int stat;

		stat = chip->ecc.correct(mtd, p,
			&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
		if (stat < 0)
			mtd->ecc_stats.failed++;
57e18d60:	b2833001 	addlt	r3, r3, #1
		else
			mtd->ecc_stats.corrected += stat;
57e18d64:	a0830000 	addge	r0, r3, r0
		int stat;

		stat = chip->ecc.correct(mtd, p,
			&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
		if (stat < 0)
			mtd->ecc_stats.failed++;
57e18d68:	b5853084 	strlt	r3, [r5, #132]	; 0x84

	for (i = 0; i < eccfrag_len; i++)
		chip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + index]];

	p = bufpoi + data_col_addr;
	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
57e18d6c:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
		stat = chip->ecc.correct(mtd, p,
			&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
		if (stat < 0)
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;
57e18d70:	a5850080 	strge	r0, [r5, #128]	; 0x80

	for (i = 0; i < eccfrag_len; i++)
		chip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + index]];

	p = bufpoi + data_col_addr;
	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
57e18d74:	e0866003 	add	r6, r6, r3
57e18d78:	e59430a4 	ldr	r3, [r4, #164]	; 0xa4
57e18d7c:	e0877003 	add	r7, r7, r3
57e18d80:	e1560009 	cmp	r6, r9
57e18d84:	baffffea 	blt	57e18d34 <nand_read_subpage+0x1f0>
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;
	}
	return 0;
}
57e18d88:	e3a00000 	mov	r0, #0
57e18d8c:	e28dd010 	add	sp, sp, #16
57e18d90:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);
		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
	} else {
		/* send the command to read the particular ecc bytes */
		/* take care about buswidth alignment in read_buf */
		index = start_step * chip->ecc.bytes;
57e18d94:	e0060692 	mul	r6, r2, r6

		aligned_pos = eccpos[index] & ~(busw - 1);
57e18d98:	e08b3106 	add	r3, fp, r6, lsl #2
57e18d9c:	e5931004 	ldr	r1, [r3, #4]
57e18da0:	e59d300c 	ldr	r3, [sp, #12]
57e18da4:	e263a000 	rsb	sl, r3, #0
		aligned_len = eccfrag_len;
		if (eccpos[index] & (busw - 1))
57e18da8:	e2433001 	sub	r3, r3, #1
57e18dac:	e1130001 	tst	r3, r1
	} else {
		/* send the command to read the particular ecc bytes */
		/* take care about buswidth alignment in read_buf */
		index = start_step * chip->ecc.bytes;

		aligned_pos = eccpos[index] & ~(busw - 1);
57e18db0:	e00aa001 	and	sl, sl, r1
		aligned_len = eccfrag_len;
		if (eccpos[index] & (busw - 1))
57e18db4:	01a07009 	moveq	r7, r9
57e18db8:	0affffbb 	beq	57e18cac <nand_read_subpage+0x168>
57e18dbc:	eaffffb9 	b	57e18ca8 <nand_read_subpage+0x164>

57e18dc0 <nand_read_page_hwecc>:
 *
 * Not for syndrome calculating ecc controllers which need a special oob layout
 */
static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
				uint8_t *buf, int page)
{
57e18dc0:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
57e18dc4:	e59130a8 	ldr	r3, [r1, #168]	; 0xa8
 *
 * Not for syndrome calculating ecc controllers which need a special oob layout
 */
static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
				uint8_t *buf, int page)
{
57e18dc8:	e1a05000 	mov	r5, r0
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
57e18dcc:	e58d3004 	str	r3, [sp, #4]
	int eccsteps = chip->ecc.steps;
	uint8_t *p = buf;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e18dd0:	e59130b8 	ldr	r3, [r1, #184]	; 0xb8
 *
 * Not for syndrome calculating ecc controllers which need a special oob layout
 */
static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
				uint8_t *buf, int page)
{
57e18dd4:	e1a04001 	mov	r4, r1
57e18dd8:	e58d2008 	str	r2, [sp, #8]
	int i, eccsize = chip->ecc.size;
57e18ddc:	e591b0a4 	ldr	fp, [r1, #164]	; 0xa4
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
57e18de0:	e59160a0 	ldr	r6, [r1, #160]	; 0xa0
	uint8_t *p = buf;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
57e18de4:	e59190e8 	ldr	r9, [r1, #232]	; 0xe8
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e18de8:	e58d300c 	str	r3, [sp, #12]
				uint8_t *buf, int page)
{
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *p = buf;
57e18dec:	e1a07002 	mov	r7, r2
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e18df0:	e3a0a000 	mov	sl, #0
57e18df4:	ea000011 	b	57e18e40 <nand_read_page_hwecc+0x80>
		chip->ecc.hwctl(mtd, NAND_ECC_READ);
57e18df8:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
57e18dfc:	e1a00005 	mov	r0, r5
57e18e00:	e3a01000 	mov	r1, #0
57e18e04:	e12fff33 	blx	r3
		chip->read_buf(mtd, p, eccsize);
57e18e08:	e1a01007 	mov	r1, r7
57e18e0c:	e5943014 	ldr	r3, [r4, #20]
57e18e10:	e1a00005 	mov	r0, r5
57e18e14:	e1a0200b 	mov	r2, fp
57e18e18:	e12fff33 	blx	r3
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
57e18e1c:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
57e18e20:	e1a01007 	mov	r1, r7
57e18e24:	e089200a 	add	r2, r9, sl
57e18e28:	e1a00005 	mov	r0, r5
57e18e2c:	e12fff33 	blx	r3
 * @buf:	buffer to store read data
 * @page:	page number to read
 *
 * Not for syndrome calculating ecc controllers which need a special oob layout
 */
static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18e30:	e59d3004 	ldr	r3, [sp, #4]
	uint8_t *p = buf;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e18e34:	e2466001 	sub	r6, r6, #1
 * @buf:	buffer to store read data
 * @page:	page number to read
 *
 * Not for syndrome calculating ecc controllers which need a special oob layout
 */
static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18e38:	e08aa003 	add	sl, sl, r3
57e18e3c:	e087700b 	add	r7, r7, fp
	uint8_t *p = buf;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e18e40:	e3560000 	cmp	r6, #0
57e18e44:	1affffeb 	bne	57e18df8 <nand_read_page_hwecc+0x38>
		chip->ecc.hwctl(mtd, NAND_ECC_READ);
		chip->read_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
	}
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
57e18e48:	e5943014 	ldr	r3, [r4, #20]
57e18e4c:	e5952018 	ldr	r2, [r5, #24]
57e18e50:	e1a00005 	mov	r0, r5
57e18e54:	e5941090 	ldr	r1, [r4, #144]	; 0x90
57e18e58:	e12fff33 	blx	r3
 * @buf:	buffer to store read data
 * @page:	page number to read
 *
 * Not for syndrome calculating ecc controllers which need a special oob layout
 */
static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18e5c:	e2893f8f 	add	r3, r9, #572	; 0x23c
	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
		chip->ecc.hwctl(mtd, NAND_ECC_READ);
		chip->read_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
	}
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
57e18e60:	e59d200c 	ldr	r2, [sp, #12]
 * @buf:	buffer to store read data
 * @page:	page number to read
 *
 * Not for syndrome calculating ecc controllers which need a special oob layout
 */
static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18e64:	e2833003 	add	r3, r3, #3
		chip->read_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
	}
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);

	for (i = 0; i < chip->ecc.total; i++)
57e18e68:	ea000004 	b	57e18e80 <nand_read_page_hwecc+0xc0>
		ecc_code[i] = chip->oob_poi[eccpos[i]];
57e18e6c:	e5b21004 	ldr	r1, [r2, #4]!
57e18e70:	e5940090 	ldr	r0, [r4, #144]	; 0x90
		chip->read_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
	}
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);

	for (i = 0; i < chip->ecc.total; i++)
57e18e74:	e2866001 	add	r6, r6, #1
		ecc_code[i] = chip->oob_poi[eccpos[i]];
57e18e78:	e7d01001 	ldrb	r1, [r0, r1]
57e18e7c:	e5e31001 	strb	r1, [r3, #1]!
		chip->read_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
	}
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);

	for (i = 0; i < chip->ecc.total; i++)
57e18e80:	e59410ac 	ldr	r1, [r4, #172]	; 0xac
57e18e84:	e1560001 	cmp	r6, r1
57e18e88:	bafffff7 	blt	57e18e6c <nand_read_page_hwecc+0xac>
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	eccsteps = chip->ecc.steps;
57e18e8c:	e59470a0 	ldr	r7, [r4, #160]	; 0xa0
	p = buf;
57e18e90:	e59da008 	ldr	sl, [sp, #8]

	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e18e94:	e3a06000 	mov	r6, #0
57e18e98:	ea000011 	b	57e18ee4 <nand_read_page_hwecc+0x124>
		int stat;

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
57e18e9c:	e2862d09 	add	r2, r6, #576	; 0x240
57e18ea0:	e0893006 	add	r3, r9, r6
57e18ea4:	e1a0100a 	mov	r1, sl
57e18ea8:	e594c0c8 	ldr	ip, [r4, #200]	; 0xc8
57e18eac:	e1a00005 	mov	r0, r5
57e18eb0:	e0892002 	add	r2, r9, r2
57e18eb4:	e12fff3c 	blx	ip
		if (stat < 0)
57e18eb8:	e3500000 	cmp	r0, #0
			mtd->ecc_stats.failed++;
57e18ebc:	b5953084 	ldrlt	r3, [r5, #132]	; 0x84
		else
			mtd->ecc_stats.corrected += stat;
57e18ec0:	a5953080 	ldrge	r3, [r5, #128]	; 0x80
	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
		int stat;

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
		if (stat < 0)
			mtd->ecc_stats.failed++;
57e18ec4:	b2833001 	addlt	r3, r3, #1
		else
			mtd->ecc_stats.corrected += stat;
57e18ec8:	a0830000 	addge	r0, r3, r0
	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
		int stat;

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
		if (stat < 0)
			mtd->ecc_stats.failed++;
57e18ecc:	b5853084 	strlt	r3, [r5, #132]	; 0x84
 * @buf:	buffer to store read data
 * @page:	page number to read
 *
 * Not for syndrome calculating ecc controllers which need a special oob layout
 */
static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18ed0:	e59d3004 	ldr	r3, [sp, #4]

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
		if (stat < 0)
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;
57e18ed4:	a5850080 	strge	r0, [r5, #128]	; 0x80
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	eccsteps = chip->ecc.steps;
	p = buf;

	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e18ed8:	e2477001 	sub	r7, r7, #1
 * @buf:	buffer to store read data
 * @page:	page number to read
 *
 * Not for syndrome calculating ecc controllers which need a special oob layout
 */
static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
57e18edc:	e0866003 	add	r6, r6, r3
57e18ee0:	e08aa00b 	add	sl, sl, fp
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	eccsteps = chip->ecc.steps;
	p = buf;

	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e18ee4:	e3570000 	cmp	r7, #0
57e18ee8:	1affffeb 	bne	57e18e9c <nand_read_page_hwecc+0xdc>
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;
	}
	return 0;
}
57e18eec:	e1a00007 	mov	r0, r7
57e18ef0:	e28dd010 	add	sp, sp, #16
57e18ef4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e18ef8 <nand_read_page_hwecc_oob_first>:
 * "infix ECC" scheme and reads/writes ECC from the data area, by
 * overwriting the NAND manufacturer bad block markings.
 */
static int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,
	struct nand_chip *chip, uint8_t *buf, int page)
{
57e18ef8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e18efc:	e58d2004 	str	r2, [sp, #4]
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
57e18f00:	e59120a8 	ldr	r2, [r1, #168]	; 0xa8
 * "infix ECC" scheme and reads/writes ECC from the data area, by
 * overwriting the NAND manufacturer bad block markings.
 */
static int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,
	struct nand_chip *chip, uint8_t *buf, int page)
{
57e18f04:	e1a05000 	mov	r5, r0
57e18f08:	e1a04001 	mov	r4, r1
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
	uint8_t *ecc_calc = chip->buffers->ecccalc;

	/* Read the OOB area first */
	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
57e18f0c:	e591c034 	ldr	ip, [r1, #52]	; 0x34
{
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *p = buf;
	uint8_t *ecc_code = chip->buffers->ecccode;
57e18f10:	e59190e8 	ldr	r9, [r1, #232]	; 0xe8
 * overwriting the NAND manufacturer bad block markings.
 */
static int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,
	struct nand_chip *chip, uint8_t *buf, int page)
{
	int i, eccsize = chip->ecc.size;
57e18f14:	e591b0a4 	ldr	fp, [r1, #164]	; 0xa4
	int eccbytes = chip->ecc.bytes;
57e18f18:	e58d2000 	str	r2, [sp]
	int eccsteps = chip->ecc.steps;
57e18f1c:	e591a0a0 	ldr	sl, [r1, #160]	; 0xa0
	uint8_t *p = buf;
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e18f20:	e59170b8 	ldr	r7, [r1, #184]	; 0xb8
	uint8_t *ecc_calc = chip->buffers->ecccalc;

	/* Read the OOB area first */
	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
57e18f24:	e3a02000 	mov	r2, #0
57e18f28:	e3a01050 	mov	r1, #80	; 0x50
 * "infix ECC" scheme and reads/writes ECC from the data area, by
 * overwriting the NAND manufacturer bad block markings.
 */
static int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,
	struct nand_chip *chip, uint8_t *buf, int page)
{
57e18f2c:	e1a06003 	mov	r6, r3
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
	uint8_t *ecc_calc = chip->buffers->ecccalc;

	/* Read the OOB area first */
	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
57e18f30:	e12fff3c 	blx	ip
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
57e18f34:	e5943014 	ldr	r3, [r4, #20]
57e18f38:	e1a00005 	mov	r0, r5
57e18f3c:	e5941090 	ldr	r1, [r4, #144]	; 0x90
57e18f40:	e5952018 	ldr	r2, [r5, #24]
57e18f44:	e12fff33 	blx	r3
	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
57e18f48:	e3a01000 	mov	r1, #0
57e18f4c:	e1a02001 	mov	r2, r1
57e18f50:	e1a03006 	mov	r3, r6
57e18f54:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e18f58:	e1a00005 	mov	r0, r5
57e18f5c:	e12fff3c 	blx	ip
 * These methods read/write ECC from the OOB area, unlike the
 * ECC_HW_SYNDROME support with multiple ECC steps, follows the
 * "infix ECC" scheme and reads/writes ECC from the data area, by
 * overwriting the NAND manufacturer bad block markings.
 */
static int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,
57e18f60:	e2892f8f 	add	r2, r9, #572	; 0x23c
57e18f64:	e2822003 	add	r2, r2, #3
	/* Read the OOB area first */
	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);

	for (i = 0; i < chip->ecc.total; i++)
57e18f68:	e3a03000 	mov	r3, #0
57e18f6c:	ea000004 	b	57e18f84 <nand_read_page_hwecc_oob_first+0x8c>
		ecc_code[i] = chip->oob_poi[eccpos[i]];
57e18f70:	e5b71004 	ldr	r1, [r7, #4]!
57e18f74:	e5940090 	ldr	r0, [r4, #144]	; 0x90
	/* Read the OOB area first */
	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);

	for (i = 0; i < chip->ecc.total; i++)
57e18f78:	e2833001 	add	r3, r3, #1
		ecc_code[i] = chip->oob_poi[eccpos[i]];
57e18f7c:	e7d01001 	ldrb	r1, [r0, r1]
57e18f80:	e5e21001 	strb	r1, [r2, #1]!
	/* Read the OOB area first */
	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);

	for (i = 0; i < chip->ecc.total; i++)
57e18f84:	e59410ac 	ldr	r1, [r4, #172]	; 0xac
57e18f88:	e1530001 	cmp	r3, r1
57e18f8c:	bafffff7 	blt	57e18f70 <nand_read_page_hwecc_oob_first+0x78>
57e18f90:	e59d6004 	ldr	r6, [sp, #4]
57e18f94:	e3a07000 	mov	r7, #0
57e18f98:	ea00001f 	b	57e1901c <nand_read_page_hwecc_oob_first+0x124>
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
		int stat;

		chip->ecc.hwctl(mtd, NAND_ECC_READ);
57e18f9c:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
57e18fa0:	e1a00005 	mov	r0, r5
57e18fa4:	e3a01000 	mov	r1, #0
57e18fa8:	e12fff33 	blx	r3
		chip->read_buf(mtd, p, eccsize);
57e18fac:	e1a01006 	mov	r1, r6
57e18fb0:	e5943014 	ldr	r3, [r4, #20]
57e18fb4:	e1a00005 	mov	r0, r5
57e18fb8:	e1a0200b 	mov	r2, fp
57e18fbc:	e12fff33 	blx	r3
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
57e18fc0:	e1a01006 	mov	r1, r6
57e18fc4:	e0892007 	add	r2, r9, r7
57e18fc8:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
57e18fcc:	e1a00005 	mov	r0, r5
57e18fd0:	e12fff33 	blx	r3

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
57e18fd4:	e2872d09 	add	r2, r7, #576	; 0x240
57e18fd8:	e3a03000 	mov	r3, #0
57e18fdc:	e1a01006 	mov	r1, r6
57e18fe0:	e594c0c8 	ldr	ip, [r4, #200]	; 0xc8
57e18fe4:	e1a00005 	mov	r0, r5
57e18fe8:	e0892002 	add	r2, r9, r2
57e18fec:	e12fff3c 	blx	ip
		if (stat < 0)
57e18ff0:	e3500000 	cmp	r0, #0
			mtd->ecc_stats.failed++;
57e18ff4:	b5953084 	ldrlt	r3, [r5, #132]	; 0x84
		else
			mtd->ecc_stats.corrected += stat;
57e18ff8:	a5953080 	ldrge	r3, [r5, #128]	; 0x80
		chip->read_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
		if (stat < 0)
			mtd->ecc_stats.failed++;
57e18ffc:	b2833001 	addlt	r3, r3, #1
		else
			mtd->ecc_stats.corrected += stat;
57e19000:	a0830000 	addge	r0, r3, r0
		chip->read_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
		if (stat < 0)
			mtd->ecc_stats.failed++;
57e19004:	b5853084 	strlt	r3, [r5, #132]	; 0x84
 * These methods read/write ECC from the OOB area, unlike the
 * ECC_HW_SYNDROME support with multiple ECC steps, follows the
 * "infix ECC" scheme and reads/writes ECC from the data area, by
 * overwriting the NAND manufacturer bad block markings.
 */
static int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,
57e19008:	e59d3000 	ldr	r3, [sp]

		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
		if (stat < 0)
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;
57e1900c:	a5850080 	strge	r0, [r5, #128]	; 0x80
	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);

	for (i = 0; i < chip->ecc.total; i++)
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e19010:	e24aa001 	sub	sl, sl, #1
 * These methods read/write ECC from the OOB area, unlike the
 * ECC_HW_SYNDROME support with multiple ECC steps, follows the
 * "infix ECC" scheme and reads/writes ECC from the data area, by
 * overwriting the NAND manufacturer bad block markings.
 */
static int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,
57e19014:	e0877003 	add	r7, r7, r3
57e19018:	e086600b 	add	r6, r6, fp
	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);

	for (i = 0; i < chip->ecc.total; i++)
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e1901c:	e35a0000 	cmp	sl, #0
57e19020:	1affffdd 	bne	57e18f9c <nand_read_page_hwecc_oob_first+0xa4>
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;
	}
	return 0;
}
57e19024:	e1a0000a 	mov	r0, sl
57e19028:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

57e1902c <nand_read_page_syndrome>:
 * The hw generator calculates the error syndrome automatically. Therefor
 * we need a special oob layout and handling.
 */
static int nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
				   uint8_t *buf, int page)
{
57e1902c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e19030:	e1a05000 	mov	r5, r0
57e19034:	e1a04001 	mov	r4, r1
	int i, eccsize = chip->ecc.size;
57e19038:	e59190a4 	ldr	r9, [r1, #164]	; 0xa4
	int eccbytes = chip->ecc.bytes;
57e1903c:	e591b0a8 	ldr	fp, [r1, #168]	; 0xa8
	int eccsteps = chip->ecc.steps;
57e19040:	e591a0a0 	ldr	sl, [r1, #160]	; 0xa0
	uint8_t *p = buf;
	uint8_t *oob = chip->oob_poi;
57e19044:	e5916090 	ldr	r6, [r1, #144]	; 0x90
				   uint8_t *buf, int page)
{
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *p = buf;
57e19048:	e1a07002 	mov	r7, r2
	uint8_t *oob = chip->oob_poi;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e1904c:	ea000033 	b	57e19120 <nand_read_page_syndrome+0xf4>
		int stat;

		chip->ecc.hwctl(mtd, NAND_ECC_READ);
57e19050:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
57e19054:	e1a00005 	mov	r0, r5
57e19058:	e3a01000 	mov	r1, #0
57e1905c:	e12fff33 	blx	r3
		chip->read_buf(mtd, p, eccsize);
57e19060:	e1a02009 	mov	r2, r9
57e19064:	e5943014 	ldr	r3, [r4, #20]
57e19068:	e1a00005 	mov	r0, r5
57e1906c:	e1a01007 	mov	r1, r7
57e19070:	e12fff33 	blx	r3

		if (chip->ecc.prepad) {
57e19074:	e59420b0 	ldr	r2, [r4, #176]	; 0xb0
57e19078:	e3520000 	cmp	r2, #0
57e1907c:	0a000005 	beq	57e19098 <nand_read_page_syndrome+0x6c>
			chip->read_buf(mtd, oob, chip->ecc.prepad);
57e19080:	e5943014 	ldr	r3, [r4, #20]
57e19084:	e1a01006 	mov	r1, r6
57e19088:	e1a00005 	mov	r0, r5
57e1908c:	e12fff33 	blx	r3
			oob += chip->ecc.prepad;
57e19090:	e59430b0 	ldr	r3, [r4, #176]	; 0xb0
57e19094:	e0866003 	add	r6, r6, r3
		}

		chip->ecc.hwctl(mtd, NAND_ECC_READSYN);
57e19098:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
57e1909c:	e1a00005 	mov	r0, r5
57e190a0:	e3a01002 	mov	r1, #2
57e190a4:	e12fff33 	blx	r3
		chip->read_buf(mtd, oob, eccbytes);
57e190a8:	e1a01006 	mov	r1, r6
57e190ac:	e5943014 	ldr	r3, [r4, #20]
57e190b0:	e1a00005 	mov	r0, r5
57e190b4:	e1a0200b 	mov	r2, fp
57e190b8:	e12fff33 	blx	r3
		stat = chip->ecc.correct(mtd, p, oob, NULL);
57e190bc:	e3a03000 	mov	r3, #0
57e190c0:	e1a02006 	mov	r2, r6
57e190c4:	e594c0c8 	ldr	ip, [r4, #200]	; 0xc8
57e190c8:	e1a00005 	mov	r0, r5
57e190cc:	e1a01007 	mov	r1, r7
57e190d0:	e12fff3c 	blx	ip

		if (stat < 0)
57e190d4:	e3500000 	cmp	r0, #0
			mtd->ecc_stats.failed++;
57e190d8:	b5953084 	ldrlt	r3, [r5, #132]	; 0x84
		else
			mtd->ecc_stats.corrected += stat;
57e190dc:	a5953080 	ldrge	r3, [r5, #128]	; 0x80

		oob += eccbytes;

		if (chip->ecc.postpad) {
57e190e0:	e59420b4 	ldr	r2, [r4, #180]	; 0xb4
		chip->ecc.hwctl(mtd, NAND_ECC_READSYN);
		chip->read_buf(mtd, oob, eccbytes);
		stat = chip->ecc.correct(mtd, p, oob, NULL);

		if (stat < 0)
			mtd->ecc_stats.failed++;
57e190e4:	b2833001 	addlt	r3, r3, #1
		else
			mtd->ecc_stats.corrected += stat;
57e190e8:	a0830000 	addge	r0, r3, r0
		chip->ecc.hwctl(mtd, NAND_ECC_READSYN);
		chip->read_buf(mtd, oob, eccbytes);
		stat = chip->ecc.correct(mtd, p, oob, NULL);

		if (stat < 0)
			mtd->ecc_stats.failed++;
57e190ec:	b5853084 	strlt	r3, [r5, #132]	; 0x84
		else
			mtd->ecc_stats.corrected += stat;
57e190f0:	a5850080 	strge	r0, [r5, #128]	; 0x80

		oob += eccbytes;

		if (chip->ecc.postpad) {
57e190f4:	e3520000 	cmp	r2, #0
		if (stat < 0)
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;

		oob += eccbytes;
57e190f8:	e086600b 	add	r6, r6, fp

		if (chip->ecc.postpad) {
57e190fc:	0a000005 	beq	57e19118 <nand_read_page_syndrome+0xec>
			chip->read_buf(mtd, oob, chip->ecc.postpad);
57e19100:	e5943014 	ldr	r3, [r4, #20]
57e19104:	e1a01006 	mov	r1, r6
57e19108:	e1a00005 	mov	r0, r5
57e1910c:	e12fff33 	blx	r3
			oob += chip->ecc.postpad;
57e19110:	e59430b4 	ldr	r3, [r4, #180]	; 0xb4
57e19114:	e0866003 	add	r6, r6, r3
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *p = buf;
	uint8_t *oob = chip->oob_poi;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e19118:	e24aa001 	sub	sl, sl, #1
 * @page:	page number to read
 *
 * The hw generator calculates the error syndrome automatically. Therefor
 * we need a special oob layout and handling.
 */
static int nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
57e1911c:	e0877009 	add	r7, r7, r9
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *p = buf;
	uint8_t *oob = chip->oob_poi;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e19120:	e35a0000 	cmp	sl, #0
57e19124:	1affffc9 	bne	57e19050 <nand_read_page_syndrome+0x24>
			oob += chip->ecc.postpad;
		}
	}

	/* Calculate remaining oob bytes */
	i = mtd->oobsize - (oob - chip->oob_poi);
57e19128:	e5942090 	ldr	r2, [r4, #144]	; 0x90
57e1912c:	e5953018 	ldr	r3, [r5, #24]
57e19130:	e0662002 	rsb	r2, r6, r2
	if (i)
57e19134:	e0922003 	adds	r2, r2, r3
57e19138:	0a000003 	beq	57e1914c <nand_read_page_syndrome+0x120>
		chip->read_buf(mtd, oob, i);
57e1913c:	e5943014 	ldr	r3, [r4, #20]
57e19140:	e1a00005 	mov	r0, r5
57e19144:	e1a01006 	mov	r1, r6
57e19148:	e12fff33 	blx	r3

	return 0;
}
57e1914c:	e3a00000 	mov	r0, #0
57e19150:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e19154 <nand_read_oob_std>:
 * @sndcmd:	flag whether to issue read command or not
 */
static int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
			     int page, int sndcmd)
{
	if (sndcmd) {
57e19154:	e3530000 	cmp	r3, #0
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
			     int page, int sndcmd)
{
57e19158:	e92d4038 	push	{r3, r4, r5, lr}
57e1915c:	e1a05000 	mov	r5, r0
57e19160:	e1a04001 	mov	r4, r1
57e19164:	e1a0e002 	mov	lr, r2
	if (sndcmd) {
57e19168:	0a000004 	beq	57e19180 <nand_read_oob_std+0x2c>
		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
57e1916c:	e591c034 	ldr	ip, [r1, #52]	; 0x34
57e19170:	e3a02000 	mov	r2, #0
57e19174:	e3a01050 	mov	r1, #80	; 0x50
57e19178:	e1a0300e 	mov	r3, lr
57e1917c:	e12fff3c 	blx	ip
		sndcmd = 0;
	}
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
57e19180:	e1a00005 	mov	r0, r5
57e19184:	e5943014 	ldr	r3, [r4, #20]
57e19188:	e5941090 	ldr	r1, [r4, #144]	; 0x90
57e1918c:	e5952018 	ldr	r2, [r5, #24]
57e19190:	e12fff33 	blx	r3
	return sndcmd;
}
57e19194:	e3a00000 	mov	r0, #0
57e19198:	e8bd8038 	pop	{r3, r4, r5, pc}

57e1919c <nand_read_oob_syndrome>:
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
				  int page, int sndcmd)
{
57e1919c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	uint8_t *buf = chip->oob_poi;
	int length = mtd->oobsize;
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
57e191a0:	e59130a8 	ldr	r3, [r1, #168]	; 0xa8
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
				  int page, int sndcmd)
{
57e191a4:	e58d2008 	str	r2, [sp, #8]
	uint8_t *buf = chip->oob_poi;
	int length = mtd->oobsize;
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
57e191a8:	e59120b0 	ldr	r2, [r1, #176]	; 0xb0
	int eccsize = chip->ecc.size;
57e191ac:	e59170a4 	ldr	r7, [r1, #164]	; 0xa4
static int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
				  int page, int sndcmd)
{
	uint8_t *buf = chip->oob_poi;
	int length = mtd->oobsize;
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
57e191b0:	e0822003 	add	r2, r2, r3
57e191b4:	e59130b4 	ldr	r3, [r1, #180]	; 0xb4
 * @sndcmd:	flag whether to issue read command or not
 */
static int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
				  int page, int sndcmd)
{
	uint8_t *buf = chip->oob_poi;
57e191b8:	e591a090 	ldr	sl, [r1, #144]	; 0x90
	int length = mtd->oobsize;
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
57e191bc:	e0823003 	add	r3, r2, r3
57e191c0:	e58d3004 	str	r3, [sp, #4]
	int eccsize = chip->ecc.size;
	uint8_t *bufpoi = buf;
	int i, toread, sndrnd = 0, pos;

	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
57e191c4:	e591c034 	ldr	ip, [r1, #52]	; 0x34
57e191c8:	e59d3008 	ldr	r3, [sp, #8]
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
				  int page, int sndcmd)
{
57e191cc:	e1a04001 	mov	r4, r1
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
	int eccsize = chip->ecc.size;
	uint8_t *bufpoi = buf;
	int i, toread, sndrnd = 0, pos;

	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
57e191d0:	e1a02007 	mov	r2, r7
57e191d4:	e3a01000 	mov	r1, #0
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
				  int page, int sndcmd)
{
57e191d8:	e1a05000 	mov	r5, r0
	uint8_t *buf = chip->oob_poi;
	int length = mtd->oobsize;
57e191dc:	e5906018 	ldr	r6, [r0, #24]
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
	int eccsize = chip->ecc.size;
	uint8_t *bufpoi = buf;
	int i, toread, sndrnd = 0, pos;

	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
57e191e0:	e12fff3c 	blx	ip
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
57e191e4:	e59d3004 	ldr	r3, [sp, #4]
57e191e8:	e0833007 	add	r3, r3, r7
57e191ec:	e58d300c 	str	r3, [sp, #12]
	uint8_t *buf = chip->oob_poi;
	int length = mtd->oobsize;
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
	int eccsize = chip->ecc.size;
	uint8_t *bufpoi = buf;
	int i, toread, sndrnd = 0, pos;
57e191f0:	e3a03000 	mov	r3, #0

	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
	for (i = 0; i < chip->ecc.steps; i++) {
57e191f4:	e1a0b003 	mov	fp, r3
57e191f8:	ea00001b 	b	57e1926c <nand_read_oob_syndrome+0xd0>
		if (sndrnd) {
57e191fc:	e3530000 	cmp	r3, #0
57e19200:	0a00000b 	beq	57e19234 <nand_read_oob_syndrome+0x98>
			pos = eccsize + i * (eccsize + chunk);
			if (mtd->writesize > 512)
57e19204:	e5953014 	ldr	r3, [r5, #20]
57e19208:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1920c:	e3530c02 	cmp	r3, #512	; 0x200
				chip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);
57e19210:	81a00005 	movhi	r0, r5
57e19214:	83a01005 	movhi	r1, #5
57e19218:	81a02007 	movhi	r2, r7
57e1921c:	83e03000 	mvnhi	r3, #0
			else
				chip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);
57e19220:	91a00005 	movls	r0, r5
57e19224:	93a01000 	movls	r1, #0
57e19228:	91a02007 	movls	r2, r7
57e1922c:	959d3008 	ldrls	r3, [sp, #8]
57e19230:	e12fff3c 	blx	ip
		} else
			sndrnd = 1;
		toread = min_t(int, length, chunk);
57e19234:	e59d9004 	ldr	r9, [sp, #4]
		chip->read_buf(mtd, bufpoi, toread);
57e19238:	e5943014 	ldr	r3, [r4, #20]
				chip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);
			else
				chip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);
		} else
			sndrnd = 1;
		toread = min_t(int, length, chunk);
57e1923c:	e1590006 	cmp	r9, r6
57e19240:	a1a09006 	movge	r9, r6
		chip->read_buf(mtd, bufpoi, toread);
57e19244:	e1a0100a 	mov	r1, sl
57e19248:	e1a00005 	mov	r0, r5
57e1924c:	e1a02009 	mov	r2, r9
57e19250:	e12fff33 	blx	r3
	int eccsize = chip->ecc.size;
	uint8_t *bufpoi = buf;
	int i, toread, sndrnd = 0, pos;

	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
	for (i = 0; i < chip->ecc.steps; i++) {
57e19254:	e59d300c 	ldr	r3, [sp, #12]
				chip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);
		} else
			sndrnd = 1;
		toread = min_t(int, length, chunk);
		chip->read_buf(mtd, bufpoi, toread);
		bufpoi += toread;
57e19258:	e08aa009 	add	sl, sl, r9
	int eccsize = chip->ecc.size;
	uint8_t *bufpoi = buf;
	int i, toread, sndrnd = 0, pos;

	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
	for (i = 0; i < chip->ecc.steps; i++) {
57e1925c:	e0877003 	add	r7, r7, r3
		} else
			sndrnd = 1;
		toread = min_t(int, length, chunk);
		chip->read_buf(mtd, bufpoi, toread);
		bufpoi += toread;
		length -= toread;
57e19260:	e0696006 	rsb	r6, r9, r6
	int eccsize = chip->ecc.size;
	uint8_t *bufpoi = buf;
	int i, toread, sndrnd = 0, pos;

	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
	for (i = 0; i < chip->ecc.steps; i++) {
57e19264:	e28bb001 	add	fp, fp, #1
57e19268:	e3a03001 	mov	r3, #1
57e1926c:	e59420a0 	ldr	r2, [r4, #160]	; 0xa0
57e19270:	e15b0002 	cmp	fp, r2
57e19274:	baffffe0 	blt	57e191fc <nand_read_oob_syndrome+0x60>
		toread = min_t(int, length, chunk);
		chip->read_buf(mtd, bufpoi, toread);
		bufpoi += toread;
		length -= toread;
	}
	if (length > 0)
57e19278:	e3560000 	cmp	r6, #0
57e1927c:	da000004 	ble	57e19294 <nand_read_oob_syndrome+0xf8>
		chip->read_buf(mtd, bufpoi, length);
57e19280:	e5943014 	ldr	r3, [r4, #20]
57e19284:	e1a00005 	mov	r0, r5
57e19288:	e1a0100a 	mov	r1, sl
57e1928c:	e1a02006 	mov	r2, r6
57e19290:	e12fff33 	blx	r3

	return 1;
}
57e19294:	e3a00001 	mov	r0, #1
57e19298:	e28dd010 	add	sp, sp, #16
57e1929c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e192a0 <nand_write_oob_std>:
 * @chip:	nand chip info structure
 * @page:	page number to write
 */
static int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
			      int page)
{
57e192a0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int status = 0;
	const uint8_t *buf = chip->oob_poi;
57e192a4:	e5916090 	ldr	r6, [r1, #144]	; 0x90
	int length = mtd->oobsize;
57e192a8:	e5907018 	ldr	r7, [r0, #24]
 * @chip:	nand chip info structure
 * @page:	page number to write
 */
static int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
			      int page)
{
57e192ac:	e1a04001 	mov	r4, r1
57e192b0:	e1a05000 	mov	r5, r0
	int status = 0;
	const uint8_t *buf = chip->oob_poi;
	int length = mtd->oobsize;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
57e192b4:	e591c034 	ldr	ip, [r1, #52]	; 0x34
 * @chip:	nand chip info structure
 * @page:	page number to write
 */
static int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
			      int page)
{
57e192b8:	e1a03002 	mov	r3, r2
	int status = 0;
	const uint8_t *buf = chip->oob_poi;
	int length = mtd->oobsize;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
57e192bc:	e3a01080 	mov	r1, #128	; 0x80
57e192c0:	e5902014 	ldr	r2, [r0, #20]
57e192c4:	e12fff3c 	blx	ip
	chip->write_buf(mtd, buf, length);
57e192c8:	e5943010 	ldr	r3, [r4, #16]
57e192cc:	e1a00005 	mov	r0, r5
57e192d0:	e1a01006 	mov	r1, r6
57e192d4:	e1a02007 	mov	r2, r7
57e192d8:	e12fff33 	blx	r3
	/* Send command to program the OOB data */
	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
57e192dc:	e3e02000 	mvn	r2, #0
57e192e0:	e1a03002 	mov	r3, r2
57e192e4:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e192e8:	e1a00005 	mov	r0, r5
57e192ec:	e3a01010 	mov	r1, #16
57e192f0:	e12fff3c 	blx	ip

	status = chip->waitfunc(mtd, chip);
57e192f4:	e5943038 	ldr	r3, [r4, #56]	; 0x38
57e192f8:	e1a00005 	mov	r0, r5
57e192fc:	e1a01004 	mov	r1, r4
57e19300:	e12fff33 	blx	r3

	return status & NAND_STATUS_FAIL ? -EIO : 0;
}
57e19304:	e2100001 	ands	r0, r0, #1
57e19308:	13e00004 	mvnne	r0, #4
57e1930c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e19310 <nand_write_oob_syndrome>:
 * @chip:	nand chip info structure
 * @page:	page number to write
 */
static int nand_write_oob_syndrome(struct mtd_info *mtd,
				   struct nand_chip *chip, int page)
{
57e19310:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e19314:	e1a04001 	mov	r4, r1
57e19318:	e1a05000 	mov	r5, r0
57e1931c:	e1a03002 	mov	r3, r2
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
57e19320:	e59400a8 	ldr	r0, [r4, #168]	; 0xa8
57e19324:	e59120b0 	ldr	r2, [r1, #176]	; 0xb0
57e19328:	e59110b4 	ldr	r1, [r1, #180]	; 0xb4
57e1932c:	e0820000 	add	r0, r2, r0
 * @chip:	nand chip info structure
 * @page:	page number to write
 */
static int nand_write_oob_syndrome(struct mtd_info *mtd,
				   struct nand_chip *chip, int page)
{
57e19330:	e24dd020 	sub	sp, sp, #32
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
57e19334:	e0800001 	add	r0, r0, r1
57e19338:	e58d0010 	str	r0, [sp, #16]
	int eccsize = chip->ecc.size, length = mtd->oobsize;
	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
57e1933c:	e59400a0 	ldr	r0, [r4, #160]	; 0xa0
	/*
	 * data-ecc-data-ecc ... ecc-oob
	 * or
	 * data-pad-ecc-pad-data-pad .... ecc-pad-oob
	 */
	if (!chip->ecc.prepad && !chip->ecc.postpad) {
57e19340:	e3520000 	cmp	r2, #0
 */
static int nand_write_oob_syndrome(struct mtd_info *mtd,
				   struct nand_chip *chip, int page)
{
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
	int eccsize = chip->ecc.size, length = mtd->oobsize;
57e19344:	e59460a4 	ldr	r6, [r4, #164]	; 0xa4
57e19348:	e595a018 	ldr	sl, [r5, #24]
	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
57e1934c:	e58d000c 	str	r0, [sp, #12]
	const uint8_t *bufpoi = chip->oob_poi;
57e19350:	e5949090 	ldr	r9, [r4, #144]	; 0x90
	/*
	 * data-ecc-data-ecc ... ecc-oob
	 * or
	 * data-pad-ecc-pad-data-pad .... ecc-pad-oob
	 */
	if (!chip->ecc.prepad && !chip->ecc.postpad) {
57e19354:	1a000007 	bne	57e19378 <nand_write_oob_syndrome+0x68>
57e19358:	e3510000 	cmp	r1, #0
57e1935c:	1a000005 	bne	57e19378 <nand_write_oob_syndrome+0x68>
		pos = steps * (eccsize + chunk);
57e19360:	e59d0010 	ldr	r0, [sp, #16]
57e19364:	e0802006 	add	r2, r0, r6
57e19368:	e59d000c 	ldr	r0, [sp, #12]
		steps = 0;
57e1936c:	e58d100c 	str	r1, [sp, #12]
	 * data-ecc-data-ecc ... ecc-oob
	 * or
	 * data-pad-ecc-pad-data-pad .... ecc-pad-oob
	 */
	if (!chip->ecc.prepad && !chip->ecc.postpad) {
		pos = steps * (eccsize + chunk);
57e19370:	e0020290 	mul	r2, r0, r2
		steps = 0;
57e19374:	ea000000 	b	57e1937c <nand_write_oob_syndrome+0x6c>
	} else
		pos = eccsize;
57e19378:	e1a02006 	mov	r2, r6

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
57e1937c:	e3a01080 	mov	r1, #128	; 0x80
57e19380:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e19384:	e1a00005 	mov	r0, r5
57e19388:	e12fff3c 	blx	ip
 *			     with syndrome - only for large page flash !
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @page:	page number to write
 */
static int nand_write_oob_syndrome(struct mtd_info *mtd,
57e1938c:	e59d1010 	ldr	r1, [sp, #16]
				   struct nand_chip *chip, int page)
{
	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
	int eccsize = chip->ecc.size, length = mtd->oobsize;
	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
57e19390:	e3a03000 	mov	r3, #0
 *			     with syndrome - only for large page flash !
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @page:	page number to write
 */
static int nand_write_oob_syndrome(struct mtd_info *mtd,
57e19394:	e0811006 	add	r1, r1, r6
57e19398:	e58d1014 	str	r1, [sp, #20]
57e1939c:	e1a0b006 	mov	fp, r6
		steps = 0;
	} else
		pos = eccsize;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
	for (i = 0; i < steps; i++) {
57e193a0:	e58d3008 	str	r3, [sp, #8]
57e193a4:	e1a07006 	mov	r7, r6
57e193a8:	ea00002c 	b	57e19460 <nand_write_oob_syndrome+0x150>
		if (sndcmd) {
57e193ac:	e3530000 	cmp	r3, #0
57e193b0:	0a00001a 	beq	57e19420 <nand_write_oob_syndrome+0x110>
			if (mtd->writesize <= 512) {
57e193b4:	e5953014 	ldr	r3, [r5, #20]
57e193b8:	e3530c02 	cmp	r3, #512	; 0x200
				uint32_t fill = 0xFFFFFFFF;
57e193bc:	93e02000 	mvnls	r2, #0
57e193c0:	958d201c 	strls	r2, [sp, #28]

				len = eccsize;
57e193c4:	91a06007 	movls	r6, r7
		pos = eccsize;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
	for (i = 0; i < steps; i++) {
		if (sndcmd) {
			if (mtd->writesize <= 512) {
57e193c8:	9a00000b 	bls	57e193fc <nand_write_oob_syndrome+0xec>
57e193cc:	ea00000d 	b	57e19408 <nand_write_oob_syndrome+0xf8>
				uint32_t fill = 0xFFFFFFFF;

				len = eccsize;
				while (len > 0) {
					int num = min_t(int, len, 4);
57e193d0:	e3560004 	cmp	r6, #4
57e193d4:	b1a0c006 	movlt	ip, r6
57e193d8:	a3a0c004 	movge	ip, #4
					chip->write_buf(mtd, (uint8_t *)&fill,
57e193dc:	e1a0200c 	mov	r2, ip
57e193e0:	e58dc004 	str	ip, [sp, #4]
57e193e4:	e5943010 	ldr	r3, [r4, #16]
57e193e8:	e1a00005 	mov	r0, r5
57e193ec:	e28d101c 	add	r1, sp, #28
57e193f0:	e12fff33 	blx	r3
							num);
					len -= num;
57e193f4:	e59dc004 	ldr	ip, [sp, #4]
57e193f8:	e06c6006 	rsb	r6, ip, r6
		if (sndcmd) {
			if (mtd->writesize <= 512) {
				uint32_t fill = 0xFFFFFFFF;

				len = eccsize;
				while (len > 0) {
57e193fc:	e3560000 	cmp	r6, #0
57e19400:	cafffff2 	bgt	57e193d0 <nand_write_oob_syndrome+0xc0>
57e19404:	ea000005 	b	57e19420 <nand_write_oob_syndrome+0x110>
							num);
					len -= num;
				}
			} else {
				pos = eccsize + i * (eccsize + chunk);
				chip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);
57e19408:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1940c:	e1a00005 	mov	r0, r5
57e19410:	e3a01085 	mov	r1, #133	; 0x85
57e19414:	e1a0200b 	mov	r2, fp
57e19418:	e3e03000 	mvn	r3, #0
57e1941c:	e12fff3c 	blx	ip
			}
		} else
			sndcmd = 1;
		len = min_t(int, length, chunk);
57e19420:	e59d6010 	ldr	r6, [sp, #16]
		chip->write_buf(mtd, bufpoi, len);
57e19424:	e5943010 	ldr	r3, [r4, #16]
				pos = eccsize + i * (eccsize + chunk);
				chip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);
			}
		} else
			sndcmd = 1;
		len = min_t(int, length, chunk);
57e19428:	e156000a 	cmp	r6, sl
57e1942c:	a1a0600a 	movge	r6, sl
		chip->write_buf(mtd, bufpoi, len);
57e19430:	e1a00005 	mov	r0, r5
57e19434:	e1a01009 	mov	r1, r9
57e19438:	e1a02006 	mov	r2, r6
57e1943c:	e12fff33 	blx	r3
		steps = 0;
	} else
		pos = eccsize;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
	for (i = 0; i < steps; i++) {
57e19440:	e59d3008 	ldr	r3, [sp, #8]
57e19444:	e59d0014 	ldr	r0, [sp, #20]
57e19448:	e2833001 	add	r3, r3, #1
57e1944c:	e58d3008 	str	r3, [sp, #8]
			}
		} else
			sndcmd = 1;
		len = min_t(int, length, chunk);
		chip->write_buf(mtd, bufpoi, len);
		bufpoi += len;
57e19450:	e0899006 	add	r9, r9, r6
		length -= len;
57e19454:	e066a00a 	rsb	sl, r6, sl
		steps = 0;
	} else
		pos = eccsize;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
	for (i = 0; i < steps; i++) {
57e19458:	e08bb000 	add	fp, fp, r0
57e1945c:	e3a03001 	mov	r3, #1
57e19460:	e59d1008 	ldr	r1, [sp, #8]
57e19464:	e59d200c 	ldr	r2, [sp, #12]
57e19468:	e1510002 	cmp	r1, r2
57e1946c:	baffffce 	blt	57e193ac <nand_write_oob_syndrome+0x9c>
		len = min_t(int, length, chunk);
		chip->write_buf(mtd, bufpoi, len);
		bufpoi += len;
		length -= len;
	}
	if (length > 0)
57e19470:	e35a0000 	cmp	sl, #0
57e19474:	da000004 	ble	57e1948c <nand_write_oob_syndrome+0x17c>
		chip->write_buf(mtd, bufpoi, length);
57e19478:	e5943010 	ldr	r3, [r4, #16]
57e1947c:	e1a00005 	mov	r0, r5
57e19480:	e1a01009 	mov	r1, r9
57e19484:	e1a0200a 	mov	r2, sl
57e19488:	e12fff33 	blx	r3

	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
57e1948c:	e3e02000 	mvn	r2, #0
57e19490:	e1a03002 	mov	r3, r2
57e19494:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e19498:	e1a00005 	mov	r0, r5
57e1949c:	e3a01010 	mov	r1, #16
57e194a0:	e12fff3c 	blx	ip
	status = chip->waitfunc(mtd, chip);
57e194a4:	e5943038 	ldr	r3, [r4, #56]	; 0x38
57e194a8:	e1a00005 	mov	r0, r5
57e194ac:	e1a01004 	mov	r1, r4
57e194b0:	e12fff33 	blx	r3

	return status & NAND_STATUS_FAIL ? -EIO : 0;
}
57e194b4:	e2100001 	ands	r0, r0, #1
57e194b8:	13e00004 	mvnne	r0, #4
57e194bc:	e28dd020 	add	sp, sp, #32
57e194c0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e194c4 <nand_write_page_raw>:
 *
 * Not for syndrome calculating ecc controllers, which use a special oob layout
 */
static void nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
				const uint8_t *buf)
{
57e194c4:	e92d4038 	push	{r3, r4, r5, lr}
57e194c8:	e1a05000 	mov	r5, r0
57e194cc:	e1a04001 	mov	r4, r1
	chip->write_buf(mtd, buf, mtd->writesize);
57e194d0:	e5913010 	ldr	r3, [r1, #16]
57e194d4:	e1a01002 	mov	r1, r2
57e194d8:	e5902014 	ldr	r2, [r0, #20]
57e194dc:	e12fff33 	blx	r3
	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
57e194e0:	e5943010 	ldr	r3, [r4, #16]
57e194e4:	e1a00005 	mov	r0, r5
57e194e8:	e5941090 	ldr	r1, [r4, #144]	; 0x90
57e194ec:	e5952018 	ldr	r2, [r5, #24]
57e194f0:	e12fff33 	blx	r3
}
57e194f4:	e8bd8038 	pop	{r3, r4, r5, pc}

57e194f8 <nand_write_page_raw_syndrome>:
 * We need a special oob layout and handling even when ECC isn't checked.
 */
static void nand_write_page_raw_syndrome(struct mtd_info *mtd,
					struct nand_chip *chip,
					const uint8_t *buf)
{
57e194f8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e194fc:	e1a06000 	mov	r6, r0
57e19500:	e1a04001 	mov	r4, r1
57e19504:	e1a07002 	mov	r7, r2
	int eccsize = chip->ecc.size;
57e19508:	e59190a4 	ldr	r9, [r1, #164]	; 0xa4
	int eccbytes = chip->ecc.bytes;
57e1950c:	e591b0a8 	ldr	fp, [r1, #168]	; 0xa8
	uint8_t *oob = chip->oob_poi;
57e19510:	e5915090 	ldr	r5, [r1, #144]	; 0x90
	int steps, size;

	for (steps = chip->ecc.steps; steps > 0; steps--) {
57e19514:	e591a0a0 	ldr	sl, [r1, #160]	; 0xa0
57e19518:	ea00001e 	b	57e19598 <nand_write_page_raw_syndrome+0xa0>
		chip->write_buf(mtd, buf, eccsize);
57e1951c:	e1a01007 	mov	r1, r7
57e19520:	e1a02009 	mov	r2, r9
57e19524:	e5943010 	ldr	r3, [r4, #16]
57e19528:	e1a00006 	mov	r0, r6
57e1952c:	e12fff33 	blx	r3
		buf += eccsize;

		if (chip->ecc.prepad) {
57e19530:	e59420b0 	ldr	r2, [r4, #176]	; 0xb0
 * @chip:	nand chip info structure
 * @buf:	data buffer
 *
 * We need a special oob layout and handling even when ECC isn't checked.
 */
static void nand_write_page_raw_syndrome(struct mtd_info *mtd,
57e19534:	e0877009 	add	r7, r7, r9

	for (steps = chip->ecc.steps; steps > 0; steps--) {
		chip->write_buf(mtd, buf, eccsize);
		buf += eccsize;

		if (chip->ecc.prepad) {
57e19538:	e3520000 	cmp	r2, #0
57e1953c:	0a000005 	beq	57e19558 <nand_write_page_raw_syndrome+0x60>
			chip->write_buf(mtd, oob, chip->ecc.prepad);
57e19540:	e5943010 	ldr	r3, [r4, #16]
57e19544:	e1a01005 	mov	r1, r5
57e19548:	e1a00006 	mov	r0, r6
57e1954c:	e12fff33 	blx	r3
			oob += chip->ecc.prepad;
57e19550:	e59430b0 	ldr	r3, [r4, #176]	; 0xb0
57e19554:	e0855003 	add	r5, r5, r3
		}

		chip->read_buf(mtd, oob, eccbytes);
57e19558:	e1a01005 	mov	r1, r5
57e1955c:	e1a0200b 	mov	r2, fp
57e19560:	e5943014 	ldr	r3, [r4, #20]
57e19564:	e1a00006 	mov	r0, r6
57e19568:	e12fff33 	blx	r3
		oob += eccbytes;

		if (chip->ecc.postpad) {
57e1956c:	e59420b4 	ldr	r2, [r4, #180]	; 0xb4
			chip->write_buf(mtd, oob, chip->ecc.prepad);
			oob += chip->ecc.prepad;
		}

		chip->read_buf(mtd, oob, eccbytes);
		oob += eccbytes;
57e19570:	e085500b 	add	r5, r5, fp

		if (chip->ecc.postpad) {
57e19574:	e3520000 	cmp	r2, #0
57e19578:	0a000005 	beq	57e19594 <nand_write_page_raw_syndrome+0x9c>
			chip->write_buf(mtd, oob, chip->ecc.postpad);
57e1957c:	e5943010 	ldr	r3, [r4, #16]
57e19580:	e1a01005 	mov	r1, r5
57e19584:	e1a00006 	mov	r0, r6
57e19588:	e12fff33 	blx	r3
			oob += chip->ecc.postpad;
57e1958c:	e59430b4 	ldr	r3, [r4, #180]	; 0xb4
57e19590:	e0855003 	add	r5, r5, r3
	int eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	uint8_t *oob = chip->oob_poi;
	int steps, size;

	for (steps = chip->ecc.steps; steps > 0; steps--) {
57e19594:	e24aa001 	sub	sl, sl, #1
57e19598:	e35a0000 	cmp	sl, #0
57e1959c:	caffffde 	bgt	57e1951c <nand_write_page_raw_syndrome+0x24>
			chip->write_buf(mtd, oob, chip->ecc.postpad);
			oob += chip->ecc.postpad;
		}
	}

	size = mtd->oobsize - (oob - chip->oob_poi);
57e195a0:	e5942090 	ldr	r2, [r4, #144]	; 0x90
57e195a4:	e5963018 	ldr	r3, [r6, #24]
57e195a8:	e0652002 	rsb	r2, r5, r2
	if (size)
57e195ac:	e0922003 	adds	r2, r2, r3
57e195b0:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
		chip->write_buf(mtd, oob, size);
57e195b4:	e5943010 	ldr	r3, [r4, #16]
57e195b8:	e1a00006 	mov	r0, r6
57e195bc:	e1a01005 	mov	r1, r5
57e195c0:	e12fff33 	blx	r3
57e195c4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e195c8 <nand_write_page_swecc>:
 * @chip:	nand chip info structure
 * @buf:	data buffer
 */
static void nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
				  const uint8_t *buf)
{
57e195c8:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
57e195cc:	e59130a8 	ldr	r3, [r1, #168]	; 0xa8
 * @buf:	data buffer
 */
static void nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
				  const uint8_t *buf)
{
	int i, eccsize = chip->ecc.size;
57e195d0:	e591c0a4 	ldr	ip, [r1, #164]	; 0xa4
	int eccbytes = chip->ecc.bytes;
57e195d4:	e58d3004 	str	r3, [sp, #4]
	int eccsteps = chip->ecc.steps;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	const uint8_t *p = buf;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e195d8:	e59130b8 	ldr	r3, [r1, #184]	; 0xb8
 * @chip:	nand chip info structure
 * @buf:	data buffer
 */
static void nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
				  const uint8_t *buf)
{
57e195dc:	e1a09000 	mov	r9, r0
57e195e0:	e1a04001 	mov	r4, r1
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
57e195e4:	e59150a0 	ldr	r5, [r1, #160]	; 0xa0
	uint8_t *ecc_calc = chip->buffers->ecccalc;
57e195e8:	e591a0e8 	ldr	sl, [r1, #232]	; 0xe8
	const uint8_t *p = buf;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e195ec:	e58d3008 	str	r3, [sp, #8]
{
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	const uint8_t *p = buf;
57e195f0:	e1a07002 	mov	r7, r2
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	/* Software ecc calculation */
	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
57e195f4:	e3a06000 	mov	r6, #0
57e195f8:	e58d200c 	str	r2, [sp, #12]
57e195fc:	e1a0b00c 	mov	fp, ip
57e19600:	ea000008 	b	57e19628 <nand_write_page_swecc+0x60>
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
57e19604:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
57e19608:	e1a01007 	mov	r1, r7
57e1960c:	e08a2006 	add	r2, sl, r6
57e19610:	e1a00009 	mov	r0, r9
57e19614:	e12fff33 	blx	r3
 * nand_write_page_swecc - [REPLACABLE] software ecc based page write function
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	data buffer
 */
static void nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
57e19618:	e59d3004 	ldr	r3, [sp, #4]
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	const uint8_t *p = buf;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	/* Software ecc calculation */
	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
57e1961c:	e2455001 	sub	r5, r5, #1
 * nand_write_page_swecc - [REPLACABLE] software ecc based page write function
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	data buffer
 */
static void nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
57e19620:	e0866003 	add	r6, r6, r3
57e19624:	e087700b 	add	r7, r7, fp
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	const uint8_t *p = buf;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	/* Software ecc calculation */
	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
57e19628:	e3550000 	cmp	r5, #0
57e1962c:	1afffff4 	bne	57e19604 <nand_write_page_swecc+0x3c>
57e19630:	e59db00c 	ldr	fp, [sp, #12]
57e19634:	e59d3008 	ldr	r3, [sp, #8]
57e19638:	ea000004 	b	57e19650 <nand_write_page_swecc+0x88>
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);

	for (i = 0; i < chip->ecc.total; i++)
		chip->oob_poi[eccpos[i]] = ecc_calc[i];
57e1963c:	e7da0005 	ldrb	r0, [sl, r5]
57e19640:	e5b32004 	ldr	r2, [r3, #4]!
57e19644:	e5941090 	ldr	r1, [r4, #144]	; 0x90

	/* Software ecc calculation */
	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);

	for (i = 0; i < chip->ecc.total; i++)
57e19648:	e2855001 	add	r5, r5, #1
		chip->oob_poi[eccpos[i]] = ecc_calc[i];
57e1964c:	e7c10002 	strb	r0, [r1, r2]

	/* Software ecc calculation */
	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);

	for (i = 0; i < chip->ecc.total; i++)
57e19650:	e59420ac 	ldr	r2, [r4, #172]	; 0xac
57e19654:	e1550002 	cmp	r5, r2
57e19658:	bafffff7 	blt	57e1963c <nand_write_page_swecc+0x74>
		chip->oob_poi[eccpos[i]] = ecc_calc[i];

	chip->ecc.write_page_raw(mtd, chip, buf);
57e1965c:	e59430d0 	ldr	r3, [r4, #208]	; 0xd0
57e19660:	e1a00009 	mov	r0, r9
57e19664:	e1a01004 	mov	r1, r4
57e19668:	e1a0200b 	mov	r2, fp
57e1966c:	e12fff33 	blx	r3
}
57e19670:	e8bd8eff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

57e19674 <nand_write_page_hwecc>:
 * @chip:	nand chip info structure
 * @buf:	data buffer
 */
static void nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
				  const uint8_t *buf)
{
57e19674:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	const uint8_t *p = buf;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e19678:	e59130b8 	ldr	r3, [r1, #184]	; 0xb8
 * @chip:	nand chip info structure
 * @buf:	data buffer
 */
static void nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
				  const uint8_t *buf)
{
57e1967c:	e1a05000 	mov	r5, r0
57e19680:	e1a04001 	mov	r4, r1
	int i, eccsize = chip->ecc.size;
57e19684:	e28160a0 	add	r6, r1, #160	; 0xa0
57e19688:	e8961240 	ldm	r6, {r6, r9, ip}
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
57e1968c:	e591b0e8 	ldr	fp, [r1, #232]	; 0xe8
	const uint8_t *p = buf;
	uint32_t *eccpos = chip->ecc.layout->eccpos;
57e19690:	e58d3004 	str	r3, [sp, #4]
{
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	const uint8_t *p = buf;
57e19694:	e1a07002 	mov	r7, r2
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e19698:	e3a0a000 	mov	sl, #0
57e1969c:	ea000012 	b	57e196ec <nand_write_page_hwecc+0x78>
		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
57e196a0:	e58dc000 	str	ip, [sp]
57e196a4:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
57e196a8:	e1a00005 	mov	r0, r5
57e196ac:	e3a01001 	mov	r1, #1
57e196b0:	e12fff33 	blx	r3
		chip->write_buf(mtd, p, eccsize);
57e196b4:	e1a01007 	mov	r1, r7
57e196b8:	e5943010 	ldr	r3, [r4, #16]
57e196bc:	e1a00005 	mov	r0, r5
57e196c0:	e1a02009 	mov	r2, r9
57e196c4:	e12fff33 	blx	r3
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
57e196c8:	e1a01007 	mov	r1, r7
57e196cc:	e08b200a 	add	r2, fp, sl
57e196d0:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
57e196d4:	e1a00005 	mov	r0, r5
57e196d8:	e12fff33 	blx	r3
 * nand_write_page_hwecc - [REPLACABLE] hardware ecc based page write function
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	data buffer
 */
static void nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
57e196dc:	e59dc000 	ldr	ip, [sp]
	int eccsteps = chip->ecc.steps;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	const uint8_t *p = buf;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e196e0:	e2466001 	sub	r6, r6, #1
 * nand_write_page_hwecc - [REPLACABLE] hardware ecc based page write function
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	data buffer
 */
static void nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
57e196e4:	e08aa00c 	add	sl, sl, ip
57e196e8:	e0877009 	add	r7, r7, r9
	int eccsteps = chip->ecc.steps;
	uint8_t *ecc_calc = chip->buffers->ecccalc;
	const uint8_t *p = buf;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e196ec:	e3560000 	cmp	r6, #0
57e196f0:	1affffea 	bne	57e196a0 <nand_write_page_hwecc+0x2c>
57e196f4:	e59d3004 	ldr	r3, [sp, #4]
57e196f8:	ea000004 	b	57e19710 <nand_write_page_hwecc+0x9c>
		chip->write_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
	}

	for (i = 0; i < chip->ecc.total; i++)
		chip->oob_poi[eccpos[i]] = ecc_calc[i];
57e196fc:	e7db0006 	ldrb	r0, [fp, r6]
57e19700:	e5b32004 	ldr	r2, [r3, #4]!
57e19704:	e5941090 	ldr	r1, [r4, #144]	; 0x90
		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
		chip->write_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
	}

	for (i = 0; i < chip->ecc.total; i++)
57e19708:	e2866001 	add	r6, r6, #1
		chip->oob_poi[eccpos[i]] = ecc_calc[i];
57e1970c:	e7c10002 	strb	r0, [r1, r2]
		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
		chip->write_buf(mtd, p, eccsize);
		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
	}

	for (i = 0; i < chip->ecc.total; i++)
57e19710:	e59420ac 	ldr	r2, [r4, #172]	; 0xac
57e19714:	e1560002 	cmp	r6, r2
57e19718:	bafffff7 	blt	57e196fc <nand_write_page_hwecc+0x88>
		chip->oob_poi[eccpos[i]] = ecc_calc[i];

	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
57e1971c:	e5943010 	ldr	r3, [r4, #16]
57e19720:	e1a00005 	mov	r0, r5
57e19724:	e5941090 	ldr	r1, [r4, #144]	; 0x90
57e19728:	e5952018 	ldr	r2, [r5, #24]
57e1972c:	e12fff33 	blx	r3
}
57e19730:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

57e19734 <nand_write_page_syndrome>:
 * The hw generator calculates the error syndrome automatically. Therefor
 * we need a special oob layout and handling.
 */
static void nand_write_page_syndrome(struct mtd_info *mtd,
				    struct nand_chip *chip, const uint8_t *buf)
{
57e19734:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e19738:	e1a06000 	mov	r6, r0
57e1973c:	e1a04001 	mov	r4, r1
	int i, eccsize = chip->ecc.size;
57e19740:	e59190a4 	ldr	r9, [r1, #164]	; 0xa4
	int eccbytes = chip->ecc.bytes;
57e19744:	e591b0a8 	ldr	fp, [r1, #168]	; 0xa8
	int eccsteps = chip->ecc.steps;
57e19748:	e591a0a0 	ldr	sl, [r1, #160]	; 0xa0
	const uint8_t *p = buf;
	uint8_t *oob = chip->oob_poi;
57e1974c:	e5915090 	ldr	r5, [r1, #144]	; 0x90
				    struct nand_chip *chip, const uint8_t *buf)
{
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	const uint8_t *p = buf;
57e19750:	e1a07002 	mov	r7, r2
	uint8_t *oob = chip->oob_poi;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e19754:	ea000027 	b	57e197f8 <nand_write_page_syndrome+0xc4>

		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
57e19758:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
57e1975c:	e1a00006 	mov	r0, r6
57e19760:	e3a01001 	mov	r1, #1
57e19764:	e12fff33 	blx	r3
		chip->write_buf(mtd, p, eccsize);
57e19768:	e1a02009 	mov	r2, r9
57e1976c:	e5943010 	ldr	r3, [r4, #16]
57e19770:	e1a00006 	mov	r0, r6
57e19774:	e1a01007 	mov	r1, r7
57e19778:	e12fff33 	blx	r3

		if (chip->ecc.prepad) {
57e1977c:	e59420b0 	ldr	r2, [r4, #176]	; 0xb0
57e19780:	e3520000 	cmp	r2, #0
57e19784:	0a000005 	beq	57e197a0 <nand_write_page_syndrome+0x6c>
			chip->write_buf(mtd, oob, chip->ecc.prepad);
57e19788:	e5943010 	ldr	r3, [r4, #16]
57e1978c:	e1a01005 	mov	r1, r5
57e19790:	e1a00006 	mov	r0, r6
57e19794:	e12fff33 	blx	r3
			oob += chip->ecc.prepad;
57e19798:	e59430b0 	ldr	r3, [r4, #176]	; 0xb0
57e1979c:	e0855003 	add	r5, r5, r3
		}

		chip->ecc.calculate(mtd, p, oob);
57e197a0:	e1a02005 	mov	r2, r5
57e197a4:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
57e197a8:	e1a01007 	mov	r1, r7
57e197ac:	e1a00006 	mov	r0, r6
57e197b0:	e12fff33 	blx	r3
		chip->write_buf(mtd, oob, eccbytes);
57e197b4:	e1a01005 	mov	r1, r5
57e197b8:	e1a0200b 	mov	r2, fp
57e197bc:	e5943010 	ldr	r3, [r4, #16]
57e197c0:	e1a00006 	mov	r0, r6
57e197c4:	e12fff33 	blx	r3
		oob += eccbytes;

		if (chip->ecc.postpad) {
57e197c8:	e59420b4 	ldr	r2, [r4, #180]	; 0xb4
			oob += chip->ecc.prepad;
		}

		chip->ecc.calculate(mtd, p, oob);
		chip->write_buf(mtd, oob, eccbytes);
		oob += eccbytes;
57e197cc:	e085500b 	add	r5, r5, fp

		if (chip->ecc.postpad) {
57e197d0:	e3520000 	cmp	r2, #0
57e197d4:	0a000005 	beq	57e197f0 <nand_write_page_syndrome+0xbc>
			chip->write_buf(mtd, oob, chip->ecc.postpad);
57e197d8:	e5943010 	ldr	r3, [r4, #16]
57e197dc:	e1a01005 	mov	r1, r5
57e197e0:	e1a00006 	mov	r0, r6
57e197e4:	e12fff33 	blx	r3
			oob += chip->ecc.postpad;
57e197e8:	e59430b4 	ldr	r3, [r4, #180]	; 0xb4
57e197ec:	e0855003 	add	r5, r5, r3
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	const uint8_t *p = buf;
	uint8_t *oob = chip->oob_poi;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e197f0:	e24aa001 	sub	sl, sl, #1
 * @buf:	data buffer
 *
 * The hw generator calculates the error syndrome automatically. Therefor
 * we need a special oob layout and handling.
 */
static void nand_write_page_syndrome(struct mtd_info *mtd,
57e197f4:	e0877009 	add	r7, r7, r9
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	const uint8_t *p = buf;
	uint8_t *oob = chip->oob_poi;

	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
57e197f8:	e35a0000 	cmp	sl, #0
57e197fc:	1affffd5 	bne	57e19758 <nand_write_page_syndrome+0x24>
			oob += chip->ecc.postpad;
		}
	}

	/* Calculate remaining oob bytes */
	i = mtd->oobsize - (oob - chip->oob_poi);
57e19800:	e5942090 	ldr	r2, [r4, #144]	; 0x90
57e19804:	e5963018 	ldr	r3, [r6, #24]
57e19808:	e0652002 	rsb	r2, r5, r2
	if (i)
57e1980c:	e0922003 	adds	r2, r2, r3
57e19810:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
		chip->write_buf(mtd, oob, i);
57e19814:	e5943010 	ldr	r3, [r4, #16]
57e19818:	e1a00006 	mov	r0, r6
57e1981c:	e1a01005 	mov	r1, r5
57e19820:	e12fff33 	blx	r3
57e19824:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e19828 <single_erase_cmd>:
 * @page:	the page address of the block which will be erased
 *
 * Standard erase command for NAND chips
 */
static void single_erase_cmd(struct mtd_info *mtd, int page)
{
57e19828:	e92d4038 	push	{r3, r4, r5, lr}
	struct nand_chip *chip = mtd->priv;
57e1982c:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 * @page:	the page address of the block which will be erased
 *
 * Standard erase command for NAND chips
 */
static void single_erase_cmd(struct mtd_info *mtd, int page)
{
57e19830:	e1a03001 	mov	r3, r1
	struct nand_chip *chip = mtd->priv;
	/* Send commands to erase a block */
	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
57e19834:	e595c034 	ldr	ip, [r5, #52]	; 0x34
57e19838:	e3a01060 	mov	r1, #96	; 0x60
57e1983c:	e3e02000 	mvn	r2, #0
 * @page:	the page address of the block which will be erased
 *
 * Standard erase command for NAND chips
 */
static void single_erase_cmd(struct mtd_info *mtd, int page)
{
57e19840:	e1a04000 	mov	r4, r0
	struct nand_chip *chip = mtd->priv;
	/* Send commands to erase a block */
	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
57e19844:	e12fff3c 	blx	ip
	chip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);
57e19848:	e3e02000 	mvn	r2, #0
57e1984c:	e595c034 	ldr	ip, [r5, #52]	; 0x34
57e19850:	e1a00004 	mov	r0, r4
57e19854:	e3a010d0 	mov	r1, #208	; 0xd0
57e19858:	e1a03002 	mov	r3, r2
57e1985c:	e12fff3c 	blx	ip
}
57e19860:	e8bd8038 	pop	{r3, r4, r5, pc}

57e19864 <multi_erase_cmd>:
 *
 * AND multi block erase command function
 * Erase 4 consecutive blocks
 */
static void multi_erase_cmd(struct mtd_info *mtd, int page)
{
57e19864:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct nand_chip *chip = mtd->priv;
57e19868:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 *
 * AND multi block erase command function
 * Erase 4 consecutive blocks
 */
static void multi_erase_cmd(struct mtd_info *mtd, int page)
{
57e1986c:	e1a04000 	mov	r4, r0
	struct nand_chip *chip = mtd->priv;
	/* Send commands to erase a block */
	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
57e19870:	e2816001 	add	r6, r1, #1
 *
 * AND multi block erase command function
 * Erase 4 consecutive blocks
 */
static void multi_erase_cmd(struct mtd_info *mtd, int page)
{
57e19874:	e1a03001 	mov	r3, r1
	struct nand_chip *chip = mtd->priv;
	/* Send commands to erase a block */
	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
57e19878:	e595c034 	ldr	ip, [r5, #52]	; 0x34
57e1987c:	e3a01060 	mov	r1, #96	; 0x60
57e19880:	e3e02000 	mvn	r2, #0
57e19884:	e12fff3c 	blx	ip
	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
57e19888:	e2867001 	add	r7, r6, #1
57e1988c:	e595c034 	ldr	ip, [r5, #52]	; 0x34
57e19890:	e1a00004 	mov	r0, r4
57e19894:	e1a03006 	mov	r3, r6
57e19898:	e3a01060 	mov	r1, #96	; 0x60
57e1989c:	e3e02000 	mvn	r2, #0
57e198a0:	e12fff3c 	blx	ip
	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
57e198a4:	e595c034 	ldr	ip, [r5, #52]	; 0x34
57e198a8:	e1a00004 	mov	r0, r4
57e198ac:	e1a03007 	mov	r3, r7
57e198b0:	e3a01060 	mov	r1, #96	; 0x60
57e198b4:	e3e02000 	mvn	r2, #0
57e198b8:	e12fff3c 	blx	ip
	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
57e198bc:	e595c034 	ldr	ip, [r5, #52]	; 0x34
57e198c0:	e1a00004 	mov	r0, r4
57e198c4:	e2873001 	add	r3, r7, #1
57e198c8:	e3a01060 	mov	r1, #96	; 0x60
57e198cc:	e3e02000 	mvn	r2, #0
57e198d0:	e12fff3c 	blx	ip
	chip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);
57e198d4:	e3e02000 	mvn	r2, #0
57e198d8:	e595c034 	ldr	ip, [r5, #52]	; 0x34
57e198dc:	e1a00004 	mov	r0, r4
57e198e0:	e3a010d0 	mov	r1, #208	; 0xd0
57e198e4:	e1a03002 	mov	r3, r2
57e198e8:	e12fff3c 	blx	ip
}
57e198ec:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e198f0 <nand_sync>:
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e198f0:	e5903094 	ldr	r3, [r0, #148]	; 0x94
57e198f4:	e3a02004 	mov	r2, #4
57e198f8:	e583208c 	str	r2, [r3, #140]	; 0x8c
	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: called\n", __func__);

	/* Grab the lock and see if the device is available */
	nand_get_device(chip, mtd, FL_SYNCING);
	/* Release it and go back */
	nand_release_device(mtd);
57e198fc:	eafffb91 	b	57e18748 <nand_release_device>

57e19900 <nand_select_chip>:
 */
static void nand_select_chip(struct mtd_info *mtd, int chipnr)
{
	struct nand_chip *chip = mtd->priv;

	switch (chipnr) {
57e19900:	e3710001 	cmn	r1, #1
 * @chipnr:	chipnumber to select, -1 for deselect
 *
 * Default select function for 1 chip devices.
 */
static void nand_select_chip(struct mtd_info *mtd, int chipnr)
{
57e19904:	e92d4008 	push	{r3, lr}
	struct nand_chip *chip = mtd->priv;
57e19908:	e5902094 	ldr	r2, [r0, #148]	; 0x94

	switch (chipnr) {
57e1990c:	0a000002 	beq	57e1991c <nand_select_chip+0x1c>
57e19910:	e3510000 	cmp	r1, #0
57e19914:	08bd8008 	popeq	{r3, pc}
57e19918:	ea000003 	b	57e1992c <nand_select_chip+0x2c>
	case -1:
		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
57e1991c:	e5923028 	ldr	r3, [r2, #40]	; 0x28
57e19920:	e3a02080 	mov	r2, #128	; 0x80
57e19924:	e12fff33 	blx	r3
57e19928:	e8bd8008 	pop	{r3, pc}
		break;
	case 0:
		break;

	default:
		BUG();
57e1992c:	e59f0014 	ldr	r0, [pc, #20]	; 57e19948 <nand_select_chip+0x48>
57e19930:	e59f1014 	ldr	r1, [pc, #20]	; 57e1994c <nand_select_chip+0x4c>
57e19934:	e3a020da 	mov	r2, #218	; 0xda
57e19938:	e59f3010 	ldr	r3, [pc, #16]	; 57e19950 <nand_select_chip+0x50>
57e1993c:	ebffbec2 	bl	57e0944c <printf>
57e19940:	e59f000c 	ldr	r0, [pc, #12]	; 57e19954 <nand_select_chip+0x54>
57e19944:	eb002e88 	bl	57e2536c <panic>
57e19948:	57e33a28 	.word	0x57e33a28
57e1994c:	57e342aa 	.word	0x57e342aa
57e19950:	57e2cc6c 	.word	0x57e2cc6c
57e19954:	57e33a50 	.word	0x57e33a50

57e19958 <nand_block_checkbad>:
 * Check, if the block is bad. Either by reading the bad block table or
 * calling of the scan function.
 */
static int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
			       int allowbbt)
{
57e19958:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	struct nand_chip *chip = mtd->priv;
57e1995c:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 * Check, if the block is bad. Either by reading the bad block table or
 * calling of the scan function.
 */
static int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
			       int allowbbt)
{
57e19960:	e1a07003 	mov	r7, r3
	struct nand_chip *chip = mtd->priv;

	if (!(chip->options & NAND_BBT_SCANNED)) {
57e19964:	e5953050 	ldr	r3, [r5, #80]	; 0x50
 * Check, if the block is bad. Either by reading the bad block table or
 * calling of the scan function.
 */
static int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
			       int allowbbt)
{
57e19968:	e1a04000 	mov	r4, r0
	struct nand_chip *chip = mtd->priv;

	if (!(chip->options & NAND_BBT_SCANNED)) {
57e1996c:	e3130101 	tst	r3, #1073741824	; 0x40000000
 * Check, if the block is bad. Either by reading the bad block table or
 * calling of the scan function.
 */
static int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
			       int allowbbt)
{
57e19970:	e1a06002 	mov	r6, r2
57e19974:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
57e19978:	e59da02c 	ldr	sl, [sp, #44]	; 0x2c
	struct nand_chip *chip = mtd->priv;

	if (!(chip->options & NAND_BBT_SCANNED)) {
57e1997c:	1a000003 	bne	57e19990 <nand_block_checkbad+0x38>
		chip->options |= NAND_BBT_SCANNED;
57e19980:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
57e19984:	e5853050 	str	r3, [r5, #80]	; 0x50
		chip->scan_bbt(mtd);
57e19988:	e5953040 	ldr	r3, [r5, #64]	; 0x40
57e1998c:	e12fff33 	blx	r3
	}

	if (!chip->bbt)
57e19990:	e5953110 	ldr	r3, [r5, #272]	; 0x110
57e19994:	e3530000 	cmp	r3, #0
57e19998:	1a000007 	bne	57e199bc <nand_block_checkbad+0x64>
		return chip->block_bad(mtd, ofs, getchip);
57e1999c:	e58d9000 	str	r9, [sp]
57e199a0:	e5951020 	ldr	r1, [r5, #32]
57e199a4:	e1a00004 	mov	r0, r4
57e199a8:	e1a02006 	mov	r2, r6
57e199ac:	e1a03007 	mov	r3, r7
57e199b0:	e12fff31 	blx	r1

	/* Return info from the table */
	return nand_isbad_bbt(mtd, ofs, allowbbt);
}
57e199b4:	e28dd00c 	add	sp, sp, #12
57e199b8:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

	if (!chip->bbt)
		return chip->block_bad(mtd, ofs, getchip);

	/* Return info from the table */
	return nand_isbad_bbt(mtd, ofs, allowbbt);
57e199bc:	e1a00004 	mov	r0, r4
57e199c0:	e1a02006 	mov	r2, r6
57e199c4:	e1a03007 	mov	r3, r7
57e199c8:	e58da028 	str	sl, [sp, #40]	; 0x28
}
57e199cc:	e28dd00c 	add	sp, sp, #12
57e199d0:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}

	if (!chip->bbt)
		return chip->block_bad(mtd, ofs, getchip);

	/* Return info from the table */
	return nand_isbad_bbt(mtd, ofs, allowbbt);
57e199d4:	eafff8a8 	b	57e17c7c <nand_isbad_bbt>

57e199d8 <nand_block_isbad>:
 * nand_block_isbad - [MTD Interface] Check if block at offset is bad
 * @mtd:	MTD device structure
 * @offs:	offset relative to mtd start
 */
static int nand_block_isbad(struct mtd_info *mtd, loff_t offs)
{
57e199d8:	e92d4007 	push	{r0, r1, r2, lr}
	/* Check for invalid offset */
	if (offs > mtd->size)
57e199dc:	e590100c 	ldr	r1, [r0, #12]
57e199e0:	e1510003 	cmp	r1, r3
57e199e4:	3a000009 	bcc	57e19a10 <nand_block_isbad+0x38>
57e199e8:	1a000002 	bne	57e199f8 <nand_block_isbad+0x20>
57e199ec:	e5901008 	ldr	r1, [r0, #8]
57e199f0:	e1510002 	cmp	r1, r2
57e199f4:	3a000005 	bcc	57e19a10 <nand_block_isbad+0x38>
		return -EINVAL;

	return nand_block_checkbad(mtd, offs, 1, 0);
57e199f8:	e3a01001 	mov	r1, #1
57e199fc:	e58d1000 	str	r1, [sp]
57e19a00:	e3a01000 	mov	r1, #0
57e19a04:	e58d1004 	str	r1, [sp, #4]
57e19a08:	ebffffd2 	bl	57e19958 <nand_block_checkbad>
57e19a0c:	ea000000 	b	57e19a14 <nand_block_isbad+0x3c>
 */
static int nand_block_isbad(struct mtd_info *mtd, loff_t offs)
{
	/* Check for invalid offset */
	if (offs > mtd->size)
		return -EINVAL;
57e19a10:	e3e00015 	mvn	r0, #21

	return nand_block_checkbad(mtd, offs, 1, 0);
}
57e19a14:	e8bd800e 	pop	{r1, r2, r3, pc}

57e19a18 <nand_block_markbad>:
 * nand_block_markbad - [MTD Interface] Mark block at the given offset as bad
 * @mtd:	MTD device structure
 * @ofs:	offset relative to mtd start
 */
static int nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
57e19a18:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e19a1c:	e1a04000 	mov	r4, r0
57e19a20:	e1a05002 	mov	r5, r2
57e19a24:	e1a06003 	mov	r6, r3
	struct nand_chip *chip = mtd->priv;
57e19a28:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	int ret;

	ret = nand_block_isbad(mtd, ofs);
57e19a2c:	ebffffe9 	bl	57e199d8 <nand_block_isbad>
	if (ret) {
57e19a30:	e3500000 	cmp	r0, #0
57e19a34:	10000fc0 	andne	r0, r0, r0, asr #31
57e19a38:	18bd80f8 	popne	{r3, r4, r5, r6, r7, pc}
		if (ret > 0)
			return 0;
		return ret;
	}

	return chip->block_markbad(mtd, ofs);
57e19a3c:	e5971024 	ldr	r1, [r7, #36]	; 0x24
57e19a40:	e1a00004 	mov	r0, r4
57e19a44:	e1a02005 	mov	r2, r5
57e19a48:	e1a03006 	mov	r3, r6
57e19a4c:	e12fff31 	blx	r1
}
57e19a50:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e19a54 <nand_write_page>:
 * @cached:	cached programming
 * @raw:	use _raw version of write_page
 */
static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
			   const uint8_t *buf, int page, int cached, int raw)
{
57e19a54:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	int status;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
57e19a58:	e591c034 	ldr	ip, [r1, #52]	; 0x34
 * @cached:	cached programming
 * @raw:	use _raw version of write_page
 */
static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
			   const uint8_t *buf, int page, int cached, int raw)
{
57e19a5c:	e1a04001 	mov	r4, r1
57e19a60:	e1a06002 	mov	r6, r2
	int status;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
57e19a64:	e3a01080 	mov	r1, #128	; 0x80
57e19a68:	e3a02000 	mov	r2, #0
 * @cached:	cached programming
 * @raw:	use _raw version of write_page
 */
static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
			   const uint8_t *buf, int page, int cached, int raw)
{
57e19a6c:	e1a05000 	mov	r5, r0
57e19a70:	e1a07003 	mov	r7, r3
	int status;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
57e19a74:	e12fff3c 	blx	ip

	if (unlikely(raw))
57e19a78:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
		chip->ecc.write_page_raw(mtd, chip, buf);
	else
		chip->ecc.write_page(mtd, chip, buf);
57e19a7c:	e1a00005 	mov	r0, r5
{
	int status;

	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);

	if (unlikely(raw))
57e19a80:	e3530000 	cmp	r3, #0
		chip->ecc.write_page_raw(mtd, chip, buf);
57e19a84:	159430d0 	ldrne	r3, [r4, #208]	; 0xd0
	else
		chip->ecc.write_page(mtd, chip, buf);
57e19a88:	059430dc 	ldreq	r3, [r4, #220]	; 0xdc
57e19a8c:	e1a01004 	mov	r1, r4
57e19a90:	e1a02006 	mov	r2, r6
57e19a94:	e12fff33 	blx	r3
	 */
	cached = 0;

	if (!cached || !(chip->options & NAND_CACHEPRG)) {

		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
57e19a98:	e3e02000 	mvn	r2, #0
57e19a9c:	e1a03002 	mov	r3, r2
57e19aa0:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e19aa4:	e1a00005 	mov	r0, r5
57e19aa8:	e3a01010 	mov	r1, #16
57e19aac:	e12fff3c 	blx	ip
		status = chip->waitfunc(mtd, chip);
57e19ab0:	e5943038 	ldr	r3, [r4, #56]	; 0x38
57e19ab4:	e1a00005 	mov	r0, r5
57e19ab8:	e1a01004 	mov	r1, r4
57e19abc:	e12fff33 	blx	r3
		/*
		 * See if operation failed and additional status checks are
		 * available
		 */
		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
57e19ac0:	e3100001 	tst	r0, #1
	cached = 0;

	if (!cached || !(chip->options & NAND_CACHEPRG)) {

		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
		status = chip->waitfunc(mtd, chip);
57e19ac4:	e1a03000 	mov	r3, r0
		/*
		 * See if operation failed and additional status checks are
		 * available
		 */
		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
57e19ac8:	0a000008 	beq	57e19af0 <nand_write_page+0x9c>
57e19acc:	e594c044 	ldr	ip, [r4, #68]	; 0x44
57e19ad0:	e35c0000 	cmp	ip, #0
57e19ad4:	0a000005 	beq	57e19af0 <nand_write_page+0x9c>
			status = chip->errstat(mtd, chip, FL_WRITING, status,
57e19ad8:	e58d7000 	str	r7, [sp]
57e19adc:	e1a00005 	mov	r0, r5
57e19ae0:	e1a01004 	mov	r1, r4
57e19ae4:	e3a02002 	mov	r2, #2
57e19ae8:	e12fff3c 	blx	ip
57e19aec:	e1a03000 	mov	r3, r0

	if (chip->verify_buf(mtd, buf, mtd->writesize))
		return -EIO;
#endif
	return 0;
}
57e19af0:	e2130001 	ands	r0, r3, #1
57e19af4:	13e00004 	mvnne	r0, #4
57e19af8:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

57e19afc <nand_block_bad>:
 * @getchip:	0, if the chip is already selected
 *
 * Check, if the block is bad.
 */
static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
57e19afc:	e92d4cf8 	push	{r3, r4, r5, r6, r7, sl, fp, lr}
	int page, chipnr, res = 0;
	struct nand_chip *chip = mtd->priv;
57e19b00:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * @getchip:	0, if the chip is already selected
 *
 * Check, if the block is bad.
 */
static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
57e19b04:	e1a0b003 	mov	fp, r3
	int page, chipnr, res = 0;
	struct nand_chip *chip = mtd->priv;
	u16 bad;

	if (chip->options & NAND_BBT_SCANLASTPAGE)
57e19b08:	e5943050 	ldr	r3, [r4, #80]	; 0x50
 * @getchip:	0, if the chip is already selected
 *
 * Check, if the block is bad.
 */
static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
57e19b0c:	e1a05000 	mov	r5, r0
	int page, chipnr, res = 0;
	struct nand_chip *chip = mtd->priv;
	u16 bad;

	if (chip->options & NAND_BBT_SCANLASTPAGE)
57e19b10:	e3130902 	tst	r3, #32768	; 0x8000
 * @getchip:	0, if the chip is already selected
 *
 * Check, if the block is bad.
 */
static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
57e19b14:	e1a0a002 	mov	sl, r2
57e19b18:	e59d7020 	ldr	r7, [sp, #32]
	int page, chipnr, res = 0;
	struct nand_chip *chip = mtd->priv;
	u16 bad;

	if (chip->options & NAND_BBT_SCANLASTPAGE)
57e19b1c:	0a000004 	beq	57e19b34 <nand_block_bad+0x38>
		ofs += mtd->erasesize - mtd->writesize;
57e19b20:	e5902010 	ldr	r2, [r0, #16]
57e19b24:	e5903014 	ldr	r3, [r0, #20]
57e19b28:	e0633002 	rsb	r3, r3, r2
57e19b2c:	e09aa003 	adds	sl, sl, r3
57e19b30:	e2abb000 	adc	fp, fp, #0

	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
57e19b34:	e1a0000a 	mov	r0, sl
57e19b38:	e1a0100b 	mov	r1, fp
57e19b3c:	e5942054 	ldr	r2, [r4, #84]	; 0x54
57e19b40:	eb004834 	bl	57e2bc18 <__ashrdi3>
57e19b44:	e5946070 	ldr	r6, [r4, #112]	; 0x70

	if (getchip) {
57e19b48:	e3570000 	cmp	r7, #0
	u16 bad;

	if (chip->options & NAND_BBT_SCANLASTPAGE)
		ofs += mtd->erasesize - mtd->writesize;

	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
57e19b4c:	e0066000 	and	r6, r6, r0

	if (getchip) {
57e19b50:	0a000009 	beq	57e19b7c <nand_block_bad+0x80>
		chipnr = (int)(ofs >> chip->chip_shift);
57e19b54:	e1a0000a 	mov	r0, sl
57e19b58:	e1a0100b 	mov	r1, fp
57e19b5c:	e5942060 	ldr	r2, [r4, #96]	; 0x60
57e19b60:	eb00482c 	bl	57e2bc18 <__ashrdi3>
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e19b64:	e3a03001 	mov	r3, #1
		ofs += mtd->erasesize - mtd->writesize;

	page = (int)(ofs >> chip->page_shift) & chip->pagemask;

	if (getchip) {
		chipnr = (int)(ofs >> chip->chip_shift);
57e19b68:	e1a01000 	mov	r1, r0
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e19b6c:	e584308c 	str	r3, [r4, #140]	; 0x8c
		chipnr = (int)(ofs >> chip->chip_shift);

		nand_get_device(chip, mtd, FL_READING);

		/* Select the NAND device */
		chip->select_chip(mtd, chipnr);
57e19b70:	e1a00005 	mov	r0, r5
57e19b74:	e594301c 	ldr	r3, [r4, #28]
57e19b78:	e12fff33 	blx	r3
	}

	if (chip->options & NAND_BUSWIDTH_16) {
57e19b7c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e19b80:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e19b84:	e3130002 	tst	r3, #2
57e19b88:	0a00000e 	beq	57e19bc8 <nand_block_bad+0xcc>
		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos & 0xFE,
57e19b8c:	e5942080 	ldr	r2, [r4, #128]	; 0x80
57e19b90:	e1a00005 	mov	r0, r5
57e19b94:	e3a01050 	mov	r1, #80	; 0x50
57e19b98:	e20220fe 	and	r2, r2, #254	; 0xfe
57e19b9c:	e1a03006 	mov	r3, r6
57e19ba0:	e12fff3c 	blx	ip
			      page);
		bad = cpu_to_le16(chip->read_word(mtd));
57e19ba4:	e594300c 	ldr	r3, [r4, #12]
57e19ba8:	e1a00005 	mov	r0, r5
57e19bac:	e12fff33 	blx	r3
		if (chip->badblockpos & 0x1)
57e19bb0:	e5943080 	ldr	r3, [r4, #128]	; 0x80
57e19bb4:	e3130001 	tst	r3, #1
			bad >>= 8;
57e19bb8:	11a00400 	lslne	r0, r0, #8
57e19bbc:	11a00820 	lsrne	r0, r0, #16
		else
			bad &= 0xFF;
57e19bc0:	020000ff 	andeq	r0, r0, #255	; 0xff
57e19bc4:	ea000007 	b	57e19be8 <nand_block_bad+0xec>
	} else {
		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos, page);
57e19bc8:	e1a00005 	mov	r0, r5
57e19bcc:	e1a03006 	mov	r3, r6
57e19bd0:	e3a01050 	mov	r1, #80	; 0x50
57e19bd4:	e5942080 	ldr	r2, [r4, #128]	; 0x80
57e19bd8:	e12fff3c 	blx	ip
		bad = chip->read_byte(mtd);
57e19bdc:	e5943008 	ldr	r3, [r4, #8]
57e19be0:	e1a00005 	mov	r0, r5
57e19be4:	e12fff33 	blx	r3
	}

	if (likely(chip->badblockbits == 8))
57e19be8:	e5943084 	ldr	r3, [r4, #132]	; 0x84
57e19bec:	e3530008 	cmp	r3, #8
57e19bf0:	1a000002 	bne	57e19c00 <nand_block_bad+0x104>
		res = bad != 0xFF;
57e19bf4:	e25040ff 	subs	r4, r0, #255	; 0xff
57e19bf8:	13a04001 	movne	r4, #1
57e19bfc:	ea00000c 	b	57e19c34 <nand_block_bad+0x138>
	return (res & 0x00FF) + ((res >> 8) & 0x00FF);
}

static inline unsigned int generic_hweight8(unsigned int w)
{
	unsigned int res = (w & 0x55) + ((w >> 1) & 0x55);
57e19c00:	e1a040a0 	lsr	r4, r0, #1
57e19c04:	e2044055 	and	r4, r4, #85	; 0x55
57e19c08:	e2000055 	and	r0, r0, #85	; 0x55
57e19c0c:	e0840000 	add	r0, r4, r0
	res = (res & 0x33) + ((res >> 2) & 0x33);
57e19c10:	e1a04120 	lsr	r4, r0, #2
57e19c14:	e2002033 	and	r2, r0, #51	; 0x33
57e19c18:	e2044033 	and	r4, r4, #51	; 0x33
57e19c1c:	e0844002 	add	r4, r4, r2
	return (res & 0x0F) + ((res >> 4) & 0x0F);
57e19c20:	e204200f 	and	r2, r4, #15
57e19c24:	e0824224 	add	r4, r2, r4, lsr #4
	else
		res = hweight8(bad) < chip->badblockbits;
57e19c28:	e1540003 	cmp	r4, r3
57e19c2c:	23a04000 	movcs	r4, #0
57e19c30:	33a04001 	movcc	r4, #1

	if (getchip)
57e19c34:	e3570000 	cmp	r7, #0
57e19c38:	0a000001 	beq	57e19c44 <nand_block_bad+0x148>
		nand_release_device(mtd);
57e19c3c:	e1a00005 	mov	r0, r5
57e19c40:	ebfffac0 	bl	57e18748 <nand_release_device>

	return res;
}
57e19c44:	e1a00004 	mov	r0, r4
57e19c48:	e8bd8cf8 	pop	{r3, r4, r5, r6, r7, sl, fp, pc}

57e19c4c <nand_fill_oob>:
 * @len:	oob data write length
 * @ops:	oob ops structure
 */
static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,
						struct mtd_oob_ops *ops)
{
57e19c4c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e19c50:	e1a05002 	mov	r5, r2
	switch (ops->mode) {
57e19c54:	e5932000 	ldr	r2, [r3]
 * @len:	oob data write length
 * @ops:	oob ops structure
 */
static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,
						struct mtd_oob_ops *ops)
{
57e19c58:	e1a06000 	mov	r6, r0
	switch (ops->mode) {
57e19c5c:	e3520001 	cmp	r2, #1
 * @len:	oob data write length
 * @ops:	oob ops structure
 */
static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,
						struct mtd_oob_ops *ops)
{
57e19c60:	e1a04001 	mov	r4, r1
	switch (ops->mode) {
57e19c64:	0a00000a 	beq	57e19c94 <nand_fill_oob+0x48>
57e19c68:	3a000001 	bcc	57e19c74 <nand_fill_oob+0x28>
57e19c6c:	e3520002 	cmp	r2, #2
57e19c70:	1a000029 	bne	57e19d1c <nand_fill_oob+0xd0>

	case MTD_OOB_PLACE:
	case MTD_OOB_RAW:
		memcpy(chip->oob_poi + ops->ooboffs, oob, len);
57e19c74:	e5960090 	ldr	r0, [r6, #144]	; 0x90
57e19c78:	e5933014 	ldr	r3, [r3, #20]
57e19c7c:	e1a01004 	mov	r1, r4
57e19c80:	e0800003 	add	r0, r0, r3
57e19c84:	e1a02005 	mov	r2, r5
57e19c88:	eb00299f 	bl	57e2430c <memcpy>
		return oob + len;
57e19c8c:	e0844005 	add	r4, r4, r5
57e19c90:	ea000028 	b	57e19d38 <nand_fill_oob+0xec>
 * @chip:	nand chip structure
 * @oob:	oob data buffer
 * @len:	oob data write length
 * @ops:	oob ops structure
 */
static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,
57e19c94:	e590a0b8 	ldr	sl, [r0, #184]	; 0xb8
		memcpy(chip->oob_poi + ops->ooboffs, oob, len);
		return oob + len;

	case MTD_OOB_AUTO: {
		struct nand_oobfree *free = chip->ecc.layout->oobfree;
		uint32_t boffs = 0, woffs = ops->ooboffs;
57e19c98:	e5933014 	ldr	r3, [r3, #20]
 * @chip:	nand chip structure
 * @oob:	oob data buffer
 * @len:	oob data write length
 * @ops:	oob ops structure
 */
static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,
57e19c9c:	e28aae21 	add	sl, sl, #528	; 0x210
		return oob + len;

	case MTD_OOB_AUTO: {
		struct nand_oobfree *free = chip->ecc.layout->oobfree;
		uint32_t boffs = 0, woffs = ops->ooboffs;
		size_t bytes = 0;
57e19ca0:	e3a07000 	mov	r7, #0

		for (; free->length && len; free++, len -= bytes) {
57e19ca4:	ea000017 	b	57e19d08 <nand_fill_oob+0xbc>
			/* Write request not from offset 0 ? */
			if (unlikely(woffs)) {
57e19ca8:	e3530000 	cmp	r3, #0
57e19cac:	0a000008 	beq	57e19cd4 <nand_fill_oob+0x88>
				if (woffs >= free->length) {
57e19cb0:	e1530002 	cmp	r3, r2
					woffs -= free->length;
57e19cb4:	20623003 	rsbcs	r3, r2, r3
		size_t bytes = 0;

		for (; free->length && len; free++, len -= bytes) {
			/* Write request not from offset 0 ? */
			if (unlikely(woffs)) {
				if (woffs >= free->length) {
57e19cb8:	2a000010 	bcs	57e19d00 <nand_fill_oob+0xb4>
					woffs -= free->length;
					continue;
				}
				boffs = free->offset + woffs;
57e19cbc:	e51a1008 	ldr	r1, [sl, #-8]
				bytes = min_t(size_t, len,
57e19cc0:	e0637002 	rsb	r7, r3, r2
			if (unlikely(woffs)) {
				if (woffs >= free->length) {
					woffs -= free->length;
					continue;
				}
				boffs = free->offset + woffs;
57e19cc4:	e0831001 	add	r1, r3, r1
				bytes = min_t(size_t, len,
57e19cc8:	e1570005 	cmp	r7, r5
57e19ccc:	21a07005 	movcs	r7, r5
57e19cd0:	ea000003 	b	57e19ce4 <nand_fill_oob+0x98>
					      (free->length - woffs));
				woffs = 0;
			} else {
				bytes = min_t(size_t, len, free->length);
				boffs = free->offset;
57e19cd4:	e51a1008 	ldr	r1, [sl, #-8]
				boffs = free->offset + woffs;
				bytes = min_t(size_t, len,
					      (free->length - woffs));
				woffs = 0;
			} else {
				bytes = min_t(size_t, len, free->length);
57e19cd8:	e1550002 	cmp	r5, r2
57e19cdc:	31a07005 	movcc	r7, r5
57e19ce0:	21a07002 	movcs	r7, r2
				boffs = free->offset;
			}
			memcpy(chip->oob_poi + boffs, oob, bytes);
57e19ce4:	e5960090 	ldr	r0, [r6, #144]	; 0x90
57e19ce8:	e1a02007 	mov	r2, r7
57e19cec:	e0800001 	add	r0, r0, r1
57e19cf0:	e1a01004 	mov	r1, r4
57e19cf4:	eb002984 	bl	57e2430c <memcpy>
			oob += bytes;
57e19cf8:	e0844007 	add	r4, r4, r7
57e19cfc:	e3a03000 	mov	r3, #0
	case MTD_OOB_AUTO: {
		struct nand_oobfree *free = chip->ecc.layout->oobfree;
		uint32_t boffs = 0, woffs = ops->ooboffs;
		size_t bytes = 0;

		for (; free->length && len; free++, len -= bytes) {
57e19d00:	e0675005 	rsb	r5, r7, r5
57e19d04:	e28aa008 	add	sl, sl, #8
57e19d08:	e51a2004 	ldr	r2, [sl, #-4]
57e19d0c:	e3550000 	cmp	r5, #0
57e19d10:	13520000 	cmpne	r2, #0
57e19d14:	1affffe3 	bne	57e19ca8 <nand_fill_oob+0x5c>
57e19d18:	ea000006 	b	57e19d38 <nand_fill_oob+0xec>
			oob += bytes;
		}
		return oob;
	}
	default:
		BUG();
57e19d1c:	e59f001c 	ldr	r0, [pc, #28]	; 57e19d40 <nand_fill_oob+0xf4>
57e19d20:	e59f101c 	ldr	r1, [pc, #28]	; 57e19d44 <nand_fill_oob+0xf8>
57e19d24:	e59f201c 	ldr	r2, [pc, #28]	; 57e19d48 <nand_fill_oob+0xfc>
57e19d28:	e59f301c 	ldr	r3, [pc, #28]	; 57e19d4c <nand_fill_oob+0x100>
57e19d2c:	ebffbdc6 	bl	57e0944c <printf>
57e19d30:	e59f0018 	ldr	r0, [pc, #24]	; 57e19d50 <nand_fill_oob+0x104>
57e19d34:	eb002d8c 	bl	57e2536c <panic>
	}
	return NULL;
}
57e19d38:	e1a00004 	mov	r0, r4
57e19d3c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e19d40:	57e33a28 	.word	0x57e33a28
57e19d44:	57e342aa 	.word	0x57e342aa
57e19d48:	0000076e 	.word	0x0000076e
57e19d4c:	57e2cc80 	.word	0x57e2cc80
57e19d50:	57e33a50 	.word	0x57e33a50

57e19d54 <nand_do_write_oob>:
 *
 * NAND write out-of-band
 */
static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
			     struct mtd_oob_ops *ops)
{
57e19d54:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e19d58:	e24dd018 	sub	sp, sp, #24
57e19d5c:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
57e19d60:	e58d300c 	str	r3, [sp, #12]
	struct nand_chip *chip = mtd->priv;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: to = 0x%08x, len = %i\n",
			 __func__, (unsigned int)to, (int)ops->ooblen);

	if (ops->mode == MTD_OOB_AUTO)
57e19d64:	e5963000 	ldr	r3, [r6]
 */
static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
			     struct mtd_oob_ops *ops)
{
	int chipnr, page, status, len;
	struct nand_chip *chip = mtd->priv;
57e19d68:	e5904094 	ldr	r4, [r0, #148]	; 0x94

	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: to = 0x%08x, len = %i\n",
			 __func__, (unsigned int)to, (int)ops->ooblen);

	if (ops->mode == MTD_OOB_AUTO)
57e19d6c:	e3530001 	cmp	r3, #1
		len = chip->ecc.layout->oobavail;
57e19d70:	059430b8 	ldreq	r3, [r4, #184]	; 0xb8
 *
 * NAND write out-of-band
 */
static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
			     struct mtd_oob_ops *ops)
{
57e19d74:	e1a09002 	mov	r9, r2

	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: to = 0x%08x, len = %i\n",
			 __func__, (unsigned int)to, (int)ops->ooblen);

	if (ops->mode == MTD_OOB_AUTO)
		len = chip->ecc.layout->oobavail;
57e19d78:	05937204 	ldreq	r7, [r3, #516]	; 0x204
	else
		len = mtd->oobsize;

	/* Do not allow write past end of page */
	if ((ops->ooboffs + ops->ooblen) > len) {
57e19d7c:	e5962014 	ldr	r2, [r6, #20]
57e19d80:	e596300c 	ldr	r3, [r6, #12]
			 __func__, (unsigned int)to, (int)ops->ooblen);

	if (ops->mode == MTD_OOB_AUTO)
		len = chip->ecc.layout->oobavail;
	else
		len = mtd->oobsize;
57e19d84:	15907018 	ldrne	r7, [r0, #24]

	/* Do not allow write past end of page */
	if ((ops->ooboffs + ops->ooblen) > len) {
57e19d88:	e0823003 	add	r3, r2, r3
57e19d8c:	e1530007 	cmp	r3, r7
 *
 * NAND write out-of-band
 */
static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
			     struct mtd_oob_ops *ops)
{
57e19d90:	e1a05000 	mov	r5, r0
		len = chip->ecc.layout->oobavail;
	else
		len = mtd->oobsize;

	/* Do not allow write past end of page */
	if ((ops->ooboffs + ops->ooblen) > len) {
57e19d94:	8a000059 	bhi	57e19f00 <nand_do_write_oob+0x1ac>
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt to write "
				"past end of page\n", __func__);
		return -EINVAL;
	}

	if (unlikely(ops->ooboffs >= len)) {
57e19d98:	e1520007 	cmp	r2, r7
57e19d9c:	2a000057 	bcs	57e19f00 <nand_do_write_oob+0x1ac>
				"write outside oob\n", __func__);
		return -EINVAL;
	}

	/* Do not allow write past end of device */
	if (unlikely(to >= mtd->size ||
57e19da0:	e595100c 	ldr	r1, [r5, #12]
57e19da4:	e59d200c 	ldr	r2, [sp, #12]
57e19da8:	e5900008 	ldr	r0, [r0, #8]
57e19dac:	e1510002 	cmp	r1, r2
57e19db0:	8a000002 	bhi	57e19dc0 <nand_do_write_oob+0x6c>
57e19db4:	1a000051 	bne	57e19f00 <nand_do_write_oob+0x1ac>
57e19db8:	e1500009 	cmp	r0, r9
57e19dbc:	9a00004f 	bls	57e19f00 <nand_do_write_oob+0x1ac>
57e19dc0:	e594c054 	ldr	ip, [r4, #84]	; 0x54
57e19dc4:	e1a0a007 	mov	sl, r7
57e19dc8:	e1a0bfca 	asr	fp, sl, #31
57e19dcc:	e1a0200c 	mov	r2, ip
57e19dd0:	e58da010 	str	sl, [sp, #16]
57e19dd4:	e58db014 	str	fp, [sp, #20]
57e19dd8:	e98d1008 	stmib	sp, {r3, ip}
57e19ddc:	eb004786 	bl	57e2bbfc <__lshrdi3>
57e19de0:	e59dc008 	ldr	ip, [sp, #8]
57e19de4:	e1a0a000 	mov	sl, r0
57e19de8:	e1a0b001 	mov	fp, r1
57e19dec:	e1a0200c 	mov	r2, ip
57e19df0:	e1a00009 	mov	r0, r9
57e19df4:	e59d100c 	ldr	r1, [sp, #12]
57e19df8:	eb004786 	bl	57e2bc18 <__ashrdi3>
57e19dfc:	e05aa000 	subs	sl, sl, r0
57e19e00:	e0cbb001 	sbc	fp, fp, r1
57e19e04:	e0000b97 	mul	r0, r7, fp
57e19e08:	e59d2014 	ldr	r2, [sp, #20]
57e19e0c:	e59d3004 	ldr	r3, [sp, #4]
57e19e10:	e020029a 	mla	r0, sl, r2, r0
57e19e14:	e0821a97 	umull	r1, r2, r7, sl
57e19e18:	e0802002 	add	r2, r0, r2
57e19e1c:	e3520000 	cmp	r2, #0
57e19e20:	1a000001 	bne	57e19e2c <nand_do_write_oob+0xd8>
57e19e24:	e1530001 	cmp	r3, r1
57e19e28:	8a000034 	bhi	57e19f00 <nand_do_write_oob+0x1ac>
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond "
				"end of device\n", __func__);
		return -EINVAL;
	}

	chipnr = (int)(to >> chip->chip_shift);
57e19e2c:	e5942060 	ldr	r2, [r4, #96]	; 0x60
57e19e30:	e59d100c 	ldr	r1, [sp, #12]
57e19e34:	e1a00009 	mov	r0, r9
57e19e38:	eb004776 	bl	57e2bc18 <__ashrdi3>
	chip->select_chip(mtd, chipnr);
57e19e3c:	e594301c 	ldr	r3, [r4, #28]
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond "
				"end of device\n", __func__);
		return -EINVAL;
	}

	chipnr = (int)(to >> chip->chip_shift);
57e19e40:	e1a01000 	mov	r1, r0
	chip->select_chip(mtd, chipnr);
57e19e44:	e1a00005 	mov	r0, r5
57e19e48:	e12fff33 	blx	r3
	 * Reset the chip. Some chips (like the Toshiba TC5832DC found in one
	 * of my DiskOnChip 2000 test units) will clear the whole data page too
	 * if we don't do this. I have no clue why, but I seem to have 'fixed'
	 * it in the doc2000 driver in August 1999.  dwmw2.
	 */
	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
57e19e4c:	e3e02000 	mvn	r2, #0
57e19e50:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e19e54:	e1a00005 	mov	r0, r5
57e19e58:	e3a010ff 	mov	r1, #255	; 0xff
57e19e5c:	e1a03002 	mov	r3, r2

	chipnr = (int)(to >> chip->chip_shift);
	chip->select_chip(mtd, chipnr);

	/* Shift to get page */
	page = (int)(to >> chip->page_shift);
57e19e60:	e5947054 	ldr	r7, [r4, #84]	; 0x54
	 * Reset the chip. Some chips (like the Toshiba TC5832DC found in one
	 * of my DiskOnChip 2000 test units) will clear the whole data page too
	 * if we don't do this. I have no clue why, but I seem to have 'fixed'
	 * it in the doc2000 driver in August 1999.  dwmw2.
	 */
	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
57e19e64:	e12fff3c 	blx	ip

	/* Check, if it is write protected */
	if (nand_check_wp(mtd))
57e19e68:	e1a00005 	mov	r0, r5
57e19e6c:	ebfffa98 	bl	57e188d4 <nand_check_wp>
57e19e70:	e3500000 	cmp	r0, #0
		return -EROFS;
57e19e74:	13e0701d 	mvnne	r7, #29
	 * it in the doc2000 driver in August 1999.  dwmw2.
	 */
	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);

	/* Check, if it is write protected */
	if (nand_check_wp(mtd))
57e19e78:	1a000021 	bne	57e19f04 <nand_do_write_oob+0x1b0>

	chipnr = (int)(to >> chip->chip_shift);
	chip->select_chip(mtd, chipnr);

	/* Shift to get page */
	page = (int)(to >> chip->page_shift);
57e19e7c:	e1a02007 	mov	r2, r7
57e19e80:	e59d100c 	ldr	r1, [sp, #12]
57e19e84:	e1a00009 	mov	r0, r9
57e19e88:	eb004762 	bl	57e2bc18 <__ashrdi3>
	/* Check, if it is write protected */
	if (nand_check_wp(mtd))
		return -EROFS;

	/* Invalidate the page cache, if we write to the cached page */
	if (page == chip->pagebuf)
57e19e8c:	e5943074 	ldr	r3, [r4, #116]	; 0x74

	chipnr = (int)(to >> chip->chip_shift);
	chip->select_chip(mtd, chipnr);

	/* Shift to get page */
	page = (int)(to >> chip->page_shift);
57e19e90:	e1a07000 	mov	r7, r0
	/* Check, if it is write protected */
	if (nand_check_wp(mtd))
		return -EROFS;

	/* Invalidate the page cache, if we write to the cached page */
	if (page == chip->pagebuf)
57e19e94:	e1500003 	cmp	r0, r3
		chip->pagebuf = -1;
57e19e98:	03e03000 	mvneq	r3, #0
57e19e9c:	05843074 	streq	r3, [r4, #116]	; 0x74

	memset(chip->oob_poi, 0xff, mtd->oobsize);
57e19ea0:	e3a010ff 	mov	r1, #255	; 0xff
57e19ea4:	e5952018 	ldr	r2, [r5, #24]
57e19ea8:	e5940090 	ldr	r0, [r4, #144]	; 0x90
57e19eac:	eb0028f2 	bl	57e2427c <memset>
	nand_fill_oob(chip, ops->oobbuf, ops->ooblen, ops);
57e19eb0:	e596101c 	ldr	r1, [r6, #28]
57e19eb4:	e596200c 	ldr	r2, [r6, #12]
57e19eb8:	e1a03006 	mov	r3, r6
57e19ebc:	e1a00004 	mov	r0, r4
57e19ec0:	ebffff61 	bl	57e19c4c <nand_fill_oob>
	status = chip->ecc.write_oob(mtd, chip, page & chip->pagemask);
57e19ec4:	e5942070 	ldr	r2, [r4, #112]	; 0x70
57e19ec8:	e59430e4 	ldr	r3, [r4, #228]	; 0xe4
57e19ecc:	e0072002 	and	r2, r7, r2
57e19ed0:	e1a01004 	mov	r1, r4
57e19ed4:	e1a00005 	mov	r0, r5
57e19ed8:	e12fff33 	blx	r3
	memset(chip->oob_poi, 0xff, mtd->oobsize);
57e19edc:	e3a010ff 	mov	r1, #255	; 0xff
	if (page == chip->pagebuf)
		chip->pagebuf = -1;

	memset(chip->oob_poi, 0xff, mtd->oobsize);
	nand_fill_oob(chip, ops->oobbuf, ops->ooblen, ops);
	status = chip->ecc.write_oob(mtd, chip, page & chip->pagemask);
57e19ee0:	e1a07000 	mov	r7, r0
	memset(chip->oob_poi, 0xff, mtd->oobsize);
57e19ee4:	e5952018 	ldr	r2, [r5, #24]
57e19ee8:	e5940090 	ldr	r0, [r4, #144]	; 0x90
57e19eec:	eb0028e2 	bl	57e2427c <memset>

	if (status)
57e19ef0:	e3570000 	cmp	r7, #0
		return status;

	ops->oobretlen = ops->ooblen;
57e19ef4:	0596300c 	ldreq	r3, [r6, #12]
57e19ef8:	05863010 	streq	r3, [r6, #16]
57e19efc:	ea000000 	b	57e19f04 <nand_do_write_oob+0x1b0>
		     ops->ooboffs + ops->ooblen >
			((mtd->size >> chip->page_shift) -
			 (to >> chip->page_shift)) * len)) {
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond "
				"end of device\n", __func__);
		return -EINVAL;
57e19f00:	e3e07015 	mvn	r7, #21
		return status;

	ops->oobretlen = ops->ooblen;

	return 0;
}
57e19f04:	e1a00007 	mov	r0, r7
57e19f08:	e28dd018 	add	sp, sp, #24
57e19f0c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e19f10 <nand_do_write_ops>:
 *
 * NAND write with ECC
 */
static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
			     struct mtd_oob_ops *ops)
{
57e19f10:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e19f14:	e24dd038 	sub	sp, sp, #56	; 0x38
57e19f18:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
57e19f1c:	e58d2010 	str	r2, [sp, #16]
57e19f20:	e58d3014 	str	r3, [sp, #20]
	struct nand_chip *chip = mtd->priv;
	uint32_t writelen = ops->len;

	uint32_t oobwritelen = ops->ooblen;
	uint32_t oobmaxlen = ops->mode == MTD_OOB_AUTO ?
				mtd->oobavail : mtd->oobsize;
57e19f24:	e5953000 	ldr	r3, [r5]
 *
 * NAND write with ECC
 */
static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
			     struct mtd_oob_ops *ops)
{
57e19f28:	e1a06000 	mov	r6, r0
	struct nand_chip *chip = mtd->priv;
	uint32_t writelen = ops->len;

	uint32_t oobwritelen = ops->ooblen;
	uint32_t oobmaxlen = ops->mode == MTD_OOB_AUTO ?
				mtd->oobavail : mtd->oobsize;
57e19f2c:	e3530001 	cmp	r3, #1

	uint8_t *oob = ops->oobbuf;
	uint8_t *buf = ops->datbuf;
57e19f30:	e5953018 	ldr	r3, [r5, #24]
	struct nand_chip *chip = mtd->priv;
	uint32_t writelen = ops->len;

	uint32_t oobwritelen = ops->ooblen;
	uint32_t oobmaxlen = ops->mode == MTD_OOB_AUTO ?
				mtd->oobavail : mtd->oobsize;
57e19f34:	0596101c 	ldreq	r1, [r6, #28]
57e19f38:	15962018 	ldrne	r2, [r6, #24]
static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
			     struct mtd_oob_ops *ops)
{
	int chipnr, realpage, page, blockmask, column;
	struct nand_chip *chip = mtd->priv;
	uint32_t writelen = ops->len;
57e19f3c:	e5957004 	ldr	r7, [r5, #4]
 */
static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
			     struct mtd_oob_ops *ops)
{
	int chipnr, realpage, page, blockmask, column;
	struct nand_chip *chip = mtd->priv;
57e19f40:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	uint32_t oobwritelen = ops->ooblen;
	uint32_t oobmaxlen = ops->mode == MTD_OOB_AUTO ?
				mtd->oobavail : mtd->oobsize;

	uint8_t *oob = ops->oobbuf;
	uint8_t *buf = ops->datbuf;
57e19f44:	e58d3024 	str	r3, [sp, #36]	; 0x24
{
	int chipnr, realpage, page, blockmask, column;
	struct nand_chip *chip = mtd->priv;
	uint32_t writelen = ops->len;

	uint32_t oobwritelen = ops->ooblen;
57e19f48:	e595000c 	ldr	r0, [r5, #12]

	uint8_t *oob = ops->oobbuf;
	uint8_t *buf = ops->datbuf;
	int ret, subpage;

	ops->retlen = 0;
57e19f4c:	e3a03000 	mov	r3, #0
	struct nand_chip *chip = mtd->priv;
	uint32_t writelen = ops->len;

	uint32_t oobwritelen = ops->ooblen;
	uint32_t oobmaxlen = ops->mode == MTD_OOB_AUTO ?
				mtd->oobavail : mtd->oobsize;
57e19f50:	058d1030 	streq	r1, [sp, #48]	; 0x30
57e19f54:	158d2030 	strne	r2, [sp, #48]	; 0x30
	uint8_t *oob = ops->oobbuf;
	uint8_t *buf = ops->datbuf;
	int ret, subpage;

	ops->retlen = 0;
	if (!writelen)
57e19f58:	e1570003 	cmp	r7, r3
{
	int chipnr, realpage, page, blockmask, column;
	struct nand_chip *chip = mtd->priv;
	uint32_t writelen = ops->len;

	uint32_t oobwritelen = ops->ooblen;
57e19f5c:	e58d002c 	str	r0, [sp, #44]	; 0x2c
	uint32_t oobmaxlen = ops->mode == MTD_OOB_AUTO ?
				mtd->oobavail : mtd->oobsize;

	uint8_t *oob = ops->oobbuf;
57e19f60:	e595901c 	ldr	r9, [r5, #28]
	uint8_t *buf = ops->datbuf;
	int ret, subpage;

	ops->retlen = 0;
57e19f64:	e5853008 	str	r3, [r5, #8]
	if (!writelen)
		return 0;
57e19f68:	01a00007 	moveq	r0, r7
	uint8_t *oob = ops->oobbuf;
	uint8_t *buf = ops->datbuf;
	int ret, subpage;

	ops->retlen = 0;
	if (!writelen)
57e19f6c:	0a0000c5 	beq	57e1a288 <nand_do_write_ops+0x378>
		return 0;

	column = to & (mtd->writesize - 1);
57e19f70:	e5963014 	ldr	r3, [r6, #20]
	subpage = column || (writelen & (mtd->writesize - 1));
57e19f74:	e59d0010 	ldr	r0, [sp, #16]

	ops->retlen = 0;
	if (!writelen)
		return 0;

	column = to & (mtd->writesize - 1);
57e19f78:	e2433001 	sub	r3, r3, #1
	subpage = column || (writelen & (mtd->writesize - 1));
57e19f7c:	e013b000 	ands	fp, r3, r0
57e19f80:	13a03001 	movne	r3, #1
57e19f84:	1a000002 	bne	57e19f94 <nand_do_write_ops+0x84>
57e19f88:	e1130007 	tst	r3, r7
57e19f8c:	03a03000 	moveq	r3, #0
57e19f90:	13a03001 	movne	r3, #1

	if (subpage && oob)
57e19f94:	e259c000 	subs	ip, r9, #0
57e19f98:	13a0c001 	movne	ip, #1
57e19f9c:	e11c0003 	tst	ip, r3
57e19fa0:	1a0000b7 	bne	57e1a284 <nand_do_write_ops+0x374>
		return -EINVAL;

	chipnr = (int)(to >> chip->chip_shift);
57e19fa4:	e5942060 	ldr	r2, [r4, #96]	; 0x60
57e19fa8:	e28d1010 	add	r1, sp, #16
57e19fac:	e8910003 	ldm	r1, {r0, r1}
57e19fb0:	e58dc00c 	str	ip, [sp, #12]
57e19fb4:	eb004717 	bl	57e2bc18 <__ashrdi3>
57e19fb8:	e58d0020 	str	r0, [sp, #32]
	chip->select_chip(mtd, chipnr);
57e19fbc:	e594301c 	ldr	r3, [r4, #28]
57e19fc0:	e1a00006 	mov	r0, r6
57e19fc4:	e59d1020 	ldr	r1, [sp, #32]
57e19fc8:	e12fff33 	blx	r3

	/* Check, if it is write protected */
	if (nand_check_wp(mtd)) {
57e19fcc:	e1a00006 	mov	r0, r6
57e19fd0:	ebfffa3f 	bl	57e188d4 <nand_check_wp>
57e19fd4:	e3500000 	cmp	r0, #0
57e19fd8:	e59dc00c 	ldr	ip, [sp, #12]
57e19fdc:	0a000003 	beq	57e19ff0 <nand_do_write_ops+0xe0>
		printk (KERN_NOTICE "nand_do_write_ops: Device is write protected\n");
57e19fe0:	e59f02a8 	ldr	r0, [pc, #680]	; 57e1a290 <nand_do_write_ops+0x380>
57e19fe4:	ebffbd18 	bl	57e0944c <printf>
		return -EIO;
57e19fe8:	e3e00004 	mvn	r0, #4
57e19fec:	ea0000a5 	b	57e1a288 <nand_do_write_ops+0x378>
	}

	realpage = (int)(to >> chip->page_shift);
57e19ff0:	e594a054 	ldr	sl, [r4, #84]	; 0x54
	page = realpage & chip->pagemask;
	blockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
57e19ff4:	e5942058 	ldr	r2, [r4, #88]	; 0x58
57e19ff8:	e3e03000 	mvn	r3, #0
57e19ffc:	e06a2002 	rsb	r2, sl, r2
57e1a000:	e1e03213 	mvn	r3, r3, lsl r2
57e1a004:	e58d3034 	str	r3, [sp, #52]	; 0x34

	/* Invalidate the page cache, when we write to the cached page */
	if (to <= (chip->pagebuf << chip->page_shift) &&
57e1a008:	e5943074 	ldr	r3, [r4, #116]	; 0x74
		printk (KERN_NOTICE "nand_do_write_ops: Device is write protected\n");
		return -EIO;
	}

	realpage = (int)(to >> chip->page_shift);
	page = realpage & chip->pagemask;
57e1a00c:	e5941070 	ldr	r1, [r4, #112]	; 0x70
	blockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;

	/* Invalidate the page cache, when we write to the cached page */
	if (to <= (chip->pagebuf << chip->page_shift) &&
57e1a010:	e1a03a13 	lsl	r3, r3, sl
57e1a014:	e59d2014 	ldr	r2, [sp, #20]
		printk (KERN_NOTICE "nand_do_write_ops: Device is write protected\n");
		return -EIO;
	}

	realpage = (int)(to >> chip->page_shift);
	page = realpage & chip->pagemask;
57e1a018:	e58d1028 	str	r1, [sp, #40]	; 0x28
	blockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;

	/* Invalidate the page cache, when we write to the cached page */
	if (to <= (chip->pagebuf << chip->page_shift) &&
57e1a01c:	e1a00003 	mov	r0, r3
57e1a020:	e1a01fc0 	asr	r1, r0, #31
57e1a024:	e1520001 	cmp	r2, r1
57e1a028:	e58d0018 	str	r0, [sp, #24]
57e1a02c:	e58d101c 	str	r1, [sp, #28]
57e1a030:	ca000010 	bgt	57e1a078 <nand_do_write_ops+0x168>
57e1a034:	1a000002 	bne	57e1a044 <nand_do_write_ops+0x134>
57e1a038:	e59d0010 	ldr	r0, [sp, #16]
57e1a03c:	e1500003 	cmp	r0, r3
57e1a040:	8a00000c 	bhi	57e1a078 <nand_do_write_ops+0x168>
	    (chip->pagebuf << chip->page_shift) < (to + ops->len))
57e1a044:	e5950004 	ldr	r0, [r5, #4]
57e1a048:	e28d2010 	add	r2, sp, #16
57e1a04c:	e8920006 	ldm	r2, {r1, r2}
57e1a050:	e0911000 	adds	r1, r1, r0
	realpage = (int)(to >> chip->page_shift);
	page = realpage & chip->pagemask;
	blockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;

	/* Invalidate the page cache, when we write to the cached page */
	if (to <= (chip->pagebuf << chip->page_shift) &&
57e1a054:	e59d001c 	ldr	r0, [sp, #28]
	    (chip->pagebuf << chip->page_shift) < (to + ops->len))
57e1a058:	e2a22000 	adc	r2, r2, #0
	realpage = (int)(to >> chip->page_shift);
	page = realpage & chip->pagemask;
	blockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;

	/* Invalidate the page cache, when we write to the cached page */
	if (to <= (chip->pagebuf << chip->page_shift) &&
57e1a05c:	e1520000 	cmp	r2, r0
57e1a060:	ca000002 	bgt	57e1a070 <nand_do_write_ops+0x160>
57e1a064:	1a000003 	bne	57e1a078 <nand_do_write_ops+0x168>
57e1a068:	e1510003 	cmp	r1, r3
57e1a06c:	9a000001 	bls	57e1a078 <nand_do_write_ops+0x168>
	    (chip->pagebuf << chip->page_shift) < (to + ops->len))
		chip->pagebuf = -1;
57e1a070:	e3e03000 	mvn	r3, #0
57e1a074:	e5843074 	str	r3, [r4, #116]	; 0x74

	/* If we're not given explicit OOB data, let it be 0xFF */
	if (likely(!oob))
57e1a078:	e3590000 	cmp	r9, #0
57e1a07c:	1a000004 	bne	57e1a094 <nand_do_write_ops+0x184>
		memset(chip->oob_poi, 0xff, mtd->oobsize);
57e1a080:	e5940090 	ldr	r0, [r4, #144]	; 0x90
57e1a084:	e3a010ff 	mov	r1, #255	; 0xff
57e1a088:	e5962018 	ldr	r2, [r6, #24]
57e1a08c:	eb00287a 	bl	57e2427c <memset>
57e1a090:	ea000006 	b	57e1a0b0 <nand_do_write_ops+0x1a0>

	/* Don't allow multipage oob writes with offset */
	if (oob && ops->ooboffs && (ops->ooboffs + ops->ooblen > oobmaxlen))
57e1a094:	e35c0000 	cmp	ip, #0
57e1a098:	0a000003 	beq	57e1a0ac <nand_do_write_ops+0x19c>
57e1a09c:	e5953014 	ldr	r3, [r5, #20]
57e1a0a0:	e3530000 	cmp	r3, #0
57e1a0a4:	0a000001 	beq	57e1a0b0 <nand_do_write_ops+0x1a0>
57e1a0a8:	ea00000a 	b	57e1a0d8 <nand_do_write_ops+0x1c8>
57e1a0ac:	e1a0900c 	mov	r9, ip
	if (nand_check_wp(mtd)) {
		printk (KERN_NOTICE "nand_do_write_ops: Device is write protected\n");
		return -EIO;
	}

	realpage = (int)(to >> chip->page_shift);
57e1a0b0:	e28d1010 	add	r1, sp, #16
57e1a0b4:	e8910003 	ldm	r1, {r0, r1}
57e1a0b8:	e1a0200a 	mov	r2, sl
57e1a0bc:	eb0046d5 	bl	57e2bc18 <__ashrdi3>
	page = realpage & chip->pagemask;
57e1a0c0:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
	if (nand_check_wp(mtd)) {
		printk (KERN_NOTICE "nand_do_write_ops: Device is write protected\n");
		return -EIO;
	}

	realpage = (int)(to >> chip->page_shift);
57e1a0c4:	e58d0010 	str	r0, [sp, #16]
	page = realpage & chip->pagemask;
57e1a0c8:	e0001001 	and	r1, r0, r1
57e1a0cc:	e58d1018 	str	r1, [sp, #24]
57e1a0d0:	e1a0a005 	mov	sl, r5
57e1a0d4:	ea000006 	b	57e1a0f4 <nand_do_write_ops+0x1e4>
	/* If we're not given explicit OOB data, let it be 0xFF */
	if (likely(!oob))
		memset(chip->oob_poi, 0xff, mtd->oobsize);

	/* Don't allow multipage oob writes with offset */
	if (oob && ops->ooboffs && (ops->ooboffs + ops->ooblen > oobmaxlen))
57e1a0d8:	e595200c 	ldr	r2, [r5, #12]
57e1a0dc:	e0833002 	add	r3, r3, r2
57e1a0e0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
57e1a0e4:	e1530002 	cmp	r3, r2
57e1a0e8:	9afffff0 	bls	57e1a0b0 <nand_do_write_ops+0x1a0>
57e1a0ec:	ea000064 	b	57e1a284 <nand_do_write_ops+0x374>
57e1a0f0:	e3a0b000 	mov	fp, #0
		return -EINVAL;

	while (1) {
		WATCHDOG_RESET();

		int bytes = mtd->writesize;
57e1a0f4:	e5965014 	ldr	r5, [r6, #20]
		int cached = writelen > bytes && page != blockmask;
		uint8_t *wbuf = buf;

		/* Partial page write ? */
		if (unlikely(column || writelen < (mtd->writesize - 1))) {
57e1a0f8:	e35b0000 	cmp	fp, #0
		return -EINVAL;

	while (1) {
		WATCHDOG_RESET();

		int bytes = mtd->writesize;
57e1a0fc:	e1a02005 	mov	r2, r5
		int cached = writelen > bytes && page != blockmask;
		uint8_t *wbuf = buf;

		/* Partial page write ? */
		if (unlikely(column || writelen < (mtd->writesize - 1))) {
57e1a100:	1a00000b 	bne	57e1a134 <nand_do_write_ops+0x224>
57e1a104:	e2453001 	sub	r3, r5, #1
57e1a108:	e1570003 	cmp	r7, r3
57e1a10c:	3a000008 	bcc	57e1a134 <nand_do_write_ops+0x224>

	while (1) {
		WATCHDOG_RESET();

		int bytes = mtd->writesize;
		int cached = writelen > bytes && page != blockmask;
57e1a110:	e59d3018 	ldr	r3, [sp, #24]
57e1a114:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
		uint8_t *wbuf = buf;
57e1a118:	e59d1024 	ldr	r1, [sp, #36]	; 0x24

	while (1) {
		WATCHDOG_RESET();

		int bytes = mtd->writesize;
		int cached = writelen > bytes && page != blockmask;
57e1a11c:	e1530000 	cmp	r3, r0
57e1a120:	11570005 	cmpne	r7, r5
57e1a124:	93a0c000 	movls	ip, #0
57e1a128:	83a0c001 	movhi	ip, #1
		uint8_t *wbuf = buf;
57e1a12c:	e58d1028 	str	r1, [sp, #40]	; 0x28
57e1a130:	ea000013 	b	57e1a184 <nand_do_write_ops+0x274>
		/* Partial page write ? */
		if (unlikely(column || writelen < (mtd->writesize - 1))) {
			cached = 0;
			bytes = min_t(int, bytes - column, (int) writelen);
			chip->pagebuf = -1;
			memset(chip->buffers->databuf, 0xff, mtd->writesize);
57e1a134:	e59400e8 	ldr	r0, [r4, #232]	; 0xe8

		/* Partial page write ? */
		if (unlikely(column || writelen < (mtd->writesize - 1))) {
			cached = 0;
			bytes = min_t(int, bytes - column, (int) writelen);
			chip->pagebuf = -1;
57e1a138:	e3e03000 	mvn	r3, #0
57e1a13c:	e5843074 	str	r3, [r4, #116]	; 0x74
			memset(chip->buffers->databuf, 0xff, mtd->writesize);
57e1a140:	e3a010ff 	mov	r1, #255	; 0xff
57e1a144:	e2800d12 	add	r0, r0, #1152	; 0x480
57e1a148:	eb00284b 	bl	57e2427c <memset>
			memcpy(&chip->buffers->databuf[column], buf, bytes);
57e1a14c:	e59400e8 	ldr	r0, [r4, #232]	; 0xe8
		uint8_t *wbuf = buf;

		/* Partial page write ? */
		if (unlikely(column || writelen < (mtd->writesize - 1))) {
			cached = 0;
			bytes = min_t(int, bytes - column, (int) writelen);
57e1a150:	e06b5005 	rsb	r5, fp, r5
57e1a154:	e1570005 	cmp	r7, r5
57e1a158:	b1a05007 	movlt	r5, r7
57e1a15c:	a1a05005 	movge	r5, r5
			chip->pagebuf = -1;
			memset(chip->buffers->databuf, 0xff, mtd->writesize);
			memcpy(&chip->buffers->databuf[column], buf, bytes);
57e1a160:	e2800d12 	add	r0, r0, #1152	; 0x480
57e1a164:	e080000b 	add	r0, r0, fp
57e1a168:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
57e1a16c:	e1a02005 	mov	r2, r5
57e1a170:	eb002865 	bl	57e2430c <memcpy>
			wbuf = chip->buffers->databuf;
57e1a174:	e59430e8 	ldr	r3, [r4, #232]	; 0xe8
		int cached = writelen > bytes && page != blockmask;
		uint8_t *wbuf = buf;

		/* Partial page write ? */
		if (unlikely(column || writelen < (mtd->writesize - 1))) {
			cached = 0;
57e1a178:	e3a0c000 	mov	ip, #0
			bytes = min_t(int, bytes - column, (int) writelen);
			chip->pagebuf = -1;
			memset(chip->buffers->databuf, 0xff, mtd->writesize);
			memcpy(&chip->buffers->databuf[column], buf, bytes);
			wbuf = chip->buffers->databuf;
57e1a17c:	e2833d12 	add	r3, r3, #1152	; 0x480
57e1a180:	e58d3028 	str	r3, [sp, #40]	; 0x28
		}

		if (unlikely(oob)) {
57e1a184:	e3590000 	cmp	r9, #0
57e1a188:	0a00000e 	beq	57e1a1c8 <nand_do_write_ops+0x2b8>
			size_t len = min(oobwritelen, oobmaxlen);
57e1a18c:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
57e1a190:	e59db02c 	ldr	fp, [sp, #44]	; 0x2c
			oob = nand_fill_oob(chip, oob, len, ops);
57e1a194:	e1a01009 	mov	r1, r9
			memcpy(&chip->buffers->databuf[column], buf, bytes);
			wbuf = chip->buffers->databuf;
		}

		if (unlikely(oob)) {
			size_t len = min(oobwritelen, oobmaxlen);
57e1a198:	e15b0000 	cmp	fp, r0
57e1a19c:	21a0b000 	movcs	fp, r0
			oob = nand_fill_oob(chip, oob, len, ops);
57e1a1a0:	e1a0200b 	mov	r2, fp
57e1a1a4:	e1a00004 	mov	r0, r4
57e1a1a8:	e1a0300a 	mov	r3, sl
57e1a1ac:	e58dc00c 	str	ip, [sp, #12]
57e1a1b0:	ebfffea5 	bl	57e19c4c <nand_fill_oob>
			oobwritelen -= len;
57e1a1b4:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
57e1a1b8:	e59dc00c 	ldr	ip, [sp, #12]
57e1a1bc:	e06b1001 	rsb	r1, fp, r1
			wbuf = chip->buffers->databuf;
		}

		if (unlikely(oob)) {
			size_t len = min(oobwritelen, oobmaxlen);
			oob = nand_fill_oob(chip, oob, len, ops);
57e1a1c0:	e1a09000 	mov	r9, r0
			oobwritelen -= len;
57e1a1c4:	e58d102c 	str	r1, [sp, #44]	; 0x2c
		}

		ret = chip->write_page(mtd, chip, wbuf, page, cached,
57e1a1c8:	e58dc000 	str	ip, [sp]
57e1a1cc:	e59a3000 	ldr	r3, [sl]
57e1a1d0:	e1a00006 	mov	r0, r6
57e1a1d4:	e3530002 	cmp	r3, #2
57e1a1d8:	13a03000 	movne	r3, #0
57e1a1dc:	03a03001 	moveq	r3, #1
57e1a1e0:	e58d3004 	str	r3, [sp, #4]
57e1a1e4:	e594c048 	ldr	ip, [r4, #72]	; 0x48
57e1a1e8:	e1a01004 	mov	r1, r4
57e1a1ec:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
57e1a1f0:	e59d3018 	ldr	r3, [sp, #24]
57e1a1f4:	e12fff3c 	blx	ip
				       (ops->mode == MTD_OOB_RAW));
		if (ret)
57e1a1f8:	e3500000 	cmp	r0, #0
57e1a1fc:	1a000018 	bne	57e1a264 <nand_do_write_ops+0x354>
			break;

		writelen -= bytes;
		if (!writelen)
57e1a200:	e0577005 	subs	r7, r7, r5
57e1a204:	0a000016 	beq	57e1a264 <nand_do_write_ops+0x354>
			break;

		column = 0;
		buf += bytes;
		realpage++;
57e1a208:	e59d3010 	ldr	r3, [sp, #16]
		writelen -= bytes;
		if (!writelen)
			break;

		column = 0;
		buf += bytes;
57e1a20c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
		realpage++;
57e1a210:	e2833001 	add	r3, r3, #1
57e1a214:	e58d3010 	str	r3, [sp, #16]

		page = realpage & chip->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
57e1a218:	e59d0010 	ldr	r0, [sp, #16]

		column = 0;
		buf += bytes;
		realpage++;

		page = realpage & chip->pagemask;
57e1a21c:	e5943070 	ldr	r3, [r4, #112]	; 0x70
		writelen -= bytes;
		if (!writelen)
			break;

		column = 0;
		buf += bytes;
57e1a220:	e0822005 	add	r2, r2, r5
		realpage++;

		page = realpage & chip->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
57e1a224:	e0103003 	ands	r3, r0, r3
		writelen -= bytes;
		if (!writelen)
			break;

		column = 0;
		buf += bytes;
57e1a228:	e58d2024 	str	r2, [sp, #36]	; 0x24
		realpage++;

		page = realpage & chip->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
57e1a22c:	e58d3018 	str	r3, [sp, #24]
57e1a230:	1affffae 	bne	57e1a0f0 <nand_do_write_ops+0x1e0>
			chipnr++;
57e1a234:	e59d1020 	ldr	r1, [sp, #32]
			chip->select_chip(mtd, -1);
57e1a238:	e594301c 	ldr	r3, [r4, #28]
		realpage++;

		page = realpage & chip->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
			chipnr++;
57e1a23c:	e2811001 	add	r1, r1, #1
57e1a240:	e58d1020 	str	r1, [sp, #32]
			chip->select_chip(mtd, -1);
57e1a244:	e1a00006 	mov	r0, r6
57e1a248:	e3e01000 	mvn	r1, #0
57e1a24c:	e12fff33 	blx	r3
			chip->select_chip(mtd, chipnr);
57e1a250:	e594301c 	ldr	r3, [r4, #28]
57e1a254:	e1a00006 	mov	r0, r6
57e1a258:	e59d1020 	ldr	r1, [sp, #32]
57e1a25c:	e12fff33 	blx	r3
57e1a260:	eaffffa2 	b	57e1a0f0 <nand_do_write_ops+0x1e0>
		}
	}

	ops->retlen = ops->len - writelen;
57e1a264:	e59a3004 	ldr	r3, [sl, #4]
	if (unlikely(oob))
57e1a268:	e3590000 	cmp	r9, #0
			chip->select_chip(mtd, -1);
			chip->select_chip(mtd, chipnr);
		}
	}

	ops->retlen = ops->len - writelen;
57e1a26c:	e0677003 	rsb	r7, r7, r3
	if (unlikely(oob))
		ops->oobretlen = ops->ooblen;
57e1a270:	159a300c 	ldrne	r3, [sl, #12]
57e1a274:	e1a0500a 	mov	r5, sl
			chip->select_chip(mtd, -1);
			chip->select_chip(mtd, chipnr);
		}
	}

	ops->retlen = ops->len - writelen;
57e1a278:	e58a7008 	str	r7, [sl, #8]
	if (unlikely(oob))
		ops->oobretlen = ops->ooblen;
57e1a27c:	158a3010 	strne	r3, [sl, #16]
57e1a280:	ea000000 	b	57e1a288 <nand_do_write_ops+0x378>
	if (likely(!oob))
		memset(chip->oob_poi, 0xff, mtd->oobsize);

	/* Don't allow multipage oob writes with offset */
	if (oob && ops->ooboffs && (ops->ooboffs + ops->ooblen > oobmaxlen))
		return -EINVAL;
57e1a284:	e3e00015 	mvn	r0, #21

	ops->retlen = ops->len - writelen;
	if (unlikely(oob))
		ops->oobretlen = ops->ooblen;
	return ret;
}
57e1a288:	e28dd038 	add	sp, sp, #56	; 0x38
57e1a28c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1a290:	57e342b6 	.word	0x57e342b6

57e1a294 <nand_write_oob>:
 * @to:		offset to write to
 * @ops:	oob operation description structure
 */
static int nand_write_oob(struct mtd_info *mtd, loff_t to,
			  struct mtd_oob_ops *ops)
{
57e1a294:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
57e1a298:	e59d1020 	ldr	r1, [sp, #32]
	struct nand_chip *chip = mtd->priv;
57e1a29c:	e590c094 	ldr	ip, [r0, #148]	; 0x94
 * @to:		offset to write to
 * @ops:	oob operation description structure
 */
static int nand_write_oob(struct mtd_info *mtd, loff_t to,
			  struct mtd_oob_ops *ops)
{
57e1a2a0:	e1a04000 	mov	r4, r0
	struct nand_chip *chip = mtd->priv;
	int ret = -ENOTSUPP;

	ops->retlen = 0;
57e1a2a4:	e3a00000 	mov	r0, #0
57e1a2a8:	e5810008 	str	r0, [r1, #8]

	/* Do not allow writes past end of device */
	if (ops->datbuf && (to + ops->len) > mtd->size) {
57e1a2ac:	e5910018 	ldr	r0, [r1, #24]
57e1a2b0:	e3500000 	cmp	r0, #0
57e1a2b4:	0a000009 	beq	57e1a2e0 <nand_write_oob+0x4c>
57e1a2b8:	e5917004 	ldr	r7, [r1, #4]
57e1a2bc:	e0925007 	adds	r5, r2, r7
57e1a2c0:	e594700c 	ldr	r7, [r4, #12]
57e1a2c4:	e2a36000 	adc	r6, r3, #0
57e1a2c8:	e1570006 	cmp	r7, r6
57e1a2cc:	3a000016 	bcc	57e1a32c <nand_write_oob+0x98>
57e1a2d0:	1a000002 	bne	57e1a2e0 <nand_write_oob+0x4c>
57e1a2d4:	e5947008 	ldr	r7, [r4, #8]
57e1a2d8:	e1570005 	cmp	r7, r5
57e1a2dc:	3a000012 	bcc	57e1a32c <nand_write_oob+0x98>
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e1a2e0:	e3a0e002 	mov	lr, #2
57e1a2e4:	e58ce08c 	str	lr, [ip, #140]	; 0x8c
		return -EINVAL;
	}

	nand_get_device(chip, mtd, FL_WRITING);

	switch (ops->mode) {
57e1a2e8:	e591c000 	ldr	ip, [r1]
57e1a2ec:	e15c000e 	cmp	ip, lr
 */
static int nand_write_oob(struct mtd_info *mtd, loff_t to,
			  struct mtd_oob_ops *ops)
{
	struct nand_chip *chip = mtd->priv;
	int ret = -ENOTSUPP;
57e1a2f0:	859f5040 	ldrhi	r5, [pc, #64]	; 57e1a338 <nand_write_oob+0xa4>
		return -EINVAL;
	}

	nand_get_device(chip, mtd, FL_WRITING);

	switch (ops->mode) {
57e1a2f4:	8a000009 	bhi	57e1a320 <nand_write_oob+0x8c>

	default:
		goto out;
	}

	if (!ops->datbuf)
57e1a2f8:	e3500000 	cmp	r0, #0
57e1a2fc:	1a000003 	bne	57e1a310 <nand_write_oob+0x7c>
		ret = nand_do_write_oob(mtd, to, ops);
57e1a300:	e1a00004 	mov	r0, r4
57e1a304:	e58d1000 	str	r1, [sp]
57e1a308:	ebfffe91 	bl	57e19d54 <nand_do_write_oob>
57e1a30c:	ea000002 	b	57e1a31c <nand_write_oob+0x88>
	else
		ret = nand_do_write_ops(mtd, to, ops);
57e1a310:	e1a00004 	mov	r0, r4
57e1a314:	e58d1000 	str	r1, [sp]
57e1a318:	ebfffefc 	bl	57e19f10 <nand_do_write_ops>
57e1a31c:	e1a05000 	mov	r5, r0

out:
	nand_release_device(mtd);
57e1a320:	e1a00004 	mov	r0, r4
57e1a324:	ebfff907 	bl	57e18748 <nand_release_device>
	return ret;
57e1a328:	ea000000 	b	57e1a330 <nand_write_oob+0x9c>

	/* Do not allow writes past end of device */
	if (ops->datbuf && (to + ops->len) > mtd->size) {
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond "
				"end of device\n", __func__);
		return -EINVAL;
57e1a32c:	e3e05015 	mvn	r5, #21
		ret = nand_do_write_ops(mtd, to, ops);

out:
	nand_release_device(mtd);
	return ret;
}
57e1a330:	e1a00005 	mov	r0, r5
57e1a334:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
57e1a338:	fffffdf4 	.word	0xfffffdf4

57e1a33c <nand_write>:
 *
 * NAND write with ECC
 */
static int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
			  size_t *retlen, const uint8_t *buf)
{
57e1a33c:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
57e1a340:	e59d6018 	ldr	r6, [sp, #24]
57e1a344:	e1a05000 	mov	r5, r0
	struct nand_chip *chip = mtd->priv;
57e1a348:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int ret;

	/* Do not allow writes past end of device */
	if ((to + len) > mtd->size)
57e1a34c:	e595c00c 	ldr	ip, [r5, #12]
57e1a350:	e0920006 	adds	r0, r2, r6
57e1a354:	e2a31000 	adc	r1, r3, #0
57e1a358:	e15c0001 	cmp	ip, r1
57e1a35c:	3a000017 	bcc	57e1a3c0 <nand_write+0x84>
57e1a360:	1a000002 	bne	57e1a370 <nand_write+0x34>
57e1a364:	e595c008 	ldr	ip, [r5, #8]
57e1a368:	e15c0000 	cmp	ip, r0
57e1a36c:	3a000013 	bcc	57e1a3c0 <nand_write+0x84>
		return -EINVAL;
	if (!len)
57e1a370:	e3560000 	cmp	r6, #0
57e1a374:	0a000012 	beq	57e1a3c4 <nand_write+0x88>
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e1a378:	e3a01002 	mov	r1, #2
57e1a37c:	e584108c 	str	r1, [r4, #140]	; 0x8c
		return 0;

	nand_get_device(chip, mtd, FL_WRITING);

	chip->ops.len = len;
	chip->ops.datbuf = (uint8_t *)buf;
57e1a380:	e59d1020 	ldr	r1, [sp, #32]
	if (!len)
		return 0;

	nand_get_device(chip, mtd, FL_WRITING);

	chip->ops.len = len;
57e1a384:	e58460f4 	str	r6, [r4, #244]	; 0xf4
	chip->ops.datbuf = (uint8_t *)buf;
57e1a388:	e5841108 	str	r1, [r4, #264]	; 0x108
	chip->ops.oobbuf = NULL;
57e1a38c:	e3a01000 	mov	r1, #0
57e1a390:	e584110c 	str	r1, [r4, #268]	; 0x10c

	ret = nand_do_write_ops(mtd, to, &chip->ops);
57e1a394:	e1a00005 	mov	r0, r5
57e1a398:	e28410f0 	add	r1, r4, #240	; 0xf0
57e1a39c:	e58d1000 	str	r1, [sp]
57e1a3a0:	ebfffeda 	bl	57e19f10 <nand_do_write_ops>

	*retlen = chip->ops.retlen;
57e1a3a4:	e59420f8 	ldr	r2, [r4, #248]	; 0xf8
57e1a3a8:	e59d301c 	ldr	r3, [sp, #28]

	chip->ops.len = len;
	chip->ops.datbuf = (uint8_t *)buf;
	chip->ops.oobbuf = NULL;

	ret = nand_do_write_ops(mtd, to, &chip->ops);
57e1a3ac:	e1a06000 	mov	r6, r0

	*retlen = chip->ops.retlen;
57e1a3b0:	e5832000 	str	r2, [r3]

	nand_release_device(mtd);
57e1a3b4:	e1a00005 	mov	r0, r5
57e1a3b8:	ebfff8e2 	bl	57e18748 <nand_release_device>

	return ret;
57e1a3bc:	ea000000 	b	57e1a3c4 <nand_write+0x88>
	struct nand_chip *chip = mtd->priv;
	int ret;

	/* Do not allow writes past end of device */
	if ((to + len) > mtd->size)
		return -EINVAL;
57e1a3c0:	e3e06015 	mvn	r6, #21
	*retlen = chip->ops.retlen;

	nand_release_device(mtd);

	return ret;
}
57e1a3c4:	e1a00006 	mov	r0, r6
57e1a3c8:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}

57e1a3cc <nand_transfer_oob>:
 * @ops:	oob ops structure
 * @len:	size of oob to transfer
 */
static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
				  struct mtd_oob_ops *ops, size_t len)
{
57e1a3cc:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e1a3d0:	e1a06003 	mov	r6, r3
	switch (ops->mode) {
57e1a3d4:	e5923000 	ldr	r3, [r2]
 * @ops:	oob ops structure
 * @len:	size of oob to transfer
 */
static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
				  struct mtd_oob_ops *ops, size_t len)
{
57e1a3d8:	e1a05000 	mov	r5, r0
	switch (ops->mode) {
57e1a3dc:	e3530001 	cmp	r3, #1
 * @ops:	oob ops structure
 * @len:	size of oob to transfer
 */
static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
				  struct mtd_oob_ops *ops, size_t len)
{
57e1a3e0:	e1a04001 	mov	r4, r1
	switch (ops->mode) {
57e1a3e4:	0a00000a 	beq	57e1a414 <nand_transfer_oob+0x48>
57e1a3e8:	3a000001 	bcc	57e1a3f4 <nand_transfer_oob+0x28>
57e1a3ec:	e3530002 	cmp	r3, #2
57e1a3f0:	1a000029 	bne	57e1a49c <nand_transfer_oob+0xd0>

	case MTD_OOB_PLACE:
	case MTD_OOB_RAW:
		memcpy(oob, chip->oob_poi + ops->ooboffs, len);
57e1a3f4:	e5923014 	ldr	r3, [r2, #20]
57e1a3f8:	e5951090 	ldr	r1, [r5, #144]	; 0x90
57e1a3fc:	e1a00004 	mov	r0, r4
57e1a400:	e0811003 	add	r1, r1, r3
57e1a404:	e1a02006 	mov	r2, r6
57e1a408:	eb0027bf 	bl	57e2430c <memcpy>
		return oob + len;
57e1a40c:	e0844006 	add	r4, r4, r6
57e1a410:	ea000028 	b	57e1a4b8 <nand_transfer_oob+0xec>
 * @chip:	nand chip structure
 * @oob:	oob destination address
 * @ops:	oob ops structure
 * @len:	size of oob to transfer
 */
static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
57e1a414:	e590a0b8 	ldr	sl, [r0, #184]	; 0xb8
		memcpy(oob, chip->oob_poi + ops->ooboffs, len);
		return oob + len;

	case MTD_OOB_AUTO: {
		struct nand_oobfree *free = chip->ecc.layout->oobfree;
		uint32_t boffs = 0, roffs = ops->ooboffs;
57e1a418:	e5923014 	ldr	r3, [r2, #20]
 * @chip:	nand chip structure
 * @oob:	oob destination address
 * @ops:	oob ops structure
 * @len:	size of oob to transfer
 */
static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
57e1a41c:	e28aae21 	add	sl, sl, #528	; 0x210
		return oob + len;

	case MTD_OOB_AUTO: {
		struct nand_oobfree *free = chip->ecc.layout->oobfree;
		uint32_t boffs = 0, roffs = ops->ooboffs;
		size_t bytes = 0;
57e1a420:	e3a07000 	mov	r7, #0

		for (; free->length && len; free++, len -= bytes) {
57e1a424:	ea000017 	b	57e1a488 <nand_transfer_oob+0xbc>
			/* Read request not from offset 0 ? */
			if (unlikely(roffs)) {
57e1a428:	e3530000 	cmp	r3, #0
57e1a42c:	0a000008 	beq	57e1a454 <nand_transfer_oob+0x88>
				if (roffs >= free->length) {
57e1a430:	e1530002 	cmp	r3, r2
					roffs -= free->length;
57e1a434:	20623003 	rsbcs	r3, r2, r3
		size_t bytes = 0;

		for (; free->length && len; free++, len -= bytes) {
			/* Read request not from offset 0 ? */
			if (unlikely(roffs)) {
				if (roffs >= free->length) {
57e1a438:	2a000010 	bcs	57e1a480 <nand_transfer_oob+0xb4>
					roffs -= free->length;
					continue;
				}
				boffs = free->offset + roffs;
57e1a43c:	e51a1008 	ldr	r1, [sl, #-8]
				bytes = min_t(size_t, len,
57e1a440:	e0637002 	rsb	r7, r3, r2
			if (unlikely(roffs)) {
				if (roffs >= free->length) {
					roffs -= free->length;
					continue;
				}
				boffs = free->offset + roffs;
57e1a444:	e0831001 	add	r1, r3, r1
				bytes = min_t(size_t, len,
57e1a448:	e1570006 	cmp	r7, r6
57e1a44c:	21a07006 	movcs	r7, r6
57e1a450:	ea000003 	b	57e1a464 <nand_transfer_oob+0x98>
					      (free->length - roffs));
				roffs = 0;
			} else {
				bytes = min_t(size_t, len, free->length);
				boffs = free->offset;
57e1a454:	e51a1008 	ldr	r1, [sl, #-8]
				boffs = free->offset + roffs;
				bytes = min_t(size_t, len,
					      (free->length - roffs));
				roffs = 0;
			} else {
				bytes = min_t(size_t, len, free->length);
57e1a458:	e1560002 	cmp	r6, r2
57e1a45c:	31a07006 	movcc	r7, r6
57e1a460:	21a07002 	movcs	r7, r2
				boffs = free->offset;
			}
			memcpy(oob, chip->oob_poi + boffs, bytes);
57e1a464:	e5953090 	ldr	r3, [r5, #144]	; 0x90
57e1a468:	e1a00004 	mov	r0, r4
57e1a46c:	e0831001 	add	r1, r3, r1
57e1a470:	e1a02007 	mov	r2, r7
57e1a474:	eb0027a4 	bl	57e2430c <memcpy>
			oob += bytes;
57e1a478:	e0844007 	add	r4, r4, r7
57e1a47c:	e3a03000 	mov	r3, #0
	case MTD_OOB_AUTO: {
		struct nand_oobfree *free = chip->ecc.layout->oobfree;
		uint32_t boffs = 0, roffs = ops->ooboffs;
		size_t bytes = 0;

		for (; free->length && len; free++, len -= bytes) {
57e1a480:	e0676006 	rsb	r6, r7, r6
57e1a484:	e28aa008 	add	sl, sl, #8
57e1a488:	e51a2004 	ldr	r2, [sl, #-4]
57e1a48c:	e3560000 	cmp	r6, #0
57e1a490:	13520000 	cmpne	r2, #0
57e1a494:	1affffe3 	bne	57e1a428 <nand_transfer_oob+0x5c>
57e1a498:	ea000006 	b	57e1a4b8 <nand_transfer_oob+0xec>
			oob += bytes;
		}
		return oob;
	}
	default:
		BUG();
57e1a49c:	e59f001c 	ldr	r0, [pc, #28]	; 57e1a4c0 <nand_transfer_oob+0xf4>
57e1a4a0:	e59f101c 	ldr	r1, [pc, #28]	; 57e1a4c4 <nand_transfer_oob+0xf8>
57e1a4a4:	e59f201c 	ldr	r2, [pc, #28]	; 57e1a4c8 <nand_transfer_oob+0xfc>
57e1a4a8:	e59f301c 	ldr	r3, [pc, #28]	; 57e1a4cc <nand_transfer_oob+0x100>
57e1a4ac:	ebffbbe6 	bl	57e0944c <printf>
57e1a4b0:	e59f0018 	ldr	r0, [pc, #24]	; 57e1a4d0 <nand_transfer_oob+0x104>
57e1a4b4:	eb002bac 	bl	57e2536c <panic>
	}
	return NULL;
}
57e1a4b8:	e1a00004 	mov	r0, r4
57e1a4bc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e1a4c0:	57e33a28 	.word	0x57e33a28
57e1a4c4:	57e342aa 	.word	0x57e342aa
57e1a4c8:	000004a2 	.word	0x000004a2
57e1a4cc:	57e2cc90 	.word	0x57e2cc90
57e1a4d0:	57e33a50 	.word	0x57e33a50

57e1a4d4 <nand_default_block_markbad>:
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
*/
static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
57e1a4d4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1a4d8:	e1a07003 	mov	r7, r3
57e1a4dc:	e24dd018 	sub	sp, sp, #24
	struct nand_chip *chip = mtd->priv;
	uint8_t buf[2] = { 0, 0 };
57e1a4e0:	e3a03000 	mov	r3, #0
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
*/
static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct nand_chip *chip = mtd->priv;
57e1a4e4:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	uint8_t buf[2] = { 0, 0 };
57e1a4e8:	e5cd3014 	strb	r3, [sp, #20]
57e1a4ec:	e5cd3015 	strb	r3, [sp, #21]
	int block, ret, i = 0;

	if (chip->options & NAND_BBT_SCANLASTPAGE)
57e1a4f0:	e5943050 	ldr	r3, [r4, #80]	; 0x50
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
*/
static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
57e1a4f4:	e1a05000 	mov	r5, r0
	struct nand_chip *chip = mtd->priv;
	uint8_t buf[2] = { 0, 0 };
	int block, ret, i = 0;

	if (chip->options & NAND_BBT_SCANLASTPAGE)
57e1a4f8:	e3130902 	tst	r3, #32768	; 0x8000
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
*/
static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
57e1a4fc:	e1a06002 	mov	r6, r2
	struct nand_chip *chip = mtd->priv;
	uint8_t buf[2] = { 0, 0 };
	int block, ret, i = 0;

	if (chip->options & NAND_BBT_SCANLASTPAGE)
57e1a500:	0a000004 	beq	57e1a518 <nand_default_block_markbad+0x44>
		ofs += mtd->erasesize - mtd->writesize;
57e1a504:	e5902010 	ldr	r2, [r0, #16]
57e1a508:	e5903014 	ldr	r3, [r0, #20]
57e1a50c:	e0633002 	rsb	r3, r3, r2
57e1a510:	e0966003 	adds	r6, r6, r3
57e1a514:	e2a77000 	adc	r7, r7, #0

	/* Get block number */
	block = (int)(ofs >> chip->bbt_erase_shift);
	if (chip->bbt)
57e1a518:	e594a110 	ldr	sl, [r4, #272]	; 0x110

	if (chip->options & NAND_BBT_SCANLASTPAGE)
		ofs += mtd->erasesize - mtd->writesize;

	/* Get block number */
	block = (int)(ofs >> chip->bbt_erase_shift);
57e1a51c:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
	if (chip->bbt)
57e1a520:	e35a0000 	cmp	sl, #0
57e1a524:	0a000008 	beq	57e1a54c <nand_default_block_markbad+0x78>

	if (chip->options & NAND_BBT_SCANLASTPAGE)
		ofs += mtd->erasesize - mtd->writesize;

	/* Get block number */
	block = (int)(ofs >> chip->bbt_erase_shift);
57e1a528:	e1a00006 	mov	r0, r6
57e1a52c:	e1a01007 	mov	r1, r7
57e1a530:	eb0045b8 	bl	57e2bc18 <__ashrdi3>
	if (chip->bbt)
		chip->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
57e1a534:	e7da2140 	ldrb	r2, [sl, r0, asr #2]
57e1a538:	e2003003 	and	r3, r0, #3
57e1a53c:	e1a03083 	lsl	r3, r3, #1
57e1a540:	e3a01001 	mov	r1, #1
57e1a544:	e1823311 	orr	r3, r2, r1, lsl r3
57e1a548:	e7ca3140 	strb	r3, [sl, r0, asr #2]

	/* Do we have a flash based bad block table ? */
	if (chip->options & NAND_USE_FLASH_BBT)
57e1a54c:	e594a050 	ldr	sl, [r4, #80]	; 0x50
57e1a550:	e21aa801 	ands	sl, sl, #65536	; 0x10000
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e1a554:	03a09002 	moveq	r9, #2
57e1a558:	0584908c 	streq	r9, [r4, #140]	; 0x8c
			chip->ops.len = chip->ops.ooblen = 2;
			chip->ops.datbuf = NULL;
			chip->ops.oobbuf = buf;
			chip->ops.ooboffs = chip->badblockpos & ~0x01;

			ret = nand_do_write_oob(mtd, ofs, &chip->ops);
57e1a55c:	0284b0f0 	addeq	fp, r4, #240	; 0xf0
	block = (int)(ofs >> chip->bbt_erase_shift);
	if (chip->bbt)
		chip->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);

	/* Do we have a flash based bad block table ? */
	if (chip->options & NAND_USE_FLASH_BBT)
57e1a560:	0a000005 	beq	57e1a57c <nand_default_block_markbad+0xa8>
		ret = nand_update_bbt(mtd, ofs);
57e1a564:	e1a03007 	mov	r3, r7
57e1a568:	e1a00005 	mov	r0, r5
57e1a56c:	e1a02006 	mov	r2, r6
57e1a570:	ebfff396 	bl	57e173d0 <nand_update_bbt>
57e1a574:	e1a03000 	mov	r3, r0
57e1a578:	ea00002e 	b	57e1a638 <nand_default_block_markbad+0x164>
		 * encountered quits the procedure. We write two bytes per
		 * location, so we dont have to mess with 16 bit access.
		 */
		do {
			chip->ops.len = chip->ops.ooblen = 2;
			chip->ops.datbuf = NULL;
57e1a57c:	e3a03000 	mov	r3, #0
57e1a580:	e5843108 	str	r3, [r4, #264]	; 0x108
			chip->ops.oobbuf = buf;
57e1a584:	e28d3014 	add	r3, sp, #20
57e1a588:	e584310c 	str	r3, [r4, #268]	; 0x10c
			chip->ops.ooboffs = chip->badblockpos & ~0x01;
57e1a58c:	e5943080 	ldr	r3, [r4, #128]	; 0x80
		 * If we write to more than one location, the first error
		 * encountered quits the procedure. We write two bytes per
		 * location, so we dont have to mess with 16 bit access.
		 */
		do {
			chip->ops.len = chip->ops.ooblen = 2;
57e1a590:	e58490fc 	str	r9, [r4, #252]	; 0xfc
			chip->ops.datbuf = NULL;
			chip->ops.oobbuf = buf;
			chip->ops.ooboffs = chip->badblockpos & ~0x01;
57e1a594:	e3c33001 	bic	r3, r3, #1
57e1a598:	e5843104 	str	r3, [r4, #260]	; 0x104
		 * If we write to more than one location, the first error
		 * encountered quits the procedure. We write two bytes per
		 * location, so we dont have to mess with 16 bit access.
		 */
		do {
			chip->ops.len = chip->ops.ooblen = 2;
57e1a59c:	e58490f4 	str	r9, [r4, #244]	; 0xf4
			chip->ops.datbuf = NULL;
			chip->ops.oobbuf = buf;
			chip->ops.ooboffs = chip->badblockpos & ~0x01;

			ret = nand_do_write_oob(mtd, ofs, &chip->ops);
57e1a5a0:	e1a00005 	mov	r0, r5
57e1a5a4:	e1a02006 	mov	r2, r6
57e1a5a8:	e1a03007 	mov	r3, r7
57e1a5ac:	e58db000 	str	fp, [sp]
57e1a5b0:	ebfffde7 	bl	57e19d54 <nand_do_write_oob>

			if (!ret && (chip->options & NAND_BBT_SCANBYTE1AND6)) {
57e1a5b4:	e3500000 	cmp	r0, #0
57e1a5b8:	1a000009 	bne	57e1a5e4 <nand_default_block_markbad+0x110>
57e1a5bc:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1a5c0:	e3130601 	tst	r3, #1048576	; 0x100000
57e1a5c4:	0a000006 	beq	57e1a5e4 <nand_default_block_markbad+0x110>
				chip->ops.ooboffs = NAND_SMALL_BADBLOCK_POS
57e1a5c8:	e3a03004 	mov	r3, #4
57e1a5cc:	e5843104 	str	r3, [r4, #260]	; 0x104
					& ~0x01;
				ret = nand_do_write_oob(mtd, ofs, &chip->ops);
57e1a5d0:	e1a00005 	mov	r0, r5
57e1a5d4:	e1a02006 	mov	r2, r6
57e1a5d8:	e1a03007 	mov	r3, r7
57e1a5dc:	e58db000 	str	fp, [sp]
57e1a5e0:	ebfffddb 	bl	57e19d54 <nand_do_write_oob>
			}
			i++;
			ofs += mtd->writesize;
		} while (!ret && (chip->options & NAND_BBT_SCAN2NDPAGE) &&
				i < 2);
57e1a5e4:	e3500000 	cmp	r0, #0
				chip->ops.ooboffs = NAND_SMALL_BADBLOCK_POS
					& ~0x01;
				ret = nand_do_write_oob(mtd, ofs, &chip->ops);
			}
			i++;
			ofs += mtd->writesize;
57e1a5e8:	e5953014 	ldr	r3, [r5, #20]
		} while (!ret && (chip->options & NAND_BBT_SCAN2NDPAGE) &&
				i < 2);
57e1a5ec:	1a00000c 	bne	57e1a624 <nand_default_block_markbad+0x150>
					& ~0x01;
				ret = nand_do_write_oob(mtd, ofs, &chip->ops);
			}
			i++;
			ofs += mtd->writesize;
		} while (!ret && (chip->options & NAND_BBT_SCAN2NDPAGE) &&
57e1a5f0:	e5942050 	ldr	r2, [r4, #80]	; 0x50
			if (!ret && (chip->options & NAND_BBT_SCANBYTE1AND6)) {
				chip->ops.ooboffs = NAND_SMALL_BADBLOCK_POS
					& ~0x01;
				ret = nand_do_write_oob(mtd, ofs, &chip->ops);
			}
			i++;
57e1a5f4:	e28aa001 	add	sl, sl, #1
			ofs += mtd->writesize;
		} while (!ret && (chip->options & NAND_BBT_SCAN2NDPAGE) &&
57e1a5f8:	e3120901 	tst	r2, #16384	; 0x4000
57e1a5fc:	03a02000 	moveq	r2, #0
57e1a600:	13a02001 	movne	r2, #1
57e1a604:	e35a0001 	cmp	sl, #1
57e1a608:	c3a02000 	movgt	r2, #0
57e1a60c:	d2022001 	andle	r2, r2, #1
57e1a610:	e3520000 	cmp	r2, #0
57e1a614:	0a000002 	beq	57e1a624 <nand_default_block_markbad+0x150>
				chip->ops.ooboffs = NAND_SMALL_BADBLOCK_POS
					& ~0x01;
				ret = nand_do_write_oob(mtd, ofs, &chip->ops);
			}
			i++;
			ofs += mtd->writesize;
57e1a618:	e0966003 	adds	r6, r6, r3
57e1a61c:	e2a77000 	adc	r7, r7, #0
57e1a620:	eaffffd5 	b	57e1a57c <nand_default_block_markbad+0xa8>
57e1a624:	e1a03000 	mov	r3, r0
		} while (!ret && (chip->options & NAND_BBT_SCAN2NDPAGE) &&
				i < 2);

		nand_release_device(mtd);
57e1a628:	e1a00005 	mov	r0, r5
57e1a62c:	e58d300c 	str	r3, [sp, #12]
57e1a630:	ebfff844 	bl	57e18748 <nand_release_device>
57e1a634:	e59d300c 	ldr	r3, [sp, #12]
	}
	if (!ret)
57e1a638:	e3530000 	cmp	r3, #0
		mtd->ecc_stats.badblocks++;
57e1a63c:	05952088 	ldreq	r2, [r5, #136]	; 0x88

	return ret;
}
57e1a640:	e1a00003 	mov	r0, r3
				i < 2);

		nand_release_device(mtd);
	}
	if (!ret)
		mtd->ecc_stats.badblocks++;
57e1a644:	02822001 	addeq	r2, r2, #1
57e1a648:	05852088 	streq	r2, [r5, #136]	; 0x88

	return ret;
}
57e1a64c:	e28dd018 	add	sp, sp, #24
57e1a650:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e1a654 <nand_wait>:
 * Wait for command done. This applies to erase and program only
 * Erase can take up to 400ms and program up to 20ms according to
 * general NAND and SmartMedia specs
 */
static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
{
57e1a654:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	unsigned long	timeo;
	int state = chip->state;
	u32 time_start;

	if (state == FL_ERASING)
57e1a658:	e591308c 	ldr	r3, [r1, #140]	; 0x8c
 * Wait for command done. This applies to erase and program only
 * Erase can take up to 400ms and program up to 20ms according to
 * general NAND and SmartMedia specs
 */
static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
{
57e1a65c:	e1a05000 	mov	r5, r0
	unsigned long	timeo;
	int state = chip->state;
	u32 time_start;

	if (state == FL_ERASING)
57e1a660:	e3530003 	cmp	r3, #3
 * Wait for command done. This applies to erase and program only
 * Erase can take up to 400ms and program up to 20ms according to
 * general NAND and SmartMedia specs
 */
static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
{
57e1a664:	e1a04001 	mov	r4, r1
	u32 time_start;

	if (state == FL_ERASING)
		timeo = (CONFIG_SYS_HZ * 400) / 1000;
	else
		timeo = (CONFIG_SYS_HZ * 20) / 1000;
57e1a668:	13a06014 	movne	r6, #20
{
	unsigned long	timeo;
	int state = chip->state;
	u32 time_start;

	if (state == FL_ERASING)
57e1a66c:	1a00000a 	bne	57e1a69c <nand_wait+0x48>
		timeo = (CONFIG_SYS_HZ * 400) / 1000;
	else
		timeo = (CONFIG_SYS_HZ * 20) / 1000;

	if ((state == FL_ERASING) && (chip->options & NAND_IS_AND))
57e1a670:	e5913050 	ldr	r3, [r1, #80]	; 0x50
57e1a674:	e3130020 	tst	r3, #32
	unsigned long	timeo;
	int state = chip->state;
	u32 time_start;

	if (state == FL_ERASING)
		timeo = (CONFIG_SYS_HZ * 400) / 1000;
57e1a678:	03a06e19 	moveq	r6, #400	; 0x190
	else
		timeo = (CONFIG_SYS_HZ * 20) / 1000;

	if ((state == FL_ERASING) && (chip->options & NAND_IS_AND))
57e1a67c:	0a000006 	beq	57e1a69c <nand_wait+0x48>
		chip->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
57e1a680:	e3e02000 	mvn	r2, #0
57e1a684:	e591c034 	ldr	ip, [r1, #52]	; 0x34
57e1a688:	e1a03002 	mov	r3, r2
57e1a68c:	e3a01071 	mov	r1, #113	; 0x71
57e1a690:	e12fff3c 	blx	ip
	unsigned long	timeo;
	int state = chip->state;
	u32 time_start;

	if (state == FL_ERASING)
		timeo = (CONFIG_SYS_HZ * 400) / 1000;
57e1a694:	e3a06e19 	mov	r6, #400	; 0x190
	else
		timeo = (CONFIG_SYS_HZ * 20) / 1000;

	if ((state == FL_ERASING) && (chip->options & NAND_IS_AND))
		chip->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
57e1a698:	ea000005 	b	57e1a6b4 <nand_wait+0x60>
	else
		chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
57e1a69c:	e3e02000 	mvn	r2, #0
57e1a6a0:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1a6a4:	e1a00005 	mov	r0, r5
57e1a6a8:	e3a01070 	mov	r1, #112	; 0x70
57e1a6ac:	e1a03002 	mov	r3, r2
57e1a6b0:	e12fff3c 	blx	ip

	time_start = get_timer(0);
57e1a6b4:	e3a00000 	mov	r0, #0
57e1a6b8:	ebff9913 	bl	57e00b0c <get_timer>
57e1a6bc:	e1a07000 	mov	r7, r0

	while (1) {
		if (get_timer(time_start) > timeo) {
57e1a6c0:	e1a00007 	mov	r0, r7
57e1a6c4:	ebff9910 	bl	57e00b0c <get_timer>
57e1a6c8:	e1500006 	cmp	r0, r6
57e1a6cc:	9a000003 	bls	57e1a6e0 <nand_wait+0x8c>
			printf("Timeout!");
57e1a6d0:	e59f004c 	ldr	r0, [pc, #76]	; 57e1a724 <nand_wait+0xd0>
57e1a6d4:	ebffbb5c 	bl	57e0944c <printf>
			return 0x01;
57e1a6d8:	e3a00001 	mov	r0, #1
57e1a6dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		}

		if (chip->dev_ready) {
57e1a6e0:	e5943030 	ldr	r3, [r4, #48]	; 0x30
57e1a6e4:	e3530000 	cmp	r3, #0
57e1a6e8:	0a000004 	beq	57e1a700 <nand_wait+0xac>
			if (chip->dev_ready(mtd))
57e1a6ec:	e1a00005 	mov	r0, r5
57e1a6f0:	e12fff33 	blx	r3
57e1a6f4:	e3500000 	cmp	r0, #0
57e1a6f8:	0afffff0 	beq	57e1a6c0 <nand_wait+0x6c>
57e1a6fc:	ea000004 	b	57e1a714 <nand_wait+0xc0>
				break;
		} else {
			if (chip->read_byte(mtd) & NAND_STATUS_READY)
57e1a700:	e5943008 	ldr	r3, [r4, #8]
57e1a704:	e1a00005 	mov	r0, r5
57e1a708:	e12fff33 	blx	r3
57e1a70c:	e3100040 	tst	r0, #64	; 0x40
57e1a710:	0affffea 	beq	57e1a6c0 <nand_wait+0x6c>
	time_start = get_timer(0);
	while (get_timer(time_start) < 10)
		;
#endif /*  PPCHAMELON_NAND_TIMER_HACK */

	return (int)chip->read_byte(mtd);
57e1a714:	e5943008 	ldr	r3, [r4, #8]
57e1a718:	e1a00005 	mov	r0, r5
57e1a71c:	e12fff33 	blx	r3
}
57e1a720:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e1a724:	57e342e4 	.word	0x57e342e4

57e1a728 <nand_wait_ready>:
/*
 * Wait for the ready pin, after a command
 * The timeout is catched later.
 */
void nand_wait_ready(struct mtd_info *mtd)
{
57e1a728:	e92d4070 	push	{r4, r5, r6, lr}
	struct nand_chip *chip = mtd->priv;
57e1a72c:	e5906094 	ldr	r6, [r0, #148]	; 0x94
/*
 * Wait for the ready pin, after a command
 * The timeout is catched later.
 */
void nand_wait_ready(struct mtd_info *mtd)
{
57e1a730:	e1a04000 	mov	r4, r0
	struct nand_chip *chip = mtd->priv;
	u32 timeo = (CONFIG_SYS_HZ * 20) / 1000;
	u32 time_start;

	time_start = get_timer(0);
57e1a734:	e3a00000 	mov	r0, #0
57e1a738:	ebff98f3 	bl	57e00b0c <get_timer>
57e1a73c:	e1a05000 	mov	r5, r0

	/* wait until command is processed or timeout occures */
	while (get_timer(time_start) < timeo) {
57e1a740:	ea000006 	b	57e1a760 <nand_wait_ready+0x38>
		if (chip->dev_ready)
57e1a744:	e5963030 	ldr	r3, [r6, #48]	; 0x30
57e1a748:	e3530000 	cmp	r3, #0
57e1a74c:	0a000003 	beq	57e1a760 <nand_wait_ready+0x38>
			if (chip->dev_ready(mtd))
57e1a750:	e1a00004 	mov	r0, r4
57e1a754:	e12fff33 	blx	r3
57e1a758:	e3500000 	cmp	r0, #0
57e1a75c:	18bd8070 	popne	{r4, r5, r6, pc}
	u32 time_start;

	time_start = get_timer(0);

	/* wait until command is processed or timeout occures */
	while (get_timer(time_start) < timeo) {
57e1a760:	e1a00005 	mov	r0, r5
57e1a764:	ebff98e8 	bl	57e00b0c <get_timer>
57e1a768:	e3500013 	cmp	r0, #19
57e1a76c:	9afffff4 	bls	57e1a744 <nand_wait_ready+0x1c>
57e1a770:	e8bd8070 	pop	{r4, r5, r6, pc}

57e1a774 <nand_do_read_ops>:
 *
 * Internal function. Called with chip held.
 */
static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
			    struct mtd_oob_ops *ops)
{
57e1a774:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int chipnr, page, realpage, col, bytes, aligned;
	struct nand_chip *chip = mtd->priv;
57e1a778:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 *
 * Internal function. Called with chip held.
 */
static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
			    struct mtd_oob_ops *ops)
{
57e1a77c:	e1a07002 	mov	r7, r2
57e1a780:	e1a0a003 	mov	sl, r3
	int chipnr, page, realpage, col, bytes, aligned;
	struct nand_chip *chip = mtd->priv;
	struct mtd_ecc_stats stats;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
57e1a784:	e5942058 	ldr	r2, [r4, #88]	; 0x58
57e1a788:	e5943054 	ldr	r3, [r4, #84]	; 0x54
 *
 * Internal function. Called with chip held.
 */
static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
			    struct mtd_oob_ops *ops)
{
57e1a78c:	e24dd048 	sub	sp, sp, #72	; 0x48
	int chipnr, page, realpage, col, bytes, aligned;
	struct nand_chip *chip = mtd->priv;
	struct mtd_ecc_stats stats;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
57e1a790:	e0633002 	rsb	r3, r3, r2
57e1a794:	e3e02000 	mvn	r2, #0
57e1a798:	e1e02312 	mvn	r2, r2, lsl r3
 *
 * Internal function. Called with chip held.
 */
static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
			    struct mtd_oob_ops *ops)
{
57e1a79c:	e59d6068 	ldr	r6, [sp, #104]	; 0x68
57e1a7a0:	e1a05000 	mov	r5, r0
	int sndcmd = 1;
	int ret = 0;
	uint32_t readlen = ops->len;
	uint32_t oobreadlen = ops->ooblen;
	uint32_t max_oobsize = ops->mode == MTD_OOB_AUTO ?
		mtd->oobavail : mtd->oobsize;
57e1a7a4:	e5963000 	ldr	r3, [r6]
	struct nand_chip *chip = mtd->priv;
	struct mtd_ecc_stats stats;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
	int sndcmd = 1;
	int ret = 0;
	uint32_t readlen = ops->len;
57e1a7a8:	e5960004 	ldr	r0, [r6, #4]
	uint32_t oobreadlen = ops->ooblen;
57e1a7ac:	e596100c 	ldr	r1, [r6, #12]
	uint32_t max_oobsize = ops->mode == MTD_OOB_AUTO ?
		mtd->oobavail : mtd->oobsize;
57e1a7b0:	e3530001 	cmp	r3, #1
			    struct mtd_oob_ops *ops)
{
	int chipnr, page, realpage, col, bytes, aligned;
	struct nand_chip *chip = mtd->priv;
	struct mtd_ecc_stats stats;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
57e1a7b4:	e58d2040 	str	r2, [sp, #64]	; 0x40
	int sndcmd = 1;
	int ret = 0;
	uint32_t readlen = ops->len;
57e1a7b8:	e58d001c 	str	r0, [sp, #28]
	uint32_t oobreadlen = ops->ooblen;
	uint32_t max_oobsize = ops->mode == MTD_OOB_AUTO ?
		mtd->oobavail : mtd->oobsize;
57e1a7bc:	0595201c 	ldreq	r2, [r5, #28]
57e1a7c0:	e5950080 	ldr	r0, [r5, #128]	; 0x80
	struct mtd_ecc_stats stats;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
	int sndcmd = 1;
	int ret = 0;
	uint32_t readlen = ops->len;
	uint32_t oobreadlen = ops->ooblen;
57e1a7c4:	e58d1028 	str	r1, [sp, #40]	; 0x28
	uint32_t max_oobsize = ops->mode == MTD_OOB_AUTO ?
		mtd->oobavail : mtd->oobsize;
57e1a7c8:	e5951084 	ldr	r1, [r5, #132]	; 0x84
57e1a7cc:	15953018 	ldrne	r3, [r5, #24]
57e1a7d0:	058d2034 	streq	r2, [sp, #52]	; 0x34
57e1a7d4:	e58d0044 	str	r0, [sp, #68]	; 0x44

	uint8_t *bufpoi, *oob, *buf;

	stats = mtd->ecc_stats;

	chipnr = (int)(from >> chip->chip_shift);
57e1a7d8:	e5942060 	ldr	r2, [r4, #96]	; 0x60
	int sndcmd = 1;
	int ret = 0;
	uint32_t readlen = ops->len;
	uint32_t oobreadlen = ops->ooblen;
	uint32_t max_oobsize = ops->mode == MTD_OOB_AUTO ?
		mtd->oobavail : mtd->oobsize;
57e1a7dc:	e58d1038 	str	r1, [sp, #56]	; 0x38

	uint8_t *bufpoi, *oob, *buf;

	stats = mtd->ecc_stats;

	chipnr = (int)(from >> chip->chip_shift);
57e1a7e0:	e1a00007 	mov	r0, r7
57e1a7e4:	e1a0100a 	mov	r1, sl
	int sndcmd = 1;
	int ret = 0;
	uint32_t readlen = ops->len;
	uint32_t oobreadlen = ops->ooblen;
	uint32_t max_oobsize = ops->mode == MTD_OOB_AUTO ?
		mtd->oobavail : mtd->oobsize;
57e1a7e8:	158d3034 	strne	r3, [sp, #52]	; 0x34

	uint8_t *bufpoi, *oob, *buf;

	stats = mtd->ecc_stats;

	chipnr = (int)(from >> chip->chip_shift);
57e1a7ec:	eb004509 	bl	57e2bc18 <__ashrdi3>
57e1a7f0:	e58d0024 	str	r0, [sp, #36]	; 0x24
	chip->select_chip(mtd, chipnr);
57e1a7f4:	e594301c 	ldr	r3, [r4, #28]
57e1a7f8:	e1a00005 	mov	r0, r5
57e1a7fc:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
57e1a800:	e12fff33 	blx	r3

	realpage = (int)(from >> chip->page_shift);
57e1a804:	e1a00007 	mov	r0, r7
57e1a808:	e1a0100a 	mov	r1, sl
57e1a80c:	e5942054 	ldr	r2, [r4, #84]	; 0x54
57e1a810:	eb004500 	bl	57e2bc18 <__ashrdi3>
	page = realpage & chip->pagemask;
57e1a814:	e5943070 	ldr	r3, [r4, #112]	; 0x70

	col = (int)(from & (mtd->writesize - 1));

	buf = ops->datbuf;
57e1a818:	e5962018 	ldr	r2, [r6, #24]

	chipnr = (int)(from >> chip->chip_shift);
	chip->select_chip(mtd, chipnr);

	realpage = (int)(from >> chip->page_shift);
	page = realpage & chip->pagemask;
57e1a81c:	e0003003 	and	r3, r0, r3
57e1a820:	e58d3014 	str	r3, [sp, #20]

	col = (int)(from & (mtd->writesize - 1));
57e1a824:	e5953014 	ldr	r3, [r5, #20]
 * @from:	offset to read from
 * @ops:	oob ops structure
 *
 * Internal function. Called with chip held.
 */
static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
57e1a828:	e2800001 	add	r0, r0, #1
	chip->select_chip(mtd, chipnr);

	realpage = (int)(from >> chip->page_shift);
	page = realpage & chip->pagemask;

	col = (int)(from & (mtd->writesize - 1));
57e1a82c:	e2433001 	sub	r3, r3, #1
57e1a830:	e0037007 	and	r7, r3, r7
57e1a834:	e58d7018 	str	r7, [sp, #24]

	buf = ops->datbuf;
57e1a838:	e58d2010 	str	r2, [sp, #16]
	oob = ops->oobbuf;
57e1a83c:	e596901c 	ldr	r9, [r6, #28]
 * @from:	offset to read from
 * @ops:	oob ops structure
 *
 * Internal function. Called with chip held.
 */
static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
57e1a840:	e58d0020 	str	r0, [sp, #32]
	int chipnr, page, realpage, col, bytes, aligned;
	struct nand_chip *chip = mtd->priv;
	struct mtd_ecc_stats stats;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
	int sndcmd = 1;
	int ret = 0;
57e1a844:	e3a07000 	mov	r7, #0
{
	int chipnr, page, realpage, col, bytes, aligned;
	struct nand_chip *chip = mtd->priv;
	struct mtd_ecc_stats stats;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
	int sndcmd = 1;
57e1a848:	e3a0a001 	mov	sl, #1
57e1a84c:	e1a0b006 	mov	fp, r6
57e1a850:	ea000004 	b	57e1a868 <nand_do_read_ops+0xf4>
	page = realpage & chip->pagemask;

	col = (int)(from & (mtd->writesize - 1));

	buf = ops->datbuf;
	oob = ops->oobbuf;
57e1a854:	e59d3020 	ldr	r3, [sp, #32]
57e1a858:	e3a00000 	mov	r0, #0
57e1a85c:	e2833001 	add	r3, r3, #1
57e1a860:	e58d3020 	str	r3, [sp, #32]
57e1a864:	e58d0018 	str	r0, [sp, #24]
 * @from:	offset to read from
 * @ops:	oob ops structure
 *
 * Internal function. Called with chip held.
 */
static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
57e1a868:	e59d1020 	ldr	r1, [sp, #32]
	oob = ops->oobbuf;

	while (1) {
		WATCHDOG_RESET();

		bytes = min(mtd->writesize - col, readlen);
57e1a86c:	e59d3018 	ldr	r3, [sp, #24]
57e1a870:	e5952014 	ldr	r2, [r5, #20]
 * @from:	offset to read from
 * @ops:	oob ops structure
 *
 * Internal function. Called with chip held.
 */
static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
57e1a874:	e2411001 	sub	r1, r1, #1
	oob = ops->oobbuf;

	while (1) {
		WATCHDOG_RESET();

		bytes = min(mtd->writesize - col, readlen);
57e1a878:	e59d001c 	ldr	r0, [sp, #28]
 * @from:	offset to read from
 * @ops:	oob ops structure
 *
 * Internal function. Called with chip held.
 */
static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
57e1a87c:	e58d103c 	str	r1, [sp, #60]	; 0x3c
	oob = ops->oobbuf;

	while (1) {
		WATCHDOG_RESET();

		bytes = min(mtd->writesize - col, readlen);
57e1a880:	e0636002 	rsb	r6, r3, r2
57e1a884:	e1560000 	cmp	r6, r0
57e1a888:	21a06000 	movcs	r6, r0
		aligned = (bytes == mtd->writesize);

		/* Is the current page in the buffer ? */
		if (realpage != chip->pagebuf || oob) {
57e1a88c:	e5943074 	ldr	r3, [r4, #116]	; 0x74
57e1a890:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
57e1a894:	e2591000 	subs	r1, r9, #0
57e1a898:	13a01001 	movne	r1, #1
57e1a89c:	e58d1030 	str	r1, [sp, #48]	; 0x30
57e1a8a0:	e1500003 	cmp	r0, r3
57e1a8a4:	13811001 	orrne	r1, r1, #1
57e1a8a8:	e3510000 	cmp	r1, #0
57e1a8ac:	e1a03001 	mov	r3, r1
57e1a8b0:	0a00006e 	beq	57e1aa70 <nand_do_read_ops+0x2fc>

	while (1) {
		WATCHDOG_RESET();

		bytes = min(mtd->writesize - col, readlen);
		aligned = (bytes == mtd->writesize);
57e1a8b4:	e1560002 	cmp	r6, r2
57e1a8b8:	13a02000 	movne	r2, #0
57e1a8bc:	03a02001 	moveq	r2, #1

		/* Is the current page in the buffer ? */
		if (realpage != chip->pagebuf || oob) {
			bufpoi = aligned ? buf : chip->buffers->databuf;
57e1a8c0:	e3520000 	cmp	r2, #0
57e1a8c4:	059470e8 	ldreq	r7, [r4, #232]	; 0xe8
57e1a8c8:	159d7010 	ldrne	r7, [sp, #16]
57e1a8cc:	02877d12 	addeq	r7, r7, #1152	; 0x480

			if (likely(sndcmd)) {
57e1a8d0:	e35a0000 	cmp	sl, #0

	while (1) {
		WATCHDOG_RESET();

		bytes = min(mtd->writesize - col, readlen);
		aligned = (bytes == mtd->writesize);
57e1a8d4:	e58d202c 	str	r2, [sp, #44]	; 0x2c

		/* Is the current page in the buffer ? */
		if (realpage != chip->pagebuf || oob) {
			bufpoi = aligned ? buf : chip->buffers->databuf;

			if (likely(sndcmd)) {
57e1a8d8:	0a000005 	beq	57e1a8f4 <nand_do_read_ops+0x180>
				chip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
57e1a8dc:	e3a01000 	mov	r1, #0
57e1a8e0:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1a8e4:	e1a00005 	mov	r0, r5
57e1a8e8:	e1a02001 	mov	r2, r1
57e1a8ec:	e59d3014 	ldr	r3, [sp, #20]
57e1a8f0:	e12fff3c 	blx	ip
				sndcmd = 0;
			}

			/* Now read the page into the buffer */
			if (unlikely(ops->mode == MTD_OOB_RAW))
57e1a8f4:	e59b3000 	ldr	r3, [fp]
57e1a8f8:	e3530002 	cmp	r3, #2
				ret = chip->ecc.read_page_raw(mtd, chip,
57e1a8fc:	0594c0cc 	ldreq	ip, [r4, #204]	; 0xcc
				chip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
				sndcmd = 0;
			}

			/* Now read the page into the buffer */
			if (unlikely(ops->mode == MTD_OOB_RAW))
57e1a900:	0a000014 	beq	57e1a958 <nand_do_read_ops+0x1e4>
				ret = chip->ecc.read_page_raw(mtd, chip,
							      bufpoi, page);
			else if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&
57e1a904:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
57e1a908:	e3510000 	cmp	r1, #0
57e1a90c:	1a000010 	bne	57e1a954 <nand_do_read_ops+0x1e0>
57e1a910:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1a914:	e3130a01 	tst	r3, #4096	; 0x1000
57e1a918:	03a03000 	moveq	r3, #0
57e1a91c:	13a03001 	movne	r3, #1
57e1a920:	e3590000 	cmp	r9, #0
57e1a924:	13a03000 	movne	r3, #0
57e1a928:	02033001 	andeq	r3, r3, #1
57e1a92c:	e3530000 	cmp	r3, #0
57e1a930:	0a000007 	beq	57e1a954 <nand_do_read_ops+0x1e0>
			    !oob)
				ret = chip->ecc.read_subpage(mtd, chip,
57e1a934:	e58d7000 	str	r7, [sp]
57e1a938:	e594c0d8 	ldr	ip, [r4, #216]	; 0xd8
57e1a93c:	e1a00005 	mov	r0, r5
57e1a940:	e1a01004 	mov	r1, r4
57e1a944:	e59d2018 	ldr	r2, [sp, #24]
57e1a948:	e1a03006 	mov	r3, r6
57e1a94c:	e12fff3c 	blx	ip
57e1a950:	ea000005 	b	57e1a96c <nand_do_read_ops+0x1f8>
							col, bytes, bufpoi);
			else
				ret = chip->ecc.read_page(mtd, chip, bufpoi,
57e1a954:	e594c0d4 	ldr	ip, [r4, #212]	; 0xd4
57e1a958:	e1a00005 	mov	r0, r5
57e1a95c:	e1a01004 	mov	r1, r4
57e1a960:	e1a02007 	mov	r2, r7
57e1a964:	e59d3014 	ldr	r3, [sp, #20]
57e1a968:	e12fff3c 	blx	ip
							  page);
			if (ret < 0)
57e1a96c:	e3500000 	cmp	r0, #0
			else if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&
			    !oob)
				ret = chip->ecc.read_subpage(mtd, chip,
							col, bytes, bufpoi);
			else
				ret = chip->ecc.read_page(mtd, chip, bufpoi,
57e1a970:	e1a07000 	mov	r7, r0
							  page);
			if (ret < 0)
57e1a974:	ba000067 	blt	57e1ab18 <nand_do_read_ops+0x3a4>
				break;

			/* Transfer not aligned data */
			if (!aligned) {
57e1a978:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
57e1a97c:	e3520000 	cmp	r2, #0
57e1a980:	1a000014 	bne	57e1a9d8 <nand_do_read_ops+0x264>
				if (!NAND_HAS_SUBPAGE_READ(chip) && !oob &&
57e1a984:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1a988:	e3130a01 	tst	r3, #4096	; 0x1000
57e1a98c:	13a03000 	movne	r3, #0
57e1a990:	03a03001 	moveq	r3, #1
57e1a994:	e3590000 	cmp	r9, #0
57e1a998:	13a03000 	movne	r3, #0
57e1a99c:	02033001 	andeq	r3, r3, #1
57e1a9a0:	e3530000 	cmp	r3, #0
57e1a9a4:	0a000004 	beq	57e1a9bc <nand_do_read_ops+0x248>
57e1a9a8:	e5953084 	ldr	r3, [r5, #132]	; 0x84
57e1a9ac:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
57e1a9b0:	e1530000 	cmp	r3, r0
				    !(mtd->ecc_stats.failed - stats.failed))
					chip->pagebuf = realpage;
57e1a9b4:	059d103c 	ldreq	r1, [sp, #60]	; 0x3c
57e1a9b8:	05841074 	streq	r1, [r4, #116]	; 0x74
				memcpy(buf, chip->buffers->databuf + col, bytes);
57e1a9bc:	e59410e8 	ldr	r1, [r4, #232]	; 0xe8
57e1a9c0:	e59d2018 	ldr	r2, [sp, #24]
57e1a9c4:	e2811d12 	add	r1, r1, #1152	; 0x480
57e1a9c8:	e0811002 	add	r1, r1, r2
57e1a9cc:	e59d0010 	ldr	r0, [sp, #16]
57e1a9d0:	e1a02006 	mov	r2, r6
57e1a9d4:	eb00264c 	bl	57e2430c <memcpy>
			}

			buf += bytes;
57e1a9d8:	e59d3010 	ldr	r3, [sp, #16]

			if (unlikely(oob)) {
57e1a9dc:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
				    !(mtd->ecc_stats.failed - stats.failed))
					chip->pagebuf = realpage;
				memcpy(buf, chip->buffers->databuf + col, bytes);
			}

			buf += bytes;
57e1a9e0:	e0833006 	add	r3, r3, r6

			if (unlikely(oob)) {
57e1a9e4:	e3500000 	cmp	r0, #0
				    !(mtd->ecc_stats.failed - stats.failed))
					chip->pagebuf = realpage;
				memcpy(buf, chip->buffers->databuf + col, bytes);
			}

			buf += bytes;
57e1a9e8:	e58d3010 	str	r3, [sp, #16]

			if (unlikely(oob)) {
57e1a9ec:	059d9030 	ldreq	r9, [sp, #48]	; 0x30
57e1a9f0:	0a00000e 	beq	57e1aa30 <nand_do_read_ops+0x2bc>

				int toread = min(oobreadlen, max_oobsize);
57e1a9f4:	e59da028 	ldr	sl, [sp, #40]	; 0x28
57e1a9f8:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
57e1a9fc:	e15a0001 	cmp	sl, r1
57e1aa00:	21a0a001 	movcs	sl, r1

				if (toread) {
57e1aa04:	e35a0000 	cmp	sl, #0
57e1aa08:	0a000008 	beq	57e1aa30 <nand_do_read_ops+0x2bc>
					oob = nand_transfer_oob(chip,
57e1aa0c:	e1a01009 	mov	r1, r9
57e1aa10:	e1a0200b 	mov	r2, fp
57e1aa14:	e1a00004 	mov	r0, r4
57e1aa18:	e1a0300a 	mov	r3, sl
57e1aa1c:	ebfffe6a 	bl	57e1a3cc <nand_transfer_oob>
						oob, ops, toread);
					oobreadlen -= toread;
57e1aa20:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
			if (unlikely(oob)) {

				int toread = min(oobreadlen, max_oobsize);

				if (toread) {
					oob = nand_transfer_oob(chip,
57e1aa24:	e1a09000 	mov	r9, r0
						oob, ops, toread);
					oobreadlen -= toread;
57e1aa28:	e06a2002 	rsb	r2, sl, r2
57e1aa2c:	e58d2028 	str	r2, [sp, #40]	; 0x28
				}
			}

			if (!(chip->options & NAND_NO_READRDY)) {
57e1aa30:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1aa34:	e2133c01 	ands	r3, r3, #256	; 0x100
57e1aa38:	13a0a000 	movne	sl, #0
57e1aa3c:	1a000018 	bne	57e1aaa4 <nand_do_read_ops+0x330>
				 * this before the AUTOINCR check, so no
				 * problems arise if a chip which does auto
				 * increment is marked as NOAUTOINCR by the
				 * board driver.
				 */
				if (!chip->dev_ready)
57e1aa40:	e594a030 	ldr	sl, [r4, #48]	; 0x30
57e1aa44:	e35a0000 	cmp	sl, #0
57e1aa48:	1a000002 	bne	57e1aa58 <nand_do_read_ops+0x2e4>
					udelay(chip->chip_delay);
57e1aa4c:	e594004c 	ldr	r0, [r4, #76]	; 0x4c
57e1aa50:	eb0026b8 	bl	57e24538 <udelay>
57e1aa54:	ea000012 	b	57e1aaa4 <nand_do_read_ops+0x330>
				else
					nand_wait_ready(mtd);
57e1aa58:	e1a00005 	mov	r0, r5
57e1aa5c:	e58d300c 	str	r3, [sp, #12]
57e1aa60:	ebffff30 	bl	57e1a728 <nand_wait_ready>
57e1aa64:	e59d300c 	ldr	r3, [sp, #12]
57e1aa68:	e1a0a003 	mov	sl, r3
57e1aa6c:	ea00000c 	b	57e1aaa4 <nand_do_read_ops+0x330>
			}
		} else {
			memcpy(buf, chip->buffers->databuf + col, bytes);
57e1aa70:	e59410e8 	ldr	r1, [r4, #232]	; 0xe8
57e1aa74:	e59d2018 	ldr	r2, [sp, #24]
57e1aa78:	e2811d12 	add	r1, r1, #1152	; 0x480
57e1aa7c:	e0811002 	add	r1, r1, r2
57e1aa80:	e59d0010 	ldr	r0, [sp, #16]
57e1aa84:	e1a02006 	mov	r2, r6
57e1aa88:	e58d300c 	str	r3, [sp, #12]
57e1aa8c:	eb00261e 	bl	57e2430c <memcpy>
			buf += bytes;
57e1aa90:	e59d0010 	ldr	r0, [sp, #16]
57e1aa94:	e59d300c 	ldr	r3, [sp, #12]
57e1aa98:	e0800006 	add	r0, r0, r6
57e1aa9c:	e58d0010 	str	r0, [sp, #16]
57e1aaa0:	e1a09003 	mov	r9, r3
		}

		readlen -= bytes;

		if (!readlen)
57e1aaa4:	e59d101c 	ldr	r1, [sp, #28]
57e1aaa8:	e0511006 	subs	r1, r1, r6
57e1aaac:	e58d101c 	str	r1, [sp, #28]
57e1aab0:	0a000018 	beq	57e1ab18 <nand_do_read_ops+0x3a4>
		/* For subsequent reads align to page boundary. */
		col = 0;
		/* Increment page address */
		realpage++;

		page = realpage & chip->pagemask;
57e1aab4:	e5943070 	ldr	r3, [r4, #112]	; 0x70
		/* Check, if we cross a chip boundary */
		if (!page) {
57e1aab8:	e59d2020 	ldr	r2, [sp, #32]
57e1aabc:	e0123003 	ands	r3, r2, r3
57e1aac0:	e58d3014 	str	r3, [sp, #20]
57e1aac4:	1a00000a 	bne	57e1aaf4 <nand_do_read_ops+0x380>
			chipnr++;
57e1aac8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
			chip->select_chip(mtd, -1);
57e1aacc:	e1a00005 	mov	r0, r5
		realpage++;

		page = realpage & chip->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
			chipnr++;
57e1aad0:	e2833001 	add	r3, r3, #1
57e1aad4:	e58d3024 	str	r3, [sp, #36]	; 0x24
			chip->select_chip(mtd, -1);
57e1aad8:	e3e01000 	mvn	r1, #0
57e1aadc:	e594301c 	ldr	r3, [r4, #28]
57e1aae0:	e12fff33 	blx	r3
			chip->select_chip(mtd, chipnr);
57e1aae4:	e594301c 	ldr	r3, [r4, #28]
57e1aae8:	e1a00005 	mov	r0, r5
57e1aaec:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
57e1aaf0:	e12fff33 	blx	r3
		}

		/* Check, if the chip supports auto page increment
		 * or if we have hit a block boundary.
		 */
		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
57e1aaf4:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1aaf8:	e3130001 	tst	r3, #1
			sndcmd = 1;
57e1aafc:	13a0a001 	movne	sl, #1
		}

		/* Check, if the chip supports auto page increment
		 * or if we have hit a block boundary.
		 */
		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
57e1ab00:	1affff53 	bne	57e1a854 <nand_do_read_ops+0xe0>
			sndcmd = 1;
57e1ab04:	e59d0014 	ldr	r0, [sp, #20]
57e1ab08:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
57e1ab0c:	e1100001 	tst	r0, r1
57e1ab10:	03a0a001 	moveq	sl, #1
57e1ab14:	eaffff4e 	b	57e1a854 <nand_do_read_ops+0xe0>
	}

	ops->retlen = ops->len - (size_t) readlen;
57e1ab18:	e59b3004 	ldr	r3, [fp, #4]
57e1ab1c:	e59d201c 	ldr	r2, [sp, #28]
	if (oob)
57e1ab20:	e3590000 	cmp	r9, #0
		 */
		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
			sndcmd = 1;
	}

	ops->retlen = ops->len - (size_t) readlen;
57e1ab24:	e0623003 	rsb	r3, r2, r3
57e1ab28:	e58b3008 	str	r3, [fp, #8]
	if (oob)
		ops->oobretlen = ops->ooblen - oobreadlen;
57e1ab2c:	159d0028 	ldrne	r0, [sp, #40]	; 0x28
57e1ab30:	159b300c 	ldrne	r3, [fp, #12]
57e1ab34:	e1a0600b 	mov	r6, fp
57e1ab38:	10603003 	rsbne	r3, r0, r3
57e1ab3c:	158b3010 	strne	r3, [fp, #16]

	if (ret)
57e1ab40:	e3570000 	cmp	r7, #0
57e1ab44:	1a000009 	bne	57e1ab70 <nand_do_read_ops+0x3fc>
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
57e1ab48:	e5953084 	ldr	r3, [r5, #132]	; 0x84
57e1ab4c:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
57e1ab50:	e1530001 	cmp	r3, r1
		return -EBADMSG;
57e1ab54:	13e07049 	mvnne	r7, #73	; 0x49
		ops->oobretlen = ops->ooblen - oobreadlen;

	if (ret)
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
57e1ab58:	1a000004 	bne	57e1ab70 <nand_do_read_ops+0x3fc>
		return -EBADMSG;

	return  mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
57e1ab5c:	e5953080 	ldr	r3, [r5, #128]	; 0x80
57e1ab60:	e59d2044 	ldr	r2, [sp, #68]	; 0x44
57e1ab64:	e1530002 	cmp	r3, r2
57e1ab68:	03a07000 	moveq	r7, #0
57e1ab6c:	13e07074 	mvnne	r7, #116	; 0x74
}
57e1ab70:	e1a00007 	mov	r0, r7
57e1ab74:	e28dd048 	add	sp, sp, #72	; 0x48
57e1ab78:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e1ab7c <nand_read_oob>:
 *
 * NAND read data and/or out-of-band data
 */
static int nand_read_oob(struct mtd_info *mtd, loff_t from,
			 struct mtd_oob_ops *ops)
{
57e1ab7c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1ab80:	e24dd030 	sub	sp, sp, #48	; 0x30
57e1ab84:	e59d6050 	ldr	r6, [sp, #80]	; 0x50
57e1ab88:	e58d2010 	str	r2, [sp, #16]
57e1ab8c:	e58d3014 	str	r3, [sp, #20]
	struct nand_chip *chip = mtd->priv;
	int ret = -ENOTSUPP;

	ops->retlen = 0;
57e1ab90:	e3a03000 	mov	r3, #0
 * NAND read data and/or out-of-band data
 */
static int nand_read_oob(struct mtd_info *mtd, loff_t from,
			 struct mtd_oob_ops *ops)
{
	struct nand_chip *chip = mtd->priv;
57e1ab94:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int ret = -ENOTSUPP;

	ops->retlen = 0;
57e1ab98:	e5863008 	str	r3, [r6, #8]

	/* Do not allow reads past end of device */
	if (ops->datbuf && (from + ops->len) > mtd->size) {
57e1ab9c:	e5963018 	ldr	r3, [r6, #24]
 *
 * NAND read data and/or out-of-band data
 */
static int nand_read_oob(struct mtd_info *mtd, loff_t from,
			 struct mtd_oob_ops *ops)
{
57e1aba0:	e1a05000 	mov	r5, r0
	int ret = -ENOTSUPP;

	ops->retlen = 0;

	/* Do not allow reads past end of device */
	if (ops->datbuf && (from + ops->len) > mtd->size) {
57e1aba4:	e3530000 	cmp	r3, #0
57e1aba8:	0a00000b 	beq	57e1abdc <nand_read_oob+0x60>
57e1abac:	e5960004 	ldr	r0, [r6, #4]
57e1abb0:	e28d2010 	add	r2, sp, #16
57e1abb4:	e8920006 	ldm	r2, {r1, r2}
57e1abb8:	e0911000 	adds	r1, r1, r0
57e1abbc:	e595000c 	ldr	r0, [r5, #12]
57e1abc0:	e2a22000 	adc	r2, r2, #0
57e1abc4:	e1500002 	cmp	r0, r2
57e1abc8:	3a000096 	bcc	57e1ae28 <nand_read_oob+0x2ac>
57e1abcc:	1a000002 	bne	57e1abdc <nand_read_oob+0x60>
57e1abd0:	e5950008 	ldr	r0, [r5, #8]
57e1abd4:	e1500001 	cmp	r0, r1
57e1abd8:	3a000092 	bcc	57e1ae28 <nand_read_oob+0x2ac>
		return -EINVAL;
	}

	nand_get_device(chip, mtd, FL_READING);

	switch (ops->mode) {
57e1abdc:	e5962000 	ldr	r2, [r6]
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e1abe0:	e3a01001 	mov	r1, #1
		return -EINVAL;
	}

	nand_get_device(chip, mtd, FL_READING);

	switch (ops->mode) {
57e1abe4:	e3520002 	cmp	r2, #2
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e1abe8:	e584108c 	str	r1, [r4, #140]	; 0x8c
 */
static int nand_read_oob(struct mtd_info *mtd, loff_t from,
			 struct mtd_oob_ops *ops)
{
	struct nand_chip *chip = mtd->priv;
	int ret = -ENOTSUPP;
57e1abec:	859f4244 	ldrhi	r4, [pc, #580]	; 57e1ae38 <nand_read_oob+0x2bc>
		return -EINVAL;
	}

	nand_get_device(chip, mtd, FL_READING);

	switch (ops->mode) {
57e1abf0:	8a000089 	bhi	57e1ae1c <nand_read_oob+0x2a0>

	default:
		goto out;
	}

	if (!ops->datbuf)
57e1abf4:	e3530000 	cmp	r3, #0
57e1abf8:	1a000081 	bne	57e1ae04 <nand_read_oob+0x288>
static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
			    struct mtd_oob_ops *ops)
{
	int page, realpage, chipnr, sndcmd = 1;
	struct nand_chip *chip = mtd->priv;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
57e1abfc:	e5949054 	ldr	r9, [r4, #84]	; 0x54
57e1ac00:	e5943058 	ldr	r3, [r4, #88]	; 0x58
	uint8_t *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: from = 0x%08Lx, len = %i\n",
			__func__, (unsigned long long)from, readlen);

	if (ops->mode == MTD_OOB_AUTO)
57e1ac04:	e3520001 	cmp	r2, #1
static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
			    struct mtd_oob_ops *ops)
{
	int page, realpage, chipnr, sndcmd = 1;
	struct nand_chip *chip = mtd->priv;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
57e1ac08:	e0693003 	rsb	r3, r9, r3
57e1ac0c:	e1a01311 	lsl	r1, r1, r3

	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: from = 0x%08Lx, len = %i\n",
			__func__, (unsigned long long)from, readlen);

	if (ops->mode == MTD_OOB_AUTO)
		len = chip->ecc.layout->oobavail;
57e1ac10:	059420b8 	ldreq	r2, [r4, #184]	; 0xb8
static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
			    struct mtd_oob_ops *ops)
{
	int page, realpage, chipnr, sndcmd = 1;
	struct nand_chip *chip = mtd->priv;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
57e1ac14:	e2411001 	sub	r1, r1, #1

	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: from = 0x%08Lx, len = %i\n",
			__func__, (unsigned long long)from, readlen);

	if (ops->mode == MTD_OOB_AUTO)
		len = chip->ecc.layout->oobavail;
57e1ac18:	05927204 	ldreq	r7, [r2, #516]	; 0x204
	else
		len = mtd->oobsize;
57e1ac1c:	15957018 	ldrne	r7, [r5, #24]

	if (unlikely(ops->ooboffs >= len)) {
57e1ac20:	e596c014 	ldr	ip, [r6, #20]
static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
			    struct mtd_oob_ops *ops)
{
	int page, realpage, chipnr, sndcmd = 1;
	struct nand_chip *chip = mtd->priv;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
57e1ac24:	e58d102c 	str	r1, [sp, #44]	; 0x2c
	int readlen = ops->ooblen;
	int len;
	uint8_t *buf = ops->oobbuf;
57e1ac28:	e596101c 	ldr	r1, [r6, #28]
	if (ops->mode == MTD_OOB_AUTO)
		len = chip->ecc.layout->oobavail;
	else
		len = mtd->oobsize;

	if (unlikely(ops->ooboffs >= len)) {
57e1ac2c:	e15c0007 	cmp	ip, r7
			    struct mtd_oob_ops *ops)
{
	int page, realpage, chipnr, sndcmd = 1;
	struct nand_chip *chip = mtd->priv;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
	int readlen = ops->ooblen;
57e1ac30:	e596300c 	ldr	r3, [r6, #12]
	int len;
	uint8_t *buf = ops->oobbuf;
57e1ac34:	e58d1028 	str	r1, [sp, #40]	; 0x28
	if (ops->mode == MTD_OOB_AUTO)
		len = chip->ecc.layout->oobavail;
	else
		len = mtd->oobsize;

	if (unlikely(ops->ooboffs >= len)) {
57e1ac38:	2a00006f 	bcs	57e1adfc <nand_read_oob+0x280>
					"outside oob\n", __func__);
		return -EINVAL;
	}

	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
57e1ac3c:	e595100c 	ldr	r1, [r5, #12]
57e1ac40:	e59d2014 	ldr	r2, [sp, #20]
57e1ac44:	e5950008 	ldr	r0, [r5, #8]
57e1ac48:	e1510002 	cmp	r1, r2
57e1ac4c:	8a000003 	bhi	57e1ac60 <nand_read_oob+0xe4>
57e1ac50:	1a000069 	bne	57e1adfc <nand_read_oob+0x280>
57e1ac54:	e59da010 	ldr	sl, [sp, #16]
57e1ac58:	e150000a 	cmp	r0, sl
57e1ac5c:	9a000066 	bls	57e1adfc <nand_read_oob+0x280>
57e1ac60:	e08cc003 	add	ip, ip, r3
57e1ac64:	e1a0a007 	mov	sl, r7
57e1ac68:	e1a0bfca 	asr	fp, sl, #31
57e1ac6c:	e1a02009 	mov	r2, r9
57e1ac70:	e58da018 	str	sl, [sp, #24]
57e1ac74:	e58db01c 	str	fp, [sp, #28]
57e1ac78:	e58d300c 	str	r3, [sp, #12]
57e1ac7c:	e58dc008 	str	ip, [sp, #8]
57e1ac80:	eb0043dd 	bl	57e2bbfc <__lshrdi3>
57e1ac84:	e1a02009 	mov	r2, r9
57e1ac88:	e1a0a000 	mov	sl, r0
57e1ac8c:	e1a0b001 	mov	fp, r1
57e1ac90:	e28d1010 	add	r1, sp, #16
57e1ac94:	e8910003 	ldm	r1, {r0, r1}
57e1ac98:	eb0043de 	bl	57e2bc18 <__ashrdi3>
57e1ac9c:	e05aa000 	subs	sl, sl, r0
57e1aca0:	e0cbb001 	sbc	fp, fp, r1
57e1aca4:	e0000b97 	mul	r0, r7, fp
57e1aca8:	e59d101c 	ldr	r1, [sp, #28]
57e1acac:	e59d300c 	ldr	r3, [sp, #12]
57e1acb0:	e020019a 	mla	r0, sl, r1, r0
57e1acb4:	e0821a97 	umull	r1, r2, r7, sl
57e1acb8:	e0802002 	add	r2, r0, r2
57e1acbc:	e3520000 	cmp	r2, #0
57e1acc0:	e59dc008 	ldr	ip, [sp, #8]
57e1acc4:	1a000001 	bne	57e1acd0 <nand_read_oob+0x154>
57e1acc8:	e15c0001 	cmp	ip, r1
57e1accc:	8a00004a 	bhi	57e1adfc <nand_read_oob+0x280>
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read beyond end "
					"of device\n", __func__);
		return -EINVAL;
	}

	chipnr = (int)(from >> chip->chip_shift);
57e1acd0:	e5942060 	ldr	r2, [r4, #96]	; 0x60
57e1acd4:	e28d1010 	add	r1, sp, #16
57e1acd8:	e8910003 	ldm	r1, {r0, r1}
			    struct mtd_oob_ops *ops)
{
	int page, realpage, chipnr, sndcmd = 1;
	struct nand_chip *chip = mtd->priv;
	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
	int readlen = ops->ooblen;
57e1acdc:	e58d3018 	str	r3, [sp, #24]
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read beyond end "
					"of device\n", __func__);
		return -EINVAL;
	}

	chipnr = (int)(from >> chip->chip_shift);
57e1ace0:	eb0043cc 	bl	57e2bc18 <__ashrdi3>
57e1ace4:	e58d0024 	str	r0, [sp, #36]	; 0x24
	chip->select_chip(mtd, chipnr);
57e1ace8:	e594301c 	ldr	r3, [r4, #28]
57e1acec:	e1a00005 	mov	r0, r5
57e1acf0:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
57e1acf4:	e12fff33 	blx	r3

	/* Shift to get page */
	realpage = (int)(from >> chip->page_shift);
57e1acf8:	e28d1010 	add	r1, sp, #16
57e1acfc:	e8910003 	ldm	r1, {r0, r1}
57e1ad00:	e5942054 	ldr	r2, [r4, #84]	; 0x54
57e1ad04:	eb0043c3 	bl	57e2bc18 <__ashrdi3>
	page = realpage & chip->pagemask;
57e1ad08:	e594b070 	ldr	fp, [r4, #112]	; 0x70

	chipnr = (int)(from >> chip->chip_shift);
	chip->select_chip(mtd, chipnr);

	/* Shift to get page */
	realpage = (int)(from >> chip->page_shift);
57e1ad0c:	e1a09000 	mov	r9, r0
	page = realpage & chip->pagemask;
57e1ad10:	e000b00b 	and	fp, r0, fp

		/* Check, if the chip supports auto page increment
		 * or if we have hit a block boundary.
		 */
		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
			sndcmd = 1;
57e1ad14:	e3a0a001 	mov	sl, #1
	realpage = (int)(from >> chip->page_shift);
	page = realpage & chip->pagemask;

	while (1) {
		WATCHDOG_RESET();
		sndcmd = chip->ecc.read_oob(mtd, chip, page, sndcmd);
57e1ad18:	e1a0300a 	mov	r3, sl
57e1ad1c:	e594c0e0 	ldr	ip, [r4, #224]	; 0xe0
57e1ad20:	e1a01004 	mov	r1, r4
57e1ad24:	e1a0200b 	mov	r2, fp
57e1ad28:	e1a00005 	mov	r0, r5
57e1ad2c:	e12fff3c 	blx	ip

		len = min(len, readlen);
57e1ad30:	e59d2018 	ldr	r2, [sp, #24]
	realpage = (int)(from >> chip->page_shift);
	page = realpage & chip->pagemask;

	while (1) {
		WATCHDOG_RESET();
		sndcmd = chip->ecc.read_oob(mtd, chip, page, sndcmd);
57e1ad34:	e1a0a000 	mov	sl, r0

		len = min(len, readlen);
57e1ad38:	e1570002 	cmp	r7, r2
57e1ad3c:	a1a07002 	movge	r7, r2
		buf = nand_transfer_oob(chip, buf, ops, len);
57e1ad40:	e1a03007 	mov	r3, r7
57e1ad44:	e1a00004 	mov	r0, r4
57e1ad48:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
57e1ad4c:	e1a02006 	mov	r2, r6
57e1ad50:	ebfffd9d 	bl	57e1a3cc <nand_transfer_oob>

		if (!(chip->options & NAND_NO_READRDY)) {
57e1ad54:	e5943050 	ldr	r3, [r4, #80]	; 0x50
	while (1) {
		WATCHDOG_RESET();
		sndcmd = chip->ecc.read_oob(mtd, chip, page, sndcmd);

		len = min(len, readlen);
		buf = nand_transfer_oob(chip, buf, ops, len);
57e1ad58:	e58d0028 	str	r0, [sp, #40]	; 0x28

		if (!(chip->options & NAND_NO_READRDY)) {
57e1ad5c:	e3130c01 	tst	r3, #256	; 0x100
57e1ad60:	1a000007 	bne	57e1ad84 <nand_read_oob+0x208>
			 * Apply delay or wait for ready/busy pin. Do this
			 * before the AUTOINCR check, so no problems arise if a
			 * chip which does auto increment is marked as
			 * NOAUTOINCR by the board driver.
			 */
			if (!chip->dev_ready)
57e1ad64:	e5943030 	ldr	r3, [r4, #48]	; 0x30
57e1ad68:	e3530000 	cmp	r3, #0
57e1ad6c:	1a000002 	bne	57e1ad7c <nand_read_oob+0x200>
				udelay(chip->chip_delay);
57e1ad70:	e594004c 	ldr	r0, [r4, #76]	; 0x4c
57e1ad74:	eb0025ef 	bl	57e24538 <udelay>
57e1ad78:	ea000001 	b	57e1ad84 <nand_read_oob+0x208>
			else
				nand_wait_ready(mtd);
57e1ad7c:	e1a00005 	mov	r0, r5
57e1ad80:	ebfffe68 	bl	57e1a728 <nand_wait_ready>
		}

		readlen -= len;
		if (!readlen)
57e1ad84:	e59d3018 	ldr	r3, [sp, #24]
57e1ad88:	e0533007 	subs	r3, r3, r7
57e1ad8c:	e58d3018 	str	r3, [sp, #24]
57e1ad90:	0a000015 	beq	57e1adec <nand_read_oob+0x270>
			break;

		/* Increment page address */
		realpage++;

		page = realpage & chip->pagemask;
57e1ad94:	e594b070 	ldr	fp, [r4, #112]	; 0x70
		readlen -= len;
		if (!readlen)
			break;

		/* Increment page address */
		realpage++;
57e1ad98:	e2899001 	add	r9, r9, #1

		page = realpage & chip->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
57e1ad9c:	e019b00b 	ands	fp, r9, fp
57e1ada0:	1a00000a 	bne	57e1add0 <nand_read_oob+0x254>
			chipnr++;
57e1ada4:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
			chip->select_chip(mtd, -1);
57e1ada8:	e594301c 	ldr	r3, [r4, #28]
		realpage++;

		page = realpage & chip->pagemask;
		/* Check, if we cross a chip boundary */
		if (!page) {
			chipnr++;
57e1adac:	e2811001 	add	r1, r1, #1
57e1adb0:	e58d1024 	str	r1, [sp, #36]	; 0x24
			chip->select_chip(mtd, -1);
57e1adb4:	e1a00005 	mov	r0, r5
57e1adb8:	e3e01000 	mvn	r1, #0
57e1adbc:	e12fff33 	blx	r3
			chip->select_chip(mtd, chipnr);
57e1adc0:	e594301c 	ldr	r3, [r4, #28]
57e1adc4:	e1a00005 	mov	r0, r5
57e1adc8:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
57e1adcc:	e12fff33 	blx	r3
		}

		/* Check, if the chip supports auto page increment
		 * or if we have hit a block boundary.
		 */
		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
57e1add0:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1add4:	e3130001 	tst	r3, #1
57e1add8:	1affffcd 	bne	57e1ad14 <nand_read_oob+0x198>
			sndcmd = 1;
57e1addc:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
57e1ade0:	e11b0002 	tst	fp, r2
57e1ade4:	03a0a001 	moveq	sl, #1
57e1ade8:	eaffffca 	b	57e1ad18 <nand_read_oob+0x19c>
	}

	ops->oobretlen = ops->ooblen;
57e1adec:	e596300c 	ldr	r3, [r6, #12]
	return 0;
57e1adf0:	e59d4018 	ldr	r4, [sp, #24]
		 */
		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
			sndcmd = 1;
	}

	ops->oobretlen = ops->ooblen;
57e1adf4:	e5863010 	str	r3, [r6, #16]
57e1adf8:	ea000007 	b	57e1ae1c <nand_read_oob+0x2a0>
	if (unlikely(from >= mtd->size ||
		     ops->ooboffs + readlen > ((mtd->size >> chip->page_shift) -
					(from >> chip->page_shift)) * len)) {
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read beyond end "
					"of device\n", __func__);
		return -EINVAL;
57e1adfc:	e3e04015 	mvn	r4, #21
57e1ae00:	ea000005 	b	57e1ae1c <nand_read_oob+0x2a0>
	}

	if (!ops->datbuf)
		ret = nand_do_read_oob(mtd, from, ops);
	else
		ret = nand_do_read_ops(mtd, from, ops);
57e1ae04:	e1a00005 	mov	r0, r5
57e1ae08:	e28d3010 	add	r3, sp, #16
57e1ae0c:	e893000c 	ldm	r3, {r2, r3}
57e1ae10:	e58d6000 	str	r6, [sp]
57e1ae14:	ebfffe56 	bl	57e1a774 <nand_do_read_ops>
57e1ae18:	e1a04000 	mov	r4, r0

out:
	nand_release_device(mtd);
57e1ae1c:	e1a00005 	mov	r0, r5
57e1ae20:	ebfff648 	bl	57e18748 <nand_release_device>
	return ret;
57e1ae24:	ea000000 	b	57e1ae2c <nand_read_oob+0x2b0>

	/* Do not allow reads past end of device */
	if (ops->datbuf && (from + ops->len) > mtd->size) {
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read "
				"beyond end of device\n", __func__);
		return -EINVAL;
57e1ae28:	e3e04015 	mvn	r4, #21
		ret = nand_do_read_ops(mtd, from, ops);

out:
	nand_release_device(mtd);
	return ret;
}
57e1ae2c:	e1a00004 	mov	r0, r4
57e1ae30:	e28dd030 	add	sp, sp, #48	; 0x30
57e1ae34:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1ae38:	fffffdf4 	.word	0xfffffdf4

57e1ae3c <nand_read>:
 *
 * Get hold of the chip and call nand_do_read
 */
static int nand_read(struct mtd_info *mtd, loff_t from, size_t len,
		     size_t *retlen, uint8_t *buf)
{
57e1ae3c:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
57e1ae40:	e59d6018 	ldr	r6, [sp, #24]
57e1ae44:	e1a05000 	mov	r5, r0
	struct nand_chip *chip = mtd->priv;
57e1ae48:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int ret;

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size)
57e1ae4c:	e595c00c 	ldr	ip, [r5, #12]
57e1ae50:	e0920006 	adds	r0, r2, r6
57e1ae54:	e2a31000 	adc	r1, r3, #0
57e1ae58:	e15c0001 	cmp	ip, r1
57e1ae5c:	3a000017 	bcc	57e1aec0 <nand_read+0x84>
57e1ae60:	1a000002 	bne	57e1ae70 <nand_read+0x34>
57e1ae64:	e595c008 	ldr	ip, [r5, #8]
57e1ae68:	e15c0000 	cmp	ip, r0
57e1ae6c:	3a000013 	bcc	57e1aec0 <nand_read+0x84>
		return -EINVAL;
	if (!len)
57e1ae70:	e3560000 	cmp	r6, #0
57e1ae74:	0a000012 	beq	57e1aec4 <nand_read+0x88>
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e1ae78:	e3a01001 	mov	r1, #1
57e1ae7c:	e584108c 	str	r1, [r4, #140]	; 0x8c
		return 0;

	nand_get_device(chip, mtd, FL_READING);

	chip->ops.len = len;
	chip->ops.datbuf = buf;
57e1ae80:	e59d1020 	ldr	r1, [sp, #32]
	if (!len)
		return 0;

	nand_get_device(chip, mtd, FL_READING);

	chip->ops.len = len;
57e1ae84:	e58460f4 	str	r6, [r4, #244]	; 0xf4
	chip->ops.datbuf = buf;
57e1ae88:	e5841108 	str	r1, [r4, #264]	; 0x108
	chip->ops.oobbuf = NULL;
57e1ae8c:	e3a01000 	mov	r1, #0
57e1ae90:	e584110c 	str	r1, [r4, #268]	; 0x10c

	ret = nand_do_read_ops(mtd, from, &chip->ops);
57e1ae94:	e1a00005 	mov	r0, r5
57e1ae98:	e28410f0 	add	r1, r4, #240	; 0xf0
57e1ae9c:	e58d1000 	str	r1, [sp]
57e1aea0:	ebfffe33 	bl	57e1a774 <nand_do_read_ops>

	*retlen = chip->ops.retlen;
57e1aea4:	e59420f8 	ldr	r2, [r4, #248]	; 0xf8
57e1aea8:	e59d301c 	ldr	r3, [sp, #28]

	chip->ops.len = len;
	chip->ops.datbuf = buf;
	chip->ops.oobbuf = NULL;

	ret = nand_do_read_ops(mtd, from, &chip->ops);
57e1aeac:	e1a06000 	mov	r6, r0

	*retlen = chip->ops.retlen;
57e1aeb0:	e5832000 	str	r2, [r3]

	nand_release_device(mtd);
57e1aeb4:	e1a00005 	mov	r0, r5
57e1aeb8:	ebfff622 	bl	57e18748 <nand_release_device>

	return ret;
57e1aebc:	ea000000 	b	57e1aec4 <nand_read+0x88>
	struct nand_chip *chip = mtd->priv;
	int ret;

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size)
		return -EINVAL;
57e1aec0:	e3e06015 	mvn	r6, #21
	*retlen = chip->ops.retlen;

	nand_release_device(mtd);

	return ret;
}
57e1aec4:	e1a00006 	mov	r0, r6
57e1aec8:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}

57e1aecc <nand_command>:
	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;

	/*
	 * Write out the command to the device.
	 */
	if (command == NAND_CMD_SEQIN) {
57e1aecc:	e3510080 	cmp	r1, #128	; 0x80
 * Send command to NAND device. This function is used for small page
 * devices (256/512 Bytes per page)
 */
static void nand_command(struct mtd_info *mtd, unsigned int command,
			 int column, int page_addr)
{
57e1aed0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e1aed4:	e1a05002 	mov	r5, r2
57e1aed8:	e1a04000 	mov	r4, r0
57e1aedc:	e1a06001 	mov	r6, r1
57e1aee0:	e1a0a003 	mov	sl, r3
	register struct nand_chip *chip = mtd->priv;
57e1aee4:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	int ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;
57e1aee8:	13a02083 	movne	r2, #131	; 0x83
	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;

	/*
	 * Write out the command to the device.
	 */
	if (command == NAND_CMD_SEQIN) {
57e1aeec:	1a00000d 	bne	57e1af28 <nand_command+0x5c>
		int readcmd;

		if (column >= mtd->writesize) {
57e1aef0:	e5903014 	ldr	r3, [r0, #20]
57e1aef4:	e1550003 	cmp	r5, r3
			/* OOB area */
			column -= mtd->writesize;
57e1aef8:	20635005 	rsbcs	r5, r3, r5
			readcmd = NAND_CMD_READOOB;
57e1aefc:	23a01050 	movcs	r1, #80	; 0x50
	 * Write out the command to the device.
	 */
	if (command == NAND_CMD_SEQIN) {
		int readcmd;

		if (column >= mtd->writesize) {
57e1af00:	2a000003 	bcs	57e1af14 <nand_command+0x48>
			/* OOB area */
			column -= mtd->writesize;
			readcmd = NAND_CMD_READOOB;
		} else if (column < 256) {
57e1af04:	e35500ff 	cmp	r5, #255	; 0xff
			/* First 256 bytes --> READ0 */
			readcmd = NAND_CMD_READ0;
		} else {
			column -= 256;
57e1af08:	c2455c01 	subgt	r5, r5, #256	; 0x100
			readcmd = NAND_CMD_READ1;
57e1af0c:	c3a01001 	movgt	r1, #1
			/* OOB area */
			column -= mtd->writesize;
			readcmd = NAND_CMD_READOOB;
		} else if (column < 256) {
			/* First 256 bytes --> READ0 */
			readcmd = NAND_CMD_READ0;
57e1af10:	d3a01000 	movle	r1, #0
		} else {
			column -= 256;
			readcmd = NAND_CMD_READ1;
		}
		chip->cmd_ctrl(mtd, readcmd, ctrl);
57e1af14:	e3a02083 	mov	r2, #131	; 0x83
57e1af18:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1af1c:	e1a00004 	mov	r0, r4
57e1af20:	e12fff33 	blx	r3
		ctrl &= ~NAND_CTRL_CHANGE;
57e1af24:	e3a02003 	mov	r2, #3
	}
	chip->cmd_ctrl(mtd, command, ctrl);
57e1af28:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1af2c:	e1a00004 	mov	r0, r4
57e1af30:	e1a01006 	mov	r1, r6
57e1af34:	e12fff33 	blx	r3
	/*
	 * Address cycle, when necessary
	 */
	ctrl = NAND_CTRL_ALE | NAND_CTRL_CHANGE;
	/* Serially input address */
	if (column != -1) {
57e1af38:	e3750001 	cmn	r5, #1
	chip->cmd_ctrl(mtd, command, ctrl);

	/*
	 * Address cycle, when necessary
	 */
	ctrl = NAND_CTRL_ALE | NAND_CTRL_CHANGE;
57e1af3c:	03a05085 	moveq	r5, #133	; 0x85
	/* Serially input address */
	if (column != -1) {
57e1af40:	0a000008 	beq	57e1af68 <nand_command+0x9c>
		/* Adjust columns for 16 bit buswidth */
		if (chip->options & NAND_BUSWIDTH_16)
57e1af44:	e5973050 	ldr	r3, [r7, #80]	; 0x50
			column >>= 1;
		chip->cmd_ctrl(mtd, column, ctrl);
57e1af48:	e1a00004 	mov	r0, r4
	 */
	ctrl = NAND_CTRL_ALE | NAND_CTRL_CHANGE;
	/* Serially input address */
	if (column != -1) {
		/* Adjust columns for 16 bit buswidth */
		if (chip->options & NAND_BUSWIDTH_16)
57e1af4c:	e3130002 	tst	r3, #2
			column >>= 1;
57e1af50:	11a050c5 	asrne	r5, r5, #1
		chip->cmd_ctrl(mtd, column, ctrl);
57e1af54:	e1a01005 	mov	r1, r5
57e1af58:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1af5c:	e3a02085 	mov	r2, #133	; 0x85
57e1af60:	e12fff33 	blx	r3
		ctrl &= ~NAND_CTRL_CHANGE;
57e1af64:	e3a05005 	mov	r5, #5
	}
	if (page_addr != -1) {
57e1af68:	e37a0001 	cmn	sl, #1
57e1af6c:	0a000015 	beq	57e1afc8 <nand_command+0xfc>
		chip->cmd_ctrl(mtd, page_addr, ctrl);
57e1af70:	e1a02005 	mov	r2, r5
57e1af74:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1af78:	e1a00004 	mov	r0, r4
57e1af7c:	e1a0100a 	mov	r1, sl
		ctrl &= ~NAND_CTRL_CHANGE;
57e1af80:	e3c55080 	bic	r5, r5, #128	; 0x80
			column >>= 1;
		chip->cmd_ctrl(mtd, column, ctrl);
		ctrl &= ~NAND_CTRL_CHANGE;
	}
	if (page_addr != -1) {
		chip->cmd_ctrl(mtd, page_addr, ctrl);
57e1af84:	e12fff33 	blx	r3
		ctrl &= ~NAND_CTRL_CHANGE;
		chip->cmd_ctrl(mtd, page_addr >> 8, ctrl);
57e1af88:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1af8c:	e1a00004 	mov	r0, r4
57e1af90:	e1a0144a 	asr	r1, sl, #8
57e1af94:	e1a02005 	mov	r2, r5
57e1af98:	e12fff33 	blx	r3
		/* One more address cycle for devices > 32MiB */
		if (chip->chipsize > (32 << 20))
57e1af9c:	e597306c 	ldr	r3, [r7, #108]	; 0x6c
57e1afa0:	e3530000 	cmp	r3, #0
57e1afa4:	1a000002 	bne	57e1afb4 <nand_command+0xe8>
57e1afa8:	e5973068 	ldr	r3, [r7, #104]	; 0x68
57e1afac:	e3530402 	cmp	r3, #33554432	; 0x2000000
57e1afb0:	9a000004 	bls	57e1afc8 <nand_command+0xfc>
			chip->cmd_ctrl(mtd, page_addr >> 16, ctrl);
57e1afb4:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1afb8:	e1a00004 	mov	r0, r4
57e1afbc:	e1a0184a 	asr	r1, sl, #16
57e1afc0:	e1a02005 	mov	r2, r5
57e1afc4:	e12fff33 	blx	r3
	}
	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
57e1afc8:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1afcc:	e1a00004 	mov	r0, r4
57e1afd0:	e3e01000 	mvn	r1, #0
57e1afd4:	e3a02081 	mov	r2, #129	; 0x81
57e1afd8:	e12fff33 	blx	r3

	/*
	 * program and erase have their own busy handlers
	 * status and sequential in needs no delay
	 */
	switch (command) {
57e1afdc:	e3560070 	cmp	r6, #112	; 0x70
57e1afe0:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
57e1afe4:	8a000004 	bhi	57e1affc <nand_command+0x130>
57e1afe8:	e3560010 	cmp	r6, #16
57e1afec:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
57e1aff0:	e3560060 	cmp	r6, #96	; 0x60
57e1aff4:	1a000020 	bne	57e1b07c <nand_command+0x1b0>
57e1aff8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e1affc:	e35600d0 	cmp	r6, #208	; 0xd0
57e1b000:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
57e1b004:	e35600ff 	cmp	r6, #255	; 0xff
57e1b008:	0a000002 	beq	57e1b018 <nand_command+0x14c>
57e1b00c:	e3560080 	cmp	r6, #128	; 0x80
57e1b010:	1a000019 	bne	57e1b07c <nand_command+0x1b0>
57e1b014:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	case NAND_CMD_SEQIN:
	case NAND_CMD_STATUS:
		return;

	case NAND_CMD_RESET:
		if (chip->dev_ready)
57e1b018:	e5973030 	ldr	r3, [r7, #48]	; 0x30
57e1b01c:	e3530000 	cmp	r3, #0
57e1b020:	1a00001b 	bne	57e1b094 <nand_command+0x1c8>
			break;
		udelay(chip->chip_delay);
57e1b024:	e597004c 	ldr	r0, [r7, #76]	; 0x4c
57e1b028:	eb002542 	bl	57e24538 <udelay>
		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
57e1b02c:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b030:	e1a00004 	mov	r0, r4
57e1b034:	e3a01070 	mov	r1, #112	; 0x70
57e1b038:	e3a02083 	mov	r2, #131	; 0x83
57e1b03c:	e12fff33 	blx	r3
			       NAND_CTRL_CLE | NAND_CTRL_CHANGE);
		chip->cmd_ctrl(mtd,
57e1b040:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b044:	e1a00004 	mov	r0, r4
57e1b048:	e3e01000 	mvn	r1, #0
57e1b04c:	e3a02081 	mov	r2, #129	; 0x81
57e1b050:	e12fff33 	blx	r3
static void nand_command(struct mtd_info *mtd, unsigned int command,
			 int column, int page_addr)
{
	register struct nand_chip *chip = mtd->priv;
	int ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;
	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;
57e1b054:	e59f504c 	ldr	r5, [pc, #76]	; 57e1b0a8 <nand_command+0x1dc>
		udelay(chip->chip_delay);
		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
			       NAND_CTRL_CLE | NAND_CTRL_CHANGE);
		chip->cmd_ctrl(mtd,
			       NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
		while (!(chip->read_byte(mtd) & NAND_STATUS_READY) &&
57e1b058:	e5973008 	ldr	r3, [r7, #8]
57e1b05c:	e1a00004 	mov	r0, r4
57e1b060:	e12fff33 	blx	r3
57e1b064:	e3100040 	tst	r0, #64	; 0x40
57e1b068:	18bd84f0 	popne	{r4, r5, r6, r7, sl, pc}
57e1b06c:	e3550000 	cmp	r5, #0
57e1b070:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
			(rst_sts_cnt--));
57e1b074:	e2455001 	sub	r5, r5, #1
57e1b078:	eafffff6 	b	57e1b058 <nand_command+0x18c>
	default:
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		 */
		if (!chip->dev_ready) {
57e1b07c:	e5973030 	ldr	r3, [r7, #48]	; 0x30
57e1b080:	e3530000 	cmp	r3, #0
57e1b084:	1a000002 	bne	57e1b094 <nand_command+0x1c8>
			udelay(chip->chip_delay);
57e1b088:	e597004c 	ldr	r0, [r7, #76]	; 0x4c
	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay(100);

	nand_wait_ready(mtd);
}
57e1b08c:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		 */
		if (!chip->dev_ready) {
			udelay(chip->chip_delay);
57e1b090:	ea002528 	b	57e24538 <udelay>
			return;
		}
	}
	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay(100);
57e1b094:	e3a00001 	mov	r0, #1
57e1b098:	eb002526 	bl	57e24538 <udelay>

	nand_wait_ready(mtd);
57e1b09c:	e1a00004 	mov	r0, r4
}
57e1b0a0:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	}
	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay(100);

	nand_wait_ready(mtd);
57e1b0a4:	eafffd9f 	b	57e1a728 <nand_wait_ready>
57e1b0a8:	00030d40 	.word	0x00030d40

57e1b0ac <nand_command_lp>:
{
	register struct nand_chip *chip = mtd->priv;
	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;

	/* Emulate NAND_CMD_READOOB */
	if (command == NAND_CMD_READOOB) {
57e1b0ac:	e3510050 	cmp	r1, #80	; 0x50
 * devices We dont have the separate regions as we have in the small page
 * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
 */
static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
			    int column, int page_addr)
{
57e1b0b0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
57e1b0b4:	e1a0a003 	mov	sl, r3
	register struct nand_chip *chip = mtd->priv;
57e1b0b8:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;

	/* Emulate NAND_CMD_READOOB */
	if (command == NAND_CMD_READOOB) {
		column += mtd->writesize;
57e1b0bc:	05903014 	ldreq	r3, [r0, #20]
 * devices We dont have the separate regions as we have in the small page
 * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
 */
static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
			    int column, int page_addr)
{
57e1b0c0:	e1a05001 	mov	r5, r1
	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;

	/* Emulate NAND_CMD_READOOB */
	if (command == NAND_CMD_READOOB) {
		column += mtd->writesize;
		command = NAND_CMD_READ0;
57e1b0c4:	03a05000 	moveq	r5, #0
 * devices We dont have the separate regions as we have in the small page
 * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
 */
static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
			    int column, int page_addr)
{
57e1b0c8:	e1a06002 	mov	r6, r2
		column += mtd->writesize;
		command = NAND_CMD_READ0;
	}

	/* Command latch cycle */
	chip->cmd_ctrl(mtd, command & 0xff,
57e1b0cc:	e20510ff 	and	r1, r5, #255	; 0xff
	register struct nand_chip *chip = mtd->priv;
	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;

	/* Emulate NAND_CMD_READOOB */
	if (command == NAND_CMD_READOOB) {
		column += mtd->writesize;
57e1b0d0:	00826003 	addeq	r6, r2, r3
		command = NAND_CMD_READ0;
	}

	/* Command latch cycle */
	chip->cmd_ctrl(mtd, command & 0xff,
57e1b0d4:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b0d8:	e3a02083 	mov	r2, #131	; 0x83
 * devices We dont have the separate regions as we have in the small page
 * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
 */
static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
			    int column, int page_addr)
{
57e1b0dc:	e1a04000 	mov	r4, r0

	/* Command latch cycle */
	chip->cmd_ctrl(mtd, command & 0xff,
		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);

	if (column != -1 || page_addr != -1) {
57e1b0e0:	e29a9001 	adds	r9, sl, #1
57e1b0e4:	13a09001 	movne	r9, #1
		column += mtd->writesize;
		command = NAND_CMD_READ0;
	}

	/* Command latch cycle */
	chip->cmd_ctrl(mtd, command & 0xff,
57e1b0e8:	e12fff33 	blx	r3
		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);

	if (column != -1 || page_addr != -1) {
57e1b0ec:	e2963001 	adds	r3, r6, #1
57e1b0f0:	13a03001 	movne	r3, #1
57e1b0f4:	e1932009 	orrs	r2, r3, r9
57e1b0f8:	0a000026 	beq	57e1b198 <nand_command_lp+0xec>
		int ctrl = NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE;

		/* Serially input address */
		if (column != -1) {
57e1b0fc:	e3530000 	cmp	r3, #0
	/* Command latch cycle */
	chip->cmd_ctrl(mtd, command & 0xff,
		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);

	if (column != -1 || page_addr != -1) {
		int ctrl = NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE;
57e1b100:	03a02085 	moveq	r2, #133	; 0x85

		/* Serially input address */
		if (column != -1) {
57e1b104:	0a00000d 	beq	57e1b140 <nand_command_lp+0x94>
			/* Adjust columns for 16 bit buswidth */
			if (chip->options & NAND_BUSWIDTH_16)
57e1b108:	e5973050 	ldr	r3, [r7, #80]	; 0x50
				column >>= 1;
			chip->cmd_ctrl(mtd, column, ctrl);
57e1b10c:	e1a00004 	mov	r0, r4
		int ctrl = NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE;

		/* Serially input address */
		if (column != -1) {
			/* Adjust columns for 16 bit buswidth */
			if (chip->options & NAND_BUSWIDTH_16)
57e1b110:	e3130002 	tst	r3, #2
				column >>= 1;
57e1b114:	11a060c6 	asrne	r6, r6, #1
			chip->cmd_ctrl(mtd, column, ctrl);
57e1b118:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b11c:	e1a01006 	mov	r1, r6
57e1b120:	e3a02085 	mov	r2, #133	; 0x85
57e1b124:	e12fff33 	blx	r3
			ctrl &= ~NAND_CTRL_CHANGE;
			chip->cmd_ctrl(mtd, column >> 8, ctrl);
57e1b128:	e3a02005 	mov	r2, #5
57e1b12c:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b130:	e1a00004 	mov	r0, r4
57e1b134:	e1a01446 	asr	r1, r6, #8
57e1b138:	e12fff33 	blx	r3
		if (column != -1) {
			/* Adjust columns for 16 bit buswidth */
			if (chip->options & NAND_BUSWIDTH_16)
				column >>= 1;
			chip->cmd_ctrl(mtd, column, ctrl);
			ctrl &= ~NAND_CTRL_CHANGE;
57e1b13c:	e3a02005 	mov	r2, #5
			chip->cmd_ctrl(mtd, column >> 8, ctrl);
		}
		if (page_addr != -1) {
57e1b140:	e3590000 	cmp	r9, #0
57e1b144:	0a000013 	beq	57e1b198 <nand_command_lp+0xec>
			chip->cmd_ctrl(mtd, page_addr, ctrl);
57e1b148:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b14c:	e1a00004 	mov	r0, r4
57e1b150:	e1a0100a 	mov	r1, sl
57e1b154:	e12fff33 	blx	r3
			chip->cmd_ctrl(mtd, page_addr >> 8,
57e1b158:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b15c:	e1a00004 	mov	r0, r4
57e1b160:	e1a0144a 	asr	r1, sl, #8
57e1b164:	e3a02005 	mov	r2, #5
57e1b168:	e12fff33 	blx	r3
				       NAND_NCE | NAND_ALE);
			/* One more address cycle for devices > 128MiB */
			if (chip->chipsize > (128 << 20))
57e1b16c:	e597306c 	ldr	r3, [r7, #108]	; 0x6c
57e1b170:	e3530000 	cmp	r3, #0
57e1b174:	1a000002 	bne	57e1b184 <nand_command_lp+0xd8>
57e1b178:	e5973068 	ldr	r3, [r7, #104]	; 0x68
57e1b17c:	e3530302 	cmp	r3, #134217728	; 0x8000000
57e1b180:	9a000004 	bls	57e1b198 <nand_command_lp+0xec>
				chip->cmd_ctrl(mtd, page_addr >> 16,
57e1b184:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b188:	e1a00004 	mov	r0, r4
57e1b18c:	e1a0184a 	asr	r1, sl, #16
57e1b190:	e3a02005 	mov	r2, #5
57e1b194:	e12fff33 	blx	r3
					       NAND_NCE | NAND_ALE);
		}
	}
	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
57e1b198:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b19c:	e1a00004 	mov	r0, r4
57e1b1a0:	e3e01000 	mvn	r1, #0
57e1b1a4:	e3a02081 	mov	r2, #129	; 0x81
57e1b1a8:	e12fff33 	blx	r3

	/*
	 * program and erase have their own busy handlers
	 * status, sequential in, and deplete1 need no delay
	 */
	switch (command) {
57e1b1ac:	e3550076 	cmp	r5, #118	; 0x76
57e1b1b0:	8a000010 	bhi	57e1b1f8 <nand_command_lp+0x14c>
57e1b1b4:	e3550072 	cmp	r5, #114	; 0x72
57e1b1b8:	2a00004c 	bcs	57e1b2f0 <nand_command_lp+0x244>
57e1b1bc:	e3550010 	cmp	r5, #16
57e1b1c0:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
57e1b1c4:	8a000004 	bhi	57e1b1dc <nand_command_lp+0x130>
57e1b1c8:	e3550000 	cmp	r5, #0
57e1b1cc:	0a00003a 	beq	57e1b2bc <nand_command_lp+0x210>
57e1b1d0:	e3550005 	cmp	r5, #5
57e1b1d4:	1a000042 	bne	57e1b2e4 <nand_command_lp+0x238>
57e1b1d8:	ea00002c 	b	57e1b290 <nand_command_lp+0x1e4>
57e1b1dc:	e3550060 	cmp	r5, #96	; 0x60
57e1b1e0:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
57e1b1e4:	e3550070 	cmp	r5, #112	; 0x70
57e1b1e8:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
57e1b1ec:	e3550015 	cmp	r5, #21
57e1b1f0:	1a00003b 	bne	57e1b2e4 <nand_command_lp+0x238>
57e1b1f4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
57e1b1f8:	e35500d0 	cmp	r5, #208	; 0xd0
57e1b1fc:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
57e1b200:	8a000004 	bhi	57e1b218 <nand_command_lp+0x16c>
57e1b204:	e3550080 	cmp	r5, #128	; 0x80
57e1b208:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
57e1b20c:	e3550085 	cmp	r5, #133	; 0x85
57e1b210:	1a000033 	bne	57e1b2e4 <nand_command_lp+0x238>
57e1b214:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
57e1b218:	e35500ff 	cmp	r5, #255	; 0xff
57e1b21c:	0a000002 	beq	57e1b22c <nand_command_lp+0x180>
57e1b220:	e3550c01 	cmp	r5, #256	; 0x100
57e1b224:	1a00002e 	bne	57e1b2e4 <nand_command_lp+0x238>
57e1b228:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
	case NAND_CMD_STATUS_ERROR3:
		udelay(chip->chip_delay);
		return;

	case NAND_CMD_RESET:
		if (chip->dev_ready)
57e1b22c:	e5973030 	ldr	r3, [r7, #48]	; 0x30
57e1b230:	e3530000 	cmp	r3, #0
57e1b234:	1a000030 	bne	57e1b2fc <nand_command_lp+0x250>
			break;
		udelay(chip->chip_delay);
57e1b238:	e597004c 	ldr	r0, [r7, #76]	; 0x4c
57e1b23c:	eb0024bd 	bl	57e24538 <udelay>
		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
57e1b240:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b244:	e1a00004 	mov	r0, r4
57e1b248:	e3a01070 	mov	r1, #112	; 0x70
57e1b24c:	e3a02083 	mov	r2, #131	; 0x83
57e1b250:	e12fff33 	blx	r3
			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
57e1b254:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b258:	e1a00004 	mov	r0, r4
57e1b25c:	e3e01000 	mvn	r1, #0
57e1b260:	e3a02081 	mov	r2, #129	; 0x81
57e1b264:	e12fff33 	blx	r3
 */
static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
			    int column, int page_addr)
{
	register struct nand_chip *chip = mtd->priv;
	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;
57e1b268:	e59f50a0 	ldr	r5, [pc, #160]	; 57e1b310 <nand_command_lp+0x264>
		udelay(chip->chip_delay);
		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
			       NAND_NCE | NAND_CTRL_CHANGE);
		while (!(chip->read_byte(mtd) & NAND_STATUS_READY) &&
57e1b26c:	e5973008 	ldr	r3, [r7, #8]
57e1b270:	e1a00004 	mov	r0, r4
57e1b274:	e12fff33 	blx	r3
57e1b278:	e3100040 	tst	r0, #64	; 0x40
57e1b27c:	18bd87f0 	popne	{r4, r5, r6, r7, r8, r9, sl, pc}
57e1b280:	e3550000 	cmp	r5, #0
57e1b284:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
			(rst_sts_cnt--));
57e1b288:	e2455001 	sub	r5, r5, #1
57e1b28c:	eafffff6 	b	57e1b26c <nand_command_lp+0x1c0>
		return;

	case NAND_CMD_RNDOUT:
		/* No ready / busy check necessary */
		chip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,
57e1b290:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b294:	e1a00004 	mov	r0, r4
57e1b298:	e3a010e0 	mov	r1, #224	; 0xe0
57e1b29c:	e3a02083 	mov	r2, #131	; 0x83
57e1b2a0:	e12fff33 	blx	r3
			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
57e1b2a4:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b2a8:	e1a00004 	mov	r0, r4
57e1b2ac:	e3e01000 	mvn	r1, #0
57e1b2b0:	e3a02081 	mov	r2, #129	; 0x81
57e1b2b4:	e12fff33 	blx	r3
57e1b2b8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
			       NAND_NCE | NAND_CTRL_CHANGE);
		return;

	case NAND_CMD_READ0:
		chip->cmd_ctrl(mtd, NAND_CMD_READSTART,
57e1b2bc:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b2c0:	e1a00004 	mov	r0, r4
57e1b2c4:	e3a01030 	mov	r1, #48	; 0x30
57e1b2c8:	e3a02083 	mov	r2, #131	; 0x83
57e1b2cc:	e12fff33 	blx	r3
			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
57e1b2d0:	e5973028 	ldr	r3, [r7, #40]	; 0x28
57e1b2d4:	e1a00004 	mov	r0, r4
57e1b2d8:	e3e01000 	mvn	r1, #0
57e1b2dc:	e3a02081 	mov	r2, #129	; 0x81
57e1b2e0:	e12fff33 	blx	r3
	default:
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		 */
		if (!chip->dev_ready) {
57e1b2e4:	e5973030 	ldr	r3, [r7, #48]	; 0x30
57e1b2e8:	e3530000 	cmp	r3, #0
57e1b2ec:	1a000002 	bne	57e1b2fc <nand_command_lp+0x250>
			udelay(chip->chip_delay);
57e1b2f0:	e597004c 	ldr	r0, [r7, #76]	; 0x4c
	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay(100);

	nand_wait_ready(mtd);
}
57e1b2f4:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		 */
		if (!chip->dev_ready) {
			udelay(chip->chip_delay);
57e1b2f8:	ea00248e 	b	57e24538 <udelay>
		}
	}

	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay(100);
57e1b2fc:	e3a00001 	mov	r0, #1
57e1b300:	eb00248c 	bl	57e24538 <udelay>

	nand_wait_ready(mtd);
57e1b304:	e1a00004 	mov	r0, r4
}
57e1b308:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}

	/* Apply this short delay always to ensure that we do wait tWB in
	 * any case on any machine. */
	ndelay(100);

	nand_wait_ready(mtd);
57e1b30c:	eafffd05 	b	57e1a728 <nand_wait_ready>
57e1b310:	00030d40 	.word	0x00030d40

57e1b314 <nand_erase_nand>:
 *
 * Erase one ore more blocks
 */
int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
		    int allowbbt)
{
57e1b314:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int page, status, pages_per_block, ret, chipnr;
	struct nand_chip *chip = mtd->priv;
57e1b318:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 *
 * Erase one ore more blocks
 */
int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
		    int allowbbt)
{
57e1b31c:	e24dd020 	sub	sp, sp, #32
{
	struct nand_chip *chip = mtd->priv;
	int ret = 0;

	/* Start address must align on block boundary */
	if (ofs & ((1 << chip->phys_erase_shift) - 1)) {
57e1b320:	e5947058 	ldr	r7, [r4, #88]	; 0x58
 *
 * Erase one ore more blocks
 */
int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
		    int allowbbt)
{
57e1b324:	e1a05001 	mov	r5, r1
57e1b328:	e1a06000 	mov	r6, r0

	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: start = 0x%012llx, len = %llu\n",
				__func__, (unsigned long long)instr->addr,
				(unsigned long long)instr->len);

	if (check_offs_len(mtd, instr->addr, instr->len))
57e1b32c:	e2811008 	add	r1, r1, #8
57e1b330:	e8910003 	ldm	r1, {r0, r1}
57e1b334:	e58d0008 	str	r0, [sp, #8]
57e1b338:	e58d100c 	str	r1, [sp, #12]
{
	struct nand_chip *chip = mtd->priv;
	int ret = 0;

	/* Start address must align on block boundary */
	if (ofs & ((1 << chip->phys_erase_shift) - 1)) {
57e1b33c:	e28db008 	add	fp, sp, #8
57e1b340:	e89b0c00 	ldm	fp, {sl, fp}
57e1b344:	e3e00000 	mvn	r0, #0
57e1b348:	e1e00710 	mvn	r0, r0, lsl r7
57e1b34c:	e1a01fc0 	asr	r1, r0, #31
57e1b350:	e001300b 	and	r3, r1, fp
 *
 * Erase one ore more blocks
 */
int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
		    int allowbbt)
{
57e1b354:	e58d201c 	str	r2, [sp, #28]
{
	struct nand_chip *chip = mtd->priv;
	int ret = 0;

	/* Start address must align on block boundary */
	if (ofs & ((1 << chip->phys_erase_shift) - 1)) {
57e1b358:	e000200a 	and	r2, r0, sl
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Unaligned address\n", __func__);
		ret = -EINVAL;
57e1b35c:	e1922003 	orrs	r2, r2, r3
	}

	/* Length must align on block boundary */
	if (len & ((1 << chip->phys_erase_shift) - 1)) {
57e1b360:	e285b010 	add	fp, r5, #16
57e1b364:	e89b0c00 	ldm	fp, {sl, fp}
57e1b368:	e000000a 	and	r0, r0, sl
57e1b36c:	e001100b 	and	r1, r1, fp
	int ret = 0;

	/* Start address must align on block boundary */
	if (ofs & ((1 << chip->phys_erase_shift) - 1)) {
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Unaligned address\n", __func__);
		ret = -EINVAL;
57e1b370:	13e02015 	mvnne	r2, #21

	/* Length must align on block boundary */
	if (len & ((1 << chip->phys_erase_shift) - 1)) {
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Length not block aligned\n",
					__func__);
		ret = -EINVAL;
57e1b374:	e190b001 	orrs	fp, r0, r1
57e1b378:	13e02015 	mvnne	r2, #21
	}

	/* Do not allow past end of device */
	if (ofs + len > mtd->size) {
57e1b37c:	e285b010 	add	fp, r5, #16
57e1b380:	e89b0c00 	ldm	fp, {sl, fp}
57e1b384:	e28d1008 	add	r1, sp, #8
57e1b388:	e8910003 	ldm	r1, {r0, r1}
57e1b38c:	e596300c 	ldr	r3, [r6, #12]
57e1b390:	e09aa000 	adds	sl, sl, r0
57e1b394:	e0abb001 	adc	fp, fp, r1
57e1b398:	e153000b 	cmp	r3, fp
57e1b39c:	3a0000d8 	bcc	57e1b704 <nand_erase_nand+0x3f0>
57e1b3a0:	1a000002 	bne	57e1b3b0 <nand_erase_nand+0x9c>
57e1b3a4:	e5963008 	ldr	r3, [r6, #8]
57e1b3a8:	e153000a 	cmp	r3, sl
57e1b3ac:	3a0000d4 	bcc	57e1b704 <nand_erase_nand+0x3f0>

	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: start = 0x%012llx, len = %llu\n",
				__func__, (unsigned long long)instr->addr,
				(unsigned long long)instr->len);

	if (check_offs_len(mtd, instr->addr, instr->len))
57e1b3b0:	e3520000 	cmp	r2, #0
57e1b3b4:	1a0000d2 	bne	57e1b704 <nand_erase_nand+0x3f0>
		return -EINVAL;

	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
57e1b3b8:	e3e02000 	mvn	r2, #0
57e1b3bc:	e3e03000 	mvn	r3, #0
57e1b3c0:	e5852018 	str	r2, [r5, #24]
57e1b3c4:	e585301c 	str	r3, [r5, #28]
	/* Grab the lock and see if the device is available */
	nand_get_device(chip, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int)(instr->addr >> chip->page_shift);
	chipnr = (int)(instr->addr >> chip->chip_shift);
57e1b3c8:	e28d1008 	add	r1, sp, #8
57e1b3cc:	e8910003 	ldm	r1, {r0, r1}
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e1b3d0:	e3a03003 	mov	r3, #3

	/* Grab the lock and see if the device is available */
	nand_get_device(chip, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int)(instr->addr >> chip->page_shift);
57e1b3d4:	e594b054 	ldr	fp, [r4, #84]	; 0x54
	chipnr = (int)(instr->addr >> chip->chip_shift);
57e1b3d8:	e5942060 	ldr	r2, [r4, #96]	; 0x60
 * Get the device and lock it for exclusive access
 */
static int
nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
{
	chip->state = new_state;
57e1b3dc:	e584308c 	str	r3, [r4, #140]	; 0x8c
	/* Grab the lock and see if the device is available */
	nand_get_device(chip, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int)(instr->addr >> chip->page_shift);
	chipnr = (int)(instr->addr >> chip->chip_shift);
57e1b3e0:	eb004205 	bl	57e2bbfc <__lshrdi3>

	/* Calculate pages in each block */
	pages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);
57e1b3e4:	e06b7007 	rsb	r7, fp, r7
57e1b3e8:	e3a03001 	mov	r3, #1
57e1b3ec:	e1a03713 	lsl	r3, r3, r7
	/* Grab the lock and see if the device is available */
	nand_get_device(chip, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int)(instr->addr >> chip->page_shift);
	chipnr = (int)(instr->addr >> chip->chip_shift);
57e1b3f0:	e1a09000 	mov	r9, r0

	/* Calculate pages in each block */
	pages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);
57e1b3f4:	e58d3018 	str	r3, [sp, #24]

	/* Select the NAND device */
	chip->select_chip(mtd, chipnr);
57e1b3f8:	e1a00006 	mov	r0, r6
57e1b3fc:	e594301c 	ldr	r3, [r4, #28]
57e1b400:	e1a01009 	mov	r1, r9
57e1b404:	e12fff33 	blx	r3

	/* Check, if it is write protected */
	if (nand_check_wp(mtd)) {
57e1b408:	e1a00006 	mov	r0, r6
57e1b40c:	ebfff530 	bl	57e188d4 <nand_check_wp>
57e1b410:	e3500000 	cmp	r0, #0
57e1b414:	0a000007 	beq	57e1b438 <nand_erase_nand+0x124>
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Device is write protected!!!\n",
					__func__);
		instr->state = MTD_ERASE_FAILED;
57e1b418:	e3a03010 	mov	r3, #16
int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
		    int allowbbt)
{
	int page, status, pages_per_block, ret, chipnr;
	struct nand_chip *chip = mtd->priv;
	loff_t rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS] = {0};
57e1b41c:	e3a01000 	mov	r1, #0
57e1b420:	e3a02000 	mov	r2, #0

	/* Check, if it is write protected */
	if (nand_check_wp(mtd)) {
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Device is write protected!!!\n",
					__func__);
		instr->state = MTD_ERASE_FAILED;
57e1b424:	e5c53038 	strb	r3, [r5, #56]	; 0x38
int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
		    int allowbbt)
{
	int page, status, pages_per_block, ret, chipnr;
	struct nand_chip *chip = mtd->priv;
	loff_t rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS] = {0};
57e1b428:	e58d1010 	str	r1, [sp, #16]
57e1b42c:	e58d2014 	str	r2, [sp, #20]
	unsigned int bbt_masked_page = 0xffffffff;
57e1b430:	e3e0a000 	mvn	sl, #0
	/* Check, if it is write protected */
	if (nand_check_wp(mtd)) {
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Device is write protected!!!\n",
					__func__);
		instr->state = MTD_ERASE_FAILED;
		goto erase_exit;
57e1b434:	ea00008e 	b	57e1b674 <nand_erase_nand+0x360>
	 * If BBT requires refresh, set the BBT page mask to see if the BBT
	 * should be rewritten. Otherwise the mask is set to 0xffffffff which
	 * can not be matched. This is also done when the bbt is actually
	 * erased to avoid recusrsive updates
	 */
	if (chip->options & BBT_AUTO_REFRESH && !allowbbt)
57e1b438:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1b43c:	e59d201c 	ldr	r2, [sp, #28]
57e1b440:	e3130080 	tst	r3, #128	; 0x80
57e1b444:	03a03000 	moveq	r3, #0
57e1b448:	13a03001 	movne	r3, #1
57e1b44c:	e3520000 	cmp	r2, #0
57e1b450:	13a03000 	movne	r3, #0
57e1b454:	02033001 	andeq	r3, r3, #1
57e1b458:	e3530000 	cmp	r3, #0
		bbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
57e1b45c:	15943114 	ldrne	r3, [r4, #276]	; 0x114

	/* Grab the lock and see if the device is available */
	nand_get_device(chip, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int)(instr->addr >> chip->page_shift);
57e1b460:	e28d1008 	add	r1, sp, #8
57e1b464:	e8910003 	ldm	r1, {r0, r1}
	 * should be rewritten. Otherwise the mask is set to 0xffffffff which
	 * can not be matched. This is also done when the bbt is actually
	 * erased to avoid recusrsive updates
	 */
	if (chip->options & BBT_AUTO_REFRESH && !allowbbt)
		bbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
57e1b468:	10833109 	addne	r3, r3, r9, lsl #2
57e1b46c:	1593a004 	ldrne	sl, [r3, #4]

	/* Grab the lock and see if the device is available */
	nand_get_device(chip, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int)(instr->addr >> chip->page_shift);
57e1b470:	e1a0200b 	mov	r2, fp
	 * should be rewritten. Otherwise the mask is set to 0xffffffff which
	 * can not be matched. This is also done when the bbt is actually
	 * erased to avoid recusrsive updates
	 */
	if (chip->options & BBT_AUTO_REFRESH && !allowbbt)
		bbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
57e1b474:	13caa0c0 	bicne	sl, sl, #192	; 0xc0
		    int allowbbt)
{
	int page, status, pages_per_block, ret, chipnr;
	struct nand_chip *chip = mtd->priv;
	loff_t rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS] = {0};
	unsigned int bbt_masked_page = 0xffffffff;
57e1b478:	03e0a000 	mvneq	sl, #0

	/* Grab the lock and see if the device is available */
	nand_get_device(chip, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int)(instr->addr >> chip->page_shift);
57e1b47c:	eb0041de 	bl	57e2bbfc <__lshrdi3>
		bbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;

	/* Loop through the pages */
	len = instr->len;

	instr->state = MTD_ERASING;
57e1b480:	e3a03002 	mov	r3, #2

	/* Grab the lock and see if the device is available */
	nand_get_device(chip, mtd, FL_ERASING);

	/* Shift to get first page */
	page = (int)(instr->addr >> chip->page_shift);
57e1b484:	e1a07000 	mov	r7, r0
int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
		    int allowbbt)
{
	int page, status, pages_per_block, ret, chipnr;
	struct nand_chip *chip = mtd->priv;
	loff_t rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS] = {0};
57e1b488:	e3a02000 	mov	r2, #0
	 */
	if (chip->options & BBT_AUTO_REFRESH && !allowbbt)
		bbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;

	/* Loop through the pages */
	len = instr->len;
57e1b48c:	e2851010 	add	r1, r5, #16
57e1b490:	e8910003 	ldm	r1, {r0, r1}
57e1b494:	e58d0008 	str	r0, [sp, #8]
57e1b498:	e58d100c 	str	r1, [sp, #12]
int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
		    int allowbbt)
{
	int page, status, pages_per_block, ret, chipnr;
	struct nand_chip *chip = mtd->priv;
	loff_t rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS] = {0};
57e1b49c:	e3a01000 	mov	r1, #0
		bbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;

	/* Loop through the pages */
	len = instr->len;

	instr->state = MTD_ERASING;
57e1b4a0:	e5c53038 	strb	r3, [r5, #56]	; 0x38
int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
		    int allowbbt)
{
	int page, status, pages_per_block, ret, chipnr;
	struct nand_chip *chip = mtd->priv;
	loff_t rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS] = {0};
57e1b4a4:	e58d1010 	str	r1, [sp, #16]
57e1b4a8:	e58d2014 	str	r2, [sp, #20]
	/* Loop through the pages */
	len = instr->len;

	instr->state = MTD_ERASING;

	while (len) {
57e1b4ac:	ea00006a 	b	57e1b65c <nand_erase_nand+0x348>
		WATCHDOG_RESET();
		/*
		 * heck if we have a bad block, we do not erase bad blocks !
		 */
		if (!instr->scrub && nand_block_checkbad(mtd, ((loff_t) page) <<
57e1b4b0:	e595b040 	ldr	fp, [r5, #64]	; 0x40
57e1b4b4:	e35b0000 	cmp	fp, #0
57e1b4b8:	1a000012 	bne	57e1b508 <nand_erase_nand+0x1f4>
57e1b4bc:	e5942054 	ldr	r2, [r4, #84]	; 0x54
57e1b4c0:	e1a00007 	mov	r0, r7
57e1b4c4:	e1a01fc0 	asr	r1, r0, #31
57e1b4c8:	eb0041d9 	bl	57e2bc34 <__ashldi3>
57e1b4cc:	e58db000 	str	fp, [sp]
57e1b4d0:	e59db01c 	ldr	fp, [sp, #28]
57e1b4d4:	e1a02000 	mov	r2, r0
57e1b4d8:	e1a03001 	mov	r3, r1
57e1b4dc:	e1a00006 	mov	r0, r6
57e1b4e0:	e58db004 	str	fp, [sp, #4]
57e1b4e4:	ebfff91b 	bl	57e19958 <nand_block_checkbad>
57e1b4e8:	e3500000 	cmp	r0, #0
57e1b4ec:	0a000005 	beq	57e1b508 <nand_erase_nand+0x1f4>
					chip->page_shift, 0, allowbbt)) {
			printk(KERN_WARNING "%s: attempt to erase a bad block "
57e1b4f0:	e59f021c 	ldr	r0, [pc, #540]	; 57e1b714 <nand_erase_nand+0x400>
57e1b4f4:	e59f121c 	ldr	r1, [pc, #540]	; 57e1b718 <nand_erase_nand+0x404>
57e1b4f8:	e1a02007 	mov	r2, r7
57e1b4fc:	ebffb7d2 	bl	57e0944c <printf>
					"at page 0x%08x\n", __func__, page);
			instr->state = MTD_ERASE_FAILED;
57e1b500:	e3a03010 	mov	r3, #16
57e1b504:	ea000059 	b	57e1b670 <nand_erase_nand+0x35c>

		/*
		 * Invalidate the page cache, if we erase the block which
		 * contains the current cached page
		 */
		if (page <= chip->pagebuf && chip->pagebuf <
57e1b508:	e5943074 	ldr	r3, [r4, #116]	; 0x74
57e1b50c:	e1570003 	cmp	r7, r3
57e1b510:	ca000004 	bgt	57e1b528 <nand_erase_nand+0x214>
		    (page + pages_per_block))
57e1b514:	e59d0018 	ldr	r0, [sp, #24]
57e1b518:	e0872000 	add	r2, r7, r0

		/*
		 * Invalidate the page cache, if we erase the block which
		 * contains the current cached page
		 */
		if (page <= chip->pagebuf && chip->pagebuf <
57e1b51c:	e1530002 	cmp	r3, r2
		    (page + pages_per_block))
			chip->pagebuf = -1;
57e1b520:	b3e01000 	mvnlt	r1, #0
57e1b524:	b5841074 	strlt	r1, [r4, #116]	; 0x74

		chip->erase_cmd(mtd, page & chip->pagemask);
57e1b528:	e5941070 	ldr	r1, [r4, #112]	; 0x70
57e1b52c:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
57e1b530:	e1a00006 	mov	r0, r6
57e1b534:	e0071001 	and	r1, r7, r1
57e1b538:	e12fff33 	blx	r3

		status = chip->waitfunc(mtd, chip);
57e1b53c:	e5943038 	ldr	r3, [r4, #56]	; 0x38
57e1b540:	e1a00006 	mov	r0, r6
57e1b544:	e1a01004 	mov	r1, r4
57e1b548:	e12fff33 	blx	r3

		/*
		 * See if operation failed and additional status checks are
		 * available
		 */
		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
57e1b54c:	e3100001 	tst	r0, #1
		    (page + pages_per_block))
			chip->pagebuf = -1;

		chip->erase_cmd(mtd, page & chip->pagemask);

		status = chip->waitfunc(mtd, chip);
57e1b550:	e1a03000 	mov	r3, r0

		/*
		 * See if operation failed and additional status checks are
		 * available
		 */
		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
57e1b554:	0a000008 	beq	57e1b57c <nand_erase_nand+0x268>
57e1b558:	e594c044 	ldr	ip, [r4, #68]	; 0x44
57e1b55c:	e35c0000 	cmp	ip, #0
57e1b560:	0a000005 	beq	57e1b57c <nand_erase_nand+0x268>
			status = chip->errstat(mtd, chip, FL_ERASING,
57e1b564:	e58d7000 	str	r7, [sp]
57e1b568:	e1a00006 	mov	r0, r6
57e1b56c:	e1a01004 	mov	r1, r4
57e1b570:	e3a02003 	mov	r2, #3
57e1b574:	e12fff3c 	blx	ip
57e1b578:	e1a03000 	mov	r3, r0
					       status, page);

		/* See if block erase succeeded */
		if (status & NAND_STATUS_FAIL) {
57e1b57c:	e3130001 	tst	r3, #1
57e1b580:	0a000008 	beq	57e1b5a8 <nand_erase_nand+0x294>
			MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Failed erase, "
					"page 0x%08x\n", __func__, page);
			instr->state = MTD_ERASE_FAILED;
57e1b584:	e3a03010 	mov	r3, #16
57e1b588:	e5c53038 	strb	r3, [r5, #56]	; 0x38
			instr->fail_addr =
				((loff_t)page << chip->page_shift);
57e1b58c:	e5942054 	ldr	r2, [r4, #84]	; 0x54
57e1b590:	e1a00007 	mov	r0, r7
57e1b594:	e1a01fc0 	asr	r1, r0, #31
57e1b598:	eb0041a5 	bl	57e2bc34 <__ashldi3>
		/* See if block erase succeeded */
		if (status & NAND_STATUS_FAIL) {
			MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Failed erase, "
					"page 0x%08x\n", __func__, page);
			instr->state = MTD_ERASE_FAILED;
			instr->fail_addr =
57e1b59c:	e5850018 	str	r0, [r5, #24]
57e1b5a0:	e585101c 	str	r1, [r5, #28]
				((loff_t)page << chip->page_shift);
			goto erase_exit;
57e1b5a4:	ea000032 	b	57e1b674 <nand_erase_nand+0x360>

		/*
		 * If BBT requires refresh, set the BBT rewrite flag to the
		 * page being erased
		 */
		if (bbt_masked_page != 0xffffffff &&
57e1b5a8:	e37a0001 	cmn	sl, #1
57e1b5ac:	0a000008 	beq	57e1b5d4 <nand_erase_nand+0x2c0>
		    (page & BBT_PAGE_MASK) == bbt_masked_page)
57e1b5b0:	e3c730c0 	bic	r3, r7, #192	; 0xc0

		/*
		 * If BBT requires refresh, set the BBT rewrite flag to the
		 * page being erased
		 */
		if (bbt_masked_page != 0xffffffff &&
57e1b5b4:	e153000a 	cmp	r3, sl
57e1b5b8:	1a000005 	bne	57e1b5d4 <nand_erase_nand+0x2c0>
		    (page & BBT_PAGE_MASK) == bbt_masked_page)
			rewrite_bbt[chipnr] =
				((loff_t)page << chip->page_shift);
57e1b5bc:	e1a00007 	mov	r0, r7
57e1b5c0:	e1a01fc0 	asr	r1, r0, #31
57e1b5c4:	e5942054 	ldr	r2, [r4, #84]	; 0x54
57e1b5c8:	eb004199 	bl	57e2bc34 <__ashldi3>
57e1b5cc:	e58d0010 	str	r0, [sp, #16]
57e1b5d0:	e58d1014 	str	r1, [sp, #20]

		/* Increment page address and decrement length */
		len -= (1 << chip->phys_erase_shift);
57e1b5d4:	e5943058 	ldr	r3, [r4, #88]	; 0x58
57e1b5d8:	e3a02001 	mov	r2, #1
57e1b5dc:	e1a03312 	lsl	r3, r2, r3
57e1b5e0:	e28d1008 	add	r1, sp, #8
57e1b5e4:	e8910003 	ldm	r1, {r0, r1}
57e1b5e8:	e0500003 	subs	r0, r0, r3
57e1b5ec:	e0c11fc3 	sbc	r1, r1, r3, asr #31
57e1b5f0:	e58d0008 	str	r0, [sp, #8]
57e1b5f4:	e58d100c 	str	r1, [sp, #12]
		page += pages_per_block;

		/* Check, if we cross a chip boundary */
		if (len && !(page & chip->pagemask)) {
57e1b5f8:	e59d200c 	ldr	r2, [sp, #12]
			rewrite_bbt[chipnr] =
				((loff_t)page << chip->page_shift);

		/* Increment page address and decrement length */
		len -= (1 << chip->phys_erase_shift);
		page += pages_per_block;
57e1b5fc:	e59d1018 	ldr	r1, [sp, #24]

		/* Check, if we cross a chip boundary */
		if (len && !(page & chip->pagemask)) {
57e1b600:	e1900002 	orrs	r0, r0, r2
			rewrite_bbt[chipnr] =
				((loff_t)page << chip->page_shift);

		/* Increment page address and decrement length */
		len -= (1 << chip->phys_erase_shift);
		page += pages_per_block;
57e1b604:	e0877001 	add	r7, r7, r1

		/* Check, if we cross a chip boundary */
		if (len && !(page & chip->pagemask)) {
57e1b608:	0a000013 	beq	57e1b65c <nand_erase_nand+0x348>
57e1b60c:	e5943070 	ldr	r3, [r4, #112]	; 0x70
57e1b610:	e1170003 	tst	r7, r3
57e1b614:	1a000010 	bne	57e1b65c <nand_erase_nand+0x348>
			chipnr++;
			chip->select_chip(mtd, -1);
57e1b618:	e594301c 	ldr	r3, [r4, #28]
57e1b61c:	e1a00006 	mov	r0, r6
57e1b620:	e3e01000 	mvn	r1, #0
		len -= (1 << chip->phys_erase_shift);
		page += pages_per_block;

		/* Check, if we cross a chip boundary */
		if (len && !(page & chip->pagemask)) {
			chipnr++;
57e1b624:	e2899001 	add	r9, r9, #1
			chip->select_chip(mtd, -1);
57e1b628:	e12fff33 	blx	r3
			chip->select_chip(mtd, chipnr);
57e1b62c:	e594301c 	ldr	r3, [r4, #28]
57e1b630:	e1a00006 	mov	r0, r6
57e1b634:	e1a01009 	mov	r1, r9
57e1b638:	e12fff33 	blx	r3

			/*
			 * If BBT requires refresh and BBT-PERCHIP, set the BBT
			 * page mask to see if this BBT should be rewritten
			 */
			if (bbt_masked_page != 0xffffffff &&
57e1b63c:	e37a0001 	cmn	sl, #1
57e1b640:	0a000005 	beq	57e1b65c <nand_erase_nand+0x348>
			    (chip->bbt_td->options & NAND_BBT_PERCHIP))
57e1b644:	e5943114 	ldr	r3, [r4, #276]	; 0x114
57e1b648:	e5932000 	ldr	r2, [r3]

			/*
			 * If BBT requires refresh and BBT-PERCHIP, set the BBT
			 * page mask to see if this BBT should be rewritten
			 */
			if (bbt_masked_page != 0xffffffff &&
57e1b64c:	e3120080 	tst	r2, #128	; 0x80
			    (chip->bbt_td->options & NAND_BBT_PERCHIP))
				bbt_masked_page = chip->bbt_td->pages[chipnr] &
57e1b650:	10833109 	addne	r3, r3, r9, lsl #2
57e1b654:	1593a004 	ldrne	sl, [r3, #4]
57e1b658:	13caa0c0 	bicne	sl, sl, #192	; 0xc0
	/* Loop through the pages */
	len = instr->len;

	instr->state = MTD_ERASING;

	while (len) {
57e1b65c:	e59d3008 	ldr	r3, [sp, #8]
57e1b660:	e59db00c 	ldr	fp, [sp, #12]
57e1b664:	e193300b 	orrs	r3, r3, fp
57e1b668:	1affff90 	bne	57e1b4b0 <nand_erase_nand+0x19c>
			    (chip->bbt_td->options & NAND_BBT_PERCHIP))
				bbt_masked_page = chip->bbt_td->pages[chipnr] &
					BBT_PAGE_MASK;
		}
	}
	instr->state = MTD_ERASE_DONE;
57e1b66c:	e3a03008 	mov	r3, #8
57e1b670:	e5c53038 	strb	r3, [r5, #56]	; 0x38

erase_exit:

	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
57e1b674:	e5d53038 	ldrb	r3, [r5, #56]	; 0x38

	/* Deselect and wake up anyone waiting on the device */
	nand_release_device(mtd);
57e1b678:	e1a00006 	mov	r0, r6
	}
	instr->state = MTD_ERASE_DONE;

erase_exit:

	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
57e1b67c:	e3530008 	cmp	r3, #8
57e1b680:	13e07004 	mvnne	r7, #4
57e1b684:	03a07000 	moveq	r7, #0

	/* Deselect and wake up anyone waiting on the device */
	nand_release_device(mtd);
57e1b688:	ebfff42e 	bl	57e18748 <nand_release_device>

	/* Do call back function */
	if (!ret)
57e1b68c:	e3570000 	cmp	r7, #0
57e1b690:	1a000004 	bne	57e1b6a8 <nand_erase_nand+0x394>
#ifdef CONFIG_MTD_PARTITIONS
void mtd_erase_callback(struct erase_info *instr);
#else
static inline void mtd_erase_callback(struct erase_info *instr)
{
	if (instr->callback)
57e1b694:	e5953030 	ldr	r3, [r5, #48]	; 0x30
57e1b698:	e3530000 	cmp	r3, #0
57e1b69c:	0a000001 	beq	57e1b6a8 <nand_erase_nand+0x394>
		instr->callback(instr);
57e1b6a0:	e1a00005 	mov	r0, r5
57e1b6a4:	e12fff33 	blx	r3

	/*
	 * If BBT requires refresh and erase was successful, rewrite any
	 * selected bad block tables
	 */
	if (bbt_masked_page == 0xffffffff || ret)
57e1b6a8:	e37a0001 	cmn	sl, #1
57e1b6ac:	13a0a000 	movne	sl, #0
57e1b6b0:	03a0a001 	moveq	sl, #1
57e1b6b4:	e3570000 	cmp	r7, #0
57e1b6b8:	138aa001 	orrne	sl, sl, #1
57e1b6bc:	e35a0000 	cmp	sl, #0
		return ret;

	for (chipnr = 0; chipnr < chip->numchips; chipnr++) {
		if (!rewrite_bbt[chipnr])
57e1b6c0:	059d0010 	ldreq	r0, [sp, #16]
57e1b6c4:	059d1014 	ldreq	r1, [sp, #20]
57e1b6c8:	01805001 	orreq	r5, r0, r1

	/*
	 * If BBT requires refresh and erase was successful, rewrite any
	 * selected bad block tables
	 */
	if (bbt_masked_page == 0xffffffff || ret)
57e1b6cc:	0a000007 	beq	57e1b6f0 <nand_erase_nand+0x3dc>
57e1b6d0:	ea00000c 	b	57e1b708 <nand_erase_nand+0x3f4>
		return ret;

	for (chipnr = 0; chipnr < chip->numchips; chipnr++) {
		if (!rewrite_bbt[chipnr])
57e1b6d4:	e3550000 	cmp	r5, #0
57e1b6d8:	0a000003 	beq	57e1b6ec <nand_erase_nand+0x3d8>
			continue;
		/* update the BBT for chip */
		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: nand_update_bbt "
			"(%d:0x%0llx 0x%0x)\n", __func__, chipnr,
			rewrite_bbt[chipnr], chip->bbt_td->pages[chipnr]);
		nand_update_bbt(mtd, rewrite_bbt[chipnr]);
57e1b6dc:	e1a00006 	mov	r0, r6
57e1b6e0:	e28d3010 	add	r3, sp, #16
57e1b6e4:	e893000c 	ldm	r3, {r2, r3}
57e1b6e8:	ebffef38 	bl	57e173d0 <nand_update_bbt>
	 * selected bad block tables
	 */
	if (bbt_masked_page == 0xffffffff || ret)
		return ret;

	for (chipnr = 0; chipnr < chip->numchips; chipnr++) {
57e1b6ec:	e28aa001 	add	sl, sl, #1
57e1b6f0:	e5943064 	ldr	r3, [r4, #100]	; 0x64
57e1b6f4:	e15a0003 	cmp	sl, r3
57e1b6f8:	bafffff5 	blt	57e1b6d4 <nand_erase_nand+0x3c0>
57e1b6fc:	e3a07000 	mov	r7, #0
57e1b700:	ea000000 	b	57e1b708 <nand_erase_nand+0x3f4>
	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: start = 0x%012llx, len = %llu\n",
				__func__, (unsigned long long)instr->addr,
				(unsigned long long)instr->len);

	if (check_offs_len(mtd, instr->addr, instr->len))
		return -EINVAL;
57e1b704:	e3e07015 	mvn	r7, #21
		nand_update_bbt(mtd, rewrite_bbt[chipnr]);
	}

	/* Return more or less happy */
	return ret;
}
57e1b708:	e1a00007 	mov	r0, r7
57e1b70c:	e28dd020 	add	sp, sp, #32
57e1b710:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1b714:	57e342ed 	.word	0x57e342ed
57e1b718:	57e2cca4 	.word	0x57e2cca4

57e1b71c <nand_erase>:
 *
 * Erase one ore more blocks
 */
static int nand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	return nand_erase_nand(mtd, instr, 0);
57e1b71c:	e3a02000 	mov	r2, #0
57e1b720:	eafffefb 	b	57e1b314 <nand_erase_nand>

57e1b724 <nand_scan_ident>:
 *
 * The mtd->owner field must be set to the module of the caller.
 */
int nand_scan_ident(struct mtd_info *mtd, int maxchips,
		    const struct nand_flash_dev *table)
{
57e1b724:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int i, busw, nand_maf_id, nand_dev_id;
	struct nand_chip *chip = mtd->priv;
57e1b728:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 *
 * The mtd->owner field must be set to the module of the caller.
 */
int nand_scan_ident(struct mtd_info *mtd, int maxchips,
		    const struct nand_flash_dev *table)
{
57e1b72c:	e1a06002 	mov	r6, r2
 * Set default functions
 */
static void nand_set_defaults(struct nand_chip *chip, int busw)
{
	/* check for proper chip_delay setup, set 20us if not */
	if (!chip->chip_delay)
57e1b730:	e594204c 	ldr	r2, [r4, #76]	; 0x4c
	int i, busw, nand_maf_id, nand_dev_id;
	struct nand_chip *chip = mtd->priv;
	const struct nand_flash_dev *type;

	/* Get buswidth to select the correct functions */
	busw = chip->options & NAND_BUSWIDTH_16;
57e1b734:	e5943050 	ldr	r3, [r4, #80]	; 0x50
 * Set default functions
 */
static void nand_set_defaults(struct nand_chip *chip, int busw)
{
	/* check for proper chip_delay setup, set 20us if not */
	if (!chip->chip_delay)
57e1b738:	e3520000 	cmp	r2, #0
		chip->chip_delay = 20;
57e1b73c:	02822014 	addeq	r2, r2, #20
57e1b740:	0584204c 	streq	r2, [r4, #76]	; 0x4c

	/* check, if a user supplied command function given */
	if (chip->cmdfunc == NULL)
57e1b744:	e5942034 	ldr	r2, [r4, #52]	; 0x34
 *
 * The mtd->owner field must be set to the module of the caller.
 */
int nand_scan_ident(struct mtd_info *mtd, int maxchips,
		    const struct nand_flash_dev *table)
{
57e1b748:	e24dd028 	sub	sp, sp, #40	; 0x28
	/* check for proper chip_delay setup, set 20us if not */
	if (!chip->chip_delay)
		chip->chip_delay = 20;

	/* check, if a user supplied command function given */
	if (chip->cmdfunc == NULL)
57e1b74c:	e3520000 	cmp	r2, #0
		chip->cmdfunc = nand_command;
57e1b750:	059f2710 	ldreq	r2, [pc, #1808]	; 57e1be68 <nand_scan_ident+0x744>
 *
 * The mtd->owner field must be set to the module of the caller.
 */
int nand_scan_ident(struct mtd_info *mtd, int maxchips,
		    const struct nand_flash_dev *table)
{
57e1b754:	e1a05000 	mov	r5, r0
	if (!chip->chip_delay)
		chip->chip_delay = 20;

	/* check, if a user supplied command function given */
	if (chip->cmdfunc == NULL)
		chip->cmdfunc = nand_command;
57e1b758:	05842034 	streq	r2, [r4, #52]	; 0x34

	/* check, if a user supplied wait function given */
	if (chip->waitfunc == NULL)
57e1b75c:	e5942038 	ldr	r2, [r4, #56]	; 0x38
 *
 * The mtd->owner field must be set to the module of the caller.
 */
int nand_scan_ident(struct mtd_info *mtd, int maxchips,
		    const struct nand_flash_dev *table)
{
57e1b760:	e58d101c 	str	r1, [sp, #28]
	/* check, if a user supplied command function given */
	if (chip->cmdfunc == NULL)
		chip->cmdfunc = nand_command;

	/* check, if a user supplied wait function given */
	if (chip->waitfunc == NULL)
57e1b764:	e3520000 	cmp	r2, #0
		chip->waitfunc = nand_wait;
57e1b768:	059f26fc 	ldreq	r2, [pc, #1788]	; 57e1be6c <nand_scan_ident+0x748>
	int i, busw, nand_maf_id, nand_dev_id;
	struct nand_chip *chip = mtd->priv;
	const struct nand_flash_dev *type;

	/* Get buswidth to select the correct functions */
	busw = chip->options & NAND_BUSWIDTH_16;
57e1b76c:	e2033002 	and	r3, r3, #2
	if (chip->cmdfunc == NULL)
		chip->cmdfunc = nand_command;

	/* check, if a user supplied wait function given */
	if (chip->waitfunc == NULL)
		chip->waitfunc = nand_wait;
57e1b770:	05842038 	streq	r2, [r4, #56]	; 0x38

	if (!chip->select_chip)
57e1b774:	e594201c 	ldr	r2, [r4, #28]
57e1b778:	e3520000 	cmp	r2, #0
		chip->select_chip = nand_select_chip;
57e1b77c:	059f26ec 	ldreq	r2, [pc, #1772]	; 57e1be70 <nand_scan_ident+0x74c>
57e1b780:	0584201c 	streq	r2, [r4, #28]
	if (!chip->read_byte)
57e1b784:	e5942008 	ldr	r2, [r4, #8]
57e1b788:	e3520000 	cmp	r2, #0
57e1b78c:	1a000004 	bne	57e1b7a4 <nand_scan_ident+0x80>
		chip->read_byte = busw ? nand_read_byte16 : nand_read_byte;
57e1b790:	e59f16dc 	ldr	r1, [pc, #1756]	; 57e1be74 <nand_scan_ident+0x750>
57e1b794:	e59f26dc 	ldr	r2, [pc, #1756]	; 57e1be78 <nand_scan_ident+0x754>
57e1b798:	e3530000 	cmp	r3, #0
57e1b79c:	01a02001 	moveq	r2, r1
57e1b7a0:	e5842008 	str	r2, [r4, #8]
	if (!chip->read_word)
57e1b7a4:	e594200c 	ldr	r2, [r4, #12]
57e1b7a8:	e3520000 	cmp	r2, #0
		chip->read_word = nand_read_word;
57e1b7ac:	059f26c8 	ldreq	r2, [pc, #1736]	; 57e1be7c <nand_scan_ident+0x758>
57e1b7b0:	0584200c 	streq	r2, [r4, #12]
	if (!chip->block_bad)
57e1b7b4:	e5942020 	ldr	r2, [r4, #32]
57e1b7b8:	e3520000 	cmp	r2, #0
		chip->block_bad = nand_block_bad;
57e1b7bc:	059f26bc 	ldreq	r2, [pc, #1724]	; 57e1be80 <nand_scan_ident+0x75c>
57e1b7c0:	05842020 	streq	r2, [r4, #32]
	if (!chip->block_markbad)
57e1b7c4:	e5942024 	ldr	r2, [r4, #36]	; 0x24
57e1b7c8:	e3520000 	cmp	r2, #0
		chip->block_markbad = nand_default_block_markbad;
57e1b7cc:	059f26b0 	ldreq	r2, [pc, #1712]	; 57e1be84 <nand_scan_ident+0x760>
57e1b7d0:	05842024 	streq	r2, [r4, #36]	; 0x24
	if (!chip->write_buf)
57e1b7d4:	e5942010 	ldr	r2, [r4, #16]
57e1b7d8:	e3520000 	cmp	r2, #0
57e1b7dc:	1a000004 	bne	57e1b7f4 <nand_scan_ident+0xd0>
		chip->write_buf = busw ? nand_write_buf16 : nand_write_buf;
57e1b7e0:	e59f16a0 	ldr	r1, [pc, #1696]	; 57e1be88 <nand_scan_ident+0x764>
57e1b7e4:	e59f26a0 	ldr	r2, [pc, #1696]	; 57e1be8c <nand_scan_ident+0x768>
57e1b7e8:	e3530000 	cmp	r3, #0
57e1b7ec:	01a02001 	moveq	r2, r1
57e1b7f0:	e5842010 	str	r2, [r4, #16]
	if (!chip->read_buf)
57e1b7f4:	e5942014 	ldr	r2, [r4, #20]
57e1b7f8:	e3520000 	cmp	r2, #0
57e1b7fc:	1a000004 	bne	57e1b814 <nand_scan_ident+0xf0>
		chip->read_buf = busw ? nand_read_buf16 : nand_read_buf;
57e1b800:	e59f1688 	ldr	r1, [pc, #1672]	; 57e1be90 <nand_scan_ident+0x76c>
57e1b804:	e59f2688 	ldr	r2, [pc, #1672]	; 57e1be94 <nand_scan_ident+0x770>
57e1b808:	e3530000 	cmp	r3, #0
57e1b80c:	01a02001 	moveq	r2, r1
57e1b810:	e5842014 	str	r2, [r4, #20]
	if (!chip->verify_buf)
57e1b814:	e5942018 	ldr	r2, [r4, #24]
57e1b818:	e3520000 	cmp	r2, #0
57e1b81c:	1a000005 	bne	57e1b838 <nand_scan_ident+0x114>
		chip->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
57e1b820:	e59f2670 	ldr	r2, [pc, #1648]	; 57e1be98 <nand_scan_ident+0x774>
57e1b824:	e59f1670 	ldr	r1, [pc, #1648]	; 57e1be9c <nand_scan_ident+0x778>
57e1b828:	e3530000 	cmp	r3, #0
57e1b82c:	01a03001 	moveq	r3, r1
57e1b830:	11a03002 	movne	r3, r2
57e1b834:	e5843018 	str	r3, [r4, #24]
	if (!chip->scan_bbt)
57e1b838:	e5943040 	ldr	r3, [r4, #64]	; 0x40
	int i, maf_idx;
	u8 id_data[8];
	int ret;

	/* Select the device */
	chip->select_chip(mtd, 0);
57e1b83c:	e1a00005 	mov	r0, r5
		chip->write_buf = busw ? nand_write_buf16 : nand_write_buf;
	if (!chip->read_buf)
		chip->read_buf = busw ? nand_read_buf16 : nand_read_buf;
	if (!chip->verify_buf)
		chip->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
	if (!chip->scan_bbt)
57e1b840:	e3530000 	cmp	r3, #0
		chip->scan_bbt = nand_default_bbt;
57e1b844:	059f3654 	ldreq	r3, [pc, #1620]	; 57e1bea0 <nand_scan_ident+0x77c>
	int i, maf_idx;
	u8 id_data[8];
	int ret;

	/* Select the device */
	chip->select_chip(mtd, 0);
57e1b848:	e3a01000 	mov	r1, #0
	if (!chip->read_buf)
		chip->read_buf = busw ? nand_read_buf16 : nand_read_buf;
	if (!chip->verify_buf)
		chip->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
	if (!chip->scan_bbt)
		chip->scan_bbt = nand_default_bbt;
57e1b84c:	05843040 	streq	r3, [r4, #64]	; 0x40
	if (!chip->controller)
57e1b850:	e5943094 	ldr	r3, [r4, #148]	; 0x94
57e1b854:	e3530000 	cmp	r3, #0
		chip->controller = &chip->hwcontrol;
57e1b858:	028430ec 	addeq	r3, r4, #236	; 0xec
57e1b85c:	05843094 	streq	r3, [r4, #148]	; 0x94
	int i, maf_idx;
	u8 id_data[8];
	int ret;

	/* Select the device */
	chip->select_chip(mtd, 0);
57e1b860:	e594301c 	ldr	r3, [r4, #28]
57e1b864:	e12fff33 	blx	r3

	/*
	 * Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)
	 * after power-up
	 */
	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
57e1b868:	e3e02000 	mvn	r2, #0
57e1b86c:	e1a03002 	mov	r3, r2
57e1b870:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1b874:	e1a00005 	mov	r0, r5
57e1b878:	e3a010ff 	mov	r1, #255	; 0xff
57e1b87c:	e12fff3c 	blx	ip

	/* Send the command for reading device ID */
	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
57e1b880:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1b884:	e3a01090 	mov	r1, #144	; 0x90
57e1b888:	e3a02000 	mov	r2, #0
57e1b88c:	e1a00005 	mov	r0, r5
57e1b890:	e3e03000 	mvn	r3, #0
57e1b894:	e12fff3c 	blx	ip

	/* Read manufacturer and device IDs */
	*maf_id = chip->read_byte(mtd);
57e1b898:	e5943008 	ldr	r3, [r4, #8]
57e1b89c:	e1a00005 	mov	r0, r5
57e1b8a0:	e12fff33 	blx	r3
	*dev_id = chip->read_byte(mtd);
57e1b8a4:	e5943008 	ldr	r3, [r4, #8]

	/* Send the command for reading device ID */
	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);

	/* Read manufacturer and device IDs */
	*maf_id = chip->read_byte(mtd);
57e1b8a8:	e1a0b000 	mov	fp, r0
	*dev_id = chip->read_byte(mtd);
57e1b8ac:	e1a00005 	mov	r0, r5
57e1b8b0:	e12fff33 	blx	r3
	 * interface concerns can cause random data which looks like a
	 * possibly credible NAND flash to appear. If the two results do
	 * not match, ignore the device completely.
	 */

	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
57e1b8b4:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1b8b8:	e3a01090 	mov	r1, #144	; 0x90
57e1b8bc:	e3a02000 	mov	r2, #0
	/* Send the command for reading device ID */
	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);

	/* Read manufacturer and device IDs */
	*maf_id = chip->read_byte(mtd);
	*dev_id = chip->read_byte(mtd);
57e1b8c0:	e58d0018 	str	r0, [sp, #24]
	 * interface concerns can cause random data which looks like a
	 * possibly credible NAND flash to appear. If the two results do
	 * not match, ignore the device completely.
	 */

	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
57e1b8c4:	e3e03000 	mvn	r3, #0
57e1b8c8:	e1a00005 	mov	r0, r5
57e1b8cc:	e12fff3c 	blx	ip

	for (i = 0; i < 2; i++)
		id_data[i] = chip->read_byte(mtd);
57e1b8d0:	e5943008 	ldr	r3, [r4, #8]
57e1b8d4:	e1a00005 	mov	r0, r5
57e1b8d8:	e12fff33 	blx	r3
57e1b8dc:	e5cd0020 	strb	r0, [sp, #32]
57e1b8e0:	e5943008 	ldr	r3, [r4, #8]
57e1b8e4:	e1a00005 	mov	r0, r5
57e1b8e8:	e12fff33 	blx	r3

	if (id_data[0] != *maf_id || id_data[1] != *dev_id) {
57e1b8ec:	e5dd7020 	ldrb	r7, [sp, #32]
	 */

	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);

	for (i = 0; i < 2; i++)
		id_data[i] = chip->read_byte(mtd);
57e1b8f0:	e58d0014 	str	r0, [sp, #20]

	if (id_data[0] != *maf_id || id_data[1] != *dev_id) {
57e1b8f4:	e157000b 	cmp	r7, fp
	 */

	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);

	for (i = 0; i < 2; i++)
		id_data[i] = chip->read_byte(mtd);
57e1b8f8:	e5cd0021 	strb	r0, [sp, #33]	; 0x21

	if (id_data[0] != *maf_id || id_data[1] != *dev_id) {
57e1b8fc:	1a000002 	bne	57e1b90c <nand_scan_ident+0x1e8>
57e1b900:	e59d3018 	ldr	r3, [sp, #24]
57e1b904:	e1500003 	cmp	r0, r3
57e1b908:	0a000008 	beq	57e1b930 <nand_scan_ident+0x20c>
		printk(KERN_INFO "%s: second ID read did not match "
57e1b90c:	e59d2014 	ldr	r2, [sp, #20]
57e1b910:	e59f158c 	ldr	r1, [pc, #1420]	; 57e1bea4 <nand_scan_ident+0x780>
57e1b914:	e58d2004 	str	r2, [sp, #4]
57e1b918:	e59d3018 	ldr	r3, [sp, #24]
57e1b91c:	e1a0200b 	mov	r2, fp
57e1b920:	e59f0580 	ldr	r0, [pc, #1408]	; 57e1bea8 <nand_scan_ident+0x784>
57e1b924:	e58d7000 	str	r7, [sp]
57e1b928:	ebffb6c7 	bl	57e0944c <printf>
57e1b92c:	ea000112 	b	57e1bd7c <nand_scan_ident+0x658>
		       *maf_id, *dev_id, id_data[0], id_data[1]);
		return ERR_PTR(-ENODEV);
	}

	if (!type)
		type = nand_flash_ids;
57e1b930:	e59f3574 	ldr	r3, [pc, #1396]	; 57e1beac <nand_scan_ident+0x788>
57e1b934:	e3560000 	cmp	r6, #0
57e1b938:	01a06003 	moveq	r6, r3
57e1b93c:	ea000004 	b	57e1b954 <nand_scan_ident+0x230>

	for (; type->name != NULL; type++)
		if (*dev_id == type->id)
57e1b940:	e5963004 	ldr	r3, [r6, #4]
57e1b944:	e59d2014 	ldr	r2, [sp, #20]
57e1b948:	e1520003 	cmp	r2, r3
57e1b94c:	0a000003 	beq	57e1b960 <nand_scan_ident+0x23c>
	}

	if (!type)
		type = nand_flash_ids;

	for (; type->name != NULL; type++)
57e1b950:	e2866018 	add	r6, r6, #24
57e1b954:	e5963000 	ldr	r3, [r6]
57e1b958:	e3530000 	cmp	r3, #0
57e1b95c:	1afffff7 	bne	57e1b940 <nand_scan_ident+0x21c>
		if (*dev_id == type->id)
			break;

	chip->onfi_version = 0;
57e1b960:	e3a02000 	mov	r2, #0
57e1b964:	e5842088 	str	r2, [r4, #136]	; 0x88
		ret = nand_flash_detect_onfi(mtd, chip, &busw);
		if (ret)
			goto ident_done;
	}

	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
57e1b968:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1b96c:	e1a00005 	mov	r0, r5
57e1b970:	e3a01090 	mov	r1, #144	; 0x90
57e1b974:	e3e03000 	mvn	r3, #0
57e1b978:	e12fff3c 	blx	ip
57e1b97c:	e28da01f 	add	sl, sp, #31
 * This is the first phase of the normal nand_scan() function. It
 * reads the flash ID and sets up MTD fields accordingly.
 *
 * The mtd->owner field must be set to the module of the caller.
 */
int nand_scan_ident(struct mtd_info *mtd, int maxchips,
57e1b980:	e28d9027 	add	r9, sp, #39	; 0x27
	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);

	/* Read entire ID string */

	for (i = 0; i < 8; i++)
		id_data[i] = chip->read_byte(mtd);
57e1b984:	e5943008 	ldr	r3, [r4, #8]
57e1b988:	e1a00005 	mov	r0, r5
57e1b98c:	e12fff33 	blx	r3
57e1b990:	e5ea0001 	strb	r0, [sl, #1]!

	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);

	/* Read entire ID string */

	for (i = 0; i < 8; i++)
57e1b994:	e15a0009 	cmp	sl, r9
57e1b998:	1afffff9 	bne	57e1b984 <nand_scan_ident+0x260>
		id_data[i] = chip->read_byte(mtd);

	if (!type->name)
57e1b99c:	e5963000 	ldr	r3, [r6]
57e1b9a0:	e3530000 	cmp	r3, #0
57e1b9a4:	0a0000f4 	beq	57e1bd7c <nand_scan_ident+0x658>
		return ERR_PTR(-ENODEV);

	if (!mtd->name)
57e1b9a8:	e5952020 	ldr	r2, [r5, #32]
57e1b9ac:	e3520000 	cmp	r2, #0
		mtd->name = type->name;
57e1b9b0:	05853020 	streq	r3, [r5, #32]

	chip->chipsize = (uint64_t)type->chipsize << 20;
57e1b9b4:	e596300c 	ldr	r3, [r6, #12]
57e1b9b8:	e1a02623 	lsr	r2, r3, #12
57e1b9bc:	e1a03a03 	lsl	r3, r3, #20
57e1b9c0:	e5843068 	str	r3, [r4, #104]	; 0x68

	if (!type->pagesize && chip->init_size) {
57e1b9c4:	e5963008 	ldr	r3, [r6, #8]
		return ERR_PTR(-ENODEV);

	if (!mtd->name)
		mtd->name = type->name;

	chip->chipsize = (uint64_t)type->chipsize << 20;
57e1b9c8:	e584206c 	str	r2, [r4, #108]	; 0x6c

	if (!type->pagesize && chip->init_size) {
57e1b9cc:	e3530000 	cmp	r3, #0
57e1b9d0:	1a000047 	bne	57e1baf4 <nand_scan_ident+0x3d0>
57e1b9d4:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
57e1b9d8:	e3530000 	cmp	r3, #0
57e1b9dc:	0a000005 	beq	57e1b9f8 <nand_scan_ident+0x2d4>
		/* set the pagesize, oobsize, erasesize by the driver*/
		busw = chip->init_size(mtd, chip, id_data);
57e1b9e0:	e1a00005 	mov	r0, r5
57e1b9e4:	e1a01004 	mov	r1, r4
57e1b9e8:	e28d2020 	add	r2, sp, #32
57e1b9ec:	e12fff33 	blx	r3
57e1b9f0:	e1a0a000 	mov	sl, r0
57e1b9f4:	ea00005b 	b	57e1bb68 <nand_scan_ident+0x444>
	} else if (!type->pagesize) {
		int extid;
		/* The 3rd id byte holds MLC / multichip data */
		chip->cellinfo = id_data[2];
57e1b9f8:	e5dd3022 	ldrb	r3, [sp, #34]	; 0x22
57e1b9fc:	e5c4307c 	strb	r3, [r4, #124]	; 0x7c
		 * New style   (6 byte ID): Samsung K9GBG08U0M (p.40)
		 *
		 * Check for wraparound + Samsung ID + nonzero 6th byte
		 * to decide what to do.
		 */
		if (id_data[0] == id_data[6] && id_data[1] == id_data[7] &&
57e1ba00:	e5dd1020 	ldrb	r1, [sp, #32]
57e1ba04:	e5dd2026 	ldrb	r2, [sp, #38]	; 0x26
	} else if (!type->pagesize) {
		int extid;
		/* The 3rd id byte holds MLC / multichip data */
		chip->cellinfo = id_data[2];
		/* The 4th id byte is the important one */
		extid = id_data[3];
57e1ba08:	e5dda023 	ldrb	sl, [sp, #35]	; 0x23
		 * New style   (6 byte ID): Samsung K9GBG08U0M (p.40)
		 *
		 * Check for wraparound + Samsung ID + nonzero 6th byte
		 * to decide what to do.
		 */
		if (id_data[0] == id_data[6] && id_data[1] == id_data[7] &&
57e1ba0c:	e1520001 	cmp	r2, r1
57e1ba10:	1a000023 	bne	57e1baa4 <nand_scan_ident+0x380>
57e1ba14:	e5dd0021 	ldrb	r0, [sp, #33]	; 0x21
57e1ba18:	e5dd1027 	ldrb	r1, [sp, #39]	; 0x27
57e1ba1c:	e1500001 	cmp	r0, r1
57e1ba20:	1a00001f 	bne	57e1baa4 <nand_scan_ident+0x380>
57e1ba24:	e35200ec 	cmp	r2, #236	; 0xec
57e1ba28:	1a00001d 	bne	57e1baa4 <nand_scan_ident+0x380>
				id_data[0] == NAND_MFR_SAMSUNG &&
57e1ba2c:	e313000c 	tst	r3, #12
57e1ba30:	0a00001b 	beq	57e1baa4 <nand_scan_ident+0x380>
				(chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
57e1ba34:	e5dd3025 	ldrb	r3, [sp, #37]	; 0x25
57e1ba38:	e3530000 	cmp	r3, #0
57e1ba3c:	0a000018 	beq	57e1baa4 <nand_scan_ident+0x380>
				id_data[5] != 0x00) {
			/* Calc pagesize */
			mtd->writesize = 2048 << (extid & 0x03);
57e1ba40:	e20a3003 	and	r3, sl, #3
57e1ba44:	e3a02b02 	mov	r2, #2048	; 0x800
57e1ba48:	e1a03312 	lsl	r3, r2, r3
			extid >>= 2;
57e1ba4c:	e1a0a14a 	asr	sl, sl, #2
		if (id_data[0] == id_data[6] && id_data[1] == id_data[7] &&
				id_data[0] == NAND_MFR_SAMSUNG &&
				(chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
				id_data[5] != 0x00) {
			/* Calc pagesize */
			mtd->writesize = 2048 << (extid & 0x03);
57e1ba50:	e5853014 	str	r3, [r5, #20]
			extid >>= 2;
			/* Calc oobsize */
			switch (extid & 0x03) {
57e1ba54:	e20a3003 	and	r3, sl, #3
57e1ba58:	e3530002 	cmp	r3, #2
			case 1:
				mtd->oobsize = 128;
				break;
			case 2:
				mtd->oobsize = 218;
57e1ba5c:	03a030da 	moveq	r3, #218	; 0xda
				id_data[5] != 0x00) {
			/* Calc pagesize */
			mtd->writesize = 2048 << (extid & 0x03);
			extid >>= 2;
			/* Calc oobsize */
			switch (extid & 0x03) {
57e1ba60:	0a000005 	beq	57e1ba7c <nand_scan_ident+0x358>
57e1ba64:	e3530003 	cmp	r3, #3
				break;
			case 2:
				mtd->oobsize = 218;
				break;
			case 3:
				mtd->oobsize = 400;
57e1ba68:	03a03e19 	moveq	r3, #400	; 0x190
				id_data[5] != 0x00) {
			/* Calc pagesize */
			mtd->writesize = 2048 << (extid & 0x03);
			extid >>= 2;
			/* Calc oobsize */
			switch (extid & 0x03) {
57e1ba6c:	0a000002 	beq	57e1ba7c <nand_scan_ident+0x358>
57e1ba70:	e3530001 	cmp	r3, #1
			case 1:
				mtd->oobsize = 128;
57e1ba74:	0283307f 	addeq	r3, r3, #127	; 0x7f
				break;
			case 3:
				mtd->oobsize = 400;
				break;
			default:
				mtd->oobsize = 436;
57e1ba78:	13a03f6d 	movne	r3, #436	; 0x1b4
57e1ba7c:	e5853018 	str	r3, [r5, #24]
				break;
			}
			extid >>= 2;
			/* Calc blocksize */
			mtd->erasesize = (128 * 1024) <<
				(((extid >> 1) & 0x04) | (extid & 0x03));
57e1ba80:	e1a031ca 	asr	r3, sl, #3
57e1ba84:	e2033004 	and	r3, r3, #4
57e1ba88:	e1a0ae0a 	lsl	sl, sl, #28
57e1ba8c:	e183af2a 	orr	sl, r3, sl, lsr #30
				mtd->oobsize = 436;
				break;
			}
			extid >>= 2;
			/* Calc blocksize */
			mtd->erasesize = (128 * 1024) <<
57e1ba90:	e3a03802 	mov	r3, #131072	; 0x20000
57e1ba94:	e1a0aa13 	lsl	sl, r3, sl
57e1ba98:	e585a010 	str	sl, [r5, #16]
				(((extid >> 1) & 0x04) | (extid & 0x03));
			busw = 0;
57e1ba9c:	e3a0a000 	mov	sl, #0
57e1baa0:	ea000030 	b	57e1bb68 <nand_scan_ident+0x444>
		} else {
			/* Calc pagesize */
			mtd->writesize = 1024 << (extid & 0x03);
57e1baa4:	e20a3003 	and	r3, sl, #3
57e1baa8:	e3a02b01 	mov	r2, #1024	; 0x400
57e1baac:	e1a03312 	lsl	r3, r2, r3
			extid >>= 2;
57e1bab0:	e1a0214a 	asr	r2, sl, #2
			/* Calc oobsize */
			mtd->oobsize = (8 << (extid & 0x01)) *
57e1bab4:	e2022001 	and	r2, r2, #1
57e1bab8:	e3a01008 	mov	r1, #8
57e1babc:	e1a02211 	lsl	r2, r1, r2
			mtd->erasesize = (128 * 1024) <<
				(((extid >> 1) & 0x04) | (extid & 0x03));
			busw = 0;
		} else {
			/* Calc pagesize */
			mtd->writesize = 1024 << (extid & 0x03);
57e1bac0:	e5853014 	str	r3, [r5, #20]
			extid >>= 2;
			/* Calc oobsize */
			mtd->oobsize = (8 << (extid & 0x01)) *
				(mtd->writesize >> 9);
57e1bac4:	e1a034a3 	lsr	r3, r3, #9
		} else {
			/* Calc pagesize */
			mtd->writesize = 1024 << (extid & 0x03);
			extid >>= 2;
			/* Calc oobsize */
			mtd->oobsize = (8 << (extid & 0x01)) *
57e1bac8:	e0030392 	mul	r3, r2, r3
57e1bacc:	e5853018 	str	r3, [r5, #24]
				(mtd->writesize >> 9);
			extid >>= 2;
57e1bad0:	e1a0324a 	asr	r3, sl, #4
			/* Calc blocksize. Blocksize is multiples of 64KiB */
			mtd->erasesize = (64 * 1024) << (extid & 0x03);
57e1bad4:	e2033003 	and	r3, r3, #3
57e1bad8:	e3a02801 	mov	r2, #65536	; 0x10000
57e1badc:	e1a03312 	lsl	r3, r2, r3
			extid >>= 2;
57e1bae0:	e1a0a34a 	asr	sl, sl, #6
			/* Get buswidth information */
			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
57e1bae4:	e21aa001 	ands	sl, sl, #1
			/* Calc oobsize */
			mtd->oobsize = (8 << (extid & 0x01)) *
				(mtd->writesize >> 9);
			extid >>= 2;
			/* Calc blocksize. Blocksize is multiples of 64KiB */
			mtd->erasesize = (64 * 1024) << (extid & 0x03);
57e1bae8:	e5853010 	str	r3, [r5, #16]
			extid >>= 2;
			/* Get buswidth information */
			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
57e1baec:	13a0a002 	movne	sl, #2
57e1baf0:	ea00001c 	b	57e1bb68 <nand_scan_ident+0x444>
		}
	} else {
		/*
		 * Old devices have chip data hardcoded in the device id table
		 */
		mtd->erasesize = type->erasesize;
57e1baf4:	e5962010 	ldr	r2, [r6, #16]
		mtd->writesize = type->pagesize;
		mtd->oobsize = mtd->writesize / 32;
		busw = type->options & NAND_BUSWIDTH_16;
57e1baf8:	e596a014 	ldr	sl, [r6, #20]
		}
	} else {
		/*
		 * Old devices have chip data hardcoded in the device id table
		 */
		mtd->erasesize = type->erasesize;
57e1bafc:	e5852010 	str	r2, [r5, #16]
		 * Check for Spansion/AMD ID + repeating 5th, 6th byte since
		 * some Spansion chips have erasesize that conflicts with size
		 * listed in nand_ids table
		 * Data sheet (5 byte ID): Spansion S30ML-P ORNAND (p.39)
		 */
		if (*maf_id == NAND_MFR_AMD && id_data[4] != 0x00 &&
57e1bb00:	e3570001 	cmp	r7, #1
		/*
		 * Old devices have chip data hardcoded in the device id table
		 */
		mtd->erasesize = type->erasesize;
		mtd->writesize = type->pagesize;
		mtd->oobsize = mtd->writesize / 32;
57e1bb04:	e1a022a3 	lsr	r2, r3, #5
	} else {
		/*
		 * Old devices have chip data hardcoded in the device id table
		 */
		mtd->erasesize = type->erasesize;
		mtd->writesize = type->pagesize;
57e1bb08:	e5853014 	str	r3, [r5, #20]
		mtd->oobsize = mtd->writesize / 32;
57e1bb0c:	e5852018 	str	r2, [r5, #24]
		busw = type->options & NAND_BUSWIDTH_16;
57e1bb10:	e20aa002 	and	sl, sl, #2
		 * Check for Spansion/AMD ID + repeating 5th, 6th byte since
		 * some Spansion chips have erasesize that conflicts with size
		 * listed in nand_ids table
		 * Data sheet (5 byte ID): Spansion S30ML-P ORNAND (p.39)
		 */
		if (*maf_id == NAND_MFR_AMD && id_data[4] != 0x00 &&
57e1bb14:	1a000013 	bne	57e1bb68 <nand_scan_ident+0x444>
57e1bb18:	e5dd2024 	ldrb	r2, [sp, #36]	; 0x24
57e1bb1c:	e3520000 	cmp	r2, #0
57e1bb20:	0a000010 	beq	57e1bb68 <nand_scan_ident+0x444>
57e1bb24:	e5dd2025 	ldrb	r2, [sp, #37]	; 0x25
57e1bb28:	e3520000 	cmp	r2, #0
57e1bb2c:	1a00000d 	bne	57e1bb68 <nand_scan_ident+0x444>
				id_data[5] == 0x00 && id_data[6] == 0x00 &&
57e1bb30:	e5dd2026 	ldrb	r2, [sp, #38]	; 0x26
57e1bb34:	e3520000 	cmp	r2, #0
57e1bb38:	1a00000a 	bne	57e1bb68 <nand_scan_ident+0x444>
57e1bb3c:	e5dd2027 	ldrb	r2, [sp, #39]	; 0x27
57e1bb40:	e3520000 	cmp	r2, #0
57e1bb44:	1a000007 	bne	57e1bb68 <nand_scan_ident+0x444>
				id_data[7] == 0x00 && mtd->writesize == 512) {
57e1bb48:	e3530c02 	cmp	r3, #512	; 0x200
57e1bb4c:	1a000005 	bne	57e1bb68 <nand_scan_ident+0x444>
			mtd->erasesize = 128 * 1024;
			mtd->erasesize <<= ((id_data[3] & 0x03) << 1);
57e1bb50:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
57e1bb54:	e2822802 	add	r2, r2, #131072	; 0x20000
57e1bb58:	e2033003 	and	r3, r3, #3
57e1bb5c:	e1a03083 	lsl	r3, r3, #1
57e1bb60:	e1a03312 	lsl	r3, r2, r3
57e1bb64:	e5853010 	str	r3, [r5, #16]
		}
	}
	/* Get chip options, preserve non chip based options */
	chip->options |= type->options;
57e1bb68:	e5962014 	ldr	r2, [r6, #20]
57e1bb6c:	e5943050 	ldr	r3, [r4, #80]	; 0x50

	/* Check if chip is a not a samsung device. Do not clear the
	 * options for chips which are not having an extended id.
	 */
	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
57e1bb70:	e35700ec 	cmp	r7, #236	; 0xec
			mtd->erasesize = 128 * 1024;
			mtd->erasesize <<= ((id_data[3] & 0x03) << 1);
		}
	}
	/* Get chip options, preserve non chip based options */
	chip->options |= type->options;
57e1bb74:	e1823003 	orr	r3, r2, r3
57e1bb78:	e5843050 	str	r3, [r4, #80]	; 0x50

	/* Check if chip is a not a samsung device. Do not clear the
	 * options for chips which are not having an extended id.
	 */
	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
57e1bb7c:	0a000003 	beq	57e1bb90 <nand_scan_ident+0x46c>
57e1bb80:	e5962008 	ldr	r2, [r6, #8]
57e1bb84:	e3520000 	cmp	r2, #0
		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
57e1bb88:	03c3301c 	biceq	r3, r3, #28
57e1bb8c:	05843050 	streq	r3, [r4, #80]	; 0x50
ident_done:

	/*
	 * Set chip as a default. Board drivers can override it, if necessary
	 */
	chip->options |= NAND_NO_AUTOINCR;
57e1bb90:	e5949050 	ldr	r9, [r4, #80]	; 0x50

	/* Try to identify manufacturer */
	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
57e1bb94:	e3a03000 	mov	r3, #0
ident_done:

	/*
	 * Set chip as a default. Board drivers can override it, if necessary
	 */
	chip->options |= NAND_NO_AUTOINCR;
57e1bb98:	e3899001 	orr	r9, r9, #1
57e1bb9c:	e5849050 	str	r9, [r4, #80]	; 0x50

	/* Try to identify manufacturer */
	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
57e1bba0:	e59f1308 	ldr	r1, [pc, #776]	; 57e1beb0 <nand_scan_ident+0x78c>
57e1bba4:	ea000002 	b	57e1bbb4 <nand_scan_ident+0x490>
		if (nand_manuf_ids[maf_idx].id == *maf_id)
57e1bba8:	e1520007 	cmp	r2, r7
57e1bbac:	0a000003 	beq	57e1bbc0 <nand_scan_ident+0x49c>
	 * Set chip as a default. Board drivers can override it, if necessary
	 */
	chip->options |= NAND_NO_AUTOINCR;

	/* Try to identify manufacturer */
	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
57e1bbb0:	e2833001 	add	r3, r3, #1
57e1bbb4:	e7912183 	ldr	r2, [r1, r3, lsl #3]
57e1bbb8:	e3520000 	cmp	r2, #0
57e1bbbc:	1afffff9 	bne	57e1bba8 <nand_scan_ident+0x484>

	/*
	 * Check, if buswidth is correct. Hardware drivers should set
	 * chip correct !
	 */
	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
57e1bbc0:	e2092002 	and	r2, r9, #2
57e1bbc4:	e15a0002 	cmp	sl, r2
57e1bbc8:	0a000013 	beq	57e1bc1c <nand_scan_ident+0x4f8>
		printk(KERN_INFO "NAND device: Manufacturer ID:"
57e1bbcc:	e59f22dc 	ldr	r2, [pc, #732]	; 57e1beb0 <nand_scan_ident+0x78c>
57e1bbd0:	e1a01007 	mov	r1, r7
57e1bbd4:	e0823183 	add	r3, r2, r3, lsl #3
57e1bbd8:	e5952020 	ldr	r2, [r5, #32]
57e1bbdc:	e5933004 	ldr	r3, [r3, #4]
57e1bbe0:	e58d2000 	str	r2, [sp]
57e1bbe4:	e59f02c8 	ldr	r0, [pc, #712]	; 57e1beb4 <nand_scan_ident+0x790>
57e1bbe8:	e59d2014 	ldr	r2, [sp, #20]
57e1bbec:	ebffb616 	bl	57e0944c <printf>
		       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
		       *dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
		       (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
57e1bbf0:	e5943050 	ldr	r3, [r4, #80]	; 0x50
	 */
	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
		printk(KERN_INFO "NAND device: Manufacturer ID:"
		       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
		       *dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
57e1bbf4:	e59f02bc 	ldr	r0, [pc, #700]	; 57e1beb8 <nand_scan_ident+0x794>
57e1bbf8:	e3130002 	tst	r3, #2
57e1bbfc:	03a01008 	moveq	r1, #8
57e1bc00:	13a01010 	movne	r1, #16
57e1bc04:	e35a0000 	cmp	sl, #0
57e1bc08:	03a02008 	moveq	r2, #8
57e1bc0c:	13a02010 	movne	r2, #16
57e1bc10:	ebffb60d 	bl	57e0944c <printf>
		       (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
		       busw ? 16 : 8);
		return ERR_PTR(-EINVAL);
57e1bc14:	e3e07015 	mvn	r7, #21
57e1bc18:	ea00005d 	b	57e1bd94 <nand_scan_ident+0x670>
	}

	/* Calculate the address shift from the page size */
	chip->page_shift = ffs(mtd->writesize) - 1;
57e1bc1c:	e5953014 	ldr	r3, [r5, #20]
57e1bc20:	e1a00003 	mov	r0, r3
57e1bc24:	e58d3014 	str	r3, [sp, #20]
57e1bc28:	ebfff2ae 	bl	57e186e8 <generic_ffs>
	/* Convert chipsize to number of pages per chip -1. */
	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;
57e1bc2c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
57e1bc30:	e594c06c 	ldr	ip, [r4, #108]	; 0x6c
		       busw ? 16 : 8);
		return ERR_PTR(-EINVAL);
	}

	/* Calculate the address shift from the page size */
	chip->page_shift = ffs(mtd->writesize) - 1;
57e1bc34:	e2402001 	sub	r2, r0, #1
57e1bc38:	e5842054 	str	r2, [r4, #84]	; 0x54
	/* Convert chipsize to number of pages per chip -1. */
	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;
57e1bc3c:	e1a00003 	mov	r0, r3
57e1bc40:	e1a0100c 	mov	r1, ip
57e1bc44:	e58d3010 	str	r3, [sp, #16]
57e1bc48:	e58dc00c 	str	ip, [sp, #12]
57e1bc4c:	eb003fea 	bl	57e2bbfc <__lshrdi3>
57e1bc50:	e2400001 	sub	r0, r0, #1
57e1bc54:	e5840070 	str	r0, [r4, #112]	; 0x70

	chip->bbt_erase_shift = chip->phys_erase_shift =
		ffs(mtd->erasesize) - 1;
57e1bc58:	e5950010 	ldr	r0, [r5, #16]
57e1bc5c:	ebfff2a1 	bl	57e186e8 <generic_ffs>
	if (chip->chipsize & 0xffffffff)
57e1bc60:	e59d3010 	ldr	r3, [sp, #16]
	chip->page_shift = ffs(mtd->writesize) - 1;
	/* Convert chipsize to number of pages per chip -1. */
	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;

	chip->bbt_erase_shift = chip->phys_erase_shift =
		ffs(mtd->erasesize) - 1;
57e1bc64:	e2400001 	sub	r0, r0, #1
	if (chip->chipsize & 0xffffffff)
57e1bc68:	e3530000 	cmp	r3, #0
	/* Calculate the address shift from the page size */
	chip->page_shift = ffs(mtd->writesize) - 1;
	/* Convert chipsize to number of pages per chip -1. */
	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;

	chip->bbt_erase_shift = chip->phys_erase_shift =
57e1bc6c:	e5840058 	str	r0, [r4, #88]	; 0x58
57e1bc70:	e584005c 	str	r0, [r4, #92]	; 0x5c
		ffs(mtd->erasesize) - 1;
	if (chip->chipsize & 0xffffffff)
57e1bc74:	e59dc00c 	ldr	ip, [sp, #12]
57e1bc78:	0a000003 	beq	57e1bc8c <nand_scan_ident+0x568>
		chip->chip_shift = ffs((unsigned)chip->chipsize) - 1;
57e1bc7c:	e1a00003 	mov	r0, r3
57e1bc80:	ebfff298 	bl	57e186e8 <generic_ffs>
57e1bc84:	e2400001 	sub	r0, r0, #1
57e1bc88:	ea000002 	b	57e1bc98 <nand_scan_ident+0x574>
	else {
		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32));
57e1bc8c:	e1a0000c 	mov	r0, ip
57e1bc90:	ebfff294 	bl	57e186e8 <generic_ffs>
		chip->chip_shift += 32 - 1;
57e1bc94:	e280001f 	add	r0, r0, #31
	}

	chip->badblockbits = 8;

	/* Set the bad block position */
	if (mtd->writesize > 512 || (busw & NAND_BUSWIDTH_16))
57e1bc98:	e59d2014 	ldr	r2, [sp, #20]
	else {
		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32));
		chip->chip_shift += 32 - 1;
	}

	chip->badblockbits = 8;
57e1bc9c:	e3a03008 	mov	r3, #8

	/* Set the bad block position */
	if (mtd->writesize > 512 || (busw & NAND_BUSWIDTH_16))
57e1bca0:	e3520c02 	cmp	r2, #512	; 0x200
		ffs(mtd->erasesize) - 1;
	if (chip->chipsize & 0xffffffff)
		chip->chip_shift = ffs((unsigned)chip->chipsize) - 1;
	else {
		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32));
		chip->chip_shift += 32 - 1;
57e1bca4:	e5840060 	str	r0, [r4, #96]	; 0x60
	}

	chip->badblockbits = 8;
57e1bca8:	e5843084 	str	r3, [r4, #132]	; 0x84

	/* Set the bad block position */
	if (mtd->writesize > 512 || (busw & NAND_BUSWIDTH_16))
57e1bcac:	8a000002 	bhi	57e1bcbc <nand_scan_ident+0x598>
57e1bcb0:	e31a0002 	tst	sl, #2
		chip->badblockpos = NAND_LARGE_BADBLOCK_POS;
	else
		chip->badblockpos = NAND_SMALL_BADBLOCK_POS;
57e1bcb4:	03a03005 	moveq	r3, #5
	}

	chip->badblockbits = 8;

	/* Set the bad block position */
	if (mtd->writesize > 512 || (busw & NAND_BUSWIDTH_16))
57e1bcb8:	0a000000 	beq	57e1bcc0 <nand_scan_ident+0x59c>
		chip->badblockpos = NAND_LARGE_BADBLOCK_POS;
57e1bcbc:	e3a03000 	mov	r3, #0
	else
		chip->badblockpos = NAND_SMALL_BADBLOCK_POS;
57e1bcc0:	e5843080 	str	r3, [r4, #128]	; 0x80
	 * on Samsung and Hynix MLC devices; stored in first two pages
	 * of each block on Micron devices with 2KiB pages and on
	 * SLC Samsung, Hynix, Toshiba and AMD/Spansion. All others scan
	 * only the first page.
	 */
	if ((chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
57e1bcc4:	e5d4307c 	ldrb	r3, [r4, #124]	; 0x7c
57e1bcc8:	e313000c 	tst	r3, #12
57e1bccc:	0a000004 	beq	57e1bce4 <nand_scan_ident+0x5c0>
57e1bcd0:	e35700ec 	cmp	r7, #236	; 0xec
57e1bcd4:	135700ad 	cmpne	r7, #173	; 0xad
			(*maf_id == NAND_MFR_SAMSUNG ||
			 *maf_id == NAND_MFR_HYNIX))
		chip->options |= NAND_BBT_SCANLASTPAGE;
57e1bcd8:	03899902 	orreq	r9, r9, #32768	; 0x8000
	 * on Samsung and Hynix MLC devices; stored in first two pages
	 * of each block on Micron devices with 2KiB pages and on
	 * SLC Samsung, Hynix, Toshiba and AMD/Spansion. All others scan
	 * only the first page.
	 */
	if ((chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
57e1bcdc:	0a00000d 	beq	57e1bd18 <nand_scan_ident+0x5f4>
57e1bce0:	ea000006 	b	57e1bd00 <nand_scan_ident+0x5dc>
			(*maf_id == NAND_MFR_SAMSUNG ||
			 *maf_id == NAND_MFR_HYNIX))
		chip->options |= NAND_BBT_SCANLASTPAGE;
	else if ((!(chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
57e1bce4:	e35b00ec 	cmp	fp, #236	; 0xec
57e1bce8:	135b00ad 	cmpne	fp, #173	; 0xad
57e1bcec:	0a000008 	beq	57e1bd14 <nand_scan_ident+0x5f0>
				(*maf_id == NAND_MFR_SAMSUNG ||
				 *maf_id == NAND_MFR_HYNIX ||
57e1bcf0:	e35b0098 	cmp	fp, #152	; 0x98
57e1bcf4:	0a000006 	beq	57e1bd14 <nand_scan_ident+0x5f0>
				 *maf_id == NAND_MFR_TOSHIBA ||
57e1bcf8:	e35b0001 	cmp	fp, #1
57e1bcfc:	0a000004 	beq	57e1bd14 <nand_scan_ident+0x5f0>
				 *maf_id == NAND_MFR_AMD)) ||
57e1bd00:	e59d3014 	ldr	r3, [sp, #20]
57e1bd04:	e3530b02 	cmp	r3, #2048	; 0x800
57e1bd08:	1a000003 	bne	57e1bd1c <nand_scan_ident+0x5f8>
			(mtd->writesize == 2048 &&
57e1bd0c:	e357002c 	cmp	r7, #44	; 0x2c
57e1bd10:	1a000001 	bne	57e1bd1c <nand_scan_ident+0x5f8>
			 *maf_id == NAND_MFR_MICRON))
		chip->options |= NAND_BBT_SCAN2NDPAGE;
57e1bd14:	e3899901 	orr	r9, r9, #16384	; 0x4000
57e1bd18:	e5849050 	str	r9, [r4, #80]	; 0x50

	/*
	 * Numonyx/ST 2K pages, x8 bus use BOTH byte 1 and 6
	 */
	if (!(busw & NAND_BUSWIDTH_16) &&
57e1bd1c:	e21aa002 	ands	sl, sl, #2
57e1bd20:	1a000007 	bne	57e1bd44 <nand_scan_ident+0x620>
57e1bd24:	e3570020 	cmp	r7, #32
57e1bd28:	1a000005 	bne	57e1bd44 <nand_scan_ident+0x620>
			*maf_id == NAND_MFR_STMICRO &&
57e1bd2c:	e5953014 	ldr	r3, [r5, #20]
57e1bd30:	e3530b02 	cmp	r3, #2048	; 0x800
			mtd->writesize == 2048) {
		chip->options |= NAND_BBT_SCANBYTE1AND6;
57e1bd34:	05943050 	ldreq	r3, [r4, #80]	; 0x50
		chip->badblockpos = 0;
57e1bd38:	0584a080 	streq	sl, [r4, #128]	; 0x80
	 * Numonyx/ST 2K pages, x8 bus use BOTH byte 1 and 6
	 */
	if (!(busw & NAND_BUSWIDTH_16) &&
			*maf_id == NAND_MFR_STMICRO &&
			mtd->writesize == 2048) {
		chip->options |= NAND_BBT_SCANBYTE1AND6;
57e1bd3c:	03833601 	orreq	r3, r3, #1048576	; 0x100000
57e1bd40:	05843050 	streq	r3, [r4, #80]	; 0x50
		chip->badblockpos = 0;
	}

	/* Check for AND chips with 4 page planes */
	if (chip->options & NAND_4PAGE_ARRAY)
57e1bd44:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1bd48:	e3130040 	tst	r3, #64	; 0x40
		chip->erase_cmd = multi_erase_cmd;
57e1bd4c:	159f3168 	ldrne	r3, [pc, #360]	; 57e1bebc <nand_scan_ident+0x798>
	else
		chip->erase_cmd = single_erase_cmd;
57e1bd50:	059f3168 	ldreq	r3, [pc, #360]	; 57e1bec0 <nand_scan_ident+0x79c>
57e1bd54:	e584303c 	str	r3, [r4, #60]	; 0x3c

	/* Do not replace user supplied command function ! */
	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
57e1bd58:	e5953014 	ldr	r3, [r5, #20]
57e1bd5c:	e3530c02 	cmp	r3, #512	; 0x200
57e1bd60:	9a000007 	bls	57e1bd84 <nand_scan_ident+0x660>
57e1bd64:	e59f30fc 	ldr	r3, [pc, #252]	; 57e1be68 <nand_scan_ident+0x744>
57e1bd68:	e5942034 	ldr	r2, [r4, #52]	; 0x34
57e1bd6c:	e1520003 	cmp	r2, r3
		chip->cmdfunc = nand_command_lp;
57e1bd70:	059f314c 	ldreq	r3, [pc, #332]	; 57e1bec4 <nand_scan_ident+0x7a0>
57e1bd74:	05843034 	streq	r3, [r4, #52]	; 0x34
57e1bd78:	ea000001 	b	57e1bd84 <nand_scan_ident+0x660>

	for (i = 0; i < 8; i++)
		id_data[i] = chip->read_byte(mtd);

	if (!type->name)
		return ERR_PTR(-ENODEV);
57e1bd7c:	e3e07012 	mvn	r7, #18
57e1bd80:	ea000003 	b	57e1bd94 <nand_scan_ident+0x670>

	/* Read the flash type */
	type = nand_get_flash_type(mtd, chip, busw,
				&nand_maf_id, &nand_dev_id, table);

	if (IS_ERR(type)) {
57e1bd84:	e3760a01 	cmn	r6, #4096	; 0x1000
		chip->erase_cmd = multi_erase_cmd;
	else
		chip->erase_cmd = single_erase_cmd;

	/* Do not replace user supplied command function ! */
	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
57e1bd88:	e1a07006 	mov	r7, r6

	/* Read the flash type */
	type = nand_get_flash_type(mtd, chip, busw,
				&nand_maf_id, &nand_dev_id, table);

	if (IS_ERR(type)) {
57e1bd8c:	93a06001 	movls	r6, #1
57e1bd90:	9a000023 	bls	57e1be24 <nand_scan_ident+0x700>
#ifndef CONFIG_SYS_NAND_QUIET_TEST
		printk(KERN_WARNING "No NAND device found!!!\n");
57e1bd94:	e59f012c 	ldr	r0, [pc, #300]	; 57e1bec8 <nand_scan_ident+0x7a4>
57e1bd98:	ebffb5ab 	bl	57e0944c <printf>
#endif
		chip->select_chip(mtd, -1);
57e1bd9c:	e1a00005 	mov	r0, r5
57e1bda0:	e594301c 	ldr	r3, [r4, #28]
57e1bda4:	e3e01000 	mvn	r1, #0
57e1bda8:	e12fff33 	blx	r3
	return (void *) error;
}

static inline long PTR_ERR(const void *ptr)
{
	return (long) ptr;
57e1bdac:	e1a00007 	mov	r0, r7
		return PTR_ERR(type);
57e1bdb0:	ea00002a 	b	57e1be60 <nand_scan_ident+0x73c>
	}

	/* Check for a chip array */
	for (i = 1; i < maxchips; i++) {
		chip->select_chip(mtd, i);
57e1bdb4:	e594301c 	ldr	r3, [r4, #28]
57e1bdb8:	e1a00005 	mov	r0, r5
57e1bdbc:	e1a01006 	mov	r1, r6
57e1bdc0:	e12fff33 	blx	r3
		/* See comment in nand_get_flash_type for reset */
		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
57e1bdc4:	e3e02000 	mvn	r2, #0
57e1bdc8:	e1a03002 	mov	r3, r2
57e1bdcc:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1bdd0:	e1a00005 	mov	r0, r5
57e1bdd4:	e3a010ff 	mov	r1, #255	; 0xff
57e1bdd8:	e12fff3c 	blx	ip
		/* Send the command for reading device ID */
		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
57e1bddc:	e594c034 	ldr	ip, [r4, #52]	; 0x34
57e1bde0:	e1a00005 	mov	r0, r5
57e1bde4:	e3a01090 	mov	r1, #144	; 0x90
57e1bde8:	e3a02000 	mov	r2, #0
57e1bdec:	e3e03000 	mvn	r3, #0
57e1bdf0:	e12fff3c 	blx	ip
		/* Read manufacturer and device IDs */
		if (nand_maf_id != chip->read_byte(mtd) ||
57e1bdf4:	e5943008 	ldr	r3, [r4, #8]
57e1bdf8:	e1a00005 	mov	r0, r5
57e1bdfc:	e12fff33 	blx	r3
57e1be00:	e15b0000 	cmp	fp, r0
57e1be04:	1a000009 	bne	57e1be30 <nand_scan_ident+0x70c>
		    nand_dev_id != chip->read_byte(mtd))
57e1be08:	e5943008 	ldr	r3, [r4, #8]
57e1be0c:	e1a00005 	mov	r0, r5
57e1be10:	e12fff33 	blx	r3
		/* See comment in nand_get_flash_type for reset */
		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
		/* Send the command for reading device ID */
		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
		/* Read manufacturer and device IDs */
		if (nand_maf_id != chip->read_byte(mtd) ||
57e1be14:	e59d2018 	ldr	r2, [sp, #24]
57e1be18:	e1520000 	cmp	r2, r0
57e1be1c:	1a000003 	bne	57e1be30 <nand_scan_ident+0x70c>
		chip->select_chip(mtd, -1);
		return PTR_ERR(type);
	}

	/* Check for a chip array */
	for (i = 1; i < maxchips; i++) {
57e1be20:	e2866001 	add	r6, r6, #1
57e1be24:	e59d301c 	ldr	r3, [sp, #28]
57e1be28:	e1560003 	cmp	r6, r3
57e1be2c:	baffffe0 	blt	57e1bdb4 <nand_scan_ident+0x690>
		printk(KERN_INFO "%d NAND chips detected\n", i);
#endif

	/* Store the number of chips and calc total size for mtd */
	chip->numchips = i;
	mtd->size = i * chip->chipsize;
57e1be30:	e594106c 	ldr	r1, [r4, #108]	; 0x6c
57e1be34:	e5942068 	ldr	r2, [r4, #104]	; 0x68
57e1be38:	e0010196 	mul	r1, r6, r1
57e1be3c:	e1a0a006 	mov	sl, r6
57e1be40:	e1a0bfca 	asr	fp, sl, #31
	if (i > 1)
		printk(KERN_INFO "%d NAND chips detected\n", i);
#endif

	/* Store the number of chips and calc total size for mtd */
	chip->numchips = i;
57e1be44:	e5846064 	str	r6, [r4, #100]	; 0x64
	mtd->size = i * chip->chipsize;
57e1be48:	e0211b92 	mla	r1, r2, fp, r1
57e1be4c:	e0843692 	umull	r3, r4, r2, r6
57e1be50:	e0814004 	add	r4, r1, r4
57e1be54:	e5853008 	str	r3, [r5, #8]
57e1be58:	e585400c 	str	r4, [r5, #12]

	return 0;
57e1be5c:	e3a00000 	mov	r0, #0
}
57e1be60:	e28dd028 	add	sp, sp, #40	; 0x28
57e1be64:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1be68:	57e1aecc 	.word	0x57e1aecc
57e1be6c:	57e1a654 	.word	0x57e1a654
57e1be70:	57e19900 	.word	0x57e19900
57e1be74:	57e18760 	.word	0x57e18760
57e1be78:	57e18774 	.word	0x57e18774
57e1be7c:	57e18788 	.word	0x57e18788
57e1be80:	57e19afc 	.word	0x57e19afc
57e1be84:	57e1a4d4 	.word	0x57e1a4d4
57e1be88:	57e18798 	.word	0x57e18798
57e1be8c:	57e18834 	.word	0x57e18834
57e1be90:	57e187c4 	.word	0x57e187c4
57e1be94:	57e18864 	.word	0x57e18864
57e1be98:	57e18890 	.word	0x57e18890
57e1be9c:	57e187f0 	.word	0x57e187f0
57e1bea0:	57e17b84 	.word	0x57e17b84
57e1bea4:	57e2ccb4 	.word	0x57e2ccb4
57e1bea8:	57e3431e 	.word	0x57e3431e
57e1beac:	57e2c45c 	.word	0x57e2c45c
57e1beb0:	57e2cb1c 	.word	0x57e2cb1c
57e1beb4:	57e3435c 	.word	0x57e3435c
57e1beb8:	57e3439b 	.word	0x57e3439b
57e1bebc:	57e19864 	.word	0x57e19864
57e1bec0:	57e19828 	.word	0x57e19828
57e1bec4:	57e1b0ac 	.word	0x57e1b0ac
57e1bec8:	57e343bd 	.word	0x57e343bd

57e1becc <nand_scan_tail>:
 * This is the second phase of the normal nand_scan() function. It
 * fills out all the uninitialized function pointers with the defaults
 * and scans for a bad block table if appropriate.
 */
int nand_scan_tail(struct mtd_info *mtd)
{
57e1becc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int i;
	struct nand_chip *chip = mtd->priv;
57e1bed0:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * This is the second phase of the normal nand_scan() function. It
 * fills out all the uninitialized function pointers with the defaults
 * and scans for a bad block table if appropriate.
 */
int nand_scan_tail(struct mtd_info *mtd)
{
57e1bed4:	e1a05000 	mov	r5, r0
	int i;
	struct nand_chip *chip = mtd->priv;

	if (!(chip->options & NAND_OWN_BUFFERS))
57e1bed8:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1bedc:	e3130701 	tst	r3, #262144	; 0x40000
57e1bee0:	1a000003 	bne	57e1bef4 <nand_scan_tail+0x28>
		chip->buffers = memalign(ARCH_DMA_MINALIGN,
57e1bee4:	e3a00040 	mov	r0, #64	; 0x40
57e1bee8:	e3a01d9b 	mov	r1, #9920	; 0x26c0
57e1beec:	ebffb8da 	bl	57e0a25c <memalign>
57e1bef0:	e58400e8 	str	r0, [r4, #232]	; 0xe8
					 sizeof(*chip->buffers));
	if (!chip->buffers)
57e1bef4:	e59430e8 	ldr	r3, [r4, #232]	; 0xe8
57e1bef8:	e3530000 	cmp	r3, #0
57e1befc:	0a00013b 	beq	57e1c3f0 <nand_scan_tail+0x524>
		return -ENOMEM;

	/* Set the internal oob buffer location, just after the page data */
	chip->oob_poi = chip->buffers->databuf + mtd->writesize;
57e1bf00:	e5952014 	ldr	r2, [r5, #20]
57e1bf04:	e2822d12 	add	r2, r2, #1152	; 0x480
57e1bf08:	e0833002 	add	r3, r3, r2
57e1bf0c:	e5843090 	str	r3, [r4, #144]	; 0x90

	/*
	 * If no default placement scheme is given, select an appropriate one
	 */
	if (!chip->ecc.layout && (chip->ecc.mode != NAND_ECC_SOFT_BCH)) {
57e1bf10:	e59430b8 	ldr	r3, [r4, #184]	; 0xb8
57e1bf14:	e3530000 	cmp	r3, #0
57e1bf18:	1a000019 	bne	57e1bf84 <nand_scan_tail+0xb8>
57e1bf1c:	e594309c 	ldr	r3, [r4, #156]	; 0x9c
57e1bf20:	e3530005 	cmp	r3, #5
57e1bf24:	0a000016 	beq	57e1bf84 <nand_scan_tail+0xb8>
		switch (mtd->oobsize) {
57e1bf28:	e5951018 	ldr	r1, [r5, #24]
57e1bf2c:	e3510010 	cmp	r1, #16
57e1bf30:	0a00000a 	beq	57e1bf60 <nand_scan_tail+0x94>
57e1bf34:	8a000002 	bhi	57e1bf44 <nand_scan_tail+0x78>
57e1bf38:	e3510008 	cmp	r1, #8
57e1bf3c:	1a00000e 	bne	57e1bf7c <nand_scan_tail+0xb0>
57e1bf40:	ea000004 	b	57e1bf58 <nand_scan_tail+0x8c>
57e1bf44:	e3510040 	cmp	r1, #64	; 0x40
57e1bf48:	0a000007 	beq	57e1bf6c <nand_scan_tail+0xa0>
57e1bf4c:	e3510080 	cmp	r1, #128	; 0x80
57e1bf50:	1a000009 	bne	57e1bf7c <nand_scan_tail+0xb0>
57e1bf54:	ea000006 	b	57e1bf74 <nand_scan_tail+0xa8>
		case 8:
			chip->ecc.layout = &nand_oob_8;
57e1bf58:	e59f3498 	ldr	r3, [pc, #1176]	; 57e1c3f8 <nand_scan_tail+0x52c>
57e1bf5c:	ea000000 	b	57e1bf64 <nand_scan_tail+0x98>
			break;
		case 16:
			chip->ecc.layout = &nand_oob_16;
57e1bf60:	e59f3494 	ldr	r3, [pc, #1172]	; 57e1c3fc <nand_scan_tail+0x530>
57e1bf64:	e58430b8 	str	r3, [r4, #184]	; 0xb8
			break;
57e1bf68:	ea000005 	b	57e1bf84 <nand_scan_tail+0xb8>
		case 64:
			chip->ecc.layout = &nand_oob_64;
57e1bf6c:	e59f348c 	ldr	r3, [pc, #1164]	; 57e1c400 <nand_scan_tail+0x534>
57e1bf70:	eafffffb 	b	57e1bf64 <nand_scan_tail+0x98>
			break;
		case 128:
			chip->ecc.layout = &nand_oob_128;
57e1bf74:	e59f3488 	ldr	r3, [pc, #1160]	; 57e1c404 <nand_scan_tail+0x538>
57e1bf78:	eafffff9 	b	57e1bf64 <nand_scan_tail+0x98>
			break;
		default:
			printk(KERN_WARNING "No oob scheme defined for "
57e1bf7c:	e59f0484 	ldr	r0, [pc, #1156]	; 57e1c408 <nand_scan_tail+0x53c>
57e1bf80:	ebffb531 	bl	57e0944c <printf>
			       "oobsize %d\n", mtd->oobsize);
		}
	}

	if (!chip->write_page)
57e1bf84:	e5943048 	ldr	r3, [r4, #72]	; 0x48
	/*
	 * check ECC mode, default to software if 3byte/512byte hardware ECC is
	 * selected and we have 256 byte pagesize fallback to software ECC
	 */

	switch (chip->ecc.mode) {
57e1bf88:	e594109c 	ldr	r1, [r4, #156]	; 0x9c
			printk(KERN_WARNING "No oob scheme defined for "
			       "oobsize %d\n", mtd->oobsize);
		}
	}

	if (!chip->write_page)
57e1bf8c:	e3530000 	cmp	r3, #0
		chip->write_page = nand_write_page;
57e1bf90:	059f3474 	ldreq	r3, [pc, #1140]	; 57e1c40c <nand_scan_tail+0x540>
57e1bf94:	05843048 	streq	r3, [r4, #72]	; 0x48
	/*
	 * check ECC mode, default to software if 3byte/512byte hardware ECC is
	 * selected and we have 256 byte pagesize fallback to software ECC
	 */

	switch (chip->ecc.mode) {
57e1bf98:	e3510005 	cmp	r1, #5
57e1bf9c:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
57e1bfa0:	ea00009b 	b	57e1c214 <nand_scan_tail+0x348>
57e1bfa4:	57e1c1d0 	.word	0x57e1c1d0
57e1bfa8:	57e1c160 	.word	0x57e1c160
57e1bfac:	57e1c008 	.word	0x57e1c008
57e1bfb0:	57e1c068 	.word	0x57e1c068
57e1bfb4:	57e1bfbc 	.word	0x57e1bfbc
57e1bfb8:	57e1c1c0 	.word	0x57e1c1c0
	case NAND_ECC_HW_OOB_FIRST:
		/* Similar to NAND_ECC_HW, but a separate read_page handle */
		if (!chip->ecc.calculate || !chip->ecc.correct ||
57e1bfbc:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
57e1bfc0:	e3530000 	cmp	r3, #0
57e1bfc4:	0a000005 	beq	57e1bfe0 <nand_scan_tail+0x114>
57e1bfc8:	e59430c8 	ldr	r3, [r4, #200]	; 0xc8
57e1bfcc:	e3530000 	cmp	r3, #0
57e1bfd0:	0a000002 	beq	57e1bfe0 <nand_scan_tail+0x114>
57e1bfd4:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
57e1bfd8:	e3530000 	cmp	r3, #0
57e1bfdc:	1a000005 	bne	57e1bff8 <nand_scan_tail+0x12c>
		     !chip->ecc.hwctl) {
			printk(KERN_WARNING "No ECC functions supplied; "
57e1bfe0:	e59f0428 	ldr	r0, [pc, #1064]	; 57e1c410 <nand_scan_tail+0x544>
57e1bfe4:	ebffb518 	bl	57e0944c <printf>
			       "Hardware ECC not possible\n");
			BUG();
57e1bfe8:	e59f0424 	ldr	r0, [pc, #1060]	; 57e1c414 <nand_scan_tail+0x548>
57e1bfec:	e59f1424 	ldr	r1, [pc, #1060]	; 57e1c418 <nand_scan_tail+0x54c>
57e1bff0:	e59f2424 	ldr	r2, [pc, #1060]	; 57e1c41c <nand_scan_tail+0x550>
57e1bff4:	ea000035 	b	57e1c0d0 <nand_scan_tail+0x204>
		}
		if (!chip->ecc.read_page)
57e1bff8:	e59430d4 	ldr	r3, [r4, #212]	; 0xd4
57e1bffc:	e3530000 	cmp	r3, #0
			chip->ecc.read_page = nand_read_page_hwecc_oob_first;
57e1c000:	059f3418 	ldreq	r3, [pc, #1048]	; 57e1c420 <nand_scan_tail+0x554>
57e1c004:	058430d4 	streq	r3, [r4, #212]	; 0xd4

	case NAND_ECC_HW:
		/* Use standard hwecc read page function ? */
		if (!chip->ecc.read_page)
57e1c008:	e59430d4 	ldr	r3, [r4, #212]	; 0xd4
57e1c00c:	e3530000 	cmp	r3, #0
			chip->ecc.read_page = nand_read_page_hwecc;
57e1c010:	059f340c 	ldreq	r3, [pc, #1036]	; 57e1c424 <nand_scan_tail+0x558>
57e1c014:	058430d4 	streq	r3, [r4, #212]	; 0xd4
		if (!chip->ecc.write_page)
57e1c018:	e59430dc 	ldr	r3, [r4, #220]	; 0xdc
57e1c01c:	e3530000 	cmp	r3, #0
			chip->ecc.write_page = nand_write_page_hwecc;
57e1c020:	059f3400 	ldreq	r3, [pc, #1024]	; 57e1c428 <nand_scan_tail+0x55c>
57e1c024:	058430dc 	streq	r3, [r4, #220]	; 0xdc
		if (!chip->ecc.read_page_raw)
57e1c028:	e59430cc 	ldr	r3, [r4, #204]	; 0xcc
57e1c02c:	e3530000 	cmp	r3, #0
			chip->ecc.read_page_raw = nand_read_page_raw;
57e1c030:	059f33f4 	ldreq	r3, [pc, #1012]	; 57e1c42c <nand_scan_tail+0x560>
57e1c034:	058430cc 	streq	r3, [r4, #204]	; 0xcc
		if (!chip->ecc.write_page_raw)
57e1c038:	e59430d0 	ldr	r3, [r4, #208]	; 0xd0
57e1c03c:	e3530000 	cmp	r3, #0
			chip->ecc.write_page_raw = nand_write_page_raw;
57e1c040:	059f33e8 	ldreq	r3, [pc, #1000]	; 57e1c430 <nand_scan_tail+0x564>
57e1c044:	058430d0 	streq	r3, [r4, #208]	; 0xd0
		if (!chip->ecc.read_oob)
57e1c048:	e59430e0 	ldr	r3, [r4, #224]	; 0xe0
57e1c04c:	e3530000 	cmp	r3, #0
			chip->ecc.read_oob = nand_read_oob_std;
57e1c050:	059f33dc 	ldreq	r3, [pc, #988]	; 57e1c434 <nand_scan_tail+0x568>
57e1c054:	058430e0 	streq	r3, [r4, #224]	; 0xe0
		if (!chip->ecc.write_oob)
57e1c058:	e59430e4 	ldr	r3, [r4, #228]	; 0xe4
57e1c05c:	e3530000 	cmp	r3, #0
			chip->ecc.write_oob = nand_write_oob_std;
57e1c060:	059f33d0 	ldreq	r3, [pc, #976]	; 57e1c438 <nand_scan_tail+0x56c>
57e1c064:	058430e4 	streq	r3, [r4, #228]	; 0xe4

	case NAND_ECC_HW_SYNDROME:
		if ((!chip->ecc.calculate || !chip->ecc.correct ||
57e1c068:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
57e1c06c:	e3530000 	cmp	r3, #0
57e1c070:	0a000005 	beq	57e1c08c <nand_scan_tail+0x1c0>
57e1c074:	e59430c8 	ldr	r3, [r4, #200]	; 0xc8
57e1c078:	e3530000 	cmp	r3, #0
57e1c07c:	0a000002 	beq	57e1c08c <nand_scan_tail+0x1c0>
57e1c080:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
57e1c084:	e3530000 	cmp	r3, #0
57e1c088:	1a000014 	bne	57e1c0e0 <nand_scan_tail+0x214>
		     !chip->ecc.hwctl) &&
		    (!chip->ecc.read_page ||
57e1c08c:	e59430d4 	ldr	r3, [r4, #212]	; 0xd4
		if (!chip->ecc.write_oob)
			chip->ecc.write_oob = nand_write_oob_std;

	case NAND_ECC_HW_SYNDROME:
		if ((!chip->ecc.calculate || !chip->ecc.correct ||
		     !chip->ecc.hwctl) &&
57e1c090:	e3530000 	cmp	r3, #0
57e1c094:	0a000008 	beq	57e1c0bc <nand_scan_tail+0x1f0>
		    (!chip->ecc.read_page ||
57e1c098:	e59f2384 	ldr	r2, [pc, #900]	; 57e1c424 <nand_scan_tail+0x558>
57e1c09c:	e1530002 	cmp	r3, r2
57e1c0a0:	0a000005 	beq	57e1c0bc <nand_scan_tail+0x1f0>
		     chip->ecc.read_page == nand_read_page_hwecc ||
		     !chip->ecc.write_page ||
57e1c0a4:	e59430dc 	ldr	r3, [r4, #220]	; 0xdc

	case NAND_ECC_HW_SYNDROME:
		if ((!chip->ecc.calculate || !chip->ecc.correct ||
		     !chip->ecc.hwctl) &&
		    (!chip->ecc.read_page ||
		     chip->ecc.read_page == nand_read_page_hwecc ||
57e1c0a8:	e3530000 	cmp	r3, #0
57e1c0ac:	0a000002 	beq	57e1c0bc <nand_scan_tail+0x1f0>
		     !chip->ecc.write_page ||
57e1c0b0:	e59f2370 	ldr	r2, [pc, #880]	; 57e1c428 <nand_scan_tail+0x55c>
57e1c0b4:	e1530002 	cmp	r3, r2
57e1c0b8:	1a000008 	bne	57e1c0e0 <nand_scan_tail+0x214>
		     chip->ecc.write_page == nand_write_page_hwecc)) {
			printk(KERN_WARNING "No ECC functions supplied; "
57e1c0bc:	e59f034c 	ldr	r0, [pc, #844]	; 57e1c410 <nand_scan_tail+0x544>
57e1c0c0:	ebffb4e1 	bl	57e0944c <printf>
			       "Hardware ECC not possible\n");
			BUG();
57e1c0c4:	e59f0348 	ldr	r0, [pc, #840]	; 57e1c414 <nand_scan_tail+0x548>
57e1c0c8:	e59f1348 	ldr	r1, [pc, #840]	; 57e1c418 <nand_scan_tail+0x54c>
57e1c0cc:	e59f2368 	ldr	r2, [pc, #872]	; 57e1c43c <nand_scan_tail+0x570>
57e1c0d0:	e59f3368 	ldr	r3, [pc, #872]	; 57e1c440 <nand_scan_tail+0x574>
57e1c0d4:	ebffb4dc 	bl	57e0944c <printf>
57e1c0d8:	e59f0364 	ldr	r0, [pc, #868]	; 57e1c444 <nand_scan_tail+0x578>
57e1c0dc:	eb0024a2 	bl	57e2536c <panic>
		}
		/* Use standard syndrome read/write page function ? */
		if (!chip->ecc.read_page)
57e1c0e0:	e59430d4 	ldr	r3, [r4, #212]	; 0xd4
		if (!chip->ecc.read_oob)
			chip->ecc.read_oob = nand_read_oob_syndrome;
		if (!chip->ecc.write_oob)
			chip->ecc.write_oob = nand_write_oob_syndrome;

		if (mtd->writesize >= chip->ecc.size)
57e1c0e4:	e5952014 	ldr	r2, [r5, #20]
			printk(KERN_WARNING "No ECC functions supplied; "
			       "Hardware ECC not possible\n");
			BUG();
		}
		/* Use standard syndrome read/write page function ? */
		if (!chip->ecc.read_page)
57e1c0e8:	e3530000 	cmp	r3, #0
			chip->ecc.read_page = nand_read_page_syndrome;
57e1c0ec:	059f3354 	ldreq	r3, [pc, #852]	; 57e1c448 <nand_scan_tail+0x57c>
		if (!chip->ecc.read_oob)
			chip->ecc.read_oob = nand_read_oob_syndrome;
		if (!chip->ecc.write_oob)
			chip->ecc.write_oob = nand_write_oob_syndrome;

		if (mtd->writesize >= chip->ecc.size)
57e1c0f0:	e59410a4 	ldr	r1, [r4, #164]	; 0xa4
			       "Hardware ECC not possible\n");
			BUG();
		}
		/* Use standard syndrome read/write page function ? */
		if (!chip->ecc.read_page)
			chip->ecc.read_page = nand_read_page_syndrome;
57e1c0f4:	058430d4 	streq	r3, [r4, #212]	; 0xd4
		if (!chip->ecc.write_page)
57e1c0f8:	e59430dc 	ldr	r3, [r4, #220]	; 0xdc
57e1c0fc:	e3530000 	cmp	r3, #0
			chip->ecc.write_page = nand_write_page_syndrome;
57e1c100:	059f3344 	ldreq	r3, [pc, #836]	; 57e1c44c <nand_scan_tail+0x580>
57e1c104:	058430dc 	streq	r3, [r4, #220]	; 0xdc
		if (!chip->ecc.read_page_raw)
57e1c108:	e59430cc 	ldr	r3, [r4, #204]	; 0xcc
57e1c10c:	e3530000 	cmp	r3, #0
			chip->ecc.read_page_raw = nand_read_page_raw_syndrome;
57e1c110:	059f3338 	ldreq	r3, [pc, #824]	; 57e1c450 <nand_scan_tail+0x584>
57e1c114:	058430cc 	streq	r3, [r4, #204]	; 0xcc
		if (!chip->ecc.write_page_raw)
57e1c118:	e59430d0 	ldr	r3, [r4, #208]	; 0xd0
57e1c11c:	e3530000 	cmp	r3, #0
			chip->ecc.write_page_raw = nand_write_page_raw_syndrome;
57e1c120:	059f332c 	ldreq	r3, [pc, #812]	; 57e1c454 <nand_scan_tail+0x588>
57e1c124:	058430d0 	streq	r3, [r4, #208]	; 0xd0
		if (!chip->ecc.read_oob)
57e1c128:	e59430e0 	ldr	r3, [r4, #224]	; 0xe0
57e1c12c:	e3530000 	cmp	r3, #0
			chip->ecc.read_oob = nand_read_oob_syndrome;
57e1c130:	059f3320 	ldreq	r3, [pc, #800]	; 57e1c458 <nand_scan_tail+0x58c>
57e1c134:	058430e0 	streq	r3, [r4, #224]	; 0xe0
		if (!chip->ecc.write_oob)
57e1c138:	e59430e4 	ldr	r3, [r4, #228]	; 0xe4
57e1c13c:	e3530000 	cmp	r3, #0
			chip->ecc.write_oob = nand_write_oob_syndrome;
57e1c140:	059f3314 	ldreq	r3, [pc, #788]	; 57e1c45c <nand_scan_tail+0x590>
57e1c144:	058430e4 	streq	r3, [r4, #228]	; 0xe4

		if (mtd->writesize >= chip->ecc.size)
57e1c148:	e1520001 	cmp	r2, r1
57e1c14c:	2a000036 	bcs	57e1c22c <nand_scan_tail+0x360>
			break;
		printk(KERN_WARNING "%d byte HW ECC not possible on "
57e1c150:	e59f0308 	ldr	r0, [pc, #776]	; 57e1c460 <nand_scan_tail+0x594>
57e1c154:	ebffb4bc 	bl	57e0944c <printf>
		       "%d byte page size, fallback to SW ECC\n",
		       chip->ecc.size, mtd->writesize);
		chip->ecc.mode = NAND_ECC_SOFT;
57e1c158:	e3a03001 	mov	r3, #1
57e1c15c:	e584309c 	str	r3, [r4, #156]	; 0x9c

	case NAND_ECC_SOFT:
		chip->ecc.calculate = nand_calculate_ecc;
57e1c160:	e59f32fc 	ldr	r3, [pc, #764]	; 57e1c464 <nand_scan_tail+0x598>
57e1c164:	e58430c4 	str	r3, [r4, #196]	; 0xc4
		chip->ecc.correct = nand_correct_data;
57e1c168:	e59f32f8 	ldr	r3, [pc, #760]	; 57e1c468 <nand_scan_tail+0x59c>
57e1c16c:	e58430c8 	str	r3, [r4, #200]	; 0xc8
		chip->ecc.read_page = nand_read_page_swecc;
57e1c170:	e59f32f4 	ldr	r3, [pc, #756]	; 57e1c46c <nand_scan_tail+0x5a0>
57e1c174:	e58430d4 	str	r3, [r4, #212]	; 0xd4
		chip->ecc.read_subpage = nand_read_subpage;
57e1c178:	e59f32f0 	ldr	r3, [pc, #752]	; 57e1c470 <nand_scan_tail+0x5a4>
57e1c17c:	e58430d8 	str	r3, [r4, #216]	; 0xd8
		chip->ecc.write_page = nand_write_page_swecc;
57e1c180:	e59f32ec 	ldr	r3, [pc, #748]	; 57e1c474 <nand_scan_tail+0x5a8>
57e1c184:	e58430dc 	str	r3, [r4, #220]	; 0xdc
		chip->ecc.read_page_raw = nand_read_page_raw;
57e1c188:	e59f329c 	ldr	r3, [pc, #668]	; 57e1c42c <nand_scan_tail+0x560>
57e1c18c:	e58430cc 	str	r3, [r4, #204]	; 0xcc
		chip->ecc.write_page_raw = nand_write_page_raw;
57e1c190:	e59f3298 	ldr	r3, [pc, #664]	; 57e1c430 <nand_scan_tail+0x564>
57e1c194:	e58430d0 	str	r3, [r4, #208]	; 0xd0
		chip->ecc.read_oob = nand_read_oob_std;
57e1c198:	e59f3294 	ldr	r3, [pc, #660]	; 57e1c434 <nand_scan_tail+0x568>
57e1c19c:	e58430e0 	str	r3, [r4, #224]	; 0xe0
		chip->ecc.write_oob = nand_write_oob_std;
57e1c1a0:	e59f3290 	ldr	r3, [pc, #656]	; 57e1c438 <nand_scan_tail+0x56c>
57e1c1a4:	e58430e4 	str	r3, [r4, #228]	; 0xe4
		if (!chip->ecc.size)
57e1c1a8:	e59430a4 	ldr	r3, [r4, #164]	; 0xa4
57e1c1ac:	e3530000 	cmp	r3, #0
			chip->ecc.size = 256;
57e1c1b0:	02833c01 	addeq	r3, r3, #256	; 0x100
57e1c1b4:	058430a4 	streq	r3, [r4, #164]	; 0xa4
		chip->ecc.bytes = 3;
57e1c1b8:	e3a03003 	mov	r3, #3
57e1c1bc:	ea000012 	b	57e1c20c <nand_scan_tail+0x340>
		break;

	case NAND_ECC_SOFT_BCH:
		if (!mtd_nand_has_bch()) {
			printk(KERN_WARNING "CONFIG_MTD_ECC_BCH not enabled\n");
57e1c1c0:	e59f02b0 	ldr	r0, [pc, #688]	; 57e1c478 <nand_scan_tail+0x5ac>
57e1c1c4:	ebffb4a0 	bl	57e0944c <printf>
			return -EINVAL;
57e1c1c8:	e3e00015 	mvn	r0, #21
57e1c1cc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			printk(KERN_WARNING "BCH ECC initialization failed!\n");

		break;

	case NAND_ECC_NONE:
		printk(KERN_WARNING "NAND_ECC_NONE selected by board driver. "
57e1c1d0:	e59f02a4 	ldr	r0, [pc, #676]	; 57e1c47c <nand_scan_tail+0x5b0>
57e1c1d4:	ebffb49c 	bl	57e0944c <printf>
		       "This is not recommended !!\n");
		chip->ecc.read_page = nand_read_page_raw;
		chip->ecc.write_page = nand_write_page_raw;
57e1c1d8:	e59f3250 	ldr	r3, [pc, #592]	; 57e1c430 <nand_scan_tail+0x564>
		break;

	case NAND_ECC_NONE:
		printk(KERN_WARNING "NAND_ECC_NONE selected by board driver. "
		       "This is not recommended !!\n");
		chip->ecc.read_page = nand_read_page_raw;
57e1c1dc:	e59f2248 	ldr	r2, [pc, #584]	; 57e1c42c <nand_scan_tail+0x560>
		chip->ecc.write_page = nand_write_page_raw;
57e1c1e0:	e58430dc 	str	r3, [r4, #220]	; 0xdc
		chip->ecc.read_oob = nand_read_oob_std;
		chip->ecc.read_page_raw = nand_read_page_raw;
		chip->ecc.write_page_raw = nand_write_page_raw;
57e1c1e4:	e58430d0 	str	r3, [r4, #208]	; 0xd0
		chip->ecc.write_oob = nand_write_oob_std;
57e1c1e8:	e59f3248 	ldr	r3, [pc, #584]	; 57e1c438 <nand_scan_tail+0x56c>
	case NAND_ECC_NONE:
		printk(KERN_WARNING "NAND_ECC_NONE selected by board driver. "
		       "This is not recommended !!\n");
		chip->ecc.read_page = nand_read_page_raw;
		chip->ecc.write_page = nand_write_page_raw;
		chip->ecc.read_oob = nand_read_oob_std;
57e1c1ec:	e59f1240 	ldr	r1, [pc, #576]	; 57e1c434 <nand_scan_tail+0x568>
		chip->ecc.read_page_raw = nand_read_page_raw;
		chip->ecc.write_page_raw = nand_write_page_raw;
		chip->ecc.write_oob = nand_write_oob_std;
57e1c1f0:	e58430e4 	str	r3, [r4, #228]	; 0xe4
		chip->ecc.size = mtd->writesize;
57e1c1f4:	e5953014 	ldr	r3, [r5, #20]
		break;

	case NAND_ECC_NONE:
		printk(KERN_WARNING "NAND_ECC_NONE selected by board driver. "
		       "This is not recommended !!\n");
		chip->ecc.read_page = nand_read_page_raw;
57e1c1f8:	e58420d4 	str	r2, [r4, #212]	; 0xd4
		chip->ecc.write_page = nand_write_page_raw;
		chip->ecc.read_oob = nand_read_oob_std;
		chip->ecc.read_page_raw = nand_read_page_raw;
		chip->ecc.write_page_raw = nand_write_page_raw;
		chip->ecc.write_oob = nand_write_oob_std;
		chip->ecc.size = mtd->writesize;
57e1c1fc:	e58430a4 	str	r3, [r4, #164]	; 0xa4
	case NAND_ECC_NONE:
		printk(KERN_WARNING "NAND_ECC_NONE selected by board driver. "
		       "This is not recommended !!\n");
		chip->ecc.read_page = nand_read_page_raw;
		chip->ecc.write_page = nand_write_page_raw;
		chip->ecc.read_oob = nand_read_oob_std;
57e1c200:	e58410e0 	str	r1, [r4, #224]	; 0xe0
		chip->ecc.read_page_raw = nand_read_page_raw;
57e1c204:	e58420cc 	str	r2, [r4, #204]	; 0xcc
		chip->ecc.write_page_raw = nand_write_page_raw;
		chip->ecc.write_oob = nand_write_oob_std;
		chip->ecc.size = mtd->writesize;
		chip->ecc.bytes = 0;
57e1c208:	e3a03000 	mov	r3, #0
57e1c20c:	e58430a8 	str	r3, [r4, #168]	; 0xa8
		break;
57e1c210:	ea000005 	b	57e1c22c <nand_scan_tail+0x360>

	default:
		printk(KERN_WARNING "Invalid NAND_ECC_MODE %d\n",
57e1c214:	e59f0264 	ldr	r0, [pc, #612]	; 57e1c480 <nand_scan_tail+0x5b4>
57e1c218:	ebffb48b 	bl	57e0944c <printf>
		       chip->ecc.mode);
		BUG();
57e1c21c:	e59f01f0 	ldr	r0, [pc, #496]	; 57e1c414 <nand_scan_tail+0x548>
57e1c220:	e59f11f0 	ldr	r1, [pc, #496]	; 57e1c418 <nand_scan_tail+0x54c>
57e1c224:	e59f2258 	ldr	r2, [pc, #600]	; 57e1c484 <nand_scan_tail+0x5b8>
57e1c228:	eaffffa8 	b	57e1c0d0 <nand_scan_tail+0x204>

	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	chip->ecc.layout->oobavail = 0;
57e1c22c:	e59430b8 	ldr	r3, [r4, #184]	; 0xb8
57e1c230:	e3a02000 	mov	r2, #0
57e1c234:	e5832204 	str	r2, [r3, #516]	; 0x204
57e1c238:	e1a01003 	mov	r1, r3
	for (i = 0; chip->ecc.layout->oobfree[i].length
57e1c23c:	ea000002 	b	57e1c24c <nand_scan_tail+0x380>
			&& i < ARRAY_SIZE(chip->ecc.layout->oobfree); i++)
		chip->ecc.layout->oobavail +=
57e1c240:	e080000c 	add	r0, r0, ip
57e1c244:	e5830204 	str	r0, [r3, #516]	; 0x204
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	chip->ecc.layout->oobavail = 0;
	for (i = 0; chip->ecc.layout->oobfree[i].length
			&& i < ARRAY_SIZE(chip->ecc.layout->oobfree); i++)
57e1c248:	e2822001 	add	r2, r2, #1
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	chip->ecc.layout->oobavail = 0;
	for (i = 0; chip->ecc.layout->oobfree[i].length
57e1c24c:	e591c20c 	ldr	ip, [r1, #524]	; 0x20c
57e1c250:	e3520007 	cmp	r2, #7
57e1c254:	83a00000 	movhi	r0, #0
57e1c258:	93a00001 	movls	r0, #1
57e1c25c:	e35c0000 	cmp	ip, #0
57e1c260:	03a00000 	moveq	r0, #0
57e1c264:	e3500000 	cmp	r0, #0
57e1c268:	e2811008 	add	r1, r1, #8
57e1c26c:	e5930204 	ldr	r0, [r3, #516]	; 0x204
57e1c270:	1afffff2 	bne	57e1c240 <nand_scan_tail+0x374>

	/*
	 * Set the number of read / write steps for one page depending on ECC
	 * mode
	 */
	chip->ecc.steps = mtd->writesize / chip->ecc.size;
57e1c274:	e5956014 	ldr	r6, [r5, #20]
57e1c278:	e59470a4 	ldr	r7, [r4, #164]	; 0xa4
	chip->ecc.layout->oobavail = 0;
	for (i = 0; chip->ecc.layout->oobfree[i].length
			&& i < ARRAY_SIZE(chip->ecc.layout->oobfree); i++)
		chip->ecc.layout->oobavail +=
			chip->ecc.layout->oobfree[i].length;
	mtd->oobavail = chip->ecc.layout->oobavail;
57e1c27c:	e585001c 	str	r0, [r5, #28]

	/*
	 * Set the number of read / write steps for one page depending on ECC
	 * mode
	 */
	chip->ecc.steps = mtd->writesize / chip->ecc.size;
57e1c280:	e1a01007 	mov	r1, r7
57e1c284:	e1a00006 	mov	r0, r6
57e1c288:	eb003d48 	bl	57e2b7b0 <__udivsi3>
	if (chip->ecc.steps * chip->ecc.size != mtd->writesize) {
57e1c28c:	e0070790 	mul	r7, r0, r7
57e1c290:	e1570006 	cmp	r7, r6

	/*
	 * Set the number of read / write steps for one page depending on ECC
	 * mode
	 */
	chip->ecc.steps = mtd->writesize / chip->ecc.size;
57e1c294:	e58400a0 	str	r0, [r4, #160]	; 0xa0
	if (chip->ecc.steps * chip->ecc.size != mtd->writesize) {
57e1c298:	0a000005 	beq	57e1c2b4 <nand_scan_tail+0x3e8>
		printk(KERN_WARNING "Invalid ecc parameters\n");
57e1c29c:	e59f01e4 	ldr	r0, [pc, #484]	; 57e1c488 <nand_scan_tail+0x5bc>
57e1c2a0:	ebffb469 	bl	57e0944c <printf>
		BUG();
57e1c2a4:	e59f0168 	ldr	r0, [pc, #360]	; 57e1c414 <nand_scan_tail+0x548>
57e1c2a8:	e59f1168 	ldr	r1, [pc, #360]	; 57e1c418 <nand_scan_tail+0x54c>
57e1c2ac:	e59f21d8 	ldr	r2, [pc, #472]	; 57e1c48c <nand_scan_tail+0x5c0>
57e1c2b0:	eaffff86 	b	57e1c0d0 <nand_scan_tail+0x204>
	}
	chip->ecc.total = chip->ecc.steps * chip->ecc.bytes;
57e1c2b4:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
57e1c2b8:	e0030390 	mul	r3, r0, r3
57e1c2bc:	e58430ac 	str	r3, [r4, #172]	; 0xac

	/*
	 * Allow subpage writes up to ecc.steps. Not possible for MLC
	 * FLASH.
	 */
	if (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&
57e1c2c0:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1c2c4:	e3130c02 	tst	r3, #512	; 0x200
57e1c2c8:	1a000011 	bne	57e1c314 <nand_scan_tail+0x448>
	    !(chip->cellinfo & NAND_CI_CELLTYPE_MSK)) {
57e1c2cc:	e5d4307c 	ldrb	r3, [r4, #124]	; 0x7c

	/*
	 * Allow subpage writes up to ecc.steps. Not possible for MLC
	 * FLASH.
	 */
	if (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&
57e1c2d0:	e313000c 	tst	r3, #12
57e1c2d4:	1a00000e 	bne	57e1c314 <nand_scan_tail+0x448>
	    !(chip->cellinfo & NAND_CI_CELLTYPE_MSK)) {
		switch (chip->ecc.steps) {
57e1c2d8:	e3500004 	cmp	r0, #4
57e1c2dc:	0a00000a 	beq	57e1c30c <nand_scan_tail+0x440>
57e1c2e0:	ca000002 	bgt	57e1c2f0 <nand_scan_tail+0x424>
57e1c2e4:	e3500002 	cmp	r0, #2
57e1c2e8:	1a000009 	bne	57e1c314 <nand_scan_tail+0x448>
57e1c2ec:	ea000004 	b	57e1c304 <nand_scan_tail+0x438>
57e1c2f0:	e3500008 	cmp	r0, #8
57e1c2f4:	0a000004 	beq	57e1c30c <nand_scan_tail+0x440>
57e1c2f8:	e3500010 	cmp	r0, #16
57e1c2fc:	1a000004 	bne	57e1c314 <nand_scan_tail+0x448>
57e1c300:	ea000001 	b	57e1c30c <nand_scan_tail+0x440>
		case 2:
			mtd->subpage_sft = 1;
57e1c304:	e3a03001 	mov	r3, #1
57e1c308:	ea000000 	b	57e1c310 <nand_scan_tail+0x444>
			break;
		case 4:
		case 8:
		case 16:
			mtd->subpage_sft = 2;
57e1c30c:	e3a03002 	mov	r3, #2
57e1c310:	e5853090 	str	r3, [r5, #144]	; 0x90
			break;
		}
	}
	chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
57e1c314:	e5952014 	ldr	r2, [r5, #20]
57e1c318:	e5953090 	ldr	r3, [r5, #144]	; 0x90

	/* Initialize state */
	chip->state = FL_READY;

	/* De-select the device */
	chip->select_chip(mtd, -1);
57e1c31c:	e1a00005 	mov	r0, r5
		case 16:
			mtd->subpage_sft = 2;
			break;
		}
	}
	chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
57e1c320:	e1a03332 	lsr	r3, r2, r3
57e1c324:	e5843078 	str	r3, [r4, #120]	; 0x78

	/* Initialize state */
	chip->state = FL_READY;
57e1c328:	e3a03000 	mov	r3, #0
57e1c32c:	e584308c 	str	r3, [r4, #140]	; 0x8c

	/* De-select the device */
	chip->select_chip(mtd, -1);
57e1c330:	e3e01000 	mvn	r1, #0
57e1c334:	e594301c 	ldr	r3, [r4, #28]
57e1c338:	e12fff33 	blx	r3

	/* Invalidate the pagebuffer reference */
	chip->pagebuf = -1;
57e1c33c:	e3e03000 	mvn	r3, #0
57e1c340:	e5843074 	str	r3, [r4, #116]	; 0x74

	/* Large page NAND with SOFT_ECC should support subpage reads */
	if ((chip->ecc.mode == NAND_ECC_SOFT) && (chip->page_shift > 9))
57e1c344:	e594309c 	ldr	r3, [r4, #156]	; 0x9c
57e1c348:	e3530001 	cmp	r3, #1
57e1c34c:	1a000004 	bne	57e1c364 <nand_scan_tail+0x498>
57e1c350:	e5943054 	ldr	r3, [r4, #84]	; 0x54
57e1c354:	e3530009 	cmp	r3, #9
		chip->options |= NAND_SUBPAGE_READ;
57e1c358:	c5943050 	ldrgt	r3, [r4, #80]	; 0x50
57e1c35c:	c3833a01 	orrgt	r3, r3, #4096	; 0x1000
57e1c360:	c5843050 	strgt	r3, [r4, #80]	; 0x50

	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
57e1c364:	e3a03004 	mov	r3, #4
	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
						MTD_CAP_NANDFLASH;
	mtd->erase = nand_erase;
	mtd->point = NULL;
	mtd->unpoint = NULL;
	mtd->read = nand_read;
57e1c368:	e59f1120 	ldr	r1, [pc, #288]	; 57e1c490 <nand_scan_tail+0x5c4>
	/* Large page NAND with SOFT_ECC should support subpage reads */
	if ((chip->ecc.mode == NAND_ECC_SOFT) && (chip->page_shift > 9))
		chip->options |= NAND_SUBPAGE_READ;

	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
57e1c36c:	e5c53000 	strb	r3, [r5]
	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
57e1c370:	e5942050 	ldr	r2, [r4, #80]	; 0x50
						MTD_CAP_NANDFLASH;
	mtd->erase = nand_erase;
	mtd->point = NULL;
	mtd->unpoint = NULL;
	mtd->read = nand_read;
57e1c374:	e5851040 	str	r1, [r5, #64]	; 0x40
	mtd->write = nand_write;
57e1c378:	e59f1114 	ldr	r1, [pc, #276]	; 57e1c494 <nand_scan_tail+0x5c8>
	if ((chip->ecc.mode == NAND_ECC_SOFT) && (chip->page_shift > 9))
		chip->options |= NAND_SUBPAGE_READ;

	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
57e1c37c:	e3120b02 	tst	r2, #2048	; 0x800
						MTD_CAP_NANDFLASH;
	mtd->erase = nand_erase;
	mtd->point = NULL;
	mtd->unpoint = NULL;
	mtd->read = nand_read;
	mtd->write = nand_write;
57e1c380:	e5851044 	str	r1, [r5, #68]	; 0x44
	mtd->read_oob = nand_read_oob;
57e1c384:	e59f110c 	ldr	r1, [pc, #268]	; 57e1c498 <nand_scan_tail+0x5cc>
	if ((chip->ecc.mode == NAND_ECC_SOFT) && (chip->page_shift > 9))
		chip->options |= NAND_SUBPAGE_READ;

	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
57e1c388:	03a03b01 	moveq	r3, #1024	; 0x400
57e1c38c:	13a03000 	movne	r3, #0
	mtd->erase = nand_erase;
	mtd->point = NULL;
	mtd->unpoint = NULL;
	mtd->read = nand_read;
	mtd->write = nand_write;
	mtd->read_oob = nand_read_oob;
57e1c390:	e585104c 	str	r1, [r5, #76]	; 0x4c
	mtd->write_oob = nand_write_oob;
57e1c394:	e59f1100 	ldr	r1, [pc, #256]	; 57e1c49c <nand_scan_tail+0x5d0>
	if ((chip->ecc.mode == NAND_ECC_SOFT) && (chip->page_shift > 9))
		chip->options |= NAND_SUBPAGE_READ;

	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
57e1c398:	e5853004 	str	r3, [r5, #4]
	mtd->point = NULL;
	mtd->unpoint = NULL;
	mtd->read = nand_read;
	mtd->write = nand_write;
	mtd->read_oob = nand_read_oob;
	mtd->write_oob = nand_write_oob;
57e1c39c:	e5851050 	str	r1, [r5, #80]	; 0x50
	mtd->sync = nand_sync;
57e1c3a0:	e59f10f8 	ldr	r1, [pc, #248]	; 57e1c4a0 <nand_scan_tail+0x5d4>

	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
						MTD_CAP_NANDFLASH;
	mtd->erase = nand_erase;
57e1c3a4:	e59f30f8 	ldr	r3, [pc, #248]	; 57e1c4a4 <nand_scan_tail+0x5d8>
	mtd->unpoint = NULL;
	mtd->read = nand_read;
	mtd->write = nand_write;
	mtd->read_oob = nand_read_oob;
	mtd->write_oob = nand_write_oob;
	mtd->sync = nand_sync;
57e1c3a8:	e585106c 	str	r1, [r5, #108]	; 0x6c
	mtd->lock = NULL;
	mtd->unlock = NULL;
	mtd->block_isbad = nand_block_isbad;
57e1c3ac:	e59f10f4 	ldr	r1, [pc, #244]	; 57e1c4a8 <nand_scan_tail+0x5dc>

	/* propagate ecc.layout to mtd_info */
	mtd->ecclayout = chip->ecc.layout;

	/* Check, if we should skip the bad block table scan */
	if (chip->options & NAND_SKIP_BBTSCAN)
57e1c3b0:	e2120802 	ands	r0, r2, #131072	; 0x20000
	mtd->read_oob = nand_read_oob;
	mtd->write_oob = nand_write_oob;
	mtd->sync = nand_sync;
	mtd->lock = NULL;
	mtd->unlock = NULL;
	mtd->block_isbad = nand_block_isbad;
57e1c3b4:	e5851078 	str	r1, [r5, #120]	; 0x78
	mtd->block_markbad = nand_block_markbad;
57e1c3b8:	e59f10ec 	ldr	r1, [pc, #236]	; 57e1c4ac <nand_scan_tail+0x5e0>

	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
						MTD_CAP_NANDFLASH;
	mtd->erase = nand_erase;
57e1c3bc:	e5853034 	str	r3, [r5, #52]	; 0x34
	mtd->write_oob = nand_write_oob;
	mtd->sync = nand_sync;
	mtd->lock = NULL;
	mtd->unlock = NULL;
	mtd->block_isbad = nand_block_isbad;
	mtd->block_markbad = nand_block_markbad;
57e1c3c0:	e585107c 	str	r1, [r5, #124]	; 0x7c

	/* propagate ecc.layout to mtd_info */
	mtd->ecclayout = chip->ecc.layout;
57e1c3c4:	e59410b8 	ldr	r1, [r4, #184]	; 0xb8
	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
						MTD_CAP_NANDFLASH;
	mtd->erase = nand_erase;
	mtd->point = NULL;
57e1c3c8:	e3a03000 	mov	r3, #0
	/* propagate ecc.layout to mtd_info */
	mtd->ecclayout = chip->ecc.layout;

	/* Check, if we should skip the bad block table scan */
	if (chip->options & NAND_SKIP_BBTSCAN)
		chip->options |= NAND_BBT_SCANNED;
57e1c3cc:	13822101 	orrne	r2, r2, #1073741824	; 0x40000000
	/* Fill in remaining MTD driver data */
	mtd->type = MTD_NANDFLASH;
	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
						MTD_CAP_NANDFLASH;
	mtd->erase = nand_erase;
	mtd->point = NULL;
57e1c3d0:	e5853038 	str	r3, [r5, #56]	; 0x38
	mtd->unpoint = NULL;
57e1c3d4:	e585303c 	str	r3, [r5, #60]	; 0x3c
	mtd->read = nand_read;
	mtd->write = nand_write;
	mtd->read_oob = nand_read_oob;
	mtd->write_oob = nand_write_oob;
	mtd->sync = nand_sync;
	mtd->lock = NULL;
57e1c3d8:	e5853070 	str	r3, [r5, #112]	; 0x70
	mtd->unlock = NULL;
57e1c3dc:	e5853074 	str	r3, [r5, #116]	; 0x74
	mtd->block_isbad = nand_block_isbad;
	mtd->block_markbad = nand_block_markbad;

	/* propagate ecc.layout to mtd_info */
	mtd->ecclayout = chip->ecc.layout;
57e1c3e0:	e5851028 	str	r1, [r5, #40]	; 0x28

	/* Check, if we should skip the bad block table scan */
	if (chip->options & NAND_SKIP_BBTSCAN)
		chip->options |= NAND_BBT_SCANNED;

	return 0;
57e1c3e4:	11a00003 	movne	r0, r3
	/* propagate ecc.layout to mtd_info */
	mtd->ecclayout = chip->ecc.layout;

	/* Check, if we should skip the bad block table scan */
	if (chip->options & NAND_SKIP_BBTSCAN)
		chip->options |= NAND_BBT_SCANNED;
57e1c3e8:	15842050 	strne	r2, [r4, #80]	; 0x50
57e1c3ec:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

	if (!(chip->options & NAND_OWN_BUFFERS))
		chip->buffers = memalign(ARCH_DMA_MINALIGN,
					 sizeof(*chip->buffers));
	if (!chip->buffers)
		return -ENOMEM;
57e1c3f0:	e3e0000b 	mvn	r0, #11
	/* Check, if we should skip the bad block table scan */
	if (chip->options & NAND_SKIP_BBTSCAN)
		chip->options |= NAND_BBT_SCANNED;

	return 0;
}
57e1c3f4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e1c3f8:	57e37008 	.word	0x57e37008
57e1c3fc:	57e37250 	.word	0x57e37250
57e1c400:	57e37498 	.word	0x57e37498
57e1c404:	57e376e0 	.word	0x57e376e0
57e1c408:	57e343d6 	.word	0x57e343d6
57e1c40c:	57e19a54 	.word	0x57e19a54
57e1c410:	57e343fc 	.word	0x57e343fc
57e1c414:	57e33a28 	.word	0x57e33a28
57e1c418:	57e342aa 	.word	0x57e342aa
57e1c41c:	00000ba9 	.word	0x00000ba9
57e1c420:	57e18ef8 	.word	0x57e18ef8
57e1c424:	57e18dc0 	.word	0x57e18dc0
57e1c428:	57e19674 	.word	0x57e19674
57e1c42c:	57e18924 	.word	0x57e18924
57e1c430:	57e194c4 	.word	0x57e194c4
57e1c434:	57e19154 	.word	0x57e19154
57e1c438:	57e192a0 	.word	0x57e192a0
57e1c43c:	00000bc6 	.word	0x00000bc6
57e1c440:	57e2ccc8 	.word	0x57e2ccc8
57e1c444:	57e33a50 	.word	0x57e33a50
57e1c448:	57e1902c 	.word	0x57e1902c
57e1c44c:	57e19734 	.word	0x57e19734
57e1c450:	57e1895c 	.word	0x57e1895c
57e1c454:	57e194f8 	.word	0x57e194f8
57e1c458:	57e1919c 	.word	0x57e1919c
57e1c45c:	57e19310 	.word	0x57e19310
57e1c460:	57e34432 	.word	0x57e34432
57e1c464:	57e184d8 	.word	0x57e184d8
57e1c468:	57e185c8 	.word	0x57e185c8
57e1c46c:	57e18a30 	.word	0x57e18a30
57e1c470:	57e18b44 	.word	0x57e18b44
57e1c474:	57e195c8 	.word	0x57e195c8
57e1c478:	57e34478 	.word	0x57e34478
57e1c47c:	57e34498 	.word	0x57e34498
57e1c480:	57e344dc 	.word	0x57e344dc
57e1c484:	00000c1d 	.word	0x00000c1d
57e1c488:	57e344f6 	.word	0x57e344f6
57e1c48c:	00000c32 	.word	0x00000c32
57e1c490:	57e1ae3c 	.word	0x57e1ae3c
57e1c494:	57e1a33c 	.word	0x57e1a33c
57e1c498:	57e1ab7c 	.word	0x57e1ab7c
57e1c49c:	57e1a294 	.word	0x57e1a294
57e1c4a0:	57e198f0 	.word	0x57e198f0
57e1c4a4:	57e1b71c 	.word	0x57e1b71c
57e1c4a8:	57e199d8 	.word	0x57e199d8
57e1c4ac:	57e19a18 	.word	0x57e19a18

57e1c4b0 <nand_scan>:
 * filled with the appropriate values.
 * The mtd->owner field must be set to the module of the caller
 *
 */
int nand_scan(struct mtd_info *mtd, int maxchips)
{
57e1c4b0:	e92d4010 	push	{r4, lr}
	int ret;

	ret = nand_scan_ident(mtd, maxchips, NULL);
57e1c4b4:	e3a02000 	mov	r2, #0
 * filled with the appropriate values.
 * The mtd->owner field must be set to the module of the caller
 *
 */
int nand_scan(struct mtd_info *mtd, int maxchips)
{
57e1c4b8:	e1a04000 	mov	r4, r0
	int ret;

	ret = nand_scan_ident(mtd, maxchips, NULL);
57e1c4bc:	ebfffc98 	bl	57e1b724 <nand_scan_ident>
	if (!ret)
57e1c4c0:	e3500000 	cmp	r0, #0
57e1c4c4:	18bd8010 	popne	{r4, pc}
		ret = nand_scan_tail(mtd);
57e1c4c8:	e1a00004 	mov	r0, r4
	return ret;
}
57e1c4cc:	e8bd4010 	pop	{r4, lr}
{
	int ret;

	ret = nand_scan_ident(mtd, maxchips, NULL);
	if (!ret)
		ret = nand_scan_tail(mtd);
57e1c4d0:	eafffe7d 	b	57e1becc <nand_scan_tail>

57e1c4d4 <nand_release>:
/**
 * nand_release - [NAND Interface] Free resources held by the NAND device
 * @mtd:	MTD device structure
*/
void nand_release(struct mtd_info *mtd)
{
57e1c4d4:	e92d4010 	push	{r4, lr}
	struct nand_chip *chip = mtd->priv;
57e1c4d8:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	/* Deregister partitions */
	del_mtd_partitions(mtd);
#endif

	/* Free bad block table memory */
	kfree(chip->bbt);
57e1c4dc:	e5940110 	ldr	r0, [r4, #272]	; 0x110
57e1c4e0:	ebffb52d 	bl	57e0999c <free>
	if (!(chip->options & NAND_OWN_BUFFERS))
57e1c4e4:	e5943050 	ldr	r3, [r4, #80]	; 0x50
57e1c4e8:	e3130701 	tst	r3, #262144	; 0x40000
57e1c4ec:	1a000001 	bne	57e1c4f8 <nand_release+0x24>
		kfree(chip->buffers);
57e1c4f0:	e59400e8 	ldr	r0, [r4, #232]	; 0xe8
57e1c4f4:	ebffb528 	bl	57e0999c <free>

	/* Free bad block descriptor memory */
	if (chip->badblock_pattern && chip->badblock_pattern->options
57e1c4f8:	e594011c 	ldr	r0, [r4, #284]	; 0x11c
57e1c4fc:	e3500000 	cmp	r0, #0
57e1c500:	08bd8010 	popeq	{r4, pc}
			& NAND_BBT_DYNAMICSTRUCT)
57e1c504:	e5903000 	ldr	r3, [r0]
	kfree(chip->bbt);
	if (!(chip->options & NAND_OWN_BUFFERS))
		kfree(chip->buffers);

	/* Free bad block descriptor memory */
	if (chip->badblock_pattern && chip->badblock_pattern->options
57e1c508:	e3130602 	tst	r3, #2097152	; 0x200000
57e1c50c:	08bd8010 	popeq	{r4, pc}
			& NAND_BBT_DYNAMICSTRUCT)
		kfree(chip->badblock_pattern);
}
57e1c510:	e8bd4010 	pop	{r4, lr}
		kfree(chip->buffers);

	/* Free bad block descriptor memory */
	if (chip->badblock_pattern && chip->badblock_pattern->options
			& NAND_BBT_DYNAMICSTRUCT)
		kfree(chip->badblock_pattern);
57e1c514:	eaffb520 	b	57e0999c <free>

57e1c518 <s3c_nand_select_chip>:
}
#endif /* S3C_NAND_DEBUG */

static void s3c_nand_select_chip(struct mtd_info *mtd, int chip)
{
	int ctrl = readl(NFCONT);
57e1c518:	e59f3034 	ldr	r3, [pc, #52]	; 57e1c554 <s3c_nand_select_chip+0x3c>
57e1c51c:	e5933004 	ldr	r3, [r3, #4]

	switch (chip) {
57e1c520:	e3510000 	cmp	r1, #0
	case -1:
		ctrl |= 6;
		break;
	case 0:
		ctrl &= ~2;
57e1c524:	03c33002 	biceq	r3, r3, #2

static void s3c_nand_select_chip(struct mtd_info *mtd, int chip)
{
	int ctrl = readl(NFCONT);

	switch (chip) {
57e1c528:	0a000006 	beq	57e1c548 <s3c_nand_select_chip+0x30>
57e1c52c:	e3510001 	cmp	r1, #1
57e1c530:	0a000003 	beq	57e1c544 <s3c_nand_select_chip+0x2c>
57e1c534:	e3710001 	cmn	r1, #1
	case -1:
		ctrl |= 6;
57e1c538:	03833006 	orreq	r3, r3, #6

static void s3c_nand_select_chip(struct mtd_info *mtd, int chip)
{
	int ctrl = readl(NFCONT);

	switch (chip) {
57e1c53c:	112fff1e 	bxne	lr
57e1c540:	ea000000 	b	57e1c548 <s3c_nand_select_chip+0x30>
		break;
	case 0:
		ctrl &= ~2;
		break;
	case 1:
		ctrl &= ~4;
57e1c544:	e3c33004 	bic	r3, r3, #4
		break;
	default:
		return;
	}

	writel(ctrl, NFCONT);
57e1c548:	e59f2004 	ldr	r2, [pc, #4]	; 57e1c554 <s3c_nand_select_chip+0x3c>
57e1c54c:	e5823004 	str	r3, [r2, #4]
57e1c550:	e12fff1e 	bx	lr
57e1c554:	70200000 	.word	0x70200000

57e1c558 <s3c_nand_hwcontrol>:
 */
static void s3c_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
{
	struct nand_chip *this = mtd->priv;

	if (ctrl & NAND_CTRL_CHANGE) {
57e1c558:	e3120080 	tst	r2, #128	; 0x80
/*
 * Hardware specific access to control-lines function
 * Written by jsgood
 */
static void s3c_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
{
57e1c55c:	e92d4038 	push	{r3, r4, r5, lr}
57e1c560:	e1a04001 	mov	r4, r1
	struct nand_chip *this = mtd->priv;
57e1c564:	e5905094 	ldr	r5, [r0, #148]	; 0x94

	if (ctrl & NAND_CTRL_CHANGE) {
57e1c568:	0a00000b 	beq	57e1c59c <s3c_nand_hwcontrol+0x44>
		if (ctrl & NAND_CLE)
57e1c56c:	e3120002 	tst	r2, #2
			this->IO_ADDR_W = (void __iomem *)NFCMMD;
57e1c570:	159f303c 	ldrne	r3, [pc, #60]	; 57e1c5b4 <s3c_nand_hwcontrol+0x5c>
static void s3c_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
{
	struct nand_chip *this = mtd->priv;

	if (ctrl & NAND_CTRL_CHANGE) {
		if (ctrl & NAND_CLE)
57e1c574:	1a000002 	bne	57e1c584 <s3c_nand_hwcontrol+0x2c>
			this->IO_ADDR_W = (void __iomem *)NFCMMD;
		else if (ctrl & NAND_ALE)
57e1c578:	e3120004 	tst	r2, #4
			this->IO_ADDR_W = (void __iomem *)NFADDR;
57e1c57c:	159f3034 	ldrne	r3, [pc, #52]	; 57e1c5b8 <s3c_nand_hwcontrol+0x60>
		else
			this->IO_ADDR_W = (void __iomem *)NFDATA;
57e1c580:	059f3034 	ldreq	r3, [pc, #52]	; 57e1c5bc <s3c_nand_hwcontrol+0x64>
		if (ctrl & NAND_NCE)
57e1c584:	e3120001 	tst	r2, #1
		if (ctrl & NAND_CLE)
			this->IO_ADDR_W = (void __iomem *)NFCMMD;
		else if (ctrl & NAND_ALE)
			this->IO_ADDR_W = (void __iomem *)NFADDR;
		else
			this->IO_ADDR_W = (void __iomem *)NFDATA;
57e1c588:	e5853004 	str	r3, [r5, #4]
		if (ctrl & NAND_NCE)
			s3c_nand_select_chip(mtd, *(int *)this->priv);
57e1c58c:	15953120 	ldrne	r3, [r5, #288]	; 0x120
		else
			s3c_nand_select_chip(mtd, -1);
57e1c590:	03e01000 	mvneq	r1, #0
		else if (ctrl & NAND_ALE)
			this->IO_ADDR_W = (void __iomem *)NFADDR;
		else
			this->IO_ADDR_W = (void __iomem *)NFDATA;
		if (ctrl & NAND_NCE)
			s3c_nand_select_chip(mtd, *(int *)this->priv);
57e1c594:	15931000 	ldrne	r1, [r3]
		else
			s3c_nand_select_chip(mtd, -1);
57e1c598:	ebffffde 	bl	57e1c518 <s3c_nand_select_chip>
	}

	if (cmd != NAND_CMD_NONE)
57e1c59c:	e3740001 	cmn	r4, #1
57e1c5a0:	08bd8038 	popeq	{r3, r4, r5, pc}
		writeb(cmd, this->IO_ADDR_W);
57e1c5a4:	e20440ff 	and	r4, r4, #255	; 0xff
57e1c5a8:	e5953004 	ldr	r3, [r5, #4]
57e1c5ac:	e5c34000 	strb	r4, [r3]
57e1c5b0:	e8bd8038 	pop	{r3, r4, r5, pc}
57e1c5b4:	70200008 	.word	0x70200008
57e1c5b8:	7020000c 	.word	0x7020000c
57e1c5bc:	70200010 	.word	0x70200010

57e1c5c0 <s3c_nand_device_ready>:
 * Function for checking device ready pin
 * Written by jsgood
 */
static int s3c_nand_device_ready(struct mtd_info *mtdinfo)
{
	return !!(readl(NFSTAT) & NFSTAT_RnB);
57e1c5c0:	e59f3008 	ldr	r3, [pc, #8]	; 57e1c5d0 <s3c_nand_device_ready+0x10>
57e1c5c4:	e5930028 	ldr	r0, [r3, #40]	; 0x28
}
57e1c5c8:	e2000001 	and	r0, r0, #1
57e1c5cc:	e12fff1e 	bx	lr
57e1c5d0:	70200000 	.word	0x70200000

57e1c5d4 <s3c_nand_enable_hwecc>:
	/*
	 * The original driver used 4-bit ECC for "new" MLC chips, i.e., for
	 * those with non-zero ID[3][3:2], which anyway only holds for ST
	 * (Numonyx) chips
	 */
	nfconf = readl(NFCONF) & ~NFCONF_ECC_4BIT;
57e1c5d4:	e59f3034 	ldr	r3, [pc, #52]	; 57e1c610 <s3c_nand_enable_hwecc+0x3c>
57e1c5d8:	e5932000 	ldr	r2, [r3]
57e1c5dc:	e3c22401 	bic	r2, r2, #16777216	; 0x1000000

	writel(nfconf, NFCONF);
57e1c5e0:	e5832000 	str	r2, [r3]

	/* Initialize & unlock */
	nfcont = readl(NFCONT);
57e1c5e4:	e5933004 	ldr	r3, [r3, #4]
	nfcont |= NFCONT_INITECC;
57e1c5e8:	e3833030 	orr	r3, r3, #48	; 0x30
	nfcont &= ~NFCONT_MECCLOCK;
57e1c5ec:	e3c33080 	bic	r3, r3, #128	; 0x80

	if (mode == NAND_ECC_WRITE)
57e1c5f0:	e3510001 	cmp	r1, #1
		nfcont |= NFCONT_ECC_ENC;
57e1c5f4:	03833701 	orreq	r3, r3, #262144	; 0x40000
	/* Initialize & unlock */
	nfcont = readl(NFCONT);
	nfcont |= NFCONT_INITECC;
	nfcont &= ~NFCONT_MECCLOCK;

	if (mode == NAND_ECC_WRITE)
57e1c5f8:	0a000001 	beq	57e1c604 <s3c_nand_enable_hwecc+0x30>
		nfcont |= NFCONT_ECC_ENC;
	else if (mode == NAND_ECC_READ)
57e1c5fc:	e3510000 	cmp	r1, #0
		nfcont &= ~NFCONT_ECC_ENC;
57e1c600:	03c33701 	biceq	r3, r3, #262144	; 0x40000

	writel(nfcont, NFCONT);
57e1c604:	e59f2004 	ldr	r2, [pc, #4]	; 57e1c610 <s3c_nand_enable_hwecc+0x3c>
57e1c608:	e5823004 	str	r3, [r2, #4]
}
57e1c60c:	e12fff1e 	bx	lr
57e1c610:	70200000 	.word	0x70200000

57e1c614 <s3c_nand_calculate_ecc>:
				  u_char *ecc_code)
{
	u_long nfcont, nfmecc0;

	/* Lock */
	nfcont = readl(NFCONT);
57e1c614:	e59f3030 	ldr	r3, [pc, #48]	; 57e1c64c <s3c_nand_calculate_ecc+0x38>
57e1c618:	e5931004 	ldr	r1, [r3, #4]
	nfcont |= NFCONT_MECCLOCK;
57e1c61c:	e3811080 	orr	r1, r1, #128	; 0x80
	writel(nfcont, NFCONT);
57e1c620:	e5831004 	str	r1, [r3, #4]

	nfmecc0 = readl(NFMECC0);
57e1c624:	e5933034 	ldr	r3, [r3, #52]	; 0x34

	ecc_code[0] = nfmecc0 & 0xff;
	ecc_code[1] = (nfmecc0 >> 8) & 0xff;
57e1c628:	e1a01423 	lsr	r1, r3, #8
	nfcont |= NFCONT_MECCLOCK;
	writel(nfcont, NFCONT);

	nfmecc0 = readl(NFMECC0);

	ecc_code[0] = nfmecc0 & 0xff;
57e1c62c:	e5c23000 	strb	r3, [r2]
	ecc_code[1] = (nfmecc0 >> 8) & 0xff;
57e1c630:	e5c21001 	strb	r1, [r2, #1]
	ecc_code[2] = (nfmecc0 >> 16) & 0xff;
57e1c634:	e1a01823 	lsr	r1, r3, #16
	ecc_code[3] = (nfmecc0 >> 24) & 0xff;
57e1c638:	e1a03c23 	lsr	r3, r3, #24

	nfmecc0 = readl(NFMECC0);

	ecc_code[0] = nfmecc0 & 0xff;
	ecc_code[1] = (nfmecc0 >> 8) & 0xff;
	ecc_code[2] = (nfmecc0 >> 16) & 0xff;
57e1c63c:	e5c21002 	strb	r1, [r2, #2]
	ecc_code[3] = (nfmecc0 >> 24) & 0xff;
57e1c640:	e5c23003 	strb	r3, [r2, #3]

	return 0;
}
57e1c644:	e3a00000 	mov	r0, #0
57e1c648:	e12fff1e 	bx	lr
57e1c64c:	70200000 	.word	0x70200000

57e1c650 <s3c_nand_correct_data>:
 * If uncorrectable errors occured, return -1.
 * Written by jsgood
 */
static int s3c_nand_correct_data(struct mtd_info *mtd, u_char *dat,
				 u_char *read_ecc, u_char *calc_ecc)
{
57e1c650:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e1c654:	e1a07001 	mov	r7, r1
	int ret = -1;
	u_long nfestat0, nfmeccdata0, nfmeccdata1, err_byte_addr;
	u_char err_type, repaired;

	/* SLC: Write ecc to compare */
	nfmeccdata0 = (calc_ecc[1] << 16) | calc_ecc[0];
57e1c658:	e5d32000 	ldrb	r2, [r3]
57e1c65c:	e5d31001 	ldrb	r1, [r3, #1]
57e1c660:	e1821801 	orr	r1, r2, r1, lsl #16
	nfmeccdata1 = (calc_ecc[3] << 16) | calc_ecc[2];
57e1c664:	e5d32003 	ldrb	r2, [r3, #3]
57e1c668:	e5d33002 	ldrb	r3, [r3, #2]
57e1c66c:	e1832802 	orr	r2, r3, r2, lsl #16
	writel(nfmeccdata0, NFMECCDATA0);
57e1c670:	e59f3068 	ldr	r3, [pc, #104]	; 57e1c6e0 <s3c_nand_correct_data+0x90>
57e1c674:	e5831014 	str	r1, [r3, #20]
	writel(nfmeccdata1, NFMECCDATA1);
57e1c678:	e5832018 	str	r2, [r3, #24]

	/* Read ecc status */
	nfestat0 = readl(NFESTAT0);
57e1c67c:	e593602c 	ldr	r6, [r3, #44]	; 0x2c
	err_type = nfestat0 & 0x3;
57e1c680:	e2064003 	and	r4, r6, #3

	switch (err_type) {
57e1c684:	e3540001 	cmp	r4, #1
57e1c688:	0a000004 	beq	57e1c6a0 <s3c_nand_correct_data+0x50>
57e1c68c:	3a000011 	bcc	57e1c6d8 <s3c_nand_correct_data+0x88>
		ret = 1;
		break;

	case 2: /* Multiple error */
	case 3: /* ECC area error */
		printf("S3C NAND: ECC uncorrectable error detected. "
57e1c690:	e59f004c 	ldr	r0, [pc, #76]	; 57e1c6e4 <s3c_nand_correct_data+0x94>
57e1c694:	ebffb36c 	bl	57e0944c <printf>
		       "Not correctable.\n");
		ret = -1;
57e1c698:	e3e00000 	mvn	r0, #0
		break;
57e1c69c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		/*
		 * 1 bit error (Correctable)
		 * (nfestat0 >> 7) & 0x7ff	:error byte number
		 * (nfestat0 >> 4) & 0x7	:error bit number
		 */
		err_byte_addr = (nfestat0 >> 7) & 0x7ff;
57e1c6a0:	e1a053a6 	lsr	r5, r6, #7
57e1c6a4:	e1a05a85 	lsl	r5, r5, #21
		repaired = dat[err_byte_addr] ^ (1 << ((nfestat0 >> 4) & 0x7));
57e1c6a8:	e7d72aa5 	ldrb	r2, [r7, r5, lsr #21]
57e1c6ac:	e1a06226 	lsr	r6, r6, #4
57e1c6b0:	e2066007 	and	r6, r6, #7
57e1c6b4:	e0226614 	eor	r6, r2, r4, lsl r6
57e1c6b8:	e20660ff 	and	r6, r6, #255	; 0xff

		printf("S3C NAND: 1 bit error detected at byte %ld. "
57e1c6bc:	e59f0024 	ldr	r0, [pc, #36]	; 57e1c6e8 <s3c_nand_correct_data+0x98>
57e1c6c0:	e1a01aa5 	lsr	r1, r5, #21
57e1c6c4:	e1a03006 	mov	r3, r6
57e1c6c8:	ebffb35f 	bl	57e0944c <printf>
		       "Correcting from 0x%02x to 0x%02x...OK\n",
		       err_byte_addr, dat[err_byte_addr], repaired);

		dat[err_byte_addr] = repaired;
57e1c6cc:	e7c76aa5 	strb	r6, [r7, r5, lsr #21]

		ret = 1;
57e1c6d0:	e1a00004 	mov	r0, r4
		break;
57e1c6d4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	nfestat0 = readl(NFESTAT0);
	err_type = nfestat0 & 0x3;

	switch (err_type) {
	case 0: /* No error */
		ret = 0;
57e1c6d8:	e3a00000 	mov	r0, #0
		ret = -1;
		break;
	}

	return ret;
}
57e1c6dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e1c6e0:	70200000 	.word	0x70200000
57e1c6e4:	57e34561 	.word	0x57e34561
57e1c6e8:	57e3450e 	.word	0x57e3450e

57e1c6ec <board_nand_init>:
 */
int board_nand_init(struct nand_chip *nand)
{
	static int chip_n;

	if (chip_n >= MAX_CHIPS)
57e1c6ec:	e59f10a0 	ldr	r1, [pc, #160]	; 57e1c794 <board_nand_init+0xa8>
57e1c6f0:	e5913000 	ldr	r3, [r1]
57e1c6f4:	e3530001 	cmp	r3, #1
57e1c6f8:	ca000023 	bgt	57e1c78c <board_nand_init+0xa0>
		return -ENODEV;

	NFCONT_REG = (NFCONT_REG & ~NFCONT_WP) | NFCONT_ENABLE | 0x6;
57e1c6fc:	e59f2094 	ldr	r2, [pc, #148]	; 57e1c798 <board_nand_init+0xac>
57e1c700:	e592c004 	ldr	ip, [r2, #4]
57e1c704:	e3ccc801 	bic	ip, ip, #65536	; 0x10000
57e1c708:	e3ccc007 	bic	ip, ip, #7
57e1c70c:	e38cc007 	orr	ip, ip, #7
57e1c710:	e582c004 	str	ip, [r2, #4]
	nand->write_buf		= nand_write_buf;
	nand->read_buf		= nand_read_buf;
#endif

#ifdef CONFIG_SYS_S3C_NAND_HWECC
	nand->ecc.hwctl		= s3c_nand_enable_hwecc;
57e1c714:	e59fc080 	ldr	ip, [pc, #128]	; 57e1c79c <board_nand_init+0xb0>
	if (chip_n >= MAX_CHIPS)
		return -ENODEV;

	NFCONT_REG = (NFCONT_REG & ~NFCONT_WP) | NFCONT_ENABLE | 0x6;

	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
57e1c718:	e2822010 	add	r2, r2, #16
	nand->write_buf		= nand_write_buf;
	nand->read_buf		= nand_read_buf;
#endif

#ifdef CONFIG_SYS_S3C_NAND_HWECC
	nand->ecc.hwctl		= s3c_nand_enable_hwecc;
57e1c71c:	e580c0c0 	str	ip, [r0, #192]	; 0xc0
	nand->ecc.calculate	= s3c_nand_calculate_ecc;
57e1c720:	e59fc078 	ldr	ip, [pc, #120]	; 57e1c7a0 <board_nand_init+0xb4>
	if (chip_n >= MAX_CHIPS)
		return -ENODEV;

	NFCONT_REG = (NFCONT_REG & ~NFCONT_WP) | NFCONT_ENABLE | 0x6;

	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
57e1c724:	e5802000 	str	r2, [r0]
	nand->read_buf		= nand_read_buf;
#endif

#ifdef CONFIG_SYS_S3C_NAND_HWECC
	nand->ecc.hwctl		= s3c_nand_enable_hwecc;
	nand->ecc.calculate	= s3c_nand_calculate_ecc;
57e1c728:	e580c0c4 	str	ip, [r0, #196]	; 0xc4
	nand->ecc.correct	= s3c_nand_correct_data;
57e1c72c:	e59fc070 	ldr	ip, [pc, #112]	; 57e1c7a4 <board_nand_init+0xb8>
		return -ENODEV;

	NFCONT_REG = (NFCONT_REG & ~NFCONT_WP) | NFCONT_ENABLE | 0x6;

	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
	nand->IO_ADDR_W		= (void __iomem *)NFDATA;
57e1c730:	e5802004 	str	r2, [r0, #4]
	nand->cmd_ctrl		= s3c_nand_hwcontrol;
57e1c734:	e59f206c 	ldr	r2, [pc, #108]	; 57e1c7a8 <board_nand_init+0xbc>
#endif

#ifdef CONFIG_SYS_S3C_NAND_HWECC
	nand->ecc.hwctl		= s3c_nand_enable_hwecc;
	nand->ecc.calculate	= s3c_nand_calculate_ecc;
	nand->ecc.correct	= s3c_nand_correct_data;
57e1c738:	e580c0c8 	str	ip, [r0, #200]	; 0xc8

	/*
	 * If you get more than 1 NAND-chip with different page-sizes on the
	 * board one day, it will get more complicated...
	 */
	nand->ecc.mode		= NAND_ECC_HW;
57e1c73c:	e3a0c002 	mov	ip, #2

	NFCONT_REG = (NFCONT_REG & ~NFCONT_WP) | NFCONT_ENABLE | 0x6;

	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
	nand->IO_ADDR_W		= (void __iomem *)NFDATA;
	nand->cmd_ctrl		= s3c_nand_hwcontrol;
57e1c740:	e5802028 	str	r2, [r0, #40]	; 0x28

	/*
	 * If you get more than 1 NAND-chip with different page-sizes on the
	 * board one day, it will get more complicated...
	 */
	nand->ecc.mode		= NAND_ECC_HW;
57e1c744:	e580c09c 	str	ip, [r0, #156]	; 0x9c
	NFCONT_REG = (NFCONT_REG & ~NFCONT_WP) | NFCONT_ENABLE | 0x6;

	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
	nand->IO_ADDR_W		= (void __iomem *)NFDATA;
	nand->cmd_ctrl		= s3c_nand_hwcontrol;
	nand->dev_ready		= s3c_nand_device_ready;
57e1c748:	e59f205c 	ldr	r2, [pc, #92]	; 57e1c7ac <board_nand_init+0xc0>
	/*
	 * If you get more than 1 NAND-chip with different page-sizes on the
	 * board one day, it will get more complicated...
	 */
	nand->ecc.mode		= NAND_ECC_HW;
	nand->ecc.size		= CONFIG_SYS_NAND_ECCSIZE;
57e1c74c:	e3a0cb02 	mov	ip, #2048	; 0x800
57e1c750:	e580c0a4 	str	ip, [r0, #164]	; 0xa4
	nand->ecc.bytes		= CONFIG_SYS_NAND_ECCBYTES;
57e1c754:	e3a0c004 	mov	ip, #4
	NFCONT_REG = (NFCONT_REG & ~NFCONT_WP) | NFCONT_ENABLE | 0x6;

	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
	nand->IO_ADDR_W		= (void __iomem *)NFDATA;
	nand->cmd_ctrl		= s3c_nand_hwcontrol;
	nand->dev_ready		= s3c_nand_device_ready;
57e1c758:	e5802030 	str	r2, [r0, #48]	; 0x30
	 * If you get more than 1 NAND-chip with different page-sizes on the
	 * board one day, it will get more complicated...
	 */
	nand->ecc.mode		= NAND_ECC_HW;
	nand->ecc.size		= CONFIG_SYS_NAND_ECCSIZE;
	nand->ecc.bytes		= CONFIG_SYS_NAND_ECCBYTES;
57e1c75c:	e580c0a8 	str	ip, [r0, #168]	; 0xa8

	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
	nand->IO_ADDR_W		= (void __iomem *)NFDATA;
	nand->cmd_ctrl		= s3c_nand_hwcontrol;
	nand->dev_ready		= s3c_nand_device_ready;
	nand->select_chip	= s3c_nand_select_chip;
57e1c760:	e59f2048 	ldr	r2, [pc, #72]	; 57e1c7b0 <board_nand_init+0xc4>
	nand->ecc.bytes		= CONFIG_SYS_NAND_ECCBYTES;
#else
	nand->ecc.mode		= NAND_ECC_SOFT;
#endif /* ! CONFIG_SYS_S3C_NAND_HWECC */

	nand->priv		= nand_cs + chip_n++;
57e1c764:	e59fc048 	ldr	ip, [pc, #72]	; 57e1c7b4 <board_nand_init+0xc8>

	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
	nand->IO_ADDR_W		= (void __iomem *)NFDATA;
	nand->cmd_ctrl		= s3c_nand_hwcontrol;
	nand->dev_ready		= s3c_nand_device_ready;
	nand->select_chip	= s3c_nand_select_chip;
57e1c768:	e580201c 	str	r2, [r0, #28]
	nand->ecc.bytes		= CONFIG_SYS_NAND_ECCBYTES;
#else
	nand->ecc.mode		= NAND_ECC_SOFT;
#endif /* ! CONFIG_SYS_S3C_NAND_HWECC */

	nand->priv		= nand_cs + chip_n++;
57e1c76c:	e08cc103 	add	ip, ip, r3, lsl #2
	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
	nand->IO_ADDR_W		= (void __iomem *)NFDATA;
	nand->cmd_ctrl		= s3c_nand_hwcontrol;
	nand->dev_ready		= s3c_nand_device_ready;
	nand->select_chip	= s3c_nand_select_chip;
	nand->options		= 0;
57e1c770:	e3a02000 	mov	r2, #0
	nand->ecc.bytes		= CONFIG_SYS_NAND_ECCBYTES;
#else
	nand->ecc.mode		= NAND_ECC_SOFT;
#endif /* ! CONFIG_SYS_S3C_NAND_HWECC */

	nand->priv		= nand_cs + chip_n++;
57e1c774:	e2833001 	add	r3, r3, #1
	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
	nand->IO_ADDR_W		= (void __iomem *)NFDATA;
	nand->cmd_ctrl		= s3c_nand_hwcontrol;
	nand->dev_ready		= s3c_nand_device_ready;
	nand->select_chip	= s3c_nand_select_chip;
	nand->options		= 0;
57e1c778:	e5802050 	str	r2, [r0, #80]	; 0x50
	nand->ecc.bytes		= CONFIG_SYS_NAND_ECCBYTES;
#else
	nand->ecc.mode		= NAND_ECC_SOFT;
#endif /* ! CONFIG_SYS_S3C_NAND_HWECC */

	nand->priv		= nand_cs + chip_n++;
57e1c77c:	e580c120 	str	ip, [r0, #288]	; 0x120
57e1c780:	e5813000 	str	r3, [r1]

	return 0;
57e1c784:	e1a00002 	mov	r0, r2
57e1c788:	e12fff1e 	bx	lr
int board_nand_init(struct nand_chip *nand)
{
	static int chip_n;

	if (chip_n >= MAX_CHIPS)
		return -ENODEV;
57e1c78c:	e3e00012 	mvn	r0, #18
#endif /* ! CONFIG_SYS_S3C_NAND_HWECC */

	nand->priv		= nand_cs + chip_n++;

	return 0;
}
57e1c790:	e12fff1e 	bx	lr
57e1c794:	57e47970 	.word	0x57e47970
57e1c798:	70200000 	.word	0x70200000
57e1c79c:	57e1c5d4 	.word	0x57e1c5d4
57e1c7a0:	57e1c614 	.word	0x57e1c614
57e1c7a4:	57e1c650 	.word	0x57e1c650
57e1c7a8:	57e1c558 	.word	0x57e1c558
57e1c7ac:	57e1c5c0 	.word	0x57e1c5c0
57e1c7b0:	57e1c518 	.word	0x57e1c518
57e1c7b4:	57e37928 	.word	0x57e37928

57e1c7b8 <get_reg_init_bus>:

static u16 get_reg_init_bus(struct eth_device *dev, int regno)
{
	/* force 16 bit busmode */
	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);
	uint8_t volatile * const iob = (uint8_t volatile * const)dev->iobase;
57e1c7b8:	e5903018 	ldr	r3, [r0, #24]
#define REG_READ(a) readw((a))

static u16 get_reg_init_bus(struct eth_device *dev, int regno)
{
	/* force 16 bit busmode */
	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);
57e1c7bc:	e590203c 	ldr	r2, [r0, #60]	; 0x3c
	uint8_t volatile * const iob = (uint8_t volatile * const)dev->iobase;

	readb(iob);
57e1c7c0:	e5d30000 	ldrb	r0, [r3]
	readb(iob + 1);
57e1c7c4:	e5d30001 	ldrb	r0, [r3, #1]
	readb(iob);
57e1c7c8:	e5d30000 	ldrb	r0, [r3]
	readb(iob + 1);
57e1c7cc:	e5d30001 	ldrb	r0, [r3, #1]
	readb(iob);
57e1c7d0:	e5d33000 	ldrb	r3, [r3]

	REG_WRITE(regno, &priv->regs->pptr);
57e1c7d4:	e1a01801 	lsl	r1, r1, #16
57e1c7d8:	e1a01821 	lsr	r1, r1, #16
57e1c7dc:	e5923000 	ldr	r3, [r2]
57e1c7e0:	e1c310ba 	strh	r1, [r3, #10]
	return REG_READ(&priv->regs->pdata);
57e1c7e4:	e1d300bc 	ldrh	r0, [r3, #12]
}
57e1c7e8:	e12fff1e 	bx	lr

57e1c7ec <get_reg.clone.0>:
#endif

static u16 get_reg(struct eth_device *dev, int regno)
{
	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);
	REG_WRITE(regno, &priv->regs->pptr);
57e1c7ec:	e1a01801 	lsl	r1, r1, #16
57e1c7f0:	e1a01821 	lsr	r1, r1, #16
57e1c7f4:	e5903000 	ldr	r3, [r0]
57e1c7f8:	e1c310ba 	strh	r1, [r3, #10]
	return REG_READ(&priv->regs->pdata);
57e1c7fc:	e1d300bc 	ldrh	r0, [r3, #12]
}
57e1c800:	e12fff1e 	bx	lr

57e1c804 <cs8900_recv>:
	return 0;
}

/* Get a data block via Ethernet */
static int cs8900_recv(struct eth_device *dev)
{
57e1c804:	e92d4038 	push	{r3, r4, r5, lr}
	int i;
	u16 rxlen;
	u16 *addr;
	u16 status;

	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);
57e1c808:	e590403c 	ldr	r4, [r0, #60]	; 0x3c

	status = get_reg(dev, PP_RER);
57e1c80c:	e3a01f49 	mov	r1, #292	; 0x124
57e1c810:	e1a00004 	mov	r0, r4
57e1c814:	ebfffff4 	bl	57e1c7ec <get_reg.clone.0>

	if ((status & PP_RER_RxOK) == 0)
57e1c818:	e2105c01 	ands	r5, r0, #256	; 0x100
57e1c81c:	0a000017 	beq	57e1c880 <cs8900_recv+0x7c>
		return 0;

	status = REG_READ(&priv->regs->rtdata);
	rxlen = REG_READ(&priv->regs->rtdata);
57e1c820:	e5943000 	ldr	r3, [r4]
57e1c824:	e1d310b0 	ldrh	r1, [r3]

	if (rxlen > PKTSIZE_ALIGN + PKTALIGN)
		debug("packet too big!\n");
	for (addr = (u16 *) NetRxPackets[0], i = rxlen >> 1; i > 0;
57e1c828:	e59f3058 	ldr	r3, [pc, #88]	; 57e1c888 <cs8900_recv+0x84>
57e1c82c:	e1a000a1 	lsr	r0, r1, #1
57e1c830:	e5932000 	ldr	r2, [r3]
57e1c834:	e1a03000 	mov	r3, r0
57e1c838:	e1a0c002 	mov	ip, r2
57e1c83c:	ea000003 	b	57e1c850 <cs8900_recv+0x4c>
		 i--)
		*addr++ = REG_READ(&priv->regs->rtdata);
57e1c840:	e594e000 	ldr	lr, [r4]
57e1c844:	e1dee0b0 	ldrh	lr, [lr]
57e1c848:	e0cce0b2 	strh	lr, [ip], #2
	rxlen = REG_READ(&priv->regs->rtdata);

	if (rxlen > PKTSIZE_ALIGN + PKTALIGN)
		debug("packet too big!\n");
	for (addr = (u16 *) NetRxPackets[0], i = rxlen >> 1; i > 0;
		 i--)
57e1c84c:	e2433001 	sub	r3, r3, #1
	status = REG_READ(&priv->regs->rtdata);
	rxlen = REG_READ(&priv->regs->rtdata);

	if (rxlen > PKTSIZE_ALIGN + PKTALIGN)
		debug("packet too big!\n");
	for (addr = (u16 *) NetRxPackets[0], i = rxlen >> 1; i > 0;
57e1c850:	e3530000 	cmp	r3, #0
57e1c854:	1afffff9 	bne	57e1c840 <cs8900_recv+0x3c>
		 i--)
		*addr++ = REG_READ(&priv->regs->rtdata);
	if (rxlen & 1)
57e1c858:	e3110001 	tst	r1, #1
	cs8900_reginit(dev);
	return 0;
}

/* Get a data block via Ethernet */
static int cs8900_recv(struct eth_device *dev)
57e1c85c:	e1a00080 	lsl	r0, r0, #1
	if (rxlen > PKTSIZE_ALIGN + PKTALIGN)
		debug("packet too big!\n");
	for (addr = (u16 *) NetRxPackets[0], i = rxlen >> 1; i > 0;
		 i--)
		*addr++ = REG_READ(&priv->regs->rtdata);
	if (rxlen & 1)
57e1c860:	e1a05001 	mov	r5, r1
57e1c864:	0a000002 	beq	57e1c874 <cs8900_recv+0x70>
		*addr++ = REG_READ(&priv->regs->rtdata);
57e1c868:	e5943000 	ldr	r3, [r4]
57e1c86c:	e1d330b0 	ldrh	r3, [r3]
57e1c870:	e18230b0 	strh	r3, [r2, r0]

	/* Pass the packet up to the protocol layers. */
	NetReceive (NetRxPackets[0], rxlen);
57e1c874:	e59f300c 	ldr	r3, [pc, #12]	; 57e1c888 <cs8900_recv+0x84>
57e1c878:	e5930000 	ldr	r0, [r3]
57e1c87c:	eb00321a 	bl	57e290ec <NetReceive>
	return rxlen;
}
57e1c880:	e1a00005 	mov	r0, r5
57e1c884:	e8bd8038 	pop	{r3, r4, r5, pc}
57e1c888:	57e7b650 	.word	0x57e7b650

57e1c88c <put_reg.clone.1>:


static void put_reg(struct eth_device *dev, int regno, u16 val)
{
	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);
	REG_WRITE(regno, &priv->regs->pptr);
57e1c88c:	e1a01801 	lsl	r1, r1, #16
57e1c890:	e1a01821 	lsr	r1, r1, #16
57e1c894:	e5903000 	ldr	r3, [r0]
57e1c898:	e1c310ba 	strh	r1, [r3, #10]
	REG_WRITE(val, &priv->regs->pdata);
57e1c89c:	e5903000 	ldr	r3, [r0]
57e1c8a0:	e1c320bc 	strh	r2, [r3, #12]
}
57e1c8a4:	e12fff1e 	bx	lr

57e1c8a8 <cs8900_halt>:
		}
	}
}

void cs8900_halt(struct eth_device *dev)
{
57e1c8a8:	e92d4010 	push	{r4, lr}
	/* disable transmitter/receiver mode */
	put_reg(dev, PP_LineCTL, 0);
57e1c8ac:	e59f101c 	ldr	r1, [pc, #28]	; 57e1c8d0 <cs8900_halt+0x28>
		}
	}
}

void cs8900_halt(struct eth_device *dev)
{
57e1c8b0:	e1a04000 	mov	r4, r0
	/* disable transmitter/receiver mode */
	put_reg(dev, PP_LineCTL, 0);
57e1c8b4:	e3a02000 	mov	r2, #0
57e1c8b8:	e590003c 	ldr	r0, [r0, #60]	; 0x3c
57e1c8bc:	ebfffff2 	bl	57e1c88c <put_reg.clone.1>

	/* "shutdown" to show ChipID or kernel wouldn't find he cs8900 ... */
	get_reg_init_bus(dev, PP_ChipID);
57e1c8c0:	e1a00004 	mov	r0, r4
57e1c8c4:	e3a01000 	mov	r1, #0
}
57e1c8c8:	e8bd4010 	pop	{r4, lr}
{
	/* disable transmitter/receiver mode */
	put_reg(dev, PP_LineCTL, 0);

	/* "shutdown" to show ChipID or kernel wouldn't find he cs8900 ... */
	get_reg_init_bus(dev, PP_ChipID);
57e1c8cc:	eaffffb9 	b	57e1c7b8 <get_reg_init_bus>
57e1c8d0:	00000112 	.word	0x00000112

57e1c8d4 <cs8900_reset>:
	REG_WRITE(regno, &priv->regs->pptr);
	REG_WRITE(val, &priv->regs->pdata);
}

static void cs8900_reset(struct eth_device *dev)
{
57e1c8d4:	e92d4038 	push	{r3, r4, r5, lr}
	int tmo;
	u16 us;

	/* reset NIC */
	put_reg(dev, PP_SelfCTL, get_reg(dev, PP_SelfCTL) | PP_SelfCTL_Reset);
57e1c8d8:	e3a01f45 	mov	r1, #276	; 0x114
	REG_WRITE(regno, &priv->regs->pptr);
	REG_WRITE(val, &priv->regs->pdata);
}

static void cs8900_reset(struct eth_device *dev)
{
57e1c8dc:	e1a04000 	mov	r4, r0
	int tmo;
	u16 us;

	/* reset NIC */
	put_reg(dev, PP_SelfCTL, get_reg(dev, PP_SelfCTL) | PP_SelfCTL_Reset);
57e1c8e0:	e590003c 	ldr	r0, [r0, #60]	; 0x3c
57e1c8e4:	ebffffc0 	bl	57e1c7ec <get_reg.clone.0>
57e1c8e8:	e3802040 	orr	r2, r0, #64	; 0x40
57e1c8ec:	e1a02802 	lsl	r2, r2, #16
57e1c8f0:	e3a01f45 	mov	r1, #276	; 0x114
57e1c8f4:	e1a02822 	lsr	r2, r2, #16
57e1c8f8:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1c8fc:	ebffffe2 	bl	57e1c88c <put_reg.clone.1>

	/* wait for 200ms */
	udelay(200000);
57e1c900:	e59f0030 	ldr	r0, [pc, #48]	; 57e1c938 <cs8900_reset+0x64>
57e1c904:	eb001f0b 	bl	57e24538 <udelay>
	/* Wait until the chip is reset */

	tmo = get_timer(0) + 1 * CONFIG_SYS_HZ;
57e1c908:	e3a00000 	mov	r0, #0
57e1c90c:	ebff907e 	bl	57e00b0c <get_timer>
57e1c910:	e2805ffa 	add	r5, r0, #1000	; 0x3e8
	while ((((us = get_reg_init_bus(dev, PP_SelfSTAT)) &
57e1c914:	e1a00004 	mov	r0, r4
57e1c918:	e59f101c 	ldr	r1, [pc, #28]	; 57e1c93c <cs8900_reset+0x68>
57e1c91c:	ebffffa5 	bl	57e1c7b8 <get_reg_init_bus>
57e1c920:	e2100080 	ands	r0, r0, #128	; 0x80
57e1c924:	18bd8038 	popne	{r3, r4, r5, pc}
		PP_SelfSTAT_InitD) == 0) && tmo < get_timer(0))
57e1c928:	ebff9077 	bl	57e00b0c <get_timer>
57e1c92c:	e1550000 	cmp	r5, r0
57e1c930:	3afffff7 	bcc	57e1c914 <cs8900_reset+0x40>
57e1c934:	e8bd8038 	pop	{r3, r4, r5, pc}
57e1c938:	00030d40 	.word	0x00030d40
57e1c93c:	00000136 	.word	0x00000136

57e1c940 <cs8900_reginit.clone.2>:
		/*NOP*/;
}

static void cs8900_reginit(struct eth_device *dev)
57e1c940:	e92d4010 	push	{r4, lr}
{
	/* receive only error free packets addressed to this card */
	put_reg(dev, PP_RxCTL,
57e1c944:	e3a01f41 	mov	r1, #260	; 0x104
	while ((((us = get_reg_init_bus(dev, PP_SelfSTAT)) &
		PP_SelfSTAT_InitD) == 0) && tmo < get_timer(0))
		/*NOP*/;
}

static void cs8900_reginit(struct eth_device *dev)
57e1c948:	e1a04000 	mov	r4, r0
{
	/* receive only error free packets addressed to this card */
	put_reg(dev, PP_RxCTL,
57e1c94c:	e3a02c0d 	mov	r2, #3328	; 0xd00
57e1c950:	e5900000 	ldr	r0, [r0]
57e1c954:	ebffffcc 	bl	57e1c88c <put_reg.clone.1>
		PP_RxCTL_IA | PP_RxCTL_Broadcast | PP_RxCTL_RxOK);
	/* do not generate any interrupts on receive operations */
	put_reg(dev, PP_RxCFG, 0);
57e1c958:	e5940000 	ldr	r0, [r4]
57e1c95c:	e59f1038 	ldr	r1, [pc, #56]	; 57e1c99c <cs8900_reginit.clone.2+0x5c>
57e1c960:	e3a02000 	mov	r2, #0
57e1c964:	ebffffc8 	bl	57e1c88c <put_reg.clone.1>
	/* do not generate any interrupts on transmit operations */
	put_reg(dev, PP_TxCFG, 0);
57e1c968:	e5940000 	ldr	r0, [r4]
57e1c96c:	e59f102c 	ldr	r1, [pc, #44]	; 57e1c9a0 <cs8900_reginit.clone.2+0x60>
57e1c970:	e3a02000 	mov	r2, #0
57e1c974:	ebffffc4 	bl	57e1c88c <put_reg.clone.1>
	/* do not generate any interrupts on buffer operations */
	put_reg(dev, PP_BufCFG, 0);
57e1c978:	e5940000 	ldr	r0, [r4]
57e1c97c:	e59f1020 	ldr	r1, [pc, #32]	; 57e1c9a4 <cs8900_reginit.clone.2+0x64>
57e1c980:	e3a02000 	mov	r2, #0
57e1c984:	ebffffc0 	bl	57e1c88c <put_reg.clone.1>
	/* enable transmitter/receiver mode */
	put_reg(dev, PP_LineCTL, PP_LineCTL_Rx | PP_LineCTL_Tx);
57e1c988:	e5940000 	ldr	r0, [r4]
57e1c98c:	e59f1014 	ldr	r1, [pc, #20]	; 57e1c9a8 <cs8900_reginit.clone.2+0x68>
57e1c990:	e3a020c0 	mov	r2, #192	; 0xc0
}
57e1c994:	e8bd4010 	pop	{r4, lr}
	/* do not generate any interrupts on transmit operations */
	put_reg(dev, PP_TxCFG, 0);
	/* do not generate any interrupts on buffer operations */
	put_reg(dev, PP_BufCFG, 0);
	/* enable transmitter/receiver mode */
	put_reg(dev, PP_LineCTL, PP_LineCTL_Rx | PP_LineCTL_Tx);
57e1c998:	eaffffbb 	b	57e1c88c <put_reg.clone.1>
57e1c99c:	00000102 	.word	0x00000102
57e1c9a0:	00000106 	.word	0x00000106
57e1c9a4:	0000010a 	.word	0x0000010a
57e1c9a8:	00000112 	.word	0x00000112

57e1c9ac <cs8900_send>:
	return rxlen;
}

/* Send a data block via Ethernet. */
static int cs8900_send(struct eth_device *dev, void *packet, int length)
{
57e1c9ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	volatile u16 *addr;
	int tmo;
	u16 s;
	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);
57e1c9b0:	e1a0a000 	mov	sl, r0

retry:
	/* initiate a transmit sequence */
	REG_WRITE(PP_TxCmd_TxStart_Full, &priv->regs->txcmd);
	REG_WRITE(length, &priv->regs->txlen);
57e1c9b4:	e1a09802 	lsl	r9, r2, #16
static int cs8900_send(struct eth_device *dev, void *packet, int length)
{
	volatile u16 *addr;
	int tmo;
	u16 s;
	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);
57e1c9b8:	e5ba703c 	ldr	r7, [sl, #60]!	; 0x3c
	return rxlen;
}

/* Send a data block via Ethernet. */
static int cs8900_send(struct eth_device *dev, void *packet, int length)
{
57e1c9bc:	e1a04000 	mov	r4, r0
57e1c9c0:	e1a05001 	mov	r5, r1
57e1c9c4:	e1a06002 	mov	r6, r2
	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);

retry:
	/* initiate a transmit sequence */
	REG_WRITE(PP_TxCmd_TxStart_Full, &priv->regs->txcmd);
	REG_WRITE(length, &priv->regs->txlen);
57e1c9c8:	e1a09829 	lsr	r9, r9, #16
	u16 s;
	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);

retry:
	/* initiate a transmit sequence */
	REG_WRITE(PP_TxCmd_TxStart_Full, &priv->regs->txcmd);
57e1c9cc:	e5973000 	ldr	r3, [r7]
57e1c9d0:	e3a020c0 	mov	r2, #192	; 0xc0
57e1c9d4:	e1c320b4 	strh	r2, [r3, #4]
	REG_WRITE(length, &priv->regs->txlen);
57e1c9d8:	e5973000 	ldr	r3, [r7]

	/* Test to see if the chip has allocated memory for the packet */
	if ((get_reg(dev, PP_BusSTAT) & PP_BusSTAT_TxRDY) == 0) {
57e1c9dc:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
	struct cs8900_priv *priv = (struct cs8900_priv *)(dev->priv);

retry:
	/* initiate a transmit sequence */
	REG_WRITE(PP_TxCmd_TxStart_Full, &priv->regs->txcmd);
	REG_WRITE(length, &priv->regs->txlen);
57e1c9e0:	e1c390b6 	strh	r9, [r3, #6]

	/* Test to see if the chip has allocated memory for the packet */
	if ((get_reg(dev, PP_BusSTAT) & PP_BusSTAT_TxRDY) == 0) {
57e1c9e4:	e3a01f4e 	mov	r1, #312	; 0x138
57e1c9e8:	ebffff7f 	bl	57e1c7ec <get_reg.clone.0>
57e1c9ec:	e2100c01 	ands	r0, r0, #256	; 0x100
57e1c9f0:	1a00000f 	bne	57e1ca34 <cs8900_send+0x88>
		/* Oops... this should not happen! */
		debug("cs: unable to send packet; retrying...\n");
		for (tmo = get_timer(0) + 5 * CONFIG_SYS_HZ;
57e1c9f4:	ebff9044 	bl	57e00b0c <get_timer>
57e1c9f8:	e2800d4e 	add	r0, r0, #4992	; 0x1380
57e1c9fc:	e280b008 	add	fp, r0, #8
			get_timer(0) < tmo;)
57e1ca00:	e3a00000 	mov	r0, #0
57e1ca04:	ebff9040 	bl	57e00b0c <get_timer>

	/* Test to see if the chip has allocated memory for the packet */
	if ((get_reg(dev, PP_BusSTAT) & PP_BusSTAT_TxRDY) == 0) {
		/* Oops... this should not happen! */
		debug("cs: unable to send packet; retrying...\n");
		for (tmo = get_timer(0) + 5 * CONFIG_SYS_HZ;
57e1ca08:	e150000b 	cmp	r0, fp
57e1ca0c:	3afffffb 	bcc	57e1ca00 <cs8900_send+0x54>
			get_timer(0) < tmo;)
			/*NOP*/;
		cs8900_reset(dev);
57e1ca10:	e1a00004 	mov	r0, r4
57e1ca14:	ebffffae 	bl	57e1c8d4 <cs8900_reset>
		cs8900_reginit(dev);
57e1ca18:	e1a0000a 	mov	r0, sl
57e1ca1c:	ebffffc7 	bl	57e1c940 <cs8900_reginit.clone.2>
		goto retry;
57e1ca20:	eaffffe9 	b	57e1c9cc <cs8900_send+0x20>
	}

	/* Write the contents of the packet */
	/* assume even number of bytes */
	for (addr = packet; length > 0; length -= 2)
		REG_WRITE(*addr++, &priv->regs->rtdata);
57e1ca24:	e0d520b2 	ldrh	r2, [r5], #2
57e1ca28:	e5973000 	ldr	r3, [r7]
		goto retry;
	}

	/* Write the contents of the packet */
	/* assume even number of bytes */
	for (addr = packet; length > 0; length -= 2)
57e1ca2c:	e2466002 	sub	r6, r6, #2
		REG_WRITE(*addr++, &priv->regs->rtdata);
57e1ca30:	e1c320b0 	strh	r2, [r3]
		goto retry;
	}

	/* Write the contents of the packet */
	/* assume even number of bytes */
	for (addr = packet; length > 0; length -= 2)
57e1ca34:	e3560000 	cmp	r6, #0
57e1ca38:	cafffff9 	bgt	57e1ca24 <cs8900_send+0x78>
		REG_WRITE(*addr++, &priv->regs->rtdata);

	/* wait for transfer to succeed */
	tmo = get_timer(0) + 5 * CONFIG_SYS_HZ;
57e1ca3c:	e3a00000 	mov	r0, #0
57e1ca40:	ebff9031 	bl	57e00b0c <get_timer>
57e1ca44:	e2800d4e 	add	r0, r0, #4992	; 0x1380
57e1ca48:	e2805008 	add	r5, r0, #8
	while ((s = get_reg(dev, PP_TER) & ~0x1F) == 0) {
57e1ca4c:	ea000003 	b	57e1ca60 <cs8900_send+0xb4>
		if (get_timer(0) >= tmo)
57e1ca50:	e1a00003 	mov	r0, r3
57e1ca54:	ebff902c 	bl	57e00b0c <get_timer>
57e1ca58:	e1500005 	cmp	r0, r5
57e1ca5c:	2a000006 	bcs	57e1ca7c <cs8900_send+0xd0>
	for (addr = packet; length > 0; length -= 2)
		REG_WRITE(*addr++, &priv->regs->rtdata);

	/* wait for transfer to succeed */
	tmo = get_timer(0) + 5 * CONFIG_SYS_HZ;
	while ((s = get_reg(dev, PP_TER) & ~0x1F) == 0) {
57e1ca60:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1ca64:	e3a01f4a 	mov	r1, #296	; 0x128
57e1ca68:	ebffff5f 	bl	57e1c7ec <get_reg.clone.0>
57e1ca6c:	e59f3010 	ldr	r3, [pc, #16]	; 57e1ca84 <cs8900_send+0xd8>
57e1ca70:	e0003003 	and	r3, r0, r3
57e1ca74:	e3530000 	cmp	r3, #0
57e1ca78:	0afffff4 	beq	57e1ca50 <cs8900_send+0xa4>
	if((s & (PP_TER_CRS | PP_TER_TxOK)) != PP_TER_TxOK) {
		debug("\ntransmission error %#x\n", s);
	}

	return 0;
}
57e1ca7c:	e3a00000 	mov	r0, #0
57e1ca80:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1ca84:	0000ffe0 	.word	0x0000ffe0

57e1ca88 <cs8900_init>:
	/* "shutdown" to show ChipID or kernel wouldn't find he cs8900 ... */
	get_reg_init_bus(dev, PP_ChipID);
}

static int cs8900_init(struct eth_device *dev, bd_t * bd)
{
57e1ca88:	e92d4010 	push	{r4, lr}
	uchar *enetaddr = dev->enetaddr;
	u16 id;

	/* verify chip id */
	id = get_reg_init_bus(dev, PP_ChipID);
57e1ca8c:	e3a01000 	mov	r1, #0
	/* "shutdown" to show ChipID or kernel wouldn't find he cs8900 ... */
	get_reg_init_bus(dev, PP_ChipID);
}

static int cs8900_init(struct eth_device *dev, bd_t * bd)
{
57e1ca90:	e1a04000 	mov	r4, r0
	uchar *enetaddr = dev->enetaddr;
	u16 id;

	/* verify chip id */
	id = get_reg_init_bus(dev, PP_ChipID);
57e1ca94:	ebffff47 	bl	57e1c7b8 <get_reg_init_bus>
	if (id != 0x630e) {
57e1ca98:	e59f2078 	ldr	r2, [pc, #120]	; 57e1cb18 <cs8900_init+0x90>
{
	uchar *enetaddr = dev->enetaddr;
	u16 id;

	/* verify chip id */
	id = get_reg_init_bus(dev, PP_ChipID);
57e1ca9c:	e1a01000 	mov	r1, r0
	if (id != 0x630e) {
57e1caa0:	e1500002 	cmp	r0, r2
57e1caa4:	0a000003 	beq	57e1cab8 <cs8900_init+0x30>
		printf ("CS8900 Ethernet chip not found: "
57e1caa8:	e59f006c 	ldr	r0, [pc, #108]	; 57e1cb1c <cs8900_init+0x94>
57e1caac:	ebffb266 	bl	57e0944c <printf>
			"ID=0x%04x instead 0x%04x\n", id, 0x630e);
		return 1;
57e1cab0:	e3a00001 	mov	r0, #1
57e1cab4:	e8bd8010 	pop	{r4, pc}
	}

	cs8900_reset (dev);
57e1cab8:	e1a00004 	mov	r0, r4
57e1cabc:	ebffff84 	bl	57e1c8d4 <cs8900_reset>
	/* set the ethernet address */
	put_reg(dev, PP_IA + 0, enetaddr[0] | (enetaddr[1] << 8));
57e1cac0:	e5d43010 	ldrb	r3, [r4, #16]
57e1cac4:	e5d42011 	ldrb	r2, [r4, #17]
57e1cac8:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cacc:	e1832402 	orr	r2, r3, r2, lsl #8
57e1cad0:	e3a01f56 	mov	r1, #344	; 0x158
57e1cad4:	ebffff6c 	bl	57e1c88c <put_reg.clone.1>
	put_reg(dev, PP_IA + 2, enetaddr[2] | (enetaddr[3] << 8));
57e1cad8:	e5d43012 	ldrb	r3, [r4, #18]
57e1cadc:	e5d42013 	ldrb	r2, [r4, #19]
57e1cae0:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cae4:	e1832402 	orr	r2, r3, r2, lsl #8
57e1cae8:	e59f1030 	ldr	r1, [pc, #48]	; 57e1cb20 <cs8900_init+0x98>
57e1caec:	ebffff66 	bl	57e1c88c <put_reg.clone.1>
	put_reg(dev, PP_IA + 4, enetaddr[4] | (enetaddr[5] << 8));
57e1caf0:	e5d43014 	ldrb	r3, [r4, #20]
57e1caf4:	e5d42015 	ldrb	r2, [r4, #21]
57e1caf8:	e5b4003c 	ldr	r0, [r4, #60]!	; 0x3c
57e1cafc:	e3a01f57 	mov	r1, #348	; 0x15c
57e1cb00:	e1832402 	orr	r2, r3, r2, lsl #8
57e1cb04:	ebffff60 	bl	57e1c88c <put_reg.clone.1>

	cs8900_reginit(dev);
57e1cb08:	e1a00004 	mov	r0, r4
57e1cb0c:	ebffff8b 	bl	57e1c940 <cs8900_reginit.clone.2>
	return 0;
57e1cb10:	e3a00000 	mov	r0, #0
}
57e1cb14:	e8bd8010 	pop	{r4, pc}
57e1cb18:	0000630e 	.word	0x0000630e
57e1cb1c:	57e3459f 	.word	0x57e3459f
57e1cb20:	0000015a 	.word	0x0000015a

57e1cb24 <cs8900_e2prom_ready.clone.3>:
	}

	return 0;
}

static void cs8900_e2prom_ready(struct eth_device *dev)
57e1cb24:	e92d4010 	push	{r4, lr}
57e1cb28:	e1a04000 	mov	r4, r0
{
	while (get_reg(dev, PP_SelfSTAT) & SI_BUSY)
57e1cb2c:	e5940000 	ldr	r0, [r4]
57e1cb30:	e59f100c 	ldr	r1, [pc, #12]	; 57e1cb44 <cs8900_e2prom_ready.clone.3+0x20>
57e1cb34:	ebffff2c 	bl	57e1c7ec <get_reg.clone.0>
57e1cb38:	e3100c01 	tst	r0, #256	; 0x100
57e1cb3c:	1afffffa 	bne	57e1cb2c <cs8900_e2prom_ready.clone.3+0x8>
		;
}
57e1cb40:	e8bd8010 	pop	{r4, pc}
57e1cb44:	00000136 	.word	0x00000136

57e1cb48 <cs8900_get_enetaddr>:
	/* enable transmitter/receiver mode */
	put_reg(dev, PP_LineCTL, PP_LineCTL_Rx | PP_LineCTL_Tx);
}

void cs8900_get_enetaddr(struct eth_device *dev)
{
57e1cb48:	e92d4010 	push	{r4, lr}
	int i;

	/* verify chip id */
	if (get_reg_init_bus(dev, PP_ChipID) != 0x630e)
57e1cb4c:	e3a01000 	mov	r1, #0
	/* enable transmitter/receiver mode */
	put_reg(dev, PP_LineCTL, PP_LineCTL_Rx | PP_LineCTL_Tx);
}

void cs8900_get_enetaddr(struct eth_device *dev)
{
57e1cb50:	e1a04000 	mov	r4, r0
	int i;

	/* verify chip id */
	if (get_reg_init_bus(dev, PP_ChipID) != 0x630e)
57e1cb54:	ebffff17 	bl	57e1c7b8 <get_reg_init_bus>
57e1cb58:	e59f3070 	ldr	r3, [pc, #112]	; 57e1cbd0 <cs8900_get_enetaddr+0x88>
57e1cb5c:	e1500003 	cmp	r0, r3
57e1cb60:	18bd8010 	popne	{r4, pc}
		return;
	cs8900_reset(dev);
57e1cb64:	e1a00004 	mov	r0, r4
57e1cb68:	ebffff59 	bl	57e1c8d4 <cs8900_reset>
	if ((get_reg(dev, PP_SelfSTAT) &
57e1cb6c:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cb70:	e59f105c 	ldr	r1, [pc, #92]	; 57e1cbd4 <cs8900_get_enetaddr+0x8c>
57e1cb74:	ebffff1c 	bl	57e1c7ec <get_reg.clone.0>
57e1cb78:	e2000c06 	and	r0, r0, #1536	; 0x600
57e1cb7c:	e3500c06 	cmp	r0, #1536	; 0x600
57e1cb80:	18bd8010 	popne	{r4, pc}

		/* Load the MAC from EEPROM */
		for (i = 0; i < 3; i++) {
			u32 Addr;

			Addr = get_reg(dev, PP_IA + i * 2);
57e1cb84:	e3a01f56 	mov	r1, #344	; 0x158
57e1cb88:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cb8c:	ebffff16 	bl	57e1c7ec <get_reg.clone.0>
			dev->enetaddr[i * 2] = Addr & 0xFF;
57e1cb90:	e5c40010 	strb	r0, [r4, #16]
			dev->enetaddr[i * 2 + 1] = Addr >> 8;
57e1cb94:	e1a00420 	lsr	r0, r0, #8
57e1cb98:	e5c40011 	strb	r0, [r4, #17]

		/* Load the MAC from EEPROM */
		for (i = 0; i < 3; i++) {
			u32 Addr;

			Addr = get_reg(dev, PP_IA + i * 2);
57e1cb9c:	e59f1034 	ldr	r1, [pc, #52]	; 57e1cbd8 <cs8900_get_enetaddr+0x90>
57e1cba0:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cba4:	ebffff10 	bl	57e1c7ec <get_reg.clone.0>
			dev->enetaddr[i * 2] = Addr & 0xFF;
57e1cba8:	e5c40012 	strb	r0, [r4, #18]
			dev->enetaddr[i * 2 + 1] = Addr >> 8;
57e1cbac:	e1a00420 	lsr	r0, r0, #8
57e1cbb0:	e5c40013 	strb	r0, [r4, #19]

		/* Load the MAC from EEPROM */
		for (i = 0; i < 3; i++) {
			u32 Addr;

			Addr = get_reg(dev, PP_IA + i * 2);
57e1cbb4:	e3a01f57 	mov	r1, #348	; 0x15c
57e1cbb8:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cbbc:	ebffff0a 	bl	57e1c7ec <get_reg.clone.0>
			dev->enetaddr[i * 2] = Addr & 0xFF;
57e1cbc0:	e5c40014 	strb	r0, [r4, #20]
			dev->enetaddr[i * 2 + 1] = Addr >> 8;
57e1cbc4:	e1a00420 	lsr	r0, r0, #8
57e1cbc8:	e5c40015 	strb	r0, [r4, #21]
57e1cbcc:	e8bd8010 	pop	{r4, pc}
57e1cbd0:	0000630e 	.word	0x0000630e
57e1cbd4:	00000136 	.word	0x00000136
57e1cbd8:	0000015a 	.word	0x0000015a

57e1cbdc <cs8900_e2prom_read>:
/* read a 16-bit word out of the EEPROM                    */
/***********************************************************/

int cs8900_e2prom_read(struct eth_device *dev,
			u8 addr, u16 *value)
{
57e1cbdc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}

	sprintf(dev->name, "%s-%hu", CS8900_DRIVERNAME, dev_num);

	eth_register(dev);
	return 0;
}
57e1cbe0:	e280503c 	add	r5, r0, #60	; 0x3c
/* read a 16-bit word out of the EEPROM                    */
/***********************************************************/

int cs8900_e2prom_read(struct eth_device *dev,
			u8 addr, u16 *value)
{
57e1cbe4:	e1a04000 	mov	r4, r0
57e1cbe8:	e1a07001 	mov	r7, r1
	cs8900_e2prom_ready(dev);
57e1cbec:	e1a00005 	mov	r0, r5
/* read a 16-bit word out of the EEPROM                    */
/***********************************************************/

int cs8900_e2prom_read(struct eth_device *dev,
			u8 addr, u16 *value)
{
57e1cbf0:	e1a06002 	mov	r6, r2
	cs8900_e2prom_ready(dev);
57e1cbf4:	ebffffca 	bl	57e1cb24 <cs8900_e2prom_ready.clone.3>
	put_reg(dev, PP_EECMD, EEPROM_READ_CMD | addr);
57e1cbf8:	e3872c02 	orr	r2, r7, #512	; 0x200
57e1cbfc:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cc00:	e3a01040 	mov	r1, #64	; 0x40
57e1cc04:	ebffff20 	bl	57e1c88c <put_reg.clone.1>
	cs8900_e2prom_ready(dev);
57e1cc08:	e1a00005 	mov	r0, r5
57e1cc0c:	ebffffc4 	bl	57e1cb24 <cs8900_e2prom_ready.clone.3>
	*value = get_reg(dev, PP_EEData);
57e1cc10:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cc14:	e3a01042 	mov	r1, #66	; 0x42
57e1cc18:	ebfffef3 	bl	57e1c7ec <get_reg.clone.0>
57e1cc1c:	e1c600b0 	strh	r0, [r6]

	return 0;
}
57e1cc20:	e3a00000 	mov	r0, #0
57e1cc24:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e1cc28 <cs8900_e2prom_write>:
/***********************************************************/
/* write a 16-bit word into the EEPROM                     */
/***********************************************************/

int cs8900_e2prom_write(struct eth_device *dev, u8 addr, u16 value)
{
57e1cc28:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}

	sprintf(dev->name, "%s-%hu", CS8900_DRIVERNAME, dev_num);

	eth_register(dev);
	return 0;
}
57e1cc2c:	e280503c 	add	r5, r0, #60	; 0x3c
/***********************************************************/
/* write a 16-bit word into the EEPROM                     */
/***********************************************************/

int cs8900_e2prom_write(struct eth_device *dev, u8 addr, u16 value)
{
57e1cc30:	e1a04000 	mov	r4, r0
	cs8900_e2prom_ready(dev);
57e1cc34:	e1a00005 	mov	r0, r5
/***********************************************************/
/* write a 16-bit word into the EEPROM                     */
/***********************************************************/

int cs8900_e2prom_write(struct eth_device *dev, u8 addr, u16 value)
{
57e1cc38:	e1a06001 	mov	r6, r1
57e1cc3c:	e1a07002 	mov	r7, r2
	cs8900_e2prom_ready(dev);
57e1cc40:	ebffffb7 	bl	57e1cb24 <cs8900_e2prom_ready.clone.3>
	put_reg(dev, PP_EECMD, EEPROM_WRITE_EN);
57e1cc44:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cc48:	e3a01040 	mov	r1, #64	; 0x40
57e1cc4c:	e3a020f0 	mov	r2, #240	; 0xf0
57e1cc50:	ebffff0d 	bl	57e1c88c <put_reg.clone.1>
	cs8900_e2prom_ready(dev);
57e1cc54:	e1a00005 	mov	r0, r5
57e1cc58:	ebffffb1 	bl	57e1cb24 <cs8900_e2prom_ready.clone.3>
	put_reg(dev, PP_EEData, value);
57e1cc5c:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cc60:	e1a02007 	mov	r2, r7
57e1cc64:	e3a01042 	mov	r1, #66	; 0x42
57e1cc68:	ebffff07 	bl	57e1c88c <put_reg.clone.1>
	put_reg(dev, PP_EECMD, EEPROM_WRITE_CMD | addr);
57e1cc6c:	e3862c01 	orr	r2, r6, #256	; 0x100
57e1cc70:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cc74:	e3a01040 	mov	r1, #64	; 0x40
57e1cc78:	ebffff03 	bl	57e1c88c <put_reg.clone.1>
	cs8900_e2prom_ready(dev);
57e1cc7c:	e1a00005 	mov	r0, r5
57e1cc80:	ebffffa7 	bl	57e1cb24 <cs8900_e2prom_ready.clone.3>
	put_reg(dev, PP_EECMD, EEPROM_WRITE_DIS);
57e1cc84:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
57e1cc88:	e3a01040 	mov	r1, #64	; 0x40
57e1cc8c:	e3a02000 	mov	r2, #0
57e1cc90:	ebfffefd 	bl	57e1c88c <put_reg.clone.1>
	cs8900_e2prom_ready(dev);
57e1cc94:	e1a00005 	mov	r0, r5
57e1cc98:	ebffffa1 	bl	57e1cb24 <cs8900_e2prom_ready.clone.3>

	return 0;
}
57e1cc9c:	e3a00000 	mov	r0, #0
57e1cca0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e1cca4 <cs8900_initialize>:

int cs8900_initialize(u8 dev_num, int base_addr)
{
57e1cca4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e1cca8:	e1a07000 	mov	r7, r0
	struct eth_device *dev;
	struct cs8900_priv *priv;

	dev = malloc(sizeof(*dev));
57e1ccac:	e3a00040 	mov	r0, #64	; 0x40

	return 0;
}

int cs8900_initialize(u8 dev_num, int base_addr)
{
57e1ccb0:	e1a06001 	mov	r6, r1
	struct eth_device *dev;
	struct cs8900_priv *priv;

	dev = malloc(sizeof(*dev));
57e1ccb4:	ebffb3c2 	bl	57e09bc4 <malloc>
	if (!dev) {
57e1ccb8:	e2504000 	subs	r4, r0, #0
57e1ccbc:	0a000020 	beq	57e1cd44 <cs8900_initialize+0xa0>
		return 0;
	}
	memset(dev, 0, sizeof(*dev));
57e1ccc0:	e3a01000 	mov	r1, #0
57e1ccc4:	e3a02040 	mov	r2, #64	; 0x40
57e1ccc8:	eb001d6b 	bl	57e2427c <memset>

	priv = malloc(sizeof(*priv));
57e1cccc:	e3a00004 	mov	r0, #4
57e1ccd0:	ebffb3bb 	bl	57e09bc4 <malloc>
	if (!priv) {
57e1ccd4:	e2505000 	subs	r5, r0, #0
57e1ccd8:	1a000002 	bne	57e1cce8 <cs8900_initialize+0x44>
		free(dev);
57e1ccdc:	e1a00004 	mov	r0, r4
57e1cce0:	ebffb32d 	bl	57e0999c <free>
		return 0;
57e1cce4:	ea000016 	b	57e1cd44 <cs8900_initialize+0xa0>
	}
	memset(priv, 0, sizeof(*priv));
57e1cce8:	e3a01000 	mov	r1, #0
57e1ccec:	e3a02004 	mov	r2, #4
57e1ccf0:	eb001d61 	bl	57e2427c <memset>
	priv->regs = (struct cs8900_regs *)base_addr;

	dev->iobase = base_addr;
	dev->priv = priv;
	dev->init = cs8900_init;
57e1ccf4:	e59f3050 	ldr	r3, [pc, #80]	; 57e1cd4c <cs8900_initialize+0xa8>
	if (!priv) {
		free(dev);
		return 0;
	}
	memset(priv, 0, sizeof(*priv));
	priv->regs = (struct cs8900_regs *)base_addr;
57e1ccf8:	e5856000 	str	r6, [r5]

	dev->iobase = base_addr;
	dev->priv = priv;
	dev->init = cs8900_init;
57e1ccfc:	e5843020 	str	r3, [r4, #32]
	dev->halt = cs8900_halt;
57e1cd00:	e59f3048 	ldr	r3, [pc, #72]	; 57e1cd50 <cs8900_initialize+0xac>
	dev->send = cs8900_send;
	dev->recv = cs8900_recv;

	/* Load MAC address from EEPROM */
	cs8900_get_enetaddr(dev);
57e1cd04:	e1a00004 	mov	r0, r4
	priv->regs = (struct cs8900_regs *)base_addr;

	dev->iobase = base_addr;
	dev->priv = priv;
	dev->init = cs8900_init;
	dev->halt = cs8900_halt;
57e1cd08:	e584302c 	str	r3, [r4, #44]	; 0x2c
	dev->send = cs8900_send;
57e1cd0c:	e59f3040 	ldr	r3, [pc, #64]	; 57e1cd54 <cs8900_initialize+0xb0>
		return 0;
	}
	memset(priv, 0, sizeof(*priv));
	priv->regs = (struct cs8900_regs *)base_addr;

	dev->iobase = base_addr;
57e1cd10:	e5846018 	str	r6, [r4, #24]
	dev->priv = priv;
	dev->init = cs8900_init;
	dev->halt = cs8900_halt;
	dev->send = cs8900_send;
57e1cd14:	e5843024 	str	r3, [r4, #36]	; 0x24
	dev->recv = cs8900_recv;
57e1cd18:	e59f3038 	ldr	r3, [pc, #56]	; 57e1cd58 <cs8900_initialize+0xb4>
	}
	memset(priv, 0, sizeof(*priv));
	priv->regs = (struct cs8900_regs *)base_addr;

	dev->iobase = base_addr;
	dev->priv = priv;
57e1cd1c:	e584503c 	str	r5, [r4, #60]	; 0x3c
	dev->init = cs8900_init;
	dev->halt = cs8900_halt;
	dev->send = cs8900_send;
	dev->recv = cs8900_recv;
57e1cd20:	e5843028 	str	r3, [r4, #40]	; 0x28

	/* Load MAC address from EEPROM */
	cs8900_get_enetaddr(dev);
57e1cd24:	ebffff87 	bl	57e1cb48 <cs8900_get_enetaddr>

	sprintf(dev->name, "%s-%hu", CS8900_DRIVERNAME, dev_num);
57e1cd28:	e1a00004 	mov	r0, r4
57e1cd2c:	e59f1028 	ldr	r1, [pc, #40]	; 57e1cd5c <cs8900_initialize+0xb8>
57e1cd30:	e59f2028 	ldr	r2, [pc, #40]	; 57e1cd60 <cs8900_initialize+0xbc>
57e1cd34:	e1a03007 	mov	r3, r7
57e1cd38:	eb002182 	bl	57e25348 <sprintf>

	eth_register(dev);
57e1cd3c:	e1a00004 	mov	r0, r4
57e1cd40:	eb002eea 	bl	57e288f0 <eth_register>
	return 0;
}
57e1cd44:	e3a00000 	mov	r0, #0
57e1cd48:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e1cd4c:	57e1ca88 	.word	0x57e1ca88
57e1cd50:	57e1c8a8 	.word	0x57e1c8a8
57e1cd54:	57e1c9ac 	.word	0x57e1c9ac
57e1cd58:	57e1c804 	.word	0x57e1c804
57e1cd5c:	57e345d9 	.word	0x57e345d9
57e1cd60:	57e345e0 	.word	0x57e345e0

57e1cd64 <s3c64xx_serial_getc>:
static int s3c64xx_serial_getc(void)
{
	s3c64xx_uart *const uart = s3c64xx_get_base_uart(UART_NR);

	/* wait for character to arrive */
	while (!(uart->UTRSTAT & 0x1));
57e1cd64:	e59f3014 	ldr	r3, [pc, #20]	; 57e1cd80 <s3c64xx_serial_getc+0x1c>
57e1cd68:	e5932010 	ldr	r2, [r3, #16]
57e1cd6c:	e3120001 	tst	r2, #1
57e1cd70:	0afffffc 	beq	57e1cd68 <s3c64xx_serial_getc+0x4>

	return uart->URXH & 0xff;
57e1cd74:	e59f3004 	ldr	r3, [pc, #4]	; 57e1cd80 <s3c64xx_serial_getc+0x1c>
57e1cd78:	e5d30024 	ldrb	r0, [r3, #36]	; 0x24
}
57e1cd7c:	e12fff1e 	bx	lr
57e1cd80:	7f005000 	.word	0x7f005000

57e1cd84 <s3c64xx_serial_tstc>:
 */
static int s3c64xx_serial_tstc(void)
{
	s3c64xx_uart *const uart = s3c64xx_get_base_uart(UART_NR);

	return uart->UTRSTAT & 0x1;
57e1cd84:	e59f3008 	ldr	r3, [pc, #8]	; 57e1cd94 <s3c64xx_serial_tstc+0x10>
57e1cd88:	e5930010 	ldr	r0, [r3, #16]
}
57e1cd8c:	e2000001 	and	r0, r0, #1
57e1cd90:	e12fff1e 	bx	lr
57e1cd94:	7f005000 	.word	0x7f005000

57e1cd98 <s3c64xx_serial_putc>:
	if (be_quiet)
		return;
#endif

	/* wait for room in the tx FIFO */
	while (!(uart->UTRSTAT & 0x2));
57e1cd98:	e59f3020 	ldr	r3, [pc, #32]	; 57e1cdc0 <s3c64xx_serial_putc+0x28>
57e1cd9c:	e5932010 	ldr	r2, [r3, #16]
57e1cda0:	e3120002 	tst	r2, #2
57e1cda4:	0afffffc 	beq	57e1cd9c <s3c64xx_serial_putc+0x4>

	uart->UTXH = c;
57e1cda8:	e59f3010 	ldr	r3, [pc, #16]	; 57e1cdc0 <s3c64xx_serial_putc+0x28>

	/* If \n, also do \r */
	if (c == '\n')
57e1cdac:	e350000a 	cmp	r0, #10
#endif

	/* wait for room in the tx FIFO */
	while (!(uart->UTRSTAT & 0x2));

	uart->UTXH = c;
57e1cdb0:	e5c30020 	strb	r0, [r3, #32]

	/* If \n, also do \r */
	if (c == '\n')
57e1cdb4:	112fff1e 	bxne	lr
		serial_putc('\r');
57e1cdb8:	e2800003 	add	r0, r0, #3
57e1cdbc:	ea00010c 	b	57e1d1f4 <serial_putc>
57e1cdc0:	7f005000 	.word	0x7f005000

57e1cdc4 <s3c64xx_serial_setbrg>:
	0xdfdf,
	0xffdf,
};

static void s3c64xx_serial_setbrg(void)
{
57e1cdc4:	e92d4008 	push	{r3, lr}
	s3c64xx_uart *const uart = s3c64xx_get_base_uart(UART_NR);
	u32 pclk = get_PCLK();
57e1cdc8:	ebff8eb3 	bl	57e0089c <get_PCLK>
	u32 baudrate = gd->baudrate;
57e1cdcc:	e5981008 	ldr	r1, [r8, #8]
	int i;

	i = (pclk / baudrate) % 16;
57e1cdd0:	eb003a76 	bl	57e2b7b0 <__udivsi3>

	uart->UBRDIV = pclk / baudrate / 16 - 1;
57e1cdd4:	e59f302c 	ldr	r3, [pc, #44]	; 57e1ce08 <s3c64xx_serial_setbrg+0x44>
57e1cdd8:	e1a02220 	lsr	r2, r0, #4
57e1cddc:	e2422001 	sub	r2, r2, #1
57e1cde0:	e5832028 	str	r2, [r3, #40]	; 0x28
	s3c64xx_uart *const uart = s3c64xx_get_base_uart(UART_NR);
	u32 pclk = get_PCLK();
	u32 baudrate = gd->baudrate;
	int i;

	i = (pclk / baudrate) % 16;
57e1cde4:	e200000f 	and	r0, r0, #15

	uart->UBRDIV = pclk / baudrate / 16 - 1;
	uart->UDIVSLOT = udivslot[i];
57e1cde8:	e59f201c 	ldr	r2, [pc, #28]	; 57e1ce0c <s3c64xx_serial_setbrg+0x48>
57e1cdec:	e1a00100 	lsl	r0, r0, #2
57e1cdf0:	e19020b2 	ldrh	r2, [r0, r2]
57e1cdf4:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
57e1cdf8:	e3a03064 	mov	r3, #100	; 0x64

	for (i = 0; i < 100; i++)
57e1cdfc:	e2533001 	subs	r3, r3, #1
57e1ce00:	1afffffd 	bne	57e1cdfc <s3c64xx_serial_setbrg+0x38>
		barrier();
}
57e1ce04:	e8bd8008 	pop	{r3, pc}
57e1ce08:	7f005000 	.word	0x7f005000
57e1ce0c:	57e2ccd8 	.word	0x57e2ccd8

57e1ce10 <s3c64xx_serial_init>:
static int s3c64xx_serial_init(void)
{
	s3c64xx_uart *const uart = s3c64xx_get_base_uart(UART_NR);

	/* reset and enable FIFOs, set triggers to the maximum */
	uart->UFCON = 0xff;
57e1ce10:	e59f302c 	ldr	r3, [pc, #44]	; 57e1ce44 <s3c64xx_serial_init+0x34>
57e1ce14:	e3a020ff 	mov	r2, #255	; 0xff
/*
 * Initialise the serial port with the given baudrate. The settings
 * are always 8 data bits, no parity, 1 stop bit, no start bits.
 */
static int s3c64xx_serial_init(void)
{
57e1ce18:	e92d4010 	push	{r4, lr}
	s3c64xx_uart *const uart = s3c64xx_get_base_uart(UART_NR);

	/* reset and enable FIFOs, set triggers to the maximum */
	uart->UFCON = 0xff;
57e1ce1c:	e5832008 	str	r2, [r3, #8]
	uart->UMCON = 0;
57e1ce20:	e3a04000 	mov	r4, #0
	/* 8N1 */
	uart->ULCON = 3;
57e1ce24:	e3a02003 	mov	r2, #3
{
	s3c64xx_uart *const uart = s3c64xx_get_base_uart(UART_NR);

	/* reset and enable FIFOs, set triggers to the maximum */
	uart->UFCON = 0xff;
	uart->UMCON = 0;
57e1ce28:	e583400c 	str	r4, [r3, #12]
	/* 8N1 */
	uart->ULCON = 3;
57e1ce2c:	e5832000 	str	r2, [r3]
	/* No interrupts, no DMA, pure polling */
	uart->UCON = 5;
57e1ce30:	e2822002 	add	r2, r2, #2
57e1ce34:	e5832004 	str	r2, [r3, #4]

	serial_setbrg();
57e1ce38:	eb00009b 	bl	57e1d0ac <serial_setbrg>

	return 0;
}
57e1ce3c:	e1a00004 	mov	r0, r4
57e1ce40:	e8bd8010 	pop	{r4, pc}
57e1ce44:	7f005000 	.word	0x7f005000

57e1ce48 <s3c64xx_serial_initialize>:
	.tstc	= s3c64xx_serial_tstc,
};

void s3c64xx_serial_initialize(void)
{
	serial_register(&s3c64xx_serial_drv);
57e1ce48:	e59f0000 	ldr	r0, [pc, #0]	; 57e1ce50 <s3c64xx_serial_initialize+0x8>
57e1ce4c:	ea000013 	b	57e1cea0 <serial_register>
57e1ce50:	57e37930 	.word	0x57e37930

57e1ce54 <default_serial_console>:
}

__weak struct serial_device *default_serial_console(void)
{
	return &s3c64xx_serial_drv;
}
57e1ce54:	e59f0000 	ldr	r0, [pc, #0]	; 57e1ce5c <default_serial_console+0x8>
57e1ce58:	e12fff1e 	bx	lr
57e1ce5c:	57e37930 	.word	0x57e37930

57e1ce60 <get_current>:
 *
 * Returns pointer to the currently selected serial port on success,
 * NULL on error.
 */
static struct serial_device *get_current(void)
{
57e1ce60:	e92d4008 	push	{r3, lr}
	struct serial_device *dev;

	if (!(gd->flags & GD_FLG_RELOC))
57e1ce64:	e5983004 	ldr	r3, [r8, #4]
57e1ce68:	e3130001 	tst	r3, #1
57e1ce6c:	0a000003 	beq	57e1ce80 <get_current+0x20>
		dev = default_serial_console();
	else if (!serial_current)
57e1ce70:	e59f301c 	ldr	r3, [pc, #28]	; 57e1ce94 <get_current+0x34>
57e1ce74:	e5930000 	ldr	r0, [r3]
57e1ce78:	e3500000 	cmp	r0, #0
57e1ce7c:	18bd8008 	popne	{r3, pc}
		dev = default_serial_console();
57e1ce80:	ebfffff3 	bl	57e1ce54 <default_serial_console>
	else
		dev = serial_current;

	/* We must have a console device */
	if (!dev) {
57e1ce84:	e3500000 	cmp	r0, #0
57e1ce88:	18bd8008 	popne	{r3, pc}
#ifdef CONFIG_SPL_BUILD
		puts("Cannot find console\n");
		hang();
#else
		panic("Cannot find console\n");
57e1ce8c:	e59f0004 	ldr	r0, [pc, #4]	; 57e1ce98 <get_current+0x38>
57e1ce90:	eb002135 	bl	57e2536c <panic>
57e1ce94:	57e47974 	.word	0x57e47974
57e1ce98:	57e345e7 	.word	0x57e345e7

57e1ce9c <altera_jtag_serial_initialize>:
 * to this empty function in case the driver is not compiled into
 * U-Boot.
 */
static void serial_null(void)
{
}
57e1ce9c:	e12fff1e 	bx	lr

57e1cea0 <serial_register>:
		dev->putc += gd->reloc_off;
	if (dev->puts)
		dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
57e1cea0:	e59f300c 	ldr	r3, [pc, #12]	; 57e1ceb4 <serial_register+0x14>
57e1cea4:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
57e1cea8:	e5830004 	str	r0, [r3, #4]
		dev->putc += gd->reloc_off;
	if (dev->puts)
		dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
57e1ceac:	e580202c 	str	r2, [r0, #44]	; 0x2c
	serial_devices = dev;
}
57e1ceb0:	e12fff1e 	bx	lr
57e1ceb4:	57e47974 	.word	0x57e47974

57e1ceb8 <serial_stdio_init>:
 * This function generates a proxy driver for each serial port driver.
 * These proxy drivers then register with the STDIO core, making the
 * serial drivers available as STDIO devices.
 */
void serial_stdio_init(void)
{
57e1ceb8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
57e1cebc:	e59f3080 	ldr	r3, [pc, #128]	; 57e1cf44 <serial_stdio_init+0x8c>
 * This function generates a proxy driver for each serial port driver.
 * These proxy drivers then register with the STDIO core, making the
 * serial drivers available as STDIO devices.
 */
void serial_stdio_init(void)
{
57e1cec0:	e24dd044 	sub	sp, sp, #68	; 0x44
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
		memset(&dev, 0, sizeof(dev));
57e1cec4:	e28d5004 	add	r5, sp, #4
 * serial drivers available as STDIO devices.
 */
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
57e1cec8:	e5934004 	ldr	r4, [r3, #4]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
57e1cecc:	e2857008 	add	r7, r5, #8
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
57e1ced0:	e3a06003 	mov	r6, #3
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
57e1ced4:	ea000016 	b	57e1cf34 <serial_stdio_init+0x7c>
		memset(&dev, 0, sizeof(dev));
57e1ced8:	e3a0203c 	mov	r2, #60	; 0x3c
57e1cedc:	e3a01000 	mov	r1, #0
57e1cee0:	e1a00005 	mov	r0, r5
57e1cee4:	eb001ce4 	bl	57e2427c <memset>

		strcpy(dev.name, s->name);
57e1cee8:	e1a01004 	mov	r1, r4
57e1ceec:	e1a00007 	mov	r0, r7
57e1cef0:	eb001bfa 	bl	57e23ee0 <strcpy>
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->start;
57e1cef4:	e5943010 	ldr	r3, [r4, #16]
		dev.putc = s->putc;
		dev.puts = s->puts;
		dev.getc = s->getc;
		dev.tstc = s->tstc;

		stdio_register(&dev);
57e1cef8:	e1a00005 	mov	r0, r5
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->start;
57e1cefc:	e58d301c 	str	r3, [sp, #28]
		dev.stop = s->stop;
57e1cf00:	e5943014 	ldr	r3, [r4, #20]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
57e1cf04:	e58d6004 	str	r6, [sp, #4]

		dev.start = s->start;
		dev.stop = s->stop;
57e1cf08:	e58d3020 	str	r3, [sp, #32]
		dev.putc = s->putc;
57e1cf0c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
57e1cf10:	e58d3024 	str	r3, [sp, #36]	; 0x24
		dev.puts = s->puts;
57e1cf14:	e5943028 	ldr	r3, [r4, #40]	; 0x28
57e1cf18:	e58d3028 	str	r3, [sp, #40]	; 0x28
		dev.getc = s->getc;
57e1cf1c:	e594301c 	ldr	r3, [r4, #28]
57e1cf20:	e58d3030 	str	r3, [sp, #48]	; 0x30
		dev.tstc = s->tstc;
57e1cf24:	e5943020 	ldr	r3, [r4, #32]
57e1cf28:	e58d302c 	str	r3, [sp, #44]	; 0x2c

		stdio_register(&dev);
57e1cf2c:	ebffca9c 	bl	57e0f9a4 <stdio_register>

		s = s->next;
57e1cf30:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
57e1cf34:	e3540000 	cmp	r4, #0
57e1cf38:	1affffe6 	bne	57e1ced8 <serial_stdio_init+0x20>

		stdio_register(&dev);

		s = s->next;
	}
}
57e1cf3c:	e28dd044 	add	sp, sp, #68	; 0x44
57e1cf40:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
57e1cf44:	57e47974 	.word	0x57e47974

57e1cf48 <serial_assign>:
 * used for the particular operation.
 *
 * Returns 0 on success, negative on error.
 */
int serial_assign(const char *name)
{
57e1cf48:	e92d4038 	push	{r3, r4, r5, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
57e1cf4c:	e59f303c 	ldr	r3, [pc, #60]	; 57e1cf90 <serial_assign+0x48>
 * used for the particular operation.
 *
 * Returns 0 on success, negative on error.
 */
int serial_assign(const char *name)
{
57e1cf50:	e1a05000 	mov	r5, r0
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
57e1cf54:	e5934004 	ldr	r4, [r3, #4]
57e1cf58:	ea000008 	b	57e1cf80 <serial_assign+0x38>
		if (strcmp(s->name, name))
57e1cf5c:	e1a00004 	mov	r0, r4
57e1cf60:	e1a01005 	mov	r1, r5
57e1cf64:	eb001c0e 	bl	57e23fa4 <strcmp>
57e1cf68:	e3500000 	cmp	r0, #0
 */
int serial_assign(const char *name)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
57e1cf6c:	1594402c 	ldrne	r4, [r4, #44]	; 0x2c
57e1cf70:	1a000002 	bne	57e1cf80 <serial_assign+0x38>
		if (strcmp(s->name, name))
			continue;
		serial_current = s;
57e1cf74:	e59f3014 	ldr	r3, [pc, #20]	; 57e1cf90 <serial_assign+0x48>
57e1cf78:	e5834000 	str	r4, [r3]
		return 0;
57e1cf7c:	e8bd8038 	pop	{r3, r4, r5, pc}
 */
int serial_assign(const char *name)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
57e1cf80:	e3540000 	cmp	r4, #0
57e1cf84:	1afffff4 	bne	57e1cf5c <serial_assign+0x14>
			continue;
		serial_current = s;
		return 0;
	}

	return -EINVAL;
57e1cf88:	e3e00015 	mvn	r0, #21
}
57e1cf8c:	e8bd8038 	pop	{r3, r4, r5, pc}
57e1cf90:	57e47974 	.word	0x57e47974

57e1cf94 <serial_initialize>:
 * available to U-Boot to use. Lastly, this function assigns a default
 * serial port to the serial core. That serial port is then used as a
 * default output.
 */
void serial_initialize(void)
{
57e1cf94:	e92d4010 	push	{r4, lr}
	mpc8xx_serial_initialize();
57e1cf98:	ebffffbf 	bl	57e1ce9c <altera_jtag_serial_initialize>
	ns16550_serial_initialize();
57e1cf9c:	ebffffbe 	bl	57e1ce9c <altera_jtag_serial_initialize>
	pxa_serial_initialize();
57e1cfa0:	ebffffbd 	bl	57e1ce9c <altera_jtag_serial_initialize>
	s3c24xx_serial_initialize();
57e1cfa4:	ebffffbc 	bl	57e1ce9c <altera_jtag_serial_initialize>
	s5p_serial_initialize();
57e1cfa8:	ebffffbb 	bl	57e1ce9c <altera_jtag_serial_initialize>
	mpc512x_serial_initialize();
57e1cfac:	ebffffba 	bl	57e1ce9c <altera_jtag_serial_initialize>
	bfin_serial_initialize();
57e1cfb0:	ebffffb9 	bl	57e1ce9c <altera_jtag_serial_initialize>
	bfin_jtag_initialize();
57e1cfb4:	ebffffb8 	bl	57e1ce9c <altera_jtag_serial_initialize>
	uartlite_serial_initialize();
57e1cfb8:	ebffffb7 	bl	57e1ce9c <altera_jtag_serial_initialize>
	zynq_serial_initalize();
57e1cfbc:	ebffffb6 	bl	57e1ce9c <altera_jtag_serial_initialize>
	au1x00_serial_initialize();
57e1cfc0:	ebffffb5 	bl	57e1ce9c <altera_jtag_serial_initialize>
	asc_serial_initialize();
57e1cfc4:	ebffffb4 	bl	57e1ce9c <altera_jtag_serial_initialize>
	jz_serial_initialize();
57e1cfc8:	ebffffb3 	bl	57e1ce9c <altera_jtag_serial_initialize>
	mpc5xx_serial_initialize();
57e1cfcc:	ebffffb2 	bl	57e1ce9c <altera_jtag_serial_initialize>
	mpc8220_serial_initialize();
57e1cfd0:	ebffffb1 	bl	57e1ce9c <altera_jtag_serial_initialize>
	mpc8260_scc_serial_initialize();
57e1cfd4:	ebffffb0 	bl	57e1ce9c <altera_jtag_serial_initialize>
	mpc8260_smc_serial_initialize();
57e1cfd8:	ebffffaf 	bl	57e1ce9c <altera_jtag_serial_initialize>
	mpc85xx_serial_initialize();
57e1cfdc:	ebffffae 	bl	57e1ce9c <altera_jtag_serial_initialize>
	iop480_serial_initialize();
57e1cfe0:	ebffffad 	bl	57e1ce9c <altera_jtag_serial_initialize>
	leon2_serial_initialize();
57e1cfe4:	ebffffac 	bl	57e1ce9c <altera_jtag_serial_initialize>
	leon3_serial_initialize();
57e1cfe8:	ebffffab 	bl	57e1ce9c <altera_jtag_serial_initialize>
	marvell_serial_initialize();
57e1cfec:	ebffffaa 	bl	57e1ce9c <altera_jtag_serial_initialize>
	amirix_serial_initialize();
57e1cff0:	ebffffa9 	bl	57e1ce9c <altera_jtag_serial_initialize>
	bmw_serial_initialize();
57e1cff4:	ebffffa8 	bl	57e1ce9c <altera_jtag_serial_initialize>
	cogent_serial_initialize();
57e1cff8:	ebffffa7 	bl	57e1ce9c <altera_jtag_serial_initialize>
	cpci750_serial_initialize();
57e1cffc:	ebffffa6 	bl	57e1ce9c <altera_jtag_serial_initialize>
	evb64260_serial_initialize();
57e1d000:	ebffffa5 	bl	57e1ce9c <altera_jtag_serial_initialize>
	ml2_serial_initialize();
57e1d004:	ebffffa4 	bl	57e1ce9c <altera_jtag_serial_initialize>
	sconsole_serial_initialize();
57e1d008:	ebffffa3 	bl	57e1ce9c <altera_jtag_serial_initialize>
	p3mx_serial_initialize();
57e1d00c:	ebffffa2 	bl	57e1ce9c <altera_jtag_serial_initialize>
	altera_jtag_serial_initialize();
57e1d010:	ebffffa1 	bl	57e1ce9c <altera_jtag_serial_initialize>
	altera_serial_initialize();
57e1d014:	ebffffa0 	bl	57e1ce9c <altera_jtag_serial_initialize>
	atmel_serial_initialize();
57e1d018:	ebffff9f 	bl	57e1ce9c <altera_jtag_serial_initialize>
	lpc32xx_serial_initialize();
57e1d01c:	ebffff9e 	bl	57e1ce9c <altera_jtag_serial_initialize>
	mcf_serial_initialize();
57e1d020:	ebffff9d 	bl	57e1ce9c <altera_jtag_serial_initialize>
	ns9750_serial_initialize();
57e1d024:	ebffff9c 	bl	57e1ce9c <altera_jtag_serial_initialize>
	oc_serial_initialize();
57e1d028:	ebffff9b 	bl	57e1ce9c <altera_jtag_serial_initialize>
	s3c64xx_serial_initialize();
57e1d02c:	ebffff85 	bl	57e1ce48 <s3c64xx_serial_initialize>
	sandbox_serial_initialize();
57e1d030:	ebffff99 	bl	57e1ce9c <altera_jtag_serial_initialize>
	clps7111_serial_initialize();
57e1d034:	ebffff98 	bl	57e1ce9c <altera_jtag_serial_initialize>
	imx_serial_initialize();
57e1d038:	ebffff97 	bl	57e1ce9c <altera_jtag_serial_initialize>
	ixp_serial_initialize();
57e1d03c:	ebffff96 	bl	57e1ce9c <altera_jtag_serial_initialize>
	ks8695_serial_initialize();
57e1d040:	ebffff95 	bl	57e1ce9c <altera_jtag_serial_initialize>
	lh7a40x_serial_initialize();
57e1d044:	ebffff94 	bl	57e1ce9c <altera_jtag_serial_initialize>
	max3100_serial_initialize();
57e1d048:	ebffff93 	bl	57e1ce9c <altera_jtag_serial_initialize>
	mxc_serial_initialize();
57e1d04c:	ebffff92 	bl	57e1ce9c <altera_jtag_serial_initialize>
	pl01x_serial_initialize();
57e1d050:	ebffff91 	bl	57e1ce9c <altera_jtag_serial_initialize>
	s3c44b0_serial_initialize();
57e1d054:	ebffff90 	bl	57e1ce9c <altera_jtag_serial_initialize>
	sa1100_serial_initialize();
57e1d058:	ebffff8f 	bl	57e1ce9c <altera_jtag_serial_initialize>
	sh_serial_initialize();
57e1d05c:	ebffff8e 	bl	57e1ce9c <altera_jtag_serial_initialize>

	serial_assign(default_serial_console()->name);
57e1d060:	ebffff7b 	bl	57e1ce54 <default_serial_console>
}
57e1d064:	e8bd4010 	pop	{r4, lr}
	pl01x_serial_initialize();
	s3c44b0_serial_initialize();
	sa1100_serial_initialize();
	sh_serial_initialize();

	serial_assign(default_serial_console()->name);
57e1d068:	eaffffb6 	b	57e1cf48 <serial_assign>

57e1d06c <serial_reinit_all>:
 */
void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
57e1d06c:	e59f3020 	ldr	r3, [pc, #32]	; 57e1d094 <serial_reinit_all+0x28>
 *
 * This function reinitializes all serial ports that are compiled
 * into U-Boot by calling their serial_start() functions.
 */
void serial_reinit_all(void)
{
57e1d070:	e92d4010 	push	{r4, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
57e1d074:	e5934004 	ldr	r4, [r3, #4]
57e1d078:	ea000002 	b	57e1d088 <serial_reinit_all+0x1c>
		s->start();
57e1d07c:	e5943010 	ldr	r3, [r4, #16]
57e1d080:	e12fff33 	blx	r3
 */
void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
57e1d084:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
57e1d088:	e3540000 	cmp	r4, #0
57e1d08c:	1afffffa 	bne	57e1d07c <serial_reinit_all+0x10>
		s->start();
}
57e1d090:	e8bd8010 	pop	{r4, pc}
57e1d094:	57e47974 	.word	0x57e47974

57e1d098 <serial_init>:
 * to determine which port is selected.
 *
 * Returns 0 on success, negative on error.
 */
int serial_init(void)
{
57e1d098:	e92d4008 	push	{r3, lr}
	return get_current()->start();
57e1d09c:	ebffff6f 	bl	57e1ce60 <get_current>
57e1d0a0:	e5903010 	ldr	r3, [r0, #16]
57e1d0a4:	e12fff33 	blx	r3
}
57e1d0a8:	e8bd8008 	pop	{r3, pc}

57e1d0ac <serial_setbrg>:
 * to determine which port is selected.
 *
 * Returns 0 on success, negative on error.
 */
void serial_setbrg(void)
{
57e1d0ac:	e92d4008 	push	{r3, lr}
	get_current()->setbrg();
57e1d0b0:	ebffff6a 	bl	57e1ce60 <get_current>
57e1d0b4:	e5903018 	ldr	r3, [r0, #24]
57e1d0b8:	e12fff33 	blx	r3
}
57e1d0bc:	e8bd8008 	pop	{r3, pc}

57e1d0c0 <on_baudrate>:
	int flags)
{
	int i;
	int baudrate;

	switch (op) {
57e1d0c0:	e3520001 	cmp	r2, #1
 *
 * This will check for a valid baudrate and only apply it if valid.
 */
static int on_baudrate(const char *name, const char *value, enum env_op op,
	int flags)
{
57e1d0c4:	e92d4038 	push	{r3, r4, r5, lr}
57e1d0c8:	e1a05002 	mov	r5, r2
57e1d0cc:	e1a04003 	mov	r4, r3
	int i;
	int baudrate;

	switch (op) {
57e1d0d0:	0a00002c 	beq	57e1d188 <on_baudrate+0xc8>
57e1d0d4:	3a000001 	bcc	57e1d0e0 <on_baudrate+0x20>
57e1d0d8:	e3520002 	cmp	r2, #2
57e1d0dc:	1a00002d 	bne	57e1d198 <on_baudrate+0xd8>
	case env_op_create:
	case env_op_overwrite:
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		baudrate = simple_strtoul(value, NULL, 10);
57e1d0e0:	e1a00001 	mov	r0, r1
57e1d0e4:	e3a0200a 	mov	r2, #10
57e1d0e8:	e3a01000 	mov	r1, #0
57e1d0ec:	eb001fec 	bl	57e250a4 <simple_strtoul>

		/* Not actually changing */
		if (gd->baudrate == baudrate)
57e1d0f0:	e5983008 	ldr	r3, [r8, #8]
	case env_op_create:
	case env_op_overwrite:
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		baudrate = simple_strtoul(value, NULL, 10);
57e1d0f4:	e1a05000 	mov	r5, r0

		/* Not actually changing */
		if (gd->baudrate == baudrate)
57e1d0f8:	e1530000 	cmp	r3, r0
57e1d0fc:	0a000025 	beq	57e1d198 <on_baudrate+0xd8>
			return 0;

		for (i = 0; i < N_BAUDRATES; ++i) {
			if (baudrate == baudrate_table[i])
57e1d100:	e3500d96 	cmp	r0, #9600	; 0x2580
57e1d104:	0a000008 	beq	57e1d12c <on_baudrate+0x6c>
57e1d108:	e3500c4b 	cmp	r0, #19200	; 0x4b00
57e1d10c:	0a000006 	beq	57e1d12c <on_baudrate+0x6c>
57e1d110:	e3500c96 	cmp	r0, #38400	; 0x9600
57e1d114:	0a000004 	beq	57e1d12c <on_baudrate+0x6c>
57e1d118:	e3500ce1 	cmp	r0, #57600	; 0xe100
57e1d11c:	0a000002 	beq	57e1d12c <on_baudrate+0x6c>
57e1d120:	e59f3090 	ldr	r3, [pc, #144]	; 57e1d1b8 <on_baudrate+0xf8>
57e1d124:	e1500003 	cmp	r0, r3
57e1d128:	1a00001e 	bne	57e1d1a8 <on_baudrate+0xe8>
			if ((flags & H_FORCE) == 0)
				printf("## Baudrate %d bps not supported\n",
					baudrate);
			return 1;
		}
		if ((flags & H_INTERACTIVE) != 0) {
57e1d12c:	e2144004 	ands	r4, r4, #4
57e1d130:	0a000009 	beq	57e1d15c <on_baudrate+0x9c>
57e1d134:	ea000003 	b	57e1d148 <on_baudrate+0x88>
			if (baudrate == baudrate_table[i])
				break;
		}
		if (i == N_BAUDRATES) {
			if ((flags & H_FORCE) == 0)
				printf("## Baudrate %d bps not supported\n",
57e1d138:	e1a01005 	mov	r1, r5
57e1d13c:	e59f0078 	ldr	r0, [pc, #120]	; 57e1d1bc <on_baudrate+0xfc>
57e1d140:	ebffb0c1 	bl	57e0944c <printf>
57e1d144:	ea000019 	b	57e1d1b0 <on_baudrate+0xf0>
					baudrate);
			return 1;
		}
		if ((flags & H_INTERACTIVE) != 0) {
			printf("## Switch baudrate to %d"
57e1d148:	e59f0070 	ldr	r0, [pc, #112]	; 57e1d1c0 <on_baudrate+0x100>
57e1d14c:	e1a01005 	mov	r1, r5
57e1d150:	ebffb0bd 	bl	57e0944c <printf>
				" bps and press ENTER ...\n", baudrate);
			udelay(50000);
57e1d154:	e59f0068 	ldr	r0, [pc, #104]	; 57e1d1c4 <on_baudrate+0x104>
57e1d158:	eb001cf6 	bl	57e24538 <udelay>
		}

		gd->baudrate = baudrate;
57e1d15c:	e5885008 	str	r5, [r8, #8]
#if defined(CONFIG_PPC) || defined(CONFIG_MCF52x2)
		gd->bd->bi_baudrate = baudrate;
#endif

		serial_setbrg();
57e1d160:	ebffffd1 	bl	57e1d0ac <serial_setbrg>

		udelay(50000);
57e1d164:	e59f0058 	ldr	r0, [pc, #88]	; 57e1d1c4 <on_baudrate+0x104>
57e1d168:	eb001cf2 	bl	57e24538 <udelay>

		if ((flags & H_INTERACTIVE) != 0)
57e1d16c:	e3540000 	cmp	r4, #0
			while (1) {
				if (getc() == '\r')
					break;
			}

		return 0;
57e1d170:	01a00004 	moveq	r0, r4

		serial_setbrg();

		udelay(50000);

		if ((flags & H_INTERACTIVE) != 0)
57e1d174:	08bd8038 	popeq	{r3, r4, r5, pc}
			while (1) {
				if (getc() == '\r')
57e1d178:	ebffb08d 	bl	57e093b4 <getc>
57e1d17c:	e350000d 	cmp	r0, #13
57e1d180:	1afffffc 	bne	57e1d178 <on_baudrate+0xb8>
57e1d184:	ea000005 	b	57e1d1a0 <on_baudrate+0xe0>
					break;
			}

		return 0;
	case env_op_delete:
		printf("## Baudrate may not be deleted\n");
57e1d188:	e59f0038 	ldr	r0, [pc, #56]	; 57e1d1c8 <on_baudrate+0x108>
57e1d18c:	ebffb0ae 	bl	57e0944c <printf>
		return 1;
57e1d190:	e1a00005 	mov	r0, r5
57e1d194:	e8bd8038 	pop	{r3, r4, r5, pc}
		 */
		baudrate = simple_strtoul(value, NULL, 10);

		/* Not actually changing */
		if (gd->baudrate == baudrate)
			return 0;
57e1d198:	e3a00000 	mov	r0, #0
57e1d19c:	e8bd8038 	pop	{r3, r4, r5, pc}
			while (1) {
				if (getc() == '\r')
					break;
			}

		return 0;
57e1d1a0:	e3a00000 	mov	r0, #0
		printf("## Baudrate may not be deleted\n");
		return 1;
	default:
		return 0;
	}
}
57e1d1a4:	e8bd8038 	pop	{r3, r4, r5, pc}
		for (i = 0; i < N_BAUDRATES; ++i) {
			if (baudrate == baudrate_table[i])
				break;
		}
		if (i == N_BAUDRATES) {
			if ((flags & H_FORCE) == 0)
57e1d1a8:	e3140002 	tst	r4, #2
57e1d1ac:	0affffe1 	beq	57e1d138 <on_baudrate+0x78>
				printf("## Baudrate %d bps not supported\n",
					baudrate);
			return 1;
57e1d1b0:	e3a00001 	mov	r0, #1
57e1d1b4:	e8bd8038 	pop	{r3, r4, r5, pc}
57e1d1b8:	0001c200 	.word	0x0001c200
57e1d1bc:	57e345fc 	.word	0x57e345fc
57e1d1c0:	57e30038 	.word	0x57e30038
57e1d1c4:	0000c350 	.word	0x0000c350
57e1d1c8:	57e3461e 	.word	0x57e3461e

57e1d1cc <serial_getc>:
 * selected.
 *
 * Returns the character on success, negative on error.
 */
int serial_getc(void)
{
57e1d1cc:	e92d4008 	push	{r3, lr}
	return get_current()->getc();
57e1d1d0:	ebffff22 	bl	57e1ce60 <get_current>
57e1d1d4:	e590301c 	ldr	r3, [r0, #28]
57e1d1d8:	e12fff33 	blx	r3
}
57e1d1dc:	e8bd8008 	pop	{r3, pc}

57e1d1e0 <serial_tstc>:
 * selected.
 *
 * Returns positive if character is available, zero otherwise.
 */
int serial_tstc(void)
{
57e1d1e0:	e92d4008 	push	{r3, lr}
	return get_current()->tstc();
57e1d1e4:	ebffff1d 	bl	57e1ce60 <get_current>
57e1d1e8:	e5903020 	ldr	r3, [r0, #32]
57e1d1ec:	e12fff33 	blx	r3
}
57e1d1f0:	e8bd8008 	pop	{r3, pc}

57e1d1f4 <serial_putc>:
 * of transmitting another character, therefore this function may block
 * for a short amount of time. This function uses the get_current()
 * call to determine which port is selected.
 */
void serial_putc(const char c)
{
57e1d1f4:	e92d4010 	push	{r4, lr}
57e1d1f8:	e1a04000 	mov	r4, r0
	get_current()->putc(c);
57e1d1fc:	ebffff17 	bl	57e1ce60 <get_current>
57e1d200:	e5903024 	ldr	r3, [r0, #36]	; 0x24
57e1d204:	e1a00004 	mov	r0, r4
57e1d208:	e12fff33 	blx	r3
}
57e1d20c:	e8bd8010 	pop	{r4, pc}

57e1d210 <serial_puts>:
 * string may take some time, thus this function may block for some
 * amount of time. This function uses the get_current() call to
 * determine which port is selected.
 */
void serial_puts(const char *s)
{
57e1d210:	e92d4010 	push	{r4, lr}
57e1d214:	e1a04000 	mov	r4, r0
	get_current()->puts(s);
57e1d218:	ebffff10 	bl	57e1ce60 <get_current>
57e1d21c:	e5903028 	ldr	r3, [r0, #40]	; 0x28
57e1d220:	e1a00004 	mov	r0, r4
57e1d224:	e12fff33 	blx	r3
}
57e1d228:	e8bd8010 	pop	{r4, pc}

57e1d22c <default_serial_puts>:
 * To optimize the number of get_current() calls, this function only
 * calls get_current() once and then directly accesses the putc() call
 * of the &struct serial_device .
 */
void default_serial_puts(const char *s)
{
57e1d22c:	e92d4038 	push	{r3, r4, r5, lr}
57e1d230:	e1a04000 	mov	r4, r0
	struct serial_device *dev = get_current();
57e1d234:	ebffff09 	bl	57e1ce60 <get_current>
57e1d238:	e1a05000 	mov	r5, r0
	while (*s)
57e1d23c:	ea000001 	b	57e1d248 <default_serial_puts+0x1c>
		dev->putc(*s++);
57e1d240:	e5953024 	ldr	r3, [r5, #36]	; 0x24
57e1d244:	e12fff33 	blx	r3
 * of the &struct serial_device .
 */
void default_serial_puts(const char *s)
{
	struct serial_device *dev = get_current();
	while (*s)
57e1d248:	e4d40001 	ldrb	r0, [r4], #1
57e1d24c:	e3500000 	cmp	r0, #0
57e1d250:	1afffffa 	bne	57e1d240 <default_serial_puts+0x14>
		dev->putc(*s++);
}
57e1d254:	e8bd8038 	pop	{r3, r4, r5, pc}

57e1d258 <ep_rev>:

/* the int tree is a binary tree
 * in order to process it sequentially the indexes of the branches have to
 * be mapped the mapping reverses the bits of a word of num_bits length */
static int ep_rev(int num_bits, int word)
{
57e1d258:	e1a03000 	mov	r3, r0
	int i, wout = 0;

	for (i = 0; i < num_bits; i++)
57e1d25c:	e1a0c000 	mov	ip, r0
/* the int tree is a binary tree
 * in order to process it sequentially the indexes of the branches have to
 * be mapped the mapping reverses the bits of a word of num_bits length */
static int ep_rev(int num_bits, int word)
{
	int i, wout = 0;
57e1d260:	e3a00000 	mov	r0, #0

/* the int tree is a binary tree
 * in order to process it sequentially the indexes of the branches have to
 * be mapped the mapping reverses the bits of a word of num_bits length */
static int ep_rev(int num_bits, int word)
{
57e1d264:	e92d4010 	push	{r4, lr}
	int i, wout = 0;

	for (i = 0; i < num_bits; i++)
57e1d268:	e1a02000 	mov	r2, r0
57e1d26c:	ea000003 	b	57e1d280 <ep_rev+0x28>
		wout |= (((word >> i) & 1) << (num_bits - i - 1));
57e1d270:	e1a04251 	asr	r4, r1, r2
57e1d274:	e2044001 	and	r4, r4, #1
57e1d278:	e1800c14 	orr	r0, r0, r4, lsl ip
 * be mapped the mapping reverses the bits of a word of num_bits length */
static int ep_rev(int num_bits, int word)
{
	int i, wout = 0;

	for (i = 0; i < num_bits; i++)
57e1d27c:	e2822001 	add	r2, r2, #1
57e1d280:	e1520003 	cmp	r2, r3
57e1d284:	e24cc001 	sub	ip, ip, #1
57e1d288:	bafffff8 	blt	57e1d270 <ep_rev+0x18>
		wout |= (((word >> i) & 1) << (num_bits - i - 1));
	return wout;
}
57e1d28c:	e8bd8010 	pop	{r4, pc}

57e1d290 <urb_free_priv>:
{
	int		i;
	int		last;
	struct td	*td;

	last = urb->length - 1;
57e1d290:	e1d0c0b4 	ldrh	ip, [r0, #4]
 *-------------------------------------------------------------------------*/

/* free HCD-private data associated with this URB */

static void urb_free_priv(urb_priv_t *urb)
{
57e1d294:	e92d4010 	push	{r4, lr}
	int		i;
	int		last;
	struct td	*td;

	last = urb->length - 1;
	if (last >= 0) {
57e1d298:	e25cc001 	subs	ip, ip, #1
57e1d29c:	3a000009 	bcc	57e1d2c8 <urb_free_priv+0x38>
 * URB support functions
 *-------------------------------------------------------------------------*/

/* free HCD-private data associated with this URB */

static void urb_free_priv(urb_priv_t *urb)
57e1d2a0:	e3a03000 	mov	r3, #0
57e1d2a4:	e2802028 	add	r2, r0, #40	; 0x28
	last = urb->length - 1;
	if (last >= 0) {
		for (i = 0; i <= last; i++) {
			td = urb->td[i];
			if (td) {
				td->usb_dev = NULL;
57e1d2a8:	e1a01003 	mov	r1, r3
	struct td	*td;

	last = urb->length - 1;
	if (last >= 0) {
		for (i = 0; i <= last; i++) {
			td = urb->td[i];
57e1d2ac:	e4924004 	ldr	r4, [r2], #4
	int		last;
	struct td	*td;

	last = urb->length - 1;
	if (last >= 0) {
		for (i = 0; i <= last; i++) {
57e1d2b0:	e2833001 	add	r3, r3, #1
			td = urb->td[i];
			if (td) {
57e1d2b4:	e3540000 	cmp	r4, #0
				td->usb_dev = NULL;
57e1d2b8:	1584101c 	strne	r1, [r4, #28]
				urb->td[i] = NULL;
57e1d2bc:	15021004 	strne	r1, [r2, #-4]
	int		last;
	struct td	*td;

	last = urb->length - 1;
	if (last >= 0) {
		for (i = 0; i <= last; i++) {
57e1d2c0:	e153000c 	cmp	r3, ip
57e1d2c4:	dafffff8 	ble	57e1d2ac <urb_free_priv+0x1c>
				urb->td[i] = NULL;
			}
		}
	}
	free(urb);
}
57e1d2c8:	e8bd4010 	pop	{r4, lr}
				td->usb_dev = NULL;
				urb->td[i] = NULL;
			}
		}
	}
	free(urb);
57e1d2cc:	eaffb1b2 	b	57e0999c <free>

57e1d2d0 <td_fill.clone.6>:
 * TD handling functions
 *-------------------------------------------------------------------------*/

/* enqueue next TD for this URB (OHCI spec 5.2.8.2) */

static void td_fill(ohci_t *ohci, unsigned int info,
57e1d2d0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e1d2d4:	e59d4018 	ldr	r4, [sp, #24]
	volatile td_t  *td, *td_pt;
#ifdef OHCI_FILL_TRACE
	int i;
#endif

	if (index > urb_priv->length) {
57e1d2d8:	e1d4c0b4 	ldrh	ip, [r4, #4]
57e1d2dc:	e153000c 	cmp	r3, ip
57e1d2e0:	da000002 	ble	57e1d2f0 <td_fill.clone.6+0x20>
		err("index > length");
57e1d2e4:	e59f006c 	ldr	r0, [pc, #108]	; 57e1d358 <td_fill.clone.6+0x88>

	td->hwNextTD = m32_swap((unsigned long)td_pt);

	/* append to queue */
	td->ed->hwTailP = td->hwNextTD;
}
57e1d2e8:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
#ifdef OHCI_FILL_TRACE
	int i;
#endif

	if (index > urb_priv->length) {
		err("index > length");
57e1d2ec:	eaffb056 	b	57e0944c <printf>
	td_pt = urb_priv->td [index];
	td_pt->hwNextTD = 0;

	/* fill the old dummy TD */
	td = urb_priv->td [index] =
			     (td_t *)(m32_swap(urb_priv->ed->hwTailP) & ~0xf);
57e1d2f0:	e5947000 	ldr	r7, [r4]
	if (index > urb_priv->length) {
		err("index > length");
		return;
	}
	/* use this td as the next dummy */
	td_pt = urb_priv->td [index];
57e1d2f4:	e283a00a 	add	sl, r3, #10
	td_pt->hwNextTD = 0;

	/* fill the old dummy TD */
	td = urb_priv->td [index] =
			     (td_t *)(m32_swap(urb_priv->ed->hwTailP) & ~0xf);
57e1d2f8:	e597c004 	ldr	ip, [r7, #4]
	if (index > urb_priv->length) {
		err("index > length");
		return;
	}
	/* use this td as the next dummy */
	td_pt = urb_priv->td [index];
57e1d2fc:	e794510a 	ldr	r5, [r4, sl, lsl #2]
	td_pt->hwNextTD = 0;
57e1d300:	e3a06000 	mov	r6, #0

	/* fill the old dummy TD */
	td = urb_priv->td [index] =
			     (td_t *)(m32_swap(urb_priv->ed->hwTailP) & ~0xf);
57e1d304:	e3ccc00f 	bic	ip, ip, #15
		printf("td->data[%d] %#2x ", i, ((unsigned char *)td->data)[i]);
		printf("\n");
	}
#endif
	if (!len)
		data = 0;
57e1d308:	e1520006 	cmp	r2, r6
	td = urb_priv->td [index] =
			     (td_t *)(m32_swap(urb_priv->ed->hwTailP) & ~0xf);

	td->ed = urb_priv->ed;
	td->next_dl_td = NULL;
	td->index = index;
57e1d30c:	e20330ff 	and	r3, r3, #255	; 0xff
		err("index > length");
		return;
	}
	/* use this td as the next dummy */
	td_pt = urb_priv->td [index];
	td_pt->hwNextTD = 0;
57e1d310:	e5856008 	str	r6, [r5, #8]

	/* fill the old dummy TD */
	td = urb_priv->td [index] =
57e1d314:	e784c10a 	str	ip, [r4, sl, lsl #2]
			     (td_t *)(m32_swap(urb_priv->ed->hwTailP) & ~0xf);

	td->ed = urb_priv->ed;
57e1d318:	e58c7014 	str	r7, [ip, #20]
	td->next_dl_td = NULL;
57e1d31c:	e58c6018 	str	r6, [ip, #24]
	td->index = index;
57e1d320:	e5cc3013 	strb	r3, [ip, #19]
	td->data = (__u32)data;
57e1d324:	e58c1024 	str	r1, [ip, #36]	; 0x24
		printf("td->data[%d] %#2x ", i, ((unsigned char *)td->data)[i]);
		printf("\n");
	}
#endif
	if (!len)
		data = 0;
57e1d328:	01a01006 	moveq	r1, r6

	td->hwINFO = m32_swap(info);
	td->hwCBP = m32_swap((unsigned long)data);
	if (data)
57e1d32c:	e1510006 	cmp	r1, r6
		td->hwBE = m32_swap((unsigned long)(data + len - 1));
57e1d330:	12422001 	subne	r2, r2, #1
	}
#endif
	if (!len)
		data = 0;

	td->hwINFO = m32_swap(info);
57e1d334:	e58c0000 	str	r0, [ip]
	td->hwCBP = m32_swap((unsigned long)data);
57e1d338:	e58c1004 	str	r1, [ip, #4]
	if (data)
		td->hwBE = m32_swap((unsigned long)(data + len - 1));
57e1d33c:	10811002 	addne	r1, r1, r2
	else
		td->hwBE = 0;
57e1d340:	e58c100c 	str	r1, [ip, #12]

	td->hwNextTD = m32_swap((unsigned long)td_pt);
57e1d344:	e58c5008 	str	r5, [ip, #8]

	/* append to queue */
	td->ed->hwTailP = td->hwNextTD;
57e1d348:	e59c3014 	ldr	r3, [ip, #20]
57e1d34c:	e59c2008 	ldr	r2, [ip, #8]
57e1d350:	e5832004 	str	r2, [r3, #4]
}
57e1d354:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e1d358:	57e3463e 	.word	0x57e3463e

57e1d35c <td_submit_job.clone.7>:

/*-------------------------------------------------------------------------*/

/* prepare all TDs of a transfer */

static void td_submit_job(struct usb_device *dev, unsigned long pipe,
57e1d35c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e1d360:	e1a07001 	mov	r7, r1
	__u32 info = 0;
	unsigned int toggle = 0;

	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle
	 * bits for reseting */
	if (usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
57e1d364:	e2179080 	ands	r9, r7, #128	; 0x80

/*-------------------------------------------------------------------------*/

/* prepare all TDs of a transfer */

static void td_submit_job(struct usb_device *dev, unsigned long pipe,
57e1d368:	e1a05003 	mov	r5, r3
	__u32 info = 0;
	unsigned int toggle = 0;

	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle
	 * bits for reseting */
	if (usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
57e1d36c:	13a03068 	movne	r3, #104	; 0x68
57e1d370:	03a0306c 	moveq	r3, #108	; 0x6c
57e1d374:	e0803003 	add	r3, r0, r3
57e1d378:	e5930004 	ldr	r0, [r3, #4]

/*-------------------------------------------------------------------------*/

/* prepare all TDs of a transfer */

static void td_submit_job(struct usb_device *dev, unsigned long pipe,
57e1d37c:	e1a04002 	mov	r4, r2
	__u32 info = 0;
	unsigned int toggle = 0;

	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle
	 * bits for reseting */
	if (usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
57e1d380:	e1a027a7 	lsr	r2, r7, #15
57e1d384:	e202200f 	and	r2, r2, #15
57e1d388:	e1a0c230 	lsr	ip, r0, r2
57e1d38c:	e31c0001 	tst	ip, #1
		toggle = TD_T_TOGGLE;
	} else {
		toggle = TD_T_DATA0;
		usb_settoggle(dev, usb_pipeendpoint(pipe),
57e1d390:	03a0c001 	moveq	ip, #1
57e1d394:	01a0221c 	lsleq	r2, ip, r2
57e1d398:	01c00002 	biceq	r0, r0, r2
57e1d39c:	01802002 	orreq	r2, r0, r2

/*-------------------------------------------------------------------------*/

/* prepare all TDs of a transfer */

static void td_submit_job(struct usb_device *dev, unsigned long pipe,
57e1d3a0:	e59d602c 	ldr	r6, [sp, #44]	; 0x2c
57e1d3a4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle
	 * bits for reseting */
	if (usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
		toggle = TD_T_TOGGLE;
	} else {
		toggle = TD_T_DATA0;
57e1d3a8:	03a0a402 	moveq	sl, #33554432	; 0x2000000
		usb_settoggle(dev, usb_pipeendpoint(pipe),
57e1d3ac:	05832004 	streq	r2, [r3, #4]
	unsigned int toggle = 0;

	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle
	 * bits for reseting */
	if (usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
		toggle = TD_T_TOGGLE;
57e1d3b0:	13a0a000 	movne	sl, #0
	if (data_len)
		data = buffer;
	else
		data = 0;

	switch (usb_pipetype(pipe)) {
57e1d3b4:	e1a07f27 	lsr	r7, r7, #30
	}
	urb->td_cnt = 0;
	if (data_len)
		data = buffer;
	else
		data = 0;
57e1d3b8:	e3550000 	cmp	r5, #0
	} else {
		toggle = TD_T_DATA0;
		usb_settoggle(dev, usb_pipeendpoint(pipe),
				usb_pipeout(pipe), 1);
	}
	urb->td_cnt = 0;
57e1d3bc:	e3a03000 	mov	r3, #0
	if (data_len)
		data = buffer;
	else
		data = 0;
57e1d3c0:	03a04000 	moveq	r4, #0

	switch (usb_pipetype(pipe)) {
57e1d3c4:	e3570002 	cmp	r7, #2
	} else {
		toggle = TD_T_DATA0;
		usb_settoggle(dev, usb_pipeendpoint(pipe),
				usb_pipeout(pipe), 1);
	}
	urb->td_cnt = 0;
57e1d3c8:	e1c630b6 	strh	r3, [r6, #6]
	if (data_len)
		data = buffer;
	else
		data = 0;

	switch (usb_pipetype(pipe)) {
57e1d3cc:	0a00002c 	beq	57e1d484 <td_submit_job.clone.7+0x128>
57e1d3d0:	e3570003 	cmp	r7, #3
57e1d3d4:	0a000002 	beq	57e1d3e4 <td_submit_job.clone.7+0x88>
57e1d3d8:	e3570001 	cmp	r7, #1
57e1d3dc:	1a000056 	bne	57e1d53c <td_submit_job.clone.7+0x1e0>
57e1d3e0:	ea000049 	b	57e1d50c <td_submit_job.clone.7+0x1b0>
	case PIPE_BULK:
		info = usb_pipeout(pipe)?
			TD_CC | TD_DP_OUT : TD_CC | TD_DP_IN ;
57e1d3e4:	e59f3158 	ldr	r3, [pc, #344]	; 57e1d544 <td_submit_job.clone.7+0x1e8>
57e1d3e8:	e3590000 	cmp	r9, #0
57e1d3ec:	e59fb154 	ldr	fp, [pc, #340]	; 57e1d548 <td_submit_job.clone.7+0x1ec>
			  int interval)
{
	ohci_t *ohci = &gohci;
	int data_len = transfer_len;
	void *data;
	int cnt = 0;
57e1d3f0:	e3a07000 	mov	r7, #0
		data = 0;

	switch (usb_pipetype(pipe)) {
	case PIPE_BULK:
		info = usb_pipeout(pipe)?
			TD_CC | TD_DP_OUT : TD_CC | TD_DP_IN ;
57e1d3f4:	11a0b003 	movne	fp, r3
57e1d3f8:	ea00000b 	b	57e1d42c <td_submit_job.clone.7+0xd0>
		while (data_len > 4096) {
			td_fill(ohci, info | (cnt? TD_T_TOGGLE:toggle),
57e1d3fc:	e3570000 	cmp	r7, #0
57e1d400:	01a0000a 	moveq	r0, sl
57e1d404:	13a00000 	movne	r0, #0
57e1d408:	e1a01004 	mov	r1, r4
57e1d40c:	e1a03007 	mov	r3, r7
57e1d410:	e180000b 	orr	r0, r0, fp
57e1d414:	e3a02a01 	mov	r2, #4096	; 0x1000
57e1d418:	e58d6000 	str	r6, [sp]
57e1d41c:	ebffffab 	bl	57e1d2d0 <td_fill.clone.6>
				data, 4096, dev, cnt, urb);
			data += 4096; data_len -= 4096; cnt++;
57e1d420:	e2844a01 	add	r4, r4, #4096	; 0x1000
57e1d424:	e2455a01 	sub	r5, r5, #4096	; 0x1000
57e1d428:	e2877001 	add	r7, r7, #1

	switch (usb_pipetype(pipe)) {
	case PIPE_BULK:
		info = usb_pipeout(pipe)?
			TD_CC | TD_DP_OUT : TD_CC | TD_DP_IN ;
		while (data_len > 4096) {
57e1d42c:	e3550a01 	cmp	r5, #4096	; 0x1000
57e1d430:	cafffff1 	bgt	57e1d3fc <td_submit_job.clone.7+0xa0>
			td_fill(ohci, info | (cnt? TD_T_TOGGLE:toggle),
				data, 4096, dev, cnt, urb);
			data += 4096; data_len -= 4096; cnt++;
		}
		info = usb_pipeout(pipe)?
			TD_CC | TD_DP_OUT : TD_CC | TD_R | TD_DP_IN ;
57e1d434:	e59f3110 	ldr	r3, [pc, #272]	; 57e1d54c <td_submit_job.clone.7+0x1f0>
57e1d438:	e59f2108 	ldr	r2, [pc, #264]	; 57e1d548 <td_submit_job.clone.7+0x1ec>
57e1d43c:	e3590000 	cmp	r9, #0
57e1d440:	01a09002 	moveq	r9, r2
57e1d444:	11a09003 	movne	r9, r3
		td_fill(ohci, info | (cnt? TD_T_TOGGLE:toggle), data,
57e1d448:	e3570000 	cmp	r7, #0
57e1d44c:	13a0a000 	movne	sl, #0
57e1d450:	e1a02005 	mov	r2, r5
57e1d454:	e1a03007 	mov	r3, r7
57e1d458:	e18a0009 	orr	r0, sl, r9
57e1d45c:	e1a01004 	mov	r1, r4
57e1d460:	e58d6000 	str	r6, [sp]
57e1d464:	ebffff99 	bl	57e1d2d0 <td_fill.clone.6>
			data_len, dev, cnt, urb);
		cnt++;

		if (!ohci->sleeping) {
57e1d468:	e59f30e0 	ldr	r3, [pc, #224]	; 57e1d550 <td_submit_job.clone.7+0x1f4>
57e1d46c:	e593200c 	ldr	r2, [r3, #12]
57e1d470:	e3520000 	cmp	r2, #0
			/* start bulk list */
			ohci_writel(OHCI_BLF, &ohci->regs->cmdstatus);
57e1d474:	05933014 	ldreq	r3, [r3, #20]
57e1d478:	02822004 	addeq	r2, r2, #4
			TD_CC | TD_DP_OUT : TD_CC | TD_R | TD_DP_IN ;
		td_fill(ohci, info | (cnt? TD_T_TOGGLE:toggle), data,
			data_len, dev, cnt, urb);
		cnt++;

		if (!ohci->sleeping) {
57e1d47c:	0a000020 	beq	57e1d504 <td_submit_job.clone.7+0x1a8>
57e1d480:	ea00002d 	b	57e1d53c <td_submit_job.clone.7+0x1e0>
		break;

	case PIPE_CONTROL:
		/* Setup phase */
		info = TD_CC | TD_DP_SETUP | TD_T_DATA0;
		td_fill(ohci, info, setup, 8, dev, cnt++, urb);
57e1d484:	e3a03000 	mov	r3, #0
57e1d488:	e3a004f2 	mov	r0, #-234881024	; 0xf2000000
57e1d48c:	e3a02008 	mov	r2, #8
57e1d490:	e58d6000 	str	r6, [sp]
57e1d494:	ebffff8d 	bl	57e1d2d0 <td_fill.clone.6>

		/* Optional Data phase */
		if (data_len > 0) {
57e1d498:	e3550000 	cmp	r5, #0
		break;

	case PIPE_CONTROL:
		/* Setup phase */
		info = TD_CC | TD_DP_SETUP | TD_T_DATA0;
		td_fill(ohci, info, setup, 8, dev, cnt++, urb);
57e1d49c:	d3a03001 	movle	r3, #1

		/* Optional Data phase */
		if (data_len > 0) {
57e1d4a0:	da000009 	ble	57e1d4cc <td_submit_job.clone.7+0x170>
			info = usb_pipeout(pipe)?
				TD_CC | TD_R | TD_DP_OUT | TD_T_DATA1 :
				TD_CC | TD_R | TD_DP_IN | TD_T_DATA1;
			/* NOTE:  mishandles transfers >8K, some >4K */
			td_fill(ohci, info, data, data_len, dev, cnt++, urb);
57e1d4a4:	e59f30a8 	ldr	r3, [pc, #168]	; 57e1d554 <td_submit_job.clone.7+0x1f8>
57e1d4a8:	e3590000 	cmp	r9, #0
57e1d4ac:	e59f00a4 	ldr	r0, [pc, #164]	; 57e1d558 <td_submit_job.clone.7+0x1fc>
57e1d4b0:	e1a01004 	mov	r1, r4
57e1d4b4:	11a00003 	movne	r0, r3
57e1d4b8:	e1a02005 	mov	r2, r5
57e1d4bc:	e3a03001 	mov	r3, #1
57e1d4c0:	e58d6000 	str	r6, [sp]
57e1d4c4:	ebffff81 	bl	57e1d2d0 <td_fill.clone.6>
57e1d4c8:	e1a03007 	mov	r3, r7

		/* Status phase */
		info = usb_pipeout(pipe)?
			TD_CC | TD_DP_IN | TD_T_DATA1:
			TD_CC | TD_DP_OUT | TD_T_DATA1;
		td_fill(ohci, info, data, 0, dev, cnt++, urb);
57e1d4cc:	e59f2088 	ldr	r2, [pc, #136]	; 57e1d55c <td_submit_job.clone.7+0x200>
57e1d4d0:	e3590000 	cmp	r9, #0
57e1d4d4:	e59f0084 	ldr	r0, [pc, #132]	; 57e1d560 <td_submit_job.clone.7+0x204>
57e1d4d8:	e1a01004 	mov	r1, r4
57e1d4dc:	11a00002 	movne	r0, r2
57e1d4e0:	e3a02000 	mov	r2, #0
57e1d4e4:	e58d6000 	str	r6, [sp]
57e1d4e8:	ebffff78 	bl	57e1d2d0 <td_fill.clone.6>

		if (!ohci->sleeping) {
57e1d4ec:	e59f305c 	ldr	r3, [pc, #92]	; 57e1d550 <td_submit_job.clone.7+0x1f4>
57e1d4f0:	e593200c 	ldr	r2, [r3, #12]
57e1d4f4:	e3520000 	cmp	r2, #0
57e1d4f8:	1a00000f 	bne	57e1d53c <td_submit_job.clone.7+0x1e0>
			/* start Control list */
			ohci_writel(OHCI_CLF, &ohci->regs->cmdstatus);
57e1d4fc:	e5933014 	ldr	r3, [r3, #20]
57e1d500:	e2822002 	add	r2, r2, #2
57e1d504:	e5832008 	str	r2, [r3, #8]
57e1d508:	ea00000b 	b	57e1d53c <td_submit_job.clone.7+0x1e0>
		}
		break;

	case PIPE_INTERRUPT:
		info = usb_pipeout(urb->pipe)?
57e1d50c:	e5963010 	ldr	r3, [r6, #16]
57e1d510:	e38a020f 	orr	r0, sl, #-268435456	; 0xf0000000
57e1d514:	e3130080 	tst	r3, #128	; 0x80
			TD_CC | TD_DP_OUT | toggle:
57e1d518:	13800705 	orrne	r0, r0, #1310720	; 0x140000
57e1d51c:	03800702 	orreq	r0, r0, #524288	; 0x80000
			TD_CC | TD_R | TD_DP_IN | toggle;
		td_fill(ohci, info, data, data_len, dev, cnt++, urb);
57e1d520:	e1a01004 	mov	r1, r4
57e1d524:	e1a02005 	mov	r2, r5
57e1d528:	e3a03000 	mov	r3, #0
57e1d52c:	e58d6028 	str	r6, [sp, #40]	; 0x28
		break;
	}
	if (urb->length != cnt)
		dbg("TD LENGTH %d != CNT %d", urb->length, cnt);
}
57e1d530:	e28dd008 	add	sp, sp, #8
57e1d534:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}

	case PIPE_INTERRUPT:
		info = usb_pipeout(urb->pipe)?
			TD_CC | TD_DP_OUT | toggle:
			TD_CC | TD_R | TD_DP_IN | toggle;
		td_fill(ohci, info, data, data_len, dev, cnt++, urb);
57e1d538:	eaffff64 	b	57e1d2d0 <td_fill.clone.6>
		break;
	}
	if (urb->length != cnt)
		dbg("TD LENGTH %d != CNT %d", urb->length, cnt);
}
57e1d53c:	e28dd008 	add	sp, sp, #8
57e1d540:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1d544:	f0100000 	.word	0xf0100000
57e1d548:	f0080000 	.word	0xf0080000
57e1d54c:	f0140000 	.word	0xf0140000
57e1d550:	57e47a00 	.word	0x57e47a00
57e1d554:	f3140000 	.word	0xf3140000
57e1d558:	f30c0000 	.word	0xf30c0000
57e1d55c:	f3080000 	.word	0xf3080000
57e1d560:	f3100000 	.word	0xf3100000

57e1d564 <hc_reset.clone.16>:
 * HC functions
 *-------------------------------------------------------------------------*/

/* reset the HC and BUS */

static int hc_reset(ohci_t *ohci)
57e1d564:	e92d4038 	push	{r3, r4, r5, lr}
			udelay(1);
		}
	} else
		printf("No EHCI func at %d index!\n", CONFIG_PCI_EHCI_DEVNO);
#endif
	if (ohci_readl(&ohci->regs->control) & OHCI_CTRL_IR) {
57e1d568:	e59f50a0 	ldr	r5, [pc, #160]	; 57e1d610 <hc_reset.clone.16+0xac>
57e1d56c:	e5953014 	ldr	r3, [r5, #20]
57e1d570:	e5932004 	ldr	r2, [r3, #4]
57e1d574:	e3120c01 	tst	r2, #256	; 0x100
		/* SMM owns the HC, request ownership */
		ohci_writel(OHCI_OCR, &ohci->regs->cmdstatus);
57e1d578:	13a02008 	movne	r2, #8
57e1d57c:	15832008 	strne	r2, [r3, #8]
{
#ifdef CONFIG_PCI_EHCI_DEVNO
	pci_dev_t pdev;
#endif
	int timeout = 30;
	int smm_timeout = 50; /* 0,5 sec */
57e1d580:	13a04032 	movne	r4, #50	; 0x32
			udelay(1);
		}
	} else
		printf("No EHCI func at %d index!\n", CONFIG_PCI_EHCI_DEVNO);
#endif
	if (ohci_readl(&ohci->regs->control) & OHCI_CTRL_IR) {
57e1d584:	1a000005 	bne	57e1d5a0 <hc_reset.clone.16+0x3c>
57e1d588:	ea000008 	b	57e1d5b0 <hc_reset.clone.16+0x4c>
		/* SMM owns the HC, request ownership */
		ohci_writel(OHCI_OCR, &ohci->regs->cmdstatus);
		info("USB HC TakeOver from SMM");
		while (ohci_readl(&ohci->regs->control) & OHCI_CTRL_IR) {
			mdelay(10);
57e1d58c:	e3a0000a 	mov	r0, #10
57e1d590:	eb001bf4 	bl	57e24568 <mdelay>
			if (--smm_timeout == 0) {
57e1d594:	e2544001 	subs	r4, r4, #1
				err("USB HC TakeOver failed!");
57e1d598:	059f0074 	ldreq	r0, [pc, #116]	; 57e1d614 <hc_reset.clone.16+0xb0>
57e1d59c:	0a000011 	beq	57e1d5e8 <hc_reset.clone.16+0x84>
#endif
	if (ohci_readl(&ohci->regs->control) & OHCI_CTRL_IR) {
		/* SMM owns the HC, request ownership */
		ohci_writel(OHCI_OCR, &ohci->regs->cmdstatus);
		info("USB HC TakeOver from SMM");
		while (ohci_readl(&ohci->regs->control) & OHCI_CTRL_IR) {
57e1d5a0:	e5953014 	ldr	r3, [r5, #20]
57e1d5a4:	e5933004 	ldr	r3, [r3, #4]
57e1d5a8:	e3130c01 	tst	r3, #256	; 0x100
57e1d5ac:	1afffff6 	bne	57e1d58c <hc_reset.clone.16+0x28>
			}
		}
	}

	/* Disable HC interrupts */
	ohci_writel(OHCI_INTR_MIE, &ohci->regs->intrdisable);
57e1d5b0:	e59f5058 	ldr	r5, [pc, #88]	; 57e1d610 <hc_reset.clone.16+0xac>
57e1d5b4:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
57e1d5b8:	e5953014 	ldr	r3, [r5, #20]
	/* Reset USB (needed by some controllers) */
	ohci->hc_control = 0;
	ohci_writel(ohci->hc_control, &ohci->regs->control);

	/* HC Reset requires max 10 us delay */
	ohci_writel(OHCI_HCR,  &ohci->regs->cmdstatus);
57e1d5bc:	e3a0401e 	mov	r4, #30
			}
		}
	}

	/* Disable HC interrupts */
	ohci_writel(OHCI_INTR_MIE, &ohci->regs->intrdisable);
57e1d5c0:	e5832014 	str	r2, [r3, #20]
	dbg("USB HC reset_hc usb-%s: ctrl = 0x%X ;\n",
		ohci->slot_name,
		ohci_readl(&ohci->regs->control));

	/* Reset USB (needed by some controllers) */
	ohci->hc_control = 0;
57e1d5c4:	e0822002 	add	r2, r2, r2
57e1d5c8:	e58520ac 	str	r2, [r5, #172]	; 0xac
	ohci_writel(ohci->hc_control, &ohci->regs->control);
57e1d5cc:	e5832004 	str	r2, [r3, #4]

	/* HC Reset requires max 10 us delay */
	ohci_writel(OHCI_HCR,  &ohci->regs->cmdstatus);
57e1d5d0:	e2822001 	add	r2, r2, #1
57e1d5d4:	e5832008 	str	r2, [r3, #8]
57e1d5d8:	ea000007 	b	57e1d5fc <hc_reset.clone.16+0x98>
	while ((ohci_readl(&ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
		if (--timeout == 0) {
57e1d5dc:	e2544001 	subs	r4, r4, #1
57e1d5e0:	1a000003 	bne	57e1d5f4 <hc_reset.clone.16+0x90>
			err("USB HC reset timed out!");
57e1d5e4:	e59f002c 	ldr	r0, [pc, #44]	; 57e1d618 <hc_reset.clone.16+0xb4>
57e1d5e8:	ebffaf97 	bl	57e0944c <printf>
			return -1;
57e1d5ec:	e3e00000 	mvn	r0, #0
57e1d5f0:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
		udelay(1);
57e1d5f4:	e3a00001 	mov	r0, #1
57e1d5f8:	eb001bce 	bl	57e24538 <udelay>
	ohci->hc_control = 0;
	ohci_writel(ohci->hc_control, &ohci->regs->control);

	/* HC Reset requires max 10 us delay */
	ohci_writel(OHCI_HCR,  &ohci->regs->cmdstatus);
	while ((ohci_readl(&ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
57e1d5fc:	e5953014 	ldr	r3, [r5, #20]
57e1d600:	e5930008 	ldr	r0, [r3, #8]
57e1d604:	e2100001 	ands	r0, r0, #1
57e1d608:	1afffff3 	bne	57e1d5dc <hc_reset.clone.16+0x78>
			return -1;
		}
		udelay(1);
	}
	return 0;
}
57e1d60c:	e8bd8038 	pop	{r3, r4, r5, pc}
57e1d610:	57e47a00 	.word	0x57e47a00
57e1d614:	57e34655 	.word	0x57e34655
57e1d618:	57e34675 	.word	0x57e34675

57e1d61c <sohci_submit_job>:
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
{
57e1d61c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	urb_priv_t *purb_priv = urb;
	int i, size = 0;
	struct usb_device *dev = urb->dev;
	unsigned long pipe = urb->pipe;
	void *buffer = urb->transfer_buffer;
	int transfer_len = urb->transfer_buffer_length;
57e1d620:	e5903018 	ldr	r3, [r0, #24]
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
{
57e1d624:	e24dd030 	sub	sp, sp, #48	; 0x30
	urb_priv_t *purb_priv = urb;
	int i, size = 0;
	struct usb_device *dev = urb->dev;
	unsigned long pipe = urb->pipe;
	void *buffer = urb->transfer_buffer;
	int transfer_len = urb->transfer_buffer_length;
57e1d628:	e58d3018 	str	r3, [sp, #24]

	ohci = &gohci;

	/* when controller's hung, permit only roothub cleanup attempts
	 * such as powering down ports */
	if (ohci->disabled) {
57e1d62c:	e59f355c 	ldr	r3, [pc, #1372]	; 57e1db90 <sohci_submit_job+0x574>
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
{
57e1d630:	e58d1028 	str	r1, [sp, #40]	; 0x28
	ed_t *ed;
	urb_priv_t *purb_priv = urb;
	int i, size = 0;
	struct usb_device *dev = urb->dev;
	unsigned long pipe = urb->pipe;
	void *buffer = urb->transfer_buffer;
57e1d634:	e5901014 	ldr	r1, [r0, #20]

	ohci = &gohci;

	/* when controller's hung, permit only roothub cleanup attempts
	 * such as powering down ports */
	if (ohci->disabled) {
57e1d638:	e5939008 	ldr	r9, [r3, #8]
	ed_t *ed;
	urb_priv_t *purb_priv = urb;
	int i, size = 0;
	struct usb_device *dev = urb->dev;
	unsigned long pipe = urb->pipe;
	void *buffer = urb->transfer_buffer;
57e1d63c:	e58d1020 	str	r1, [sp, #32]
	int transfer_len = urb->transfer_buffer_length;
	int interval = urb->interval;
57e1d640:	e590101c 	ldr	r1, [r0, #28]

	ohci = &gohci;

	/* when controller's hung, permit only roothub cleanup attempts
	 * such as powering down ports */
	if (ohci->disabled) {
57e1d644:	e3590000 	cmp	r9, #0
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
{
57e1d648:	e1a05000 	mov	r5, r0
	ohci_t *ohci;
	ed_t *ed;
	urb_priv_t *purb_priv = urb;
	int i, size = 0;
	struct usb_device *dev = urb->dev;
57e1d64c:	e590a008 	ldr	sl, [r0, #8]
	unsigned long pipe = urb->pipe;
57e1d650:	e5906010 	ldr	r6, [r0, #16]
	void *buffer = urb->transfer_buffer;
	int transfer_len = urb->transfer_buffer_length;
	int interval = urb->interval;
57e1d654:	e58d101c 	str	r1, [sp, #28]
	ohci = &gohci;

	/* when controller's hung, permit only roothub cleanup attempts
	 * such as powering down ports */
	if (ohci->disabled) {
		err("sohci_submit_job: EPIPE");
57e1d658:	159f0534 	ldrne	r0, [pc, #1332]	; 57e1db94 <sohci_submit_job+0x578>

	ohci = &gohci;

	/* when controller's hung, permit only roothub cleanup attempts
	 * such as powering down ports */
	if (ohci->disabled) {
57e1d65c:	1a000018 	bne	57e1d6c4 <sohci_submit_job+0xa8>
{
	td_t *td;
	ed_t *ed_ret;
	volatile ed_t *ed;

	ed = ed_ret = &ohci_dev.ed[(usb_pipeendpoint(pipe) << 1) |
57e1d660:	e1a007a6 	lsr	r0, r6, #15
			(usb_pipecontrol(pipe)? 0: usb_pipeout(pipe))];
57e1d664:	e1a07f26 	lsr	r7, r6, #30
{
	td_t *td;
	ed_t *ed_ret;
	volatile ed_t *ed;

	ed = ed_ret = &ohci_dev.ed[(usb_pipeendpoint(pipe) << 1) |
57e1d668:	e200000f 	and	r0, r0, #15
57e1d66c:	e3570002 	cmp	r7, #2
		return -1;
	}

	/* we're about to begin a new transaction here so mark the
	 * URB unfinished */
	urb->finished = 0;
57e1d670:	e5859024 	str	r9, [r5, #36]	; 0x24
{
	td_t *td;
	ed_t *ed_ret;
	volatile ed_t *ed;

	ed = ed_ret = &ohci_dev.ed[(usb_pipeendpoint(pipe) << 1) |
57e1d674:	e1a03080 	lsl	r3, r0, #1
57e1d678:	0a000002 	beq	57e1d688 <sohci_submit_job+0x6c>
57e1d67c:	e3160080 	tst	r6, #128	; 0x80
57e1d680:	13a09000 	movne	r9, #0
57e1d684:	03a09001 	moveq	r9, #1
57e1d688:	e1899003 	orr	r9, r9, r3
57e1d68c:	e3a02030 	mov	r2, #48	; 0x30
57e1d690:	e0020299 	mul	r2, r9, r2
57e1d694:	e59f14f4 	ldr	r1, [pc, #1268]	; 57e1db90 <sohci_submit_job+0x574>
57e1d698:	e2813e15 	add	r3, r1, #336	; 0x150
57e1d69c:	e0834002 	add	r4, r3, r2
			(usb_pipecontrol(pipe)? 0: usb_pipeout(pipe))];

	if ((ed->state & ED_DEL) || (ed->state & ED_URB_DEL)) {
57e1d6a0:	e5d4c018 	ldrb	ip, [r4, #24]
57e1d6a4:	e31c0004 	tst	ip, #4
57e1d6a8:	1a000002 	bne	57e1d6b8 <sohci_submit_job+0x9c>
57e1d6ac:	e5d4c018 	ldrb	ip, [r4, #24]
57e1d6b0:	e31c0008 	tst	ip, #8
57e1d6b4:	0a000005 	beq	57e1d6d0 <sohci_submit_job+0xb4>
		err("ep_add_ed: pending delete");
57e1d6b8:	e59f04d8 	ldr	r0, [pc, #1240]	; 57e1db98 <sohci_submit_job+0x57c>
57e1d6bc:	ebffaf62 	bl	57e0944c <printf>
	urb->finished = 0;

	/* every endpoint has a ed, locate and fill it */
	ed = ep_add_ed(dev, pipe, interval, 1);
	if (!ed) {
		err("sohci_submit_job: ENOMEM");
57e1d6c0:	e59f04d4 	ldr	r0, [pc, #1236]	; 57e1db9c <sohci_submit_job+0x580>
57e1d6c4:	ebffaf60 	bl	57e0944c <printf>
		return -1;
57e1d6c8:	e3e00000 	mvn	r0, #0
57e1d6cc:	ea00012d 	b	57e1db88 <sohci_submit_job+0x56c>
		err("ep_add_ed: pending delete");
		/* pending delete request */
		return NULL;
	}

	if (ed->state == ED_NEW) {
57e1d6d0:	e5d4c018 	ldrb	ip, [r4, #24]
57e1d6d4:	e35c0000 	cmp	ip, #0
57e1d6d8:	1a000014 	bne	57e1d730 <sohci_submit_job+0x114>
57e1d6dc:	e59112e0 	ldr	r1, [r1, #736]	; 0x2e0
 * Interface functions (URB)
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
57e1d6e0:	e281ca01 	add	ip, r1, #4096	; 0x1000
	struct td	*td;

	td = NULL;
	for (i = 0; i < NUM_TD; i++)
	{
		if (ptd[i].usb_dev == NULL)
57e1d6e4:	e591e01c 	ldr	lr, [r1, #28]
57e1d6e8:	e35e0000 	cmp	lr, #0
		{
			td = &ptd[i];
			td->usb_dev = usb_dev;
57e1d6ec:	0581a01c 	streq	sl, [r1, #28]
57e1d6f0:	0a000003 	beq	57e1d704 <sohci_submit_job+0xe8>
57e1d6f4:	e2811040 	add	r1, r1, #64	; 0x40
{
	int i;
	struct td	*td;

	td = NULL;
	for (i = 0; i < NUM_TD; i++)
57e1d6f8:	e151000c 	cmp	r1, ip
57e1d6fc:	1afffff8 	bne	57e1d6e4 <sohci_submit_job+0xc8>
td_alloc (struct usb_device *usb_dev)
{
	int i;
	struct td	*td;

	td = NULL;
57e1d700:	e3a01000 	mov	r1, #0
	}

	if (ed->state == ED_NEW) {
		/* dummy td; end of td list for ed */
		td = td_alloc(usb_dev);
		ed->hwTailP = m32_swap((unsigned long)td);
57e1d704:	e5841004 	str	r1, [r4, #4]
		ed->hwHeadP = ed->hwTailP;
57e1d708:	e5941004 	ldr	r1, [r4, #4]
57e1d70c:	e5841008 	str	r1, [r4, #8]
		ed->state = ED_UNLINK;
57e1d710:	e3a01001 	mov	r1, #1
57e1d714:	e5c41018 	strb	r1, [r4, #24]
		ed->type = usb_pipetype(pipe);
57e1d718:	e20710ff 	and	r1, r7, #255	; 0xff
57e1d71c:	e5c41019 	strb	r1, [r4, #25]
		ohci_dev.ed_cnt++;
57e1d720:	e59f1468 	ldr	r1, [pc, #1128]	; 57e1db90 <sohci_submit_job+0x574>
57e1d724:	e591c2d0 	ldr	ip, [r1, #720]	; 0x2d0
57e1d728:	e28cc001 	add	ip, ip, #1
57e1d72c:	e581c2d0 	str	ip, [r1, #720]	; 0x2d0
	}

	ed->hwINFO = m32_swap(usb_pipedevice(pipe)
57e1d730:	e1a0c426 	lsr	ip, r6, #8
57e1d734:	e3570000 	cmp	r7, #0
57e1d738:	e20cc07f 	and	ip, ip, #127	; 0x7f
57e1d73c:	03a01902 	moveq	r1, #32768	; 0x8000
57e1d740:	13a01000 	movne	r1, #0
57e1d744:	e18cc380 	orr	ip, ip, r0, lsl #7
57e1d748:	e3570002 	cmp	r7, #2
57e1d74c:	e18cc001 	orr	ip, ip, r1
57e1d750:	03a01000 	moveq	r1, #0
57e1d754:	0a000002 	beq	57e1d764 <sohci_submit_job+0x148>
57e1d758:	e3160080 	tst	r6, #128	; 0x80
57e1d75c:	03a01b02 	moveq	r1, #2048	; 0x800
57e1d760:	13a01a01 	movne	r1, #4096	; 0x1000
57e1d764:	e59ab004 	ldr	fp, [sl, #4]
57e1d768:	e18cc001 	orr	ip, ip, r1
57e1d76c:	e35b0001 	cmp	fp, #1
57e1d770:	e1a0000a 	mov	r0, sl
57e1d774:	e1a01006 	mov	r1, r6
57e1d778:	03a0ba02 	moveq	fp, #8192	; 0x2000
57e1d77c:	13a0b000 	movne	fp, #0
57e1d780:	e58d2010 	str	r2, [sp, #16]
57e1d784:	e58d300c 	str	r3, [sp, #12]
57e1d788:	e58dc014 	str	ip, [sp, #20]
57e1d78c:	ebffc9b9 	bl	57e0fe78 <usb_maxpacket>
57e1d790:	e59dc014 	ldr	ip, [sp, #20]
57e1d794:	e59d300c 	ldr	r3, [sp, #12]
57e1d798:	e18cb00b 	orr	fp, ip, fp
57e1d79c:	e59d2010 	ldr	r2, [sp, #16]
57e1d7a0:	e18bb800 	orr	fp, fp, r0, lsl #16
57e1d7a4:	e783b002 	str	fp, [r3, r2]
			| (usb_pipecontrol(pipe)? 0: \
					   (usb_pipeout(pipe)? 0x800: 0x1000))
			| (usb_dev->speed == USB_SPEED_LOW) << 13
			| usb_maxpacket(usb_dev, pipe) << 16);

	if (ed->type == PIPE_INTERRUPT && ed->state == ED_UNLINK) {
57e1d7a8:	e5d43019 	ldrb	r3, [r4, #25]
57e1d7ac:	e3530001 	cmp	r3, #1
57e1d7b0:	1a000006 	bne	57e1d7d0 <sohci_submit_job+0x1b4>
57e1d7b4:	e5d43018 	ldrb	r3, [r4, #24]
57e1d7b8:	e20330ff 	and	r3, r3, #255	; 0xff
57e1d7bc:	e3530001 	cmp	r3, #1
		ed->int_period = interval;
57e1d7c0:	059d101c 	ldreq	r1, [sp, #28]
57e1d7c4:	020120ff 	andeq	r2, r1, #255	; 0xff
57e1d7c8:	05c42014 	strbeq	r2, [r4, #20]
		ed->int_load = load;
57e1d7cc:	05c43016 	strbeq	r3, [r4, #22]
		err("sohci_submit_job: ENOMEM");
		return -1;
	}

	/* for the private part of the URB we need the number of TDs (size) */
	switch (usb_pipetype(pipe)) {
57e1d7d0:	e3570002 	cmp	r7, #2
57e1d7d4:	0a00000d 	beq	57e1d810 <sohci_submit_job+0x1f4>
57e1d7d8:	e3570003 	cmp	r7, #3
57e1d7dc:	0a000003 	beq	57e1d7f0 <sohci_submit_job+0x1d4>
int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
{
	ohci_t *ohci;
	ed_t *ed;
	urb_priv_t *purb_priv = urb;
	int i, size = 0;
57e1d7e0:	e3570001 	cmp	r7, #1
57e1d7e4:	03a01001 	moveq	r1, #1
57e1d7e8:	13a01000 	movne	r1, #0
57e1d7ec:	ea000011 	b	57e1d838 <sohci_submit_job+0x21c>
	}

	/* for the private part of the URB we need the number of TDs (size) */
	switch (usb_pipetype(pipe)) {
	case PIPE_BULK: /* one TD for every 4096 Byte */
		size = (transfer_len - 1) / 4096 + 1;
57e1d7f0:	e59d3018 	ldr	r3, [sp, #24]
57e1d7f4:	e2431001 	sub	r1, r3, #1
57e1d7f8:	e2817eff 	add	r7, r1, #4080	; 0xff0
57e1d7fc:	e3510000 	cmp	r1, #0
57e1d800:	b287100f 	addlt	r1, r7, #15
57e1d804:	e1a01641 	asr	r1, r1, #12
57e1d808:	e2811001 	add	r1, r1, #1
		break;
57e1d80c:	ea000009 	b	57e1d838 <sohci_submit_job+0x21c>
	case PIPE_CONTROL:/* 1 TD for setup, 1 for ACK and 1 for every 4096 B */
		size = (transfer_len == 0)? 2:
57e1d810:	e59d1018 	ldr	r1, [sp, #24]
57e1d814:	e3510000 	cmp	r1, #0
57e1d818:	01a01007 	moveq	r1, r7
57e1d81c:	0a000005 	beq	57e1d838 <sohci_submit_job+0x21c>
					(transfer_len - 1) / 4096 + 3;
57e1d820:	e2411001 	sub	r1, r1, #1
57e1d824:	e2817eff 	add	r7, r1, #4080	; 0xff0
57e1d828:	e3510000 	cmp	r1, #0
57e1d82c:	b287100f 	addlt	r1, r7, #15
57e1d830:	e1a01641 	asr	r1, r1, #12
	switch (usb_pipetype(pipe)) {
	case PIPE_BULK: /* one TD for every 4096 Byte */
		size = (transfer_len - 1) / 4096 + 1;
		break;
	case PIPE_CONTROL:/* 1 TD for setup, 1 for ACK and 1 for every 4096 B */
		size = (transfer_len == 0)? 2:
57e1d834:	e2811003 	add	r1, r1, #3
	case PIPE_INTERRUPT: /* 1 TD */
		size = 1;
		break;
	}

	ed->purb = urb;
57e1d838:	e59f3350 	ldr	r3, [pc, #848]	; 57e1db90 <sohci_submit_job+0x574>
57e1d83c:	e3a02030 	mov	r2, #48	; 0x30
57e1d840:	e0203992 	mla	r0, r2, r9, r3

	if (size >= (N_URB_TD - 1)) {
57e1d844:	e351002e 	cmp	r1, #46	; 0x2e
	case PIPE_INTERRUPT: /* 1 TD */
		size = 1;
		break;
	}

	ed->purb = urb;
57e1d848:	e5805174 	str	r5, [r0, #372]	; 0x174

	if (size >= (N_URB_TD - 1)) {
57e1d84c:	da000002 	ble	57e1d85c <sohci_submit_job+0x240>
		err("need %d TDs, only have %d", size, N_URB_TD);
57e1d850:	e59f0348 	ldr	r0, [pc, #840]	; 57e1dba0 <sohci_submit_job+0x584>
57e1d854:	ebffaefc 	bl	57e0944c <printf>
57e1d858:	eaffff9a 	b	57e1d6c8 <sohci_submit_job+0xac>
	for (i = 0; i < NUM_TD; i++)
	{
		if (ptd[i].usb_dev == NULL)
57e1d85c:	e59302e0 	ldr	r0, [r3, #736]	; 0x2e0
	purb_priv->pipe = pipe;

	/* fill the private part of the URB */
	purb_priv->length = size;
	purb_priv->ed = ed;
	purb_priv->actual_length = 0;
57e1d860:	e3a02000 	mov	r2, #0

	if (size >= (N_URB_TD - 1)) {
		err("need %d TDs, only have %d", size, N_URB_TD);
		return -1;
	}
	purb_priv->pipe = pipe;
57e1d864:	e5856010 	str	r6, [r5, #16]

	/* fill the private part of the URB */
	purb_priv->length = size;
57e1d868:	e1c510b4 	strh	r1, [r5, #4]
	purb_priv->ed = ed;
57e1d86c:	e5854000 	str	r4, [r5]
	purb_priv->actual_length = 0;
57e1d870:	e5852020 	str	r2, [r5, #32]
 * Interface functions (URB)
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
57e1d874:	e285c024 	add	ip, r5, #36	; 0x24
57e1d878:	e280ea01 	add	lr, r0, #4096	; 0x1000
	purb_priv->ed = ed;
	purb_priv->actual_length = 0;

	/* allocate the TDs */
	/* note that td[0] was allocated in ep_add_ed */
	for (i = 0; i < size; i++) {
57e1d87c:	ea00000f 	b	57e1d8c0 <sohci_submit_job+0x2a4>
57e1d880:	e593701c 	ldr	r7, [r3, #28]
57e1d884:	e3570000 	cmp	r7, #0
		{
			td = &ptd[i];
			td->usb_dev = usb_dev;
57e1d888:	0583a01c 	streq	sl, [r3, #28]
57e1d88c:	0a000003 	beq	57e1d8a0 <sohci_submit_job+0x284>
57e1d890:	e2833040 	add	r3, r3, #64	; 0x40
{
	int i;
	struct td	*td;

	td = NULL;
	for (i = 0; i < NUM_TD; i++)
57e1d894:	e153000e 	cmp	r3, lr
57e1d898:	1afffff8 	bne	57e1d880 <sohci_submit_job+0x264>
td_alloc (struct usb_device *usb_dev)
{
	int i;
	struct td	*td;

	td = NULL;
57e1d89c:	e3a03000 	mov	r3, #0
		purb_priv->td[i] = td_alloc(dev);
		if (!purb_priv->td[i]) {
57e1d8a0:	e3530000 	cmp	r3, #0
	purb_priv->actual_length = 0;

	/* allocate the TDs */
	/* note that td[0] was allocated in ep_add_ed */
	for (i = 0; i < size; i++) {
		purb_priv->td[i] = td_alloc(dev);
57e1d8a4:	e5ac3004 	str	r3, [ip, #4]!
		if (!purb_priv->td[i]) {
57e1d8a8:	1a000003 	bne	57e1d8bc <sohci_submit_job+0x2a0>
			purb_priv->length = i;
57e1d8ac:	e1c520b4 	strh	r2, [r5, #4]
			urb_free_priv(purb_priv);
57e1d8b0:	e1a00005 	mov	r0, r5
57e1d8b4:	ebfffe75 	bl	57e1d290 <urb_free_priv>
57e1d8b8:	eaffff80 	b	57e1d6c0 <sohci_submit_job+0xa4>
	purb_priv->ed = ed;
	purb_priv->actual_length = 0;

	/* allocate the TDs */
	/* note that td[0] was allocated in ep_add_ed */
	for (i = 0; i < size; i++) {
57e1d8bc:	e2822001 	add	r2, r2, #1
57e1d8c0:	e1520001 	cmp	r2, r1
57e1d8c4:	b1a03000 	movlt	r3, r0
57e1d8c8:	baffffec 	blt	57e1d880 <sohci_submit_job+0x264>
			err("sohci_submit_job: ENOMEM");
			return -1;
		}
	}

	if (ed->state == ED_NEW || (ed->state & ED_DEL)) {
57e1d8cc:	e59f32bc 	ldr	r3, [pc, #700]	; 57e1db90 <sohci_submit_job+0x574>
57e1d8d0:	e3a02030 	mov	r2, #48	; 0x30
57e1d8d4:	e0293992 	mla	r9, r2, r9, r3
57e1d8d8:	e5d92168 	ldrb	r2, [r9, #360]	; 0x168
57e1d8dc:	e3520000 	cmp	r2, #0
57e1d8e0:	0a000001 	beq	57e1d8ec <sohci_submit_job+0x2d0>
57e1d8e4:	e2127004 	ands	r7, r2, #4
57e1d8e8:	0a000003 	beq	57e1d8fc <sohci_submit_job+0x2e0>
		urb_free_priv(purb_priv);
57e1d8ec:	e1a00005 	mov	r0, r5
57e1d8f0:	ebfffe66 	bl	57e1d290 <urb_free_priv>
		err("sohci_submit_job: EINVAL");
57e1d8f4:	e59f02a8 	ldr	r0, [pc, #680]	; 57e1dba4 <sohci_submit_job+0x588>
57e1d8f8:	eaffff71 	b	57e1d6c4 <sohci_submit_job+0xa8>
		return -1;
	}

	/* link the ed into a chain if is not already */
	if (ed->state != ED_OPER)
57e1d8fc:	e3520002 	cmp	r2, #2
57e1d900:	0a000097 	beq	57e1db64 <sohci_submit_job+0x548>
	int inter;
	int interval;
	int load;
	__u32 *ed_p;

	ed->state = ED_OPER;
57e1d904:	e3a02002 	mov	r2, #2
57e1d908:	e5c42018 	strb	r2, [r4, #24]
	ed->int_interval = 0;
57e1d90c:	e5c47017 	strb	r7, [r4, #23]

	switch (ed->type) {
57e1d910:	e5d42019 	ldrb	r2, [r4, #25]
57e1d914:	e20220ff 	and	r2, r2, #255	; 0xff
57e1d918:	e3520002 	cmp	r2, #2
57e1d91c:	0a000004 	beq	57e1d934 <sohci_submit_job+0x318>
57e1d920:	e3520003 	cmp	r2, #3
57e1d924:	0a00001c 	beq	57e1d99c <sohci_submit_job+0x380>
57e1d928:	e3520001 	cmp	r2, #1
57e1d92c:	1a00008c 	bne	57e1db64 <sohci_submit_job+0x548>
57e1d930:	ea000033 	b	57e1da04 <sohci_submit_job+0x3e8>
	case PIPE_CONTROL:
		ed->hwNextED = 0;
		if (ohci->ed_controltail == NULL)
57e1d934:	e59320a4 	ldr	r2, [r3, #164]	; 0xa4
	ed->state = ED_OPER;
	ed->int_interval = 0;

	switch (ed->type) {
	case PIPE_CONTROL:
		ed->hwNextED = 0;
57e1d938:	e584700c 	str	r7, [r4, #12]
		if (ohci->ed_controltail == NULL)
57e1d93c:	e3520000 	cmp	r2, #0
			ohci_writel(ed, &ohci->regs->ed_controlhead);
57e1d940:	05933014 	ldreq	r3, [r3, #20]
		else
			ohci->ed_controltail->hwNextED =
57e1d944:	1582400c 	strne	r4, [r2, #12]

	switch (ed->type) {
	case PIPE_CONTROL:
		ed->hwNextED = 0;
		if (ohci->ed_controltail == NULL)
			ohci_writel(ed, &ohci->regs->ed_controlhead);
57e1d948:	05834020 	streq	r4, [r3, #32]
		else
			ohci->ed_controltail->hwNextED =
						   m32_swap((unsigned long)ed);

		ed->ed_prev = ohci->ed_controltail;
		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
57e1d94c:	e3520000 	cmp	r2, #0
			ohci_writel(ed, &ohci->regs->ed_controlhead);
		else
			ohci->ed_controltail->hwNextED =
						   m32_swap((unsigned long)ed);

		ed->ed_prev = ohci->ed_controltail;
57e1d950:	e5842010 	str	r2, [r4, #16]
		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
57e1d954:	1a00000d 	bne	57e1d990 <sohci_submit_job+0x374>
57e1d958:	e59f3230 	ldr	r3, [pc, #560]	; 57e1db90 <sohci_submit_job+0x574>
57e1d95c:	e5932098 	ldr	r2, [r3, #152]	; 0x98
57e1d960:	e3520000 	cmp	r2, #0
57e1d964:	1a000009 	bne	57e1d990 <sohci_submit_job+0x374>
57e1d968:	e593209c 	ldr	r2, [r3, #156]	; 0x9c
57e1d96c:	e3520000 	cmp	r2, #0
57e1d970:	1a000006 	bne	57e1d990 <sohci_submit_job+0x374>
			!ohci->ed_rm_list[1] && !ohci->sleeping) {
57e1d974:	e593200c 	ldr	r2, [r3, #12]
57e1d978:	e3520000 	cmp	r2, #0
			ohci->hc_control |= OHCI_CTRL_CLE;
57e1d97c:	059320ac 	ldreq	r2, [r3, #172]	; 0xac
57e1d980:	03822010 	orreq	r2, r2, #16
57e1d984:	058320ac 	streq	r2, [r3, #172]	; 0xac
			ohci_writel(ohci->hc_control, &ohci->regs->control);
57e1d988:	05933014 	ldreq	r3, [r3, #20]
57e1d98c:	05832004 	streq	r2, [r3, #4]
		}
		ohci->ed_controltail = edi;
57e1d990:	e59f31f8 	ldr	r3, [pc, #504]	; 57e1db90 <sohci_submit_job+0x574>
57e1d994:	e58340a4 	str	r4, [r3, #164]	; 0xa4
57e1d998:	ea000071 	b	57e1db64 <sohci_submit_job+0x548>
		break;

	case PIPE_BULK:
		ed->hwNextED = 0;
		if (ohci->ed_bulktail == NULL)
57e1d99c:	e59320a0 	ldr	r2, [r3, #160]	; 0xa0
		}
		ohci->ed_controltail = edi;
		break;

	case PIPE_BULK:
		ed->hwNextED = 0;
57e1d9a0:	e584700c 	str	r7, [r4, #12]
		if (ohci->ed_bulktail == NULL)
57e1d9a4:	e3520000 	cmp	r2, #0
			ohci_writel(ed, &ohci->regs->ed_bulkhead);
57e1d9a8:	05933014 	ldreq	r3, [r3, #20]
		else
			ohci->ed_bulktail->hwNextED =
57e1d9ac:	1582400c 	strne	r4, [r2, #12]
		break;

	case PIPE_BULK:
		ed->hwNextED = 0;
		if (ohci->ed_bulktail == NULL)
			ohci_writel(ed, &ohci->regs->ed_bulkhead);
57e1d9b0:	05834028 	streq	r4, [r3, #40]	; 0x28
		else
			ohci->ed_bulktail->hwNextED =
						   m32_swap((unsigned long)ed);

		ed->ed_prev = ohci->ed_bulktail;
		if (!ohci->ed_bulktail && !ohci->ed_rm_list[0] &&
57e1d9b4:	e3520000 	cmp	r2, #0
			ohci_writel(ed, &ohci->regs->ed_bulkhead);
		else
			ohci->ed_bulktail->hwNextED =
						   m32_swap((unsigned long)ed);

		ed->ed_prev = ohci->ed_bulktail;
57e1d9b8:	e5842010 	str	r2, [r4, #16]
		if (!ohci->ed_bulktail && !ohci->ed_rm_list[0] &&
57e1d9bc:	1a00000d 	bne	57e1d9f8 <sohci_submit_job+0x3dc>
57e1d9c0:	e59f31c8 	ldr	r3, [pc, #456]	; 57e1db90 <sohci_submit_job+0x574>
57e1d9c4:	e5932098 	ldr	r2, [r3, #152]	; 0x98
57e1d9c8:	e3520000 	cmp	r2, #0
57e1d9cc:	1a000009 	bne	57e1d9f8 <sohci_submit_job+0x3dc>
57e1d9d0:	e593209c 	ldr	r2, [r3, #156]	; 0x9c
57e1d9d4:	e3520000 	cmp	r2, #0
57e1d9d8:	1a000006 	bne	57e1d9f8 <sohci_submit_job+0x3dc>
			!ohci->ed_rm_list[1] && !ohci->sleeping) {
57e1d9dc:	e593200c 	ldr	r2, [r3, #12]
57e1d9e0:	e3520000 	cmp	r2, #0
			ohci->hc_control |= OHCI_CTRL_BLE;
57e1d9e4:	059320ac 	ldreq	r2, [r3, #172]	; 0xac
57e1d9e8:	03822020 	orreq	r2, r2, #32
57e1d9ec:	058320ac 	streq	r2, [r3, #172]	; 0xac
			ohci_writel(ohci->hc_control, &ohci->regs->control);
57e1d9f0:	05933014 	ldreq	r3, [r3, #20]
57e1d9f4:	05832004 	streq	r2, [r3, #4]
		}
		ohci->ed_bulktail = edi;
57e1d9f8:	e59f3190 	ldr	r3, [pc, #400]	; 57e1db90 <sohci_submit_job+0x574>
57e1d9fc:	e58340a0 	str	r4, [r3, #160]	; 0xa0
57e1da00:	ea000057 	b	57e1db64 <sohci_submit_job+0x548>
		break;

	case PIPE_INTERRUPT:
		load = ed->int_load;
57e1da04:	e5d49016 	ldrb	r9, [r4, #22]
		interval = ep_2_n_interval(ed->int_period);
57e1da08:	e5d42014 	ldrb	r2, [r4, #20]
		}
		ohci->ed_bulktail = edi;
		break;

	case PIPE_INTERRUPT:
		load = ed->int_load;
57e1da0c:	e20990ff 	and	r9, r9, #255	; 0xff
		interval = ep_2_n_interval(ed->int_period);
57e1da10:	e20220ff 	and	r2, r2, #255	; 0xff
57e1da14:	ea000000 	b	57e1da1c <sohci_submit_job+0x400>
/*  2^int( ld (inter)) */

static int ep_2_n_interval(int inter)
{
	int i;
	for (i = 0; ((inter >> i) > 1) && (i < 5); i++);
57e1da18:	e2877001 	add	r7, r7, #1
57e1da1c:	e1a03752 	asr	r3, r2, r7
57e1da20:	e3530001 	cmp	r3, #1
57e1da24:	d3a03000 	movle	r3, #0
57e1da28:	c3a03001 	movgt	r3, #1
57e1da2c:	e3570004 	cmp	r7, #4
57e1da30:	c3a03000 	movgt	r3, #0
57e1da34:	e3530000 	cmp	r3, #0
57e1da38:	1afffff6 	bne	57e1da18 <sohci_submit_job+0x3fc>
	return 1 << i;
57e1da3c:	e3a02001 	mov	r2, #1
57e1da40:	e1a07712 	lsl	r7, r2, r7
		break;

	case PIPE_INTERRUPT:
		load = ed->int_load;
		interval = ep_2_n_interval(ed->int_period);
		ed->int_interval = interval;
57e1da44:	e20720ff 	and	r2, r7, #255	; 0xff
57e1da48:	e5c42017 	strb	r2, [r4, #23]

	/* search for the least loaded interrupt endpoint
	 * branch of all 32 branches
	 */
	for (i = 0; i < 32; i++)
		if (ohci->ohci_int_load [branch] > ohci->ohci_int_load [i])
57e1da4c:	e59f113c 	ldr	r1, [pc, #316]	; 57e1db90 <sohci_submit_job+0x574>
		break;

	case PIPE_INTERRUPT:
		load = ed->int_load;
		interval = ep_2_n_interval(ed->int_period);
		ed->int_interval = interval;
57e1da50:	e59f2150 	ldr	r2, [pc, #336]	; 57e1dba8 <sohci_submit_job+0x58c>
 * returns the branch and
 * sets the interval to interval = 2^integer (ld (interval)) */

static int ep_int_ballance(ohci_t *ohci, int interval, int load)
{
	int i, branch = 0;
57e1da54:	e1a00003 	mov	r0, r3

	/* search for the least loaded interrupt endpoint
	 * branch of all 32 branches
	 */
	for (i = 0; i < 32; i++)
		if (ohci->ohci_int_load [branch] > ohci->ohci_int_load [i])
57e1da58:	e280c006 	add	ip, r0, #6
57e1da5c:	e791e10c 	ldr	lr, [r1, ip, lsl #2]
57e1da60:	e5b2c004 	ldr	ip, [r2, #4]!
57e1da64:	e15e000c 	cmp	lr, ip
57e1da68:	c1a00003 	movgt	r0, r3
	int i, branch = 0;

	/* search for the least loaded interrupt endpoint
	 * branch of all 32 branches
	 */
	for (i = 0; i < 32; i++)
57e1da6c:	e2833001 	add	r3, r3, #1
57e1da70:	e3530020 	cmp	r3, #32
57e1da74:	1afffff7 	bne	57e1da58 <sohci_submit_job+0x43c>
		if (ohci->ohci_int_load [branch] > ohci->ohci_int_load [i])
			branch = i;

	branch = branch % interval;
57e1da78:	e1a01007 	mov	r1, r7
57e1da7c:	eb003856 	bl	57e2bbdc <__aeabi_idivmod>
 * Interface functions (URB)
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
57e1da80:	e59f3108 	ldr	r3, [pc, #264]	; 57e1db90 <sohci_submit_job+0x574>
57e1da84:	e2812006 	add	r2, r1, #6
	 */
	for (i = 0; i < 32; i++)
		if (ohci->ohci_int_load [branch] > ohci->ohci_int_load [i])
			branch = i;

	branch = branch % interval;
57e1da88:	e1a0b001 	mov	fp, r1
 * Interface functions (URB)
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
57e1da8c:	e0833102 	add	r3, r3, r2, lsl #2
	for (i = 0; i < 32; i++)
		if (ohci->ohci_int_load [branch] > ohci->ohci_int_load [i])
			branch = i;

	branch = branch % interval;
	for (i = branch; i < 32; i += interval)
57e1da90:	e1a02001 	mov	r2, r1
 * Interface functions (URB)
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
57e1da94:	e3e01003 	mvn	r1, #3
57e1da98:	e1a00107 	lsl	r0, r7, #2
57e1da9c:	e0010197 	mul	r1, r7, r1
57e1daa0:	ea000003 	b	57e1dab4 <sohci_submit_job+0x498>
		if (ohci->ohci_int_load [branch] > ohci->ohci_int_load [i])
			branch = i;

	branch = branch % interval;
	for (i = branch; i < 32; i += interval)
		ohci->ohci_int_load [i] += load;
57e1daa4:	e793c001 	ldr	ip, [r3, r1]
 * Interface functions (URB)
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
57e1daa8:	e0822007 	add	r2, r2, r7
		if (ohci->ohci_int_load [branch] > ohci->ohci_int_load [i])
			branch = i;

	branch = branch % interval;
	for (i = branch; i < 32; i += interval)
		ohci->ohci_int_load [i] += load;
57e1daac:	e08cc009 	add	ip, ip, r9
57e1dab0:	e783c001 	str	ip, [r3, r1]
	for (i = 0; i < 32; i++)
		if (ohci->ohci_int_load [branch] > ohci->ohci_int_load [i])
			branch = i;

	branch = branch % interval;
	for (i = branch; i < 32; i += interval)
57e1dab4:	e352001f 	cmp	r2, #31
 * Interface functions (URB)
 *-------------------------------------------------------------------------*/

/* get a transfer request */

int sohci_submit_job(urb_priv_t *urb, struct devrequest *setup)
57e1dab8:	e0833000 	add	r3, r3, r0
	for (i = 0; i < 32; i++)
		if (ohci->ohci_int_load [branch] > ohci->ohci_int_load [i])
			branch = i;

	branch = branch % interval;
	for (i = branch; i < 32; i += interval)
57e1dabc:	dafffff8 	ble	57e1daa4 <sohci_submit_job+0x488>
	case PIPE_INTERRUPT:
		load = ed->int_load;
		interval = ep_2_n_interval(ed->int_period);
		ed->int_interval = interval;
		int_branch = ep_int_ballance(ohci, interval, load);
		ed->int_branch = int_branch;
57e1dac0:	e20b30ff 	and	r3, fp, #255	; 0xff
57e1dac4:	e5c43015 	strb	r3, [r4, #21]

		for (i = 0; i < ep_rev(6, interval); i += inter) {
57e1dac8:	e3a00006 	mov	r0, #6
57e1dacc:	e1a01007 	mov	r1, r7
57e1dad0:	ebfffde0 	bl	57e1d258 <ep_rev>
			inter = 1;
			for (ed_p = &(ohci->hcca->int_table[\
57e1dad4:	e59f30b4 	ldr	r3, [pc, #180]	; 57e1db90 <sohci_submit_job+0x574>
		interval = ep_2_n_interval(ed->int_period);
		ed->int_interval = interval;
		int_branch = ep_int_ballance(ohci, interval, load);
		ed->int_branch = int_branch;

		for (i = 0; i < ep_rev(6, interval); i += inter) {
57e1dad8:	e58d0024 	str	r0, [sp, #36]	; 0x24
			inter = 1;
			for (ed_p = &(ohci->hcca->int_table[\
57e1dadc:	e5933000 	ldr	r3, [r3]
57e1dae0:	e58da02c 	str	sl, [sp, #44]	; 0x2c
57e1dae4:	e58d301c 	str	r3, [sp, #28]
		interval = ep_2_n_interval(ed->int_period);
		ed->int_interval = interval;
		int_branch = ep_int_ballance(ohci, interval, load);
		ed->int_branch = int_branch;

		for (i = 0; i < ep_rev(6, interval); i += inter) {
57e1dae8:	e3a03000 	mov	r3, #0
57e1daec:	e1a09003 	mov	r9, r3
57e1daf0:	ea000017 	b	57e1db54 <sohci_submit_job+0x538>
			inter = 1;
			for (ed_p = &(ohci->hcca->int_table[\
						ep_rev(5, i) + int_branch]);
57e1daf4:	e3a00005 	mov	r0, #5
57e1daf8:	e1a01009 	mov	r1, r9
57e1dafc:	ebfffdd5 	bl	57e1d258 <ep_rev>
		int_branch = ep_int_ballance(ohci, interval, load);
		ed->int_branch = int_branch;

		for (i = 0; i < ep_rev(6, interval); i += inter) {
			inter = 1;
			for (ed_p = &(ohci->hcca->int_table[\
57e1db00:	e59d301c 	ldr	r3, [sp, #28]
						ep_rev(5, i) + int_branch]);
57e1db04:	e080000b 	add	r0, r0, fp
		int_branch = ep_int_ballance(ohci, interval, load);
		ed->int_branch = int_branch;

		for (i = 0; i < ep_rev(6, interval); i += inter) {
			inter = 1;
			for (ed_p = &(ohci->hcca->int_table[\
57e1db08:	e083a100 	add	sl, r3, r0, lsl #2
57e1db0c:	e7932100 	ldr	r2, [r3, r0, lsl #2]
		ed->int_interval = interval;
		int_branch = ep_int_ballance(ohci, interval, load);
		ed->int_branch = int_branch;

		for (i = 0; i < ep_rev(6, interval); i += inter) {
			inter = 1;
57e1db10:	e3a00001 	mov	r0, #1
57e1db14:	ea000005 	b	57e1db30 <sohci_submit_job+0x514>
			for (ed_p = &(ohci->hcca->int_table[\
						ep_rev(5, i) + int_branch]);
				(*ed_p != 0) &&
				(((ed_t *)ed_p)->int_interval >= interval);
				ed_p = &(((ed_t *)ed_p)->hwNextED))
					inter = ep_rev(6,
57e1db18:	e3a00006 	mov	r0, #6
57e1db1c:	e58d300c 	str	r3, [sp, #12]
57e1db20:	ebfffdcc 	bl	57e1d258 <ep_rev>
			inter = 1;
			for (ed_p = &(ohci->hcca->int_table[\
						ep_rev(5, i) + int_branch]);
				(*ed_p != 0) &&
				(((ed_t *)ed_p)->int_interval >= interval);
				ed_p = &(((ed_t *)ed_p)->hwNextED))
57e1db24:	e59d300c 	ldr	r3, [sp, #12]
57e1db28:	e28aa00c 	add	sl, sl, #12
57e1db2c:	e593200c 	ldr	r2, [r3, #12]
		int_branch = ep_int_ballance(ohci, interval, load);
		ed->int_branch = int_branch;

		for (i = 0; i < ep_rev(6, interval); i += inter) {
			inter = 1;
			for (ed_p = &(ohci->hcca->int_table[\
57e1db30:	e3520000 	cmp	r2, #0
57e1db34:	0a000003 	beq	57e1db48 <sohci_submit_job+0x52c>
						ep_rev(5, i) + int_branch]);
				(*ed_p != 0) &&
				(((ed_t *)ed_p)->int_interval >= interval);
57e1db38:	e5da1017 	ldrb	r1, [sl, #23]
57e1db3c:	e1a0300a 	mov	r3, sl

		for (i = 0; i < ep_rev(6, interval); i += inter) {
			inter = 1;
			for (ed_p = &(ohci->hcca->int_table[\
						ep_rev(5, i) + int_branch]);
				(*ed_p != 0) &&
57e1db40:	e1510007 	cmp	r1, r7
57e1db44:	aafffff3 	bge	57e1db18 <sohci_submit_job+0x4fc>
				(((ed_t *)ed_p)->int_interval >= interval);
				ed_p = &(((ed_t *)ed_p)->hwNextED))
					inter = ep_rev(6,
						 ((ed_t *)ed_p)->int_interval);
			ed->hwNextED = *ed_p;
57e1db48:	e584200c 	str	r2, [r4, #12]
		interval = ep_2_n_interval(ed->int_period);
		ed->int_interval = interval;
		int_branch = ep_int_ballance(ohci, interval, load);
		ed->int_branch = int_branch;

		for (i = 0; i < ep_rev(6, interval); i += inter) {
57e1db4c:	e0899000 	add	r9, r9, r0
				(((ed_t *)ed_p)->int_interval >= interval);
				ed_p = &(((ed_t *)ed_p)->hwNextED))
					inter = ep_rev(6,
						 ((ed_t *)ed_p)->int_interval);
			ed->hwNextED = *ed_p;
			*ed_p = m32_swap((unsigned long)ed);
57e1db50:	e58a4000 	str	r4, [sl]
		interval = ep_2_n_interval(ed->int_period);
		ed->int_interval = interval;
		int_branch = ep_int_ballance(ohci, interval, load);
		ed->int_branch = int_branch;

		for (i = 0; i < ep_rev(6, interval); i += inter) {
57e1db54:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
57e1db58:	e1590001 	cmp	r9, r1
57e1db5c:	baffffe4 	blt	57e1daf4 <sohci_submit_job+0x4d8>
57e1db60:	e59da02c 	ldr	sl, [sp, #44]	; 0x2c
	/* link the ed into a chain if is not already */
	if (ed->state != ED_OPER)
		ep_link(ohci, ed);

	/* fill the TDs and link it to the ed */
	td_submit_job(dev, pipe, buffer, transfer_len,
57e1db64:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
57e1db68:	e1a0000a 	mov	r0, sl
57e1db6c:	e58d3000 	str	r3, [sp]
57e1db70:	e1a01006 	mov	r1, r6
57e1db74:	e59d2020 	ldr	r2, [sp, #32]
57e1db78:	e59d3018 	ldr	r3, [sp, #24]
57e1db7c:	e58d5004 	str	r5, [sp, #4]
57e1db80:	ebfffdf5 	bl	57e1d35c <td_submit_job.clone.7>
		      setup, purb_priv, interval);

	return 0;
57e1db84:	e3a00000 	mov	r0, #0
}
57e1db88:	e28dd030 	add	sp, sp, #48	; 0x30
57e1db8c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1db90:	57e47a00 	.word	0x57e47a00
57e1db94:	57e34695 	.word	0x57e34695
57e1db98:	57e346b5 	.word	0x57e346b5
57e1db9c:	57e346d7 	.word	0x57e346d7
57e1dba0:	57e346f8 	.word	0x57e346f8
57e1dba4:	57e3471a 	.word	0x57e3471a
57e1dba8:	57e47a14 	.word	0x57e47a14

57e1dbac <rh_check_port_status>:
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
	return 0;
}
57e1dbac:	e5902014 	ldr	r2, [r0, #20]
#define RD_RH_PORTSTAT		roothub_portstatus(&gohci, wIndex-1)

/* request to virtual root hub */

int rh_check_port_status(ohci_t *controller)
{
57e1dbb0:	e92d4010 	push	{r4, lr}
struct ohci_device ohci_dev;
/* device which was disconnected */
struct usb_device *devgone;

static inline u32 roothub_a(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.a); }
57e1dbb4:	e592c048 	ldr	ip, [r2, #72]	; 0x48
	temp = roothub_a(controller);
	ndp = (temp & RH_A_NDP);
#ifdef CONFIG_AT91C_PQFP_UHPBUG
	ndp = (ndp == 2) ? 1:0;
#endif
	for (i = 0; i < ndp; i++) {
57e1dbb8:	e3a03000 	mov	r3, #0
	__u32 temp, ndp, i;
	int res;

	res = -1;
	temp = roothub_a(controller);
	ndp = (temp & RH_A_NDP);
57e1dbbc:	e20cc0ff 	and	ip, ip, #255	; 0xff
static inline u32 roothub_b(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.b); }
static inline u32 roothub_status(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.status); }
static inline u32 roothub_portstatus(struct ohci *hc, int i)
	{ return ohci_readl(&hc->regs->roothub.portstatus[i]); }
57e1dbc0:	e2821054 	add	r1, r2, #84	; 0x54
	temp = roothub_a(controller);
	ndp = (temp & RH_A_NDP);
#ifdef CONFIG_AT91C_PQFP_UHPBUG
	ndp = (ndp == 2) ? 1:0;
#endif
	for (i = 0; i < ndp; i++) {
57e1dbc4:	ea000006 	b	57e1dbe4 <rh_check_port_status+0x38>
static inline u32 roothub_b(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.b); }
static inline u32 roothub_status(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.status); }
static inline u32 roothub_portstatus(struct ohci *hc, int i)
	{ return ohci_readl(&hc->regs->roothub.portstatus[i]); }
57e1dbc8:	e7914103 	ldr	r4, [r1, r3, lsl #2]
#endif
	for (i = 0; i < ndp; i++) {
		temp = roothub_portstatus(controller, i);
		/* check for a device disconnect */
		if (((temp & (RH_PS_PESC | RH_PS_CSC)) ==
			(RH_PS_PESC | RH_PS_CSC)) &&
57e1dbcc:	e59f2020 	ldr	r2, [pc, #32]	; 57e1dbf4 <rh_check_port_status+0x48>
	temp = roothub_a(controller);
	ndp = (temp & RH_A_NDP);
#ifdef CONFIG_AT91C_PQFP_UHPBUG
	ndp = (ndp == 2) ? 1:0;
#endif
	for (i = 0; i < ndp; i++) {
57e1dbd0:	e1a00003 	mov	r0, r3
		temp = roothub_portstatus(controller, i);
		/* check for a device disconnect */
		if (((temp & (RH_PS_PESC | RH_PS_CSC)) ==
			(RH_PS_PESC | RH_PS_CSC)) &&
57e1dbd4:	e0042002 	and	r2, r4, r2
	ndp = (ndp == 2) ? 1:0;
#endif
	for (i = 0; i < ndp; i++) {
		temp = roothub_portstatus(controller, i);
		/* check for a device disconnect */
		if (((temp & (RH_PS_PESC | RH_PS_CSC)) ==
57e1dbd8:	e3520803 	cmp	r2, #196608	; 0x30000
57e1dbdc:	08bd8010 	popeq	{r4, pc}
	temp = roothub_a(controller);
	ndp = (temp & RH_A_NDP);
#ifdef CONFIG_AT91C_PQFP_UHPBUG
	ndp = (ndp == 2) ? 1:0;
#endif
	for (i = 0; i < ndp; i++) {
57e1dbe0:	e2833001 	add	r3, r3, #1
57e1dbe4:	e153000c 	cmp	r3, ip
57e1dbe8:	3afffff6 	bcc	57e1dbc8 <rh_check_port_status+0x1c>
int rh_check_port_status(ohci_t *controller)
{
	__u32 temp, ndp, i;
	int res;

	res = -1;
57e1dbec:	e3e00000 	mvn	r0, #0
			res = i;
			break;
		}
	}
	return res;
}
57e1dbf0:	e8bd8010 	pop	{r4, pc}
57e1dbf4:	00030001 	.word	0x00030001

57e1dbf8 <submit_common_msg>:

/* common code for handling submit messages - used for all but root hub */
/* accesses. */
int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
		int transfer_len, struct devrequest *setup, int interval)
{
57e1dbf8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1dbfc:	e24dd028 	sub	sp, sp, #40	; 0x28
57e1dc00:	e1a05002 	mov	r5, r2
57e1dc04:	e1a04001 	mov	r4, r1
57e1dc08:	e58d3024 	str	r3, [sp, #36]	; 0x24
57e1dc0c:	e58d0018 	str	r0, [sp, #24]
	int stat = 0;
	int maxsize = usb_maxpacket(dev, pipe);
57e1dc10:	ebffc898 	bl	57e0fe78 <usb_maxpacket>
57e1dc14:	e1a06000 	mov	r6, r0
	int timeout;
	urb_priv_t *urb;

	urb = malloc(sizeof(urb_priv_t));
57e1dc18:	e3a000e8 	mov	r0, #232	; 0xe8
57e1dc1c:	ebffafe8 	bl	57e09bc4 <malloc>
	memset(urb, 0, sizeof(urb_priv_t));
57e1dc20:	e3a01000 	mov	r1, #0
	int stat = 0;
	int maxsize = usb_maxpacket(dev, pipe);
	int timeout;
	urb_priv_t *urb;

	urb = malloc(sizeof(urb_priv_t));
57e1dc24:	e1a0b000 	mov	fp, r0
	memset(urb, 0, sizeof(urb_priv_t));
57e1dc28:	e3a020e8 	mov	r2, #232	; 0xe8
57e1dc2c:	eb001992 	bl	57e2427c <memset>

	urb->dev = dev;
	urb->pipe = pipe;
	urb->transfer_buffer = buffer;
57e1dc30:	e58b5014 	str	r5, [fp, #20]
	urb->transfer_buffer_length = transfer_len;
	urb->interval = interval;
57e1dc34:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c

	/* device pulled? Shortcut the action. */
	if (devgone == dev) {
57e1dc38:	e59f5614 	ldr	r5, [pc, #1556]	; 57e1e254 <submit_common_msg+0x65c>
	urb_priv_t *urb;

	urb = malloc(sizeof(urb_priv_t));
	memset(urb, 0, sizeof(urb_priv_t));

	urb->dev = dev;
57e1dc3c:	e59d1018 	ldr	r1, [sp, #24]
	urb->pipe = pipe;
	urb->transfer_buffer = buffer;
	urb->transfer_buffer_length = transfer_len;
	urb->interval = interval;
57e1dc40:	e58b301c 	str	r3, [fp, #28]

	/* device pulled? Shortcut the action. */
	if (devgone == dev) {
57e1dc44:	e59532e4 	ldr	r3, [r5, #740]	; 0x2e4
	memset(urb, 0, sizeof(urb_priv_t));

	urb->dev = dev;
	urb->pipe = pipe;
	urb->transfer_buffer = buffer;
	urb->transfer_buffer_length = transfer_len;
57e1dc48:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
	urb->interval = interval;

	/* device pulled? Shortcut the action. */
	if (devgone == dev) {
57e1dc4c:	e1530001 	cmp	r3, r1
	memset(urb, 0, sizeof(urb_priv_t));

	urb->dev = dev;
	urb->pipe = pipe;
	urb->transfer_buffer = buffer;
	urb->transfer_buffer_length = transfer_len;
57e1dc50:	e58b2018 	str	r2, [fp, #24]
	urb->interval = interval;

	/* device pulled? Shortcut the action. */
	if (devgone == dev) {
		dev->status = USB_ST_CRC_ERR;
57e1dc54:	03a02020 	moveq	r2, #32
	urb_priv_t *urb;

	urb = malloc(sizeof(urb_priv_t));
	memset(urb, 0, sizeof(urb_priv_t));

	urb->dev = dev;
57e1dc58:	e58b1008 	str	r1, [fp, #8]
	urb->pipe = pipe;
57e1dc5c:	e58b4010 	str	r4, [fp, #16]
	urb->transfer_buffer_length = transfer_len;
	urb->interval = interval;

	/* device pulled? Shortcut the action. */
	if (devgone == dev) {
		dev->status = USB_ST_CRC_ERR;
57e1dc60:	05832614 	streq	r2, [r3, #1556]	; 0x614
	urb->transfer_buffer = buffer;
	urb->transfer_buffer_length = transfer_len;
	urb->interval = interval;

	/* device pulled? Shortcut the action. */
	if (devgone == dev) {
57e1dc64:	0a000175 	beq	57e1e240 <submit_common_msg+0x648>
#ifdef DEBUG
	urb->actual_length = 0;
	pkt_print(urb, dev, pipe, buffer, transfer_len,
		  setup, "SUB", usb_pipein(pipe));
#else
	mdelay(1);
57e1dc68:	e3a00001 	mov	r0, #1
57e1dc6c:	eb001a3d 	bl	57e24568 <mdelay>
#endif
	if (!maxsize) {
57e1dc70:	e3560000 	cmp	r6, #0
57e1dc74:	1a000003 	bne	57e1dc88 <submit_common_msg+0x90>
		err("submit_common_message: pipesize for pipe %lx is zero",
57e1dc78:	e1a01004 	mov	r1, r4
57e1dc7c:	e59f05d4 	ldr	r0, [pc, #1492]	; 57e1e258 <submit_common_msg+0x660>
57e1dc80:	ebffadf1 	bl	57e0944c <printf>
57e1dc84:	ea000006 	b	57e1dca4 <submit_common_msg+0xac>
			pipe);
		return -1;
	}

	if (sohci_submit_job(urb, setup) < 0) {
57e1dc88:	e1a0000b 	mov	r0, fp
57e1dc8c:	e59d1048 	ldr	r1, [sp, #72]	; 0x48
57e1dc90:	ebfffe61 	bl	57e1d61c <sohci_submit_job>
57e1dc94:	e3500000 	cmp	r0, #0
57e1dc98:	aa000003 	bge	57e1dcac <submit_common_msg+0xb4>
		err("sohci_submit_job failed");
57e1dc9c:	e59f05b8 	ldr	r0, [pc, #1464]	; 57e1e25c <submit_common_msg+0x664>
57e1dca0:	ebffade9 	bl	57e0944c <printf>
		return -1;
57e1dca4:	e3e00000 	mvn	r0, #0
57e1dca8:	ea000165 	b	57e1e244 <submit_common_msg+0x64c>
#if 0
	mdelay(10);
	/* ohci_dump_status(&gohci); */
#endif

	timeout = USB_TIMEOUT_MS(pipe);
57e1dcac:	e1a04f24 	lsr	r4, r4, #30
57e1dcb0:	e59f35a8 	ldr	r3, [pc, #1448]	; 57e1e260 <submit_common_msg+0x668>
57e1dcb4:	e3540003 	cmp	r4, #3
57e1dcb8:	13a03ffa 	movne	r3, #1000	; 0x3e8
57e1dcbc:	e58d4020 	str	r4, [sp, #32]
57e1dcc0:	e58d301c 	str	r3, [sp, #28]
/* scan the periodic table to find and unlink this ED */
static void periodic_unlink(struct ohci *ohci, volatile struct ed *ed,
			    unsigned index, unsigned period)
{
	for (; index < NUM_INTS; index += period) {
		__u32	*ed_p = &ohci->hcca->int_table [index];
57e1dcc4:	e58db014 	str	fp, [sp, #20]
	ohci_t *ohci = &gohci;
	struct ohci_regs *regs = ohci->regs;
	int ints;
	int stat = -1;

	if ((ohci->hcca->done_head != 0) &&
57e1dcc8:	e5953000 	ldr	r3, [r5]
/* an interrupt happens */

static int hc_interrupt(void)
{
	ohci_t *ohci = &gohci;
	struct ohci_regs *regs = ohci->regs;
57e1dccc:	e5959014 	ldr	r9, [r5, #20]
	int ints;
	int stat = -1;

	if ((ohci->hcca->done_head != 0) &&
57e1dcd0:	e5933084 	ldr	r3, [r3, #132]	; 0x84
57e1dcd4:	e3530000 	cmp	r3, #0
57e1dcd8:	0a000002 	beq	57e1dce8 <submit_common_msg+0xf0>
57e1dcdc:	e3130001 	tst	r3, #1
				!(m32_swap(ohci->hcca->done_head) & 0x01)) {
		ints =  OHCI_INTR_WDH;
57e1dce0:	03a0b002 	moveq	fp, #2
	ohci_t *ohci = &gohci;
	struct ohci_regs *regs = ohci->regs;
	int ints;
	int stat = -1;

	if ((ohci->hcca->done_head != 0) &&
57e1dce4:	0a00000e 	beq	57e1dd24 <submit_common_msg+0x12c>
				!(m32_swap(ohci->hcca->done_head) & 0x01)) {
		ints =  OHCI_INTR_WDH;
	} else {
		ints = ohci_readl(&regs->intrstatus);
57e1dce8:	e599300c 	ldr	r3, [r9, #12]
		if (ints == ~(u32)0) {
57e1dcec:	e3730001 	cmn	r3, #1
57e1dcf0:	1a000008 	bne	57e1dd18 <submit_common_msg+0x120>
			ohci->disabled++;
57e1dcf4:	e59f3558 	ldr	r3, [pc, #1368]	; 57e1e254 <submit_common_msg+0x65c>
			err("%s device removed!", ohci->slot_name);
57e1dcf8:	e59f0564 	ldr	r0, [pc, #1380]	; 57e1e264 <submit_common_msg+0x66c>
				!(m32_swap(ohci->hcca->done_head) & 0x01)) {
		ints =  OHCI_INTR_WDH;
	} else {
		ints = ohci_readl(&regs->intrstatus);
		if (ints == ~(u32)0) {
			ohci->disabled++;
57e1dcfc:	e5932008 	ldr	r2, [r3, #8]
			err("%s device removed!", ohci->slot_name);
57e1dd00:	e5931144 	ldr	r1, [r3, #324]	; 0x144
				!(m32_swap(ohci->hcca->done_head) & 0x01)) {
		ints =  OHCI_INTR_WDH;
	} else {
		ints = ohci_readl(&regs->intrstatus);
		if (ints == ~(u32)0) {
			ohci->disabled++;
57e1dd04:	e2822001 	add	r2, r2, #1
57e1dd08:	e5832008 	str	r2, [r3, #8]
57e1dd0c:	e59db014 	ldr	fp, [sp, #20]
			err("%s device removed!", ohci->slot_name);
57e1dd10:	ebffadcd 	bl	57e0944c <printf>
57e1dd14:	ea00014c 	b	57e1e24c <submit_common_msg+0x654>
			return -1;
		} else {
			ints &= ohci_readl(&regs->intrenable);
57e1dd18:	e599b010 	ldr	fp, [r9, #16]
			if (ints == 0) {
57e1dd1c:	e01bb003 	ands	fp, fp, r3
57e1dd20:	0a000126 	beq	57e1e1c0 <submit_common_msg+0x5c8>

	/* dbg("Interrupt: %x frame: %x", ints,
					le16_to_cpu(ohci->hcca->frame_no)); */

	if (ints & OHCI_INTR_RHSC)
		stat = 0xff;
57e1dd24:	e31b0040 	tst	fp, #64	; 0x40
57e1dd28:	03e07000 	mvneq	r7, #0
57e1dd2c:	13a070ff 	movne	r7, #255	; 0xff

	if (ints & OHCI_INTR_UE) {
57e1dd30:	e21ba010 	ands	sl, fp, #16
57e1dd34:	0a00000b 	beq	57e1dd68 <submit_common_msg+0x170>
		ohci->disabled++;
57e1dd38:	e59f3514 	ldr	r3, [pc, #1300]	; 57e1e254 <submit_common_msg+0x65c>
		err("OHCI Unrecoverable Error, controller usb-%s disabled",
57e1dd3c:	e59f0524 	ldr	r0, [pc, #1316]	; 57e1e268 <submit_common_msg+0x670>

	if (ints & OHCI_INTR_RHSC)
		stat = 0xff;

	if (ints & OHCI_INTR_UE) {
		ohci->disabled++;
57e1dd40:	e5932008 	ldr	r2, [r3, #8]
		err("OHCI Unrecoverable Error, controller usb-%s disabled",
57e1dd44:	e5931144 	ldr	r1, [r3, #324]	; 0x144

	if (ints & OHCI_INTR_RHSC)
		stat = 0xff;

	if (ints & OHCI_INTR_UE) {
		ohci->disabled++;
57e1dd48:	e2822001 	add	r2, r2, #1
57e1dd4c:	e5832008 	str	r2, [r3, #8]
57e1dd50:	e59db014 	ldr	fp, [sp, #20]
		err("OHCI Unrecoverable Error, controller usb-%s disabled",
57e1dd54:	ebffadbc 	bl	57e0944c <printf>
		/* e.g. due to PCI Master/Target Abort */

#ifdef	DEBUG
		ohci_dump(ohci, 1);
#else
		mdelay(1);
57e1dd58:	e3a00001 	mov	r0, #1
57e1dd5c:	eb001a01 	bl	57e24568 <mdelay>
#endif
		/* FIXME: be optimistic, hope that bug won't repeat often. */
		/* Make some non-interrupt context restart the controller. */
		/* Count and limit the retries though; either hardware or */
		/* software errors can go forever... */
		hc_reset(ohci);
57e1dd60:	ebfffdff 	bl	57e1d564 <hc_reset.clone.16>
57e1dd64:	ea000138 	b	57e1e24c <submit_common_msg+0x654>
		return -1;
	}

	if (ints & OHCI_INTR_WDH) {
57e1dd68:	e31b0002 	tst	fp, #2
57e1dd6c:	0a0000fc 	beq	57e1e164 <submit_common_msg+0x56c>
		mdelay(1);
57e1dd70:	e3a00001 	mov	r0, #1
57e1dd74:	eb0019fb 	bl	57e24568 <mdelay>
		ohci_writel(OHCI_INTR_WDH, &regs->intrdisable);
57e1dd78:	e3a03002 	mov	r3, #2
57e1dd7c:	e5893014 	str	r3, [r9, #20]
		(void)ohci_readl(&regs->intrdisable); /* flush */
57e1dd80:	e5993014 	ldr	r3, [r9, #20]
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
	return 0;
}
57e1dd84:	e5953000 	ldr	r3, [r5]
{
	__u32 td_list_hc;
	td_t *td_rev = NULL;
	td_t *td_list = NULL;

	td_list_hc = m32_swap(ohci->hcca->done_head) & 0xfffffff0;
57e1dd88:	e5937084 	ldr	r7, [r3, #132]	; 0x84
	ohci->hcca->done_head = 0;
57e1dd8c:	e583a084 	str	sl, [r3, #132]	; 0x84
{
	__u32 td_list_hc;
	td_t *td_rev = NULL;
	td_t *td_list = NULL;

	td_list_hc = m32_swap(ohci->hcca->done_head) & 0xfffffff0;
57e1dd90:	e3c7700f 	bic	r7, r7, #15
57e1dd94:	e1a03009 	mov	r3, r9
57e1dd98:	ea000028 	b	57e1de40 <submit_common_msg+0x248>
}

/*-------------------------------------------------------------------------*/
static void check_status(td_t *td_list)
{
	urb_priv_t *lurb_priv = td_list->ed->purb;
57e1dd9c:	e5974014 	ldr	r4, [r7, #20]
	int	   urb_len    = lurb_priv->length;
	__u32      *phwHeadP  = &td_list->ed->hwHeadP;
	int	   cc;

	cc = TD_CC_GET(m32_swap(td_list->hwINFO));
57e1dda0:	e5972000 	ldr	r2, [r7]
}

/*-------------------------------------------------------------------------*/
static void check_status(td_t *td_list)
{
	urb_priv_t *lurb_priv = td_list->ed->purb;
57e1dda4:	e5946024 	ldr	r6, [r4, #36]	; 0x24
	int	   urb_len    = lurb_priv->length;
	__u32      *phwHeadP  = &td_list->ed->hwHeadP;
	int	   cc;

	cc = TD_CC_GET(m32_swap(td_list->hwINFO));
	if (cc) {
57e1dda8:	e1b02e22 	lsrs	r2, r2, #28

	td_list_hc = m32_swap(ohci->hcca->done_head) & 0xfffffff0;
	ohci->hcca->done_head = 0;

	while (td_list_hc) {
		td_list = (td_t *)td_list_hc;
57e1ddac:	e1a0c007 	mov	ip, r7

/*-------------------------------------------------------------------------*/
static void check_status(td_t *td_list)
{
	urb_priv_t *lurb_priv = td_list->ed->purb;
	int	   urb_len    = lurb_priv->length;
57e1ddb0:	e1d690b4 	ldrh	r9, [r6, #4]
	__u32      *phwHeadP  = &td_list->ed->hwHeadP;
	int	   cc;

	cc = TD_CC_GET(m32_swap(td_list->hwINFO));
	if (cc) {
57e1ddb4:	0a00001d 	beq	57e1de30 <submit_common_msg+0x238>
		err(" USB-error: %s (%x)", cc_to_string[cc], cc);
57e1ddb8:	e59fe4ac 	ldr	lr, [pc, #1196]	; 57e1e26c <submit_common_msg+0x674>
57e1ddbc:	e59f04ac 	ldr	r0, [pc, #1196]	; 57e1e270 <submit_common_msg+0x678>
57e1ddc0:	e79e1102 	ldr	r1, [lr, r2, lsl #2]
57e1ddc4:	e58d300c 	str	r3, [sp, #12]
57e1ddc8:	e58d7010 	str	r7, [sp, #16]
57e1ddcc:	ebffad9e 	bl	57e0944c <printf>

		if (*phwHeadP & m32_swap(0x1)) {
57e1ddd0:	e5942008 	ldr	r2, [r4, #8]
57e1ddd4:	e59d300c 	ldr	r3, [sp, #12]
57e1ddd8:	e3120001 	tst	r2, #1
57e1dddc:	e59dc010 	ldr	ip, [sp, #16]
57e1dde0:	0a000012 	beq	57e1de30 <submit_common_msg+0x238>
			if (lurb_priv &&
			    ((td_list->index + 1) < urb_len)) {
57e1dde4:	e5d71013 	ldrb	r1, [r7, #19]
57e1dde8:	e2811001 	add	r1, r1, #1
	cc = TD_CC_GET(m32_swap(td_list->hwINFO));
	if (cc) {
		err(" USB-error: %s (%x)", cc_to_string[cc], cc);

		if (*phwHeadP & m32_swap(0x1)) {
			if (lurb_priv &&
57e1ddec:	e1510009 	cmp	r1, r9
						   (*phwHeadP & m32_swap(0x2));

				lurb_priv->td_cnt += urb_len -
						     td_list->index - 1;
			} else
				*phwHeadP &= m32_swap(0xfffffff2);
57e1ddf0:	a3c2200d 	bicge	r2, r2, #13
57e1ddf4:	a5842008 	strge	r2, [r4, #8]
	cc = TD_CC_GET(m32_swap(td_list->hwINFO));
	if (cc) {
		err(" USB-error: %s (%x)", cc_to_string[cc], cc);

		if (*phwHeadP & m32_swap(0x1)) {
			if (lurb_priv &&
57e1ddf8:	aa00000c 	bge	57e1de30 <submit_common_msg+0x238>
			    ((td_list->index + 1) < urb_len)) {
				*phwHeadP =
					(lurb_priv->td[urb_len - 1]->hwNextTD &\
57e1ddfc:	e2891009 	add	r1, r9, #9
57e1de00:	e7961101 	ldr	r1, [r6, r1, lsl #2]
							m32_swap(0xfffffff0)) |
						   (*phwHeadP & m32_swap(0x2));
57e1de04:	e2022002 	and	r2, r2, #2

		if (*phwHeadP & m32_swap(0x1)) {
			if (lurb_priv &&
			    ((td_list->index + 1) < urb_len)) {
				*phwHeadP =
					(lurb_priv->td[urb_len - 1]->hwNextTD &\
57e1de08:	e5911008 	ldr	r1, [r1, #8]
57e1de0c:	e3c1100f 	bic	r1, r1, #15
							m32_swap(0xfffffff0)) |
57e1de10:	e1822001 	orr	r2, r2, r1
		err(" USB-error: %s (%x)", cc_to_string[cc], cc);

		if (*phwHeadP & m32_swap(0x1)) {
			if (lurb_priv &&
			    ((td_list->index + 1) < urb_len)) {
				*phwHeadP =
57e1de14:	e5842008 	str	r2, [r4, #8]
					(lurb_priv->td[urb_len - 1]->hwNextTD &\
							m32_swap(0xfffffff0)) |
						   (*phwHeadP & m32_swap(0x2));

				lurb_priv->td_cnt += urb_len -
57e1de18:	e1d620b6 	ldrh	r2, [r6, #6]
57e1de1c:	e0899002 	add	r9, r9, r2
57e1de20:	e5d72013 	ldrb	r2, [r7, #19]
57e1de24:	e2499001 	sub	r9, r9, #1
57e1de28:	e0622009 	rsb	r2, r2, r9
57e1de2c:	e1c620b6 	strh	r2, [r6, #6]
	ohci->hcca->done_head = 0;

	while (td_list_hc) {
		td_list = (td_t *)td_list_hc;
		check_status(td_list);
		td_list->next_dl_td = td_rev;
57e1de30:	e587a018 	str	sl, [r7, #24]
		td_rev = td_list;
		td_list_hc = m32_swap(td_list->hwNextTD) & 0xfffffff0;
57e1de34:	e5977008 	ldr	r7, [r7, #8]
57e1de38:	e1a0a00c 	mov	sl, ip
57e1de3c:	e3c7700f 	bic	r7, r7, #15
	td_t *td_list = NULL;

	td_list_hc = m32_swap(ohci->hcca->done_head) & 0xfffffff0;
	ohci->hcca->done_head = 0;

	while (td_list_hc) {
57e1de40:	e3570000 	cmp	r7, #0
57e1de44:	1affffd4 	bne	57e1dd9c <submit_common_msg+0x1a4>
57e1de48:	e1a09003 	mov	r9, r3
57e1de4c:	ea0000be 	b	57e1e14c <submit_common_msg+0x554>
	urb_priv_t *lurb_priv;
	__u32 tdINFO, edHeadP, edTailP;

	tdINFO = m32_swap(td_list->hwINFO);

	ed = td_list->ed;
57e1de50:	e5934014 	ldr	r4, [r3, #20]
{
	int stat = 0;
	td_t	*td_list = dl_reverse_done_list(ohci);

	while (td_list) {
		td_t	*td_next = td_list->next_dl_td;
57e1de54:	e593a018 	ldr	sl, [r3, #24]
	__u32 tdINFO, edHeadP, edTailP;

	tdINFO = m32_swap(td_list->hwINFO);

	ed = td_list->ed;
	lurb_priv = ed->purb;
57e1de58:	e5946024 	ldr	r6, [r4, #36]	; 0x24
	int stat = 0;
	/* urb_t *urb; */
	urb_priv_t *lurb_priv;
	__u32 tdINFO, edHeadP, edTailP;

	tdINFO = m32_swap(td_list->hwINFO);
57e1de5c:	e5937000 	ldr	r7, [r3]
	urb_priv_t *lurb_priv = td->ed->purb;

	tdBE   = m32_swap(td->hwBE);
	tdCBP  = m32_swap(td->hwCBP);

	if (!(usb_pipecontrol(lurb_priv->pipe) &&
57e1de60:	e5960010 	ldr	r0, [r6, #16]
static void dl_transfer_length(td_t *td)
{
	__u32 tdBE, tdCBP;
	urb_priv_t *lurb_priv = td->ed->purb;

	tdBE   = m32_swap(td->hwBE);
57e1de64:	e593100c 	ldr	r1, [r3, #12]
	tdCBP  = m32_swap(td->hwCBP);

	if (!(usb_pipecontrol(lurb_priv->pipe) &&
57e1de68:	e1a00f20 	lsr	r0, r0, #30
57e1de6c:	e3500002 	cmp	r0, #2
{
	__u32 tdBE, tdCBP;
	urb_priv_t *lurb_priv = td->ed->purb;

	tdBE   = m32_swap(td->hwBE);
	tdCBP  = m32_swap(td->hwCBP);
57e1de70:	e5932004 	ldr	r2, [r3, #4]

	if (!(usb_pipecontrol(lurb_priv->pipe) &&
57e1de74:	1a000006 	bne	57e1de94 <submit_common_msg+0x29c>
	    ((td->index == 0) || (td->index == lurb_priv->length - 1)))) {
57e1de78:	e5d30013 	ldrb	r0, [r3, #19]
	urb_priv_t *lurb_priv = td->ed->purb;

	tdBE   = m32_swap(td->hwBE);
	tdCBP  = m32_swap(td->hwCBP);

	if (!(usb_pipecontrol(lurb_priv->pipe) &&
57e1de7c:	e3500000 	cmp	r0, #0
57e1de80:	0a00000f 	beq	57e1dec4 <submit_common_msg+0x2cc>
	    ((td->index == 0) || (td->index == lurb_priv->length - 1)))) {
57e1de84:	e1d6c0b4 	ldrh	ip, [r6, #4]
57e1de88:	e24cc001 	sub	ip, ip, #1
57e1de8c:	e150000c 	cmp	r0, ip
57e1de90:	0a00000b 	beq	57e1dec4 <submit_common_msg+0x2cc>
		if (tdBE != 0) {
57e1de94:	e3510000 	cmp	r1, #0
57e1de98:	0a000009 	beq	57e1dec4 <submit_common_msg+0x2cc>
			if (td->hwCBP == 0)
57e1de9c:	e3520000 	cmp	r2, #0
57e1dea0:	e5960020 	ldr	r0, [r6, #32]
57e1dea4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
				lurb_priv->actual_length += tdBE - td->data + 1;
57e1dea8:	02811001 	addeq	r1, r1, #1
57e1deac:	00811000 	addeq	r1, r1, r0
			else
				lurb_priv->actual_length += tdCBP - td->data;
57e1deb0:	10630000 	rsbne	r0, r3, r0

	if (!(usb_pipecontrol(lurb_priv->pipe) &&
	    ((td->index == 0) || (td->index == lurb_priv->length - 1)))) {
		if (tdBE != 0) {
			if (td->hwCBP == 0)
				lurb_priv->actual_length += tdBE - td->data + 1;
57e1deb4:	00631001 	rsbeq	r1, r3, r1
			else
				lurb_priv->actual_length += tdCBP - td->data;
57e1deb8:	10800002 	addne	r0, r0, r2

	if (!(usb_pipecontrol(lurb_priv->pipe) &&
	    ((td->index == 0) || (td->index == lurb_priv->length - 1)))) {
		if (tdBE != 0) {
			if (td->hwCBP == 0)
				lurb_priv->actual_length += tdBE - td->data + 1;
57e1debc:	05861020 	streq	r1, [r6, #32]
			else
				lurb_priv->actual_length += tdCBP - td->data;
57e1dec0:	15860020 	strne	r0, [r6, #32]
	ed = td_list->ed;
	lurb_priv = ed->purb;

	dl_transfer_length(td_list);

	lurb_priv->td_cnt++;
57e1dec4:	e1d630b6 	ldrh	r3, [r6, #6]

	/* error code of transfer */
	cc = TD_CC_GET(tdINFO);
	if (cc) {
57e1dec8:	e1b07e27 	lsrs	r7, r7, #28
	ed = td_list->ed;
	lurb_priv = ed->purb;

	dl_transfer_length(td_list);

	lurb_priv->td_cnt++;
57e1decc:	e2833001 	add	r3, r3, #1
57e1ded0:	e1c630b6 	strh	r3, [r6, #6]

	/* error code of transfer */
	cc = TD_CC_GET(tdINFO);
	if (cc) {
57e1ded4:	0a000007 	beq	57e1def8 <submit_common_msg+0x300>
		err("USB-error: %s (%x)", cc_to_string[cc], cc);
57e1ded8:	e59f238c 	ldr	r2, [pc, #908]	; 57e1e26c <submit_common_msg+0x674>
57e1dedc:	e59f0390 	ldr	r0, [pc, #912]	; 57e1e274 <submit_common_msg+0x67c>
57e1dee0:	e7921107 	ldr	r1, [r2, r7, lsl #2]
57e1dee4:	e1a02007 	mov	r2, r7
57e1dee8:	ebffad57 	bl	57e0944c <printf>
		stat = cc_to_error[cc];
57e1deec:	e59f3378 	ldr	r3, [pc, #888]	; 57e1e26c <submit_common_msg+0x674>
57e1def0:	e0837107 	add	r7, r3, r7, lsl #2
57e1def4:	e5977040 	ldr	r7, [r7, #64]	; 0x40
	}

	/* see if this done list makes for all TD's of current URB,
	* and mark the URB finished if so */
	if (lurb_priv->td_cnt == lurb_priv->length)
57e1def8:	e1d620b6 	ldrh	r2, [r6, #6]
57e1defc:	e1d630b4 	ldrh	r3, [r6, #4]
57e1df00:	e1520003 	cmp	r2, r3
57e1df04:	1a000027 	bne	57e1dfa8 <submit_common_msg+0x3b0>
		finish_urb(ohci, lurb_priv, ed->state);
57e1df08:	e5d43018 	ldrb	r3, [r4, #24]
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

static void finish_urb(ohci_t *ohci, urb_priv_t *urb, int status)
{
	if ((status & (ED_OPER | ED_UNLINK)) && (urb->state != URB_DEL))
57e1df0c:	e3130003 	tst	r3, #3
57e1df10:	0a000024 	beq	57e1dfa8 <submit_common_msg+0x3b0>
57e1df14:	e596300c 	ldr	r3, [r6, #12]
57e1df18:	e3530001 	cmp	r3, #1
57e1df1c:	0a000021 	beq	57e1dfa8 <submit_common_msg+0x3b0>

static inline int sohci_return_job(struct ohci *hc, urb_priv_t *urb)
{
	struct ohci_regs *regs = hc->regs;

	switch (usb_pipetype(urb->pipe)) {
57e1df20:	e5962010 	ldr	r2, [r6, #16]
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
	return 0;
}
57e1df24:	e5953014 	ldr	r3, [r5, #20]

static inline int sohci_return_job(struct ohci *hc, urb_priv_t *urb)
{
	struct ohci_regs *regs = hc->regs;

	switch (usb_pipetype(urb->pipe)) {
57e1df28:	e1a02f22 	lsr	r2, r2, #30
57e1df2c:	e3520001 	cmp	r2, #1
57e1df30:	0a000002 	beq	57e1df40 <submit_common_msg+0x348>
		break;
	case PIPE_CONTROL:
	case PIPE_BULK:
		break;
	default:
		return 0;
57e1df34:	33a03000 	movcc	r3, #0

static inline int sohci_return_job(struct ohci *hc, urb_priv_t *urb)
{
	struct ohci_regs *regs = hc->regs;

	switch (usb_pipetype(urb->pipe)) {
57e1df38:	3a000019 	bcc	57e1dfa4 <submit_common_msg+0x3ac>
57e1df3c:	ea000017 	b	57e1dfa0 <submit_common_msg+0x3a8>
	case PIPE_INTERRUPT:
		/* implicitly requeued */
		if (urb->dev->irq_handle &&
57e1df40:	e5960008 	ldr	r0, [r6, #8]
57e1df44:	e5902604 	ldr	r2, [r0, #1540]	; 0x604
57e1df48:	e3520000 	cmp	r2, #0
57e1df4c:	0a00000c 	beq	57e1df84 <submit_common_msg+0x38c>
				(urb->dev->irq_act_len = urb->actual_length)) {
57e1df50:	e5961020 	ldr	r1, [r6, #32]
	struct ohci_regs *regs = hc->regs;

	switch (usb_pipetype(urb->pipe)) {
	case PIPE_INTERRUPT:
		/* implicitly requeued */
		if (urb->dev->irq_handle &&
57e1df54:	e3510000 	cmp	r1, #0
				(urb->dev->irq_act_len = urb->actual_length)) {
57e1df58:	e580160c 	str	r1, [r0, #1548]	; 0x60c
	struct ohci_regs *regs = hc->regs;

	switch (usb_pipetype(urb->pipe)) {
	case PIPE_INTERRUPT:
		/* implicitly requeued */
		if (urb->dev->irq_handle &&
57e1df5c:	0a000008 	beq	57e1df84 <submit_common_msg+0x38c>
				(urb->dev->irq_act_len = urb->actual_length)) {
			ohci_writel(OHCI_INTR_WDH, &regs->intrenable);
57e1df60:	e3a0e002 	mov	lr, #2
57e1df64:	e583e010 	str	lr, [r3, #16]
			ohci_readl(&regs->intrenable); /* PCI posting flush */
57e1df68:	e5931010 	ldr	r1, [r3, #16]
			urb->dev->irq_handle(urb->dev);
57e1df6c:	e58d300c 	str	r3, [sp, #12]
57e1df70:	e12fff32 	blx	r2
			ohci_writel(OHCI_INTR_WDH, &regs->intrdisable);
57e1df74:	e59d300c 	ldr	r3, [sp, #12]
57e1df78:	e3a01002 	mov	r1, #2
57e1df7c:	e5831014 	str	r1, [r3, #20]
			ohci_readl(&regs->intrdisable); /* PCI posting flush */
57e1df80:	e5933014 	ldr	r3, [r3, #20]
		}
		urb->actual_length = 0;
57e1df84:	e3a02000 	mov	r2, #0
57e1df88:	e5862020 	str	r2, [r6, #32]
		td_submit_job(
57e1df8c:	e88d0044 	stm	sp, {r2, r6}
57e1df90:	e5960008 	ldr	r0, [r6, #8]
57e1df94:	e2861010 	add	r1, r6, #16
57e1df98:	e891000e 	ldm	r1, {r1, r2, r3}
57e1df9c:	ebfffcee 	bl	57e1d35c <td_submit_job.clone.7>
	case PIPE_BULK:
		break;
	default:
		return 0;
	}
	return 1;
57e1dfa0:	e3a03001 	mov	r3, #1
/*-------------------------------------------------------------------------*/

static void finish_urb(ohci_t *ohci, urb_priv_t *urb, int status)
{
	if ((status & (ED_OPER | ED_UNLINK)) && (urb->state != URB_DEL))
		urb->finished = sohci_return_job(ohci, urb);
57e1dfa4:	e5863024 	str	r3, [r6, #36]	; 0x24
		finish_urb(ohci, lurb_priv, ed->state);

	dbg("dl_done_list: processing TD %x, len %x\n",
		lurb_priv->td_cnt, lurb_priv->length);

	if (ed->state != ED_NEW && (!usb_pipeint(lurb_priv->pipe))) {
57e1dfa8:	e5d43018 	ldrb	r3, [r4, #24]
57e1dfac:	e3530000 	cmp	r3, #0
57e1dfb0:	0a000065 	beq	57e1e14c <submit_common_msg+0x554>
57e1dfb4:	e5962010 	ldr	r2, [r6, #16]
57e1dfb8:	e1a02f22 	lsr	r2, r2, #30
57e1dfbc:	e3520001 	cmp	r2, #1
57e1dfc0:	0a000061 	beq	57e1e14c <submit_common_msg+0x554>
		edHeadP = m32_swap(ed->hwHeadP) & 0xfffffff0;
57e1dfc4:	e5941008 	ldr	r1, [r4, #8]
		edTailP = m32_swap(ed->hwTailP);

		/* unlink eds if they are not busy */
		if ((edHeadP == edTailP) && (ed->state == ED_OPER))
57e1dfc8:	e5942004 	ldr	r2, [r4, #4]

	dbg("dl_done_list: processing TD %x, len %x\n",
		lurb_priv->td_cnt, lurb_priv->length);

	if (ed->state != ED_NEW && (!usb_pipeint(lurb_priv->pipe))) {
		edHeadP = m32_swap(ed->hwHeadP) & 0xfffffff0;
57e1dfcc:	e3c1100f 	bic	r1, r1, #15
		edTailP = m32_swap(ed->hwTailP);

		/* unlink eds if they are not busy */
		if ((edHeadP == edTailP) && (ed->state == ED_OPER))
57e1dfd0:	e1510002 	cmp	r1, r2
57e1dfd4:	1a00005c 	bne	57e1e14c <submit_common_msg+0x554>
57e1dfd8:	e3530002 	cmp	r3, #2
57e1dfdc:	1a00005a 	bne	57e1e14c <submit_common_msg+0x554>
static int ep_unlink(ohci_t *ohci, ed_t *edi)
{
	volatile ed_t *ed = edi;
	int i;

	ed->hwINFO |= m32_swap(OHCI_ED_SKIP);
57e1dfe0:	e5943000 	ldr	r3, [r4]
57e1dfe4:	e3833901 	orr	r3, r3, #16384	; 0x4000
57e1dfe8:	e5843000 	str	r3, [r4]

	switch (ed->type) {
57e1dfec:	e5d43019 	ldrb	r3, [r4, #25]
57e1dff0:	e20330ff 	and	r3, r3, #255	; 0xff
57e1dff4:	e3530002 	cmp	r3, #2
57e1dff8:	0a000004 	beq	57e1e010 <submit_common_msg+0x418>
57e1dffc:	e3530003 	cmp	r3, #3
57e1e000:	0a000018 	beq	57e1e068 <submit_common_msg+0x470>
57e1e004:	e3530001 	cmp	r3, #1
57e1e008:	1a00004d 	bne	57e1e144 <submit_common_msg+0x54c>
57e1e00c:	ea00002e 	b	57e1e0cc <submit_common_msg+0x4d4>
	case PIPE_CONTROL:
		if (ed->ed_prev == NULL) {
57e1e010:	e5943010 	ldr	r3, [r4, #16]
57e1e014:	e3530000 	cmp	r3, #0
					    &ohci->regs->control);
			}
			ohci_writel(m32_swap(*((__u32 *)&ed->hwNextED)),
				&ohci->regs->ed_controlhead);
		} else {
			ed->ed_prev->hwNextED = ed->hwNextED;
57e1e018:	15943010 	ldrne	r3, [r4, #16]
57e1e01c:	1594200c 	ldrne	r2, [r4, #12]
57e1e020:	1583200c 	strne	r2, [r3, #12]

	ed->hwINFO |= m32_swap(OHCI_ED_SKIP);

	switch (ed->type) {
	case PIPE_CONTROL:
		if (ed->ed_prev == NULL) {
57e1e024:	1a000009 	bne	57e1e050 <submit_common_msg+0x458>
			if (!ed->hwNextED) {
57e1e028:	e594300c 	ldr	r3, [r4, #12]
57e1e02c:	e3530000 	cmp	r3, #0
				ohci->hc_control &= ~OHCI_CTRL_CLE;
57e1e030:	059530ac 	ldreq	r3, [r5, #172]	; 0xac
				ohci_writel(ohci->hc_control,
57e1e034:	05952014 	ldreq	r2, [r5, #20]

	switch (ed->type) {
	case PIPE_CONTROL:
		if (ed->ed_prev == NULL) {
			if (!ed->hwNextED) {
				ohci->hc_control &= ~OHCI_CTRL_CLE;
57e1e038:	03c33010 	biceq	r3, r3, #16
57e1e03c:	058530ac 	streq	r3, [r5, #172]	; 0xac
				ohci_writel(ohci->hc_control,
57e1e040:	05823004 	streq	r3, [r2, #4]
					    &ohci->regs->control);
			}
			ohci_writel(m32_swap(*((__u32 *)&ed->hwNextED)),
57e1e044:	e594200c 	ldr	r2, [r4, #12]
57e1e048:	e5953014 	ldr	r3, [r5, #20]
57e1e04c:	e5832020 	str	r2, [r3, #32]
				&ohci->regs->ed_controlhead);
		} else {
			ed->ed_prev->hwNextED = ed->hwNextED;
		}
		if (ohci->ed_controltail == ed) {
57e1e050:	e59530a4 	ldr	r3, [r5, #164]	; 0xa4
57e1e054:	e1530004 	cmp	r3, r4
			ohci->ed_controltail = ed->ed_prev;
57e1e058:	05943010 	ldreq	r3, [r4, #16]
57e1e05c:	058530a4 	streq	r3, [r5, #164]	; 0xa4
			ohci_writel(m32_swap(*((__u32 *)&ed->hwNextED)),
				&ohci->regs->ed_controlhead);
		} else {
			ed->ed_prev->hwNextED = ed->hwNextED;
		}
		if (ohci->ed_controltail == ed) {
57e1e060:	1a000015 	bne	57e1e0bc <submit_common_msg+0x4c4>
57e1e064:	ea000036 	b	57e1e144 <submit_common_msg+0x54c>
			    *((__u32 *)&ed->hwNextED)))->ed_prev = ed->ed_prev;
		}
		break;

	case PIPE_BULK:
		if (ed->ed_prev == NULL) {
57e1e068:	e5943010 	ldr	r3, [r4, #16]
57e1e06c:	e3530000 	cmp	r3, #0
					    &ohci->regs->control);
			}
			ohci_writel(m32_swap(*((__u32 *)&ed->hwNextED)),
			       &ohci->regs->ed_bulkhead);
		} else {
			ed->ed_prev->hwNextED = ed->hwNextED;
57e1e070:	15943010 	ldrne	r3, [r4, #16]
57e1e074:	1594200c 	ldrne	r2, [r4, #12]
57e1e078:	1583200c 	strne	r2, [r3, #12]
			    *((__u32 *)&ed->hwNextED)))->ed_prev = ed->ed_prev;
		}
		break;

	case PIPE_BULK:
		if (ed->ed_prev == NULL) {
57e1e07c:	1a000009 	bne	57e1e0a8 <submit_common_msg+0x4b0>
			if (!ed->hwNextED) {
57e1e080:	e594300c 	ldr	r3, [r4, #12]
57e1e084:	e3530000 	cmp	r3, #0
				ohci->hc_control &= ~OHCI_CTRL_BLE;
57e1e088:	059530ac 	ldreq	r3, [r5, #172]	; 0xac
				ohci_writel(ohci->hc_control,
57e1e08c:	05952014 	ldreq	r2, [r5, #20]
		break;

	case PIPE_BULK:
		if (ed->ed_prev == NULL) {
			if (!ed->hwNextED) {
				ohci->hc_control &= ~OHCI_CTRL_BLE;
57e1e090:	03c33020 	biceq	r3, r3, #32
57e1e094:	058530ac 	streq	r3, [r5, #172]	; 0xac
				ohci_writel(ohci->hc_control,
57e1e098:	05823004 	streq	r3, [r2, #4]
					    &ohci->regs->control);
			}
			ohci_writel(m32_swap(*((__u32 *)&ed->hwNextED)),
57e1e09c:	e594200c 	ldr	r2, [r4, #12]
57e1e0a0:	e5953014 	ldr	r3, [r5, #20]
57e1e0a4:	e5832028 	str	r2, [r3, #40]	; 0x28
			       &ohci->regs->ed_bulkhead);
		} else {
			ed->ed_prev->hwNextED = ed->hwNextED;
		}
		if (ohci->ed_bulktail == ed) {
57e1e0a8:	e59530a0 	ldr	r3, [r5, #160]	; 0xa0
57e1e0ac:	e1530004 	cmp	r3, r4
			ohci->ed_bulktail = ed->ed_prev;
57e1e0b0:	05943010 	ldreq	r3, [r4, #16]
57e1e0b4:	058530a0 	streq	r3, [r5, #160]	; 0xa0
			ohci_writel(m32_swap(*((__u32 *)&ed->hwNextED)),
			       &ohci->regs->ed_bulkhead);
		} else {
			ed->ed_prev->hwNextED = ed->hwNextED;
		}
		if (ohci->ed_bulktail == ed) {
57e1e0b8:	0a000021 	beq	57e1e144 <submit_common_msg+0x54c>
			ohci->ed_bulktail = ed->ed_prev;
		} else {
			((ed_t *)m32_swap(
57e1e0bc:	e594300c 	ldr	r3, [r4, #12]
			     *((__u32 *)&ed->hwNextED)))->ed_prev = ed->ed_prev;
57e1e0c0:	e5942010 	ldr	r2, [r4, #16]
57e1e0c4:	e5832010 	str	r2, [r3, #16]
57e1e0c8:	ea00001d 	b	57e1e144 <submit_common_msg+0x54c>
/* scan the periodic table to find and unlink this ED */
static void periodic_unlink(struct ohci *ohci, volatile struct ed *ed,
			    unsigned index, unsigned period)
{
	for (; index < NUM_INTS; index += period) {
		__u32	*ed_p = &ohci->hcca->int_table [index];
57e1e0cc:	e5950000 	ldr	r0, [r5]
57e1e0d0:	e3a03000 	mov	r3, #0
57e1e0d4:	e1a01000 	mov	r1, r0
57e1e0d8:	e0802103 	add	r2, r0, r3, lsl #2
57e1e0dc:	e491c004 	ldr	ip, [r1], #4
57e1e0e0:	ea000006 	b	57e1e100 <submit_common_msg+0x508>

		/* ED might have been unlinked through another path */
		while (*ed_p != 0) {
			if (((struct ed *)
57e1e0e4:	e1520004 	cmp	r2, r4
					m32_swap((unsigned long)ed_p)) == ed) {
				*ed_p = ed->hwNextED;
57e1e0e8:	0594200c 	ldreq	r2, [r4, #12]
57e1e0ec:	05842000 	streq	r2, [r4]
57e1e0f0:	0a000004 	beq	57e1e108 <submit_common_msg+0x510>
				break;
			}
			ed_p = &(((struct ed *)
57e1e0f4:	e1a0c002 	mov	ip, r2
57e1e0f8:	e59cc00c 	ldr	ip, [ip, #12]
57e1e0fc:	e282200c 	add	r2, r2, #12
{
	for (; index < NUM_INTS; index += period) {
		__u32	*ed_p = &ohci->hcca->int_table [index];

		/* ED might have been unlinked through another path */
		while (*ed_p != 0) {
57e1e100:	e35c0000 	cmp	ip, #0
57e1e104:	1afffff6 	bne	57e1e0e4 <submit_common_msg+0x4ec>

/* scan the periodic table to find and unlink this ED */
static void periodic_unlink(struct ohci *ohci, volatile struct ed *ed,
			    unsigned index, unsigned period)
{
	for (; index < NUM_INTS; index += period) {
57e1e108:	e2833001 	add	r3, r3, #1
57e1e10c:	e3530020 	cmp	r3, #32
57e1e110:	1afffff0 	bne	57e1e0d8 <submit_common_msg+0x4e0>
		}
		break;

	case PIPE_INTERRUPT:
		periodic_unlink(ohci, ed, 0, 1);
		for (i = ed->int_branch; i < 32; i += ed->int_interval)
57e1e114:	e5d43015 	ldrb	r3, [r4, #21]
57e1e118:	e20330ff 	and	r3, r3, #255	; 0xff
57e1e11c:	ea000006 	b	57e1e13c <submit_common_msg+0x544>
		    ohci->ohci_int_load[i] -= ed->int_load;
57e1e120:	e2832006 	add	r2, r3, #6
57e1e124:	e5d41016 	ldrb	r1, [r4, #22]
57e1e128:	e7950102 	ldr	r0, [r5, r2, lsl #2]
57e1e12c:	e0611000 	rsb	r1, r1, r0
57e1e130:	e7851102 	str	r1, [r5, r2, lsl #2]
		}
		break;

	case PIPE_INTERRUPT:
		periodic_unlink(ohci, ed, 0, 1);
		for (i = ed->int_branch; i < 32; i += ed->int_interval)
57e1e134:	e5d42017 	ldrb	r2, [r4, #23]
57e1e138:	e0833002 	add	r3, r3, r2
57e1e13c:	e353001f 	cmp	r3, #31
57e1e140:	dafffff6 	ble	57e1e120 <submit_common_msg+0x528>
		    ohci->ohci_int_load[i] -= ed->int_load;
		break;
	}
	ed->state = ED_UNLINK;
57e1e144:	e3a03001 	mov	r3, #1
57e1e148:	e5c43018 	strb	r3, [r4, #24]
static int dl_done_list(ohci_t *ohci)
{
	int stat = 0;
	td_t	*td_list = dl_reverse_done_list(ohci);

	while (td_list) {
57e1e14c:	e35a0000 	cmp	sl, #0
		td_t	*td_next = td_list->next_dl_td;
		stat = takeback_td(ohci, td_list);
		td_list = td_next;
57e1e150:	e1a0300a 	mov	r3, sl
static int dl_done_list(ohci_t *ohci)
{
	int stat = 0;
	td_t	*td_list = dl_reverse_done_list(ohci);

	while (td_list) {
57e1e154:	1affff3d 	bne	57e1de50 <submit_common_msg+0x258>
	if (ints & OHCI_INTR_WDH) {
		mdelay(1);
		ohci_writel(OHCI_INTR_WDH, &regs->intrdisable);
		(void)ohci_readl(&regs->intrdisable); /* flush */
		stat = dl_done_list(&gohci);
		ohci_writel(OHCI_INTR_WDH, &regs->intrenable);
57e1e158:	e28a3002 	add	r3, sl, #2
57e1e15c:	e5893010 	str	r3, [r9, #16]
		(void)ohci_readl(&regs->intrdisable); /* flush */
57e1e160:	e5993014 	ldr	r3, [r9, #20]
	}

	if (ints & OHCI_INTR_SO) {
57e1e164:	e31b0001 	tst	fp, #1
		dbg("USB Schedule overrun\n");
		ohci_writel(OHCI_INTR_SO, &regs->intrenable);
57e1e168:	13a03001 	movne	r3, #1
57e1e16c:	15893010 	strne	r3, [r9, #16]
		stat = -1;
57e1e170:	13e07000 	mvnne	r7, #0
	}

	/* FIXME:  this assumes SOF (1/ms) interrupts don't get lost... */
	if (ints & OHCI_INTR_SF) {
57e1e174:	e31b0004 	tst	fp, #4
57e1e178:	0a00000b 	beq	57e1e1ac <submit_common_msg+0x5b4>
		unsigned int frame = m16_swap(ohci->hcca->frame_no) & 1;
57e1e17c:	e5953000 	ldr	r3, [r5]
		mdelay(1);
57e1e180:	e3a00001 	mov	r0, #1
		stat = -1;
	}

	/* FIXME:  this assumes SOF (1/ms) interrupts don't get lost... */
	if (ints & OHCI_INTR_SF) {
		unsigned int frame = m16_swap(ohci->hcca->frame_no) & 1;
57e1e184:	e1d348b0 	ldrh	r4, [r3, #128]	; 0x80
		mdelay(1);
57e1e188:	eb0018f6 	bl	57e24568 <mdelay>
		stat = -1;
	}

	/* FIXME:  this assumes SOF (1/ms) interrupts don't get lost... */
	if (ints & OHCI_INTR_SF) {
		unsigned int frame = m16_swap(ohci->hcca->frame_no) & 1;
57e1e18c:	e2044001 	and	r4, r4, #1
		mdelay(1);
		ohci_writel(OHCI_INTR_SF, &regs->intrdisable);
		if (ohci->ed_rm_list[frame] != NULL)
57e1e190:	e2844026 	add	r4, r4, #38	; 0x26
57e1e194:	e7952104 	ldr	r2, [r5, r4, lsl #2]

	/* FIXME:  this assumes SOF (1/ms) interrupts don't get lost... */
	if (ints & OHCI_INTR_SF) {
		unsigned int frame = m16_swap(ohci->hcca->frame_no) & 1;
		mdelay(1);
		ohci_writel(OHCI_INTR_SF, &regs->intrdisable);
57e1e198:	e3a03004 	mov	r3, #4
		if (ohci->ed_rm_list[frame] != NULL)
57e1e19c:	e3520000 	cmp	r2, #0

	/* FIXME:  this assumes SOF (1/ms) interrupts don't get lost... */
	if (ints & OHCI_INTR_SF) {
		unsigned int frame = m16_swap(ohci->hcca->frame_no) & 1;
		mdelay(1);
		ohci_writel(OHCI_INTR_SF, &regs->intrdisable);
57e1e1a0:	e5893014 	str	r3, [r9, #20]
		if (ohci->ed_rm_list[frame] != NULL)
			ohci_writel(OHCI_INTR_SF, &regs->intrenable);
		stat = 0xff;
57e1e1a4:	e3a070ff 	mov	r7, #255	; 0xff
	if (ints & OHCI_INTR_SF) {
		unsigned int frame = m16_swap(ohci->hcca->frame_no) & 1;
		mdelay(1);
		ohci_writel(OHCI_INTR_SF, &regs->intrdisable);
		if (ohci->ed_rm_list[frame] != NULL)
			ohci_writel(OHCI_INTR_SF, &regs->intrenable);
57e1e1a8:	15893010 	strne	r3, [r9, #16]

	/* wait for it to complete */
	for (;;) {
		/* check whether the controller is done */
		stat = hc_interrupt();
		if (stat < 0) {
57e1e1ac:	e3570000 	cmp	r7, #0
		if (ohci->ed_rm_list[frame] != NULL)
			ohci_writel(OHCI_INTR_SF, &regs->intrenable);
		stat = 0xff;
	}

	ohci_writel(ints, &regs->intrstatus);
57e1e1b0:	e589b00c 	str	fp, [r9, #12]

	/* wait for it to complete */
	for (;;) {
		/* check whether the controller is done */
		stat = hc_interrupt();
		if (stat < 0) {
57e1e1b4:	aa000002 	bge	57e1e1c4 <submit_common_msg+0x5cc>
57e1e1b8:	e59db014 	ldr	fp, [sp, #20]
57e1e1bc:	ea000022 	b	57e1e24c <submit_common_msg+0x654>
			return -1;
		} else {
			ints &= ohci_readl(&regs->intrenable);
			if (ints == 0) {
				dbg("hc_interrupt: returning..\n");
				return 0xff;
57e1e1c0:	e3a070ff 	mov	r7, #255	; 0xff
		 * meaning that all TD's to/from device got actually
		 * transferred and processed. If the current URB is not
		 * finished we need to re-iterate this loop so as
		 * hc_interrupt() gets called again as there needs to be some
		 * more TD's to process still */
		if ((stat >= 0) && (stat != 0xff) && (urb->finished)) {
57e1e1c4:	e35700ff 	cmp	r7, #255	; 0xff
57e1e1c8:	0a000003 	beq	57e1e1dc <submit_common_msg+0x5e4>
57e1e1cc:	e59de014 	ldr	lr, [sp, #20]
57e1e1d0:	e59e3024 	ldr	r3, [lr, #36]	; 0x24
57e1e1d4:	e3530000 	cmp	r3, #0
57e1e1d8:	1a00000c 	bne	57e1e210 <submit_common_msg+0x618>
			/* 0xff is returned for an SF-interrupt */
			break;
		}

		if (--timeout) {
57e1e1dc:	e59d101c 	ldr	r1, [sp, #28]
57e1e1e0:	e2511001 	subs	r1, r1, #1
57e1e1e4:	e58d101c 	str	r1, [sp, #28]
57e1e1e8:	0a000002 	beq	57e1e1f8 <submit_common_msg+0x600>
			mdelay(1);
57e1e1ec:	e3a00001 	mov	r0, #1
57e1e1f0:	eb0018dc 	bl	57e24568 <mdelay>
57e1e1f4:	eafffeb3 	b	57e1dcc8 <submit_common_msg+0xd0>
57e1e1f8:	e59db014 	ldr	fp, [sp, #20]
			if (!urb->finished)
				dbg("*");

		} else {
			err("CTL:TIMEOUT ");
57e1e1fc:	e59f0074 	ldr	r0, [pc, #116]	; 57e1e278 <submit_common_msg+0x680>
57e1e200:	ebffac91 	bl	57e0944c <printf>
			dbg("submit_common_msg: TO status %x\n", stat);
			urb->finished = 1;
57e1e204:	e3a03001 	mov	r3, #1
57e1e208:	e58b3024 	str	r3, [fp, #36]	; 0x24
57e1e20c:	ea00000e 	b	57e1e24c <submit_common_msg+0x654>
57e1e210:	e59db014 	ldr	fp, [sp, #20]
			stat = USB_ST_CRC_ERR;
			break;
		}
	}

	dev->status = stat;
57e1e214:	e59d2018 	ldr	r2, [sp, #24]
	dev->act_len = transfer_len;
57e1e218:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
			stat = USB_ST_CRC_ERR;
			break;
		}
	}

	dev->status = stat;
57e1e21c:	e5827614 	str	r7, [r2, #1556]	; 0x614
	dev->act_len = transfer_len;
57e1e220:	e5823618 	str	r3, [r2, #1560]	; 0x618

#ifdef DEBUG
	pkt_print(urb, dev, pipe, buffer, transfer_len,
		  setup, "RET(ctlr)", usb_pipein(pipe));
#else
	mdelay(1);
57e1e224:	e3a00001 	mov	r0, #1
57e1e228:	eb0018ce 	bl	57e24568 <mdelay>
#endif

	/* free TDs in urb_priv */
	if (!usb_pipeint(pipe))
57e1e22c:	e59d1020 	ldr	r1, [sp, #32]
57e1e230:	e3510001 	cmp	r1, #1
57e1e234:	0a000001 	beq	57e1e240 <submit_common_msg+0x648>
		urb_free_priv(urb);
57e1e238:	e1a0000b 	mov	r0, fp
57e1e23c:	ebfffc13 	bl	57e1d290 <urb_free_priv>
	return 0;
57e1e240:	e3a00000 	mov	r0, #0
}
57e1e244:	e28dd028 	add	sp, sp, #40	; 0x28
57e1e248:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	/* wait for it to complete */
	for (;;) {
		/* check whether the controller is done */
		stat = hc_interrupt();
		if (stat < 0) {
			stat = USB_ST_CRC_ERR;
57e1e24c:	e3a07020 	mov	r7, #32
57e1e250:	eaffffef 	b	57e1e214 <submit_common_msg+0x61c>
57e1e254:	57e47a00 	.word	0x57e47a00
57e1e258:	57e3473b 	.word	0x57e3473b
57e1e25c:	57e34778 	.word	0x57e34778
57e1e260:	00001388 	.word	0x00001388
57e1e264:	57e34798 	.word	0x57e34798
57e1e268:	57e347b3 	.word	0x57e347b3
57e1e26c:	57e2cd18 	.word	0x57e2cd18
57e1e270:	57e347f0 	.word	0x57e347f0
57e1e274:	57e3480c 	.word	0x57e3480c
57e1e278:	57e34827 	.word	0x57e34827

57e1e27c <submit_bulk_msg>:
}

/* submit routines called from usb.c */
int submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
		int transfer_len)
{
57e1e27c:	e92d4007 	push	{r0, r1, r2, lr}
	info("submit_bulk_msg");
	return submit_common_msg(dev, pipe, buffer, transfer_len, NULL, 0);
57e1e280:	e3a0c000 	mov	ip, #0
57e1e284:	e58dc000 	str	ip, [sp]
57e1e288:	e58dc004 	str	ip, [sp, #4]
57e1e28c:	ebfffe59 	bl	57e1dbf8 <submit_common_msg>
}
57e1e290:	e8bd800e 	pop	{r1, r2, r3, pc}

57e1e294 <submit_control_msg>:

int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
		int transfer_len, struct devrequest *setup)
{
57e1e294:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1e298:	e24dd020 	sub	sp, sp, #32
57e1e29c:	e1a04001 	mov	r4, r1
57e1e2a0:	e1a07002 	mov	r7, r2
57e1e2a4:	e1a06003 	mov	r6, r3
57e1e2a8:	e1a05000 	mov	r5, r0
57e1e2ac:	e59da040 	ldr	sl, [sp, #64]	; 0x40
	int maxsize = usb_maxpacket(dev, pipe);
57e1e2b0:	ebffc6f0 	bl	57e0fe78 <usb_maxpacket>
57e1e2b4:	e1a09000 	mov	r9, r0
	info("submit_control_msg");
#ifdef DEBUG
	pkt_print(NULL, dev, pipe, buffer, transfer_len,
		  setup, "SUB", usb_pipein(pipe));
#else
	mdelay(1);
57e1e2b8:	e3a00001 	mov	r0, #1
57e1e2bc:	eb0018a9 	bl	57e24568 <mdelay>
#endif
	if (!maxsize) {
57e1e2c0:	e3590000 	cmp	r9, #0
57e1e2c4:	1a000004 	bne	57e1e2dc <submit_control_msg+0x48>
		err("submit_control_message: pipesize for pipe %lx is zero",
57e1e2c8:	e1a01004 	mov	r1, r4
57e1e2cc:	e59f0558 	ldr	r0, [pc, #1368]	; 57e1e82c <submit_control_msg+0x598>
57e1e2d0:	ebffac5d 	bl	57e0944c <printf>
			pipe);
		return -1;
57e1e2d4:	e3e04000 	mvn	r4, #0
57e1e2d8:	ea000150 	b	57e1e820 <submit_control_msg+0x58c>
	}
	if (((pipe >> 8) & 0x7f) == gohci.rh.devnum) {
57e1e2dc:	e59fb54c 	ldr	fp, [pc, #1356]	; 57e1e830 <submit_control_msg+0x59c>
57e1e2e0:	e1a02424 	lsr	r2, r4, #8
57e1e2e4:	e59b3130 	ldr	r3, [fp, #304]	; 0x130
57e1e2e8:	e202207f 	and	r2, r2, #127	; 0x7f
57e1e2ec:	e1520003 	cmp	r2, r3
57e1e2f0:	1a000141 	bne	57e1e7fc <submit_control_msg+0x568>
pkt_print(NULL, dev, pipe, buffer, transfer_len,
	  cmd, "SUB(rh)", usb_pipein(pipe));
#else
	mdelay(1);
#endif
	if (usb_pipeint(pipe)) {
57e1e2f4:	e1a04f24 	lsr	r4, r4, #30
		err("submit_control_message: pipesize for pipe %lx is zero",
			pipe);
		return -1;
	}
	if (((pipe >> 8) & 0x7f) == gohci.rh.devnum) {
		gohci.rh.dev = dev;
57e1e2f8:	e58b5134 	str	r5, [fp, #308]	; 0x134

#ifdef DEBUG
pkt_print(NULL, dev, pipe, buffer, transfer_len,
	  cmd, "SUB(rh)", usb_pipein(pipe));
#else
	mdelay(1);
57e1e2fc:	e3a00001 	mov	r0, #1
57e1e300:	eb001898 	bl	57e24568 <mdelay>
#endif
	if (usb_pipeint(pipe)) {
57e1e304:	e3540001 	cmp	r4, #1
		info("Root-Hub submit IRQ: NOT implemented");
		return 0;
57e1e308:	03a04000 	moveq	r4, #0
pkt_print(NULL, dev, pipe, buffer, transfer_len,
	  cmd, "SUB(rh)", usb_pipein(pipe));
#else
	mdelay(1);
#endif
	if (usb_pipeint(pipe)) {
57e1e30c:	0a000143 	beq	57e1e820 <submit_control_msg+0x58c>
		info("Root-Hub submit IRQ: NOT implemented");
		return 0;
	}

	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
	wValue	      = le16_to_cpu(cmd->value);
57e1e310:	e5da3002 	ldrb	r3, [sl, #2]
57e1e314:	e5dac003 	ldrb	ip, [sl, #3]
	wIndex	      = le16_to_cpu(cmd->index);
57e1e318:	e5da2005 	ldrb	r2, [sl, #5]
		info("Root-Hub submit IRQ: NOT implemented");
		return 0;
	}

	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
	wValue	      = le16_to_cpu(cmd->value);
57e1e31c:	e183c40c 	orr	ip, r3, ip, lsl #8
	wIndex	      = le16_to_cpu(cmd->index);
57e1e320:	e5da3004 	ldrb	r3, [sl, #4]
	wLength	      = le16_to_cpu(cmd->length);
57e1e324:	e5da0007 	ldrb	r0, [sl, #7]
		return 0;
	}

	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
	wValue	      = le16_to_cpu(cmd->value);
	wIndex	      = le16_to_cpu(cmd->index);
57e1e328:	e1832402 	orr	r2, r3, r2, lsl #8
	wLength	      = le16_to_cpu(cmd->length);
57e1e32c:	e5da3006 	ldrb	r3, [sl, #6]
	if (usb_pipeint(pipe)) {
		info("Root-Hub submit IRQ: NOT implemented");
		return 0;
	}

	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
57e1e330:	e5dae001 	ldrb	lr, [sl, #1]
	wValue	      = le16_to_cpu(cmd->value);
	wIndex	      = le16_to_cpu(cmd->index);
	wLength	      = le16_to_cpu(cmd->length);
57e1e334:	e1830400 	orr	r0, r3, r0, lsl #8
	if (usb_pipeint(pipe)) {
		info("Root-Hub submit IRQ: NOT implemented");
		return 0;
	}

	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
57e1e338:	e5da3000 	ldrb	r3, [sl]
	wValue	      = le16_to_cpu(cmd->value);
57e1e33c:	e1a0c80c 	lsl	ip, ip, #16
	wLength	      = le16_to_cpu(cmd->length);

	info("Root-Hub: adr: %2x cmd(%1x): %08x %04x %04x %04x",
		dev->devnum, 8, bmRType_bReq, wValue, wIndex, wLength);

	switch (bmRType_bReq) {
57e1e340:	e183340e 	orr	r3, r3, lr, lsl #8
57e1e344:	e3530e12 	cmp	r3, #288	; 0x120
	int stat = 0;
	__u16 bmRType_bReq;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	ALLOC_ALIGN_BUFFER(__u8, databuf, 16, sizeof(u32));
57e1e348:	e28d900c 	add	r9, sp, #12
		info("Root-Hub submit IRQ: NOT implemented");
		return 0;
	}

	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
	wValue	      = le16_to_cpu(cmd->value);
57e1e34c:	e1a0182c 	lsr	r1, ip, #16
	wLength	      = le16_to_cpu(cmd->length);

	info("Root-Hub: adr: %2x cmd(%1x): %08x %04x %04x %04x",
		dev->devnum, 8, bmRType_bReq, wValue, wIndex, wLength);

	switch (bmRType_bReq) {
57e1e350:	0a000038 	beq	57e1e438 <submit_control_msg+0x1a4>
57e1e354:	8a00000f 	bhi	57e1e398 <submit_control_msg+0x104>
57e1e358:	e3530082 	cmp	r3, #130	; 0x82
57e1e35c:	0a000022 	beq	57e1e3ec <submit_control_msg+0x158>
57e1e360:	8a000004 	bhi	57e1e378 <submit_control_msg+0xe4>
57e1e364:	e3530080 	cmp	r3, #128	; 0x80
57e1e368:	0a00001d 	beq	57e1e3e4 <submit_control_msg+0x150>
57e1e36c:	e3530081 	cmp	r3, #129	; 0x81
57e1e370:	1a00010f 	bne	57e1e7b4 <submit_control_msg+0x520>
57e1e374:	ea00001c 	b	57e1e3ec <submit_control_msg+0x158>
57e1e378:	e35300a3 	cmp	r3, #163	; 0xa3
57e1e37c:	0a000025 	beq	57e1e418 <submit_control_msg+0x184>
57e1e380:	e59f24ac 	ldr	r2, [pc, #1196]	; 57e1e834 <submit_control_msg+0x5a0>
57e1e384:	e1530002 	cmp	r3, r2
57e1e388:	0a000106 	beq	57e1e7a8 <submit_control_msg+0x514>
57e1e38c:	e35300a0 	cmp	r3, #160	; 0xa0
57e1e390:	1a000107 	bne	57e1e7b4 <submit_control_msg+0x520>
57e1e394:	ea000019 	b	57e1e400 <submit_control_msg+0x16c>
57e1e398:	e3530d1a 	cmp	r3, #1664	; 0x680
57e1e39c:	0a0000a2 	beq	57e1e62c <submit_control_msg+0x398>
57e1e3a0:	8a000008 	bhi	57e1e3c8 <submit_control_msg+0x134>
57e1e3a4:	e59f048c 	ldr	r0, [pc, #1164]	; 57e1e838 <submit_control_msg+0x5a4>
57e1e3a8:	e1530000 	cmp	r3, r0
57e1e3ac:	0a00006f 	beq	57e1e570 <submit_control_msg+0x2dc>
57e1e3b0:	e3530c05 	cmp	r3, #1280	; 0x500
57e1e3b4:	0a00009a 	beq	57e1e624 <submit_control_msg+0x390>
57e1e3b8:	e2400c02 	sub	r0, r0, #512	; 0x200
57e1e3bc:	e1530000 	cmp	r3, r0
57e1e3c0:	1a0000fb 	bne	57e1e7b4 <submit_control_msg+0x520>
57e1e3c4:	ea000020 	b	57e1e44c <submit_control_msg+0x1b8>
57e1e3c8:	e3530d22 	cmp	r3, #2176	; 0x880
57e1e3cc:	0a0000ee 	beq	57e1e78c <submit_control_msg+0x4f8>
57e1e3d0:	e3530c09 	cmp	r3, #2304	; 0x900
57e1e3d4:	0a0000f0 	beq	57e1e79c <submit_control_msg+0x508>
57e1e3d8:	e3530e6a 	cmp	r3, #1696	; 0x6a0
57e1e3dc:	1a0000f4 	bne	57e1e7b4 <submit_control_msg+0x520>
57e1e3e0:	ea0000b9 	b	57e1e6cc <submit_control_msg+0x438>
	   RH_CLASS means HUB here,
	   RH_OTHER | RH_CLASS	almost ever means HUB_PORT here
	*/

	case RH_GET_STATUS:
		*(u16 *)databuf = cpu_to_le16(1);
57e1e3e4:	e3a03001 	mov	r3, #1
57e1e3e8:	ea000000 	b	57e1e3f0 <submit_control_msg+0x15c>
		OK(2);
	case RH_GET_STATUS | RH_INTERFACE:
		*(u16 *)databuf = cpu_to_le16(0);
57e1e3ec:	e3a03000 	mov	r3, #0
57e1e3f0:	e1c930b0 	strh	r3, [r9]
		void *buffer, int transfer_len, struct devrequest *cmd)
{
	void *data = buffer;
	int leni = transfer_len;
	int len = 0;
	int stat = 0;
57e1e3f4:	e3a04000 	mov	r4, #0
	case RH_GET_STATUS:
		*(u16 *)databuf = cpu_to_le16(1);
		OK(2);
	case RH_GET_STATUS | RH_INTERFACE:
		*(u16 *)databuf = cpu_to_le16(0);
		OK(2);
57e1e3f8:	e3a0a002 	mov	sl, #2
57e1e3fc:	ea0000ee 	b	57e1e7bc <submit_control_msg+0x528>
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
	return 0;
}
57e1e400:	e59f3428 	ldr	r3, [pc, #1064]	; 57e1e830 <submit_control_msg+0x59c>
static inline u32 roothub_a(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.a); }
static inline u32 roothub_b(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.b); }
static inline u32 roothub_status(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.status); }
57e1e404:	e5933014 	ldr	r3, [r3, #20]
57e1e408:	e5933050 	ldr	r3, [r3, #80]	; 0x50
		OK(2);
	case RH_GET_STATUS | RH_ENDPOINT:
		*(u16 *)databuf = cpu_to_le16(0);
		OK(2);
	case RH_GET_STATUS | RH_CLASS:
		*(u32 *)databuf = cpu_to_le32(
57e1e40c:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
57e1e410:	e3c33902 	bic	r3, r3, #32768	; 0x8000
57e1e414:	ea000003 	b	57e1e428 <submit_control_msg+0x194>
static inline u32 roothub_b(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.b); }
static inline u32 roothub_status(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.status); }
static inline u32 roothub_portstatus(struct ohci *hc, int i)
	{ return ohci_readl(&hc->regs->roothub.portstatus[i]); }
57e1e418:	e59b3014 	ldr	r3, [fp, #20]
	case RH_GET_STATUS | RH_CLASS:
		*(u32 *)databuf = cpu_to_le32(
				RD_RH_STAT & ~(RH_HS_CRWE | RH_HS_DRWE));
		OK(4);
	case RH_GET_STATUS | RH_OTHER | RH_CLASS:
		*(u32 *)databuf = cpu_to_le32(RD_RH_PORTSTAT);
57e1e41c:	e2422001 	sub	r2, r2, #1
static inline u32 roothub_b(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.b); }
static inline u32 roothub_status(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.status); }
static inline u32 roothub_portstatus(struct ohci *hc, int i)
	{ return ohci_readl(&hc->regs->roothub.portstatus[i]); }
57e1e420:	e2833054 	add	r3, r3, #84	; 0x54
57e1e424:	e7933102 	ldr	r3, [r3, r2, lsl #2]
	case RH_GET_STATUS | RH_CLASS:
		*(u32 *)databuf = cpu_to_le32(
				RD_RH_STAT & ~(RH_HS_CRWE | RH_HS_DRWE));
		OK(4);
	case RH_GET_STATUS | RH_OTHER | RH_CLASS:
		*(u32 *)databuf = cpu_to_le32(RD_RH_PORTSTAT);
57e1e428:	e5893000 	str	r3, [r9]
		void *buffer, int transfer_len, struct devrequest *cmd)
{
	void *data = buffer;
	int leni = transfer_len;
	int len = 0;
	int stat = 0;
57e1e42c:	e3a04000 	mov	r4, #0
		*(u32 *)databuf = cpu_to_le32(
				RD_RH_STAT & ~(RH_HS_CRWE | RH_HS_DRWE));
		OK(4);
	case RH_GET_STATUS | RH_OTHER | RH_CLASS:
		*(u32 *)databuf = cpu_to_le32(RD_RH_PORTSTAT);
		OK(4);
57e1e430:	e3a0a004 	mov	sl, #4
57e1e434:	ea0000e0 	b	57e1e7bc <submit_control_msg+0x528>
			OK(0);
		}
		break;

	case RH_CLEAR_FEATURE | RH_CLASS:
		switch (wValue) {
57e1e438:	e3510001 	cmp	r1, #1
		case RH_C_HUB_LOCAL_POWER:
			OK(0);
		case (RH_C_HUB_OVER_CURRENT):
			WR_RH_STAT(RH_HS_OCIC);
57e1e43c:	059b3014 	ldreq	r3, [fp, #20]
57e1e440:	03a02802 	moveq	r2, #131072	; 0x20000
			OK(0);
		}
		break;

	case RH_CLEAR_FEATURE | RH_CLASS:
		switch (wValue) {
57e1e444:	1a0000d7 	bne	57e1e7a8 <submit_control_msg+0x514>
57e1e448:	ea0000d5 	b	57e1e7a4 <submit_control_msg+0x510>
			OK(0);
		}
		break;

	case RH_CLEAR_FEATURE | RH_OTHER | RH_CLASS:
		switch (wValue) {
57e1e44c:	e2411001 	sub	r1, r1, #1
57e1e450:	e3510013 	cmp	r1, #19
57e1e454:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
57e1e458:	ea0000d2 	b	57e1e7a8 <submit_control_msg+0x514>
57e1e45c:	57e1e4ac 	.word	0x57e1e4ac
57e1e460:	57e1e4c4 	.word	0x57e1e4c4
57e1e464:	57e1e7a8 	.word	0x57e1e7a8
57e1e468:	57e1e7a8 	.word	0x57e1e7a8
57e1e46c:	57e1e7a8 	.word	0x57e1e7a8
57e1e470:	57e1e7a8 	.word	0x57e1e7a8
57e1e474:	57e1e7a8 	.word	0x57e1e7a8
57e1e478:	57e1e4e0 	.word	0x57e1e4e0
57e1e47c:	57e1e7a8 	.word	0x57e1e7a8
57e1e480:	57e1e7a8 	.word	0x57e1e7a8
57e1e484:	57e1e7a8 	.word	0x57e1e7a8
57e1e488:	57e1e7a8 	.word	0x57e1e7a8
57e1e48c:	57e1e7a8 	.word	0x57e1e7a8
57e1e490:	57e1e7a8 	.word	0x57e1e7a8
57e1e494:	57e1e7a8 	.word	0x57e1e7a8
57e1e498:	57e1e4f8 	.word	0x57e1e4f8
57e1e49c:	57e1e510 	.word	0x57e1e510
57e1e4a0:	57e1e528 	.word	0x57e1e528
57e1e4a4:	57e1e540 	.word	0x57e1e540
57e1e4a8:	57e1e558 	.word	0x57e1e558
		case (RH_PORT_ENABLE):        WR_RH_PORTSTAT(RH_PS_CCS);  OK(0);
57e1e4ac:	e59f337c 	ldr	r3, [pc, #892]	; 57e1e830 <submit_control_msg+0x59c>
57e1e4b0:	e2422001 	sub	r2, r2, #1
57e1e4b4:	e5933014 	ldr	r3, [r3, #20]
57e1e4b8:	e3a01001 	mov	r1, #1
57e1e4bc:	e2833054 	add	r3, r3, #84	; 0x54
57e1e4c0:	ea000004 	b	57e1e4d8 <submit_control_msg+0x244>
		case (RH_PORT_SUSPEND):       WR_RH_PORTSTAT(RH_PS_POCI); OK(0);
57e1e4c4:	e59f3364 	ldr	r3, [pc, #868]	; 57e1e830 <submit_control_msg+0x59c>
57e1e4c8:	e2422001 	sub	r2, r2, #1
57e1e4cc:	e5933014 	ldr	r3, [r3, #20]
57e1e4d0:	e3a01008 	mov	r1, #8
57e1e4d4:	e2833054 	add	r3, r3, #84	; 0x54
57e1e4d8:	e7831102 	str	r1, [r3, r2, lsl #2]
57e1e4dc:	ea0000b1 	b	57e1e7a8 <submit_control_msg+0x514>
		case (RH_PORT_POWER):         WR_RH_PORTSTAT(RH_PS_LSDA); OK(0);
57e1e4e0:	e59f3348 	ldr	r3, [pc, #840]	; 57e1e830 <submit_control_msg+0x59c>
57e1e4e4:	e2422001 	sub	r2, r2, #1
57e1e4e8:	e5933014 	ldr	r3, [r3, #20]
57e1e4ec:	e3a01c02 	mov	r1, #512	; 0x200
57e1e4f0:	e2833054 	add	r3, r3, #84	; 0x54
57e1e4f4:	eafffff7 	b	57e1e4d8 <submit_control_msg+0x244>
		case (RH_C_PORT_CONNECTION):  WR_RH_PORTSTAT(RH_PS_CSC);  OK(0);
57e1e4f8:	e59f3330 	ldr	r3, [pc, #816]	; 57e1e830 <submit_control_msg+0x59c>
57e1e4fc:	e2422001 	sub	r2, r2, #1
57e1e500:	e5933014 	ldr	r3, [r3, #20]
57e1e504:	e3a01801 	mov	r1, #65536	; 0x10000
57e1e508:	e2833054 	add	r3, r3, #84	; 0x54
57e1e50c:	eafffff1 	b	57e1e4d8 <submit_control_msg+0x244>
		case (RH_C_PORT_ENABLE):      WR_RH_PORTSTAT(RH_PS_PESC); OK(0);
57e1e510:	e59f3318 	ldr	r3, [pc, #792]	; 57e1e830 <submit_control_msg+0x59c>
57e1e514:	e2422001 	sub	r2, r2, #1
57e1e518:	e5933014 	ldr	r3, [r3, #20]
57e1e51c:	e3a01802 	mov	r1, #131072	; 0x20000
57e1e520:	e2833054 	add	r3, r3, #84	; 0x54
57e1e524:	eaffffeb 	b	57e1e4d8 <submit_control_msg+0x244>
		case (RH_C_PORT_SUSPEND):     WR_RH_PORTSTAT(RH_PS_PSSC); OK(0);
57e1e528:	e59f3300 	ldr	r3, [pc, #768]	; 57e1e830 <submit_control_msg+0x59c>
57e1e52c:	e2422001 	sub	r2, r2, #1
57e1e530:	e5933014 	ldr	r3, [r3, #20]
57e1e534:	e3a01701 	mov	r1, #262144	; 0x40000
57e1e538:	e2833054 	add	r3, r3, #84	; 0x54
57e1e53c:	eaffffe5 	b	57e1e4d8 <submit_control_msg+0x244>
		case (RH_C_PORT_OVER_CURRENT):WR_RH_PORTSTAT(RH_PS_OCIC); OK(0);
57e1e540:	e59f32e8 	ldr	r3, [pc, #744]	; 57e1e830 <submit_control_msg+0x59c>
57e1e544:	e2422001 	sub	r2, r2, #1
57e1e548:	e5933014 	ldr	r3, [r3, #20]
57e1e54c:	e3a01702 	mov	r1, #524288	; 0x80000
57e1e550:	e2833054 	add	r3, r3, #84	; 0x54
57e1e554:	eaffffdf 	b	57e1e4d8 <submit_control_msg+0x244>
		case (RH_C_PORT_RESET):       WR_RH_PORTSTAT(RH_PS_PRSC); OK(0);
57e1e558:	e59f32d0 	ldr	r3, [pc, #720]	; 57e1e830 <submit_control_msg+0x59c>
57e1e55c:	e2422001 	sub	r2, r2, #1
57e1e560:	e5933014 	ldr	r3, [r3, #20]
57e1e564:	e3a01601 	mov	r1, #1048576	; 0x100000
57e1e568:	e2833054 	add	r3, r3, #84	; 0x54
57e1e56c:	eaffffd9 	b	57e1e4d8 <submit_control_msg+0x244>
		}
		break;

	case RH_SET_FEATURE | RH_OTHER | RH_CLASS:
		switch (wValue) {
57e1e570:	e2411001 	sub	r1, r1, #1
57e1e574:	e3510007 	cmp	r1, #7
57e1e578:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
57e1e57c:	ea000089 	b	57e1e7a8 <submit_control_msg+0x514>
57e1e580:	57e1e600 	.word	0x57e1e600
57e1e584:	57e1e5a0 	.word	0x57e1e5a0
57e1e588:	57e1e7a8 	.word	0x57e1e7a8
57e1e58c:	57e1e5b8 	.word	0x57e1e5b8
57e1e590:	57e1e7a8 	.word	0x57e1e7a8
57e1e594:	57e1e7a8 	.word	0x57e1e7a8
57e1e598:	57e1e7a8 	.word	0x57e1e7a8
57e1e59c:	57e1e5dc 	.word	0x57e1e5dc
		case (RH_PORT_SUSPEND):
			WR_RH_PORTSTAT(RH_PS_PSS);  OK(0);
57e1e5a0:	e59f3288 	ldr	r3, [pc, #648]	; 57e1e830 <submit_control_msg+0x59c>
57e1e5a4:	e2422001 	sub	r2, r2, #1
57e1e5a8:	e5933014 	ldr	r3, [r3, #20]
57e1e5ac:	e3a01004 	mov	r1, #4
57e1e5b0:	e2833054 	add	r3, r3, #84	; 0x54
57e1e5b4:	eaffffc7 	b	57e1e4d8 <submit_control_msg+0x244>
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
	return 0;
}
57e1e5b8:	e59f3270 	ldr	r3, [pc, #624]	; 57e1e830 <submit_control_msg+0x59c>
	case RH_SET_FEATURE | RH_OTHER | RH_CLASS:
		switch (wValue) {
		case (RH_PORT_SUSPEND):
			WR_RH_PORTSTAT(RH_PS_PSS);  OK(0);
		case (RH_PORT_RESET): /* BUG IN HUP CODE *********/
			if (RD_RH_PORTSTAT & RH_PS_CCS)
57e1e5bc:	e2422001 	sub	r2, r2, #1
static inline u32 roothub_b(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.b); }
static inline u32 roothub_status(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.status); }
static inline u32 roothub_portstatus(struct ohci *hc, int i)
	{ return ohci_readl(&hc->regs->roothub.portstatus[i]); }
57e1e5c0:	e5933014 	ldr	r3, [r3, #20]
57e1e5c4:	e2833054 	add	r3, r3, #84	; 0x54
57e1e5c8:	e7934102 	ldr	r4, [r3, r2, lsl #2]
	case RH_SET_FEATURE | RH_OTHER | RH_CLASS:
		switch (wValue) {
		case (RH_PORT_SUSPEND):
			WR_RH_PORTSTAT(RH_PS_PSS);  OK(0);
		case (RH_PORT_RESET): /* BUG IN HUP CODE *********/
			if (RD_RH_PORTSTAT & RH_PS_CCS)
57e1e5cc:	e2144001 	ands	r4, r4, #1
				WR_RH_PORTSTAT(RH_PS_PRS);
57e1e5d0:	13a01010 	movne	r1, #16
	case RH_SET_FEATURE | RH_OTHER | RH_CLASS:
		switch (wValue) {
		case (RH_PORT_SUSPEND):
			WR_RH_PORTSTAT(RH_PS_PSS);  OK(0);
		case (RH_PORT_RESET): /* BUG IN HUP CODE *********/
			if (RD_RH_PORTSTAT & RH_PS_CCS)
57e1e5d4:	1affffbf 	bne	57e1e4d8 <submit_control_msg+0x244>
57e1e5d8:	ea000073 	b	57e1e7ac <submit_control_msg+0x518>
				WR_RH_PORTSTAT(RH_PS_PRS);
			OK(0);
		case (RH_PORT_POWER):
			WR_RH_PORTSTAT(RH_PS_PPS);
57e1e5dc:	e59f324c 	ldr	r3, [pc, #588]	; 57e1e830 <submit_control_msg+0x59c>
57e1e5e0:	e2422001 	sub	r2, r2, #1
57e1e5e4:	e5933014 	ldr	r3, [r3, #20]
57e1e5e8:	e3a01c01 	mov	r1, #256	; 0x100
57e1e5ec:	e2833054 	add	r3, r3, #84	; 0x54
57e1e5f0:	e7831102 	str	r1, [r3, r2, lsl #2]
			mdelay(100);
57e1e5f4:	e3a00064 	mov	r0, #100	; 0x64
57e1e5f8:	eb0017da 	bl	57e24568 <mdelay>
57e1e5fc:	ea000069 	b	57e1e7a8 <submit_control_msg+0x514>
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
	return 0;
}
57e1e600:	e59f3228 	ldr	r3, [pc, #552]	; 57e1e830 <submit_control_msg+0x59c>
		case (RH_PORT_POWER):
			WR_RH_PORTSTAT(RH_PS_PPS);
			mdelay(100);
			OK(0);
		case (RH_PORT_ENABLE): /* BUG IN HUP CODE *********/
			if (RD_RH_PORTSTAT & RH_PS_CCS)
57e1e604:	e2422001 	sub	r2, r2, #1
static inline u32 roothub_b(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.b); }
static inline u32 roothub_status(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.status); }
static inline u32 roothub_portstatus(struct ohci *hc, int i)
	{ return ohci_readl(&hc->regs->roothub.portstatus[i]); }
57e1e608:	e5933014 	ldr	r3, [r3, #20]
57e1e60c:	e2833054 	add	r3, r3, #84	; 0x54
57e1e610:	e7934102 	ldr	r4, [r3, r2, lsl #2]
		case (RH_PORT_POWER):
			WR_RH_PORTSTAT(RH_PS_PPS);
			mdelay(100);
			OK(0);
		case (RH_PORT_ENABLE): /* BUG IN HUP CODE *********/
			if (RD_RH_PORTSTAT & RH_PS_CCS)
57e1e614:	e2144001 	ands	r4, r4, #1
				WR_RH_PORTSTAT(RH_PS_PES);
57e1e618:	13a01002 	movne	r1, #2
		case (RH_PORT_POWER):
			WR_RH_PORTSTAT(RH_PS_PPS);
			mdelay(100);
			OK(0);
		case (RH_PORT_ENABLE): /* BUG IN HUP CODE *********/
			if (RD_RH_PORTSTAT & RH_PS_CCS)
57e1e61c:	1affffad 	bne	57e1e4d8 <submit_control_msg+0x244>
57e1e620:	ea000061 	b	57e1e7ac <submit_control_msg+0x518>
			OK(0);
		}
		break;

	case RH_SET_ADDRESS:
		gohci.rh.devnum = wValue;
57e1e624:	e58b1130 	str	r1, [fp, #304]	; 0x130
57e1e628:	ea00005e 	b	57e1e7a8 <submit_control_msg+0x514>
		OK(0);

	case RH_GET_DESCRIPTOR:
		switch ((wValue & 0xff00) >> 8) {
57e1e62c:	e1a03c2c 	lsr	r3, ip, #24
57e1e630:	e3530002 	cmp	r3, #2
57e1e634:	0a00000a 	beq	57e1e664 <submit_control_msg+0x3d0>
57e1e638:	e3530003 	cmp	r3, #3
57e1e63c:	0a00000f 	beq	57e1e680 <submit_control_msg+0x3ec>
57e1e640:	e3530001 	cmp	r3, #1
57e1e644:	1a00005a 	bne	57e1e7b4 <submit_control_msg+0x520>
		case (0x01): /* device descriptor */
			len = min_t(unsigned int,
57e1e648:	e3500012 	cmp	r0, #18
57e1e64c:	31a0a000 	movcc	sl, r0
57e1e650:	23a0a012 	movcs	sl, #18
57e1e654:	e15a0006 	cmp	sl, r6
57e1e658:	21a0a006 	movcs	sl, r6
					leni,
					min_t(unsigned int,
					sizeof(root_hub_dev_des),
					wLength));
			databuf = root_hub_dev_des; OK(len);
57e1e65c:	e59f91d8 	ldr	r9, [pc, #472]	; 57e1e83c <submit_control_msg+0x5a8>
57e1e660:	ea00004b 	b	57e1e794 <submit_control_msg+0x500>
		case (0x02): /* configuration descriptor */
			len = min_t(unsigned int,
57e1e664:	e3500019 	cmp	r0, #25
57e1e668:	31a0a000 	movcc	sl, r0
57e1e66c:	23a0a019 	movcs	sl, #25
57e1e670:	e15a0006 	cmp	sl, r6
57e1e674:	21a0a006 	movcs	sl, r6
					leni,
					min_t(unsigned int,
					sizeof(root_hub_config_des),
					wLength));
			databuf = root_hub_config_des; OK(len);
57e1e678:	e59f91c0 	ldr	r9, [pc, #448]	; 57e1e840 <submit_control_msg+0x5ac>
57e1e67c:	ea000044 	b	57e1e794 <submit_control_msg+0x500>
		case (0x03): /* string descriptors */
			if (wValue == 0x0300) {
57e1e680:	e3510c03 	cmp	r1, #768	; 0x300
57e1e684:	1a000006 	bne	57e1e6a4 <submit_control_msg+0x410>
				len = min_t(unsigned int,
57e1e688:	e3500004 	cmp	r0, #4
57e1e68c:	31a0a000 	movcc	sl, r0
57e1e690:	23a0a004 	movcs	sl, #4
57e1e694:	e15a0006 	cmp	sl, r6
57e1e698:	21a0a006 	movcs	sl, r6
						leni,
						min_t(unsigned int,
						sizeof(root_hub_str_index0),
						wLength));
				databuf = root_hub_str_index0;
57e1e69c:	e59f91a0 	ldr	r9, [pc, #416]	; 57e1e844 <submit_control_msg+0x5b0>
57e1e6a0:	ea00003b 	b	57e1e794 <submit_control_msg+0x500>
				OK(len);
			}
			if (wValue == 0x0301) {
57e1e6a4:	e59f319c 	ldr	r3, [pc, #412]	; 57e1e848 <submit_control_msg+0x5b4>
57e1e6a8:	e1510003 	cmp	r1, r3
57e1e6ac:	1a000040 	bne	57e1e7b4 <submit_control_msg+0x520>
				len = min_t(unsigned int,
57e1e6b0:	e350001c 	cmp	r0, #28
57e1e6b4:	31a0a000 	movcc	sl, r0
57e1e6b8:	23a0a01c 	movcs	sl, #28
57e1e6bc:	e15a0006 	cmp	sl, r6
57e1e6c0:	21a0a006 	movcs	sl, r6
						leni,
						min_t(unsigned int,
						sizeof(root_hub_str_index1),
						wLength));
				databuf = root_hub_str_index1;
57e1e6c4:	e59f9180 	ldr	r9, [pc, #384]	; 57e1e84c <submit_control_msg+0x5b8>
57e1e6c8:	ea000031 	b	57e1e794 <submit_control_msg+0x500>
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
	return 0;
}
57e1e6cc:	e59f315c 	ldr	r3, [pc, #348]	; 57e1e830 <submit_control_msg+0x59c>

	case RH_GET_DESCRIPTOR | RH_CLASS:
	{
		__u32 temp = roothub_a(&gohci);

		databuf[0] = 9;		/* min length; */
57e1e6d0:	e3a02009 	mov	r2, #9
struct ohci_device ohci_dev;
/* device which was disconnected */
struct usb_device *devgone;

static inline u32 roothub_a(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.a); }
57e1e6d4:	e5933014 	ldr	r3, [r3, #20]
	{
		__u32 temp = roothub_a(&gohci);

		databuf[0] = 9;		/* min length; */
		databuf[1] = 0x29;
		databuf[2] = temp & RH_A_NDP;
57e1e6d8:	e2891002 	add	r1, r9, #2
struct ohci_device ohci_dev;
/* device which was disconnected */
struct usb_device *devgone;

static inline u32 roothub_a(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.a); }
57e1e6dc:	e5933048 	ldr	r3, [r3, #72]	; 0x48

	case RH_GET_DESCRIPTOR | RH_CLASS:
	{
		__u32 temp = roothub_a(&gohci);

		databuf[0] = 9;		/* min length; */
57e1e6e0:	e5c92000 	strb	r2, [r9]
#ifdef CONFIG_AT91C_PQFP_UHPBUG
		databuf[2] = (databuf[2] == 2) ? 1 : 0;
#endif
		databuf[3] = 0;
		if (temp & RH_A_PSM)	/* per-port power switching? */
			databuf[3] |= 0x1;
57e1e6e4:	e3130c01 	tst	r3, #256	; 0x100
	case RH_GET_DESCRIPTOR | RH_CLASS:
	{
		__u32 temp = roothub_a(&gohci);

		databuf[0] = 9;		/* min length; */
		databuf[1] = 0x29;
57e1e6e8:	e2822020 	add	r2, r2, #32
57e1e6ec:	e5c92001 	strb	r2, [r9, #1]
#ifdef CONFIG_AT91C_PQFP_UHPBUG
		databuf[2] = (databuf[2] == 2) ? 1 : 0;
#endif
		databuf[3] = 0;
		if (temp & RH_A_PSM)	/* per-port power switching? */
			databuf[3] |= 0x1;
57e1e6f0:	03a02000 	moveq	r2, #0
57e1e6f4:	13a02001 	movne	r2, #1
		if (temp & RH_A_NOCP)	/* no overcurrent reporting? */
57e1e6f8:	e3130a01 	tst	r3, #4096	; 0x1000
#ifdef CONFIG_AT91C_PQFP_UHPBUG
		databuf[2] = (databuf[2] == 2) ? 1 : 0;
#endif
		databuf[3] = 0;
		if (temp & RH_A_PSM)	/* per-port power switching? */
			databuf[3] |= 0x1;
57e1e6fc:	e5c92003 	strb	r2, [r9, #3]
		if (temp & RH_A_NOCP)	/* no overcurrent reporting? */
			databuf[3] |= 0x10;
57e1e700:	13822010 	orrne	r2, r2, #16
	{
		__u32 temp = roothub_a(&gohci);

		databuf[0] = 9;		/* min length; */
		databuf[1] = 0x29;
		databuf[2] = temp & RH_A_NDP;
57e1e704:	e5c93002 	strb	r3, [r9, #2]
#ifdef CONFIG_AT91C_PQFP_UHPBUG
		databuf[2] = (databuf[2] == 2) ? 1 : 0;
#endif
		databuf[3] = 0;
57e1e708:	e289c003 	add	ip, r9, #3
		if (temp & RH_A_PSM)	/* per-port power switching? */
			databuf[3] |= 0x1;
		if (temp & RH_A_NOCP)	/* no overcurrent reporting? */
			databuf[3] |= 0x10;
57e1e70c:	15c92003 	strbne	r2, [r9, #3]
		databuf[2] = (databuf[2] == 2) ? 1 : 0;
#endif
		databuf[3] = 0;
		if (temp & RH_A_PSM)	/* per-port power switching? */
			databuf[3] |= 0x1;
		if (temp & RH_A_NOCP)	/* no overcurrent reporting? */
57e1e710:	1a000002 	bne	57e1e720 <submit_control_msg+0x48c>
			databuf[3] |= 0x10;
		else if (temp & RH_A_OCPM)/* per-port overcurrent reporting? */
57e1e714:	e3130b02 	tst	r3, #2048	; 0x800
			databuf[3] |= 0x8;
57e1e718:	13822008 	orrne	r2, r2, #8
57e1e71c:	15cc2000 	strbne	r2, [ip]

		databuf[4] = 0;
		databuf[5] = (temp & RH_A_POTPGT) >> 24;
57e1e720:	e1a03c23 	lsr	r3, r3, #24
57e1e724:	e5c93005 	strb	r3, [r9, #5]
		if (temp & RH_A_NOCP)	/* no overcurrent reporting? */
			databuf[3] |= 0x10;
		else if (temp & RH_A_OCPM)/* per-port overcurrent reporting? */
			databuf[3] |= 0x8;

		databuf[4] = 0;
57e1e728:	e3a02000 	mov	r2, #0
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
	return 0;
}
57e1e72c:	e59f30fc 	ldr	r3, [pc, #252]	; 57e1e830 <submit_control_msg+0x59c>
		if (temp & RH_A_NOCP)	/* no overcurrent reporting? */
			databuf[3] |= 0x10;
		else if (temp & RH_A_OCPM)/* per-port overcurrent reporting? */
			databuf[3] |= 0x8;

		databuf[4] = 0;
57e1e730:	e5c92004 	strb	r2, [r9, #4]
		databuf[5] = (temp & RH_A_POTPGT) >> 24;
		databuf[6] = 0;
57e1e734:	e5c92006 	strb	r2, [r9, #6]
struct usb_device *devgone;

static inline u32 roothub_a(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.a); }
static inline u32 roothub_b(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.b); }
57e1e738:	e5933014 	ldr	r3, [r3, #20]
57e1e73c:	e593304c 	ldr	r3, [r3, #76]	; 0x4c

		databuf[4] = 0;
		databuf[5] = (temp & RH_A_POTPGT) >> 24;
		databuf[6] = 0;
		temp = roothub_b(&gohci);
		databuf[7] = temp & RH_B_DR;
57e1e740:	e5c93007 	strb	r3, [r9, #7]
		if (databuf[2] < 7) {
57e1e744:	e5d12000 	ldrb	r2, [r1]
57e1e748:	e3520006 	cmp	r2, #6
			databuf[8] = 0xff;
		} else {
			databuf[0] += 2;
57e1e74c:	85d92000 	ldrbhi	r2, [r9]
			databuf[8] = (temp & RH_B_DR) >> 8;
57e1e750:	81a03423 	lsrhi	r3, r3, #8
		temp = roothub_b(&gohci);
		databuf[7] = temp & RH_B_DR;
		if (databuf[2] < 7) {
			databuf[8] = 0xff;
		} else {
			databuf[0] += 2;
57e1e754:	82822002 	addhi	r2, r2, #2
57e1e758:	85c92000 	strbhi	r2, [r9]
			databuf[8] = (temp & RH_B_DR) >> 8;
			databuf[10] = databuf[9] = 0xff;
		}

		len = min_t(unsigned int, leni,
57e1e75c:	e5d9a000 	ldrb	sl, [r9]
		databuf[5] = (temp & RH_A_POTPGT) >> 24;
		databuf[6] = 0;
		temp = roothub_b(&gohci);
		databuf[7] = temp & RH_B_DR;
		if (databuf[2] < 7) {
			databuf[8] = 0xff;
57e1e760:	93e03000 	mvnls	r3, #0
		} else {
			databuf[0] += 2;
			databuf[8] = (temp & RH_B_DR) >> 8;
57e1e764:	85c93008 	strbhi	r3, [r9, #8]
			databuf[10] = databuf[9] = 0xff;
57e1e768:	83e03000 	mvnhi	r3, #0
		databuf[5] = (temp & RH_A_POTPGT) >> 24;
		databuf[6] = 0;
		temp = roothub_b(&gohci);
		databuf[7] = temp & RH_B_DR;
		if (databuf[2] < 7) {
			databuf[8] = 0xff;
57e1e76c:	95c93008 	strbls	r3, [r9, #8]
		} else {
			databuf[0] += 2;
			databuf[8] = (temp & RH_B_DR) >> 8;
			databuf[10] = databuf[9] = 0xff;
57e1e770:	85c93009 	strbhi	r3, [r9, #9]
57e1e774:	85c9300a 	strbhi	r3, [r9, #10]
		}

		len = min_t(unsigned int, leni,
57e1e778:	e15a0000 	cmp	sl, r0
57e1e77c:	21a0a000 	movcs	sl, r0
57e1e780:	e15a0006 	cmp	sl, r6
57e1e784:	21a0a006 	movcs	sl, r6
57e1e788:	ea000001 	b	57e1e794 <submit_control_msg+0x500>
			    min_t(unsigned int, databuf[0], wLength));
		OK(len);
	}

	case RH_GET_CONFIGURATION:
		databuf[0] = 0x01;
57e1e78c:	e3a0a001 	mov	sl, #1
57e1e790:	e5c9a000 	strb	sl, [r9]
		void *buffer, int transfer_len, struct devrequest *cmd)
{
	void *data = buffer;
	int leni = transfer_len;
	int len = 0;
	int stat = 0;
57e1e794:	e3a04000 	mov	r4, #0
57e1e798:	ea000007 	b	57e1e7bc <submit_control_msg+0x528>
	case RH_GET_CONFIGURATION:
		databuf[0] = 0x01;
		OK(1);

	case RH_SET_CONFIGURATION:
		WR_RH_STAT(0x10000);
57e1e79c:	e59b3014 	ldr	r3, [fp, #20]
57e1e7a0:	e3a02801 	mov	r2, #65536	; 0x10000
57e1e7a4:	e5832050 	str	r2, [r3, #80]	; 0x50
		void *buffer, int transfer_len, struct devrequest *cmd)
{
	void *data = buffer;
	int leni = transfer_len;
	int len = 0;
	int stat = 0;
57e1e7a8:	e3a04000 	mov	r4, #0
			mdelay(100);
			OK(0);
		case (RH_PORT_ENABLE): /* BUG IN HUP CODE *********/
			if (RD_RH_PORTSTAT & RH_PS_CCS)
				WR_RH_PORTSTAT(RH_PS_PES);
			OK(0);
57e1e7ac:	e1a0a004 	mov	sl, r4
57e1e7b0:	ea000001 	b	57e1e7bc <submit_control_msg+0x528>
						wLength));
				databuf = root_hub_str_index1;
				OK(len);
		}
		default:
			stat = USB_ST_STALLED;
57e1e7b4:	e3a04002 	mov	r4, #2
static int ohci_submit_rh_msg(struct usb_device *dev, unsigned long pipe,
		void *buffer, int transfer_len, struct devrequest *cmd)
{
	void *data = buffer;
	int leni = transfer_len;
	int len = 0;
57e1e7b8:	e3a0a000 	mov	sl, #0
	}

#ifdef	DEBUG
	ohci_dump_roothub(&gohci, 1);
#else
	mdelay(1);
57e1e7bc:	e3a00001 	mov	r0, #1
57e1e7c0:	eb001768 	bl	57e24568 <mdelay>
#endif

	len = min_t(int, len, leni);
57e1e7c4:	e15a0006 	cmp	sl, r6
57e1e7c8:	b1a0600a 	movlt	r6, sl
57e1e7cc:	a1a06006 	movge	r6, r6
	if (data != databuf)
57e1e7d0:	e1570009 	cmp	r7, r9
57e1e7d4:	0a000003 	beq	57e1e7e8 <submit_control_msg+0x554>
		memcpy(data, databuf, len);
57e1e7d8:	e1a00007 	mov	r0, r7
57e1e7dc:	e1a01009 	mov	r1, r9
57e1e7e0:	e1a02006 	mov	r2, r6
57e1e7e4:	eb0016c8 	bl	57e2430c <memcpy>
	dev->act_len = len;
57e1e7e8:	e5856618 	str	r6, [r5, #1560]	; 0x618
	dev->status = stat;
57e1e7ec:	e5854614 	str	r4, [r5, #1556]	; 0x614

#ifdef DEBUG
	pkt_print(NULL, dev, pipe, buffer,
		  transfer_len, cmd, "RET(rh)", 0/*usb_pipein(pipe)*/);
#else
	mdelay(1);
57e1e7f0:	e3a00001 	mov	r0, #1
57e1e7f4:	eb00175b 	bl	57e24568 <mdelay>
57e1e7f8:	ea000008 	b	57e1e820 <submit_control_msg+0x58c>
		/* root hub - redirect */
		return ohci_submit_rh_msg(dev, pipe, buffer, transfer_len,
			setup);
	}

	return submit_common_msg(dev, pipe, buffer, transfer_len, setup, 0);
57e1e7fc:	e3a03000 	mov	r3, #0
57e1e800:	e58d3004 	str	r3, [sp, #4]
57e1e804:	e1a01004 	mov	r1, r4
57e1e808:	e1a00005 	mov	r0, r5
57e1e80c:	e1a02007 	mov	r2, r7
57e1e810:	e1a03006 	mov	r3, r6
57e1e814:	e58da000 	str	sl, [sp]
57e1e818:	ebfffcf6 	bl	57e1dbf8 <submit_common_msg>
57e1e81c:	e1a04000 	mov	r4, r0
}
57e1e820:	e1a00004 	mov	r0, r4
57e1e824:	e28dd020 	add	sp, sp, #32
57e1e828:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1e82c:	57e3483c 	.word	0x57e3483c
57e1e830:	57e47a00 	.word	0x57e47a00
57e1e834:	00000102 	.word	0x00000102
57e1e838:	00000323 	.word	0x00000323
57e1e83c:	57e37960 	.word	0x57e37960
57e1e840:	57e37974 	.word	0x57e37974
57e1e844:	57e37990 	.word	0x57e37990
57e1e848:	00000301 	.word	0x00000301
57e1e84c:	57e37994 	.word	0x57e37994

57e1e850 <submit_int_msg>:

int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
		int transfer_len, int interval)
{
57e1e850:	e92d4007 	push	{r0, r1, r2, lr}
	info("submit_int_msg");
	return submit_common_msg(dev, pipe, buffer, transfer_len, NULL,
57e1e854:	e3a0c000 	mov	ip, #0
57e1e858:	e58dc000 	str	ip, [sp]
57e1e85c:	e59dc010 	ldr	ip, [sp, #16]
57e1e860:	e58dc004 	str	ip, [sp, #4]
57e1e864:	ebfffce3 	bl	57e1dbf8 <submit_common_msg>
			interval);
}
57e1e868:	e8bd800e 	pop	{r1, r2, r3, pc}

57e1e86c <usb_lowlevel_init>:
 * low level initalisation routine, called from usb.c
 */
static char ohci_inited = 0;

int usb_lowlevel_init(int index, void **controller)
{
57e1e86c:	e92d4070 	push	{r4, r5, r6, lr}
	pci_dev_t pdev;
#endif

#ifdef CONFIG_SYS_USB_OHCI_CPU_INIT
	/* cpu dependant init */
	if (usb_cpu_init())
57e1e870:	eb00006d 	bl	57e1ea2c <usb_cpu_init>
57e1e874:	e2505000 	subs	r5, r0, #0
57e1e878:	1a000054 	bne	57e1e9d0 <usb_lowlevel_init+0x164>
#ifdef CONFIG_SYS_USB_OHCI_BOARD_INIT
	/*  board dependant init */
	if (usb_board_init())
		return -1;
#endif
	memset(&gohci, 0, sizeof(ohci_t));
57e1e87c:	e59f4154 	ldr	r4, [pc, #340]	; 57e1e9d8 <usb_lowlevel_init+0x16c>
57e1e880:	e1a01005 	mov	r1, r5
57e1e884:	e3a02f52 	mov	r2, #328	; 0x148
57e1e888:	e1a00004 	mov	r0, r4
57e1e88c:	eb00167a 	bl	57e2427c <memset>
	memset(&ohci_dev, 0, sizeof(struct ohci_device));
	if ((__u32)&ohci_dev.ed[0] & 0x7) {
		err("EDs not aligned!!");
		return -1;
	}
	memset(gtd, 0, sizeof(td_t) * (NUM_TD + 1));
57e1e890:	e2846b01 	add	r6, r4, #1024	; 0x400
	/* align the storage */
	if ((__u32)&ghcca[0] & 0xff) {
		err("HCCA not aligned!!");
		return -1;
	}
	phcca = &ghcca[0];
57e1e894:	e2843c03 	add	r3, r4, #768	; 0x300
	info("aligned ghcca %p", phcca);
	memset(&ohci_dev, 0, sizeof(struct ohci_device));
57e1e898:	e1a01005 	mov	r1, r5
57e1e89c:	e3a02e19 	mov	r2, #400	; 0x190
57e1e8a0:	e2840e15 	add	r0, r4, #336	; 0x150
	/* align the storage */
	if ((__u32)&ghcca[0] & 0xff) {
		err("HCCA not aligned!!");
		return -1;
	}
	phcca = &ghcca[0];
57e1e8a4:	e58432e8 	str	r3, [r4, #744]	; 0x2e8
	info("aligned ghcca %p", phcca);
	memset(&ohci_dev, 0, sizeof(struct ohci_device));
57e1e8a8:	eb001673 	bl	57e2427c <memset>
	if ((__u32)&ohci_dev.ed[0] & 0x7) {
		err("EDs not aligned!!");
		return -1;
	}
	memset(gtd, 0, sizeof(td_t) * (NUM_TD + 1));
57e1e8ac:	e1a00006 	mov	r0, r6
57e1e8b0:	e1a01005 	mov	r1, r5
57e1e8b4:	e3a02d41 	mov	r2, #4160	; 0x1040
57e1e8b8:	eb00166f 	bl	57e2427c <memset>
	if ((__u32)gtd & 0x7) {
		err("TDs not aligned!!");
		return -1;
	}
	ptd = gtd;
	gohci.hcca = phcca;
57e1e8bc:	e59402e8 	ldr	r0, [r4, #744]	; 0x2e8
	memset(phcca, 0, sizeof(struct ohci_hcca));
57e1e8c0:	e1a01005 	mov	r1, r5
57e1e8c4:	e3a02c01 	mov	r2, #256	; 0x100
	memset(gtd, 0, sizeof(td_t) * (NUM_TD + 1));
	if ((__u32)gtd & 0x7) {
		err("TDs not aligned!!");
		return -1;
	}
	ptd = gtd;
57e1e8c8:	e58462e0 	str	r6, [r4, #736]	; 0x2e0
	gohci.hcca = phcca;
57e1e8cc:	e5840000 	str	r0, [r4]
	memset(phcca, 0, sizeof(struct ohci_hcca));
57e1e8d0:	eb001669 	bl	57e2427c <memset>

	gohci.disabled = 1;
	gohci.sleeping = 0;
	gohci.irq = -1;
57e1e8d4:	e3e03000 	mvn	r3, #0
57e1e8d8:	e5843004 	str	r3, [r4, #4]
		printf("OHCI regs address 0x%08x\n", base);
		gohci.regs = (struct ohci_regs *)base;
	} else
		return -1;
#else
	gohci.regs = (struct ohci_regs *)CONFIG_SYS_USB_OHCI_REGS_BASE;
57e1e8dc:	e59f30f8 	ldr	r3, [pc, #248]	; 57e1e9dc <usb_lowlevel_init+0x170>
	}
	ptd = gtd;
	gohci.hcca = phcca;
	memset(phcca, 0, sizeof(struct ohci_hcca));

	gohci.disabled = 1;
57e1e8e0:	e3a06001 	mov	r6, #1
		printf("OHCI regs address 0x%08x\n", base);
		gohci.regs = (struct ohci_regs *)base;
	} else
		return -1;
#else
	gohci.regs = (struct ohci_regs *)CONFIG_SYS_USB_OHCI_REGS_BASE;
57e1e8e4:	e5843014 	str	r3, [r4, #20]
#endif

	gohci.flags = 0;
	gohci.slot_name = CONFIG_SYS_USB_OHCI_SLOT_NAME;
57e1e8e8:	e59f30f0 	ldr	r3, [pc, #240]	; 57e1e9e0 <usb_lowlevel_init+0x174>
	}
	ptd = gtd;
	gohci.hcca = phcca;
	memset(phcca, 0, sizeof(struct ohci_hcca));

	gohci.disabled = 1;
57e1e8ec:	e5846008 	str	r6, [r4, #8]
	gohci.sleeping = 0;
57e1e8f0:	e584500c 	str	r5, [r4, #12]
		return -1;
#else
	gohci.regs = (struct ohci_regs *)CONFIG_SYS_USB_OHCI_REGS_BASE;
#endif

	gohci.flags = 0;
57e1e8f4:	e5845010 	str	r5, [r4, #16]
	gohci.slot_name = CONFIG_SYS_USB_OHCI_SLOT_NAME;
57e1e8f8:	e5843144 	str	r3, [r4, #324]	; 0x144

	if (hc_reset (&gohci) < 0) {
57e1e8fc:	ebfffb18 	bl	57e1d564 <hc_reset.clone.16>
57e1e900:	e3500000 	cmp	r0, #0
57e1e904:	aa00000a 	bge	57e1e934 <usb_lowlevel_init+0xc8>

static void hc_release_ohci(ohci_t *ohci)
{
	dbg("USB HC release ohci usb-%s", ohci->slot_name);

	if (!ohci->disabled)
57e1e908:	e5943008 	ldr	r3, [r4, #8]
57e1e90c:	e3530000 	cmp	r3, #0
57e1e910:	1a000000 	bne	57e1e918 <usb_lowlevel_init+0xac>
		hc_reset(ohci);
57e1e914:	ebfffb12 	bl	57e1d564 <hc_reset.clone.16>
	gohci.flags = 0;
	gohci.slot_name = CONFIG_SYS_USB_OHCI_SLOT_NAME;

	if (hc_reset (&gohci) < 0) {
		hc_release_ohci (&gohci);
		err ("can't reset usb-%s", gohci.slot_name);
57e1e918:	e59f30b8 	ldr	r3, [pc, #184]	; 57e1e9d8 <usb_lowlevel_init+0x16c>
57e1e91c:	e59f00c0 	ldr	r0, [pc, #192]	; 57e1e9e4 <usb_lowlevel_init+0x178>
57e1e920:	e5931144 	ldr	r1, [r3, #324]	; 0x144
57e1e924:	ebffaac8 	bl	57e0944c <printf>
		usb_board_init_fail();
#endif

#ifdef CONFIG_SYS_USB_OHCI_CPU_INIT
		/* cpu dependant cleanup */
		usb_cpu_init_fail();
57e1e928:	eb00004d 	bl	57e1ea64 <usb_cpu_init_fail>
#endif
		return -1;
57e1e92c:	e3e00000 	mvn	r0, #0
57e1e930:	e8bd8070 	pop	{r4, r5, r6, pc}
	ohci->disabled = 1;

	/* Tell the controller where the control and bulk lists are
	 * The lists are empty now. */

	ohci_writel(0, &ohci->regs->ed_controlhead);
57e1e934:	e5943014 	ldr	r3, [r4, #20]
	ohci_writel(0, &ohci->regs->ed_bulkhead);

	ohci_writel((__u32)ohci->hcca,
57e1e938:	e5942000 	ldr	r2, [r4]
	ohci->disabled = 1;

	/* Tell the controller where the control and bulk lists are
	 * The lists are empty now. */

	ohci_writel(0, &ohci->regs->ed_controlhead);
57e1e93c:	e5835020 	str	r5, [r3, #32]
	ohci_writel(0, &ohci->regs->ed_bulkhead);
57e1e940:	e5835028 	str	r5, [r3, #40]	; 0x28

	ohci_writel((__u32)ohci->hcca,
57e1e944:	e5832018 	str	r2, [r3, #24]
		    &ohci->regs->hcca); /* reset clears this */

	fminterval = 0x2edf;
	ohci_writel((fminterval * 9) / 10, &ohci->regs->periodicstart);
57e1e948:	e59f2098 	ldr	r2, [pc, #152]	; 57e1e9e8 <usb_lowlevel_init+0x17c>
		&ohci->regs->roothub.a);
	ohci_writel(RH_HS_LPSC, &ohci->regs->roothub.status);
#endif	/* OHCI_USE_NPS */

	/* POTPGT delay is bits 24-31, in 2 ms units. */
	mdelay((roothub_a(ohci) >> 23) & 0x1fe);
57e1e94c:	e59f0098 	ldr	r0, [pc, #152]	; 57e1e9ec <usb_lowlevel_init+0x180>

	ohci_writel((__u32)ohci->hcca,
		    &ohci->regs->hcca); /* reset clears this */

	fminterval = 0x2edf;
	ohci_writel((fminterval * 9) / 10, &ohci->regs->periodicstart);
57e1e950:	e5832040 	str	r2, [r3, #64]	; 0x40
	fminterval |= ((((fminterval - 210) * 6) / 7) << 16);
	ohci_writel(fminterval, &ohci->regs->fminterval);
57e1e954:	e59f2094 	ldr	r2, [pc, #148]	; 57e1e9f0 <usb_lowlevel_init+0x184>
57e1e958:	e5832034 	str	r2, [r3, #52]	; 0x34
	ohci_writel(0x628, &ohci->regs->lsthresh);
57e1e95c:	e59f2090 	ldr	r2, [pc, #144]	; 57e1e9f4 <usb_lowlevel_init+0x188>
57e1e960:	e5832044 	str	r2, [r3, #68]	; 0x44

	/* start controller operations */
	ohci->hc_control = OHCI_CONTROL_INIT | OHCI_USB_OPER;
57e1e964:	e3a0208f 	mov	r2, #143	; 0x8f
57e1e968:	e58420ac 	str	r2, [r4, #172]	; 0xac
	ohci->disabled = 0;
57e1e96c:	e5845008 	str	r5, [r4, #8]
	ohci_writel(ohci->hc_control, &ohci->regs->control);
57e1e970:	e5832004 	str	r2, [r3, #4]

	/* disable all interrupts */
	mask = (OHCI_INTR_SO | OHCI_INTR_WDH | OHCI_INTR_SF | OHCI_INTR_RD |
			OHCI_INTR_UE | OHCI_INTR_FNO | OHCI_INTR_RHSC |
			OHCI_INTR_OC | OHCI_INTR_MIE);
	ohci_writel(mask, &ohci->regs->intrdisable);
57e1e974:	e2422141 	sub	r2, r2, #1073741840	; 0x40000010
57e1e978:	e5832014 	str	r2, [r3, #20]
	/* clear all interrupts */
	mask &= ~OHCI_INTR_MIE;
	ohci_writel(mask, &ohci->regs->intrstatus);
57e1e97c:	e2822102 	add	r2, r2, #-2147483648	; 0x80000000
57e1e980:	e583200c 	str	r2, [r3, #12]
	/* Choose the interrupts we care about now  - but w/o MIE */
	mask = OHCI_INTR_RHSC | OHCI_INTR_UE | OHCI_INTR_WDH | OHCI_INTR_SO;
	ohci_writel(mask, &ohci->regs->intrenable);
57e1e984:	e3a02053 	mov	r2, #83	; 0x53
57e1e988:	e5832010 	str	r2, [r3, #16]
struct ohci_device ohci_dev;
/* device which was disconnected */
struct usb_device *devgone;

static inline u32 roothub_a(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.a); }
57e1e98c:	e5932048 	ldr	r2, [r3, #72]	; 0x48
	mask = OHCI_INTR_RHSC | OHCI_INTR_UE | OHCI_INTR_WDH | OHCI_INTR_SO;
	ohci_writel(mask, &ohci->regs->intrenable);

#ifdef	OHCI_USE_NPS
	/* required for AMD-756 and some Mac platforms */
	ohci_writel((roothub_a(ohci) | RH_A_NPS) & ~RH_A_PSM,
57e1e990:	e3c22c03 	bic	r2, r2, #768	; 0x300
57e1e994:	e3822c02 	orr	r2, r2, #512	; 0x200
57e1e998:	e5832048 	str	r2, [r3, #72]	; 0x48
		&ohci->regs->roothub.a);
	ohci_writel(RH_HS_LPSC, &ohci->regs->roothub.status);
57e1e99c:	e3a02801 	mov	r2, #65536	; 0x10000
57e1e9a0:	e5832050 	str	r2, [r3, #80]	; 0x50
struct ohci_device ohci_dev;
/* device which was disconnected */
struct usb_device *devgone;

static inline u32 roothub_a(struct ohci *hc)
	{ return ohci_readl(&hc->regs->roothub.a); }
57e1e9a4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
		&ohci->regs->roothub.a);
	ohci_writel(RH_HS_LPSC, &ohci->regs->roothub.status);
#endif	/* OHCI_USE_NPS */

	/* POTPGT delay is bits 24-31, in 2 ms units. */
	mdelay((roothub_a(ohci) >> 23) & 0x1fe);
57e1e9a8:	e1a03ba3 	lsr	r3, r3, #23
57e1e9ac:	e0030000 	and	r0, r3, r0
57e1e9b0:	eb0016ec 	bl	57e24568 <mdelay>
	}

#ifdef	DEBUG
	ohci_dump(&gohci, 1);
#else
	mdelay(1);
57e1e9b4:	e1a00006 	mov	r0, r6

	/* POTPGT delay is bits 24-31, in 2 ms units. */
	mdelay((roothub_a(ohci) >> 23) & 0x1fe);

	/* connect the virtual root hub */
	ohci->rh.devnum = 0;
57e1e9b8:	e5845130 	str	r5, [r4, #304]	; 0x130
	}

#ifdef	DEBUG
	ohci_dump(&gohci, 1);
#else
	mdelay(1);
57e1e9bc:	eb0016e9 	bl	57e24568 <mdelay>
#endif
	ohci_inited = 1;
57e1e9c0:	e59f3030 	ldr	r3, [pc, #48]	; 57e1e9f8 <usb_lowlevel_init+0x18c>
	return 0;
57e1e9c4:	e1a00005 	mov	r0, r5
#ifdef	DEBUG
	ohci_dump(&gohci, 1);
#else
	mdelay(1);
#endif
	ohci_inited = 1;
57e1e9c8:	e5436bb8 	strb	r6, [r3, #-3000]	; 0xbb8
	return 0;
57e1e9cc:	e8bd8070 	pop	{r4, r5, r6, pc}
#endif

#ifdef CONFIG_SYS_USB_OHCI_CPU_INIT
	/* cpu dependant init */
	if (usb_cpu_init())
		return -1;
57e1e9d0:	e3e00000 	mvn	r0, #0
#else
	mdelay(1);
#endif
	ohci_inited = 1;
	return 0;
}
57e1e9d4:	e8bd8070 	pop	{r4, r5, r6, pc}
57e1e9d8:	57e47a00 	.word	0x57e47a00
57e1e9dc:	74300000 	.word	0x74300000
57e1e9e0:	57e3487a 	.word	0x57e3487a
57e1e9e4:	57e34882 	.word	0x57e34882
57e1e9e8:	00002a2f 	.word	0x00002a2f
57e1e9ec:	000001fe 	.word	0x000001fe
57e1e9f0:	27782edf 	.word	0x27782edf
57e1e9f4:	00000628 	.word	0x00000628
57e1e9f8:	57e499f8 	.word	0x57e499f8

57e1e9fc <usb_lowlevel_stop>:

int usb_lowlevel_stop(int index)
{
57e1e9fc:	e92d4010 	push	{r4, lr}
	/* this gets called really early - before the controller has */
	/* even been initialized! */
	if (!ohci_inited)
57e1ea00:	e59f4020 	ldr	r4, [pc, #32]	; 57e1ea28 <usb_lowlevel_stop+0x2c>
57e1ea04:	e5540bb8 	ldrb	r0, [r4, #-3000]	; 0xbb8
57e1ea08:	e3500000 	cmp	r0, #0
57e1ea0c:	08bd8010 	popeq	{r4, pc}
		return 0;
	/* TODO release any interrupts, etc. */
	/* call hc_release_ohci() here ? */
	hc_reset(&gohci);
57e1ea10:	ebfffad3 	bl	57e1d564 <hc_reset.clone.16>
		return -1;
#endif

#ifdef CONFIG_SYS_USB_OHCI_CPU_INIT
	/* cpu dependant cleanup */
	if (usb_cpu_stop())
57e1ea14:	eb00000b 	bl	57e1ea48 <usb_cpu_stop>
57e1ea18:	e3500000 	cmp	r0, #0
		return -1;
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
57e1ea1c:	05440bb8 	strbeq	r0, [r4, #-3000]	; 0xbb8
#endif

#ifdef CONFIG_SYS_USB_OHCI_CPU_INIT
	/* cpu dependant cleanup */
	if (usb_cpu_stop())
		return -1;
57e1ea20:	13e00000 	mvnne	r0, #0
#endif
	/* This driver is no longer initialised. It needs a new low-level
	 * init (board/cpu) before it can be used again. */
	ohci_inited = 0;
	return 0;
}
57e1ea24:	e8bd8010 	pop	{r4, pc}
57e1ea28:	57e499f8 	.word	0x57e499f8

57e1ea2c <usb_cpu_init>:
#include <common.h>
#include <asm/arch/s3c6400.h>

int usb_cpu_init(void)
{
	OTHERS_REG |= 0x10000;
57e1ea2c:	e59f3010 	ldr	r3, [pc, #16]	; 57e1ea44 <usb_cpu_init+0x18>
	return 0;
}
57e1ea30:	e3a00000 	mov	r0, #0
#include <common.h>
#include <asm/arch/s3c6400.h>

int usb_cpu_init(void)
{
	OTHERS_REG |= 0x10000;
57e1ea34:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
57e1ea38:	e3822801 	orr	r2, r2, #65536	; 0x10000
57e1ea3c:	e5832900 	str	r2, [r3, #2304]	; 0x900
	return 0;
}
57e1ea40:	e12fff1e 	bx	lr
57e1ea44:	7e00f000 	.word	0x7e00f000

57e1ea48 <usb_cpu_stop>:

int usb_cpu_stop(void)
{
	OTHERS_REG &= ~0x10000;
57e1ea48:	e59f3010 	ldr	r3, [pc, #16]	; 57e1ea60 <usb_cpu_stop+0x18>
	return 0;
}
57e1ea4c:	e3a00000 	mov	r0, #0
	return 0;
}

int usb_cpu_stop(void)
{
	OTHERS_REG &= ~0x10000;
57e1ea50:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
57e1ea54:	e3c22801 	bic	r2, r2, #65536	; 0x10000
57e1ea58:	e5832900 	str	r2, [r3, #2304]	; 0x900
	return 0;
}
57e1ea5c:	e12fff1e 	bx	lr
57e1ea60:	7e00f000 	.word	0x7e00f000

57e1ea64 <usb_cpu_init_fail>:

void usb_cpu_init_fail(void)
{
	OTHERS_REG &= ~0x10000;
57e1ea64:	e59f300c 	ldr	r3, [pc, #12]	; 57e1ea78 <usb_cpu_init_fail+0x14>
57e1ea68:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
57e1ea6c:	e3c22801 	bic	r2, r2, #65536	; 0x10000
57e1ea70:	e5832900 	str	r2, [r3, #2304]	; 0x900
}
57e1ea74:	e12fff1e 	bx	lr
57e1ea78:	7e00f000 	.word	0x7e00f000

57e1ea7c <get_fs>:
struct ext_filesystem ext_fs;

struct ext_filesystem *get_fs(void)
{
	return &ext_fs;
}
57e1ea7c:	e59f0000 	ldr	r0, [pc, #0]	; 57e1ea84 <get_fs+0x8>
57e1ea80:	e12fff1e 	bx	lr
57e1ea84:	57e48f00 	.word	0x57e48f00

57e1ea88 <ext4fs_free_node>:

void ext4fs_free_node(struct ext2fs_node *node, struct ext2fs_node *currroot)
{
	if ((node != &ext4fs_root->diropen) && (node != currroot))
57e1ea88:	e59f3014 	ldr	r3, [pc, #20]	; 57e1eaa4 <ext4fs_free_node+0x1c>
57e1ea8c:	e5933000 	ldr	r3, [r3]
57e1ea90:	e28330d0 	add	r3, r3, #208	; 0xd0
57e1ea94:	e1500001 	cmp	r0, r1
57e1ea98:	11530000 	cmpne	r3, r0
57e1ea9c:	012fff1e 	bxeq	lr
		free(node);
57e1eaa0:	eaffabbd 	b	57e0999c <free>
57e1eaa4:	57e48f50 	.word	0x57e48f50

57e1eaa8 <ext4fs_read_file>:
 * Optimized read file API : collects and defers contiguous sector
 * reads into one potentially more efficient larger sequential read action
 */
int ext4fs_read_file(struct ext2fs_node *node, int pos,
		unsigned int len, char *buf)
{
57e1eaa8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1eaac:	e24dd038 	sub	sp, sp, #56	; 0x38
57e1eab0:	e58d3014 	str	r3, [sp, #20]
	int i;
	int blockcnt;
	int log2blocksize = LOG2_EXT2_BLOCK_SIZE(node->data);
57e1eab4:	e5903000 	ldr	r3, [r0]
 * Optimized read file API : collects and defers contiguous sector
 * reads into one potentially more efficient larger sequential read action
 */
int ext4fs_read_file(struct ext2fs_node *node, int pos,
		unsigned int len, char *buf)
{
57e1eab8:	e1a06000 	mov	r6, r0
	int i;
	int blockcnt;
	int log2blocksize = LOG2_EXT2_BLOCK_SIZE(node->data);
57e1eabc:	e5935018 	ldr	r5, [r3, #24]
 * Optimized read file API : collects and defers contiguous sector
 * reads into one potentially more efficient larger sequential read action
 */
int ext4fs_read_file(struct ext2fs_node *node, int pos,
		unsigned int len, char *buf)
{
57e1eac0:	e58d1018 	str	r1, [sp, #24]
	int i;
	int blockcnt;
	int log2blocksize = LOG2_EXT2_BLOCK_SIZE(node->data);
57e1eac4:	e2853001 	add	r3, r5, #1
57e1eac8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	int blocksize = 1 << (log2blocksize + DISK_SECTOR_BITS);
57e1eacc:	e285500a 	add	r5, r5, #10
57e1ead0:	e3a03001 	mov	r3, #1
57e1ead4:	e1a05513 	lsl	r5, r3, r5
57e1ead8:	e5903008 	ldr	r3, [r0, #8]

	/* Adjust len so it we can't read past the end of the file. */
	if (len > filesize)
		len = filesize;

	blockcnt = ((len + pos) + blocksize - 1) / blocksize;
57e1eadc:	e2450001 	sub	r0, r5, #1
		unsigned int len, char *buf)
{
	int i;
	int blockcnt;
	int log2blocksize = LOG2_EXT2_BLOCK_SIZE(node->data);
	int blocksize = 1 << (log2blocksize + DISK_SECTOR_BITS);
57e1eae0:	e1520003 	cmp	r2, r3
57e1eae4:	21a02003 	movcs	r2, r3
57e1eae8:	e58d201c 	str	r2, [sp, #28]

	/* Adjust len so it we can't read past the end of the file. */
	if (len > filesize)
		len = filesize;

	blockcnt = ((len + pos) + blocksize - 1) / blocksize;
57e1eaec:	e0822001 	add	r2, r2, r1
57e1eaf0:	e0800002 	add	r0, r0, r2
57e1eaf4:	e1a01005 	mov	r1, r5
57e1eaf8:	e58d2020 	str	r2, [sp, #32]
57e1eafc:	eb00332b 	bl	57e2b7b0 <__udivsi3>

	for (i = pos / blocksize; i < blockcnt; i++) {
57e1eb00:	e1a01005 	mov	r1, r5

	/* Adjust len so it we can't read past the end of the file. */
	if (len > filesize)
		len = filesize;

	blockcnt = ((len + pos) + blocksize - 1) / blocksize;
57e1eb04:	e58d0024 	str	r0, [sp, #36]	; 0x24

	for (i = pos / blocksize; i < blockcnt; i++) {
57e1eb08:	e59d0018 	ldr	r0, [sp, #24]
57e1eb0c:	eb0033aa 	bl	57e2b9bc <__divsi3>
			return -1;

		blknr = blknr << log2blocksize;

		/* Last block.  */
		if (i == blockcnt - 1) {
57e1eb10:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
	int i;
	int blockcnt;
	int log2blocksize = LOG2_EXT2_BLOCK_SIZE(node->data);
	int blocksize = 1 << (log2blocksize + DISK_SECTOR_BITS);
	unsigned int filesize = __le32_to_cpu(node->inode.size);
	int previous_block_number = -1;
57e1eb14:	e3e0b000 	mvn	fp, #0
	int delayed_start = 0;
	int delayed_extent = 0;
	int delayed_skipfirst = 0;
	int delayed_next = 0;
	char *delayed_buf = NULL;
57e1eb18:	e3a04000 	mov	r4, #0
	for (i = pos / blocksize; i < blockcnt; i++) {
		int blknr;
		int blockoff = pos % blocksize;
		int blockend = blocksize;
		int skipfirst = 0;
		blknr = read_allocated_block(&(node->inode), i);
57e1eb1c:	e2866004 	add	r6, r6, #4
			return -1;

		blknr = blknr << log2blocksize;

		/* Last block.  */
		if (i == blockcnt - 1) {
57e1eb20:	e083300b 	add	r3, r3, fp
	for (i = pos / blocksize; i < blockcnt; i++) {
		int blknr;
		int blockoff = pos % blocksize;
		int blockend = blocksize;
		int skipfirst = 0;
		blknr = read_allocated_block(&(node->inode), i);
57e1eb24:	e58d6030 	str	r6, [sp, #48]	; 0x30
	if (len > filesize)
		len = filesize;

	blockcnt = ((len + pos) + blocksize - 1) / blocksize;

	for (i = pos / blocksize; i < blockcnt; i++) {
57e1eb28:	e58d0028 	str	r0, [sp, #40]	; 0x28
57e1eb2c:	e58d0008 	str	r0, [sp, #8]
	unsigned int filesize = __le32_to_cpu(node->inode.size);
	int previous_block_number = -1;
	int delayed_start = 0;
	int delayed_extent = 0;
	int delayed_skipfirst = 0;
	int delayed_next = 0;
57e1eb30:	e58d4010 	str	r4, [sp, #16]
	int blocksize = 1 << (log2blocksize + DISK_SECTOR_BITS);
	unsigned int filesize = __le32_to_cpu(node->inode.size);
	int previous_block_number = -1;
	int delayed_start = 0;
	int delayed_extent = 0;
	int delayed_skipfirst = 0;
57e1eb34:	e58d400c 	str	r4, [sp, #12]
	int log2blocksize = LOG2_EXT2_BLOCK_SIZE(node->data);
	int blocksize = 1 << (log2blocksize + DISK_SECTOR_BITS);
	unsigned int filesize = __le32_to_cpu(node->inode.size);
	int previous_block_number = -1;
	int delayed_start = 0;
	int delayed_extent = 0;
57e1eb38:	e1a0a004 	mov	sl, r4
	int blockcnt;
	int log2blocksize = LOG2_EXT2_BLOCK_SIZE(node->data);
	int blocksize = 1 << (log2blocksize + DISK_SECTOR_BITS);
	unsigned int filesize = __le32_to_cpu(node->inode.size);
	int previous_block_number = -1;
	int delayed_start = 0;
57e1eb3c:	e1a07004 	mov	r7, r4
			return -1;

		blknr = blknr << log2blocksize;

		/* Last block.  */
		if (i == blockcnt - 1) {
57e1eb40:	e58d3034 	str	r3, [sp, #52]	; 0x34
57e1eb44:	e1a06004 	mov	r6, r4
	if (len > filesize)
		len = filesize;

	blockcnt = ((len + pos) + blocksize - 1) / blocksize;

	for (i = pos / blocksize; i < blockcnt; i++) {
57e1eb48:	ea000052 	b	57e1ec98 <ext4fs_read_file+0x1f0>
		int blknr;
		int blockoff = pos % blocksize;
		int blockend = blocksize;
		int skipfirst = 0;
		blknr = read_allocated_block(&(node->inode), i);
57e1eb4c:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
57e1eb50:	e59d1008 	ldr	r1, [sp, #8]
57e1eb54:	eb0000ce 	bl	57e1ee94 <read_allocated_block>
		if (blknr < 0)
57e1eb58:	e3500000 	cmp	r0, #0
57e1eb5c:	ba00005d 	blt	57e1ecd8 <ext4fs_read_file+0x230>
			return -1;

		blknr = blknr << log2blocksize;
57e1eb60:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c

		/* Last block.  */
		if (i == blockcnt - 1) {
57e1eb64:	e59d3008 	ldr	r3, [sp, #8]
		int skipfirst = 0;
		blknr = read_allocated_block(&(node->inode), i);
		if (blknr < 0)
			return -1;

		blknr = blknr << log2blocksize;
57e1eb68:	e1a09210 	lsl	r9, r0, r2

		/* Last block.  */
		if (i == blockcnt - 1) {
57e1eb6c:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
57e1eb70:	e1530002 	cmp	r3, r2
	blockcnt = ((len + pos) + blocksize - 1) / blocksize;

	for (i = pos / blocksize; i < blockcnt; i++) {
		int blknr;
		int blockoff = pos % blocksize;
		int blockend = blocksize;
57e1eb74:	11a04005 	movne	r4, r5
			return -1;

		blknr = blknr << log2blocksize;

		/* Last block.  */
		if (i == blockcnt - 1) {
57e1eb78:	1a000005 	bne	57e1eb94 <ext4fs_read_file+0xec>
			blockend = (len + pos) % blocksize;
57e1eb7c:	e59d0020 	ldr	r0, [sp, #32]
57e1eb80:	e1a01005 	mov	r1, r5
57e1eb84:	eb003384 	bl	57e2b99c <__aeabi_uidivmod>

			/* The last portion is exactly blocksize. */
			if (!blockend)
				blockend = blocksize;
57e1eb88:	e3510000 	cmp	r1, #0
57e1eb8c:	11a04001 	movne	r4, r1
57e1eb90:	01a04005 	moveq	r4, r5
		}

		/* First block. */
		if (i == pos / blocksize) {
57e1eb94:	e59d3008 	ldr	r3, [sp, #8]
57e1eb98:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
57e1eb9c:	e1530002 	cmp	r3, r2

	for (i = pos / blocksize; i < blockcnt; i++) {
		int blknr;
		int blockoff = pos % blocksize;
		int blockend = blocksize;
		int skipfirst = 0;
57e1eba0:	13a0c000 	movne	ip, #0
			if (!blockend)
				blockend = blocksize;
		}

		/* First block. */
		if (i == pos / blocksize) {
57e1eba4:	1a000004 	bne	57e1ebbc <ext4fs_read_file+0x114>

	blockcnt = ((len + pos) + blocksize - 1) / blocksize;

	for (i = pos / blocksize; i < blockcnt; i++) {
		int blknr;
		int blockoff = pos % blocksize;
57e1eba8:	e59d0018 	ldr	r0, [sp, #24]
57e1ebac:	e1a01005 	mov	r1, r5
57e1ebb0:	eb003409 	bl	57e2bbdc <__aeabi_idivmod>
		}

		/* First block. */
		if (i == pos / blocksize) {
			skipfirst = blockoff;
			blockend -= skipfirst;
57e1ebb4:	e0614004 	rsb	r4, r1, r4
				blockend = blocksize;
		}

		/* First block. */
		if (i == pos / blocksize) {
			skipfirst = blockoff;
57e1ebb8:	e1a0c001 	mov	ip, r1
			blockend -= skipfirst;
		}
		if (blknr) {
57e1ebbc:	e3590000 	cmp	r9, #0
57e1ebc0:	0a00001b 	beq	57e1ec34 <ext4fs_read_file+0x18c>
			int status;

			if (previous_block_number != -1) {
57e1ebc4:	e37b0001 	cmn	fp, #1
57e1ebc8:	0a000011 	beq	57e1ec14 <ext4fs_read_file+0x16c>
				if (delayed_next == blknr) {
57e1ebcc:	e59d3010 	ldr	r3, [sp, #16]
57e1ebd0:	e1530009 	cmp	r3, r9
					delayed_extent += blockend;
					delayed_next += blockend >> SECTOR_BITS;
57e1ebd4:	008334c4 	addeq	r3, r3, r4, asr #9
		if (blknr) {
			int status;

			if (previous_block_number != -1) {
				if (delayed_next == blknr) {
					delayed_extent += blockend;
57e1ebd8:	008aa004 	addeq	sl, sl, r4
					delayed_next += blockend >> SECTOR_BITS;
57e1ebdc:	058d3010 	streq	r3, [sp, #16]
		}
		if (blknr) {
			int status;

			if (previous_block_number != -1) {
				if (delayed_next == blknr) {
57e1ebe0:	0a000025 	beq	57e1ec7c <ext4fs_read_file+0x1d4>
					delayed_extent += blockend;
					delayed_next += blockend >> SECTOR_BITS;
				} else {	/* spill */
					status = ext4fs_devread(delayed_start,
57e1ebe4:	e1a00007 	mov	r0, r7
57e1ebe8:	e59d100c 	ldr	r1, [sp, #12]
57e1ebec:	e1a0200a 	mov	r2, sl
57e1ebf0:	e1a03006 	mov	r3, r6
57e1ebf4:	e58dc004 	str	ip, [sp, #4]
57e1ebf8:	eb0004f5 	bl	57e1ffd4 <ext4fs_devread>
							delayed_skipfirst,
							delayed_extent,
							delayed_buf);
					if (status == 0)
57e1ebfc:	e3500000 	cmp	r0, #0
57e1ec00:	e59dc004 	ldr	ip, [sp, #4]
57e1ec04:	0a000033 	beq	57e1ecd8 <ext4fs_read_file+0x230>
					previous_block_number = blknr;
					delayed_start = blknr;
					delayed_extent = blockend;
					delayed_skipfirst = skipfirst;
					delayed_buf = buf;
					delayed_next = blknr +
57e1ec08:	e08924c4 	add	r2, r9, r4, asr #9
57e1ec0c:	e58d2010 	str	r2, [sp, #16]
57e1ec10:	ea000001 	b	57e1ec1c <ext4fs_read_file+0x174>
				previous_block_number = blknr;
				delayed_start = blknr;
				delayed_extent = blockend;
				delayed_skipfirst = skipfirst;
				delayed_buf = buf;
				delayed_next = blknr +
57e1ec14:	e08934c4 	add	r3, r9, r4, asr #9
57e1ec18:	e58d3010 	str	r3, [sp, #16]
			} else {
				previous_block_number = blknr;
				delayed_start = blknr;
				delayed_extent = blockend;
				delayed_skipfirst = skipfirst;
				delayed_buf = buf;
57e1ec1c:	e59d6014 	ldr	r6, [sp, #20]
				}
			} else {
				previous_block_number = blknr;
				delayed_start = blknr;
				delayed_extent = blockend;
				delayed_skipfirst = skipfirst;
57e1ec20:	e58dc00c 	str	ip, [sp, #12]
						(blockend >> SECTOR_BITS);
				}
			} else {
				previous_block_number = blknr;
				delayed_start = blknr;
				delayed_extent = blockend;
57e1ec24:	e1a0a004 	mov	sl, r4
				delayed_skipfirst = skipfirst;
				delayed_buf = buf;
				delayed_next = blknr +
57e1ec28:	e1a07009 	mov	r7, r9
57e1ec2c:	e1a0b009 	mov	fp, r9
57e1ec30:	ea000011 	b	57e1ec7c <ext4fs_read_file+0x1d4>
					(blockend >> SECTOR_BITS);
			}
		} else {
			if (previous_block_number != -1) {
57e1ec34:	e37b0001 	cmn	fp, #1
57e1ec38:	0a000008 	beq	57e1ec60 <ext4fs_read_file+0x1b8>
				/* spill */
				status = ext4fs_devread(delayed_start,
57e1ec3c:	e1a00007 	mov	r0, r7
57e1ec40:	e59d100c 	ldr	r1, [sp, #12]
57e1ec44:	e1a0200a 	mov	r2, sl
57e1ec48:	e1a03006 	mov	r3, r6
57e1ec4c:	e58dc004 	str	ip, [sp, #4]
57e1ec50:	eb0004df 	bl	57e1ffd4 <ext4fs_devread>
							delayed_skipfirst,
							delayed_extent,
							delayed_buf);
				if (status == 0)
57e1ec54:	e1b00800 	lsls	r0, r0, #16
57e1ec58:	e59dc004 	ldr	ip, [sp, #4]
57e1ec5c:	0a00001d 	beq	57e1ecd8 <ext4fs_read_file+0x230>
					return -1;
				previous_block_number = -1;
			}
			memset(buf, 0, blocksize - skipfirst);
57e1ec60:	e06c2005 	rsb	r2, ip, r5
57e1ec64:	e59d0014 	ldr	r0, [sp, #20]
57e1ec68:	e3a01000 	mov	r1, #0
57e1ec6c:	e58dc004 	str	ip, [sp, #4]
57e1ec70:	eb001581 	bl	57e2427c <memset>
57e1ec74:	e59dc004 	ldr	ip, [sp, #4]
57e1ec78:	e3e0b000 	mvn	fp, #0
		}
		buf += blocksize - skipfirst;
57e1ec7c:	e59d2014 	ldr	r2, [sp, #20]
	if (len > filesize)
		len = filesize;

	blockcnt = ((len + pos) + blocksize - 1) / blocksize;

	for (i = pos / blocksize; i < blockcnt; i++) {
57e1ec80:	e59d3008 	ldr	r3, [sp, #8]
					return -1;
				previous_block_number = -1;
			}
			memset(buf, 0, blocksize - skipfirst);
		}
		buf += blocksize - skipfirst;
57e1ec84:	e06cc005 	rsb	ip, ip, r5
57e1ec88:	e082200c 	add	r2, r2, ip
	if (len > filesize)
		len = filesize;

	blockcnt = ((len + pos) + blocksize - 1) / blocksize;

	for (i = pos / blocksize; i < blockcnt; i++) {
57e1ec8c:	e2833001 	add	r3, r3, #1
					return -1;
				previous_block_number = -1;
			}
			memset(buf, 0, blocksize - skipfirst);
		}
		buf += blocksize - skipfirst;
57e1ec90:	e58d2014 	str	r2, [sp, #20]
	if (len > filesize)
		len = filesize;

	blockcnt = ((len + pos) + blocksize - 1) / blocksize;

	for (i = pos / blocksize; i < blockcnt; i++) {
57e1ec94:	e58d3008 	str	r3, [sp, #8]
57e1ec98:	e59d2008 	ldr	r2, [sp, #8]
57e1ec9c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e1eca0:	e1520003 	cmp	r2, r3
57e1eca4:	baffffa8 	blt	57e1eb4c <ext4fs_read_file+0xa4>
			}
			memset(buf, 0, blocksize - skipfirst);
		}
		buf += blocksize - skipfirst;
	}
	if (previous_block_number != -1) {
57e1eca8:	e37b0001 	cmn	fp, #1
57e1ecac:	e1a04006 	mov	r4, r6
57e1ecb0:	0a000006 	beq	57e1ecd0 <ext4fs_read_file+0x228>
		/* spill */
		status = ext4fs_devread(delayed_start,
57e1ecb4:	e1a00007 	mov	r0, r7
57e1ecb8:	e59d100c 	ldr	r1, [sp, #12]
57e1ecbc:	e1a0200a 	mov	r2, sl
57e1ecc0:	e1a03006 	mov	r3, r6
57e1ecc4:	eb0004c2 	bl	57e1ffd4 <ext4fs_devread>
					delayed_skipfirst, delayed_extent,
					delayed_buf);
		if (status == 0)
57e1ecc8:	e1b00800 	lsls	r0, r0, #16
57e1eccc:	0a000001 	beq	57e1ecd8 <ext4fs_read_file+0x230>
			return -1;
		previous_block_number = -1;
	}

	return len;
57e1ecd0:	e59d001c 	ldr	r0, [sp, #28]
57e1ecd4:	ea000000 	b	57e1ecdc <ext4fs_read_file+0x234>
		/* spill */
		status = ext4fs_devread(delayed_start,
					delayed_skipfirst, delayed_extent,
					delayed_buf);
		if (status == 0)
			return -1;
57e1ecd8:	e3e00000 	mvn	r0, #0
		previous_block_number = -1;
	}

	return len;
}
57e1ecdc:	e28dd038 	add	sp, sp, #56	; 0x38
57e1ece0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e1ece4 <ext4fs_ls>:
int ext4fs_ls(const char *dirname)
{
	struct ext2fs_node *dirnode;
	int status;

	if (dirname == NULL)
57e1ece4:	e2503000 	subs	r3, r0, #0

	return len;
}

int ext4fs_ls(const char *dirname)
{
57e1ece8:	e92d4013 	push	{r0, r1, r4, lr}
	struct ext2fs_node *dirnode;
	int status;

	if (dirname == NULL)
		return 0;
57e1ecec:	01a00003 	moveq	r0, r3
int ext4fs_ls(const char *dirname)
{
	struct ext2fs_node *dirnode;
	int status;

	if (dirname == NULL)
57e1ecf0:	0a000015 	beq	57e1ed4c <ext4fs_ls+0x68>
		return 0;

	status = ext4fs_find_file(dirname, &ext4fs_root->diropen, &dirnode,
57e1ecf4:	e59f4054 	ldr	r4, [pc, #84]	; 57e1ed50 <ext4fs_ls+0x6c>
57e1ecf8:	e28d2004 	add	r2, sp, #4
57e1ecfc:	e5941000 	ldr	r1, [r4]
57e1ed00:	e3a03002 	mov	r3, #2
57e1ed04:	e28110d0 	add	r1, r1, #208	; 0xd0
57e1ed08:	eb000425 	bl	57e1fda4 <ext4fs_find_file>
				  FILETYPE_DIRECTORY);
	if (status != 1) {
57e1ed0c:	e3500001 	cmp	r0, #1
57e1ed10:	0a000003 	beq	57e1ed24 <ext4fs_ls+0x40>
		printf("** Can not find directory. **\n");
57e1ed14:	e59f0038 	ldr	r0, [pc, #56]	; 57e1ed54 <ext4fs_ls+0x70>
57e1ed18:	ebffa9cb 	bl	57e0944c <printf>
		return 1;
57e1ed1c:	e3a00001 	mov	r0, #1
57e1ed20:	ea000009 	b	57e1ed4c <ext4fs_ls+0x68>
	}

	ext4fs_iterate_dir(dirnode, NULL, NULL, NULL);
57e1ed24:	e3a01000 	mov	r1, #0
57e1ed28:	e1a02001 	mov	r2, r1
57e1ed2c:	e1a03001 	mov	r3, r1
57e1ed30:	e59d0004 	ldr	r0, [sp, #4]
57e1ed34:	eb0002ca 	bl	57e1f864 <ext4fs_iterate_dir>
	ext4fs_free_node(dirnode, &ext4fs_root->diropen);
57e1ed38:	e5941000 	ldr	r1, [r4]
57e1ed3c:	e59d0004 	ldr	r0, [sp, #4]
57e1ed40:	e28110d0 	add	r1, r1, #208	; 0xd0
57e1ed44:	ebffff4f 	bl	57e1ea88 <ext4fs_free_node>

	return 0;
57e1ed48:	e3a00000 	mov	r0, #0
}
57e1ed4c:	e8bd801c 	pop	{r2, r3, r4, pc}
57e1ed50:	57e48f50 	.word	0x57e48f50
57e1ed54:	57e34e1b 	.word	0x57e34e1b

57e1ed58 <ext4fs_read>:

int ext4fs_read(char *buf, unsigned len)
{
57e1ed58:	e1a02001 	mov	r2, r1
	if (ext4fs_root == NULL || ext4fs_file == NULL)
57e1ed5c:	e59f1024 	ldr	r1, [pc, #36]	; 57e1ed88 <ext4fs_read+0x30>

	return 0;
}

int ext4fs_read(char *buf, unsigned len)
{
57e1ed60:	e1a03000 	mov	r3, r0
	if (ext4fs_root == NULL || ext4fs_file == NULL)
57e1ed64:	e5910000 	ldr	r0, [r1]
57e1ed68:	e3500000 	cmp	r0, #0
57e1ed6c:	012fff1e 	bxeq	lr
57e1ed70:	e59f1014 	ldr	r1, [pc, #20]	; 57e1ed8c <ext4fs_read+0x34>
57e1ed74:	e5910000 	ldr	r0, [r1]
57e1ed78:	e3500000 	cmp	r0, #0
57e1ed7c:	012fff1e 	bxeq	lr
		return 0;

	return ext4fs_read_file(ext4fs_file, 0, len, buf);
57e1ed80:	e3a01000 	mov	r1, #0
57e1ed84:	eaffff47 	b	57e1eaa8 <ext4fs_read_file>
57e1ed88:	57e48f50 	.word	0x57e48f50
57e1ed8c:	57e48f6c 	.word	0x57e48f6c

57e1ed90 <ext4fs_read_inode>:
			      blkoff, sizeof(struct ext2_block_group),
			      (char *)blkgrp);
}

int ext4fs_read_inode(struct ext2_data *data, int ino, struct ext2_inode *inode)
{
57e1ed90:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1ed94:	e24dd028 	sub	sp, sp, #40	; 0x28
57e1ed98:	e58d2004 	str	r2, [sp, #4]
57e1ed9c:	e1a04000 	mov	r4, r0
57e1eda0:	e1a05001 	mov	r5, r1
	struct ext2_block_group blkgrp;
	struct ext2_sblock *sblock = &data->sblock;
	struct ext_filesystem *fs = get_fs();
57e1eda4:	ebffff34 	bl	57e1ea7c <get_fs>
	int inodes_per_block, status;
	long int blkno;
	unsigned int blkoff;

	/* It is easier to calculate if the first inode is 0. */
	ino--;
57e1eda8:	e2455001 	sub	r5, r5, #1

int ext4fs_read_inode(struct ext2_data *data, int ino, struct ext2_inode *inode)
{
	struct ext2_block_group blkgrp;
	struct ext2_sblock *sblock = &data->sblock;
	struct ext_filesystem *fs = get_fs();
57e1edac:	e1a0c000 	mov	ip, r0
	long int blkno;
	unsigned int blkoff;

	/* It is easier to calculate if the first inode is 0. */
	ino--;
	status = ext4fs_blockgroup(data, ino / __le32_to_cpu
57e1edb0:	e5941028 	ldr	r1, [r4, #40]	; 0x28
57e1edb4:	e1a00005 	mov	r0, r5
57e1edb8:	e58dc000 	str	ip, [sp]
57e1edbc:	eb00327b 	bl	57e2b7b0 <__udivsi3>
	(struct ext2_data *data, int group, struct ext2_block_group *blkgrp)
{
	long int blkno;
	unsigned int blkoff, desc_per_blk;

	desc_per_blk = EXT2_BLOCK_SIZE(data) / sizeof(struct ext2_block_group);
57e1edc0:	e594a018 	ldr	sl, [r4, #24]
57e1edc4:	e3a06001 	mov	r6, #1
57e1edc8:	e28a700a 	add	r7, sl, #10
57e1edcc:	e1a07716 	lsl	r7, r6, r7
57e1edd0:	e1a072a7 	lsr	r7, r7, #5

	blkno = __le32_to_cpu(data->sblock.first_data_block) + 1 +
			group / desc_per_blk;
57e1edd4:	e1a01007 	mov	r1, r7
	long int blkno;
	unsigned int blkoff;

	/* It is easier to calculate if the first inode is 0. */
	ino--;
	status = ext4fs_blockgroup(data, ino / __le32_to_cpu
57e1edd8:	e1a09000 	mov	r9, r0
	unsigned int blkoff, desc_per_blk;

	desc_per_blk = EXT2_BLOCK_SIZE(data) / sizeof(struct ext2_block_group);

	blkno = __le32_to_cpu(data->sblock.first_data_block) + 1 +
			group / desc_per_blk;
57e1eddc:	eb003273 	bl	57e2b7b0 <__udivsi3>
	long int blkno;
	unsigned int blkoff, desc_per_blk;

	desc_per_blk = EXT2_BLOCK_SIZE(data) / sizeof(struct ext2_block_group);

	blkno = __le32_to_cpu(data->sblock.first_data_block) + 1 +
57e1ede0:	e594b014 	ldr	fp, [r4, #20]
	blkoff = (group % desc_per_blk) * sizeof(struct ext2_block_group);

	debug("ext4fs read %d group descriptor (blkno %ld blkoff %u)\n",
	      group, blkno, blkoff);

	return ext4fs_devread(blkno << LOG2_EXT2_BLOCK_SIZE(data),
57e1ede4:	e08aa006 	add	sl, sl, r6
	long int blkno;
	unsigned int blkoff, desc_per_blk;

	desc_per_blk = EXT2_BLOCK_SIZE(data) / sizeof(struct ext2_block_group);

	blkno = __le32_to_cpu(data->sblock.first_data_block) + 1 +
57e1ede8:	e08bb006 	add	fp, fp, r6
57e1edec:	e08bb000 	add	fp, fp, r0
			group / desc_per_blk;
	blkoff = (group % desc_per_blk) * sizeof(struct ext2_block_group);
57e1edf0:	e1a01007 	mov	r1, r7
57e1edf4:	e1a00009 	mov	r0, r9
57e1edf8:	eb0032e7 	bl	57e2b99c <__aeabi_uidivmod>

	debug("ext4fs read %d group descriptor (blkno %ld blkoff %u)\n",
	      group, blkno, blkoff);

	return ext4fs_devread(blkno << LOG2_EXT2_BLOCK_SIZE(data),
57e1edfc:	e1a0aa1b 	lsl	sl, fp, sl
57e1ee00:	e1a01281 	lsl	r1, r1, #5
57e1ee04:	e1a0000a 	mov	r0, sl
57e1ee08:	e3a02020 	mov	r2, #32
57e1ee0c:	e28d3008 	add	r3, sp, #8
57e1ee10:	eb00046f 	bl	57e1ffd4 <ext4fs_devread>

	/* It is easier to calculate if the first inode is 0. */
	ino--;
	status = ext4fs_blockgroup(data, ino / __le32_to_cpu
				   (sblock->inodes_per_group), &blkgrp);
	if (status == 0)
57e1ee14:	e3500000 	cmp	r0, #0
57e1ee18:	e59dc000 	ldr	ip, [sp]
57e1ee1c:	0a00001a 	beq	57e1ee8c <ext4fs_read_inode+0xfc>
		return 0;

	inodes_per_block = EXT2_BLOCK_SIZE(data) / fs->inodesz;
57e1ee20:	e594a018 	ldr	sl, [r4, #24]
57e1ee24:	e59c700c 	ldr	r7, [ip, #12]
57e1ee28:	e28a000a 	add	r0, sl, #10
57e1ee2c:	e1a00016 	lsl	r0, r6, r0
57e1ee30:	e1a01007 	mov	r1, r7
57e1ee34:	eb00325d 	bl	57e2b7b0 <__udivsi3>
	blkno = __le32_to_cpu(blkgrp.inode_table_id) +
	    (ino % __le32_to_cpu(sblock->inodes_per_group)) / inodes_per_block;
57e1ee38:	e5941028 	ldr	r1, [r4, #40]	; 0x28
	status = ext4fs_blockgroup(data, ino / __le32_to_cpu
				   (sblock->inodes_per_group), &blkgrp);
	if (status == 0)
		return 0;

	inodes_per_block = EXT2_BLOCK_SIZE(data) / fs->inodesz;
57e1ee3c:	e1a06000 	mov	r6, r0
	blkno = __le32_to_cpu(blkgrp.inode_table_id) +
	    (ino % __le32_to_cpu(sblock->inodes_per_group)) / inodes_per_block;
57e1ee40:	e1a00005 	mov	r0, r5
57e1ee44:	eb0032d4 	bl	57e2b99c <__aeabi_uidivmod>
57e1ee48:	e1a00001 	mov	r0, r1
57e1ee4c:	e1a01006 	mov	r1, r6
57e1ee50:	eb003256 	bl	57e2b7b0 <__udivsi3>
				   (sblock->inodes_per_group), &blkgrp);
	if (status == 0)
		return 0;

	inodes_per_block = EXT2_BLOCK_SIZE(data) / fs->inodesz;
	blkno = __le32_to_cpu(blkgrp.inode_table_id) +
57e1ee54:	e59d3010 	ldr	r3, [sp, #16]
	    (ino % __le32_to_cpu(sblock->inodes_per_group)) / inodes_per_block;
	blkoff = (ino % inodes_per_block) * fs->inodesz;
	/* Read the inode. */
	status = ext4fs_devread(blkno << LOG2_EXT2_BLOCK_SIZE(data), blkoff,
57e1ee58:	e28aa001 	add	sl, sl, #1
				   (sblock->inodes_per_group), &blkgrp);
	if (status == 0)
		return 0;

	inodes_per_block = EXT2_BLOCK_SIZE(data) / fs->inodesz;
	blkno = __le32_to_cpu(blkgrp.inode_table_id) +
57e1ee5c:	e0803003 	add	r3, r0, r3
	    (ino % __le32_to_cpu(sblock->inodes_per_group)) / inodes_per_block;
	blkoff = (ino % inodes_per_block) * fs->inodesz;
57e1ee60:	e1a01006 	mov	r1, r6
57e1ee64:	e1a00005 	mov	r0, r5
	/* Read the inode. */
	status = ext4fs_devread(blkno << LOG2_EXT2_BLOCK_SIZE(data), blkoff,
57e1ee68:	e1a0aa13 	lsl	sl, r3, sl
		return 0;

	inodes_per_block = EXT2_BLOCK_SIZE(data) / fs->inodesz;
	blkno = __le32_to_cpu(blkgrp.inode_table_id) +
	    (ino % __le32_to_cpu(sblock->inodes_per_group)) / inodes_per_block;
	blkoff = (ino % inodes_per_block) * fs->inodesz;
57e1ee6c:	eb00335a 	bl	57e2bbdc <__aeabi_idivmod>
	/* Read the inode. */
	status = ext4fs_devread(blkno << LOG2_EXT2_BLOCK_SIZE(data), blkoff,
57e1ee70:	e1a0000a 	mov	r0, sl
57e1ee74:	e0010197 	mul	r1, r7, r1
57e1ee78:	e3a02080 	mov	r2, #128	; 0x80
57e1ee7c:	e59d3004 	ldr	r3, [sp, #4]
57e1ee80:	eb000453 	bl	57e1ffd4 <ext4fs_devread>
	/* It is easier to calculate if the first inode is 0. */
	ino--;
	status = ext4fs_blockgroup(data, ino / __le32_to_cpu
				   (sblock->inodes_per_group), &blkgrp);
	if (status == 0)
		return 0;
57e1ee84:	e2500000 	subs	r0, r0, #0
57e1ee88:	13a00001 	movne	r0, #1
				sizeof(struct ext2_inode), (char *)inode);
	if (status == 0)
		return 0;

	return 1;
}
57e1ee8c:	e28dd028 	add	sp, sp, #40	; 0x28
57e1ee90:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e1ee94 <read_allocated_block>:

long int read_allocated_block(struct ext2_inode *inode, int fileblock)
{
57e1ee94:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	long int rblock;
	long int perblock_parent;
	long int perblock_child;
	unsigned long long start;
	/* get the blocksize of the filesystem */
	blksz = EXT2_BLOCK_SIZE(ext4fs_root);
57e1ee98:	e59f78a8 	ldr	r7, [pc, #2216]	; 57e1f748 <read_allocated_block+0x8b4>
57e1ee9c:	e3a04001 	mov	r4, #1
57e1eea0:	e5973000 	ldr	r3, [r7]

	return 1;
}

long int read_allocated_block(struct ext2_inode *inode, int fileblock)
{
57e1eea4:	e1a06000 	mov	r6, r0
	long int rblock;
	long int perblock_parent;
	long int perblock_child;
	unsigned long long start;
	/* get the blocksize of the filesystem */
	blksz = EXT2_BLOCK_SIZE(ext4fs_root);
57e1eea8:	e5935018 	ldr	r5, [r3, #24]

	return 1;
}

long int read_allocated_block(struct ext2_inode *inode, int fileblock)
{
57e1eeac:	e58d1004 	str	r1, [sp, #4]
	long int rblock;
	long int perblock_parent;
	long int perblock_child;
	unsigned long long start;
	/* get the blocksize of the filesystem */
	blksz = EXT2_BLOCK_SIZE(ext4fs_root);
57e1eeb0:	e285300a 	add	r3, r5, #10
57e1eeb4:	e1a04314 	lsl	r4, r4, r3
	log2_blksz = LOG2_EXT2_BLOCK_SIZE(ext4fs_root);
	if (le32_to_cpu(inode->flags) & EXT4_EXTENTS_FL) {
57e1eeb8:	e5903020 	ldr	r3, [r0, #32]
	long int perblock_parent;
	long int perblock_child;
	unsigned long long start;
	/* get the blocksize of the filesystem */
	blksz = EXT2_BLOCK_SIZE(ext4fs_root);
	log2_blksz = LOG2_EXT2_BLOCK_SIZE(ext4fs_root);
57e1eebc:	e2855001 	add	r5, r5, #1
	if (le32_to_cpu(inode->flags) & EXT4_EXTENTS_FL) {
57e1eec0:	e3130702 	tst	r3, #524288	; 0x80000
57e1eec4:	0a00005e 	beq	57e1f044 <read_allocated_block+0x1b0>
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1eec8:	e1a01004 	mov	r1, r4
57e1eecc:	e3a00040 	mov	r0, #64	; 0x40
57e1eed0:	ebfface1 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1eed4:	e3a01000 	mov	r1, #0
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1eed8:	e1a07000 	mov	r7, r0
	memset(p, 0, size);
57e1eedc:	e1a02004 	mov	r2, r4
57e1eee0:	eb0014e5 	bl	57e2427c <memset>
		char *buf = zalloc(blksz);
		if (!buf)
57e1eee4:	e3570000 	cmp	r7, #0
			return -ENOMEM;
57e1eee8:	03e0b00b 	mvneq	fp, #11
	/* get the blocksize of the filesystem */
	blksz = EXT2_BLOCK_SIZE(ext4fs_root);
	log2_blksz = LOG2_EXT2_BLOCK_SIZE(ext4fs_root);
	if (le32_to_cpu(inode->flags) & EXT4_EXTENTS_FL) {
		char *buf = zalloc(blksz);
		if (!buf)
57e1eeec:	0a00020c 	beq	57e1f724 <read_allocated_block+0x890>
		struct ext4_extent_header *ext_block,
		uint32_t fileblock, int log2_blksz)
{
	struct ext4_extent_idx *index;
	unsigned long long block;
	struct ext_filesystem *fs = get_fs();
57e1eef0:	ebfffee1 	bl	57e1ea7c <get_fs>
	int i;

	while (1) {
		index = (struct ext4_extent_idx *)(ext_block + 1);

		if (le32_to_cpu(ext_block->eh_magic) != EXT4_EXT_MAGIC)
57e1eef4:	e59fa850 	ldr	sl, [pc, #2128]	; 57e1f74c <read_allocated_block+0x8b8>
		struct ext4_extent_header *ext_block;
		struct ext4_extent *extent;
		int i = -1;
		ext_block = ext4fs_get_extent_block(ext4fs_root, buf,
						    (struct ext4_extent_header
						     *)inode->b.
57e1eef8:	e2866028 	add	r6, r6, #40	; 0x28
		struct ext4_extent_header *ext_block,
		uint32_t fileblock, int log2_blksz)
{
	struct ext4_extent_idx *index;
	unsigned long long block;
	struct ext_filesystem *fs = get_fs();
57e1eefc:	e1a04000 	mov	r4, r0
		} while (fileblock > le32_to_cpu(index[i].ei_block));

		if (--i < 0)
			return 0;

		block = le32_to_cpu(index[i].ei_leaf_hi);
57e1ef00:	e3a0900c 	mov	r9, #12
	int i;

	while (1) {
		index = (struct ext4_extent_idx *)(ext_block + 1);

		if (le32_to_cpu(ext_block->eh_magic) != EXT4_EXT_MAGIC)
57e1ef04:	e1d630b0 	ldrh	r3, [r6]
	unsigned long long block;
	struct ext_filesystem *fs = get_fs();
	int i;

	while (1) {
		index = (struct ext4_extent_idx *)(ext_block + 1);
57e1ef08:	e286200c 	add	r2, r6, #12

		if (le32_to_cpu(ext_block->eh_magic) != EXT4_EXT_MAGIC)
57e1ef0c:	e153000a 	cmp	r3, sl
57e1ef10:	1a000206 	bne	57e1f730 <read_allocated_block+0x89c>
			return 0;

		if (ext_block->eh_depth == 0)
57e1ef14:	e1d630b6 	ldrh	r3, [r6, #6]
57e1ef18:	e3530000 	cmp	r3, #0
57e1ef1c:	0a000022 	beq	57e1efac <read_allocated_block+0x118>
			return ext_block;
		i = -1;
		do {
			i++;
			if (i >= le32_to_cpu(ext_block->eh_entries))
57e1ef20:	e1d600b2 	ldrh	r0, [r6, #2]
57e1ef24:	e3e03000 	mvn	r3, #0
57e1ef28:	ea000000 	b	57e1ef30 <read_allocated_block+0x9c>

		if (ext_block->eh_depth == 0)
			return ext_block;
		i = -1;
		do {
			i++;
57e1ef2c:	e1a03001 	mov	r3, r1
57e1ef30:	e2831001 	add	r1, r3, #1
			if (i >= le32_to_cpu(ext_block->eh_entries))
57e1ef34:	e1510000 	cmp	r1, r0
57e1ef38:	2a000003 	bcs	57e1ef4c <read_allocated_block+0xb8>
				break;
		} while (fileblock > le32_to_cpu(index[i].ei_block));
57e1ef3c:	e5b6c00c 	ldr	ip, [r6, #12]!
57e1ef40:	e59de004 	ldr	lr, [sp, #4]
57e1ef44:	e15e000c 	cmp	lr, ip
57e1ef48:	8afffff7 	bhi	57e1ef2c <read_allocated_block+0x98>

		if (--i < 0)
57e1ef4c:	e3730001 	cmn	r3, #1
57e1ef50:	0a0001f6 	beq	57e1f730 <read_allocated_block+0x89c>
			return 0;

		block = le32_to_cpu(index[i].ei_leaf_hi);
57e1ef54:	e0232399 	mla	r3, r9, r3, r2
		block = (block << 32) + le32_to_cpu(index[i].ei_leaf_lo);
57e1ef58:	e1d320b8 	ldrh	r2, [r3, #8]
57e1ef5c:	e5930004 	ldr	r0, [r3, #4]
57e1ef60:	e3a0c000 	mov	ip, #0
57e1ef64:	e58dc008 	str	ip, [sp, #8]
57e1ef68:	e58d200c 	str	r2, [sp, #12]

		if (ext4fs_devread(block << log2_blksz, 0, fs->blksz, buf))
57e1ef6c:	e28d3008 	add	r3, sp, #8
57e1ef70:	e893000c 	ldm	r3, {r2, r3}
57e1ef74:	e0922000 	adds	r2, r2, r0
57e1ef78:	e2a33000 	adc	r3, r3, #0
57e1ef7c:	e1a00002 	mov	r0, r2
57e1ef80:	e1a01003 	mov	r1, r3
57e1ef84:	e1a02005 	mov	r2, r5
57e1ef88:	eb003329 	bl	57e2bc34 <__ashldi3>
57e1ef8c:	e59d1008 	ldr	r1, [sp, #8]
57e1ef90:	e5942008 	ldr	r2, [r4, #8]
57e1ef94:	e1a03007 	mov	r3, r7
57e1ef98:	eb00040d 	bl	57e1ffd4 <ext4fs_devread>
57e1ef9c:	e3500000 	cmp	r0, #0
57e1efa0:	0a0001e2 	beq	57e1f730 <read_allocated_block+0x89c>
			ext_block = (struct ext4_extent_header *)buf;
57e1efa4:	e1a06007 	mov	r6, r7
57e1efa8:	eaffffd5 	b	57e1ef04 <read_allocated_block+0x70>

		extent = (struct ext4_extent *)(ext_block + 1);

		do {
			i++;
			if (i >= le32_to_cpu(ext_block->eh_entries))
57e1efac:	e1d610b2 	ldrh	r1, [r6, #2]
		char *buf = zalloc(blksz);
		if (!buf)
			return -ENOMEM;
		struct ext4_extent_header *ext_block;
		struct ext4_extent *extent;
		int i = -1;
57e1efb0:	e3e0b000 	mvn	fp, #0
57e1efb4:	ea000000 	b	57e1efbc <read_allocated_block+0x128>
		}

		extent = (struct ext4_extent *)(ext_block + 1);

		do {
			i++;
57e1efb8:	e1a0b003 	mov	fp, r3
57e1efbc:	e28b3001 	add	r3, fp, #1
			if (i >= le32_to_cpu(ext_block->eh_entries))
57e1efc0:	e1530001 	cmp	r3, r1
57e1efc4:	2a000003 	bcs	57e1efd8 <read_allocated_block+0x144>
				break;
		} while (fileblock >= le32_to_cpu(extent[i].ee_block));
57e1efc8:	e5b6000c 	ldr	r0, [r6, #12]!
57e1efcc:	e59dc004 	ldr	ip, [sp, #4]
57e1efd0:	e15c0000 	cmp	ip, r0
57e1efd4:	2afffff7 	bcs	57e1efb8 <read_allocated_block+0x124>
		if (--i >= 0) {
57e1efd8:	e37b0001 	cmn	fp, #1
57e1efdc:	0a000013 	beq	57e1f030 <read_allocated_block+0x19c>
			fileblock -= le32_to_cpu(extent[i].ee_block);
57e1efe0:	e3a0a00c 	mov	sl, #12
57e1efe4:	e00b0b9a 	mul	fp, sl, fp
57e1efe8:	e59de004 	ldr	lr, [sp, #4]
57e1efec:	e792400b 	ldr	r4, [r2, fp]
57e1eff0:	e082300b 	add	r3, r2, fp
			if (fileblock >= le32_to_cpu(extent[i].ee_len)) {
57e1eff4:	e1d320b4 	ldrh	r2, [r3, #4]
			i++;
			if (i >= le32_to_cpu(ext_block->eh_entries))
				break;
		} while (fileblock >= le32_to_cpu(extent[i].ee_block));
		if (--i >= 0) {
			fileblock -= le32_to_cpu(extent[i].ee_block);
57e1eff8:	e064400e 	rsb	r4, r4, lr
			if (fileblock >= le32_to_cpu(extent[i].ee_len)) {
57e1effc:	e1540002 	cmp	r4, r2
57e1f000:	3a000003 	bcc	57e1f014 <read_allocated_block+0x180>
				free(buf);
57e1f004:	e1a00007 	mov	r0, r7
57e1f008:	ebffaa63 	bl	57e0999c <free>
				return 0;
57e1f00c:	e3a0b000 	mov	fp, #0
57e1f010:	ea0001c3 	b	57e1f724 <read_allocated_block+0x890>
			}

			start = le32_to_cpu(extent[i].ee_start_hi);
			start = (start << 32) +
57e1f014:	e5933008 	ldr	r3, [r3, #8]
57e1f018:	e3a0a000 	mov	sl, #0
57e1f01c:	e09aa003 	adds	sl, sl, r3
					le32_to_cpu(extent[i].ee_start_lo);
			free(buf);
57e1f020:	e1a00007 	mov	r0, r7
57e1f024:	ebffaa5c 	bl	57e0999c <free>
			return fileblock + start;
57e1f028:	e084b00a 	add	fp, r4, sl
57e1f02c:	ea0001bc 	b	57e1f724 <read_allocated_block+0x890>
		}

		printf("Extent Error\n");
57e1f030:	e59f0718 	ldr	r0, [pc, #1816]	; 57e1f750 <read_allocated_block+0x8bc>
57e1f034:	ebffa904 	bl	57e0944c <printf>
		free(buf);
57e1f038:	e1a00007 	mov	r0, r7
57e1f03c:	ebffaa56 	bl	57e0999c <free>
		return -1;
57e1f040:	ea0001b7 	b	57e1f724 <read_allocated_block+0x890>
	}

	/* Direct blocks. */
	if (fileblock < INDIRECT_BLOCKS)
57e1f044:	e59d2004 	ldr	r2, [sp, #4]
57e1f048:	e352000b 	cmp	r2, #11
		blknr = __le32_to_cpu(inode->b.blocks.dir_blocks[fileblock]);
57e1f04c:	d282300a 	addle	r3, r2, #10
57e1f050:	d790b103 	ldrle	fp, [r0, r3, lsl #2]
		free(buf);
		return -1;
	}

	/* Direct blocks. */
	if (fileblock < INDIRECT_BLOCKS)
57e1f054:	da0001b2 	ble	57e1f724 <read_allocated_block+0x890>
		blknr = __le32_to_cpu(inode->b.blocks.dir_blocks[fileblock]);

	/* Indirect. */
	else if (fileblock < (INDIRECT_BLOCKS + (blksz / 4))) {
57e1f058:	e3540000 	cmp	r4, #0
57e1f05c:	e2849003 	add	r9, r4, #3
57e1f060:	a1a09004 	movge	r9, r4
57e1f064:	e1a09149 	asr	r9, r9, #2
57e1f068:	e59dc004 	ldr	ip, [sp, #4]
57e1f06c:	e289300b 	add	r3, r9, #11
57e1f070:	e153000c 	cmp	r3, ip
57e1f074:	ba000040 	blt	57e1f17c <read_allocated_block+0x2e8>
		if (ext4fs_indir1_block == NULL) {
57e1f078:	e5979004 	ldr	r9, [r7, #4]
57e1f07c:	e3590000 	cmp	r9, #0
57e1f080:	1a00000e 	bne	57e1f0c0 <read_allocated_block+0x22c>
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f084:	e1a01004 	mov	r1, r4
57e1f088:	e3a00040 	mov	r0, #64	; 0x40
57e1f08c:	ebffac72 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f090:	e1a01009 	mov	r1, r9
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f094:	e1a0a000 	mov	sl, r0
	memset(p, 0, size);
57e1f098:	e1a02004 	mov	r2, r4
57e1f09c:	eb001476 	bl	57e2427c <memset>
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f0a0:	e35a0000 	cmp	sl, #0
		blknr = __le32_to_cpu(inode->b.blocks.dir_blocks[fileblock]);

	/* Indirect. */
	else if (fileblock < (INDIRECT_BLOCKS + (blksz / 4))) {
		if (ext4fs_indir1_block == NULL) {
			ext4fs_indir1_block = zalloc(blksz);
57e1f0a4:	e587a004 	str	sl, [r7, #4]
			if (ext4fs_indir1_block == NULL) {
				printf("** SI ext2fs read block (indir 1)"
57e1f0a8:	059f06a4 	ldreq	r0, [pc, #1700]	; 57e1f754 <read_allocated_block+0x8c0>

	/* Indirect. */
	else if (fileblock < (INDIRECT_BLOCKS + (blksz / 4))) {
		if (ext4fs_indir1_block == NULL) {
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f0ac:	0a00018f 	beq	57e1f6f0 <read_allocated_block+0x85c>
				printf("** SI ext2fs read block (indir 1)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
			ext4fs_indir1_blkno = -1;
57e1f0b0:	e59f36a0 	ldr	r3, [pc, #1696]	; 57e1f758 <read_allocated_block+0x8c4>
57e1f0b4:	e3e02000 	mvn	r2, #0
			if (ext4fs_indir1_block == NULL) {
				printf("** SI ext2fs read block (indir 1)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
57e1f0b8:	e5874008 	str	r4, [r7, #8]
			ext4fs_indir1_blkno = -1;
57e1f0bc:	e5832000 	str	r2, [r3]
		}
		if (blksz != ext4fs_indir1_size) {
57e1f0c0:	e59f7680 	ldr	r7, [pc, #1664]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f0c4:	e5973008 	ldr	r3, [r7, #8]
57e1f0c8:	e1540003 	cmp	r4, r3
57e1f0cc:	0a000013 	beq	57e1f120 <read_allocated_block+0x28c>
			free(ext4fs_indir1_block);
57e1f0d0:	e5970004 	ldr	r0, [r7, #4]
57e1f0d4:	ebffaa30 	bl	57e0999c <free>
			ext4fs_indir1_block = NULL;
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
57e1f0d8:	e59f3678 	ldr	r3, [pc, #1656]	; 57e1f758 <read_allocated_block+0x8c4>
			ext4fs_indir1_size = blksz;
			ext4fs_indir1_blkno = -1;
		}
		if (blksz != ext4fs_indir1_size) {
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
57e1f0dc:	e3a09000 	mov	r9, #0
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
57e1f0e0:	e3e0b000 	mvn	fp, #0
57e1f0e4:	e583b000 	str	fp, [r3]
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f0e8:	e1a01004 	mov	r1, r4
			ext4fs_indir1_size = blksz;
			ext4fs_indir1_blkno = -1;
		}
		if (blksz != ext4fs_indir1_size) {
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
57e1f0ec:	e5879004 	str	r9, [r7, #4]
			ext4fs_indir1_size = 0;
57e1f0f0:	e5879008 	str	r9, [r7, #8]
57e1f0f4:	e3a00040 	mov	r0, #64	; 0x40
57e1f0f8:	ebffac57 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f0fc:	e1a01009 	mov	r1, r9
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f100:	e1a0a000 	mov	sl, r0
	memset(p, 0, size);
57e1f104:	e1a02004 	mov	r2, r4
57e1f108:	eb00145b 	bl	57e2427c <memset>
			ext4fs_indir1_blkno = -1;
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f10c:	e15a0009 	cmp	sl, r9
		if (blksz != ext4fs_indir1_size) {
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
			ext4fs_indir1_block = zalloc(blksz);
57e1f110:	e587a004 	str	sl, [r7, #4]
			if (ext4fs_indir1_block == NULL) {
				printf("** SI ext2fs read block (indir 1):"
57e1f114:	059f0640 	ldreq	r0, [pc, #1600]	; 57e1f75c <read_allocated_block+0x8c8>
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f118:	0a000083 	beq	57e1f32c <read_allocated_block+0x498>
				printf("** SI ext2fs read block (indir 1):"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
57e1f11c:	e5874008 	str	r4, [r7, #8]
		}
		if ((__le32_to_cpu(inode->b.blocks.indir_block) <<
57e1f120:	e5960058 	ldr	r0, [r6, #88]	; 0x58
		     log2_blksz) != ext4fs_indir1_blkno) {
57e1f124:	e59f762c 	ldr	r7, [pc, #1580]	; 57e1f758 <read_allocated_block+0x8c4>
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
		}
		if ((__le32_to_cpu(inode->b.blocks.indir_block) <<
57e1f128:	e1a00510 	lsl	r0, r0, r5
57e1f12c:	e5973000 	ldr	r3, [r7]
57e1f130:	e1500003 	cmp	r0, r3
57e1f134:	0a00000a 	beq	57e1f164 <read_allocated_block+0x2d0>
		     log2_blksz) != ext4fs_indir1_blkno) {
			status =
57e1f138:	e59f3608 	ldr	r3, [pc, #1544]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f13c:	e3a01000 	mov	r1, #0
57e1f140:	e1a02004 	mov	r2, r4
57e1f144:	e5933004 	ldr	r3, [r3, #4]
57e1f148:	eb0003a1 	bl	57e1ffd4 <ext4fs_devread>
			    ext4fs_devread(__le32_to_cpu
					   (inode->b.blocks.
					    indir_block) << log2_blksz, 0,
					   blksz, (char *)ext4fs_indir1_block);
			if (status == 0) {
57e1f14c:	e250b000 	subs	fp, r0, #0
				printf("** SI ext2fs read block (indir 1)"
57e1f150:	059f0608 	ldreq	r0, [pc, #1544]	; 57e1f760 <read_allocated_block+0x8cc>
			status =
			    ext4fs_devread(__le32_to_cpu
					   (inode->b.blocks.
					    indir_block) << log2_blksz, 0,
					   blksz, (char *)ext4fs_indir1_block);
			if (status == 0) {
57e1f154:	0a000074 	beq	57e1f32c <read_allocated_block+0x498>
					"failed. **\n");
				return 0;
			}
			ext4fs_indir1_blkno =
				__le32_to_cpu(inode->b.blocks.
					       indir_block) << log2_blksz;
57e1f158:	e5963058 	ldr	r3, [r6, #88]	; 0x58
57e1f15c:	e1a05513 	lsl	r5, r3, r5
			if (status == 0) {
				printf("** SI ext2fs read block (indir 1)"
					"failed. **\n");
				return 0;
			}
			ext4fs_indir1_blkno =
57e1f160:	e5875000 	str	r5, [r7]
				__le32_to_cpu(inode->b.blocks.
					       indir_block) << log2_blksz;
		}
		blknr = __le32_to_cpu(ext4fs_indir1_block
57e1f164:	e59d3004 	ldr	r3, [sp, #4]
57e1f168:	e243200c 	sub	r2, r3, #12
57e1f16c:	e59f35d4 	ldr	r3, [pc, #1492]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f170:	e5933004 	ldr	r3, [r3, #4]
57e1f174:	e793b102 	ldr	fp, [r3, r2, lsl #2]
57e1f178:	ea000169 	b	57e1f724 <read_allocated_block+0x890>
				      [fileblock - INDIRECT_BLOCKS]);
	}
	/* Double indirect. */
	else if (fileblock < (INDIRECT_BLOCKS + (blksz / 4 *
					(blksz / 4 + 1)))) {
57e1f17c:	e2893001 	add	r3, r9, #1
		}
		blknr = __le32_to_cpu(ext4fs_indir1_block
				      [fileblock - INDIRECT_BLOCKS]);
	}
	/* Double indirect. */
	else if (fileblock < (INDIRECT_BLOCKS + (blksz / 4 *
57e1f180:	e0030399 	mul	r3, r9, r3
57e1f184:	e59dc004 	ldr	ip, [sp, #4]
57e1f188:	e283300b 	add	r3, r3, #11
57e1f18c:	e153000c 	cmp	r3, ip
57e1f190:	ba00008a 	blt	57e1f3c0 <read_allocated_block+0x52c>
					(blksz / 4 + 1)))) {

		long int perblock = blksz / 4;
		long int rblock = fileblock - (INDIRECT_BLOCKS + blksz / 4);

		if (ext4fs_indir1_block == NULL) {
57e1f194:	e597b004 	ldr	fp, [r7, #4]
57e1f198:	e35b0000 	cmp	fp, #0
57e1f19c:	1a00000d 	bne	57e1f1d8 <read_allocated_block+0x344>
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f1a0:	e1a01004 	mov	r1, r4
57e1f1a4:	e3a00040 	mov	r0, #64	; 0x40
57e1f1a8:	ebffac2b 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f1ac:	e1a0100b 	mov	r1, fp
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f1b0:	e1a0a000 	mov	sl, r0
	memset(p, 0, size);
57e1f1b4:	e1a02004 	mov	r2, r4
57e1f1b8:	eb00142f 	bl	57e2427c <memset>
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f1bc:	e35a0000 	cmp	sl, #0

		long int perblock = blksz / 4;
		long int rblock = fileblock - (INDIRECT_BLOCKS + blksz / 4);

		if (ext4fs_indir1_block == NULL) {
			ext4fs_indir1_block = zalloc(blksz);
57e1f1c0:	e587a004 	str	sl, [r7, #4]
			if (ext4fs_indir1_block == NULL) {
57e1f1c4:	0a00001a 	beq	57e1f234 <read_allocated_block+0x3a0>
				printf("** DI ext2fs read block (indir 2 1)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
			ext4fs_indir1_blkno = -1;
57e1f1c8:	e59f3588 	ldr	r3, [pc, #1416]	; 57e1f758 <read_allocated_block+0x8c4>
57e1f1cc:	e3e02000 	mvn	r2, #0
			if (ext4fs_indir1_block == NULL) {
				printf("** DI ext2fs read block (indir 2 1)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
57e1f1d0:	e5874008 	str	r4, [r7, #8]
			ext4fs_indir1_blkno = -1;
57e1f1d4:	e5832000 	str	r2, [r3]
		}
		if (blksz != ext4fs_indir1_size) {
57e1f1d8:	e59f7568 	ldr	r7, [pc, #1384]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f1dc:	e5973008 	ldr	r3, [r7, #8]
57e1f1e0:	e1540003 	cmp	r4, r3
57e1f1e4:	0a000014 	beq	57e1f23c <read_allocated_block+0x3a8>
			free(ext4fs_indir1_block);
57e1f1e8:	e5970004 	ldr	r0, [r7, #4]
57e1f1ec:	ebffa9ea 	bl	57e0999c <free>
			ext4fs_indir1_block = NULL;
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
57e1f1f0:	e59f3560 	ldr	r3, [pc, #1376]	; 57e1f758 <read_allocated_block+0x8c4>
			ext4fs_indir1_size = blksz;
			ext4fs_indir1_blkno = -1;
		}
		if (blksz != ext4fs_indir1_size) {
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
57e1f1f4:	e3a0b000 	mov	fp, #0
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
57e1f1f8:	e3e0e000 	mvn	lr, #0
57e1f1fc:	e583e000 	str	lr, [r3]
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f200:	e1a01004 	mov	r1, r4
			ext4fs_indir1_size = blksz;
			ext4fs_indir1_blkno = -1;
		}
		if (blksz != ext4fs_indir1_size) {
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
57e1f204:	e587b004 	str	fp, [r7, #4]
			ext4fs_indir1_size = 0;
57e1f208:	e587b008 	str	fp, [r7, #8]
57e1f20c:	e3a00040 	mov	r0, #64	; 0x40
57e1f210:	ebffac11 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f214:	e1a0100b 	mov	r1, fp
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f218:	e1a0a000 	mov	sl, r0
	memset(p, 0, size);
57e1f21c:	e1a02004 	mov	r2, r4
57e1f220:	eb001415 	bl	57e2427c <memset>
			ext4fs_indir1_blkno = -1;
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f224:	e15a000b 	cmp	sl, fp
		if (blksz != ext4fs_indir1_size) {
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
			ext4fs_indir1_block = zalloc(blksz);
57e1f228:	e587a004 	str	sl, [r7, #4]
			if (ext4fs_indir1_block == NULL) {
				printf("** DI ext2fs read block (indir 2 1)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
57e1f22c:	15874008 	strne	r4, [r7, #8]
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f230:	1a000001 	bne	57e1f23c <read_allocated_block+0x3a8>
				printf("** DI ext2fs read block (indir 2 1)"
57e1f234:	e59f0528 	ldr	r0, [pc, #1320]	; 57e1f764 <read_allocated_block+0x8d0>
57e1f238:	ea00012c 	b	57e1f6f0 <read_allocated_block+0x85c>
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
		}
		if ((__le32_to_cpu(inode->b.blocks.double_indir_block) <<
57e1f23c:	e596005c 	ldr	r0, [r6, #92]	; 0x5c
		     log2_blksz) != ext4fs_indir1_blkno) {
57e1f240:	e59f7510 	ldr	r7, [pc, #1296]	; 57e1f758 <read_allocated_block+0x8c4>
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
		}
		if ((__le32_to_cpu(inode->b.blocks.double_indir_block) <<
57e1f244:	e1a00510 	lsl	r0, r0, r5
57e1f248:	e5973000 	ldr	r3, [r7]
57e1f24c:	e1500003 	cmp	r0, r3
57e1f250:	0a00000a 	beq	57e1f280 <read_allocated_block+0x3ec>
		     log2_blksz) != ext4fs_indir1_blkno) {
			status =
57e1f254:	e59f34ec 	ldr	r3, [pc, #1260]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f258:	e3a01000 	mov	r1, #0
57e1f25c:	e1a02004 	mov	r2, r4
57e1f260:	e5933004 	ldr	r3, [r3, #4]
57e1f264:	eb00035a 	bl	57e1ffd4 <ext4fs_devread>
			    ext4fs_devread(__le32_to_cpu
					   (inode->b.blocks.
					    double_indir_block) << log2_blksz,
					   0, blksz,
					   (char *)ext4fs_indir1_block);
			if (status == 0) {
57e1f268:	e3500000 	cmp	r0, #0
				printf("** DI ext2fs read block (indir 2 1)"
57e1f26c:	059f04f4 	ldreq	r0, [pc, #1268]	; 57e1f768 <read_allocated_block+0x8d4>
			    ext4fs_devread(__le32_to_cpu
					   (inode->b.blocks.
					    double_indir_block) << log2_blksz,
					   0, blksz,
					   (char *)ext4fs_indir1_block);
			if (status == 0) {
57e1f270:	0a00011e 	beq	57e1f6f0 <read_allocated_block+0x85c>
				printf("** DI ext2fs read block (indir 2 1)"
					"failed. **\n");
				return -1;
			}
			ext4fs_indir1_blkno =
			    __le32_to_cpu(inode->b.blocks.double_indir_block) <<
57e1f274:	e596305c 	ldr	r3, [r6, #92]	; 0x5c
57e1f278:	e1a03513 	lsl	r3, r3, r5
			if (status == 0) {
				printf("** DI ext2fs read block (indir 2 1)"
					"failed. **\n");
				return -1;
			}
			ext4fs_indir1_blkno =
57e1f27c:	e5873000 	str	r3, [r7]
			    __le32_to_cpu(inode->b.blocks.double_indir_block) <<
			    log2_blksz;
		}

		if (ext4fs_indir2_block == NULL) {
57e1f280:	e59f64c0 	ldr	r6, [pc, #1216]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f284:	e596a00c 	ldr	sl, [r6, #12]
57e1f288:	e35a0000 	cmp	sl, #0
57e1f28c:	1a00000e 	bne	57e1f2cc <read_allocated_block+0x438>
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f290:	e1a01004 	mov	r1, r4
57e1f294:	e3a00040 	mov	r0, #64	; 0x40
57e1f298:	ebffabef 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f29c:	e1a0100a 	mov	r1, sl
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f2a0:	e1a07000 	mov	r7, r0
	memset(p, 0, size);
57e1f2a4:	e1a02004 	mov	r2, r4
57e1f2a8:	eb0013f3 	bl	57e2427c <memset>
			ext4fs_indir2_block = zalloc(blksz);
			if (ext4fs_indir2_block == NULL) {
57e1f2ac:	e3570000 	cmp	r7, #0
			    __le32_to_cpu(inode->b.blocks.double_indir_block) <<
			    log2_blksz;
		}

		if (ext4fs_indir2_block == NULL) {
			ext4fs_indir2_block = zalloc(blksz);
57e1f2b0:	e586700c 	str	r7, [r6, #12]
			if (ext4fs_indir2_block == NULL) {
				printf("** DI ext2fs read block (indir 2 2)"
57e1f2b4:	059f04b0 	ldreq	r0, [pc, #1200]	; 57e1f76c <read_allocated_block+0x8d8>
			    log2_blksz;
		}

		if (ext4fs_indir2_block == NULL) {
			ext4fs_indir2_block = zalloc(blksz);
			if (ext4fs_indir2_block == NULL) {
57e1f2b8:	0a00010c 	beq	57e1f6f0 <read_allocated_block+0x85c>
				printf("** DI ext2fs read block (indir 2 2)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
			ext4fs_indir2_blkno = -1;
57e1f2bc:	e59f3494 	ldr	r3, [pc, #1172]	; 57e1f758 <read_allocated_block+0x8c4>
57e1f2c0:	e3e02000 	mvn	r2, #0
			if (ext4fs_indir2_block == NULL) {
				printf("** DI ext2fs read block (indir 2 2)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
57e1f2c4:	e5864010 	str	r4, [r6, #16]
			ext4fs_indir2_blkno = -1;
57e1f2c8:	e5832004 	str	r2, [r3, #4]
		}
		if (blksz != ext4fs_indir2_size) {
57e1f2cc:	e59f6474 	ldr	r6, [pc, #1140]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f2d0:	e5963010 	ldr	r3, [r6, #16]
57e1f2d4:	e1540003 	cmp	r4, r3
57e1f2d8:	0a000015 	beq	57e1f334 <read_allocated_block+0x4a0>
			free(ext4fs_indir2_block);
57e1f2dc:	e596000c 	ldr	r0, [r6, #12]
57e1f2e0:	ebffa9ad 	bl	57e0999c <free>
			ext4fs_indir2_block = NULL;
			ext4fs_indir2_size = 0;
			ext4fs_indir2_blkno = -1;
57e1f2e4:	e59f346c 	ldr	r3, [pc, #1132]	; 57e1f758 <read_allocated_block+0x8c4>
			ext4fs_indir2_size = blksz;
			ext4fs_indir2_blkno = -1;
		}
		if (blksz != ext4fs_indir2_size) {
			free(ext4fs_indir2_block);
			ext4fs_indir2_block = NULL;
57e1f2e8:	e3a0a000 	mov	sl, #0
			ext4fs_indir2_size = 0;
			ext4fs_indir2_blkno = -1;
57e1f2ec:	e3e0b000 	mvn	fp, #0
57e1f2f0:	e583b004 	str	fp, [r3, #4]
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f2f4:	e1a01004 	mov	r1, r4
			ext4fs_indir2_size = blksz;
			ext4fs_indir2_blkno = -1;
		}
		if (blksz != ext4fs_indir2_size) {
			free(ext4fs_indir2_block);
			ext4fs_indir2_block = NULL;
57e1f2f8:	e586a00c 	str	sl, [r6, #12]
			ext4fs_indir2_size = 0;
57e1f2fc:	e586a010 	str	sl, [r6, #16]
57e1f300:	e3a00040 	mov	r0, #64	; 0x40
57e1f304:	ebffabd4 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f308:	e1a0100a 	mov	r1, sl
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f30c:	e1a07000 	mov	r7, r0
	memset(p, 0, size);
57e1f310:	e1a02004 	mov	r2, r4
57e1f314:	eb0013d8 	bl	57e2427c <memset>
			ext4fs_indir2_blkno = -1;
			ext4fs_indir2_block = zalloc(blksz);
			if (ext4fs_indir2_block == NULL) {
57e1f318:	e157000a 	cmp	r7, sl
		if (blksz != ext4fs_indir2_size) {
			free(ext4fs_indir2_block);
			ext4fs_indir2_block = NULL;
			ext4fs_indir2_size = 0;
			ext4fs_indir2_blkno = -1;
			ext4fs_indir2_block = zalloc(blksz);
57e1f31c:	e586700c 	str	r7, [r6, #12]
			if (ext4fs_indir2_block == NULL) {
				printf("** DI ext2fs read block (indir 2 2)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
57e1f320:	15864010 	strne	r4, [r6, #16]
			free(ext4fs_indir2_block);
			ext4fs_indir2_block = NULL;
			ext4fs_indir2_size = 0;
			ext4fs_indir2_blkno = -1;
			ext4fs_indir2_block = zalloc(blksz);
			if (ext4fs_indir2_block == NULL) {
57e1f324:	1a000002 	bne	57e1f334 <read_allocated_block+0x4a0>
				printf("** DI ext2fs read block (indir 2 2)"
57e1f328:	e59f043c 	ldr	r0, [pc, #1084]	; 57e1f76c <read_allocated_block+0x8d8>
57e1f32c:	ebffa846 	bl	57e0944c <printf>
					"malloc failed. **\n");
				return -1;
57e1f330:	ea0000fb 	b	57e1f724 <read_allocated_block+0x890>
	/* Double indirect. */
	else if (fileblock < (INDIRECT_BLOCKS + (blksz / 4 *
					(blksz / 4 + 1)))) {

		long int perblock = blksz / 4;
		long int rblock = fileblock - (INDIRECT_BLOCKS + blksz / 4);
57e1f334:	e59d2004 	ldr	r2, [sp, #4]
57e1f338:	e3540000 	cmp	r4, #0
57e1f33c:	e242300c 	sub	r3, r2, #12
57e1f340:	e284b003 	add	fp, r4, #3
57e1f344:	a1a0b004 	movge	fp, r4
57e1f348:	e043b14b 	sub	fp, r3, fp, asr #2
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir1_block[rblock / perblock]) <<
57e1f34c:	e1a0000b 	mov	r0, fp
57e1f350:	e1a01009 	mov	r1, r9
57e1f354:	eb003198 	bl	57e2b9bc <__divsi3>
57e1f358:	e59f63e8 	ldr	r6, [pc, #1000]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f35c:	e1a0a000 	mov	sl, r0
57e1f360:	e5963004 	ldr	r3, [r6, #4]
		     log2_blksz) != ext4fs_indir2_blkno) {
57e1f364:	e59f73ec 	ldr	r7, [pc, #1004]	; 57e1f758 <read_allocated_block+0x8c4>
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir1_block[rblock / perblock]) <<
57e1f368:	e7930100 	ldr	r0, [r3, r0, lsl #2]
57e1f36c:	e5973004 	ldr	r3, [r7, #4]
57e1f370:	e1a00510 	lsl	r0, r0, r5
57e1f374:	e1500003 	cmp	r0, r3
57e1f378:	0a00000a 	beq	57e1f3a8 <read_allocated_block+0x514>
		     log2_blksz) != ext4fs_indir2_blkno) {
			status = ext4fs_devread(__le32_to_cpu
57e1f37c:	e3a01000 	mov	r1, #0
57e1f380:	e1a02004 	mov	r2, r4
57e1f384:	e596300c 	ldr	r3, [r6, #12]
57e1f388:	eb000311 	bl	57e1ffd4 <ext4fs_devread>
						(ext4fs_indir1_block
						 [rblock /
						  perblock]) << log2_blksz, 0,
						blksz,
						(char *)ext4fs_indir2_block);
			if (status == 0) {
57e1f38c:	e3500000 	cmp	r0, #0
				printf("** DI ext2fs read block (indir 2 2)"
57e1f390:	059f03d8 	ldreq	r0, [pc, #984]	; 57e1f770 <read_allocated_block+0x8dc>
						(ext4fs_indir1_block
						 [rblock /
						  perblock]) << log2_blksz, 0,
						blksz,
						(char *)ext4fs_indir2_block);
			if (status == 0) {
57e1f394:	0a0000d5 	beq	57e1f6f0 <read_allocated_block+0x85c>
				printf("** DI ext2fs read block (indir 2 2)"
					"failed. **\n");
				return -1;
			}
			ext4fs_indir2_blkno =
			    __le32_to_cpu(ext4fs_indir1_block[rblock
57e1f398:	e5963004 	ldr	r3, [r6, #4]
							      /
							      perblock]) <<
57e1f39c:	e793310a 	ldr	r3, [r3, sl, lsl #2]
57e1f3a0:	e1a05513 	lsl	r5, r3, r5
			if (status == 0) {
				printf("** DI ext2fs read block (indir 2 2)"
					"failed. **\n");
				return -1;
			}
			ext4fs_indir2_blkno =
57e1f3a4:	e5875004 	str	r5, [r7, #4]
			    __le32_to_cpu(ext4fs_indir1_block[rblock
							      /
							      perblock]) <<
			    log2_blksz;
		}
		blknr = __le32_to_cpu(ext4fs_indir2_block[rblock % perblock]);
57e1f3a8:	e1a0000b 	mov	r0, fp
57e1f3ac:	e1a01009 	mov	r1, r9
57e1f3b0:	eb003209 	bl	57e2bbdc <__aeabi_idivmod>
57e1f3b4:	e59f338c 	ldr	r3, [pc, #908]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f3b8:	e593300c 	ldr	r3, [r3, #12]
57e1f3bc:	ea0000d7 	b	57e1f720 <read_allocated_block+0x88c>
		rblock = fileblock - (INDIRECT_BLOCKS + blksz / 4 +
				      (blksz / 4 * blksz / 4));
		perblock_child = blksz / 4;
		perblock_parent = ((blksz / 4) * (blksz / 4));

		if (ext4fs_indir1_block == NULL) {
57e1f3c0:	e597b004 	ldr	fp, [r7, #4]
57e1f3c4:	e35b0000 	cmp	fp, #0
57e1f3c8:	1a00000d 	bne	57e1f404 <read_allocated_block+0x570>
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f3cc:	e1a01004 	mov	r1, r4
57e1f3d0:	e3a00040 	mov	r0, #64	; 0x40
57e1f3d4:	ebffaba0 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f3d8:	e1a0100b 	mov	r1, fp
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f3dc:	e1a0a000 	mov	sl, r0
	memset(p, 0, size);
57e1f3e0:	e1a02004 	mov	r2, r4
57e1f3e4:	eb0013a4 	bl	57e2427c <memset>
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f3e8:	e35a0000 	cmp	sl, #0
				      (blksz / 4 * blksz / 4));
		perblock_child = blksz / 4;
		perblock_parent = ((blksz / 4) * (blksz / 4));

		if (ext4fs_indir1_block == NULL) {
			ext4fs_indir1_block = zalloc(blksz);
57e1f3ec:	e587a004 	str	sl, [r7, #4]
			if (ext4fs_indir1_block == NULL) {
57e1f3f0:	0a00001a 	beq	57e1f460 <read_allocated_block+0x5cc>
				printf("** TI ext2fs read block (indir 2 1)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
			ext4fs_indir1_blkno = -1;
57e1f3f4:	e59f335c 	ldr	r3, [pc, #860]	; 57e1f758 <read_allocated_block+0x8c4>
57e1f3f8:	e3e02000 	mvn	r2, #0
			if (ext4fs_indir1_block == NULL) {
				printf("** TI ext2fs read block (indir 2 1)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
57e1f3fc:	e5874008 	str	r4, [r7, #8]
			ext4fs_indir1_blkno = -1;
57e1f400:	e5832000 	str	r2, [r3]
		}
		if (blksz != ext4fs_indir1_size) {
57e1f404:	e59f733c 	ldr	r7, [pc, #828]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f408:	e5973008 	ldr	r3, [r7, #8]
57e1f40c:	e1540003 	cmp	r4, r3
57e1f410:	0a000014 	beq	57e1f468 <read_allocated_block+0x5d4>
			free(ext4fs_indir1_block);
57e1f414:	e5970004 	ldr	r0, [r7, #4]
57e1f418:	ebffa95f 	bl	57e0999c <free>
			ext4fs_indir1_block = NULL;
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
57e1f41c:	e59f3334 	ldr	r3, [pc, #820]	; 57e1f758 <read_allocated_block+0x8c4>
			ext4fs_indir1_size = blksz;
			ext4fs_indir1_blkno = -1;
		}
		if (blksz != ext4fs_indir1_size) {
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
57e1f420:	e3a0b000 	mov	fp, #0
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
57e1f424:	e3e0c000 	mvn	ip, #0
57e1f428:	e583c000 	str	ip, [r3]
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f42c:	e1a01004 	mov	r1, r4
			ext4fs_indir1_size = blksz;
			ext4fs_indir1_blkno = -1;
		}
		if (blksz != ext4fs_indir1_size) {
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
57e1f430:	e587b004 	str	fp, [r7, #4]
			ext4fs_indir1_size = 0;
57e1f434:	e587b008 	str	fp, [r7, #8]
57e1f438:	e3a00040 	mov	r0, #64	; 0x40
57e1f43c:	ebffab86 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f440:	e1a0100b 	mov	r1, fp
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f444:	e1a0a000 	mov	sl, r0
	memset(p, 0, size);
57e1f448:	e1a02004 	mov	r2, r4
57e1f44c:	eb00138a 	bl	57e2427c <memset>
			ext4fs_indir1_blkno = -1;
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f450:	e15a000b 	cmp	sl, fp
		if (blksz != ext4fs_indir1_size) {
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
			ext4fs_indir1_block = zalloc(blksz);
57e1f454:	e587a004 	str	sl, [r7, #4]
			if (ext4fs_indir1_block == NULL) {
				printf("** TI ext2fs read block (indir 2 1)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
57e1f458:	15874008 	strne	r4, [r7, #8]
			free(ext4fs_indir1_block);
			ext4fs_indir1_block = NULL;
			ext4fs_indir1_size = 0;
			ext4fs_indir1_blkno = -1;
			ext4fs_indir1_block = zalloc(blksz);
			if (ext4fs_indir1_block == NULL) {
57e1f45c:	1a000001 	bne	57e1f468 <read_allocated_block+0x5d4>
				printf("** TI ext2fs read block (indir 2 1)"
57e1f460:	e59f030c 	ldr	r0, [pc, #780]	; 57e1f774 <read_allocated_block+0x8e0>
57e1f464:	ea0000a1 	b	57e1f6f0 <read_allocated_block+0x85c>
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
		}
		if ((__le32_to_cpu(inode->b.blocks.triple_indir_block) <<
57e1f468:	e5960060 	ldr	r0, [r6, #96]	; 0x60
		     log2_blksz) != ext4fs_indir1_blkno) {
57e1f46c:	e59f72e4 	ldr	r7, [pc, #740]	; 57e1f758 <read_allocated_block+0x8c4>
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir1_size = blksz;
		}
		if ((__le32_to_cpu(inode->b.blocks.triple_indir_block) <<
57e1f470:	e1a00510 	lsl	r0, r0, r5
57e1f474:	e5973000 	ldr	r3, [r7]
57e1f478:	e1500003 	cmp	r0, r3
57e1f47c:	0a00000a 	beq	57e1f4ac <read_allocated_block+0x618>
		     log2_blksz) != ext4fs_indir1_blkno) {
			status = ext4fs_devread
57e1f480:	e59f32c0 	ldr	r3, [pc, #704]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f484:	e3a01000 	mov	r1, #0
57e1f488:	e1a02004 	mov	r2, r4
57e1f48c:	e5933004 	ldr	r3, [r3, #4]
57e1f490:	eb0002cf 	bl	57e1ffd4 <ext4fs_devread>
			    (__le32_to_cpu(inode->b.blocks.triple_indir_block)
			     << log2_blksz, 0, blksz,
			     (char *)ext4fs_indir1_block);
			if (status == 0) {
57e1f494:	e3500000 	cmp	r0, #0
				printf("** TI ext2fs read block (indir 2 1)"
57e1f498:	059f02d8 	ldreq	r0, [pc, #728]	; 57e1f778 <read_allocated_block+0x8e4>
		     log2_blksz) != ext4fs_indir1_blkno) {
			status = ext4fs_devread
			    (__le32_to_cpu(inode->b.blocks.triple_indir_block)
			     << log2_blksz, 0, blksz,
			     (char *)ext4fs_indir1_block);
			if (status == 0) {
57e1f49c:	0a000093 	beq	57e1f6f0 <read_allocated_block+0x85c>
				printf("** TI ext2fs read block (indir 2 1)"
					"failed. **\n");
				return -1;
			}
			ext4fs_indir1_blkno =
			    __le32_to_cpu(inode->b.blocks.triple_indir_block) <<
57e1f4a0:	e5963060 	ldr	r3, [r6, #96]	; 0x60
57e1f4a4:	e1a03513 	lsl	r3, r3, r5
			if (status == 0) {
				printf("** TI ext2fs read block (indir 2 1)"
					"failed. **\n");
				return -1;
			}
			ext4fs_indir1_blkno =
57e1f4a8:	e5873000 	str	r3, [r7]
			    __le32_to_cpu(inode->b.blocks.triple_indir_block) <<
			    log2_blksz;
		}

		if (ext4fs_indir2_block == NULL) {
57e1f4ac:	e59f6294 	ldr	r6, [pc, #660]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f4b0:	e596a00c 	ldr	sl, [r6, #12]
57e1f4b4:	e35a0000 	cmp	sl, #0
57e1f4b8:	1a00000d 	bne	57e1f4f4 <read_allocated_block+0x660>
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f4bc:	e1a01004 	mov	r1, r4
57e1f4c0:	e3a00040 	mov	r0, #64	; 0x40
57e1f4c4:	ebffab64 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f4c8:	e1a0100a 	mov	r1, sl
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f4cc:	e1a07000 	mov	r7, r0
	memset(p, 0, size);
57e1f4d0:	e1a02004 	mov	r2, r4
57e1f4d4:	eb001368 	bl	57e2427c <memset>
			ext4fs_indir2_block = zalloc(blksz);
			if (ext4fs_indir2_block == NULL) {
57e1f4d8:	e3570000 	cmp	r7, #0
			    __le32_to_cpu(inode->b.blocks.triple_indir_block) <<
			    log2_blksz;
		}

		if (ext4fs_indir2_block == NULL) {
			ext4fs_indir2_block = zalloc(blksz);
57e1f4dc:	e586700c 	str	r7, [r6, #12]
			if (ext4fs_indir2_block == NULL) {
57e1f4e0:	0a00004b 	beq	57e1f614 <read_allocated_block+0x780>
				printf("** TI ext2fs read block (indir 2 2)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
			ext4fs_indir2_blkno = -1;
57e1f4e4:	e59f326c 	ldr	r3, [pc, #620]	; 57e1f758 <read_allocated_block+0x8c4>
57e1f4e8:	e3e02000 	mvn	r2, #0
			if (ext4fs_indir2_block == NULL) {
				printf("** TI ext2fs read block (indir 2 2)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
57e1f4ec:	e5864010 	str	r4, [r6, #16]
			ext4fs_indir2_blkno = -1;
57e1f4f0:	e5832004 	str	r2, [r3, #4]
		}
		if (blksz != ext4fs_indir2_size) {
57e1f4f4:	e59f624c 	ldr	r6, [pc, #588]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f4f8:	e5963010 	ldr	r3, [r6, #16]
57e1f4fc:	e1540003 	cmp	r4, r3
57e1f500:	0a000013 	beq	57e1f554 <read_allocated_block+0x6c0>
			free(ext4fs_indir2_block);
57e1f504:	e596000c 	ldr	r0, [r6, #12]
57e1f508:	ebffa923 	bl	57e0999c <free>
			ext4fs_indir2_block = NULL;
			ext4fs_indir2_size = 0;
			ext4fs_indir2_blkno = -1;
57e1f50c:	e59f3244 	ldr	r3, [pc, #580]	; 57e1f758 <read_allocated_block+0x8c4>
			ext4fs_indir2_size = blksz;
			ext4fs_indir2_blkno = -1;
		}
		if (blksz != ext4fs_indir2_size) {
			free(ext4fs_indir2_block);
			ext4fs_indir2_block = NULL;
57e1f510:	e3a0a000 	mov	sl, #0
			ext4fs_indir2_size = 0;
			ext4fs_indir2_blkno = -1;
57e1f514:	e3e0b000 	mvn	fp, #0
57e1f518:	e583b004 	str	fp, [r3, #4]
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f51c:	e1a01004 	mov	r1, r4
			ext4fs_indir2_size = blksz;
			ext4fs_indir2_blkno = -1;
		}
		if (blksz != ext4fs_indir2_size) {
			free(ext4fs_indir2_block);
			ext4fs_indir2_block = NULL;
57e1f520:	e586a00c 	str	sl, [r6, #12]
			ext4fs_indir2_size = 0;
57e1f524:	e586a010 	str	sl, [r6, #16]
57e1f528:	e3a00040 	mov	r0, #64	; 0x40
57e1f52c:	ebffab4a 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f530:	e1a0100a 	mov	r1, sl
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f534:	e1a07000 	mov	r7, r0
	memset(p, 0, size);
57e1f538:	e1a02004 	mov	r2, r4
57e1f53c:	eb00134e 	bl	57e2427c <memset>
			ext4fs_indir2_blkno = -1;
			ext4fs_indir2_block = zalloc(blksz);
			if (ext4fs_indir2_block == NULL) {
57e1f540:	e157000a 	cmp	r7, sl
		if (blksz != ext4fs_indir2_size) {
			free(ext4fs_indir2_block);
			ext4fs_indir2_block = NULL;
			ext4fs_indir2_size = 0;
			ext4fs_indir2_blkno = -1;
			ext4fs_indir2_block = zalloc(blksz);
57e1f544:	e586700c 	str	r7, [r6, #12]
			if (ext4fs_indir2_block == NULL) {
				printf("** TI ext2fs read block (indir 2 2)"
57e1f548:	059f022c 	ldreq	r0, [pc, #556]	; 57e1f77c <read_allocated_block+0x8e8>
			free(ext4fs_indir2_block);
			ext4fs_indir2_block = NULL;
			ext4fs_indir2_size = 0;
			ext4fs_indir2_blkno = -1;
			ext4fs_indir2_block = zalloc(blksz);
			if (ext4fs_indir2_block == NULL) {
57e1f54c:	0affff76 	beq	57e1f32c <read_allocated_block+0x498>
				printf("** TI ext2fs read block (indir 2 2)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
57e1f550:	e5864010 	str	r4, [r6, #16]
		}
		blknr = __le32_to_cpu(ext4fs_indir2_block[rblock % perblock]);
	}
	/* Tripple indirect. */
	else {
		rblock = fileblock - (INDIRECT_BLOCKS + blksz / 4 +
57e1f554:	e59de004 	ldr	lr, [sp, #4]
57e1f558:	e3540000 	cmp	r4, #0
57e1f55c:	e24e300c 	sub	r3, lr, #12
57e1f560:	e2842003 	add	r2, r4, #3
57e1f564:	a1a02004 	movge	r2, r4
57e1f568:	e0432142 	sub	r2, r3, r2, asr #2
				      (blksz / 4 * blksz / 4));
57e1f56c:	e0030994 	mul	r3, r4, r9
57e1f570:	e3530000 	cmp	r3, #0
57e1f574:	e2831003 	add	r1, r3, #3
57e1f578:	b1a03001 	movlt	r3, r1
		}
		blknr = __le32_to_cpu(ext4fs_indir2_block[rblock % perblock]);
	}
	/* Tripple indirect. */
	else {
		rblock = fileblock - (INDIRECT_BLOCKS + blksz / 4 +
57e1f57c:	e0423143 	sub	r3, r2, r3, asr #2
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir1_block[rblock /
57e1f580:	e1a00003 	mov	r0, r3
57e1f584:	e0010999 	mul	r1, r9, r9
		}
		blknr = __le32_to_cpu(ext4fs_indir2_block[rblock % perblock]);
	}
	/* Tripple indirect. */
	else {
		rblock = fileblock - (INDIRECT_BLOCKS + blksz / 4 +
57e1f588:	e58d3004 	str	r3, [sp, #4]
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir1_block[rblock /
57e1f58c:	eb00310a 	bl	57e2b9bc <__divsi3>
57e1f590:	e59f61b0 	ldr	r6, [pc, #432]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f594:	e1a0a000 	mov	sl, r0
57e1f598:	e5963004 	ldr	r3, [r6, #4]
						       perblock_parent]) <<
		     log2_blksz)
		    != ext4fs_indir2_blkno) {
57e1f59c:	e59f71b4 	ldr	r7, [pc, #436]	; 57e1f758 <read_allocated_block+0x8c4>
				return -1;
			}
			ext4fs_indir2_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir1_block[rblock /
						       perblock_parent]) <<
57e1f5a0:	e7930100 	ldr	r0, [r3, r0, lsl #2]
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir1_block[rblock /
57e1f5a4:	e5973004 	ldr	r3, [r7, #4]
						       perblock_parent]) <<
57e1f5a8:	e1a00510 	lsl	r0, r0, r5
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir2_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir1_block[rblock /
57e1f5ac:	e1500003 	cmp	r0, r3
57e1f5b0:	0a000009 	beq	57e1f5dc <read_allocated_block+0x748>
						       perblock_parent]) <<
		     log2_blksz)
		    != ext4fs_indir2_blkno) {
			status = ext4fs_devread(__le32_to_cpu
57e1f5b4:	e3a01000 	mov	r1, #0
57e1f5b8:	e1a02004 	mov	r2, r4
57e1f5bc:	e596300c 	ldr	r3, [r6, #12]
57e1f5c0:	eb000283 	bl	57e1ffd4 <ext4fs_devread>
						(ext4fs_indir1_block
						 [rblock /
						  perblock_parent]) <<
						log2_blksz, 0, blksz,
						(char *)ext4fs_indir2_block);
			if (status == 0) {
57e1f5c4:	e3500000 	cmp	r0, #0
57e1f5c8:	0a000047 	beq	57e1f6ec <read_allocated_block+0x858>
				printf("** TI ext2fs read block (indir 2 2)"
					"failed. **\n");
				return -1;
			}
			ext4fs_indir2_blkno =
			    __le32_to_cpu(ext4fs_indir1_block[rblock /
57e1f5cc:	e5963004 	ldr	r3, [r6, #4]
							      perblock_parent])
			    << log2_blksz;
57e1f5d0:	e793310a 	ldr	r3, [r3, sl, lsl #2]
57e1f5d4:	e1a03513 	lsl	r3, r3, r5
			if (status == 0) {
				printf("** TI ext2fs read block (indir 2 2)"
					"failed. **\n");
				return -1;
			}
			ext4fs_indir2_blkno =
57e1f5d8:	e5873004 	str	r3, [r7, #4]
			    __le32_to_cpu(ext4fs_indir1_block[rblock /
							      perblock_parent])
			    << log2_blksz;
		}

		if (ext4fs_indir3_block == NULL) {
57e1f5dc:	e59f6164 	ldr	r6, [pc, #356]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f5e0:	e596a014 	ldr	sl, [r6, #20]
57e1f5e4:	e35a0000 	cmp	sl, #0
57e1f5e8:	1a00000f 	bne	57e1f62c <read_allocated_block+0x798>
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f5ec:	e1a01004 	mov	r1, r4
57e1f5f0:	e3a00040 	mov	r0, #64	; 0x40
57e1f5f4:	ebffab18 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f5f8:	e1a0100a 	mov	r1, sl
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f5fc:	e1a07000 	mov	r7, r0
	memset(p, 0, size);
57e1f600:	e1a02004 	mov	r2, r4
57e1f604:	eb00131c 	bl	57e2427c <memset>
			ext4fs_indir3_block = zalloc(blksz);
			if (ext4fs_indir3_block == NULL) {
57e1f608:	e3570000 	cmp	r7, #0
							      perblock_parent])
			    << log2_blksz;
		}

		if (ext4fs_indir3_block == NULL) {
			ext4fs_indir3_block = zalloc(blksz);
57e1f60c:	e5867014 	str	r7, [r6, #20]
			if (ext4fs_indir3_block == NULL) {
57e1f610:	1a000001 	bne	57e1f61c <read_allocated_block+0x788>
				printf("** TI ext2fs read block (indir 2 2)"
57e1f614:	e59f0160 	ldr	r0, [pc, #352]	; 57e1f77c <read_allocated_block+0x8e8>
57e1f618:	ea000034 	b	57e1f6f0 <read_allocated_block+0x85c>
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir3_size = blksz;
			ext4fs_indir3_blkno = -1;
57e1f61c:	e59f3134 	ldr	r3, [pc, #308]	; 57e1f758 <read_allocated_block+0x8c4>
57e1f620:	e3e02000 	mvn	r2, #0
			if (ext4fs_indir3_block == NULL) {
				printf("** TI ext2fs read block (indir 2 2)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir3_size = blksz;
57e1f624:	e5864018 	str	r4, [r6, #24]
			ext4fs_indir3_blkno = -1;
57e1f628:	e5832008 	str	r2, [r3, #8]
		}
		if (blksz != ext4fs_indir3_size) {
57e1f62c:	e59f6114 	ldr	r6, [pc, #276]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f630:	e5963018 	ldr	r3, [r6, #24]
57e1f634:	e1540003 	cmp	r4, r3
57e1f638:	0a000016 	beq	57e1f698 <read_allocated_block+0x804>
			free(ext4fs_indir3_block);
57e1f63c:	e5960014 	ldr	r0, [r6, #20]
57e1f640:	ebffa8d5 	bl	57e0999c <free>
			ext4fs_indir3_block = NULL;
			ext4fs_indir3_size = 0;
			ext4fs_indir3_blkno = -1;
57e1f644:	e59f310c 	ldr	r3, [pc, #268]	; 57e1f758 <read_allocated_block+0x8c4>
			ext4fs_indir3_size = blksz;
			ext4fs_indir3_blkno = -1;
		}
		if (blksz != ext4fs_indir3_size) {
			free(ext4fs_indir3_block);
			ext4fs_indir3_block = NULL;
57e1f648:	e3a0b000 	mov	fp, #0
			ext4fs_indir3_size = 0;
			ext4fs_indir3_blkno = -1;
57e1f64c:	e3e0a000 	mvn	sl, #0
57e1f650:	e583a008 	str	sl, [r3, #8]
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f654:	e1a01004 	mov	r1, r4
			ext4fs_indir3_size = blksz;
			ext4fs_indir3_blkno = -1;
		}
		if (blksz != ext4fs_indir3_size) {
			free(ext4fs_indir3_block);
			ext4fs_indir3_block = NULL;
57e1f658:	e586b014 	str	fp, [r6, #20]
			ext4fs_indir3_size = 0;
57e1f65c:	e586b018 	str	fp, [r6, #24]
57e1f660:	e3a00040 	mov	r0, #64	; 0x40
57e1f664:	ebffaafc 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f668:	e1a0100b 	mov	r1, fp
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f66c:	e1a07000 	mov	r7, r0
	memset(p, 0, size);
57e1f670:	e1a02004 	mov	r2, r4
57e1f674:	eb001300 	bl	57e2427c <memset>
			ext4fs_indir3_blkno = -1;
			ext4fs_indir3_block = zalloc(blksz);
			if (ext4fs_indir3_block == NULL) {
57e1f678:	e157000b 	cmp	r7, fp
		if (blksz != ext4fs_indir3_size) {
			free(ext4fs_indir3_block);
			ext4fs_indir3_block = NULL;
			ext4fs_indir3_size = 0;
			ext4fs_indir3_blkno = -1;
			ext4fs_indir3_block = zalloc(blksz);
57e1f67c:	e5867014 	str	r7, [r6, #20]
			if (ext4fs_indir3_block == NULL) {
				printf("** TI ext2fs read block (indir 2 2)"
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir3_size = blksz;
57e1f680:	15864018 	strne	r4, [r6, #24]
			free(ext4fs_indir3_block);
			ext4fs_indir3_block = NULL;
			ext4fs_indir3_size = 0;
			ext4fs_indir3_blkno = -1;
			ext4fs_indir3_block = zalloc(blksz);
			if (ext4fs_indir3_block == NULL) {
57e1f684:	1a000003 	bne	57e1f698 <read_allocated_block+0x804>
				printf("** TI ext2fs read block (indir 2 2)"
57e1f688:	e59f00ec 	ldr	r0, [pc, #236]	; 57e1f77c <read_allocated_block+0x8e8>
57e1f68c:	ebffa76e 	bl	57e0944c <printf>
					"malloc failed. **\n");
				return -1;
57e1f690:	e1a0b00a 	mov	fp, sl
57e1f694:	ea000022 	b	57e1f724 <read_allocated_block+0x890>
			}
			ext4fs_indir3_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir2_block[rblock
57e1f698:	e59d0004 	ldr	r0, [sp, #4]
57e1f69c:	e1a01009 	mov	r1, r9
57e1f6a0:	eb0030c5 	bl	57e2b9bc <__divsi3>
57e1f6a4:	e59f609c 	ldr	r6, [pc, #156]	; 57e1f748 <read_allocated_block+0x8b4>
						       /
						       perblock_child]) <<
		     log2_blksz) != ext4fs_indir3_blkno) {
57e1f6a8:	e59f70a8 	ldr	r7, [pc, #168]	; 57e1f758 <read_allocated_block+0x8c4>
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir3_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir2_block[rblock
57e1f6ac:	e596b00c 	ldr	fp, [r6, #12]
57e1f6b0:	e5973008 	ldr	r3, [r7, #8]
						       /
						       perblock_child]) <<
57e1f6b4:	e79b2100 	ldr	r2, [fp, r0, lsl #2]
					"malloc failed. **\n");
				return -1;
			}
			ext4fs_indir3_size = blksz;
		}
		if ((__le32_to_cpu(ext4fs_indir2_block[rblock
57e1f6b8:	e1530512 	cmp	r3, r2, lsl r5
57e1f6bc:	0a000012 	beq	57e1f70c <read_allocated_block+0x878>
						       /
						       perblock_child]) <<
		     log2_blksz) != ext4fs_indir3_blkno) {
			status =
			    ext4fs_devread(__le32_to_cpu
57e1f6c0:	e1a01009 	mov	r1, r9
57e1f6c4:	eb003144 	bl	57e2bbdc <__aeabi_idivmod>
					   (ext4fs_indir2_block
					    [(rblock / perblock_child)
					     % (blksz / 4)]) << log2_blksz, 0,
57e1f6c8:	e79b0101 	ldr	r0, [fp, r1, lsl #2]
		if ((__le32_to_cpu(ext4fs_indir2_block[rblock
						       /
						       perblock_child]) <<
		     log2_blksz) != ext4fs_indir3_blkno) {
			status =
			    ext4fs_devread(__le32_to_cpu
57e1f6cc:	e1a0a001 	mov	sl, r1
		}
		if ((__le32_to_cpu(ext4fs_indir2_block[rblock
						       /
						       perblock_child]) <<
		     log2_blksz) != ext4fs_indir3_blkno) {
			status =
57e1f6d0:	e1a00510 	lsl	r0, r0, r5
57e1f6d4:	e3a01000 	mov	r1, #0
57e1f6d8:	e1a02004 	mov	r2, r4
57e1f6dc:	e5963014 	ldr	r3, [r6, #20]
57e1f6e0:	eb00023b 	bl	57e1ffd4 <ext4fs_devread>
			    ext4fs_devread(__le32_to_cpu
					   (ext4fs_indir2_block
					    [(rblock / perblock_child)
					     % (blksz / 4)]) << log2_blksz, 0,
					   blksz, (char *)ext4fs_indir3_block);
			if (status == 0) {
57e1f6e4:	e3500000 	cmp	r0, #0
57e1f6e8:	1a000003 	bne	57e1f6fc <read_allocated_block+0x868>
				printf("** TI ext2fs read block (indir 2 2)"
57e1f6ec:	e59f008c 	ldr	r0, [pc, #140]	; 57e1f780 <read_allocated_block+0x8ec>
57e1f6f0:	ebffa755 	bl	57e0944c <printf>
				       "failed. **\n");
				return -1;
57e1f6f4:	e3e0b000 	mvn	fp, #0
57e1f6f8:	ea000009 	b	57e1f724 <read_allocated_block+0x890>
			}
			ext4fs_indir3_blkno =
			    __le32_to_cpu(ext4fs_indir2_block[(rblock /
57e1f6fc:	e596300c 	ldr	r3, [r6, #12]
							       perblock_child) %
							      (blksz /
							       4)]) <<
57e1f700:	e793310a 	ldr	r3, [r3, sl, lsl #2]
57e1f704:	e1a05513 	lsl	r5, r3, r5
			if (status == 0) {
				printf("** TI ext2fs read block (indir 2 2)"
				       "failed. **\n");
				return -1;
			}
			ext4fs_indir3_blkno =
57e1f708:	e5875008 	str	r5, [r7, #8]
							      (blksz /
							       4)]) <<
			    log2_blksz;
		}

		blknr = __le32_to_cpu(ext4fs_indir3_block
57e1f70c:	e59d0004 	ldr	r0, [sp, #4]
57e1f710:	e1a01009 	mov	r1, r9
57e1f714:	eb003130 	bl	57e2bbdc <__aeabi_idivmod>
57e1f718:	e59f3028 	ldr	r3, [pc, #40]	; 57e1f748 <read_allocated_block+0x8b4>
57e1f71c:	e5933014 	ldr	r3, [r3, #20]
57e1f720:	e793b101 	ldr	fp, [r3, r1, lsl #2]
				      [rblock % perblock_child]);
	}
	debug("ext4fs_read_block %ld\n", blknr);

	return blknr;
}
57e1f724:	e1a0000b 	mov	r0, fp
57e1f728:	e28dd010 	add	sp, sp, #16
57e1f72c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
						    (struct ext4_extent_header
						     *)inode->b.
						    blocks.dir_blocks,
						    fileblock, log2_blksz);
		if (!ext_block) {
			printf("invalid extent block\n");
57e1f730:	e59f004c 	ldr	r0, [pc, #76]	; 57e1f784 <read_allocated_block+0x8f0>
57e1f734:	ebffa744 	bl	57e0944c <printf>
			free(buf);
57e1f738:	e1a00007 	mov	r0, r7
57e1f73c:	ebffa896 	bl	57e0999c <free>
			return -EINVAL;
57e1f740:	e3e0b015 	mvn	fp, #21
57e1f744:	eafffff6 	b	57e1f724 <read_allocated_block+0x890>
57e1f748:	57e48f50 	.word	0x57e48f50
57e1f74c:	0000f30a 	.word	0x0000f30a
57e1f750:	57e34e3a 	.word	0x57e34e3a
57e1f754:	57e34e48 	.word	0x57e34e48
57e1f758:	57e379b0 	.word	0x57e379b0
57e1f75c:	57e34e7c 	.word	0x57e34e7c
57e1f760:	57e34eb1 	.word	0x57e34eb1
57e1f764:	57e34ede 	.word	0x57e34ede
57e1f768:	57e34f14 	.word	0x57e34f14
57e1f76c:	57e34f43 	.word	0x57e34f43
57e1f770:	57e34f79 	.word	0x57e34f79
57e1f774:	57e34fa8 	.word	0x57e34fa8
57e1f778:	57e34fde 	.word	0x57e34fde
57e1f77c:	57e3500d 	.word	0x57e3500d
57e1f780:	57e35043 	.word	0x57e35043
57e1f784:	57e35072 	.word	0x57e35072

57e1f788 <ext4fs_close>:

	return blknr;
}

void ext4fs_close(void)
{
57e1f788:	e92d4010 	push	{r4, lr}
	if ((ext4fs_file != NULL) && (ext4fs_root != NULL)) {
57e1f78c:	e59f40c8 	ldr	r4, [pc, #200]	; 57e1f85c <ext4fs_close+0xd4>
57e1f790:	e594001c 	ldr	r0, [r4, #28]
57e1f794:	e3500000 	cmp	r0, #0
57e1f798:	0a000006 	beq	57e1f7b8 <ext4fs_close+0x30>
57e1f79c:	e5941000 	ldr	r1, [r4]
57e1f7a0:	e3510000 	cmp	r1, #0
57e1f7a4:	0a000003 	beq	57e1f7b8 <ext4fs_close+0x30>
		ext4fs_free_node(ext4fs_file, &ext4fs_root->diropen);
57e1f7a8:	e28110d0 	add	r1, r1, #208	; 0xd0
57e1f7ac:	ebfffcb5 	bl	57e1ea88 <ext4fs_free_node>
		ext4fs_file = NULL;
57e1f7b0:	e3a03000 	mov	r3, #0
57e1f7b4:	e584301c 	str	r3, [r4, #28]
	}
	if (ext4fs_root != NULL) {
57e1f7b8:	e59f409c 	ldr	r4, [pc, #156]	; 57e1f85c <ext4fs_close+0xd4>
57e1f7bc:	e5940000 	ldr	r0, [r4]
57e1f7c0:	e3500000 	cmp	r0, #0
57e1f7c4:	0a000002 	beq	57e1f7d4 <ext4fs_close+0x4c>
		free(ext4fs_root);
57e1f7c8:	ebffa873 	bl	57e0999c <free>
		ext4fs_root = NULL;
57e1f7cc:	e3a03000 	mov	r3, #0
57e1f7d0:	e5843000 	str	r3, [r4]
	}
	if (ext4fs_indir1_block != NULL) {
57e1f7d4:	e59f4080 	ldr	r4, [pc, #128]	; 57e1f85c <ext4fs_close+0xd4>
57e1f7d8:	e5940004 	ldr	r0, [r4, #4]
57e1f7dc:	e3500000 	cmp	r0, #0
57e1f7e0:	0a000006 	beq	57e1f800 <ext4fs_close+0x78>
		free(ext4fs_indir1_block);
57e1f7e4:	ebffa86c 	bl	57e0999c <free>
		ext4fs_indir1_block = NULL;
57e1f7e8:	e3a03000 	mov	r3, #0
57e1f7ec:	e5843004 	str	r3, [r4, #4]
		ext4fs_indir1_size = 0;
57e1f7f0:	e5843008 	str	r3, [r4, #8]
		ext4fs_indir1_blkno = -1;
57e1f7f4:	e59f3064 	ldr	r3, [pc, #100]	; 57e1f860 <ext4fs_close+0xd8>
57e1f7f8:	e3e02000 	mvn	r2, #0
57e1f7fc:	e5832000 	str	r2, [r3]
	}
	if (ext4fs_indir2_block != NULL) {
57e1f800:	e59f4054 	ldr	r4, [pc, #84]	; 57e1f85c <ext4fs_close+0xd4>
57e1f804:	e594000c 	ldr	r0, [r4, #12]
57e1f808:	e3500000 	cmp	r0, #0
57e1f80c:	0a000006 	beq	57e1f82c <ext4fs_close+0xa4>
		free(ext4fs_indir2_block);
57e1f810:	ebffa861 	bl	57e0999c <free>
		ext4fs_indir2_block = NULL;
57e1f814:	e3a03000 	mov	r3, #0
57e1f818:	e584300c 	str	r3, [r4, #12]
		ext4fs_indir2_size = 0;
57e1f81c:	e5843010 	str	r3, [r4, #16]
		ext4fs_indir2_blkno = -1;
57e1f820:	e59f3038 	ldr	r3, [pc, #56]	; 57e1f860 <ext4fs_close+0xd8>
57e1f824:	e3e02000 	mvn	r2, #0
57e1f828:	e5832004 	str	r2, [r3, #4]
	}
	if (ext4fs_indir3_block != NULL) {
57e1f82c:	e59f4028 	ldr	r4, [pc, #40]	; 57e1f85c <ext4fs_close+0xd4>
57e1f830:	e5940014 	ldr	r0, [r4, #20]
57e1f834:	e3500000 	cmp	r0, #0
57e1f838:	08bd8010 	popeq	{r4, pc}
		free(ext4fs_indir3_block);
57e1f83c:	ebffa856 	bl	57e0999c <free>
		ext4fs_indir3_block = NULL;
57e1f840:	e3a03000 	mov	r3, #0
57e1f844:	e5843014 	str	r3, [r4, #20]
		ext4fs_indir3_size = 0;
57e1f848:	e5843018 	str	r3, [r4, #24]
		ext4fs_indir3_blkno = -1;
57e1f84c:	e59f300c 	ldr	r3, [pc, #12]	; 57e1f860 <ext4fs_close+0xd8>
57e1f850:	e3e02000 	mvn	r2, #0
57e1f854:	e5832008 	str	r2, [r3, #8]
57e1f858:	e8bd8010 	pop	{r4, pc}
57e1f85c:	57e48f50 	.word	0x57e48f50
57e1f860:	57e379b0 	.word	0x57e379b0

57e1f864 <ext4fs_iterate_dir>:
	}
}

int ext4fs_iterate_dir(struct ext2fs_node *dir, char *name,
				struct ext2fs_node **fnode, int *ftype)
{
57e1f864:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1f868:	e28db01c 	add	fp, sp, #28
57e1f86c:	e24dd020 	sub	sp, sp, #32
57e1f870:	e50b3034 	str	r3, [fp, #-52]	; 0x34

#ifdef DEBUG
	if (name != NULL)
		printf("Iterate dir %s\n", name);
#endif /* of DEBUG */
	if (!diro->inode_read) {
57e1f874:	e5903088 	ldr	r3, [r0, #136]	; 0x88
	}
}

int ext4fs_iterate_dir(struct ext2fs_node *dir, char *name,
				struct ext2fs_node **fnode, int *ftype)
{
57e1f878:	e1a04000 	mov	r4, r0

#ifdef DEBUG
	if (name != NULL)
		printf("Iterate dir %s\n", name);
#endif /* of DEBUG */
	if (!diro->inode_read) {
57e1f87c:	e3530000 	cmp	r3, #0
	}
}

int ext4fs_iterate_dir(struct ext2fs_node *dir, char *name,
				struct ext2fs_node **fnode, int *ftype)
{
57e1f880:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
57e1f884:	e50b2030 	str	r2, [fp, #-48]	; 0x30

#ifdef DEBUG
	if (name != NULL)
		printf("Iterate dir %s\n", name);
#endif /* of DEBUG */
	if (!diro->inode_read) {
57e1f888:	0a000002 	beq	57e1f898 <ext4fs_iterate_dir+0x34>
								 __le32_to_cpu(
								 dirent.inode),
								 &fdiro->inode);
					if (status == 0) {
						free(fdiro);
						return 0;
57e1f88c:	e3a05000 	mov	r5, #0
					}
					fdiro->inode_read = 1;
57e1f890:	e3a09001 	mov	r9, #1
57e1f894:	ea00008a 	b	57e1fac4 <ext4fs_iterate_dir+0x260>
#ifdef DEBUG
	if (name != NULL)
		printf("Iterate dir %s\n", name);
#endif /* of DEBUG */
	if (!diro->inode_read) {
		status = ext4fs_read_inode(diro->data, diro->ino, &diro->inode);
57e1f898:	e5900000 	ldr	r0, [r0]
57e1f89c:	e5941084 	ldr	r1, [r4, #132]	; 0x84
57e1f8a0:	e2842004 	add	r2, r4, #4
57e1f8a4:	ebfffd39 	bl	57e1ed90 <ext4fs_read_inode>
		if (status == 0)
57e1f8a8:	e3500000 	cmp	r0, #0
57e1f8ac:	1afffff6 	bne	57e1f88c <ext4fs_iterate_dir+0x28>
57e1f8b0:	ea000087 	b	57e1fad4 <ext4fs_iterate_dir+0x270>
	}
	/* Search the file.  */
	while (fpos < __le32_to_cpu(diro->inode.size)) {
		struct ext2_dirent dirent;

		status = ext4fs_read_file(diro, fpos,
57e1f8b4:	e1a00004 	mov	r0, r4
57e1f8b8:	e1a01005 	mov	r1, r5
57e1f8bc:	e3a02008 	mov	r2, #8
57e1f8c0:	e24b3024 	sub	r3, fp, #36	; 0x24
57e1f8c4:	ebfffc77 	bl	57e1eaa8 <ext4fs_read_file>
					   sizeof(struct ext2_dirent),
					   (char *) &dirent);
		if (status < 1)
57e1f8c8:	e3500000 	cmp	r0, #0
57e1f8cc:	da00007f 	ble	57e1fad0 <ext4fs_iterate_dir+0x26c>
			return 0;

		if (dirent.namelen != 0) {
57e1f8d0:	e55b201e 	ldrb	r2, [fp, #-30]
57e1f8d4:	e3520000 	cmp	r2, #0
57e1f8d8:	0a000077 	beq	57e1fabc <ext4fs_iterate_dir+0x258>
			char filename[dirent.namelen + 1];
57e1f8dc:	e282300f 	add	r3, r2, #15
57e1f8e0:	e2033f7e 	and	r3, r3, #504	; 0x1f8
					   sizeof(struct ext2_dirent),
					   (char *) &dirent);
		if (status < 1)
			return 0;

		if (dirent.namelen != 0) {
57e1f8e4:	e50bd028 	str	sp, [fp, #-40]	; 0x28
			char filename[dirent.namelen + 1];
57e1f8e8:	e04dd003 	sub	sp, sp, r3
57e1f8ec:	e1a0300d 	mov	r3, sp
57e1f8f0:	e1a071a3 	lsr	r7, r3, #3
57e1f8f4:	e1a0a187 	lsl	sl, r7, #3
			struct ext2fs_node *fdiro;
			int type = FILETYPE_UNKNOWN;

			status = ext4fs_read_file(diro,
57e1f8f8:	e1a00004 	mov	r0, r4
57e1f8fc:	e2851008 	add	r1, r5, #8
57e1f900:	e1a0300a 	mov	r3, sl
57e1f904:	ebfffc67 	bl	57e1eaa8 <ext4fs_read_file>
						  fpos +
						  sizeof(struct ext2_dirent),
						  dirent.namelen, filename);
			if (status < 1)
57e1f908:	e3500000 	cmp	r0, #0
57e1f90c:	da000065 	ble	57e1faa8 <ext4fs_iterate_dir+0x244>
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f910:	e3a0108c 	mov	r1, #140	; 0x8c
57e1f914:	e3a00040 	mov	r0, #64	; 0x40
57e1f918:	ebffaa4f 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1f91c:	e3a01000 	mov	r1, #0
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1f920:	e1a06000 	mov	r6, r0
	memset(p, 0, size);
57e1f924:	e3a0208c 	mov	r2, #140	; 0x8c
57e1f928:	eb001253 	bl	57e2427c <memset>
				return 0;

			fdiro = zalloc(sizeof(struct ext2fs_node));
			if (!fdiro)
57e1f92c:	e3560000 	cmp	r6, #0
57e1f930:	0a00005e 	beq	57e1fab0 <ext4fs_iterate_dir+0x24c>
				return 0;

			fdiro->data = diro->data;
57e1f934:	e5943000 	ldr	r3, [r4]
			fdiro->ino = __le32_to_cpu(dirent.inode);
57e1f938:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24

			fdiro = zalloc(sizeof(struct ext2fs_node));
			if (!fdiro)
				return 0;

			fdiro->data = diro->data;
57e1f93c:	e5863000 	str	r3, [r6]
			fdiro->ino = __le32_to_cpu(dirent.inode);

			filename[dirent.namelen] = '\0';
57e1f940:	e55b201e 	ldrb	r2, [fp, #-30]
57e1f944:	e3a03000 	mov	r3, #0
			fdiro = zalloc(sizeof(struct ext2fs_node));
			if (!fdiro)
				return 0;

			fdiro->data = diro->data;
			fdiro->ino = __le32_to_cpu(dirent.inode);
57e1f948:	e5861084 	str	r1, [r6, #132]	; 0x84

			filename[dirent.namelen] = '\0';
57e1f94c:	e7c23187 	strb	r3, [r2, r7, lsl #3]

			if (dirent.filetype != FILETYPE_UNKNOWN) {
57e1f950:	e55b701d 	ldrb	r7, [fp, #-29]
57e1f954:	e1570003 	cmp	r7, r3
57e1f958:	0a000008 	beq	57e1f980 <ext4fs_iterate_dir+0x11c>
				fdiro->inode_read = 0;

				if (dirent.filetype == FILETYPE_DIRECTORY)
57e1f95c:	e3570002 	cmp	r7, #2
			fdiro->ino = __le32_to_cpu(dirent.inode);

			filename[dirent.namelen] = '\0';

			if (dirent.filetype != FILETYPE_UNKNOWN) {
				fdiro->inode_read = 0;
57e1f960:	e5863088 	str	r3, [r6, #136]	; 0x88

				if (dirent.filetype == FILETYPE_DIRECTORY)
57e1f964:	0a00001a 	beq	57e1f9d4 <ext4fs_iterate_dir+0x170>
					type = FILETYPE_DIRECTORY;
				else if (dirent.filetype == FILETYPE_SYMLINK)
57e1f968:	e3570007 	cmp	r7, #7
57e1f96c:	0a000018 	beq	57e1f9d4 <ext4fs_iterate_dir+0x170>
			return 0;

		if (dirent.namelen != 0) {
			char filename[dirent.namelen + 1];
			struct ext2fs_node *fdiro;
			int type = FILETYPE_UNKNOWN;
57e1f970:	e3570001 	cmp	r7, #1
57e1f974:	03a07001 	moveq	r7, #1
57e1f978:	11a07003 	movne	r7, r3
57e1f97c:	ea000014 	b	57e1f9d4 <ext4fs_iterate_dir+0x170>
				else if (dirent.filetype == FILETYPE_SYMLINK)
					type = FILETYPE_SYMLINK;
				else if (dirent.filetype == FILETYPE_REG)
					type = FILETYPE_REG;
			} else {
				status = ext4fs_read_inode(diro->data,
57e1f980:	e5940000 	ldr	r0, [r4]
57e1f984:	e2862004 	add	r2, r6, #4
57e1f988:	ebfffd00 	bl	57e1ed90 <ext4fs_read_inode>
							   __le32_to_cpu
							   (dirent.inode),
							   &fdiro->inode);
				if (status == 0) {
57e1f98c:	e2507000 	subs	r7, r0, #0
57e1f990:	1a000003 	bne	57e1f9a4 <ext4fs_iterate_dir+0x140>
					free(fdiro);
57e1f994:	e1a00006 	mov	r0, r6
57e1f998:	ebffa7ff 	bl	57e0999c <free>
					return 0;
57e1f99c:	e1a00007 	mov	r0, r7
57e1f9a0:	ea000043 	b	57e1fab4 <ext4fs_iterate_dir+0x250>
				}
				fdiro->inode_read = 1;

				if ((__le16_to_cpu(fdiro->inode.mode) &
57e1f9a4:	e1d670b4 	ldrh	r7, [r6, #4]
							   &fdiro->inode);
				if (status == 0) {
					free(fdiro);
					return 0;
				}
				fdiro->inode_read = 1;
57e1f9a8:	e5869088 	str	r9, [r6, #136]	; 0x88

				if ((__le16_to_cpu(fdiro->inode.mode) &
57e1f9ac:	e2077a0f 	and	r7, r7, #61440	; 0xf000
57e1f9b0:	e3570901 	cmp	r7, #16384	; 0x4000
				     FILETYPE_INO_MASK) ==
				    FILETYPE_INO_DIRECTORY) {
					type = FILETYPE_DIRECTORY;
57e1f9b4:	03a07002 	moveq	r7, #2
					free(fdiro);
					return 0;
				}
				fdiro->inode_read = 1;

				if ((__le16_to_cpu(fdiro->inode.mode) &
57e1f9b8:	0a000005 	beq	57e1f9d4 <ext4fs_iterate_dir+0x170>
				     FILETYPE_INO_MASK) ==
				    FILETYPE_INO_DIRECTORY) {
					type = FILETYPE_DIRECTORY;
				} else if ((__le16_to_cpu(fdiro->inode.mode)
57e1f9bc:	e3570a0a 	cmp	r7, #40960	; 0xa000
					    & FILETYPE_INO_MASK) ==
					   FILETYPE_INO_SYMLINK) {
					type = FILETYPE_SYMLINK;
57e1f9c0:	03a07007 	moveq	r7, #7

				if ((__le16_to_cpu(fdiro->inode.mode) &
				     FILETYPE_INO_MASK) ==
				    FILETYPE_INO_DIRECTORY) {
					type = FILETYPE_DIRECTORY;
				} else if ((__le16_to_cpu(fdiro->inode.mode)
57e1f9c4:	0a000002 	beq	57e1f9d4 <ext4fs_iterate_dir+0x170>
			return 0;

		if (dirent.namelen != 0) {
			char filename[dirent.namelen + 1];
			struct ext2fs_node *fdiro;
			int type = FILETYPE_UNKNOWN;
57e1f9c8:	e3570902 	cmp	r7, #32768	; 0x8000
57e1f9cc:	13a07000 	movne	r7, #0
57e1f9d0:	03a07001 	moveq	r7, #1
				}
			}
#ifdef DEBUG
			printf("iterate >%s<\n", filename);
#endif /* of DEBUG */
			if ((name != NULL) && (fnode != NULL)
57e1f9d4:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
57e1f9d8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
57e1f9dc:	e3520000 	cmp	r2, #0
57e1f9e0:	13530000 	cmpne	r3, #0
57e1f9e4:	0a00000d 	beq	57e1fa20 <ext4fs_iterate_dir+0x1bc>
			    && (ftype != NULL)) {
57e1f9e8:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
57e1f9ec:	e3520000 	cmp	r2, #0
57e1f9f0:	0a00000a 	beq	57e1fa20 <ext4fs_iterate_dir+0x1bc>
				if (strcmp(filename, name) == 0) {
57e1f9f4:	e1a0000a 	mov	r0, sl
57e1f9f8:	e1a01003 	mov	r1, r3
57e1f9fc:	eb001168 	bl	57e23fa4 <strcmp>
57e1fa00:	e3500000 	cmp	r0, #0
57e1fa04:	1a000023 	bne	57e1fa98 <ext4fs_iterate_dir+0x234>
					*ftype = type;
57e1fa08:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
					*fnode = fdiro;
57e1fa0c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
			printf("iterate >%s<\n", filename);
#endif /* of DEBUG */
			if ((name != NULL) && (fnode != NULL)
			    && (ftype != NULL)) {
				if (strcmp(filename, name) == 0) {
					*ftype = type;
57e1fa10:	e5837000 	str	r7, [r3]
					*fnode = fdiro;
					return 1;
57e1fa14:	e2800001 	add	r0, r0, #1
#endif /* of DEBUG */
			if ((name != NULL) && (fnode != NULL)
			    && (ftype != NULL)) {
				if (strcmp(filename, name) == 0) {
					*ftype = type;
					*fnode = fdiro;
57e1fa18:	e5826000 	str	r6, [r2]
57e1fa1c:	ea000024 	b	57e1fab4 <ext4fs_iterate_dir+0x250>
					return 1;
				}
			} else {
				if (fdiro->inode_read == 0) {
57e1fa20:	e5963088 	ldr	r3, [r6, #136]	; 0x88
57e1fa24:	e3530000 	cmp	r3, #0
57e1fa28:	1a00000c 	bne	57e1fa60 <ext4fs_iterate_dir+0x1fc>
					status = ext4fs_read_inode(diro->data,
57e1fa2c:	e5940000 	ldr	r0, [r4]
57e1fa30:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
57e1fa34:	e2862004 	add	r2, r6, #4
57e1fa38:	ebfffcd4 	bl	57e1ed90 <ext4fs_read_inode>
								 __le32_to_cpu(
								 dirent.inode),
								 &fdiro->inode);
					if (status == 0) {
57e1fa3c:	e2503000 	subs	r3, r0, #0
57e1fa40:	1a000005 	bne	57e1fa5c <ext4fs_iterate_dir+0x1f8>
						free(fdiro);
57e1fa44:	e1a00006 	mov	r0, r6
57e1fa48:	e50b3038 	str	r3, [fp, #-56]	; 0x38
57e1fa4c:	ebffa7d2 	bl	57e0999c <free>
						return 0;
57e1fa50:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
57e1fa54:	e1a00003 	mov	r0, r3
57e1fa58:	ea000015 	b	57e1fab4 <ext4fs_iterate_dir+0x250>
					}
					fdiro->inode_read = 1;
57e1fa5c:	e5869088 	str	r9, [r6, #136]	; 0x88
				}
				switch (type) {
57e1fa60:	e3570002 	cmp	r7, #2
				case FILETYPE_DIRECTORY:
					printf("<DIR> ");
57e1fa64:	059f0070 	ldreq	r0, [pc, #112]	; 57e1fadc <ext4fs_iterate_dir+0x278>
						free(fdiro);
						return 0;
					}
					fdiro->inode_read = 1;
				}
				switch (type) {
57e1fa68:	0a000005 	beq	57e1fa84 <ext4fs_iterate_dir+0x220>
57e1fa6c:	e3570007 	cmp	r7, #7
				case FILETYPE_DIRECTORY:
					printf("<DIR> ");
					break;
				case FILETYPE_SYMLINK:
					printf("<SYM> ");
57e1fa70:	059f0068 	ldreq	r0, [pc, #104]	; 57e1fae0 <ext4fs_iterate_dir+0x27c>
						free(fdiro);
						return 0;
					}
					fdiro->inode_read = 1;
				}
				switch (type) {
57e1fa74:	0a000002 	beq	57e1fa84 <ext4fs_iterate_dir+0x220>
57e1fa78:	e3570001 	cmp	r7, #1
					break;
				case FILETYPE_REG:
					printf("      ");
					break;
				default:
					printf("< ? > ");
57e1fa7c:	159f0060 	ldrne	r0, [pc, #96]	; 57e1fae4 <ext4fs_iterate_dir+0x280>
					break;
				case FILETYPE_SYMLINK:
					printf("<SYM> ");
					break;
				case FILETYPE_REG:
					printf("      ");
57e1fa80:	059f0060 	ldreq	r0, [pc, #96]	; 57e1fae8 <ext4fs_iterate_dir+0x284>
					break;
				default:
					printf("< ? > ");
57e1fa84:	ebffa670 	bl	57e0944c <printf>
					break;
				}
				printf("%10d %s\n",
57e1fa88:	e59f005c 	ldr	r0, [pc, #92]	; 57e1faec <ext4fs_iterate_dir+0x288>
57e1fa8c:	e5961008 	ldr	r1, [r6, #8]
57e1fa90:	e1a0200a 	mov	r2, sl
57e1fa94:	ebffa66c 	bl	57e0944c <printf>
					__le32_to_cpu(fdiro->inode.size),
					filename);
			}
			free(fdiro);
57e1fa98:	e1a00006 	mov	r0, r6
57e1fa9c:	ebffa7be 	bl	57e0999c <free>
57e1faa0:	e51bd028 	ldr	sp, [fp, #-40]	; 0x28
57e1faa4:	ea000004 	b	57e1fabc <ext4fs_iterate_dir+0x258>
			status = ext4fs_read_file(diro,
						  fpos +
						  sizeof(struct ext2_dirent),
						  dirent.namelen, filename);
			if (status < 1)
				return 0;
57e1faa8:	e3a00000 	mov	r0, #0
57e1faac:	ea000000 	b	57e1fab4 <ext4fs_iterate_dir+0x250>

			fdiro = zalloc(sizeof(struct ext2fs_node));
			if (!fdiro)
				return 0;
57e1fab0:	e1a00006 	mov	r0, r6
				}
				printf("%10d %s\n",
					__le32_to_cpu(fdiro->inode.size),
					filename);
			}
			free(fdiro);
57e1fab4:	e51bd028 	ldr	sp, [fp, #-40]	; 0x28
57e1fab8:	ea000005 	b	57e1fad4 <ext4fs_iterate_dir+0x270>
		}
		fpos += __le16_to_cpu(dirent.direntlen);
57e1fabc:	e15b32b0 	ldrh	r3, [fp, #-32]	; 0xffffffe0
57e1fac0:	e0855003 	add	r5, r5, r3
		status = ext4fs_read_inode(diro->data, diro->ino, &diro->inode);
		if (status == 0)
			return 0;
	}
	/* Search the file.  */
	while (fpos < __le32_to_cpu(diro->inode.size)) {
57e1fac4:	e5943008 	ldr	r3, [r4, #8]
57e1fac8:	e1550003 	cmp	r5, r3
57e1facc:	3affff78 	bcc	57e1f8b4 <ext4fs_iterate_dir+0x50>

		status = ext4fs_read_file(diro, fpos,
					   sizeof(struct ext2_dirent),
					   (char *) &dirent);
		if (status < 1)
			return 0;
57e1fad0:	e3a00000 	mov	r0, #0
			free(fdiro);
		}
		fpos += __le16_to_cpu(dirent.direntlen);
	}
	return 0;
}
57e1fad4:	e24bd01c 	sub	sp, fp, #28
57e1fad8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1fadc:	57e35088 	.word	0x57e35088
57e1fae0:	57e3508f 	.word	0x57e3508f
57e1fae4:	57e3509d 	.word	0x57e3509d
57e1fae8:	57e35096 	.word	0x57e35096
57e1faec:	57e350a4 	.word	0x57e350a4

57e1faf0 <ext4fs_find_file1>:
}

static int ext4fs_find_file1(const char *currpath,
			     struct ext2fs_node *currroot,
			     struct ext2fs_node **currfound, int *foundtype)
{
57e1faf0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1faf4:	e28db01c 	add	fp, sp, #28
57e1faf8:	e24dd018 	sub	sp, sp, #24
57e1fafc:	e1a06001 	mov	r6, r1
57e1fb00:	e1a04000 	mov	r4, r0
57e1fb04:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
57e1fb08:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	char fpath[strlen(currpath) + 1];
57e1fb0c:	eb00114f 	bl	57e24050 <strlen>
57e1fb10:	e280000f 	add	r0, r0, #15
57e1fb14:	e3c00007 	bic	r0, r0, #7
57e1fb18:	e04dd000 	sub	sp, sp, r0
	char *name = fpath;
	char *next;
	int status;
	int type = FILETYPE_DIRECTORY;
57e1fb1c:	e3a03002 	mov	r3, #2
	struct ext2fs_node *currnode = currroot;
	struct ext2fs_node *oldnode = currroot;

	strncpy(fpath, currpath, strlen(currpath) + 1);
57e1fb20:	e1a00004 	mov	r0, r4
{
	char fpath[strlen(currpath) + 1];
	char *name = fpath;
	char *next;
	int status;
	int type = FILETYPE_DIRECTORY;
57e1fb24:	e50b3020 	str	r3, [fp, #-32]
	struct ext2fs_node *currnode = currroot;
57e1fb28:	e50b6024 	str	r6, [fp, #-36]	; 0x24
	struct ext2fs_node *oldnode = currroot;

	strncpy(fpath, currpath, strlen(currpath) + 1);
57e1fb2c:	eb001147 	bl	57e24050 <strlen>
57e1fb30:	e1a01004 	mov	r1, r4
57e1fb34:	e2802001 	add	r2, r0, #1
57e1fb38:	e1a0000d 	mov	r0, sp

static int ext4fs_find_file1(const char *currpath,
			     struct ext2fs_node *currroot,
			     struct ext2fs_node **currfound, int *foundtype)
{
	char fpath[strlen(currpath) + 1];
57e1fb3c:	e1a0500d 	mov	r5, sp
	int status;
	int type = FILETYPE_DIRECTORY;
	struct ext2fs_node *currnode = currroot;
	struct ext2fs_node *oldnode = currroot;

	strncpy(fpath, currpath, strlen(currpath) + 1);
57e1fb40:	eb0010ed 	bl	57e23efc <strncpy>

	/* Remove all leading slashes. */
	while (*name == '/')
57e1fb44:	e1a04005 	mov	r4, r5
57e1fb48:	e4d53001 	ldrb	r3, [r5], #1
57e1fb4c:	e353002f 	cmp	r3, #47	; 0x2f
57e1fb50:	0afffffb 	beq	57e1fb44 <ext4fs_find_file1+0x54>
		name++;

	if (!*name) {
57e1fb54:	e3530000 	cmp	r3, #0
		*currfound = currnode;
57e1fb58:	051b3024 	ldreq	r3, [fp, #-36]	; 0x24
57e1fb5c:	051b102c 	ldreq	r1, [fp, #-44]	; 0x2c
57e1fb60:	05813000 	streq	r3, [r1]

	/* Remove all leading slashes. */
	while (*name == '/')
		name++;

	if (!*name) {
57e1fb64:	1a000002 	bne	57e1fb74 <ext4fs_find_file1+0x84>
57e1fb68:	ea000089 	b	57e1fd94 <ext4fs_find_file1+0x2a4>
		}

		ext4fs_free_node(oldnode, currroot);

		/* Found the node! */
		if (!next || *next == '\0') {
57e1fb6c:	e1a0400a 	mov	r4, sl
57e1fb70:	ea000000 	b	57e1fb78 <ext4fs_find_file1+0x88>
		/* Read in the symlink and follow it. */
		if (type == FILETYPE_SYMLINK) {
			char *symlink;

			/* Test if the symlink does not loop. */
			if (++symlinknest == 8) {
57e1fb74:	e59f9224 	ldr	r9, [pc, #548]	; 57e1fda0 <ext4fs_find_file1+0x2b0>

	for (;;) {
		int found;

		/* Extract the actual part from the pathname. */
		next = strchr(name, '/');
57e1fb78:	e1a00004 	mov	r0, r4
57e1fb7c:	e3a0102f 	mov	r1, #47	; 0x2f
57e1fb80:	eb001125 	bl	57e2401c <strchr>
		if (next) {
57e1fb84:	e250a000 	subs	sl, r0, #0
57e1fb88:	11a0300a 	movne	r3, sl
57e1fb8c:	1a000002 	bne	57e1fb9c <ext4fs_find_file1+0xac>
57e1fb90:	ea000005 	b	57e1fbac <ext4fs_find_file1+0xbc>
			/* Remove all leading slashes. */
			while (*next == '/')
				*(next++) = '\0';
57e1fb94:	e3a02000 	mov	r2, #0
57e1fb98:	e5432001 	strb	r2, [r3, #-1]
57e1fb9c:	e1a0a003 	mov	sl, r3

		/* Extract the actual part from the pathname. */
		next = strchr(name, '/');
		if (next) {
			/* Remove all leading slashes. */
			while (*next == '/')
57e1fba0:	e4d32001 	ldrb	r2, [r3], #1
57e1fba4:	e352002f 	cmp	r2, #47	; 0x2f
57e1fba8:	0afffff9 	beq	57e1fb94 <ext4fs_find_file1+0xa4>
				*(next++) = '\0';
		}

		if (type != FILETYPE_DIRECTORY) {
57e1fbac:	e51b3020 	ldr	r3, [fp, #-32]
57e1fbb0:	e3530002 	cmp	r3, #2
			ext4fs_free_node(currnode, currroot);
57e1fbb4:	151b0024 	ldrne	r0, [fp, #-36]	; 0x24
57e1fbb8:	1a000015 	bne	57e1fc14 <ext4fs_find_file1+0x124>
			return 0;
		}

		oldnode = currnode;
57e1fbbc:	e51b7024 	ldr	r7, [fp, #-36]	; 0x24

		/* Iterate over the directory. */
		found = ext4fs_iterate_dir(currnode, name, &currnode, &type);
57e1fbc0:	e1a01004 	mov	r1, r4
57e1fbc4:	e1a00007 	mov	r0, r7
57e1fbc8:	e24b2024 	sub	r2, fp, #36	; 0x24
57e1fbcc:	e24b3020 	sub	r3, fp, #32
57e1fbd0:	ebffff23 	bl	57e1f864 <ext4fs_iterate_dir>
		if (found == 0)
57e1fbd4:	e3500000 	cmp	r0, #0
57e1fbd8:	0a00006e 	beq	57e1fd98 <ext4fs_find_file1+0x2a8>
			return 0;

		if (found == -1)
57e1fbdc:	e3700001 	cmn	r0, #1
57e1fbe0:	0a00006c 	beq	57e1fd98 <ext4fs_find_file1+0x2a8>
			break;

		/* Read in the symlink and follow it. */
		if (type == FILETYPE_SYMLINK) {
57e1fbe4:	e51b3020 	ldr	r3, [fp, #-32]
57e1fbe8:	e3530007 	cmp	r3, #7
57e1fbec:	1a00005a 	bne	57e1fd5c <ext4fs_find_file1+0x26c>
			char *symlink;

			/* Test if the symlink does not loop. */
			if (++symlinknest == 8) {
57e1fbf0:	e5993020 	ldr	r3, [r9, #32]
57e1fbf4:	e2833001 	add	r3, r3, #1
57e1fbf8:	e3530008 	cmp	r3, #8
57e1fbfc:	e5893020 	str	r3, [r9, #32]
57e1fc00:	1a000007 	bne	57e1fc24 <ext4fs_find_file1+0x134>
				ext4fs_free_node(currnode, currroot);
57e1fc04:	e51b0024 	ldr	r0, [fp, #-36]	; 0x24
57e1fc08:	e1a01006 	mov	r1, r6
57e1fc0c:	ebfffb9d 	bl	57e1ea88 <ext4fs_free_node>
				ext4fs_free_node(oldnode, currroot);
57e1fc10:	e1a00007 	mov	r0, r7
57e1fc14:	e1a01006 	mov	r1, r6
57e1fc18:	ebfffb9a 	bl	57e1ea88 <ext4fs_free_node>
				return 0;
57e1fc1c:	e3a00000 	mov	r0, #0
57e1fc20:	ea00005c 	b	57e1fd98 <ext4fs_find_file1+0x2a8>
			}

			symlink = ext4fs_read_symlink(currnode);
57e1fc24:	e51b5024 	ldr	r5, [fp, #-36]	; 0x24
{
	char *symlink;
	struct ext2fs_node *diro = node;
	int status;

	if (!diro->inode_read) {
57e1fc28:	e5953088 	ldr	r3, [r5, #136]	; 0x88
57e1fc2c:	e3530000 	cmp	r3, #0
57e1fc30:	1a000005 	bne	57e1fc4c <ext4fs_find_file1+0x15c>
		status = ext4fs_read_inode(diro->data, diro->ino, &diro->inode);
57e1fc34:	e5950000 	ldr	r0, [r5]
57e1fc38:	e5951084 	ldr	r1, [r5, #132]	; 0x84
57e1fc3c:	e2852004 	add	r2, r5, #4
57e1fc40:	ebfffc52 	bl	57e1ed90 <ext4fs_read_inode>
		if (status == 0)
57e1fc44:	e2504000 	subs	r4, r0, #0
57e1fc48:	0a000022 	beq	57e1fcd8 <ext4fs_find_file1+0x1e8>
			return 0;
	}
	symlink = zalloc(__le32_to_cpu(diro->inode.size) + 1);
57e1fc4c:	e5954008 	ldr	r4, [r5, #8]
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1fc50:	e3a00040 	mov	r0, #64	; 0x40
57e1fc54:	e2844001 	add	r4, r4, #1
57e1fc58:	e1a01004 	mov	r1, r4
57e1fc5c:	ebffa97e 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1fc60:	e1a02004 	mov	r2, r4
57e1fc64:	e3a01000 	mov	r1, #0
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1fc68:	e50b0028 	str	r0, [fp, #-40]	; 0x28
	memset(p, 0, size);
57e1fc6c:	eb001182 	bl	57e2427c <memset>
57e1fc70:	e51b4028 	ldr	r4, [fp, #-40]	; 0x28
	if (!symlink)
57e1fc74:	e3540000 	cmp	r4, #0
57e1fc78:	0a000016 	beq	57e1fcd8 <ext4fs_find_file1+0x1e8>
		return 0;

	if (__le32_to_cpu(diro->inode.size) <= 60) {
57e1fc7c:	e5952008 	ldr	r2, [r5, #8]
57e1fc80:	e352003c 	cmp	r2, #60	; 0x3c
57e1fc84:	8a000003 	bhi	57e1fc98 <ext4fs_find_file1+0x1a8>
		strncpy(symlink, diro->inode.b.symlink,
57e1fc88:	e1a00004 	mov	r0, r4
57e1fc8c:	e285102c 	add	r1, r5, #44	; 0x2c
57e1fc90:	eb001099 	bl	57e23efc <strncpy>
57e1fc94:	ea00000b 	b	57e1fcc8 <ext4fs_find_file1+0x1d8>
			 __le32_to_cpu(diro->inode.size));
	} else {
		status = ext4fs_read_file(diro, 0,
57e1fc98:	e1a03004 	mov	r3, r4
57e1fc9c:	e1a00005 	mov	r0, r5
57e1fca0:	e3a01000 	mov	r1, #0
57e1fca4:	ebfffb7f 	bl	57e1eaa8 <ext4fs_read_file>
					   __le32_to_cpu(diro->inode.size),
					   symlink);
		if (status == 0) {
57e1fca8:	e2503000 	subs	r3, r0, #0
57e1fcac:	1a000005 	bne	57e1fcc8 <ext4fs_find_file1+0x1d8>
			free(symlink);
57e1fcb0:	e1a00004 	mov	r0, r4
57e1fcb4:	e50b3034 	str	r3, [fp, #-52]	; 0x34
57e1fcb8:	ebffa737 	bl	57e0999c <free>
			return 0;
57e1fcbc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
57e1fcc0:	e1a04003 	mov	r4, r3
57e1fcc4:	ea000003 	b	57e1fcd8 <ext4fs_find_file1+0x1e8>
		}
	}
	symlink[__le32_to_cpu(diro->inode.size)] = '\0';
57e1fcc8:	e5953008 	ldr	r3, [r5, #8]
57e1fccc:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
57e1fcd0:	e3a01000 	mov	r1, #0
57e1fcd4:	e7c21003 	strb	r1, [r2, r3]
				ext4fs_free_node(oldnode, currroot);
				return 0;
			}

			symlink = ext4fs_read_symlink(currnode);
			ext4fs_free_node(currnode, currroot);
57e1fcd8:	e51b0024 	ldr	r0, [fp, #-36]	; 0x24
57e1fcdc:	e1a01006 	mov	r1, r6
57e1fce0:	ebfffb68 	bl	57e1ea88 <ext4fs_free_node>

			if (!symlink) {
57e1fce4:	e3540000 	cmp	r4, #0
57e1fce8:	1a000004 	bne	57e1fd00 <ext4fs_find_file1+0x210>
				ext4fs_free_node(oldnode, currroot);
57e1fcec:	e1a00007 	mov	r0, r7
57e1fcf0:	e1a01006 	mov	r1, r6
57e1fcf4:	ebfffb63 	bl	57e1ea88 <ext4fs_free_node>
				return 0;
57e1fcf8:	e1a00004 	mov	r0, r4
57e1fcfc:	ea000025 	b	57e1fd98 <ext4fs_find_file1+0x2a8>
			}

			debug("Got symlink >%s<\n", symlink);

			if (symlink[0] == '/') {
57e1fd00:	e5d43000 	ldrb	r3, [r4]
57e1fd04:	e353002f 	cmp	r3, #47	; 0x2f
57e1fd08:	1a000004 	bne	57e1fd20 <ext4fs_find_file1+0x230>
				ext4fs_free_node(oldnode, currroot);
57e1fd0c:	e1a00007 	mov	r0, r7
57e1fd10:	e1a01006 	mov	r1, r6
57e1fd14:	ebfffb5b 	bl	57e1ea88 <ext4fs_free_node>
				oldnode = &ext4fs_root->diropen;
57e1fd18:	e5997000 	ldr	r7, [r9]
57e1fd1c:	e28770d0 	add	r7, r7, #208	; 0xd0
			}

			/* Lookup the node the symlink points to. */
			status = ext4fs_find_file1(symlink, oldnode,
57e1fd20:	e1a01007 	mov	r1, r7
57e1fd24:	e24b2024 	sub	r2, fp, #36	; 0x24
57e1fd28:	e24b3020 	sub	r3, fp, #32
57e1fd2c:	e1a00004 	mov	r0, r4
57e1fd30:	ebffff6e 	bl	57e1faf0 <ext4fs_find_file1>
57e1fd34:	e1a05000 	mov	r5, r0
						    &currnode, &type);

			free(symlink);
57e1fd38:	e1a00004 	mov	r0, r4
57e1fd3c:	ebffa716 	bl	57e0999c <free>

			if (status == 0) {
57e1fd40:	e3550000 	cmp	r5, #0
57e1fd44:	1a000004 	bne	57e1fd5c <ext4fs_find_file1+0x26c>
				ext4fs_free_node(oldnode, currroot);
57e1fd48:	e1a00007 	mov	r0, r7
57e1fd4c:	e1a01006 	mov	r1, r6
57e1fd50:	ebfffb4c 	bl	57e1ea88 <ext4fs_free_node>
				return 0;
57e1fd54:	e1a00005 	mov	r0, r5
57e1fd58:	ea00000e 	b	57e1fd98 <ext4fs_find_file1+0x2a8>
			}
		}

		ext4fs_free_node(oldnode, currroot);
57e1fd5c:	e1a00007 	mov	r0, r7
57e1fd60:	e1a01006 	mov	r1, r6
57e1fd64:	ebfffb47 	bl	57e1ea88 <ext4fs_free_node>

		/* Found the node! */
		if (!next || *next == '\0') {
57e1fd68:	e35a0000 	cmp	sl, #0
57e1fd6c:	0a000002 	beq	57e1fd7c <ext4fs_find_file1+0x28c>
57e1fd70:	e5da3000 	ldrb	r3, [sl]
57e1fd74:	e3530000 	cmp	r3, #0
57e1fd78:	1affff7b 	bne	57e1fb6c <ext4fs_find_file1+0x7c>
			*currfound = currnode;
57e1fd7c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
57e1fd80:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
			*foundtype = type;
57e1fd84:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30

		ext4fs_free_node(oldnode, currroot);

		/* Found the node! */
		if (!next || *next == '\0') {
			*currfound = currnode;
57e1fd88:	e5813000 	str	r3, [r1]
			*foundtype = type;
57e1fd8c:	e51b3020 	ldr	r3, [fp, #-32]
57e1fd90:	e5823000 	str	r3, [r2]
			return 1;
57e1fd94:	e3a00001 	mov	r0, #1
		}
		name = next;
	}
	return -1;
}
57e1fd98:	e24bd01c 	sub	sp, fp, #28
57e1fd9c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e1fda0:	57e48f50 	.word	0x57e48f50

57e1fda4 <ext4fs_find_file>:

int ext4fs_find_file(const char *path, struct ext2fs_node *rootnode,
	struct ext2fs_node **foundnode, int expecttype)
{
57e1fda4:	e92d4013 	push	{r0, r1, r4, lr}
57e1fda8:	e1a04003 	mov	r4, r3
	int status;
	int foundtype = FILETYPE_DIRECTORY;
57e1fdac:	e3a03002 	mov	r3, #2
57e1fdb0:	e58d3004 	str	r3, [sp, #4]

	symlinknest = 0;
57e1fdb4:	e59f305c 	ldr	r3, [pc, #92]	; 57e1fe18 <ext4fs_find_file+0x74>
57e1fdb8:	e3a0c000 	mov	ip, #0
57e1fdbc:	e583c020 	str	ip, [r3, #32]
	if (!path)
57e1fdc0:	e2503000 	subs	r3, r0, #0
		return 0;
57e1fdc4:	01a00003 	moveq	r0, r3
{
	int status;
	int foundtype = FILETYPE_DIRECTORY;

	symlinknest = 0;
	if (!path)
57e1fdc8:	0a000011 	beq	57e1fe14 <ext4fs_find_file+0x70>
		return 0;

	status = ext4fs_find_file1(path, rootnode, foundnode, &foundtype);
57e1fdcc:	e28d3004 	add	r3, sp, #4
57e1fdd0:	ebffff46 	bl	57e1faf0 <ext4fs_find_file1>
	if (status == 0)
57e1fdd4:	e3500000 	cmp	r0, #0
57e1fdd8:	0a00000d 	beq	57e1fe14 <ext4fs_find_file+0x70>
		return 0;

	/* Check if the node that was found was of the expected type. */
	if ((expecttype == FILETYPE_REG) && (foundtype != expecttype))
57e1fddc:	e3540001 	cmp	r4, #1
57e1fde0:	1a000004 	bne	57e1fdf8 <ext4fs_find_file+0x54>
		name = next;
	}
	return -1;
}

int ext4fs_find_file(const char *path, struct ext2fs_node *rootnode,
57e1fde4:	e59d0004 	ldr	r0, [sp, #4]
57e1fde8:	e3500001 	cmp	r0, #1
57e1fdec:	13a00000 	movne	r0, #0
57e1fdf0:	03a00001 	moveq	r0, #1
57e1fdf4:	ea000006 	b	57e1fe14 <ext4fs_find_file+0x70>
		return 0;

	/* Check if the node that was found was of the expected type. */
	if ((expecttype == FILETYPE_REG) && (foundtype != expecttype))
		return 0;
	else if ((expecttype == FILETYPE_DIRECTORY)
57e1fdf8:	e3540002 	cmp	r4, #2
		   && (foundtype != expecttype))
		return 0;

	return 1;
57e1fdfc:	13a00001 	movne	r0, #1
		return 0;

	/* Check if the node that was found was of the expected type. */
	if ((expecttype == FILETYPE_REG) && (foundtype != expecttype))
		return 0;
	else if ((expecttype == FILETYPE_DIRECTORY)
57e1fe00:	1a000003 	bne	57e1fe14 <ext4fs_find_file+0x70>
		name = next;
	}
	return -1;
}

int ext4fs_find_file(const char *path, struct ext2fs_node *rootnode,
57e1fe04:	e59d0004 	ldr	r0, [sp, #4]
57e1fe08:	e3500002 	cmp	r0, #2
57e1fe0c:	13a00000 	movne	r0, #0
57e1fe10:	03a00001 	moveq	r0, #1
	else if ((expecttype == FILETYPE_DIRECTORY)
		   && (foundtype != expecttype))
		return 0;

	return 1;
}
57e1fe14:	e8bd801c 	pop	{r2, r3, r4, pc}
57e1fe18:	57e48f50 	.word	0x57e48f50

57e1fe1c <ext4fs_open>:

int ext4fs_open(const char *filename)
{
57e1fe1c:	e92d4007 	push	{r0, r1, r2, lr}
	struct ext2fs_node *fdiro = NULL;
	int status;
	int len;

	if (ext4fs_root == NULL)
57e1fe20:	e59f3084 	ldr	r3, [pc, #132]	; 57e1feac <ext4fs_open+0x90>
	return 1;
}

int ext4fs_open(const char *filename)
{
	struct ext2fs_node *fdiro = NULL;
57e1fe24:	e3a02000 	mov	r2, #0
	int status;
	int len;

	if (ext4fs_root == NULL)
57e1fe28:	e5931000 	ldr	r1, [r3]
	return 1;
}

int ext4fs_open(const char *filename)
{
	struct ext2fs_node *fdiro = NULL;
57e1fe2c:	e58d2004 	str	r2, [sp, #4]
	int status;
	int len;

	if (ext4fs_root == NULL)
57e1fe30:	e1510002 	cmp	r1, r2
57e1fe34:	0a00001a 	beq	57e1fea4 <ext4fs_open+0x88>
		return -1;

	ext4fs_file = NULL;
57e1fe38:	e583201c 	str	r2, [r3, #28]
	status = ext4fs_find_file(filename, &ext4fs_root->diropen, &fdiro,
57e1fe3c:	e28110d0 	add	r1, r1, #208	; 0xd0
57e1fe40:	e28d2004 	add	r2, sp, #4
57e1fe44:	e3a03001 	mov	r3, #1
57e1fe48:	ebffffd5 	bl	57e1fda4 <ext4fs_find_file>
				  FILETYPE_REG);
	if (status == 0)
57e1fe4c:	e3500000 	cmp	r0, #0
57e1fe50:	0a00000e 	beq	57e1fe90 <ext4fs_open+0x74>
		goto fail;

	if (!fdiro->inode_read) {
57e1fe54:	e59d2004 	ldr	r2, [sp, #4]
57e1fe58:	e5923088 	ldr	r3, [r2, #136]	; 0x88
57e1fe5c:	e3530000 	cmp	r3, #0
57e1fe60:	1a000005 	bne	57e1fe7c <ext4fs_open+0x60>
		status = ext4fs_read_inode(fdiro->data, fdiro->ino,
57e1fe64:	e5920000 	ldr	r0, [r2]
57e1fe68:	e5921084 	ldr	r1, [r2, #132]	; 0x84
57e1fe6c:	e2822004 	add	r2, r2, #4
57e1fe70:	ebfffbc6 	bl	57e1ed90 <ext4fs_read_inode>
				&fdiro->inode);
		if (status == 0)
57e1fe74:	e3500000 	cmp	r0, #0
57e1fe78:	0a000004 	beq	57e1fe90 <ext4fs_open+0x74>
			goto fail;
	}
	len = __le32_to_cpu(fdiro->inode.size);
57e1fe7c:	e59d3004 	ldr	r3, [sp, #4]
	ext4fs_file = fdiro;
57e1fe80:	e59f2024 	ldr	r2, [pc, #36]	; 57e1feac <ext4fs_open+0x90>
		status = ext4fs_read_inode(fdiro->data, fdiro->ino,
				&fdiro->inode);
		if (status == 0)
			goto fail;
	}
	len = __le32_to_cpu(fdiro->inode.size);
57e1fe84:	e5930008 	ldr	r0, [r3, #8]
	ext4fs_file = fdiro;
57e1fe88:	e582301c 	str	r3, [r2, #28]

	return len;
57e1fe8c:	ea000005 	b	57e1fea8 <ext4fs_open+0x8c>
fail:
	ext4fs_free_node(fdiro, &ext4fs_root->diropen);
57e1fe90:	e59f3014 	ldr	r3, [pc, #20]	; 57e1feac <ext4fs_open+0x90>
57e1fe94:	e59d0004 	ldr	r0, [sp, #4]
57e1fe98:	e5931000 	ldr	r1, [r3]
57e1fe9c:	e28110d0 	add	r1, r1, #208	; 0xd0
57e1fea0:	ebfffaf8 	bl	57e1ea88 <ext4fs_free_node>
	struct ext2fs_node *fdiro = NULL;
	int status;
	int len;

	if (ext4fs_root == NULL)
		return -1;
57e1fea4:	e3e00000 	mvn	r0, #0
	return len;
fail:
	ext4fs_free_node(fdiro, &ext4fs_root->diropen);

	return -1;
}
57e1fea8:	e8bd800e 	pop	{r1, r2, r3, pc}
57e1feac:	57e48f50 	.word	0x57e48f50

57e1feb0 <ext4fs_mount>:

int ext4fs_mount(unsigned part_length)
{
57e1feb0:	e92d4038 	push	{r3, r4, r5, lr}
	struct ext2_data *data;
	int status;
	struct ext_filesystem *fs = get_fs();
57e1feb4:	ebfffaf0 	bl	57e1ea7c <get_fs>
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1feb8:	e3a01f57 	mov	r1, #348	; 0x15c
57e1febc:	e1a05000 	mov	r5, r0
57e1fec0:	e3a00040 	mov	r0, #64	; 0x40
57e1fec4:	ebffa8e4 	bl	57e0a25c <memalign>
	memset(p, 0, size);
57e1fec8:	e3a01000 	mov	r1, #0
#define SUPERBLOCK_SIZE	1024
#define F_FILE			1

static inline void *zalloc(size_t size)
{
	void *p = memalign(ARCH_DMA_MINALIGN, size);
57e1fecc:	e1a04000 	mov	r4, r0
	memset(p, 0, size);
57e1fed0:	e3a02f57 	mov	r2, #348	; 0x15c
57e1fed4:	eb0010e8 	bl	57e2427c <memset>
	data = zalloc(sizeof(struct ext2_data));
	if (!data)
57e1fed8:	e3540000 	cmp	r4, #0
57e1fedc:	0a000026 	beq	57e1ff7c <ext4fs_mount+0xcc>
		return 0;

	/* Read the superblock. */
	status = ext4fs_devread(1 * 2, 0, sizeof(struct ext2_sblock),
57e1fee0:	e3a00002 	mov	r0, #2
57e1fee4:	e3a01000 	mov	r1, #0
57e1fee8:	e3a020cc 	mov	r2, #204	; 0xcc
57e1feec:	e1a03004 	mov	r3, r4
57e1fef0:	eb000037 	bl	57e1ffd4 <ext4fs_devread>
				(char *)&data->sblock);

	if (status == 0)
57e1fef4:	e3500000 	cmp	r0, #0
57e1fef8:	0a000017 	beq	57e1ff5c <ext4fs_mount+0xac>
		goto fail;

	/* Make sure this is an ext2 filesystem. */
	if (__le16_to_cpu(data->sblock.magic) != EXT2_MAGIC)
57e1fefc:	e1d423b8 	ldrh	r2, [r4, #56]	; 0x38
57e1ff00:	e59f307c 	ldr	r3, [pc, #124]	; 57e1ff84 <ext4fs_mount+0xd4>
57e1ff04:	e1520003 	cmp	r2, r3
57e1ff08:	1a000013 	bne	57e1ff5c <ext4fs_mount+0xac>
		goto fail;

	if (__le32_to_cpu(data->sblock.revision_level == 0))
57e1ff0c:	e594304c 	ldr	r3, [r4, #76]	; 0x4c

	debug("EXT2 rev %d, inode_size %d\n",
	       __le32_to_cpu(data->sblock.revision_level), fs->inodesz);

	data->diropen.data = data;
	data->diropen.ino = 2;
57e1ff10:	e3a01002 	mov	r1, #2

	/* Make sure this is an ext2 filesystem. */
	if (__le16_to_cpu(data->sblock.magic) != EXT2_MAGIC)
		goto fail;

	if (__le32_to_cpu(data->sblock.revision_level == 0))
57e1ff14:	e3530000 	cmp	r3, #0
		fs->inodesz = 128;
	else
		fs->inodesz = __le16_to_cpu(data->sblock.inode_size);
57e1ff18:	11d435b8 	ldrhne	r3, [r4, #88]	; 0x58
	/* Make sure this is an ext2 filesystem. */
	if (__le16_to_cpu(data->sblock.magic) != EXT2_MAGIC)
		goto fail;

	if (__le32_to_cpu(data->sblock.revision_level == 0))
		fs->inodesz = 128;
57e1ff1c:	02833080 	addeq	r3, r3, #128	; 0x80
	else
		fs->inodesz = __le16_to_cpu(data->sblock.inode_size);
57e1ff20:	e585300c 	str	r3, [r5, #12]
	       __le32_to_cpu(data->sblock.revision_level), fs->inodesz);

	data->diropen.data = data;
	data->diropen.ino = 2;
	data->diropen.inode_read = 1;
	data->inode = &data->diropen.inode;
57e1ff24:	e28420d4 	add	r2, r4, #212	; 0xd4
	debug("EXT2 rev %d, inode_size %d\n",
	       __le32_to_cpu(data->sblock.revision_level), fs->inodesz);

	data->diropen.data = data;
	data->diropen.ino = 2;
	data->diropen.inode_read = 1;
57e1ff28:	e3a05001 	mov	r5, #1
		fs->inodesz = __le16_to_cpu(data->sblock.inode_size);

	debug("EXT2 rev %d, inode_size %d\n",
	       __le32_to_cpu(data->sblock.revision_level), fs->inodesz);

	data->diropen.data = data;
57e1ff2c:	e58440d0 	str	r4, [r4, #208]	; 0xd0
	data->diropen.ino = 2;
57e1ff30:	e5841154 	str	r1, [r4, #340]	; 0x154
	data->diropen.inode_read = 1;
57e1ff34:	e5845158 	str	r5, [r4, #344]	; 0x158
	data->inode = &data->diropen.inode;
57e1ff38:	e58420cc 	str	r2, [r4, #204]	; 0xcc

	status = ext4fs_read_inode(data, 2, data->inode);
57e1ff3c:	e1a00004 	mov	r0, r4
57e1ff40:	ebfffb92 	bl	57e1ed90 <ext4fs_read_inode>
	if (status == 0)
57e1ff44:	e3500000 	cmp	r0, #0
57e1ff48:	0a000003 	beq	57e1ff5c <ext4fs_mount+0xac>
		goto fail;

	ext4fs_root = data;
57e1ff4c:	e59f3034 	ldr	r3, [pc, #52]	; 57e1ff88 <ext4fs_mount+0xd8>

	return 1;
57e1ff50:	e1a00005 	mov	r0, r5

	status = ext4fs_read_inode(data, 2, data->inode);
	if (status == 0)
		goto fail;

	ext4fs_root = data;
57e1ff54:	e5834000 	str	r4, [r3]

	return 1;
57e1ff58:	e8bd8038 	pop	{r3, r4, r5, pc}
fail:
	printf("Failed to mount ext2 filesystem...\n");
57e1ff5c:	e59f0028 	ldr	r0, [pc, #40]	; 57e1ff8c <ext4fs_mount+0xdc>
57e1ff60:	ebffa539 	bl	57e0944c <printf>
	free(data);
57e1ff64:	e1a00004 	mov	r0, r4
57e1ff68:	ebffa68b 	bl	57e0999c <free>
	ext4fs_root = NULL;
57e1ff6c:	e59f3014 	ldr	r3, [pc, #20]	; 57e1ff88 <ext4fs_mount+0xd8>
57e1ff70:	e3a00000 	mov	r0, #0
57e1ff74:	e5830000 	str	r0, [r3]

	return 0;
57e1ff78:	e8bd8038 	pop	{r3, r4, r5, pc}
	struct ext2_data *data;
	int status;
	struct ext_filesystem *fs = get_fs();
	data = zalloc(sizeof(struct ext2_data));
	if (!data)
		return 0;
57e1ff7c:	e1a00004 	mov	r0, r4
	printf("Failed to mount ext2 filesystem...\n");
	free(data);
	ext4fs_root = NULL;

	return 0;
}
57e1ff80:	e8bd8038 	pop	{r3, r4, r5, pc}
57e1ff84:	0000ef53 	.word	0x0000ef53
57e1ff88:	57e48f50 	.word	0x57e48f50
57e1ff8c:	57e350ad 	.word	0x57e350ad

57e1ff90 <ext4fs_set_blk_dev>:

static block_dev_desc_t *ext4fs_block_dev_desc;
static disk_partition_t *part_info;

void ext4fs_set_blk_dev(block_dev_desc_t *rbdd, disk_partition_t *info)
{
57e1ff90:	e92d4038 	push	{r3, r4, r5, lr}
	ext4fs_block_dev_desc = rbdd;
	part_info = info;
	part_offset = info->start;
57e1ff94:	e5912000 	ldr	r2, [r1]
static block_dev_desc_t *ext4fs_block_dev_desc;
static disk_partition_t *part_info;

void ext4fs_set_blk_dev(block_dev_desc_t *rbdd, disk_partition_t *info)
{
	ext4fs_block_dev_desc = rbdd;
57e1ff98:	e59f3030 	ldr	r3, [pc, #48]	; 57e1ffd0 <ext4fs_set_blk_dev+0x40>

static block_dev_desc_t *ext4fs_block_dev_desc;
static disk_partition_t *part_info;

void ext4fs_set_blk_dev(block_dev_desc_t *rbdd, disk_partition_t *info)
{
57e1ff9c:	e1a05001 	mov	r5, r1
	ext4fs_block_dev_desc = rbdd;
	part_info = info;
57e1ffa0:	e8830007 	stm	r3, {r0, r1, r2}

static block_dev_desc_t *ext4fs_block_dev_desc;
static disk_partition_t *part_info;

void ext4fs_set_blk_dev(block_dev_desc_t *rbdd, disk_partition_t *info)
{
57e1ffa4:	e1a04000 	mov	r4, r0
	ext4fs_block_dev_desc = rbdd;
	part_info = info;
	part_offset = info->start;
	get_fs()->total_sect = (info->size * info->blksz) / SECTOR_SIZE;
57e1ffa8:	ebfffab3 	bl	57e1ea7c <get_fs>
57e1ffac:	e995000c 	ldmib	r5, {r2, r3}
57e1ffb0:	e0030392 	mul	r3, r2, r3
57e1ffb4:	e1a034a3 	lsr	r3, r3, #9
57e1ffb8:	e5803000 	str	r3, [r0]
57e1ffbc:	e3a03000 	mov	r3, #0
57e1ffc0:	e5803004 	str	r3, [r0, #4]
	get_fs()->dev_desc = rbdd;
57e1ffc4:	ebfffaac 	bl	57e1ea7c <get_fs>
57e1ffc8:	e5804044 	str	r4, [r0, #68]	; 0x44
}
57e1ffcc:	e8bd8038 	pop	{r3, r4, r5, pc}
57e1ffd0:	57e48f78 	.word	0x57e48f78

57e1ffd4 <ext4fs_devread>:

int ext4fs_devread(int sector, int byte_offset, int byte_len, char *buf)
{
57e1ffd4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e1ffd8:	e1a04002 	mov	r4, r2
	ALLOC_CACHE_ALIGN_BUFFER(char, sec_buf, SECTOR_SIZE);
	unsigned block_len;

	/* Check partition boundaries */
	if ((sector < 0)
57e1ffdc:	e2502000 	subs	r2, r0, #0
	get_fs()->total_sect = (info->size * info->blksz) / SECTOR_SIZE;
	get_fs()->dev_desc = rbdd;
}

int ext4fs_devread(int sector, int byte_offset, int byte_len, char *buf)
{
57e1ffe0:	e24ddd12 	sub	sp, sp, #1152	; 0x480
57e1ffe4:	e1a0a003 	mov	sl, r3
	ALLOC_CACHE_ALIGN_BUFFER(char, sec_buf, SECTOR_SIZE);
	unsigned block_len;

	/* Check partition boundaries */
	if ((sector < 0)
57e1ffe8:	ba000007 	blt	57e2000c <ext4fs_devread+0x38>
	    || ((sector + ((byte_offset + byte_len - 1) >> SECTOR_BITS)) >=
		part_info->size)) {
57e1ffec:	e59f01bc 	ldr	r0, [pc, #444]	; 57e201b0 <ext4fs_devread+0x1dc>
	ALLOC_CACHE_ALIGN_BUFFER(char, sec_buf, SECTOR_SIZE);
	unsigned block_len;

	/* Check partition boundaries */
	if ((sector < 0)
	    || ((sector + ((byte_offset + byte_len - 1) >> SECTOR_BITS)) >=
57e1fff0:	e2415001 	sub	r5, r1, #1
		part_info->size)) {
57e1fff4:	e5903004 	ldr	r3, [r0, #4]
	ALLOC_CACHE_ALIGN_BUFFER(char, sec_buf, SECTOR_SIZE);
	unsigned block_len;

	/* Check partition boundaries */
	if ((sector < 0)
	    || ((sector + ((byte_offset + byte_len - 1) >> SECTOR_BITS)) >=
57e1fff8:	e0855004 	add	r5, r5, r4
57e1fffc:	e593c004 	ldr	ip, [r3, #4]
57e20000:	e08254c5 	add	r5, r2, r5, asr #9
57e20004:	e155000c 	cmp	r5, ip
57e20008:	3a000003 	bcc	57e2001c <ext4fs_devread+0x48>
		part_info->size)) {
		printf("%s read outside partition %d\n", __func__, sector);
57e2000c:	e59f11a0 	ldr	r1, [pc, #416]	; 57e201b4 <ext4fs_devread+0x1e0>
57e20010:	e59f01a0 	ldr	r0, [pc, #416]	; 57e201b8 <ext4fs_devread+0x1e4>
57e20014:	ebffa50c 	bl	57e0944c <printf>
57e20018:	ea000059 	b	57e20184 <ext4fs_devread+0x1b0>
	sector += byte_offset >> SECTOR_BITS;
	byte_offset &= SECTOR_SIZE - 1;

	debug(" <%d, %d, %d>\n", sector, byte_offset, byte_len);

	if (ext4fs_block_dev_desc == NULL) {
57e2001c:	e5905000 	ldr	r5, [r0]
57e20020:	e3550000 	cmp	r5, #0
57e20024:	1a000002 	bne	57e20034 <ext4fs_devread+0x60>
		printf("** Invalid Block Device Descriptor (NULL)\n");
57e20028:	e59f018c 	ldr	r0, [pc, #396]	; 57e201bc <ext4fs_devread+0x1e8>
57e2002c:	ebffa506 	bl	57e0944c <printf>
		return 0;
57e20030:	ea00005b 	b	57e201a4 <ext4fs_devread+0x1d0>
	get_fs()->dev_desc = rbdd;
}

int ext4fs_devread(int sector, int byte_offset, int byte_len, char *buf)
{
	ALLOC_CACHE_ALIGN_BUFFER(char, sec_buf, SECTOR_SIZE);
57e20034:	e28d9f9f 	add	r9, sp, #636	; 0x27c
		return 0;
	}

	/* Get the read to the beginning of a partition */
	sector += byte_offset >> SECTOR_BITS;
	byte_offset &= SECTOR_SIZE - 1;
57e20038:	e1a07b81 	lsl	r7, r1, #23
	get_fs()->dev_desc = rbdd;
}

int ext4fs_devread(int sector, int byte_offset, int byte_len, char *buf)
{
	ALLOC_CACHE_ALIGN_BUFFER(char, sec_buf, SECTOR_SIZE);
57e2003c:	e2899003 	add	r9, r9, #3
	if (ext4fs_block_dev_desc == NULL) {
		printf("** Invalid Block Device Descriptor (NULL)\n");
		return 0;
	}

	if (byte_offset != 0) {
57e20040:	e1b07ba7 	lsrs	r7, r7, #23
	get_fs()->dev_desc = rbdd;
}

int ext4fs_devread(int sector, int byte_offset, int byte_len, char *buf)
{
	ALLOC_CACHE_ALIGN_BUFFER(char, sec_buf, SECTOR_SIZE);
57e20044:	e3c9903f 	bic	r9, r9, #63	; 0x3f
		printf("%s read outside partition %d\n", __func__, sector);
		return 0;
	}

	/* Get the read to the beginning of a partition */
	sector += byte_offset >> SECTOR_BITS;
57e20048:	e08264c1 	add	r6, r2, r1, asr #9
	if (ext4fs_block_dev_desc == NULL) {
		printf("** Invalid Block Device Descriptor (NULL)\n");
		return 0;
	}

	if (byte_offset != 0) {
57e2004c:	0a000015 	beq	57e200a8 <ext4fs_devread+0xd4>
		/* read first part which isn't aligned with start of sector */
		if (ext4fs_block_dev_desc->
		    block_read(ext4fs_block_dev_desc->dev,
57e20050:	e5931000 	ldr	r1, [r3]
57e20054:	e595c060 	ldr	ip, [r5, #96]	; 0x60
57e20058:	e5950004 	ldr	r0, [r5, #4]
57e2005c:	e0861001 	add	r1, r6, r1
57e20060:	e3a02001 	mov	r2, #1
57e20064:	e1a03009 	mov	r3, r9
57e20068:	e12fff3c 	blx	ip
		return 0;
	}

	if (byte_offset != 0) {
		/* read first part which isn't aligned with start of sector */
		if (ext4fs_block_dev_desc->
57e2006c:	e3500001 	cmp	r0, #1
57e20070:	0a000002 	beq	57e20080 <ext4fs_devread+0xac>
		    block_read(ext4fs_block_dev_desc->dev,
				part_info->start + sector, 1,
				(unsigned long *) sec_buf) != 1) {
			printf(" ** ext2fs_devread() read error **\n");
57e20074:	e59f0144 	ldr	r0, [pc, #324]	; 57e201c0 <ext4fs_devread+0x1ec>
57e20078:	ebffa4f3 	bl	57e0944c <printf>
57e2007c:	ea000040 	b	57e20184 <ext4fs_devread+0x1b0>
			return 0;
		}
		memcpy(buf, sec_buf + byte_offset,
			min(SECTOR_SIZE - byte_offset, byte_len));
57e20080:	e2675c02 	rsb	r5, r7, #512	; 0x200
57e20084:	e1550004 	cmp	r5, r4
57e20088:	a1a05004 	movge	r5, r4
				part_info->start + sector, 1,
				(unsigned long *) sec_buf) != 1) {
			printf(" ** ext2fs_devread() read error **\n");
			return 0;
		}
		memcpy(buf, sec_buf + byte_offset,
57e2008c:	e1a0000a 	mov	r0, sl
57e20090:	e0891007 	add	r1, r9, r7
57e20094:	e1a02005 	mov	r2, r5
57e20098:	eb00109b 	bl	57e2430c <memcpy>
			min(SECTOR_SIZE - byte_offset, byte_len));
		buf += min(SECTOR_SIZE - byte_offset, byte_len);
57e2009c:	e08aa005 	add	sl, sl, r5
		byte_len -= min(SECTOR_SIZE - byte_offset, byte_len);
57e200a0:	e0654004 	rsb	r4, r5, r4
		sector++;
57e200a4:	e2866001 	add	r6, r6, #1
	}

	if (byte_len == 0)
57e200a8:	e3540000 	cmp	r4, #0
57e200ac:	0a00003b 	beq	57e201a0 <ext4fs_devread+0x1cc>
		return 1;

	/* read sector aligned part */
	block_len = byte_len & ~(SECTOR_SIZE - 1);
57e200b0:	e3c47f7f 	bic	r7, r4, #508	; 0x1fc
57e200b4:	e3c77003 	bic	r7, r7, #3

	if (block_len == 0) {
57e200b8:	e3570000 	cmp	r7, #0
57e200bc:	e59f50ec 	ldr	r5, [pc, #236]	; 57e201b0 <ext4fs_devread+0x1dc>
57e200c0:	1a00000f 	bne	57e20104 <ext4fs_devread+0x130>
		ALLOC_CACHE_ALIGN_BUFFER(u8, p, SECTOR_SIZE);

		block_len = SECTOR_SIZE;
		ext4fs_block_dev_desc->block_read(ext4fs_block_dev_desc->dev,
						  part_info->start + sector,
57e200c4:	e5952004 	ldr	r2, [r5, #4]

	if (block_len == 0) {
		ALLOC_CACHE_ALIGN_BUFFER(u8, p, SECTOR_SIZE);

		block_len = SECTOR_SIZE;
		ext4fs_block_dev_desc->block_read(ext4fs_block_dev_desc->dev,
57e200c8:	e5953000 	ldr	r3, [r5]
57e200cc:	e5921000 	ldr	r1, [r2]

	/* read sector aligned part */
	block_len = byte_len & ~(SECTOR_SIZE - 1);

	if (block_len == 0) {
		ALLOC_CACHE_ALIGN_BUFFER(u8, p, SECTOR_SIZE);
57e200d0:	e28d703f 	add	r7, sp, #63	; 0x3f
57e200d4:	e3c7703f 	bic	r7, r7, #63	; 0x3f

		block_len = SECTOR_SIZE;
		ext4fs_block_dev_desc->block_read(ext4fs_block_dev_desc->dev,
57e200d8:	e593c060 	ldr	ip, [r3, #96]	; 0x60
57e200dc:	e0861001 	add	r1, r6, r1
57e200e0:	e5930004 	ldr	r0, [r3, #4]
57e200e4:	e3a02001 	mov	r2, #1
57e200e8:	e1a03007 	mov	r3, r7
57e200ec:	e12fff3c 	blx	ip
						  part_info->start + sector,
						  1, (unsigned long *)p);
		memcpy(buf, p, byte_len);
57e200f0:	e1a0000a 	mov	r0, sl
57e200f4:	e1a01007 	mov	r1, r7
57e200f8:	e1a02004 	mov	r2, r4
57e200fc:	eb001082 	bl	57e2430c <memcpy>
57e20100:	ea000026 	b	57e201a0 <ext4fs_devread+0x1cc>
		return 1;
	}

	if (ext4fs_block_dev_desc->block_read(ext4fs_block_dev_desc->dev,
					       part_info->start + sector,
57e20104:	e5952004 	ldr	r2, [r5, #4]
						  1, (unsigned long *)p);
		memcpy(buf, p, byte_len);
		return 1;
	}

	if (ext4fs_block_dev_desc->block_read(ext4fs_block_dev_desc->dev,
57e20108:	e5953000 	ldr	r3, [r5]
57e2010c:	e5921000 	ldr	r1, [r2]
					       part_info->start + sector,
					       block_len / SECTOR_SIZE,
57e20110:	e1a0b4a7 	lsr	fp, r7, #9
						  1, (unsigned long *)p);
		memcpy(buf, p, byte_len);
		return 1;
	}

	if (ext4fs_block_dev_desc->block_read(ext4fs_block_dev_desc->dev,
57e20114:	e593c060 	ldr	ip, [r3, #96]	; 0x60
57e20118:	e5930004 	ldr	r0, [r3, #4]
57e2011c:	e0861001 	add	r1, r6, r1
57e20120:	e1a0300a 	mov	r3, sl
57e20124:	e1a0200b 	mov	r2, fp
57e20128:	e12fff3c 	blx	ip
57e2012c:	e150000b 	cmp	r0, fp
57e20130:	e1a03000 	mov	r3, r0
					       part_info->start + sector,
					       block_len / SECTOR_SIZE,
					       (unsigned long *) buf) !=
					       block_len / SECTOR_SIZE) {
		printf(" ** %s read error - block\n", __func__);
57e20134:	159f0088 	ldrne	r0, [pc, #136]	; 57e201c4 <ext4fs_devread+0x1f0>
						  1, (unsigned long *)p);
		memcpy(buf, p, byte_len);
		return 1;
	}

	if (ext4fs_block_dev_desc->block_read(ext4fs_block_dev_desc->dev,
57e20138:	1a00000f 	bne	57e2017c <ext4fs_devread+0x1a8>
	block_len = byte_len & ~(SECTOR_SIZE - 1);
	buf += block_len;
	byte_len -= block_len;
	sector += block_len / SECTOR_SIZE;

	if (byte_len != 0) {
57e2013c:	e0544007 	subs	r4, r4, r7
57e20140:	0a000016 	beq	57e201a0 <ext4fs_devread+0x1cc>
		/* read rest of data which are not in whole sector */
		if (ext4fs_block_dev_desc->
		    block_read(ext4fs_block_dev_desc->dev,
				part_info->start + sector, 1,
57e20144:	e5951004 	ldr	r1, [r5, #4]
	byte_len -= block_len;
	sector += block_len / SECTOR_SIZE;

	if (byte_len != 0) {
		/* read rest of data which are not in whole sector */
		if (ext4fs_block_dev_desc->
57e20148:	e5952000 	ldr	r2, [r5]
		return 0;
	}
	block_len = byte_len & ~(SECTOR_SIZE - 1);
	buf += block_len;
	byte_len -= block_len;
	sector += block_len / SECTOR_SIZE;
57e2014c:	e5911000 	ldr	r1, [r1]

	if (byte_len != 0) {
		/* read rest of data which are not in whole sector */
		if (ext4fs_block_dev_desc->
		    block_read(ext4fs_block_dev_desc->dev,
57e20150:	e592c060 	ldr	ip, [r2, #96]	; 0x60
		return 0;
	}
	block_len = byte_len & ~(SECTOR_SIZE - 1);
	buf += block_len;
	byte_len -= block_len;
	sector += block_len / SECTOR_SIZE;
57e20154:	e0866001 	add	r6, r6, r1

	if (byte_len != 0) {
		/* read rest of data which are not in whole sector */
		if (ext4fs_block_dev_desc->
		    block_read(ext4fs_block_dev_desc->dev,
57e20158:	e5920004 	ldr	r0, [r2, #4]
57e2015c:	e0861003 	add	r1, r6, r3
57e20160:	e3a02001 	mov	r2, #1
57e20164:	e1a03009 	mov	r3, r9
57e20168:	e12fff3c 	blx	ip
	byte_len -= block_len;
	sector += block_len / SECTOR_SIZE;

	if (byte_len != 0) {
		/* read rest of data which are not in whole sector */
		if (ext4fs_block_dev_desc->
57e2016c:	e3500001 	cmp	r0, #1
		    block_read(ext4fs_block_dev_desc->dev,
57e20170:	e1a05000 	mov	r5, r0
	byte_len -= block_len;
	sector += block_len / SECTOR_SIZE;

	if (byte_len != 0) {
		/* read rest of data which are not in whole sector */
		if (ext4fs_block_dev_desc->
57e20174:	0a000004 	beq	57e2018c <ext4fs_devread+0x1b8>
		    block_read(ext4fs_block_dev_desc->dev,
				part_info->start + sector, 1,
				(unsigned long *) sec_buf) != 1) {
			printf("* %s read error - last part\n", __func__);
57e20178:	e59f0048 	ldr	r0, [pc, #72]	; 57e201c8 <ext4fs_devread+0x1f4>
57e2017c:	e59f1030 	ldr	r1, [pc, #48]	; 57e201b4 <ext4fs_devread+0x1e0>
57e20180:	ebffa4b1 	bl	57e0944c <printf>
			return 0;
57e20184:	e3a05000 	mov	r5, #0
57e20188:	ea000005 	b	57e201a4 <ext4fs_devread+0x1d0>
		}
		memcpy(buf, sec_buf, byte_len);
57e2018c:	e08a0007 	add	r0, sl, r7
57e20190:	e1a01009 	mov	r1, r9
57e20194:	e1a02004 	mov	r2, r4
57e20198:	eb00105b 	bl	57e2430c <memcpy>
57e2019c:	ea000000 	b	57e201a4 <ext4fs_devread+0x1d0>
	}
	return 1;
57e201a0:	e3a05001 	mov	r5, #1
}
57e201a4:	e1a00005 	mov	r0, r5
57e201a8:	e28ddd12 	add	sp, sp, #1152	; 0x480
57e201ac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e201b0:	57e48f78 	.word	0x57e48f78
57e201b4:	57e2cd98 	.word	0x57e2cd98
57e201b8:	57e350d1 	.word	0x57e350d1
57e201bc:	57e350ef 	.word	0x57e350ef
57e201c0:	57e3511a 	.word	0x57e3511a
57e201c4:	57e3513e 	.word	0x57e3513e
57e201c8:	57e35159 	.word	0x57e35159

57e201cc <downcase>:
/*
 * Convert a string to lowercase.
 */
static void downcase(char *str)
{
	while (*str != '\0') {
57e201cc:	ea000003 	b	57e201e0 <downcase+0x14>
		TOLOWER(*str);
57e201d0:	e2432041 	sub	r2, r3, #65	; 0x41
57e201d4:	e3520019 	cmp	r2, #25
57e201d8:	92833020 	addls	r3, r3, #32
57e201dc:	95403001 	strbls	r3, [r0, #-1]
/*
 * Convert a string to lowercase.
 */
static void downcase(char *str)
{
	while (*str != '\0') {
57e201e0:	e4d03001 	ldrb	r3, [r0], #1
57e201e4:	e3530000 	cmp	r3, #0
57e201e8:	1afffff8 	bne	57e201d0 <downcase+0x4>
		TOLOWER(*str);
		str++;
	}
}
57e201ec:	e12fff1e 	bx	lr

57e201f0 <disk_read>:
#define DOS_BOOT_MAGIC_OFFSET	0x1fe
#define DOS_FS_TYPE_OFFSET	0x36
#define DOS_FS32_TYPE_OFFSET	0x52

static int disk_read(__u32 block, __u32 nr_blocks, void *buf)
{
57e201f0:	e92d4038 	push	{r3, r4, r5, lr}
57e201f4:	e1a04001 	mov	r4, r1
	if (!cur_dev || !cur_dev->block_read)
57e201f8:	e59f1040 	ldr	r1, [pc, #64]	; 57e20240 <disk_read+0x50>
#define DOS_BOOT_MAGIC_OFFSET	0x1fe
#define DOS_FS_TYPE_OFFSET	0x36
#define DOS_FS32_TYPE_OFFSET	0x52

static int disk_read(__u32 block, __u32 nr_blocks, void *buf)
{
57e201fc:	e1a03002 	mov	r3, r2
	if (!cur_dev || !cur_dev->block_read)
57e20200:	e5912000 	ldr	r2, [r1]
#define DOS_BOOT_MAGIC_OFFSET	0x1fe
#define DOS_FS_TYPE_OFFSET	0x36
#define DOS_FS32_TYPE_OFFSET	0x52

static int disk_read(__u32 block, __u32 nr_blocks, void *buf)
{
57e20204:	e1a05000 	mov	r5, r0
	if (!cur_dev || !cur_dev->block_read)
57e20208:	e3520000 	cmp	r2, #0
		return -1;
57e2020c:	03e00000 	mvneq	r0, #0
#define DOS_FS_TYPE_OFFSET	0x36
#define DOS_FS32_TYPE_OFFSET	0x52

static int disk_read(__u32 block, __u32 nr_blocks, void *buf)
{
	if (!cur_dev || !cur_dev->block_read)
57e20210:	08bd8038 	popeq	{r3, r4, r5, pc}
57e20214:	e592c060 	ldr	ip, [r2, #96]	; 0x60
57e20218:	e35c0000 	cmp	ip, #0
57e2021c:	0a000005 	beq	57e20238 <disk_read+0x48>
		return -1;

	return cur_dev->block_read(cur_dev->dev,
57e20220:	e5911004 	ldr	r1, [r1, #4]
57e20224:	e5920004 	ldr	r0, [r2, #4]
57e20228:	e0851001 	add	r1, r5, r1
57e2022c:	e1a02004 	mov	r2, r4
57e20230:	e12fff3c 	blx	ip
57e20234:	e8bd8038 	pop	{r3, r4, r5, pc}
#define DOS_FS32_TYPE_OFFSET	0x52

static int disk_read(__u32 block, __u32 nr_blocks, void *buf)
{
	if (!cur_dev || !cur_dev->block_read)
		return -1;
57e20238:	e3e00000 	mvn	r0, #0

	return cur_dev->block_read(cur_dev->dev,
			cur_part_info.start + block, nr_blocks, buf);
}
57e2023c:	e8bd8038 	pop	{r3, r4, r5, pc}
57e20240:	57e48fc0 	.word	0x57e48fc0

57e20244 <dirdelim>:
	while (*str != '\0') {
		if (ISDIRDELIM(*str))
			return str - start;
		str++;
	}
	return -1;
57e20244:	e1a03000 	mov	r3, r0
 */
static int dirdelim(char *str)
{
	char *start = str;

	while (*str != '\0') {
57e20248:	ea000004 	b	57e20260 <dirdelim+0x1c>
		if (ISDIRDELIM(*str))
57e2024c:	e352002f 	cmp	r2, #47	; 0x2f
57e20250:	1352005c 	cmpne	r2, #92	; 0x5c
57e20254:	1a000001 	bne	57e20260 <dirdelim+0x1c>
			return str - start;
57e20258:	e0600001 	rsb	r0, r0, r1
57e2025c:	e12fff1e 	bx	lr
57e20260:	e1a01003 	mov	r1, r3
 */
static int dirdelim(char *str)
{
	char *start = str;

	while (*str != '\0') {
57e20264:	e4d32001 	ldrb	r2, [r3], #1
57e20268:	e3520000 	cmp	r2, #0
57e2026c:	1afffff6 	bne	57e2024c <dirdelim+0x8>
		if (ISDIRDELIM(*str))
			return str - start;
		str++;
	}
	return -1;
57e20270:	e3e00000 	mvn	r0, #0
}
57e20274:	e12fff1e 	bx	lr

57e20278 <get_fatent>:
/*
 * Get the entry at index 'entry' in a FAT (12/16/32) table.
 * On failure 0x00 is returned.
 */
static __u32 get_fatent(fsdata *mydata, __u32 entry)
{
57e20278:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	__u32 bufnum;
	__u32 off16, offset;
	__u32 ret = 0x00;
	__u16 val1, val2;

	switch (mydata->fatsize) {
57e2027c:	e5903004 	ldr	r3, [r0, #4]
/*
 * Get the entry at index 'entry' in a FAT (12/16/32) table.
 * On failure 0x00 is returned.
 */
static __u32 get_fatent(fsdata *mydata, __u32 entry)
{
57e20280:	e1a04000 	mov	r4, r0
	__u32 bufnum;
	__u32 off16, offset;
	__u32 ret = 0x00;
	__u16 val1, val2;

	switch (mydata->fatsize) {
57e20284:	e3530010 	cmp	r3, #16
/*
 * Get the entry at index 'entry' in a FAT (12/16/32) table.
 * On failure 0x00 is returned.
 */
static __u32 get_fatent(fsdata *mydata, __u32 entry)
{
57e20288:	e1a07001 	mov	r7, r1
	__u32 bufnum;
	__u32 off16, offset;
	__u32 ret = 0x00;
	__u16 val1, val2;

	switch (mydata->fatsize) {
57e2028c:	0a000009 	beq	57e202b8 <get_fatent+0x40>
57e20290:	e3530020 	cmp	r3, #32
57e20294:	0a000002 	beq	57e202a4 <get_fatent+0x2c>
57e20298:	e353000c 	cmp	r3, #12
57e2029c:	1a00004d 	bne	57e203d8 <get_fatent+0x160>
57e202a0:	ea000007 	b	57e202c4 <get_fatent+0x4c>
	case 32:
		bufnum = entry / FAT32BUFSIZE;
57e202a4:	e1d031b4 	ldrh	r3, [r0, #20]
57e202a8:	e3a06006 	mov	r6, #6
57e202ac:	e0060693 	mul	r6, r3, r6
57e202b0:	e1a06146 	asr	r6, r6, #2
57e202b4:	ea000004 	b	57e202cc <get_fatent+0x54>
		offset = entry - bufnum * FAT32BUFSIZE;
		break;
	case 16:
		bufnum = entry / FAT16BUFSIZE;
57e202b8:	e1d061b4 	ldrh	r6, [r0, #20]
57e202bc:	e0866086 	add	r6, r6, r6, lsl #1
57e202c0:	ea000001 	b	57e202cc <get_fatent+0x54>
		offset = entry - bufnum * FAT16BUFSIZE;
		break;
	case 12:
		bufnum = entry / FAT12BUFSIZE;
57e202c4:	e1d061b4 	ldrh	r6, [r0, #20]
57e202c8:	e1a06106 	lsl	r6, r6, #2
57e202cc:	e1a01006 	mov	r1, r6
57e202d0:	e1a00007 	mov	r0, r7
57e202d4:	eb002d35 	bl	57e2b7b0 <__udivsi3>
		offset = entry - bufnum * FAT12BUFSIZE;
57e202d8:	e0060690 	mul	r6, r0, r6

	debug("FAT%d: entry: 0x%04x = %d, offset: 0x%04x = %d\n",
	       mydata->fatsize, entry, entry, offset, offset);

	/* Read a new block of FAT entries into the cache. */
	if (bufnum != mydata->fatbufnum) {
57e202dc:	e594301c 	ldr	r3, [r4, #28]
	case 16:
		bufnum = entry / FAT16BUFSIZE;
		offset = entry - bufnum * FAT16BUFSIZE;
		break;
	case 12:
		bufnum = entry / FAT12BUFSIZE;
57e202e0:	e1a05000 	mov	r5, r0

	debug("FAT%d: entry: 0x%04x = %d, offset: 0x%04x = %d\n",
	       mydata->fatsize, entry, entry, offset, offset);

	/* Read a new block of FAT entries into the cache. */
	if (bufnum != mydata->fatbufnum) {
57e202e4:	e1500003 	cmp	r0, r3
		bufnum = entry / FAT16BUFSIZE;
		offset = entry - bufnum * FAT16BUFSIZE;
		break;
	case 12:
		bufnum = entry / FAT12BUFSIZE;
		offset = entry - bufnum * FAT12BUFSIZE;
57e202e8:	e0666007 	rsb	r6, r6, r7

	debug("FAT%d: entry: 0x%04x = %d, offset: 0x%04x = %d\n",
	       mydata->fatsize, entry, entry, offset, offset);

	/* Read a new block of FAT entries into the cache. */
	if (bufnum != mydata->fatbufnum) {
57e202ec:	0a00000c 	beq	57e20324 <get_fatent+0xac>
		__u32 getsize = FATBUFBLOCKS;
		__u8 *bufptr = mydata->fatbuf;
		__u32 fatlength = mydata->fatlength;
		__u32 startblock = bufnum * FATBUFBLOCKS;
57e202f0:	e3a01006 	mov	r1, #6
57e202f4:	e0030591 	mul	r3, r1, r5

	/* Read a new block of FAT entries into the cache. */
	if (bufnum != mydata->fatbufnum) {
		__u32 getsize = FATBUFBLOCKS;
		__u8 *bufptr = mydata->fatbuf;
		__u32 fatlength = mydata->fatlength;
57e202f8:	e5940008 	ldr	r0, [r4, #8]
		__u32 startblock = bufnum * FATBUFBLOCKS;

		if (startblock + getsize > fatlength)
57e202fc:	e083c001 	add	ip, r3, r1
57e20300:	e15c0000 	cmp	ip, r0
			getsize = fatlength - startblock;
57e20304:	80631000 	rsbhi	r1, r3, r0

		startblock += mydata->fat_sect;	/* Offset from start of disk */
57e20308:	e1d400bc 	ldrh	r0, [r4, #12]
	       mydata->fatsize, entry, entry, offset, offset);

	/* Read a new block of FAT entries into the cache. */
	if (bufnum != mydata->fatbufnum) {
		__u32 getsize = FATBUFBLOCKS;
		__u8 *bufptr = mydata->fatbuf;
57e2030c:	e5942000 	ldr	r2, [r4]
		if (startblock + getsize > fatlength)
			getsize = fatlength - startblock;

		startblock += mydata->fat_sect;	/* Offset from start of disk */

		if (disk_read(startblock, getsize, bufptr) < 0) {
57e20310:	e0830000 	add	r0, r3, r0
57e20314:	ebffffb5 	bl	57e201f0 <disk_read>
57e20318:	e3500000 	cmp	r0, #0
57e2031c:	ba00002d 	blt	57e203d8 <get_fatent+0x160>
			debug("Error reading FAT blocks\n");
			return ret;
		}
		mydata->fatbufnum = bufnum;
57e20320:	e584501c 	str	r5, [r4, #28]
	}

	/* Get the actual entry from the table */
	switch (mydata->fatsize) {
57e20324:	e5943004 	ldr	r3, [r4, #4]
57e20328:	e3530010 	cmp	r3, #16
	case 32:
		ret = FAT2CPU32(((__u32 *) mydata->fatbuf)[offset]);
		break;
	case 16:
		ret = FAT2CPU16(((__u16 *) mydata->fatbuf)[offset]);
57e2032c:	05943000 	ldreq	r3, [r4]
57e20330:	01a06086 	lsleq	r6, r6, #1
57e20334:	019300b6 	ldrheq	r0, [r3, r6]
		}
		mydata->fatbufnum = bufnum;
	}

	/* Get the actual entry from the table */
	switch (mydata->fatsize) {
57e20338:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
57e2033c:	e3530020 	cmp	r3, #32
	case 32:
		ret = FAT2CPU32(((__u32 *) mydata->fatbuf)[offset]);
57e20340:	05943000 	ldreq	r3, [r4]
57e20344:	07930106 	ldreq	r0, [r3, r6, lsl #2]
		}
		mydata->fatbufnum = bufnum;
	}

	/* Get the actual entry from the table */
	switch (mydata->fatsize) {
57e20348:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
57e2034c:	e353000c 	cmp	r3, #12
57e20350:	1a000022 	bne	57e203e0 <get_fatent+0x168>
		break;
	case 16:
		ret = FAT2CPU16(((__u16 *) mydata->fatbuf)[offset]);
		break;
	case 12:
		off16 = (offset * 3) / 4;
57e20354:	e0863086 	add	r3, r6, r6, lsl #1

		switch (offset & 0x3) {
57e20358:	e2066003 	and	r6, r6, #3
57e2035c:	e3560002 	cmp	r6, #2
		break;
	case 16:
		ret = FAT2CPU16(((__u16 *) mydata->fatbuf)[offset]);
		break;
	case 12:
		off16 = (offset * 3) / 4;
57e20360:	e1a03123 	lsr	r3, r3, #2

		switch (offset & 0x3) {
57e20364:	0a00000d 	beq	57e203a0 <get_fatent+0x128>
57e20368:	e3560003 	cmp	r6, #3
57e2036c:	0a000014 	beq	57e203c4 <get_fatent+0x14c>
57e20370:	e5942000 	ldr	r2, [r4]
57e20374:	e3560001 	cmp	r6, #1
57e20378:	e1a01083 	lsl	r1, r3, #1
		case 0:
			ret = FAT2CPU16(((__u16 *) mydata->fatbuf)[off16]);
57e2037c:	119200b1 	ldrhne	r0, [r2, r1]
			ret &= 0xfff;
			break;
		case 1:
			val1 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16]);
57e20380:	019200b1 	ldrheq	r0, [r2, r1]
			val1 &= 0xf000;
			val2 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16 + 1]);
57e20384:	00823083 	addeq	r3, r2, r3, lsl #1
			val2 &= 0x00ff;
			ret = (val2 << 4) | (val1 >> 12);
57e20388:	05d33002 	ldrbeq	r3, [r3, #2]
		off16 = (offset * 3) / 4;

		switch (offset & 0x3) {
		case 0:
			ret = FAT2CPU16(((__u16 *) mydata->fatbuf)[off16]);
			ret &= 0xfff;
57e2038c:	11a00a00 	lslne	r0, r0, #20
		case 1:
			val1 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16]);
			val1 &= 0xf000;
			val2 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16 + 1]);
			val2 &= 0x00ff;
			ret = (val2 << 4) | (val1 >> 12);
57e20390:	01a00620 	lsreq	r0, r0, #12
		off16 = (offset * 3) / 4;

		switch (offset & 0x3) {
		case 0:
			ret = FAT2CPU16(((__u16 *) mydata->fatbuf)[off16]);
			ret &= 0xfff;
57e20394:	11a00a20 	lsrne	r0, r0, #20
		case 1:
			val1 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16]);
			val1 &= 0xf000;
			val2 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16 + 1]);
			val2 &= 0x00ff;
			ret = (val2 << 4) | (val1 >> 12);
57e20398:	01800203 	orreq	r0, r0, r3, lsl #4
			break;
57e2039c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		case 2:
			val1 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16]);
57e203a0:	e5942000 	ldr	r2, [r4]
57e203a4:	e1a01083 	lsl	r1, r3, #1
			val1 &= 0xff00;
			val2 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16 + 1]);
57e203a8:	e0823083 	add	r3, r2, r3, lsl #1
57e203ac:	e1d300b2 	ldrh	r0, [r3, #2]
			val2 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16 + 1]);
			val2 &= 0x00ff;
			ret = (val2 << 4) | (val1 >> 12);
			break;
		case 2:
			val1 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16]);
57e203b0:	e19210b1 	ldrh	r1, [r2, r1]
			val1 &= 0xff00;
			val2 = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16 + 1]);
			val2 &= 0x000f;
			ret = (val2 << 8) | (val1 >> 8);
57e203b4:	e200000f 	and	r0, r0, #15
57e203b8:	e1a03421 	lsr	r3, r1, #8
57e203bc:	e1830400 	orr	r0, r3, r0, lsl #8
			break;
57e203c0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		case 3:
			ret = FAT2CPU16(((__u16 *)mydata->fatbuf)[off16]);
57e203c4:	e5942000 	ldr	r2, [r4]
57e203c8:	e1a03083 	lsl	r3, r3, #1
57e203cc:	e19200b3 	ldrh	r0, [r2, r3]
			ret = (ret & 0xfff0) >> 4;
57e203d0:	e1a00220 	lsr	r0, r0, #4
			break;
57e203d4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

		startblock += mydata->fat_sect;	/* Offset from start of disk */

		if (disk_read(startblock, getsize, bufptr) < 0) {
			debug("Error reading FAT blocks\n");
			return ret;
57e203d8:	e3a00000 	mov	r0, #0
57e203dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
 */
static __u32 get_fatent(fsdata *mydata, __u32 entry)
{
	__u32 bufnum;
	__u32 off16, offset;
	__u32 ret = 0x00;
57e203e0:	e3a00000 	mov	r0, #0
	}
	debug("FAT%d: ret: %08x, offset: %04x\n",
	       mydata->fatsize, ret, offset);

	return ret;
}
57e203e4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e203e8 <slot2str>:
 * Extract the file name information from 'slotptr' into 'l_name',
 * starting at l_name[*idx].
 * Return 1 if terminator (zero byte) is found, 0 otherwise.
 */
static int slot2str(dir_slot *slotptr, char *l_name, int *idx)
{
57e203e8:	e92d4030 	push	{r4, r5, lr}
	int j;

	for (j = 0; j <= 8; j += 2) {
57e203ec:	e3a03000 	mov	r3, #0
/*
 * Extract the file name information from 'slotptr' into 'l_name',
 * starting at l_name[*idx].
 * Return 1 if terminator (zero byte) is found, 0 otherwise.
 */
static int slot2str(dir_slot *slotptr, char *l_name, int *idx)
57e203f0:	e0804003 	add	r4, r0, r3
{
	int j;

	for (j = 0; j <= 8; j += 2) {
		l_name[*idx] = slotptr->name0_4[j];
57e203f4:	e592c000 	ldr	ip, [r2]
57e203f8:	e5d44001 	ldrb	r4, [r4, #1]
57e203fc:	e7c1400c 	strb	r4, [r1, ip]
		if (l_name[*idx] == 0x00)
57e20400:	e592c000 	ldr	ip, [r2]
57e20404:	e7d1400c 	ldrb	r4, [r1, ip]
57e20408:	e3540000 	cmp	r4, #0
57e2040c:	0a000025 	beq	57e204a8 <slot2str+0xc0>
 */
static int slot2str(dir_slot *slotptr, char *l_name, int *idx)
{
	int j;

	for (j = 0; j <= 8; j += 2) {
57e20410:	e2833002 	add	r3, r3, #2
		l_name[*idx] = slotptr->name0_4[j];
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
57e20414:	e28cc001 	add	ip, ip, #1
 */
static int slot2str(dir_slot *slotptr, char *l_name, int *idx)
{
	int j;

	for (j = 0; j <= 8; j += 2) {
57e20418:	e353000a 	cmp	r3, #10
		l_name[*idx] = slotptr->name0_4[j];
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
57e2041c:	e582c000 	str	ip, [r2]
 */
static int slot2str(dir_slot *slotptr, char *l_name, int *idx)
{
	int j;

	for (j = 0; j <= 8; j += 2) {
57e20420:	1afffff2 	bne	57e203f0 <slot2str+0x8>
57e20424:	e1a0c000 	mov	ip, r0
57e20428:	e3a03000 	mov	r3, #0
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
	}
	for (j = 0; j <= 10; j += 2) {
		l_name[*idx] = slotptr->name5_10[j];
57e2042c:	e5924000 	ldr	r4, [r2]
57e20430:	e5dc500e 	ldrb	r5, [ip, #14]
57e20434:	e7c15004 	strb	r5, [r1, r4]
		if (l_name[*idx] == 0x00)
57e20438:	e5924000 	ldr	r4, [r2]
57e2043c:	e7d15004 	ldrb	r5, [r1, r4]
57e20440:	e3550000 	cmp	r5, #0
57e20444:	0a000017 	beq	57e204a8 <slot2str+0xc0>
		l_name[*idx] = slotptr->name0_4[j];
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
	}
	for (j = 0; j <= 10; j += 2) {
57e20448:	e2833002 	add	r3, r3, #2
		l_name[*idx] = slotptr->name5_10[j];
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
57e2044c:	e2844001 	add	r4, r4, #1
		l_name[*idx] = slotptr->name0_4[j];
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
	}
	for (j = 0; j <= 10; j += 2) {
57e20450:	e353000c 	cmp	r3, #12
		l_name[*idx] = slotptr->name5_10[j];
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
57e20454:	e5824000 	str	r4, [r2]
		l_name[*idx] = slotptr->name0_4[j];
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
	}
	for (j = 0; j <= 10; j += 2) {
57e20458:	e28cc002 	add	ip, ip, #2
57e2045c:	1afffff2 	bne	57e2042c <slot2str+0x44>
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
	}
	for (j = 0; j <= 2; j += 2) {
		l_name[*idx] = slotptr->name11_12[j];
57e20460:	e5d0301c 	ldrb	r3, [r0, #28]
57e20464:	e7c13004 	strb	r3, [r1, r4]
		if (l_name[*idx] == 0x00)
57e20468:	e5923000 	ldr	r3, [r2]
57e2046c:	e7d1c003 	ldrb	ip, [r1, r3]
57e20470:	e35c0000 	cmp	ip, #0
57e20474:	0a00000b 	beq	57e204a8 <slot2str+0xc0>
			return 1;
		(*idx)++;
57e20478:	e2833001 	add	r3, r3, #1
57e2047c:	e5823000 	str	r3, [r2]
		if (l_name[*idx] == 0x00)
			return 1;
		(*idx)++;
	}
	for (j = 0; j <= 2; j += 2) {
		l_name[*idx] = slotptr->name11_12[j];
57e20480:	e5d0001e 	ldrb	r0, [r0, #30]
57e20484:	e7c10003 	strb	r0, [r1, r3]
		if (l_name[*idx] == 0x00)
57e20488:	e5923000 	ldr	r3, [r2]
57e2048c:	e7d11003 	ldrb	r1, [r1, r3]
57e20490:	e3510000 	cmp	r1, #0
			return 1;
		(*idx)++;
57e20494:	12833001 	addne	r3, r3, #1
57e20498:	15823000 	strne	r3, [r2]
	}

	return 0;
57e2049c:	13a00000 	movne	r0, #0
			return 1;
		(*idx)++;
	}
	for (j = 0; j <= 2; j += 2) {
		l_name[*idx] = slotptr->name11_12[j];
		if (l_name[*idx] == 0x00)
57e204a0:	18bd8030 	popne	{r4, r5, pc}
57e204a4:	ea000001 	b	57e204b0 <slot2str+0xc8>
			return 1;
57e204a8:	e3a00001 	mov	r0, #1
57e204ac:	e8bd8030 	pop	{r4, r5, pc}
57e204b0:	e3a00001 	mov	r0, #1
		(*idx)++;
	}

	return 0;
}
57e204b4:	e8bd8030 	pop	{r4, r5, pc}

57e204b8 <mkcksum>:
	return 0;
}

/* Calculate short name checksum */
static __u8 mkcksum(const char name[8], const char ext[3])
{
57e204b8:	e1a03000 	mov	r3, r0
	int i;

	__u8 ret = 0;
57e204bc:	e3a00000 	mov	r0, #0

	for (i = 0; i < sizeof(name); i++)
57e204c0:	e1a02000 	mov	r2, r0
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + name[i];
57e204c4:	e1a0c0a0 	lsr	ip, r0, #1
57e204c8:	e18c0380 	orr	r0, ip, r0, lsl #7
57e204cc:	e7d3c002 	ldrb	ip, [r3, r2]
{
	int i;

	__u8 ret = 0;

	for (i = 0; i < sizeof(name); i++)
57e204d0:	e2822001 	add	r2, r2, #1
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + name[i];
57e204d4:	e080000c 	add	r0, r0, ip
{
	int i;

	__u8 ret = 0;

	for (i = 0; i < sizeof(name); i++)
57e204d8:	e3520004 	cmp	r2, #4
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + name[i];
57e204dc:	e20000ff 	and	r0, r0, #255	; 0xff
{
	int i;

	__u8 ret = 0;

	for (i = 0; i < sizeof(name); i++)
57e204e0:	1afffff7 	bne	57e204c4 <mkcksum+0xc>
57e204e4:	e3a03000 	mov	r3, #0
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + name[i];
	for (i = 0; i < sizeof(ext); i++)
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + ext[i];
57e204e8:	e1a020a0 	lsr	r2, r0, #1
57e204ec:	e1820380 	orr	r0, r2, r0, lsl #7
57e204f0:	e7d12003 	ldrb	r2, [r1, r3]

	__u8 ret = 0;

	for (i = 0; i < sizeof(name); i++)
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + name[i];
	for (i = 0; i < sizeof(ext); i++)
57e204f4:	e2833001 	add	r3, r3, #1
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + ext[i];
57e204f8:	e0800002 	add	r0, r0, r2

	__u8 ret = 0;

	for (i = 0; i < sizeof(name); i++)
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + name[i];
	for (i = 0; i < sizeof(ext); i++)
57e204fc:	e3530004 	cmp	r3, #4
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + ext[i];
57e20500:	e20000ff 	and	r0, r0, #255	; 0xff

	__u8 ret = 0;

	for (i = 0; i < sizeof(name); i++)
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + name[i];
	for (i = 0; i < sizeof(ext); i++)
57e20504:	1afffff7 	bne	57e204e8 <mkcksum+0x30>
		ret = (((ret & 1) << 7) | ((ret & 0xfe) >> 1)) + ext[i];

	return ret;
}
57e20508:	e12fff1e 	bx	lr

57e2050c <get_name>:

/*
 * Extract zero terminated short name from a directory entry.
 */
static void get_name(dir_entry *dirent, char *s_name)
{
57e2050c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
57e20510:	e1a06000 	mov	r6, r0
57e20514:	e1a04001 	mov	r4, r1
	char *ptr;

	memcpy(s_name, dirent->name, 8);
57e20518:	e1a00001 	mov	r0, r1
57e2051c:	e3a02008 	mov	r2, #8
57e20520:	e1a01006 	mov	r1, r6
57e20524:	eb000f78 	bl	57e2430c <memcpy>
	s_name[8] = '\0';
57e20528:	e3a03000 	mov	r3, #0
57e2052c:	e5c43008 	strb	r3, [r4, #8]
57e20530:	e1a02004 	mov	r2, r4
	ptr = s_name;
	while (*ptr && *ptr != ' ')
57e20534:	e1a03002 	mov	r3, r2
57e20538:	e4d27001 	ldrb	r7, [r2], #1
57e2053c:	e3570020 	cmp	r7, #32
57e20540:	13570000 	cmpne	r7, #0
57e20544:	03a07000 	moveq	r7, #0
57e20548:	13a07001 	movne	r7, #1
57e2054c:	1afffff8 	bne	57e20534 <get_name+0x28>
		ptr++;
	if (dirent->ext[0] && dirent->ext[0] != ' ') {
57e20550:	e5d62008 	ldrb	r2, [r6, #8]
57e20554:	e3520020 	cmp	r2, #32
57e20558:	13520000 	cmpne	r2, #0
57e2055c:	0a00000c 	beq	57e20594 <get_name+0x88>
		*ptr = '.';
57e20560:	e1a05003 	mov	r5, r3
57e20564:	e3a0302e 	mov	r3, #46	; 0x2e
57e20568:	e4c53001 	strb	r3, [r5], #1
		ptr++;
		memcpy(ptr, dirent->ext, 3);
57e2056c:	e1a00005 	mov	r0, r5
57e20570:	e2861008 	add	r1, r6, #8
57e20574:	e3a02003 	mov	r2, #3
57e20578:	eb000f63 	bl	57e2430c <memcpy>
		ptr[3] = '\0';
57e2057c:	e5c57003 	strb	r7, [r5, #3]
		while (*ptr && *ptr != ' ')
57e20580:	e1a03005 	mov	r3, r5
57e20584:	e4d52001 	ldrb	r2, [r5], #1
57e20588:	e3520020 	cmp	r2, #32
57e2058c:	13520000 	cmpne	r2, #0
57e20590:	1afffffa 	bne	57e20580 <get_name+0x74>
			ptr++;
	}
	*ptr = '\0';
57e20594:	e3a02000 	mov	r2, #0
57e20598:	e5c32000 	strb	r2, [r3]
	if (*s_name == DELETED_FLAG)
57e2059c:	e5d43000 	ldrb	r3, [r4]
57e205a0:	e35300e5 	cmp	r3, #229	; 0xe5
		*s_name = '\0';
57e205a4:	05c42000 	strbeq	r2, [r4]
		ptr[3] = '\0';
		while (*ptr && *ptr != ' ')
			ptr++;
	}
	*ptr = '\0';
	if (*s_name == DELETED_FLAG)
57e205a8:	0a000002 	beq	57e205b8 <get_name+0xac>
		*s_name = '\0';
	else if (*s_name == aRING)
57e205ac:	e3530005 	cmp	r3, #5
		*s_name = DELETED_FLAG;
57e205b0:	03e0301a 	mvneq	r3, #26
57e205b4:	05c43000 	strbeq	r3, [r4]
	downcase(s_name);
57e205b8:	e1a00004 	mov	r0, r4
}
57e205bc:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	*ptr = '\0';
	if (*s_name == DELETED_FLAG)
		*s_name = '\0';
	else if (*s_name == aRING)
		*s_name = DELETED_FLAG;
	downcase(s_name);
57e205c0:	eaffff01 	b	57e201cc <downcase>

57e205c4 <read_bootsectandvi>:
/*
 * Read boot sector and volume info from a FAT filesystem
 */
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
57e205c4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	__u8 *block;
	volume_info *vistart;
	int ret = 0;

	if (cur_dev == NULL) {
57e205c8:	e59f310c 	ldr	r3, [pc, #268]	; 57e206dc <read_bootsectandvi+0x118>
/*
 * Read boot sector and volume info from a FAT filesystem
 */
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
57e205cc:	e1a06000 	mov	r6, r0
	__u8 *block;
	volume_info *vistart;
	int ret = 0;

	if (cur_dev == NULL) {
57e205d0:	e5933000 	ldr	r3, [r3]
/*
 * Read boot sector and volume info from a FAT filesystem
 */
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
57e205d4:	e1a07001 	mov	r7, r1
	__u8 *block;
	volume_info *vistart;
	int ret = 0;

	if (cur_dev == NULL) {
57e205d8:	e3530000 	cmp	r3, #0
/*
 * Read boot sector and volume info from a FAT filesystem
 */
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
57e205dc:	e1a04002 	mov	r4, r2
	__u8 *block;
	volume_info *vistart;
	int ret = 0;

	if (cur_dev == NULL) {
57e205e0:	0a00003a 	beq	57e206d0 <read_bootsectandvi+0x10c>
		debug("Error: no device selected\n");
		return -1;
	}

	block = memalign(ARCH_DMA_MINALIGN, cur_dev->blksz);
57e205e4:	e3a00040 	mov	r0, #64	; 0x40
57e205e8:	e5931014 	ldr	r1, [r3, #20]
57e205ec:	ebffa71a 	bl	57e0a25c <memalign>
	if (block == NULL) {
57e205f0:	e2505000 	subs	r5, r0, #0
57e205f4:	0a000035 	beq	57e206d0 <read_bootsectandvi+0x10c>
		debug("Error: allocating block\n");
		return -1;
	}

	if (disk_read(0, 1, block) < 0) {
57e205f8:	e3a00000 	mov	r0, #0
57e205fc:	e3a01001 	mov	r1, #1
57e20600:	e1a02005 	mov	r2, r5
57e20604:	ebfffef9 	bl	57e201f0 <disk_read>
57e20608:	e3500000 	cmp	r0, #0
57e2060c:	ba00002b 	blt	57e206c0 <read_bootsectandvi+0xfc>
		debug("Error: reading block\n");
		goto fail;
	}

	memcpy(bs, block, sizeof(boot_sector));
57e20610:	e1a00006 	mov	r0, r6
57e20614:	e1a01005 	mov	r1, r5
57e20618:	e3a02040 	mov	r2, #64	; 0x40
57e2061c:	eb000f3a 	bl	57e2430c <memcpy>
	bs->secs_track = FAT2CPU16(bs->secs_track);
	bs->heads = FAT2CPU16(bs->heads);
	bs->total_sect = FAT2CPU32(bs->total_sect);

	/* FAT32 entries */
	if (bs->fat_length == 0) {
57e20620:	e1d631b6 	ldrh	r3, [r6, #22]
		*fatsize = 32;
	} else {
		vistart = (volume_info *)&(bs->fat32_length);
		*fatsize = 0;
	}
	memcpy(volinfo, vistart, sizeof(volume_info));
57e20624:	e1a00007 	mov	r0, r7
	bs->secs_track = FAT2CPU16(bs->secs_track);
	bs->heads = FAT2CPU16(bs->heads);
	bs->total_sect = FAT2CPU32(bs->total_sect);

	/* FAT32 entries */
	if (bs->fat_length == 0) {
57e20628:	e3530000 	cmp	r3, #0
		bs->fat32_length = FAT2CPU32(bs->fat32_length);
		bs->flags = FAT2CPU16(bs->flags);
		bs->root_cluster = FAT2CPU32(bs->root_cluster);
		bs->info_sector = FAT2CPU16(bs->info_sector);
		bs->backup_boot = FAT2CPU16(bs->backup_boot);
		vistart = (volume_info *)(block + sizeof(boot_sector));
57e2062c:	02856040 	addeq	r6, r5, #64	; 0x40
		*fatsize = 32;
57e20630:	02833020 	addeq	r3, r3, #32
	} else {
		vistart = (volume_info *)&(bs->fat32_length);
57e20634:	12866024 	addne	r6, r6, #36	; 0x24
		*fatsize = 0;
57e20638:	13a03000 	movne	r3, #0
57e2063c:	e5843000 	str	r3, [r4]
	}
	memcpy(volinfo, vistart, sizeof(volume_info));
57e20640:	e1a01006 	mov	r1, r6
57e20644:	e3a0201a 	mov	r2, #26
57e20648:	eb000f2f 	bl	57e2430c <memcpy>

	if (*fatsize == 32) {
57e2064c:	e5943000 	ldr	r3, [r4]
57e20650:	e2866012 	add	r6, r6, #18
57e20654:	e3530020 	cmp	r3, #32
57e20658:	1a000007 	bne	57e2067c <read_bootsectandvi+0xb8>
		if (strncmp(FAT32_SIGN, vistart->fs_type, SIGNLEN) == 0)
57e2065c:	e59f007c 	ldr	r0, [pc, #124]	; 57e206e0 <read_bootsectandvi+0x11c>
57e20660:	e1a01006 	mov	r1, r6
57e20664:	e3a02008 	mov	r2, #8
57e20668:	eb000e59 	bl	57e23fd4 <strncmp>
57e2066c:	e3500000 	cmp	r0, #0
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
	__u8 *block;
	volume_info *vistart;
	int ret = 0;
57e20670:	01a04000 	moveq	r4, r0
57e20674:	13e04000 	mvnne	r4, #0
57e20678:	ea000011 	b	57e206c4 <read_bootsectandvi+0x100>

	if (*fatsize == 32) {
		if (strncmp(FAT32_SIGN, vistart->fs_type, SIGNLEN) == 0)
			goto exit;
	} else {
		if (strncmp(FAT12_SIGN, vistart->fs_type, SIGNLEN) == 0) {
57e2067c:	e59f0060 	ldr	r0, [pc, #96]	; 57e206e4 <read_bootsectandvi+0x120>
57e20680:	e1a01006 	mov	r1, r6
57e20684:	e3a02008 	mov	r2, #8
57e20688:	eb000e51 	bl	57e23fd4 <strncmp>
57e2068c:	e3500000 	cmp	r0, #0
			*fatsize = 12;
57e20690:	03a0300c 	moveq	r3, #12

	if (*fatsize == 32) {
		if (strncmp(FAT32_SIGN, vistart->fs_type, SIGNLEN) == 0)
			goto exit;
	} else {
		if (strncmp(FAT12_SIGN, vistart->fs_type, SIGNLEN) == 0) {
57e20694:	0a000006 	beq	57e206b4 <read_bootsectandvi+0xf0>
			*fatsize = 12;
			goto exit;
		}
		if (strncmp(FAT16_SIGN, vistart->fs_type, SIGNLEN) == 0) {
57e20698:	e59f0048 	ldr	r0, [pc, #72]	; 57e206e8 <read_bootsectandvi+0x124>
57e2069c:	e1a01006 	mov	r1, r6
57e206a0:	e3a02008 	mov	r2, #8
57e206a4:	eb000e4a 	bl	57e23fd4 <strncmp>
57e206a8:	e3500000 	cmp	r0, #0
57e206ac:	1a000003 	bne	57e206c0 <read_bootsectandvi+0xfc>
			*fatsize = 16;
57e206b0:	e3a03010 	mov	r3, #16
57e206b4:	e5843000 	str	r3, [r4]
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
	__u8 *block;
	volume_info *vistart;
	int ret = 0;
57e206b8:	e1a04000 	mov	r4, r0
			*fatsize = 12;
			goto exit;
		}
		if (strncmp(FAT16_SIGN, vistart->fs_type, SIGNLEN) == 0) {
			*fatsize = 16;
			goto exit;
57e206bc:	ea000000 	b	57e206c4 <read_bootsectandvi+0x100>
		}
	}

	debug("Error: broken fs_type sign\n");
fail:
	ret = -1;
57e206c0:	e3e04000 	mvn	r4, #0
exit:
	free(block);
57e206c4:	e1a00005 	mov	r0, r5
57e206c8:	ebffa4b3 	bl	57e0999c <free>
	return ret;
57e206cc:	ea000000 	b	57e206d4 <read_bootsectandvi+0x110>
	}

	block = memalign(ARCH_DMA_MINALIGN, cur_dev->blksz);
	if (block == NULL) {
		debug("Error: allocating block\n");
		return -1;
57e206d0:	e3e04000 	mvn	r4, #0
fail:
	ret = -1;
exit:
	free(block);
	return ret;
}
57e206d4:	e1a00004 	mov	r0, r4
57e206d8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e206dc:	57e48fc0 	.word	0x57e48fc0
57e206e0:	57e35176 	.word	0x57e35176
57e206e4:	57e3517f 	.word	0x57e3517f
57e206e8:	57e35188 	.word	0x57e35188

57e206ec <get_cluster>:
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
{
57e206ec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	__u32 idx = 0;
	__u32 startsect;
	int ret;

	if (clustnum > 0) {
57e206f0:	e3510000 	cmp	r1, #0
		startsect = mydata->data_begin +
				clustnum * mydata->clust_size;
57e206f4:	11d071b6 	ldrhne	r7, [r0, #22]
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
{
57e206f8:	e1a06003 	mov	r6, r3
	__u32 idx = 0;
	__u32 startsect;
	int ret;

	if (clustnum > 0) {
		startsect = mydata->data_begin +
57e206fc:	15903018 	ldrne	r3, [r0, #24]
				clustnum * mydata->clust_size;
	} else {
		startsect = mydata->rootdir_sect;
57e20700:	05907010 	ldreq	r7, [r0, #16]
	__u32 idx = 0;
	__u32 startsect;
	int ret;

	if (clustnum > 0) {
		startsect = mydata->data_begin +
57e20704:	10273791 	mlane	r7, r1, r7, r3
		startsect = mydata->rootdir_sect;
	}

	debug("gc - clustnum: %d, startsect: %d\n", clustnum, startsect);

	if ((unsigned long)buffer & (ARCH_DMA_MINALIGN - 1)) {
57e20708:	e312003f 	tst	r2, #63	; 0x3f
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
{
57e2070c:	e28db01c 	add	fp, sp, #28
57e20710:	e1a05000 	mov	r5, r0
57e20714:	e1a04002 	mov	r4, r2
57e20718:	e1d011b4 	ldrh	r1, [r0, #20]
		startsect = mydata->rootdir_sect;
	}

	debug("gc - clustnum: %d, startsect: %d\n", clustnum, startsect);

	if ((unsigned long)buffer & (ARCH_DMA_MINALIGN - 1)) {
57e2071c:	0a000021 	beq	57e207a8 <get_cluster+0xbc>
		ALLOC_CACHE_ALIGN_BUFFER(__u8, tmpbuf, mydata->sect_size);
57e20720:	e281303f 	add	r3, r1, #63	; 0x3f
57e20724:	e3c3303f 	bic	r3, r3, #63	; 0x3f
57e20728:	e283304d 	add	r3, r3, #77	; 0x4d
57e2072c:	e1a031a3 	lsr	r3, r3, #3
57e20730:	e1a03183 	lsl	r3, r3, #3
		startsect = mydata->rootdir_sect;
	}

	debug("gc - clustnum: %d, startsect: %d\n", clustnum, startsect);

	if ((unsigned long)buffer & (ARCH_DMA_MINALIGN - 1)) {
57e20734:	e1a0900d 	mov	r9, sp
		ALLOC_CACHE_ALIGN_BUFFER(__u8, tmpbuf, mydata->sect_size);
57e20738:	e04dd003 	sub	sp, sp, r3
57e2073c:	e28da03f 	add	sl, sp, #63	; 0x3f

		printf("FAT: Misaligned buffer address (%p)\n", buffer);
57e20740:	e1a01002 	mov	r1, r2
57e20744:	e59f0110 	ldr	r0, [pc, #272]	; 57e2085c <get_cluster+0x170>
	}

	debug("gc - clustnum: %d, startsect: %d\n", clustnum, startsect);

	if ((unsigned long)buffer & (ARCH_DMA_MINALIGN - 1)) {
		ALLOC_CACHE_ALIGN_BUFFER(__u8, tmpbuf, mydata->sect_size);
57e20748:	e3caa03f 	bic	sl, sl, #63	; 0x3f

		printf("FAT: Misaligned buffer address (%p)\n", buffer);
57e2074c:	ebffa33e 	bl	57e0944c <printf>

		while (size >= mydata->sect_size) {
57e20750:	ea00000f 	b	57e20794 <get_cluster+0xa8>
			ret = disk_read(startsect++, 1, tmpbuf);
57e20754:	e1a00007 	mov	r0, r7
57e20758:	e3a01001 	mov	r1, #1
57e2075c:	e1a0200a 	mov	r2, sl
57e20760:	ebfffea2 	bl	57e201f0 <disk_read>
			if (ret != 1) {
57e20764:	e3500001 	cmp	r0, #1
57e20768:	0a000001 	beq	57e20774 <get_cluster+0x88>
57e2076c:	e1a0d009 	mov	sp, r9
57e20770:	ea000036 	b	57e20850 <get_cluster+0x164>
				debug("Error reading data (got %d)\n", ret);
				return -1;
			}

			memcpy(buffer, tmpbuf, mydata->sect_size);
57e20774:	e1a00004 	mov	r0, r4
57e20778:	e1a0100a 	mov	r1, sl
57e2077c:	e1d521b4 	ldrh	r2, [r5, #20]
57e20780:	eb000ee1 	bl	57e2430c <memcpy>
			buffer += mydata->sect_size;
57e20784:	e1d531b4 	ldrh	r3, [r5, #20]
		ALLOC_CACHE_ALIGN_BUFFER(__u8, tmpbuf, mydata->sect_size);

		printf("FAT: Misaligned buffer address (%p)\n", buffer);

		while (size >= mydata->sect_size) {
			ret = disk_read(startsect++, 1, tmpbuf);
57e20788:	e2877001 	add	r7, r7, #1
				debug("Error reading data (got %d)\n", ret);
				return -1;
			}

			memcpy(buffer, tmpbuf, mydata->sect_size);
			buffer += mydata->sect_size;
57e2078c:	e0844003 	add	r4, r4, r3
			size -= mydata->sect_size;
57e20790:	e0636006 	rsb	r6, r3, r6
	if ((unsigned long)buffer & (ARCH_DMA_MINALIGN - 1)) {
		ALLOC_CACHE_ALIGN_BUFFER(__u8, tmpbuf, mydata->sect_size);

		printf("FAT: Misaligned buffer address (%p)\n", buffer);

		while (size >= mydata->sect_size) {
57e20794:	e1d531b4 	ldrh	r3, [r5, #20]
57e20798:	e1560003 	cmp	r6, r3
57e2079c:	2affffec 	bcs	57e20754 <get_cluster+0x68>
57e207a0:	e1a0d009 	mov	sp, r9
57e207a4:	ea00000d 	b	57e207e0 <get_cluster+0xf4>
			memcpy(buffer, tmpbuf, mydata->sect_size);
			buffer += mydata->sect_size;
			size -= mydata->sect_size;
		}
	} else {
		idx = size / mydata->sect_size;
57e207a8:	e1a00006 	mov	r0, r6
57e207ac:	eb002bff 	bl	57e2b7b0 <__udivsi3>
57e207b0:	e1a0a000 	mov	sl, r0
		ret = disk_read(startsect, idx, buffer);
57e207b4:	e1a0100a 	mov	r1, sl
57e207b8:	e1a00007 	mov	r0, r7
57e207bc:	e1a02004 	mov	r2, r4
57e207c0:	ebfffe8a 	bl	57e201f0 <disk_read>
		if (ret != idx) {
57e207c4:	e150000a 	cmp	r0, sl
57e207c8:	1a000020 	bne	57e20850 <get_cluster+0x164>
			debug("Error reading data (got %d)\n", ret);
			return -1;
		}
		startsect += idx;
		idx *= mydata->sect_size;
57e207cc:	e1d531b4 	ldrh	r3, [r5, #20]
		ret = disk_read(startsect, idx, buffer);
		if (ret != idx) {
			debug("Error reading data (got %d)\n", ret);
			return -1;
		}
		startsect += idx;
57e207d0:	e0877000 	add	r7, r7, r0
		idx *= mydata->sect_size;
57e207d4:	e0000093 	mul	r0, r3, r0
		buffer += idx;
57e207d8:	e0844000 	add	r4, r4, r0
		size -= idx;
57e207dc:	e0606006 	rsb	r6, r0, r6
	}
	if (size) {
57e207e0:	e3560000 	cmp	r6, #0
		}

		memcpy(buffer, tmpbuf, size);
	}

	return 0;
57e207e4:	01a00006 	moveq	r0, r6
		startsect += idx;
		idx *= mydata->sect_size;
		buffer += idx;
		size -= idx;
	}
	if (size) {
57e207e8:	0a000019 	beq	57e20854 <get_cluster+0x168>
		ALLOC_CACHE_ALIGN_BUFFER(__u8, tmpbuf, mydata->sect_size);
57e207ec:	e1d531b4 	ldrh	r3, [r5, #20]
		startsect += idx;
		idx *= mydata->sect_size;
		buffer += idx;
		size -= idx;
	}
	if (size) {
57e207f0:	e1a0a00d 	mov	sl, sp
		ALLOC_CACHE_ALIGN_BUFFER(__u8, tmpbuf, mydata->sect_size);
57e207f4:	e283303f 	add	r3, r3, #63	; 0x3f
57e207f8:	e3c3303f 	bic	r3, r3, #63	; 0x3f
57e207fc:	e283304d 	add	r3, r3, #77	; 0x4d
57e20800:	e1a031a3 	lsr	r3, r3, #3
57e20804:	e1a03183 	lsl	r3, r3, #3
57e20808:	e04dd003 	sub	sp, sp, r3
57e2080c:	e28d503f 	add	r5, sp, #63	; 0x3f
57e20810:	e3c5503f 	bic	r5, r5, #63	; 0x3f

		ret = disk_read(startsect, 1, tmpbuf);
57e20814:	e1a00007 	mov	r0, r7
57e20818:	e3a01001 	mov	r1, #1
57e2081c:	e1a02005 	mov	r2, r5
57e20820:	ebfffe72 	bl	57e201f0 <disk_read>
		if (ret != 1) {
57e20824:	e3500001 	cmp	r0, #1
57e20828:	0a000001 	beq	57e20834 <get_cluster+0x148>
57e2082c:	e1a0d00a 	mov	sp, sl
57e20830:	ea000006 	b	57e20850 <get_cluster+0x164>
			debug("Error reading data (got %d)\n", ret);
			return -1;
		}

		memcpy(buffer, tmpbuf, size);
57e20834:	e1a00004 	mov	r0, r4
57e20838:	e1a01005 	mov	r1, r5
57e2083c:	e1a02006 	mov	r2, r6
57e20840:	eb000eb1 	bl	57e2430c <memcpy>
	}

	return 0;
57e20844:	e3a00000 	mov	r0, #0
		if (ret != 1) {
			debug("Error reading data (got %d)\n", ret);
			return -1;
		}

		memcpy(buffer, tmpbuf, size);
57e20848:	e1a0d00a 	mov	sp, sl
57e2084c:	ea000000 	b	57e20854 <get_cluster+0x168>
	} else {
		idx = size / mydata->sect_size;
		ret = disk_read(startsect, idx, buffer);
		if (ret != idx) {
			debug("Error reading data (got %d)\n", ret);
			return -1;
57e20850:	e3e00000 	mvn	r0, #0

		memcpy(buffer, tmpbuf, size);
	}

	return 0;
}
57e20854:	e24bd01c 	sub	sp, fp, #28
57e20858:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e2085c:	57e35191 	.word	0x57e35191

57e20860 <get_vfatname>:
 * Return 0 on success, -1 otherwise.
 */
static int
get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
	     dir_entry *retdent, char *l_name)
{
57e20860:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e20864:	e1a0a003 	mov	sl, r3
	dir_entry *realdent;
	dir_slot *slotptr = (dir_slot *)retdent;
	__u8 *buflimit = cluster + mydata->sect_size * ((curclust == 0) ?
							PREFETCH_BLOCKS :
							mydata->clust_size);
	__u8 counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
57e20868:	e5da5000 	ldrb	r5, [sl]
	     dir_entry *retdent, char *l_name)
{
	dir_entry *realdent;
	dir_slot *slotptr = (dir_slot *)retdent;
	__u8 *buflimit = cluster + mydata->sect_size * ((curclust == 0) ?
							PREFETCH_BLOCKS :
57e2086c:	e3510000 	cmp	r1, #0
 * Return 0 on success, -1 otherwise.
 */
static int
get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
	     dir_entry *retdent, char *l_name)
{
57e20870:	e1a06000 	mov	r6, r0
	dir_entry *realdent;
	dir_slot *slotptr = (dir_slot *)retdent;
57e20874:	e1a04003 	mov	r4, r3
	__u8 *buflimit = cluster + mydata->sect_size * ((curclust == 0) ?
							PREFETCH_BLOCKS :
							mydata->clust_size);
	__u8 counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
57e20878:	e20550bf 	and	r5, r5, #191	; 0xbf
get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
	     dir_entry *retdent, char *l_name)
{
	dir_entry *realdent;
	dir_slot *slotptr = (dir_slot *)retdent;
	__u8 *buflimit = cluster + mydata->sect_size * ((curclust == 0) ?
57e2087c:	e1d031b4 	ldrh	r3, [r0, #20]
							PREFETCH_BLOCKS :
57e20880:	11d001b6 	ldrhne	r0, [r0, #22]
57e20884:	03a00002 	moveq	r0, #2
							mydata->clust_size);
	__u8 counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
	int idx = 0;
57e20888:	e3a0c000 	mov	ip, #0

	if (counter > VFAT_MAXSEQ) {
57e2088c:	e3550009 	cmp	r5, #9
 * Return 0 on success, -1 otherwise.
 */
static int
get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
	     dir_entry *retdent, char *l_name)
{
57e20890:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
	dir_entry *realdent;
	dir_slot *slotptr = (dir_slot *)retdent;
	__u8 *buflimit = cluster + mydata->sect_size * ((curclust == 0) ?
57e20894:	e0222093 	mla	r2, r3, r0, r2
							PREFETCH_BLOCKS :
							mydata->clust_size);
	__u8 counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
	int idx = 0;
57e20898:	e58dc004 	str	ip, [sp, #4]

	if (counter > VFAT_MAXSEQ) {
57e2089c:	9a000009 	bls	57e208c8 <get_vfatname+0x68>
57e208a0:	ea000056 	b	57e20a00 <get_vfatname+0x1a0>
		debug("Error: VFAT name is too long\n");
		return -1;
	}

	while ((__u8 *)slotptr < buflimit) {
		if (counter == 0)
57e208a4:	e3550000 	cmp	r5, #0
57e208a8:	0a000009 	beq	57e208d4 <get_vfatname+0x74>
			break;
		if (((slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff) != counter)
57e208ac:	e5d43000 	ldrb	r3, [r4]
57e208b0:	e20330bf 	and	r3, r3, #191	; 0xbf
57e208b4:	e1530005 	cmp	r3, r5
57e208b8:	1a000050 	bne	57e20a00 <get_vfatname+0x1a0>
			return -1;
		slotptr++;
		counter--;
57e208bc:	e2455001 	sub	r5, r5, #1
	while ((__u8 *)slotptr < buflimit) {
		if (counter == 0)
			break;
		if (((slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff) != counter)
			return -1;
		slotptr++;
57e208c0:	e2844020 	add	r4, r4, #32
		counter--;
57e208c4:	e20550ff 	and	r5, r5, #255	; 0xff
	if (counter > VFAT_MAXSEQ) {
		debug("Error: VFAT name is too long\n");
		return -1;
	}

	while ((__u8 *)slotptr < buflimit) {
57e208c8:	e1540002 	cmp	r4, r2
57e208cc:	3afffff4 	bcc	57e208a4 <get_vfatname+0x44>
57e208d0:	ea00004c 	b	57e20a08 <get_vfatname+0x1a8>
			slotptr2--;
			slot2str(slotptr2, l_name, &idx);
		}
	} else {
		/* Save the real directory entry */
		realdent = (dir_entry *)slotptr;
57e208d4:	e1a05004 	mov	r5, r4
57e208d8:	ea00002b 	b	57e2098c <get_vfatname+0x12c>
	if ((__u8 *)slotptr >= buflimit) {
		dir_slot *slotptr2;

		if (curclust == 0)
			return -1;
		curclust = get_fatent(mydata, curclust);
57e208dc:	e1a00006 	mov	r0, r6
57e208e0:	ebfffe64 	bl	57e20278 <get_fatent>
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e208e4:	e3500001 	cmp	r0, #1
	if ((__u8 *)slotptr >= buflimit) {
		dir_slot *slotptr2;

		if (curclust == 0)
			return -1;
		curclust = get_fatent(mydata, curclust);
57e208e8:	e1a01000 	mov	r1, r0
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e208ec:	da000005 	ble	57e20908 <get_vfatname+0xa8>
57e208f0:	e5963004 	ldr	r3, [r6, #4]
57e208f4:	e3530020 	cmp	r3, #32
57e208f8:	e59f3114 	ldr	r3, [pc, #276]	; 57e20a14 <get_vfatname+0x1b4>
57e208fc:	03e032ff 	mvneq	r3, #-268435441	; 0xf000000f
57e20900:	e1500003 	cmp	r0, r3
57e20904:	ba000002 	blt	57e20914 <get_vfatname+0xb4>
			debug("curclust: 0x%x\n", curclust);
			printf("Invalid FAT entry\n");
57e20908:	e59f0108 	ldr	r0, [pc, #264]	; 57e20a18 <get_vfatname+0x1b8>
57e2090c:	ebffa2ce 	bl	57e0944c <printf>
57e20910:	ea00003a 	b	57e20a00 <get_vfatname+0x1a0>
			return -1;
		}

		if (get_cluster(mydata, curclust, get_contents_vfatname_block,
				mydata->clust_size * mydata->sect_size) != 0) {
57e20914:	e1d631b4 	ldrh	r3, [r6, #20]
57e20918:	e1d6c1b6 	ldrh	ip, [r6, #22]
			debug("curclust: 0x%x\n", curclust);
			printf("Invalid FAT entry\n");
			return -1;
		}

		if (get_cluster(mydata, curclust, get_contents_vfatname_block,
57e2091c:	e1a00006 	mov	r0, r6
57e20920:	e59f20f4 	ldr	r2, [pc, #244]	; 57e20a1c <get_vfatname+0x1bc>
57e20924:	e003039c 	mul	r3, ip, r3
57e20928:	ebffff6f 	bl	57e206ec <get_cluster>
57e2092c:	e3500000 	cmp	r0, #0
				mydata->clust_size * mydata->sect_size) != 0) {
			debug("Error: reading directory block\n");
			return -1;
		}

		slotptr2 = (dir_slot *)get_contents_vfatname_block;
57e20930:	059f60e4 	ldreq	r6, [pc, #228]	; 57e20a1c <get_vfatname+0x1bc>
			debug("curclust: 0x%x\n", curclust);
			printf("Invalid FAT entry\n");
			return -1;
		}

		if (get_cluster(mydata, curclust, get_contents_vfatname_block,
57e20934:	0a000007 	beq	57e20958 <get_vfatname+0xf8>
57e20938:	ea000030 	b	57e20a00 <get_vfatname+0x1a0>
		}

		slotptr2 = (dir_slot *)get_contents_vfatname_block;
		while (counter > 0) {
			if (((slotptr2->id & ~LAST_LONG_ENTRY_MASK)
			    & 0xff) != counter)
57e2093c:	e5d63000 	ldrb	r3, [r6]
57e20940:	e20330bf 	and	r3, r3, #191	; 0xbf
			return -1;
		}

		slotptr2 = (dir_slot *)get_contents_vfatname_block;
		while (counter > 0) {
			if (((slotptr2->id & ~LAST_LONG_ENTRY_MASK)
57e20944:	e1530005 	cmp	r3, r5
57e20948:	1a00002c 	bne	57e20a00 <get_vfatname+0x1a0>
			    & 0xff) != counter)
				return -1;
			slotptr2++;
			counter--;
57e2094c:	e2455001 	sub	r5, r5, #1
		slotptr2 = (dir_slot *)get_contents_vfatname_block;
		while (counter > 0) {
			if (((slotptr2->id & ~LAST_LONG_ENTRY_MASK)
			    & 0xff) != counter)
				return -1;
			slotptr2++;
57e20950:	e2866020 	add	r6, r6, #32
			counter--;
57e20954:	e20550ff 	and	r5, r5, #255	; 0xff
			debug("Error: reading directory block\n");
			return -1;
		}

		slotptr2 = (dir_slot *)get_contents_vfatname_block;
		while (counter > 0) {
57e20958:	e3550000 	cmp	r5, #0
57e2095c:	1afffff6 	bne	57e2093c <get_vfatname+0xdc>
			slotptr2++;
			counter--;
		}

		/* Save the real directory entry */
		realdent = (dir_entry *)slotptr2;
57e20960:	e1a05006 	mov	r5, r6
		while ((__u8 *)slotptr2 > get_contents_vfatname_block) {
57e20964:	e59f90b0 	ldr	r9, [pc, #176]	; 57e20a1c <get_vfatname+0x1bc>
			slotptr2--;
			slot2str(slotptr2, l_name, &idx);
57e20968:	e28db004 	add	fp, sp, #4
			counter--;
		}

		/* Save the real directory entry */
		realdent = (dir_entry *)slotptr2;
		while ((__u8 *)slotptr2 > get_contents_vfatname_block) {
57e2096c:	ea000004 	b	57e20984 <get_vfatname+0x124>
			slotptr2--;
57e20970:	e2466020 	sub	r6, r6, #32
			slot2str(slotptr2, l_name, &idx);
57e20974:	e1a00006 	mov	r0, r6
57e20978:	e1a01007 	mov	r1, r7
57e2097c:	e1a0200b 	mov	r2, fp
57e20980:	ebfffe98 	bl	57e203e8 <slot2str>
			counter--;
		}

		/* Save the real directory entry */
		realdent = (dir_entry *)slotptr2;
		while ((__u8 *)slotptr2 > get_contents_vfatname_block) {
57e20984:	e1560009 	cmp	r6, r9
57e20988:	8afffff8 	bhi	57e20970 <get_vfatname+0x110>
		realdent = (dir_entry *)slotptr;
	}

	do {
		slotptr--;
		if (slot2str(slotptr, l_name, &idx))
57e2098c:	e28d6004 	add	r6, sp, #4
		/* Save the real directory entry */
		realdent = (dir_entry *)slotptr;
	}

	do {
		slotptr--;
57e20990:	e2444020 	sub	r4, r4, #32
		if (slot2str(slotptr, l_name, &idx))
57e20994:	e1a00004 	mov	r0, r4
57e20998:	e1a01007 	mov	r1, r7
57e2099c:	e1a02006 	mov	r2, r6
57e209a0:	ebfffe90 	bl	57e203e8 <slot2str>
57e209a4:	e3500000 	cmp	r0, #0
57e209a8:	1a000002 	bne	57e209b8 <get_vfatname+0x158>
			break;
	} while (!(slotptr->id & LAST_LONG_ENTRY_MASK));
57e209ac:	e5d43000 	ldrb	r3, [r4]
57e209b0:	e3130040 	tst	r3, #64	; 0x40
57e209b4:	0afffff5 	beq	57e20990 <get_vfatname+0x130>

	l_name[idx] = '\0';
57e209b8:	e59d3004 	ldr	r3, [sp, #4]
57e209bc:	e3a02000 	mov	r2, #0
57e209c0:	e7c72003 	strb	r2, [r7, r3]
	if (*l_name == DELETED_FLAG)
57e209c4:	e5d73000 	ldrb	r3, [r7]
57e209c8:	e35300e5 	cmp	r3, #229	; 0xe5
		*l_name = '\0';
57e209cc:	05c72000 	strbeq	r2, [r7]
		if (slot2str(slotptr, l_name, &idx))
			break;
	} while (!(slotptr->id & LAST_LONG_ENTRY_MASK));

	l_name[idx] = '\0';
	if (*l_name == DELETED_FLAG)
57e209d0:	0a000002 	beq	57e209e0 <get_vfatname+0x180>
		*l_name = '\0';
	else if (*l_name == aRING)
57e209d4:	e3530005 	cmp	r3, #5
		*l_name = DELETED_FLAG;
57e209d8:	03e0301a 	mvneq	r3, #26
57e209dc:	05c73000 	strbeq	r3, [r7]
	downcase(l_name);
57e209e0:	e1a00007 	mov	r0, r7
57e209e4:	ebfffdf8 	bl	57e201cc <downcase>

	/* Return the real directory entry */
	memcpy(retdent, realdent, sizeof(dir_entry));
57e209e8:	e1a0000a 	mov	r0, sl
57e209ec:	e1a01005 	mov	r1, r5
57e209f0:	e3a02020 	mov	r2, #32
57e209f4:	eb000e44 	bl	57e2430c <memcpy>

	return 0;
57e209f8:	e3a00000 	mov	r0, #0
57e209fc:	ea000000 	b	57e20a04 <get_vfatname+0x1a4>

	if ((__u8 *)slotptr >= buflimit) {
		dir_slot *slotptr2;

		if (curclust == 0)
			return -1;
57e20a00:	e3e00000 	mvn	r0, #0

	/* Return the real directory entry */
	memcpy(retdent, realdent, sizeof(dir_entry));

	return 0;
}
57e20a04:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if ((__u8 *)slotptr >= buflimit) {
		dir_slot *slotptr2;

		if (curclust == 0)
57e20a08:	e3510000 	cmp	r1, #0
57e20a0c:	0afffffb 	beq	57e20a00 <get_vfatname+0x1a0>
57e20a10:	eaffffb1 	b	57e208dc <get_vfatname+0x7c>
57e20a14:	0000fff0 	.word	0x0000fff0
57e20a18:	57e351b6 	.word	0x57e351b6
57e20a1c:	57e49040 	.word	0x57e49040

57e20a20 <fat_set_blk_dev>:
	return cur_dev->block_read(cur_dev->dev,
			cur_part_info.start + block, nr_blocks, buf);
}

int fat_set_blk_dev(block_dev_desc_t *dev_desc, disk_partition_t *info)
{
57e20a20:	e92d4878 	push	{r3, r4, r5, r6, fp, lr}
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e20a24:	e5902014 	ldr	r2, [r0, #20]

	cur_dev = dev_desc;
57e20a28:	e59f40ac 	ldr	r4, [pc, #172]	; 57e20adc <fat_set_blk_dev+0xbc>
			cur_part_info.start + block, nr_blocks, buf);
}

int fat_set_blk_dev(block_dev_desc_t *dev_desc, disk_partition_t *info)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e20a2c:	e282203f 	add	r2, r2, #63	; 0x3f
57e20a30:	e3c2203f 	bic	r2, r2, #63	; 0x3f
57e20a34:	e2822048 	add	r2, r2, #72	; 0x48
	return cur_dev->block_read(cur_dev->dev,
			cur_part_info.start + block, nr_blocks, buf);
}

int fat_set_blk_dev(block_dev_desc_t *dev_desc, disk_partition_t *info)
{
57e20a38:	e28db014 	add	fp, sp, #20
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e20a3c:	e04dd002 	sub	sp, sp, r2
	return cur_dev->block_read(cur_dev->dev,
			cur_part_info.start + block, nr_blocks, buf);
}

int fat_set_blk_dev(block_dev_desc_t *dev_desc, disk_partition_t *info)
{
57e20a40:	e1a03000 	mov	r3, r0
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e20a44:	e28d503f 	add	r5, sp, #63	; 0x3f

	cur_dev = dev_desc;
57e20a48:	e1a00004 	mov	r0, r4
57e20a4c:	e4803004 	str	r3, [r0], #4
	cur_part_info = *info;
57e20a50:	e3a02050 	mov	r2, #80	; 0x50
			cur_part_info.start + block, nr_blocks, buf);
}

int fat_set_blk_dev(block_dev_desc_t *dev_desc, disk_partition_t *info)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
57e20a54:	e3c5503f 	bic	r5, r5, #63	; 0x3f

	cur_dev = dev_desc;
	cur_part_info = *info;
57e20a58:	eb000e2b 	bl	57e2430c <memcpy>

	/* Make sure it has a valid FAT header */
	if (disk_read(0, 1, buffer) != 1) {
57e20a5c:	e3a00000 	mov	r0, #0
57e20a60:	e3a01001 	mov	r1, #1
57e20a64:	e1a02005 	mov	r2, r5
57e20a68:	ebfffde0 	bl	57e201f0 <disk_read>
57e20a6c:	e3500001 	cmp	r0, #1
57e20a70:	1a000006 	bne	57e20a90 <fat_set_blk_dev+0x70>
		cur_dev = NULL;
		return -1;
	}

	/* Check if it's actually a DOS volume */
	if (memcmp(buffer + DOS_BOOT_MAGIC_OFFSET, "\x55\xAA", 2)) {
57e20a74:	e2850f7f 	add	r0, r5, #508	; 0x1fc
57e20a78:	e2800002 	add	r0, r0, #2
57e20a7c:	e59f105c 	ldr	r1, [pc, #92]	; 57e20ae0 <fat_set_blk_dev+0xc0>
57e20a80:	e3a02002 	mov	r2, #2
57e20a84:	eb000e53 	bl	57e243d8 <memcmp>
57e20a88:	e2506000 	subs	r6, r0, #0
57e20a8c:	0a000002 	beq	57e20a9c <fat_set_blk_dev+0x7c>
		cur_dev = NULL;
57e20a90:	e3a03000 	mov	r3, #0
57e20a94:	e5843000 	str	r3, [r4]
57e20a98:	ea00000c 	b	57e20ad0 <fat_set_blk_dev+0xb0>
		return -1;
	}

	/* Check for FAT12/FAT16/FAT32 filesystem */
	if (!memcmp(buffer + DOS_FS_TYPE_OFFSET, "FAT", 3))
57e20a9c:	e2850036 	add	r0, r5, #54	; 0x36
57e20aa0:	e59f103c 	ldr	r1, [pc, #60]	; 57e20ae4 <fat_set_blk_dev+0xc4>
57e20aa4:	e3a02003 	mov	r2, #3
57e20aa8:	eb000e4a 	bl	57e243d8 <memcmp>
57e20aac:	e3500000 	cmp	r0, #0
57e20ab0:	0a000007 	beq	57e20ad4 <fat_set_blk_dev+0xb4>
		return 0;
	if (!memcmp(buffer + DOS_FS32_TYPE_OFFSET, "FAT32", 5))
57e20ab4:	e2850052 	add	r0, r5, #82	; 0x52
57e20ab8:	e59f1028 	ldr	r1, [pc, #40]	; 57e20ae8 <fat_set_blk_dev+0xc8>
57e20abc:	e3a02005 	mov	r2, #5
57e20ac0:	eb000e44 	bl	57e243d8 <memcmp>
57e20ac4:	e3500000 	cmp	r0, #0
57e20ac8:	0a000001 	beq	57e20ad4 <fat_set_blk_dev+0xb4>
		return 0;

	cur_dev = NULL;
57e20acc:	e5846000 	str	r6, [r4]
	return -1;
57e20ad0:	e3e00000 	mvn	r0, #0
}
57e20ad4:	e24bd014 	sub	sp, fp, #20
57e20ad8:	e8bd8878 	pop	{r3, r4, r5, r6, fp, pc}
57e20adc:	57e48fc0 	.word	0x57e48fc0
57e20ae0:	57e351c9 	.word	0x57e351c9
57e20ae4:	57e333d3 	.word	0x57e333d3
57e20ae8:	57e333d7 	.word	0x57e333d7

57e20aec <fat_register_device>:

int fat_register_device(block_dev_desc_t *dev_desc, int part_no)
{
57e20aec:	e92d4030 	push	{r4, r5, lr}
	disk_partition_t info;

	/* First close any currently found FAT filesystem */
	cur_dev = NULL;
57e20af0:	e59f3074 	ldr	r3, [pc, #116]	; 57e20b6c <fat_register_device+0x80>
	cur_dev = NULL;
	return -1;
}

int fat_register_device(block_dev_desc_t *dev_desc, int part_no)
{
57e20af4:	e24dd054 	sub	sp, sp, #84	; 0x54
	disk_partition_t info;

	/* First close any currently found FAT filesystem */
	cur_dev = NULL;
57e20af8:	e3a02000 	mov	r2, #0
57e20afc:	e5832000 	str	r2, [r3]

	/* Read the partition table, if present */
	if (get_partition_info(dev_desc, part_no, &info)) {
57e20b00:	e1a0200d 	mov	r2, sp
	cur_dev = NULL;
	return -1;
}

int fat_register_device(block_dev_desc_t *dev_desc, int part_no)
{
57e20b04:	e1a05000 	mov	r5, r0
57e20b08:	e1a04001 	mov	r4, r1

	/* First close any currently found FAT filesystem */
	cur_dev = NULL;

	/* Read the partition table, if present */
	if (get_partition_info(dev_desc, part_no, &info)) {
57e20b0c:	ebffc9d5 	bl	57e13268 <get_partition_info>
57e20b10:	e3500000 	cmp	r0, #0
57e20b14:	0a00000f 	beq	57e20b58 <fat_register_device+0x6c>
		if (part_no != 0) {
57e20b18:	e3540000 	cmp	r4, #0
57e20b1c:	0a000005 	beq	57e20b38 <fat_register_device+0x4c>
			printf("** Partition %d not valid on device %d **\n",
57e20b20:	e59f0048 	ldr	r0, [pc, #72]	; 57e20b70 <fat_register_device+0x84>
57e20b24:	e1a01004 	mov	r1, r4
57e20b28:	e5952004 	ldr	r2, [r5, #4]
57e20b2c:	ebffa246 	bl	57e0944c <printf>
					part_no, dev_desc->dev);
			return -1;
57e20b30:	e3e00000 	mvn	r0, #0
57e20b34:	ea00000a 	b	57e20b64 <fat_register_device+0x78>
		}

		info.start = 0;
		info.size = dev_desc->lba;
57e20b38:	e5953010 	ldr	r3, [r5, #16]
			printf("** Partition %d not valid on device %d **\n",
					part_no, dev_desc->dev);
			return -1;
		}

		info.start = 0;
57e20b3c:	e58d4000 	str	r4, [sp]
		info.size = dev_desc->lba;
57e20b40:	e58d3004 	str	r3, [sp, #4]
		info.blksz = dev_desc->blksz;
57e20b44:	e5953014 	ldr	r3, [r5, #20]
		info.name[0] = 0;
57e20b48:	e5cd400c 	strb	r4, [sp, #12]
			return -1;
		}

		info.start = 0;
		info.size = dev_desc->lba;
		info.blksz = dev_desc->blksz;
57e20b4c:	e58d3008 	str	r3, [sp, #8]
		info.name[0] = 0;
		info.type[0] = 0;
57e20b50:	e5cd402c 	strb	r4, [sp, #44]	; 0x2c
		info.bootable = 0;
57e20b54:	e58d404c 	str	r4, [sp, #76]	; 0x4c
#ifdef CONFIG_PARTITION_UUIDS
		info.uuid[0] = 0;
#endif
	}

	return fat_set_blk_dev(dev_desc, &info);
57e20b58:	e1a00005 	mov	r0, r5
57e20b5c:	e1a0100d 	mov	r1, sp
57e20b60:	ebffffae 	bl	57e20a20 <fat_set_blk_dev>
}
57e20b64:	e28dd054 	add	sp, sp, #84	; 0x54
57e20b68:	e8bd8030 	pop	{r4, r5, pc}
57e20b6c:	57e48fc0 	.word	0x57e48fc0
57e20b70:	57e351cc 	.word	0x57e351cc

57e20b74 <do_fat_read_at>:
	__aligned(ARCH_DMA_MINALIGN);

long
do_fat_read_at(const char *filename, unsigned long pos, void *buffer,
	       unsigned long maxsize, int dols)
{
57e20b74:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e20b78:	e24ddd2b 	sub	sp, sp, #2752	; 0xac0
57e20b7c:	e24dd008 	sub	sp, sp, #8
57e20b80:	e58d1024 	str	r1, [sp, #36]	; 0x24
57e20b84:	e1a06000 	mov	r6, r0
	int firsttime;
	__u32 root_cluster = 0;
	int rootdir_size = 0;
	int j;

	if (read_bootsectandvi(&bs, &volinfo, &mydata->fatsize)) {
57e20b88:	e28d1ea9 	add	r1, sp, #2704	; 0xa90
57e20b8c:	e28d0ea3 	add	r0, sp, #2608	; 0xa30
	__aligned(ARCH_DMA_MINALIGN);

long
do_fat_read_at(const char *filename, unsigned long pos, void *buffer,
	       unsigned long maxsize, int dols)
{
57e20b90:	e58d2030 	str	r2, [sp, #48]	; 0x30
	int firsttime;
	__u32 root_cluster = 0;
	int rootdir_size = 0;
	int j;

	if (read_bootsectandvi(&bs, &volinfo, &mydata->fatsize)) {
57e20b94:	e280000c 	add	r0, r0, #12
57e20b98:	e281100c 	add	r1, r1, #12
57e20b9c:	e28d2d2a 	add	r2, sp, #2688	; 0xa80
	__aligned(ARCH_DMA_MINALIGN);

long
do_fat_read_at(const char *filename, unsigned long pos, void *buffer,
	       unsigned long maxsize, int dols)
{
57e20ba0:	e58d3034 	str	r3, [sp, #52]	; 0x34
57e20ba4:	e59d7ae8 	ldr	r7, [sp, #2792]	; 0xae8
	int firsttime;
	__u32 root_cluster = 0;
	int rootdir_size = 0;
	int j;

	if (read_bootsectandvi(&bs, &volinfo, &mydata->fatsize)) {
57e20ba8:	ebfffe85 	bl	57e205c4 <read_bootsectandvi>
57e20bac:	e3500000 	cmp	r0, #0
57e20bb0:	1a0002b8 	bne	57e21698 <do_fat_read_at+0xb24>
		debug("Error: reading boot sector\n");
		return -1;
	}

	if (mydata->fatsize == 32) {
57e20bb4:	e59d3a80 	ldr	r3, [sp, #2688]	; 0xa80
		mydata->fatlength = bs.fat32_length;
	} else {
		mydata->fatlength = bs.fat_length;
	}

	mydata->fat_sect = bs.reserved;
57e20bb8:	e28dcc0a 	add	ip, sp, #2560	; 0xa00
	if (read_bootsectandvi(&bs, &volinfo, &mydata->fatsize)) {
		debug("Error: reading boot sector\n");
		return -1;
	}

	if (mydata->fatsize == 32) {
57e20bbc:	e3530020 	cmp	r3, #32
		root_cluster = bs.root_cluster;
		mydata->fatlength = bs.fat32_length;
	} else {
		mydata->fatlength = bs.fat_length;
57e20bc0:	128d1c0a 	addne	r1, sp, #2560	; 0xa00
57e20bc4:	11d125b2 	ldrhne	r2, [r1, #82]	; 0x52
		return -1;
	}

	if (mydata->fatsize == 32) {
		root_cluster = bs.root_cluster;
		mydata->fatlength = bs.fat32_length;
57e20bc8:	059d2a60 	ldreq	r2, [sp, #2656]	; 0xa60
	} else {
		mydata->fatlength = bs.fat_length;
57e20bcc:	158d2a84 	strne	r2, [sp, #2692]	; 0xa84
		return -1;
	}

	if (mydata->fatsize == 32) {
		root_cluster = bs.root_cluster;
		mydata->fatlength = bs.fat32_length;
57e20bd0:	058d2a84 	streq	r2, [sp, #2692]	; 0xa84
	}

	mydata->fat_sect = bs.reserved;

	cursect = mydata->rootdir_sect
		= mydata->fat_sect + mydata->fatlength * bs.fats;
57e20bd4:	e5dd1a4c 	ldrb	r1, [sp, #2636]	; 0xa4c
		mydata->fatlength = bs.fat32_length;
	} else {
		mydata->fatlength = bs.fat_length;
	}

	mydata->fat_sect = bs.reserved;
57e20bd8:	e1dc24ba 	ldrh	r2, [ip, #74]	; 0x4a

	cursect = mydata->rootdir_sect
		= mydata->fat_sect + mydata->fatlength * bs.fats;
57e20bdc:	e59dba84 	ldr	fp, [sp, #2692]	; 0xa84
		mydata->fatlength = bs.fat32_length;
	} else {
		mydata->fatlength = bs.fat_length;
	}

	mydata->fat_sect = bs.reserved;
57e20be0:	e1cc28b8 	strh	r2, [ip, #136]	; 0x88

	cursect = mydata->rootdir_sect
		= mydata->fat_sect + mydata->fatlength * bs.fats;
57e20be4:	e02b2b91 	mla	fp, r1, fp, r2

	mydata->sect_size = (bs.sector_size[1] << 8) + bs.sector_size[0];
57e20be8:	e5ddaa48 	ldrb	sl, [sp, #2632]	; 0xa48
57e20bec:	e5dd2a47 	ldrb	r2, [sp, #2631]	; 0xa47
		debug("Error: reading boot sector\n");
		return -1;
	}

	if (mydata->fatsize == 32) {
		root_cluster = bs.root_cluster;
57e20bf0:	059d0a68 	ldreq	r0, [sp, #2664]	; 0xa68
	mydata->fat_sect = bs.reserved;

	cursect = mydata->rootdir_sect
		= mydata->fat_sect + mydata->fatlength * bs.fats;

	mydata->sect_size = (bs.sector_size[1] << 8) + bs.sector_size[0];
57e20bf4:	e082a40a 	add	sl, r2, sl, lsl #8
	mydata->clust_size = bs.cluster_size;
	if (mydata->sect_size != cur_part_info.blksz) {
57e20bf8:	e59f2aac 	ldr	r2, [pc, #2732]	; 57e216ac <do_fat_read_at+0xb38>
	mydata->fat_sect = bs.reserved;

	cursect = mydata->rootdir_sect
		= mydata->fat_sect + mydata->fatlength * bs.fats;

	mydata->sect_size = (bs.sector_size[1] << 8) + bs.sector_size[0];
57e20bfc:	e1a0a80a 	lsl	sl, sl, #16
	mydata->clust_size = bs.cluster_size;
	if (mydata->sect_size != cur_part_info.blksz) {
57e20c00:	e592200c 	ldr	r2, [r2, #12]
	mydata->fat_sect = bs.reserved;

	cursect = mydata->rootdir_sect
		= mydata->fat_sect + mydata->fatlength * bs.fats;

	mydata->sect_size = (bs.sector_size[1] << 8) + bs.sector_size[0];
57e20c04:	e1a0a82a 	lsr	sl, sl, #16
	mydata->clust_size = bs.cluster_size;
57e20c08:	e5dd4a49 	ldrb	r4, [sp, #2633]	; 0xa49
		debug("Error: reading boot sector\n");
		return -1;
	}

	if (mydata->fatsize == 32) {
		root_cluster = bs.root_cluster;
57e20c0c:	058d0018 	streq	r0, [sp, #24]
	__u32 cursect;
	int idx, isdir = 0;
	int files = 0, dirs = 0;
	long ret = -1;
	int firsttime;
	__u32 root_cluster = 0;
57e20c10:	158d0018 	strne	r0, [sp, #24]
	cursect = mydata->rootdir_sect
		= mydata->fat_sect + mydata->fatlength * bs.fats;

	mydata->sect_size = (bs.sector_size[1] << 8) + bs.sector_size[0];
	mydata->clust_size = bs.cluster_size;
	if (mydata->sect_size != cur_part_info.blksz) {
57e20c14:	e15a0002 	cmp	sl, r2
	}

	mydata->fat_sect = bs.reserved;

	cursect = mydata->rootdir_sect
		= mydata->fat_sect + mydata->fatlength * bs.fats;
57e20c18:	e58dba8c 	str	fp, [sp, #2700]	; 0xa8c

	mydata->sect_size = (bs.sector_size[1] << 8) + bs.sector_size[0];
57e20c1c:	e1cca9b0 	strh	sl, [ip, #144]	; 0x90
	mydata->clust_size = bs.cluster_size;
57e20c20:	e1cc49b2 	strh	r4, [ip, #146]	; 0x92
	if (mydata->sect_size != cur_part_info.blksz) {
57e20c24:	0a000003 	beq	57e20c38 <do_fat_read_at+0xc4>
		printf("Error: FAT sector size mismatch (fs=%hu, dev=%lu)\n",
57e20c28:	e1a0100a 	mov	r1, sl
57e20c2c:	e59f0a7c 	ldr	r0, [pc, #2684]	; 57e216b0 <do_fat_read_at+0xb3c>
57e20c30:	ebffa205 	bl	57e0944c <printf>
57e20c34:	ea000297 	b	57e21698 <do_fat_read_at+0xb24>
				mydata->sect_size, cur_part_info.blksz);
		return -1;
	}

	if (mydata->fatsize == 32) {
57e20c38:	e3530020 	cmp	r3, #32
57e20c3c:	1a000005 	bne	57e20c58 <do_fat_read_at+0xe4>
		mydata->data_begin = mydata->rootdir_sect -
57e20c40:	e3e03001 	mvn	r3, #1
57e20c44:	e024b493 	mla	r4, r3, r4, fp
	int idx, isdir = 0;
	int files = 0, dirs = 0;
	long ret = -1;
	int firsttime;
	__u32 root_cluster = 0;
	int rootdir_size = 0;
57e20c48:	e3a00000 	mov	r0, #0
				mydata->sect_size, cur_part_info.blksz);
		return -1;
	}

	if (mydata->fatsize == 32) {
		mydata->data_begin = mydata->rootdir_sect -
57e20c4c:	e58d4a94 	str	r4, [sp, #2708]	; 0xa94
	int idx, isdir = 0;
	int files = 0, dirs = 0;
	long ret = -1;
	int firsttime;
	__u32 root_cluster = 0;
	int rootdir_size = 0;
57e20c50:	e58d0020 	str	r0, [sp, #32]
57e20c54:	ea00000a 	b	57e20c84 <do_fat_read_at+0x110>

	if (mydata->fatsize == 32) {
		mydata->data_begin = mydata->rootdir_sect -
					(mydata->clust_size * 2);
	} else {
		rootdir_size = ((bs.dir_entries[1]  * (int)256 +
57e20c58:	e5dd3a4d 	ldrb	r3, [sp, #2637]	; 0xa4d
57e20c5c:	e5dd0a4e 	ldrb	r0, [sp, #2638]	; 0xa4e
				 bs.dir_entries[0]) *
				 sizeof(dir_entry)) /
57e20c60:	e1a0100a 	mov	r1, sl

	if (mydata->fatsize == 32) {
		mydata->data_begin = mydata->rootdir_sect -
					(mydata->clust_size * 2);
	} else {
		rootdir_size = ((bs.dir_entries[1]  * (int)256 +
57e20c64:	e0830400 	add	r0, r3, r0, lsl #8
				 bs.dir_entries[0]) *
				 sizeof(dir_entry)) /
57e20c68:	e1a00280 	lsl	r0, r0, #5
57e20c6c:	eb002acf 	bl	57e2b7b0 <__udivsi3>
				 mydata->sect_size;
		mydata->data_begin = mydata->rootdir_sect +
57e20c70:	e3e03001 	mvn	r3, #1
57e20c74:	e024b493 	mla	r4, r3, r4, fp
					rootdir_size -
57e20c78:	e0844000 	add	r4, r4, r0
		mydata->data_begin = mydata->rootdir_sect -
					(mydata->clust_size * 2);
	} else {
		rootdir_size = ((bs.dir_entries[1]  * (int)256 +
				 bs.dir_entries[0]) *
				 sizeof(dir_entry)) /
57e20c7c:	e58d0020 	str	r0, [sp, #32]
				 mydata->sect_size;
		mydata->data_begin = mydata->rootdir_sect +
57e20c80:	e58d4a94 	str	r4, [sp, #2708]	; 0xa94
					rootdir_size -
					(mydata->clust_size * 2);
	}

	mydata->fatbufnum = -1;
	mydata->fatbuf = memalign(ARCH_DMA_MINALIGN, FATBUFSIZE);
57e20c84:	e3a01006 	mov	r1, #6
		mydata->data_begin = mydata->rootdir_sect +
					rootdir_size -
					(mydata->clust_size * 2);
	}

	mydata->fatbufnum = -1;
57e20c88:	e3e04000 	mvn	r4, #0
	mydata->fatbuf = memalign(ARCH_DMA_MINALIGN, FATBUFSIZE);
57e20c8c:	e3a00040 	mov	r0, #64	; 0x40
57e20c90:	e001019a 	mul	r1, sl, r1
		mydata->data_begin = mydata->rootdir_sect +
					rootdir_size -
					(mydata->clust_size * 2);
	}

	mydata->fatbufnum = -1;
57e20c94:	e58d4a98 	str	r4, [sp, #2712]	; 0xa98
	mydata->fatbuf = memalign(ARCH_DMA_MINALIGN, FATBUFSIZE);
57e20c98:	ebffa56f 	bl	57e0a25c <memalign>
	if (mydata->fatbuf == NULL) {
57e20c9c:	e3500000 	cmp	r0, #0
					rootdir_size -
					(mydata->clust_size * 2);
	}

	mydata->fatbufnum = -1;
	mydata->fatbuf = memalign(ARCH_DMA_MINALIGN, FATBUFSIZE);
57e20ca0:	e58d0a7c 	str	r0, [sp, #2684]	; 0xa7c
	if (mydata->fatbuf == NULL) {
57e20ca4:	0a00027c 	beq	57e2169c <do_fat_read_at+0xb28>
57e20ca8:	e1a01006 	mov	r1, r6
	       mydata->rootdir_sect * mydata->sect_size, mydata->data_begin);
	debug("Sector size: %d, cluster size: %d\n", mydata->sect_size,
	      mydata->clust_size);

	/* "cwd" is always the root... */
	while (ISDIRDELIM(*filename))
57e20cac:	e4d65001 	ldrb	r5, [r6], #1
57e20cb0:	e355002f 	cmp	r5, #47	; 0x2f
57e20cb4:	1355005c 	cmpne	r5, #92	; 0x5c
57e20cb8:	13a05000 	movne	r5, #0
57e20cbc:	03a05001 	moveq	r5, #1
57e20cc0:	0afffff8 	beq	57e20ca8 <do_fat_read_at+0x134>
		filename++;

	/* Make a copy of the filename and convert it to lowercase */
	strcpy(fnamecopy, filename);
57e20cc4:	e28d403c 	add	r4, sp, #60	; 0x3c
57e20cc8:	e1a00004 	mov	r0, r4
57e20ccc:	eb000c83 	bl	57e23ee0 <strcpy>
	downcase(fnamecopy);
57e20cd0:	e1a00004 	mov	r0, r4
57e20cd4:	ebfffd3c 	bl	57e201cc <downcase>

	if (*fnamecopy == '\0') {
57e20cd8:	e5dda03c 	ldrb	sl, [sp, #60]	; 0x3c
57e20cdc:	e35a0000 	cmp	sl, #0
57e20ce0:	1a000004 	bne	57e20cf8 <do_fat_read_at+0x184>
		if (!dols)
57e20ce4:	e3570000 	cmp	r7, #0
	volume_info volinfo;
	fsdata datablock;
	fsdata *mydata = &datablock;
	dir_entry *dentptr = NULL;
	__u16 prevcksum = 0xffff;
	char *subname = "";
57e20ce8:	159f59c4 	ldrne	r5, [pc, #2500]	; 57e216b4 <do_fat_read_at+0xb40>

	if (*fnamecopy == '\0') {
		if (!dols)
			goto exit;

		dols = LS_ROOT;
57e20cec:	13a07002 	movne	r7, #2
	/* Make a copy of the filename and convert it to lowercase */
	strcpy(fnamecopy, filename);
	downcase(fnamecopy);

	if (*fnamecopy == '\0') {
		if (!dols)
57e20cf0:	1a000016 	bne	57e20d50 <do_fat_read_at+0x1dc>
57e20cf4:	ea000263 	b	57e21688 <do_fat_read_at+0xb14>
			goto exit;

		dols = LS_ROOT;
	} else if ((idx = dirdelim(fnamecopy)) >= 0) {
57e20cf8:	e1a00004 	mov	r0, r4
57e20cfc:	ebfffd50 	bl	57e20244 <dirdelim>
57e20d00:	e3500000 	cmp	r0, #0
57e20d04:	ba00000d 	blt	57e20d40 <do_fat_read_at+0x1cc>
		isdir = 1;
		fnamecopy[idx] = '\0';
57e20d08:	e28d1d2b 	add	r1, sp, #2752	; 0xac0
57e20d0c:	e2811008 	add	r1, r1, #8
57e20d10:	e0813000 	add	r3, r1, r0
		subname = fnamecopy + idx + 1;
57e20d14:	e2800001 	add	r0, r0, #1
			goto exit;

		dols = LS_ROOT;
	} else if ((idx = dirdelim(fnamecopy)) >= 0) {
		isdir = 1;
		fnamecopy[idx] = '\0';
57e20d18:	e5435a8c 	strb	r5, [r3, #-2700]	; 0xa8c
		subname = fnamecopy + idx + 1;
57e20d1c:	e0844000 	add	r4, r4, r0

		/* Handle multiple delimiters */
		while (ISDIRDELIM(*subname))
57e20d20:	e5d43000 	ldrb	r3, [r4]
57e20d24:	e1a05004 	mov	r5, r4
57e20d28:	e353002f 	cmp	r3, #47	; 0x2f
57e20d2c:	1353005c 	cmpne	r3, #92	; 0x5c
57e20d30:	e2844001 	add	r4, r4, #1
57e20d34:	0afffff9 	beq	57e20d20 <do_fat_read_at+0x1ac>
		if (!dols)
			goto exit;

		dols = LS_ROOT;
	} else if ((idx = dirdelim(fnamecopy)) >= 0) {
		isdir = 1;
57e20d38:	e3a0a001 	mov	sl, #1
57e20d3c:	ea000003 	b	57e20d50 <do_fat_read_at+0x1dc>
	fsdata *mydata = &datablock;
	dir_entry *dentptr = NULL;
	__u16 prevcksum = 0xffff;
	char *subname = "";
	__u32 cursect;
	int idx, isdir = 0;
57e20d40:	e3570000 	cmp	r7, #0
57e20d44:	e59f5968 	ldr	r5, [pc, #2408]	; 57e216b4 <do_fat_read_at+0xb40>
57e20d48:	13a0a001 	movne	sl, #1
57e20d4c:	03a0a000 	moveq	sl, #0
	boot_sector bs;
	volume_info volinfo;
	fsdata datablock;
	fsdata *mydata = &datablock;
	dir_entry *dentptr = NULL;
	__u16 prevcksum = 0xffff;
57e20d50:	e59f2960 	ldr	r2, [pc, #2400]	; 57e216b8 <do_fat_read_at+0xb44>
			subname++;
	} else if (dols) {
		isdir = 1;
	}

	j = 0;
57e20d54:	e3a06000 	mov	r6, #0
	dir_entry *dentptr = NULL;
	__u16 prevcksum = 0xffff;
	char *subname = "";
	__u32 cursect;
	int idx, isdir = 0;
	int files = 0, dirs = 0;
57e20d58:	e58d6014 	str	r6, [sp, #20]
57e20d5c:	e58d6010 	str	r6, [sp, #16]
	boot_sector bs;
	volume_info volinfo;
	fsdata datablock;
	fsdata *mydata = &datablock;
	dir_entry *dentptr = NULL;
	__u16 prevcksum = 0xffff;
57e20d60:	e58d201c 	str	r2, [sp, #28]
	char fnamecopy[2048];
	boot_sector bs;
	volume_info volinfo;
	fsdata datablock;
	fsdata *mydata = &datablock;
	dir_entry *dentptr = NULL;
57e20d64:	e1a04006 	mov	r4, r6
				}
				dentptr++;
				continue;
			}

			if (strcmp(fnamecopy, s_name)
57e20d68:	e58d5028 	str	r5, [sp, #40]	; 0x28
57e20d6c:	e58da02c 	str	sl, [sp, #44]	; 0x2c

	j = 0;
	while (1) {
		int i;

		if (j == 0) {
57e20d70:	e3560000 	cmp	r6, #0
57e20d74:	1a00000a 	bne	57e20da4 <do_fat_read_at+0x230>
			debug("FAT read sect=%d, clust_size=%d, DIRENTSPERBLOCK=%zd\n",
				cursect, mydata->clust_size, DIRENTSPERBLOCK);

			if (disk_read(cursect,
57e20d78:	e59d3a80 	ldr	r3, [sp, #2688]	; 0xa80
57e20d7c:	e1a0000b 	mov	r0, fp
57e20d80:	e3530020 	cmp	r3, #32
57e20d84:	028d3c0a 	addeq	r3, sp, #2560	; 0xa00
57e20d88:	01d319b2 	ldrheq	r1, [r3, #146]	; 0x92
57e20d8c:	13a01002 	movne	r1, #2
57e20d90:	e59f2924 	ldr	r2, [pc, #2340]	; 57e216bc <do_fat_read_at+0xb48>
57e20d94:	ebfffd15 	bl	57e201f0 <disk_read>
57e20d98:	e3500000 	cmp	r0, #0
57e20d9c:	ba000239 	blt	57e21688 <do_fat_read_at+0xb14>
					do_fat_read_at_block) < 0) {
				debug("Error: reading rootdir block\n");
				goto exit;
			}

			dentptr = (dir_entry *) do_fat_read_at_block;
57e20da0:	e59f4914 	ldr	r4, [pc, #2324]	; 57e216bc <do_fat_read_at+0xb48>

__u8 do_fat_read_at_block[MAX_CLUSTSIZE]
	__aligned(ARCH_DMA_MINALIGN);

long
do_fat_read_at(const char *filename, unsigned long pos, void *buffer,
57e20da4:	e2845020 	add	r5, r4, #32
57e20da8:	e3a0a000 	mov	sl, #0
57e20dac:	ea00007f 	b	57e20fb0 <do_fat_read_at+0x43c>

		for (i = 0; i < DIRENTSPERBLOCK; i++) {
			char s_name[14], l_name[VFAT_MAXLEN_BYTES];
			__u8 csum;

			l_name[0] = '\0';
57e20db0:	e3a0c000 	mov	ip, #0
57e20db4:	e5cdc93c 	strb	ip, [sp, #2364]	; 0x93c
			if (dentptr->name[0] == DELETED_FLAG) {
57e20db8:	e5559020 	ldrb	r9, [r5, #-32]
57e20dbc:	e35900e5 	cmp	r9, #229	; 0xe5
57e20dc0:	0a000078 	beq	57e20fa8 <do_fat_read_at+0x434>
				dentptr++;
				continue;
			}

			csum = mkcksum(dentptr->name, dentptr->ext);
57e20dc4:	e1a00004 	mov	r0, r4
57e20dc8:	e2841008 	add	r1, r4, #8
57e20dcc:	ebfffdb9 	bl	57e204b8 <mkcksum>
			if (dentptr->attr & ATTR_VOLUME) {
57e20dd0:	e5553015 	ldrb	r3, [r5, #-21]
57e20dd4:	e3130008 	tst	r3, #8
57e20dd8:	0a000026 	beq	57e20e78 <do_fat_read_at+0x304>
#ifdef CONFIG_SUPPORT_VFAT
				if ((dentptr->attr & ATTR_VFAT) == ATTR_VFAT &&
57e20ddc:	e203300f 	and	r3, r3, #15
57e20de0:	e353000f 	cmp	r3, #15
57e20de4:	1a00006f 	bne	57e20fa8 <do_fat_read_at+0x434>
57e20de8:	e3190040 	tst	r9, #64	; 0x40
57e20dec:	0a00006d 	beq	57e20fa8 <do_fat_read_at+0x434>
				    (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
					prevcksum =
57e20df0:	e5550013 	ldrb	r0, [r5, #-19]
						((dir_slot *)dentptr)->alias_checksum;

					get_vfatname(mydata,
57e20df4:	e28d1e93 	add	r1, sp, #2352	; 0x930
			csum = mkcksum(dentptr->name, dentptr->ext);
			if (dentptr->attr & ATTR_VOLUME) {
#ifdef CONFIG_SUPPORT_VFAT
				if ((dentptr->attr & ATTR_VFAT) == ATTR_VFAT &&
				    (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
					prevcksum =
57e20df8:	e58d001c 	str	r0, [sp, #28]
						((dir_slot *)dentptr)->alias_checksum;

					get_vfatname(mydata,
57e20dfc:	e281100c 	add	r1, r1, #12
57e20e00:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
57e20e04:	e58d1000 	str	r1, [sp]
57e20e08:	e280000c 	add	r0, r0, #12
57e20e0c:	e59d1018 	ldr	r1, [sp, #24]
57e20e10:	e59f28a4 	ldr	r2, [pc, #2212]	; 57e216bc <do_fat_read_at+0xb48>
57e20e14:	e1a03004 	mov	r3, r4
57e20e18:	ebfffe90 	bl	57e20860 <get_vfatname>
						     root_cluster,
						     do_fat_read_at_block,
						     dentptr, l_name);

					if (dols == LS_ROOT) {
57e20e1c:	e3570002 	cmp	r7, #2
57e20e20:	1a000025 	bne	57e20ebc <do_fat_read_at+0x348>
						char dirc;
						int doit = 0;
						int isdir =
							(dentptr->attr & ATTR_DIR);
57e20e24:	e5553015 	ldrb	r3, [r5, #-21]

						if (isdir) {
57e20e28:	e3130010 	tst	r3, #16
57e20e2c:	0a000006 	beq	57e20e4c <do_fat_read_at+0x2d8>
							dirs++;
57e20e30:	e59d2014 	ldr	r2, [sp, #20]
								printf(" %8ld   %s%c\n",
									(long)FAT2CPU32(dentptr->size),
									l_name,
									dirc);
							} else {
								printf("            %s%c\n",
57e20e34:	e28d1e93 	add	r1, sp, #2352	; 0x930
						int doit = 0;
						int isdir =
							(dentptr->attr & ATTR_DIR);

						if (isdir) {
							dirs++;
57e20e38:	e2822001 	add	r2, r2, #1
57e20e3c:	e58d2014 	str	r2, [sp, #20]
								printf(" %8ld   %s%c\n",
									(long)FAT2CPU32(dentptr->size),
									l_name,
									dirc);
							} else {
								printf("            %s%c\n",
57e20e40:	e59f0878 	ldr	r0, [pc, #2168]	; 57e216c0 <do_fat_read_at+0xb4c>
57e20e44:	e281100c 	add	r1, r1, #12
57e20e48:	ea00002d 	b	57e20f04 <do_fat_read_at+0x390>
							dirs++;
							dirc = '/';
							doit = 1;
						} else {
							dirc = ' ';
							if (l_name[0] != 0) {
57e20e4c:	e5dd393c 	ldrb	r3, [sp, #2364]	; 0x93c
57e20e50:	e3530000 	cmp	r3, #0
57e20e54:	0a000053 	beq	57e20fa8 <do_fat_read_at+0x434>
								files++;
57e20e58:	e59d3010 	ldr	r3, [sp, #16]
								doit = 1;
							}
						}
						if (doit) {
							if (dirc == ' ') {
								printf(" %8ld   %s%c\n",
57e20e5c:	e28d2e93 	add	r2, sp, #2352	; 0x930
							dirc = '/';
							doit = 1;
						} else {
							dirc = ' ';
							if (l_name[0] != 0) {
								files++;
57e20e60:	e2833001 	add	r3, r3, #1
57e20e64:	e58d3010 	str	r3, [sp, #16]
								doit = 1;
							}
						}
						if (doit) {
							if (dirc == ' ') {
								printf(" %8ld   %s%c\n",
57e20e68:	e59f0854 	ldr	r0, [pc, #2132]	; 57e216c4 <do_fat_read_at+0xb50>
57e20e6c:	e5151004 	ldr	r1, [r5, #-4]
57e20e70:	e282200c 	add	r2, r2, #12
57e20e74:	ea00002e 	b	57e20f34 <do_fat_read_at+0x3c0>
				{
					/* Volume label or VFAT entry */
					dentptr++;
					continue;
				}
			} else if (dentptr->name[0] == 0) {
57e20e78:	e3590000 	cmp	r9, #0
57e20e7c:	1a000009 	bne	57e20ea8 <do_fat_read_at+0x334>
				debug("RootDentname == NULL - %d\n", i);
				if (dols == LS_ROOT) {
57e20e80:	e3570002 	cmp	r7, #2
57e20e84:	1a0001ff 	bne	57e21688 <do_fat_read_at+0xb14>
					printf("\n%d file(s), %d dir(s)\n\n",
57e20e88:	e59f0838 	ldr	r0, [pc, #2104]	; 57e216c8 <do_fat_read_at+0xb54>
57e20e8c:	e59d1010 	ldr	r1, [sp, #16]
57e20e90:	e59d2014 	ldr	r2, [sp, #20]
57e20e94:	e58d900c 	str	r9, [sp, #12]
57e20e98:	ebffa16b 	bl	57e0944c <printf>
						files, dirs);
					ret = 0;
57e20e9c:	e59d300c 	ldr	r3, [sp, #12]
57e20ea0:	e1a04003 	mov	r4, r3
57e20ea4:	ea0001f8 	b	57e2168c <do_fat_read_at+0xb18>
				}
				goto exit;
			}
#ifdef CONFIG_SUPPORT_VFAT
			else if (dols == LS_ROOT && csum == prevcksum) {
57e20ea8:	e3570002 	cmp	r7, #2
57e20eac:	1a000002 	bne	57e20ebc <do_fat_read_at+0x348>
57e20eb0:	e59dc01c 	ldr	ip, [sp, #28]
57e20eb4:	e150000c 	cmp	r0, ip
57e20eb8:	0a000038 	beq	57e20fa0 <do_fat_read_at+0x42c>
				prevcksum = 0xffff;
				dentptr++;
				continue;
			}
#endif
			get_name(dentptr, s_name);
57e20ebc:	e28d1eab 	add	r1, sp, #2736	; 0xab0
57e20ec0:	e1a00004 	mov	r0, r4
57e20ec4:	e2811008 	add	r1, r1, #8
57e20ec8:	ebfffd8f 	bl	57e2050c <get_name>

			if (dols == LS_ROOT) {
57e20ecc:	e3570002 	cmp	r7, #2
57e20ed0:	1a00001a 	bne	57e20f40 <do_fat_read_at+0x3cc>
				int isdir = (dentptr->attr & ATTR_DIR);
57e20ed4:	e5553015 	ldrb	r3, [r5, #-21]
				char dirc;
				int doit = 0;

				if (isdir) {
57e20ed8:	e3130010 	tst	r3, #16
57e20edc:	e5dd3ab8 	ldrb	r3, [sp, #2744]	; 0xab8
57e20ee0:	0a00000a 	beq	57e20f10 <do_fat_read_at+0x39c>
					dirc = '/';
					if (s_name[0] != 0) {
57e20ee4:	e3530000 	cmp	r3, #0
57e20ee8:	0a00002e 	beq	57e20fa8 <do_fat_read_at+0x434>
						dirs++;
57e20eec:	e59d0014 	ldr	r0, [sp, #20]
					if (dirc == ' ') {
						printf(" %8ld   %s%c\n",
							(long)FAT2CPU32(dentptr->size),
							s_name, dirc);
					} else {
						printf("            %s%c\n",
57e20ef0:	e28d1eab 	add	r1, sp, #2736	; 0xab0
				int doit = 0;

				if (isdir) {
					dirc = '/';
					if (s_name[0] != 0) {
						dirs++;
57e20ef4:	e2800001 	add	r0, r0, #1
57e20ef8:	e58d0014 	str	r0, [sp, #20]
					if (dirc == ' ') {
						printf(" %8ld   %s%c\n",
							(long)FAT2CPU32(dentptr->size),
							s_name, dirc);
					} else {
						printf("            %s%c\n",
57e20efc:	e59f07bc 	ldr	r0, [pc, #1980]	; 57e216c0 <do_fat_read_at+0xb4c>
57e20f00:	e2811008 	add	r1, r1, #8
57e20f04:	e3a0202f 	mov	r2, #47	; 0x2f
57e20f08:	ebffa14f 	bl	57e0944c <printf>
57e20f0c:	ea000025 	b	57e20fa8 <do_fat_read_at+0x434>
						dirs++;
						doit = 1;
					}
				} else {
					dirc = ' ';
					if (s_name[0] != 0) {
57e20f10:	e3530000 	cmp	r3, #0
57e20f14:	0a000023 	beq	57e20fa8 <do_fat_read_at+0x434>
						files++;
57e20f18:	e59d1010 	ldr	r1, [sp, #16]
						doit = 1;
					}
				}
				if (doit) {
					if (dirc == ' ') {
						printf(" %8ld   %s%c\n",
57e20f1c:	e28d2eab 	add	r2, sp, #2736	; 0xab0
						doit = 1;
					}
				} else {
					dirc = ' ';
					if (s_name[0] != 0) {
						files++;
57e20f20:	e2811001 	add	r1, r1, #1
57e20f24:	e58d1010 	str	r1, [sp, #16]
						doit = 1;
					}
				}
				if (doit) {
					if (dirc == ' ') {
						printf(" %8ld   %s%c\n",
57e20f28:	e59f0794 	ldr	r0, [pc, #1940]	; 57e216c4 <do_fat_read_at+0xb50>
57e20f2c:	e5151004 	ldr	r1, [r5, #-4]
57e20f30:	e2822008 	add	r2, r2, #8
57e20f34:	e3a03020 	mov	r3, #32
57e20f38:	ebffa143 	bl	57e0944c <printf>
						printf("            %s%c\n",
							s_name, dirc);
					}
				}
				dentptr++;
				continue;
57e20f3c:	ea000019 	b	57e20fa8 <do_fat_read_at+0x434>
			}

			if (strcmp(fnamecopy, s_name)
57e20f40:	e28d1eab 	add	r1, sp, #2736	; 0xab0
57e20f44:	e28d003c 	add	r0, sp, #60	; 0x3c
57e20f48:	e2811008 	add	r1, r1, #8
57e20f4c:	eb000c14 	bl	57e23fa4 <strcmp>
57e20f50:	e3500000 	cmp	r0, #0
57e20f54:	0a000005 	beq	57e20f70 <do_fat_read_at+0x3fc>
			    && strcmp(fnamecopy, l_name)) {
57e20f58:	e28d1e93 	add	r1, sp, #2352	; 0x930
57e20f5c:	e28d003c 	add	r0, sp, #60	; 0x3c
57e20f60:	e281100c 	add	r1, r1, #12
57e20f64:	eb000c0e 	bl	57e23fa4 <strcmp>
57e20f68:	e3500000 	cmp	r0, #0
57e20f6c:	1a00000d 	bne	57e20fa8 <do_fat_read_at+0x434>
57e20f70:	e59da02c 	ldr	sl, [sp, #44]	; 0x2c
57e20f74:	e59d5028 	ldr	r5, [sp, #40]	; 0x28
				       l_name);
				dentptr++;
				continue;
			}

			if (isdir && !(dentptr->attr & ATTR_DIR))
57e20f78:	e35a0000 	cmp	sl, #0
57e20f7c:	1a000002 	bne	57e20f8c <do_fat_read_at+0x418>
		}

		if (isdir && !(dentptr->attr & ATTR_DIR))
			goto exit;

		if (idx >= 0)
57e20f80:	e3a02001 	mov	r2, #1
57e20f84:	e58d2010 	str	r2, [sp, #16]
57e20f88:	ea00012a 	b	57e21438 <do_fat_read_at+0x8c4>
				       l_name);
				dentptr++;
				continue;
			}

			if (isdir && !(dentptr->attr & ATTR_DIR))
57e20f8c:	e5d4300b 	ldrb	r3, [r4, #11]
57e20f90:	e3130010 	tst	r3, #16
57e20f94:	13a0a001 	movne	sl, #1
57e20f98:	1afffff8 	bne	57e20f80 <do_fat_read_at+0x40c>
57e20f9c:	ea0001b9 	b	57e21688 <do_fat_read_at+0xb14>
				}
				goto exit;
			}
#ifdef CONFIG_SUPPORT_VFAT
			else if (dols == LS_ROOT && csum == prevcksum) {
				prevcksum = 0xffff;
57e20fa0:	e59f3710 	ldr	r3, [pc, #1808]	; 57e216b8 <do_fat_read_at+0xb44>
57e20fa4:	e58d301c 	str	r3, [sp, #28]
			}

			dentptr = (dir_entry *) do_fat_read_at_block;
		}

		for (i = 0; i < DIRENTSPERBLOCK; i++) {
57e20fa8:	e28aa001 	add	sl, sl, #1
57e20fac:	e2855020 	add	r5, r5, #32
57e20fb0:	e28dcc0a 	add	ip, sp, #2560	; 0xa00
57e20fb4:	e1dc39b0 	ldrh	r3, [ip, #144]	; 0x90

__u8 do_fat_read_at_block[MAX_CLUSTSIZE]
	__aligned(ARCH_DMA_MINALIGN);

long
do_fat_read_at(const char *filename, unsigned long pos, void *buffer,
57e20fb8:	e2454020 	sub	r4, r5, #32
			}

			dentptr = (dir_entry *) do_fat_read_at_block;
		}

		for (i = 0; i < DIRENTSPERBLOCK; i++) {
57e20fbc:	e15a02a3 	cmp	sl, r3, lsr #5
57e20fc0:	3affff7a 	bcc	57e20db0 <do_fat_read_at+0x23c>
		 * root directory clusters when a cluster has been
		 * completely processed.
		 */
		++j;
		int rootdir_end = 0;
		if (mydata->fatsize == 32) {
57e20fc4:	e59d3a80 	ldr	r3, [sp, #2688]	; 0xa80
		/*
		 * On FAT32 we must fetch the FAT entries for the next
		 * root directory clusters when a cluster has been
		 * completely processed.
		 */
		++j;
57e20fc8:	e2866001 	add	r6, r6, #1
		int rootdir_end = 0;
		if (mydata->fatsize == 32) {
57e20fcc:	e3530020 	cmp	r3, #32
57e20fd0:	1a000013 	bne	57e21024 <do_fat_read_at+0x4b0>
			if (j == mydata->clust_size) {
57e20fd4:	e1dc39b2 	ldrh	r3, [ip, #146]	; 0x92
57e20fd8:	e1560003 	cmp	r6, r3
57e20fdc:	1affff63 	bne	57e20d70 <do_fat_read_at+0x1fc>
				int nxtsect = 0;
				int nxt_clust = 0;

				nxt_clust = get_fatent(mydata, root_cluster);
57e20fe0:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
57e20fe4:	e59d1018 	ldr	r1, [sp, #24]
57e20fe8:	e280000c 	add	r0, r0, #12
57e20fec:	ebfffca1 	bl	57e20278 <get_fatent>
				rootdir_end = CHECK_CLUST(nxt_clust, 32);
57e20ff0:	e59f36d4 	ldr	r3, [pc, #1748]	; 57e216cc <do_fat_read_at+0xb58>
57e20ff4:	e2402002 	sub	r2, r0, #2
		if (mydata->fatsize == 32) {
			if (j == mydata->clust_size) {
				int nxtsect = 0;
				int nxt_clust = 0;

				nxt_clust = get_fatent(mydata, root_cluster);
57e20ff8:	e58d0018 	str	r0, [sp, #24]
				rootdir_end = CHECK_CLUST(nxt_clust, 32);

				nxtsect = mydata->data_begin +
					(nxt_clust * mydata->clust_size);
57e20ffc:	e28d0c0a 	add	r0, sp, #2560	; 0xa00
			if (j == mydata->clust_size) {
				int nxtsect = 0;
				int nxt_clust = 0;

				nxt_clust = get_fatent(mydata, root_cluster);
				rootdir_end = CHECK_CLUST(nxt_clust, 32);
57e21000:	e1520003 	cmp	r2, r3
57e21004:	93a03000 	movls	r3, #0
57e21008:	83a03001 	movhi	r3, #1

				nxtsect = mydata->data_begin +
					(nxt_clust * mydata->clust_size);
57e2100c:	e1d0b9b2 	ldrh	fp, [r0, #146]	; 0x92
				int nxt_clust = 0;

				nxt_clust = get_fatent(mydata, root_cluster);
				rootdir_end = CHECK_CLUST(nxt_clust, 32);

				nxtsect = mydata->data_begin +
57e21010:	e59d2a94 	ldr	r2, [sp, #2708]	; 0xa94
57e21014:	e59d1018 	ldr	r1, [sp, #24]
					(nxt_clust * mydata->clust_size);

				root_cluster = nxt_clust;

				cursect = nxtsect;
				j = 0;
57e21018:	e3a06000 	mov	r6, #0
				int nxt_clust = 0;

				nxt_clust = get_fatent(mydata, root_cluster);
				rootdir_end = CHECK_CLUST(nxt_clust, 32);

				nxtsect = mydata->data_begin +
57e2101c:	e02b2b91 	mla	fp, r1, fp, r2
57e21020:	ea000008 	b	57e21048 <do_fat_read_at+0x4d4>
			}
		} else {
			if (j == PREFETCH_BLOCKS)
				j = 0;

			rootdir_end = (++cursect - mydata->rootdir_sect >=
57e21024:	e59d3a8c 	ldr	r3, [sp, #2700]	; 0xa8c
57e21028:	e28bb001 	add	fp, fp, #1
57e2102c:	e59d2020 	ldr	r2, [sp, #32]
				cursect = nxtsect;
				j = 0;
			}
		} else {
			if (j == PREFETCH_BLOCKS)
				j = 0;
57e21030:	e3560002 	cmp	r6, #2

			rootdir_end = (++cursect - mydata->rootdir_sect >=
57e21034:	e063300b 	rsb	r3, r3, fp
				cursect = nxtsect;
				j = 0;
			}
		} else {
			if (j == PREFETCH_BLOCKS)
				j = 0;
57e21038:	03a06000 	moveq	r6, #0

			rootdir_end = (++cursect - mydata->rootdir_sect >=
57e2103c:	e1530002 	cmp	r3, r2
57e21040:	33a03000 	movcc	r3, #0
57e21044:	23a03001 	movcs	r3, #1
				       rootdir_size);
		}

		/* If end of rootdir reached */
		if (rootdir_end) {
57e21048:	e3530000 	cmp	r3, #0
57e2104c:	0affff47 	beq	57e20d70 <do_fat_read_at+0x1fc>
			if (dols == LS_ROOT) {
57e21050:	e3570002 	cmp	r7, #2
57e21054:	1a00018b 	bne	57e21688 <do_fat_read_at+0xb14>
				printf("\n%d file(s), %d dir(s)\n\n",
57e21058:	e59d1010 	ldr	r1, [sp, #16]
57e2105c:	e59d2014 	ldr	r2, [sp, #20]
57e21060:	e59f0660 	ldr	r0, [pc, #1632]	; 57e216c8 <do_fat_read_at+0xb54>
57e21064:	ebffa0f8 	bl	57e0944c <printf>
57e21068:	ea000184 	b	57e21680 <do_fat_read_at+0xb0c>
		int startsect = mydata->data_begin
			+ START(dentptr) * mydata->clust_size;
		dir_entry dent;
		char *nextname = NULL;

		dent = *dentptr;
57e2106c:	e28dce93 	add	ip, sp, #2352	; 0x930
57e21070:	e28cc00c 	add	ip, ip, #12
57e21074:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
57e21078:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
57e2107c:	e894000f 	ldm	r4, {r0, r1, r2, r3}
57e21080:	e88c000f 	stm	ip, {r0, r1, r2, r3}
		dentptr = &dent;

		idx = dirdelim(subname);
57e21084:	e1a00005 	mov	r0, r5
57e21088:	ebfffc6d 	bl	57e20244 <dirdelim>

		if (idx >= 0) {
57e2108c:	e3500000 	cmp	r0, #0
57e21090:	e58d0028 	str	r0, [sp, #40]	; 0x28
57e21094:	ba000011 	blt	57e210e0 <do_fat_read_at+0x56c>
			subname[idx] = '\0';
57e21098:	e3a03000 	mov	r3, #0
			nextname = subname + idx + 1;
57e2109c:	e2802001 	add	r2, r0, #1
		dentptr = &dent;

		idx = dirdelim(subname);

		if (idx >= 0) {
			subname[idx] = '\0';
57e210a0:	e7c53000 	strb	r3, [r5, r0]
			nextname = subname + idx + 1;
57e210a4:	e0852002 	add	r2, r5, r2
			/* Handle multiple delimiters */
			while (ISDIRDELIM(*nextname))
57e210a8:	e5d23000 	ldrb	r3, [r2]
57e210ac:	e1a01002 	mov	r1, r2
57e210b0:	e353002f 	cmp	r3, #47	; 0x2f
57e210b4:	1353005c 	cmpne	r3, #92	; 0x5c
57e210b8:	e2822001 	add	r2, r2, #1
57e210bc:	0afffff9 	beq	57e210a8 <do_fat_read_at+0x534>
				nextname++;
			if (dols && *nextname == '\0')
57e210c0:	e3570000 	cmp	r7, #0
57e210c4:	e58d1020 	str	r1, [sp, #32]
57e210c8:	0a00000f 	beq	57e2110c <do_fat_read_at+0x598>
				firsttime = 0;
57e210cc:	e59dc010 	ldr	ip, [sp, #16]
57e210d0:	e3530000 	cmp	r3, #0
57e210d4:	03a0c000 	moveq	ip, #0
57e210d8:	e58dc010 	str	ip, [sp, #16]
57e210dc:	ea00000a 	b	57e2110c <do_fat_read_at+0x598>
		} else {
			if (dols && firsttime) {
57e210e0:	e59da010 	ldr	sl, [sp, #16]
57e210e4:	e3570000 	cmp	r7, #0
57e210e8:	03a0a000 	moveq	sl, #0
57e210ec:	120aa001 	andne	sl, sl, #1
57e210f0:	e35a0000 	cmp	sl, #0
57e210f4:	058d7014 	streq	r7, [sp, #20]
				firsttime = 0;
			} else {
				isdir = 0;
57e210f8:	058da020 	streq	sl, [sp, #32]
			while (ISDIRDELIM(*nextname))
				nextname++;
			if (dols && *nextname == '\0')
				firsttime = 0;
		} else {
			if (dols && firsttime) {
57e210fc:	0a000005 	beq	57e21118 <do_fat_read_at+0x5a4>

	while (isdir) {
		int startsect = mydata->data_begin
			+ START(dentptr) * mydata->clust_size;
		dir_entry dent;
		char *nextname = NULL;
57e21100:	e3a00000 	mov	r0, #0
57e21104:	e58d0010 	str	r0, [sp, #16]
				nextname++;
			if (dols && *nextname == '\0')
				firsttime = 0;
		} else {
			if (dols && firsttime) {
				firsttime = 0;
57e21108:	e58d0020 	str	r0, [sp, #32]
			} else {
				isdir = 0;
			}
		}

		if (get_dentfromdir(mydata, startsect, subname, dentptr,
57e2110c:	e3a01000 	mov	r1, #0
				firsttime = 0;
		} else {
			if (dols && firsttime) {
				firsttime = 0;
			} else {
				isdir = 0;
57e21110:	e3a0a001 	mov	sl, #1
			}
		}

		if (get_dentfromdir(mydata, startsect, subname, dentptr,
57e21114:	e58d1014 	str	r1, [sp, #20]
static dir_entry *get_dentfromdir(fsdata *mydata, int startsect,
				  char *filename, dir_entry *retdent,
				  int dols)
{
	__u16 prevcksum = 0xffff;
	__u32 curclust = START(retdent);
57e21118:	e59f35b0 	ldr	r3, [pc, #1456]	; 57e216d0 <do_fat_read_at+0xb5c>
57e2111c:	e28d2d2b 	add	r2, sp, #2752	; 0xac0
57e21120:	e2822008 	add	r2, r2, #8
57e21124:	e19230b3 	ldrh	r3, [r2, r3]
57e21128:	e59d2a80 	ldr	r2, [sp, #2688]	; 0xa80

static dir_entry *get_dentfromdir(fsdata *mydata, int startsect,
				  char *filename, dir_entry *retdent,
				  int dols)
{
	__u16 prevcksum = 0xffff;
57e2112c:	e59f0584 	ldr	r0, [pc, #1412]	; 57e216b8 <do_fat_read_at+0xb44>
	__u32 curclust = START(retdent);
57e21130:	e3520020 	cmp	r2, #32
57e21134:	028dcd2b 	addeq	ip, sp, #2752	; 0xac0
57e21138:	02422f66 	subeq	r2, r2, #408	; 0x198
57e2113c:	028cc008 	addeq	ip, ip, #8
57e21140:	019c60b2 	ldrheq	r6, [ip, r2]
57e21144:	13a06000 	movne	r6, #0
57e21148:	01a06806 	lsleq	r6, r6, #16
	int files = 0, dirs = 0;
57e2114c:	e3a09000 	mov	r9, #0
				dentptr++;
				continue;
			}

			if (strcmp(filename, s_name)
			    && strcmp(filename, l_name)) {
57e21150:	e58da01c 	str	sl, [sp, #28]
static dir_entry *get_dentfromdir(fsdata *mydata, int startsect,
				  char *filename, dir_entry *retdent,
				  int dols)
{
	__u16 prevcksum = 0xffff;
	__u32 curclust = START(retdent);
57e21154:	e0866003 	add	r6, r6, r3
	int files = 0, dirs = 0;
57e21158:	e58d9018 	str	r9, [sp, #24]

static dir_entry *get_dentfromdir(fsdata *mydata, int startsect,
				  char *filename, dir_entry *retdent,
				  int dols)
{
	__u16 prevcksum = 0xffff;
57e2115c:	e58d002c 	str	r0, [sp, #44]	; 0x2c
				dentptr++;
				continue;
			}

			if (strcmp(filename, s_name)
			    && strcmp(filename, l_name)) {
57e21160:	e1a0a007 	mov	sl, r7
		dir_entry *dentptr;

		int i;

		if (get_cluster(mydata, curclust, get_dentfromdir_block,
				mydata->clust_size * mydata->sect_size) != 0) {
57e21164:	e28d1c0a 	add	r1, sp, #2560	; 0xa00
57e21168:	e1d1c9b0 	ldrh	ip, [r1, #144]	; 0x90
57e2116c:	e1d139b2 	ldrh	r3, [r1, #146]	; 0x92
{
	char fnamecopy[2048];
	boot_sector bs;
	volume_info volinfo;
	fsdata datablock;
	fsdata *mydata = &datablock;
57e21170:	e28dbea7 	add	fp, sp, #2672	; 0xa70
57e21174:	e28bb00c 	add	fp, fp, #12
	while (1) {
		dir_entry *dentptr;

		int i;

		if (get_cluster(mydata, curclust, get_dentfromdir_block,
57e21178:	e1a0000b 	mov	r0, fp
57e2117c:	e1a01006 	mov	r1, r6
57e21180:	e59f254c 	ldr	r2, [pc, #1356]	; 57e216d4 <do_fat_read_at+0xb60>
57e21184:	e003039c 	mul	r3, ip, r3
57e21188:	ebfffd57 	bl	57e206ec <get_cluster>
57e2118c:	e2507000 	subs	r7, r0, #0
57e21190:	1a000095 	bne	57e213ec <do_fat_read_at+0x878>

__u8 do_fat_read_at_block[MAX_CLUSTSIZE]
	__aligned(ARCH_DMA_MINALIGN);

long
do_fat_read_at(const char *filename, unsigned long pos, void *buffer,
57e21194:	e59f453c 	ldr	r4, [pc, #1340]	; 57e216d8 <do_fat_read_at+0xb64>
57e21198:	ea00007a 	b	57e21388 <do_fat_read_at+0x814>
		dentptr = (dir_entry *)get_dentfromdir_block;

		for (i = 0; i < DIRENTSPERCLUST; i++) {
			char s_name[14], l_name[VFAT_MAXLEN_BYTES];

			l_name[0] = '\0';
57e2119c:	e3a02000 	mov	r2, #0
57e211a0:	e5cd283c 	strb	r2, [sp, #2108]	; 0x83c
			if (dentptr->name[0] == DELETED_FLAG) {
57e211a4:	e5543020 	ldrb	r3, [r4, #-32]
57e211a8:	e35300e5 	cmp	r3, #229	; 0xe5
57e211ac:	0a000073 	beq	57e21380 <do_fat_read_at+0x80c>
				dentptr++;
				continue;
			}
			if ((dentptr->attr & ATTR_VOLUME)) {
57e211b0:	e5542015 	ldrb	r2, [r4, #-21]
57e211b4:	e3120008 	tst	r2, #8
57e211b8:	0a000024 	beq	57e21250 <do_fat_read_at+0x6dc>
#ifdef CONFIG_SUPPORT_VFAT
				if ((dentptr->attr & ATTR_VFAT) == ATTR_VFAT &&
57e211bc:	e202200f 	and	r2, r2, #15
57e211c0:	e352000f 	cmp	r2, #15
57e211c4:	1a00006d 	bne	57e21380 <do_fat_read_at+0x80c>
57e211c8:	e3130040 	tst	r3, #64	; 0x40
57e211cc:	0a00006b 	beq	57e21380 <do_fat_read_at+0x80c>
				    (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
					prevcksum = ((dir_slot *)dentptr)->alias_checksum;
57e211d0:	e5543013 	ldrb	r3, [r4, #-19]
					get_vfatname(mydata, curclust,
57e211d4:	e28dce83 	add	ip, sp, #2096	; 0x830
57e211d8:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
			}
			if ((dentptr->attr & ATTR_VOLUME)) {
#ifdef CONFIG_SUPPORT_VFAT
				if ((dentptr->attr & ATTR_VFAT) == ATTR_VFAT &&
				    (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
					prevcksum = ((dir_slot *)dentptr)->alias_checksum;
57e211dc:	e58d302c 	str	r3, [sp, #44]	; 0x2c
					get_vfatname(mydata, curclust,
57e211e0:	e28cc00c 	add	ip, ip, #12
57e211e4:	e280000c 	add	r0, r0, #12
57e211e8:	e1a01006 	mov	r1, r6
57e211ec:	e59f24e0 	ldr	r2, [pc, #1248]	; 57e216d4 <do_fat_read_at+0xb60>
57e211f0:	e1a0300b 	mov	r3, fp
57e211f4:	e58dc000 	str	ip, [sp]
57e211f8:	ebfffd98 	bl	57e20860 <get_vfatname>
						     get_dentfromdir_block,
						     dentptr, l_name);
					if (dols) {
57e211fc:	e59d0014 	ldr	r0, [sp, #20]
57e21200:	e3500000 	cmp	r0, #0
57e21204:	0a000011 	beq	57e21250 <do_fat_read_at+0x6dc>
						int isdir;
						char dirc;
						int doit = 0;

						isdir = (dentptr->attr & ATTR_DIR);
57e21208:	e5543015 	ldrb	r3, [r4, #-21]

						if (isdir) {
57e2120c:	e3130010 	tst	r3, #16
								printf(" %8ld   %s%c\n",
									(long)FAT2CPU32(dentptr->size),
									l_name,
									dirc);
							} else {
								printf("            %s%c\n",
57e21210:	128d1e83 	addne	r1, sp, #2096	; 0x830
						int doit = 0;

						isdir = (dentptr->attr & ATTR_DIR);

						if (isdir) {
							dirs++;
57e21214:	12899001 	addne	r9, r9, #1
								printf(" %8ld   %s%c\n",
									(long)FAT2CPU32(dentptr->size),
									l_name,
									dirc);
							} else {
								printf("            %s%c\n",
57e21218:	159f04a0 	ldrne	r0, [pc, #1184]	; 57e216c0 <do_fat_read_at+0xb4c>
57e2121c:	1281100c 	addne	r1, r1, #12
57e21220:	1a00002e 	bne	57e212e0 <do_fat_read_at+0x76c>
							dirs++;
							dirc = '/';
							doit = 1;
						} else {
							dirc = ' ';
							if (l_name[0] != 0) {
57e21224:	e5dd383c 	ldrb	r3, [sp, #2108]	; 0x83c
57e21228:	e3530000 	cmp	r3, #0
57e2122c:	0a000053 	beq	57e21380 <do_fat_read_at+0x80c>
								files++;
57e21230:	e59d1018 	ldr	r1, [sp, #24]
								doit = 1;
							}
						}
						if (doit) {
							if (dirc == ' ') {
								printf(" %8ld   %s%c\n",
57e21234:	e28d2e83 	add	r2, sp, #2096	; 0x830
							dirc = '/';
							doit = 1;
						} else {
							dirc = ' ';
							if (l_name[0] != 0) {
								files++;
57e21238:	e2811001 	add	r1, r1, #1
57e2123c:	e58d1018 	str	r1, [sp, #24]
								doit = 1;
							}
						}
						if (doit) {
							if (dirc == ' ') {
								printf(" %8ld   %s%c\n",
57e21240:	e59f047c 	ldr	r0, [pc, #1148]	; 57e216c4 <do_fat_read_at+0xb50>
57e21244:	e5141004 	ldr	r1, [r4, #-4]
57e21248:	e282200c 	add	r2, r2, #12
57e2124c:	ea000030 	b	57e21314 <do_fat_read_at+0x7a0>
					/* Volume label or VFAT entry */
					dentptr++;
					continue;
				}
			}
			if (dentptr->name[0] == 0) {
57e21250:	e5543020 	ldrb	r3, [r4, #-32]
57e21254:	e3530000 	cmp	r3, #0
57e21258:	1a000009 	bne	57e21284 <do_fat_read_at+0x710>
				if (dols) {
57e2125c:	e59d2014 	ldr	r2, [sp, #20]
57e21260:	e1a0700a 	mov	r7, sl
57e21264:	e3520000 	cmp	r2, #0
57e21268:	e59da01c 	ldr	sl, [sp, #28]
57e2126c:	0a000060 	beq	57e213f4 <do_fat_read_at+0x880>
					printf("\n%d file(s), %d dir(s)\n\n",
57e21270:	e59d1018 	ldr	r1, [sp, #24]
57e21274:	e1a02009 	mov	r2, r9
57e21278:	e59f0448 	ldr	r0, [pc, #1096]	; 57e216c8 <do_fat_read_at+0xb54>
57e2127c:	ebffa072 	bl	57e0944c <printf>
57e21280:	ea00005b 	b	57e213f4 <do_fat_read_at+0x880>
				}
				debug("Dentname == NULL - %d\n", i);
				return NULL;
			}
#ifdef CONFIG_SUPPORT_VFAT
			__u8 csum = mkcksum(dentptr->name, dentptr->ext);
57e21284:	e1a0000b 	mov	r0, fp
57e21288:	e28b1008 	add	r1, fp, #8
57e2128c:	ebfffc89 	bl	57e204b8 <mkcksum>
			if (dols && csum == prevcksum) {
57e21290:	e59d3014 	ldr	r3, [sp, #20]
57e21294:	e3530000 	cmp	r3, #0
57e21298:	0a000002 	beq	57e212a8 <do_fat_read_at+0x734>
57e2129c:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
57e212a0:	e150000c 	cmp	r0, ip
57e212a4:	0a000033 	beq	57e21378 <do_fat_read_at+0x804>
				prevcksum = 0xffff;
				dentptr++;
				continue;
			}
#endif
			get_name(dentptr, s_name);
57e212a8:	e28d1eab 	add	r1, sp, #2736	; 0xab0
57e212ac:	e1a0000b 	mov	r0, fp
57e212b0:	e2811008 	add	r1, r1, #8
57e212b4:	ebfffc94 	bl	57e2050c <get_name>
			if (dols) {
57e212b8:	e59d0014 	ldr	r0, [sp, #20]
57e212bc:	e3500000 	cmp	r0, #0
57e212c0:	0a000016 	beq	57e21320 <do_fat_read_at+0x7ac>
				int isdir = (dentptr->attr & ATTR_DIR);
57e212c4:	e5543015 	ldrb	r3, [r4, #-21]
				char dirc;
				int doit = 0;

				if (isdir) {
57e212c8:	e3130010 	tst	r3, #16
57e212cc:	0a000006 	beq	57e212ec <do_fat_read_at+0x778>
					if (dirc == ' ') {
						printf(" %8ld   %s%c\n",
							(long)FAT2CPU32(dentptr->size),
							s_name, dirc);
					} else {
						printf("            %s%c\n",
57e212d0:	e28d1eab 	add	r1, sp, #2736	; 0xab0
57e212d4:	e59f03e4 	ldr	r0, [pc, #996]	; 57e216c0 <do_fat_read_at+0xb4c>
				int isdir = (dentptr->attr & ATTR_DIR);
				char dirc;
				int doit = 0;

				if (isdir) {
					dirs++;
57e212d8:	e2899001 	add	r9, r9, #1
					if (dirc == ' ') {
						printf(" %8ld   %s%c\n",
							(long)FAT2CPU32(dentptr->size),
							s_name, dirc);
					} else {
						printf("            %s%c\n",
57e212dc:	e2811008 	add	r1, r1, #8
57e212e0:	e3a0202f 	mov	r2, #47	; 0x2f
57e212e4:	ebffa058 	bl	57e0944c <printf>
57e212e8:	ea000024 	b	57e21380 <do_fat_read_at+0x80c>
					dirs++;
					dirc = '/';
					doit = 1;
				} else {
					dirc = ' ';
					if (s_name[0] != 0) {
57e212ec:	e5dd3ab8 	ldrb	r3, [sp, #2744]	; 0xab8
57e212f0:	e3530000 	cmp	r3, #0
57e212f4:	0a000021 	beq	57e21380 <do_fat_read_at+0x80c>
						files++;
57e212f8:	e59d1018 	ldr	r1, [sp, #24]
					}
				}

				if (doit) {
					if (dirc == ' ') {
						printf(" %8ld   %s%c\n",
57e212fc:	e28d2eab 	add	r2, sp, #2736	; 0xab0
					dirc = '/';
					doit = 1;
				} else {
					dirc = ' ';
					if (s_name[0] != 0) {
						files++;
57e21300:	e2811001 	add	r1, r1, #1
57e21304:	e58d1018 	str	r1, [sp, #24]
					}
				}

				if (doit) {
					if (dirc == ' ') {
						printf(" %8ld   %s%c\n",
57e21308:	e59f03b4 	ldr	r0, [pc, #948]	; 57e216c4 <do_fat_read_at+0xb50>
57e2130c:	e5141004 	ldr	r1, [r4, #-4]
57e21310:	e2822008 	add	r2, r2, #8
57e21314:	e3a03020 	mov	r3, #32
57e21318:	ebffa04b 	bl	57e0944c <printf>
57e2131c:	ea000017 	b	57e21380 <do_fat_read_at+0x80c>

				dentptr++;
				continue;
			}

			if (strcmp(filename, s_name)
57e21320:	e28d1eab 	add	r1, sp, #2736	; 0xab0
57e21324:	e1a00005 	mov	r0, r5
57e21328:	e2811008 	add	r1, r1, #8
57e2132c:	eb000b1c 	bl	57e23fa4 <strcmp>
57e21330:	e3500000 	cmp	r0, #0
57e21334:	0a000005 	beq	57e21350 <do_fat_read_at+0x7dc>
			    && strcmp(filename, l_name)) {
57e21338:	e28d1e83 	add	r1, sp, #2096	; 0x830
57e2133c:	e1a00005 	mov	r0, r5
57e21340:	e281100c 	add	r1, r1, #12
57e21344:	eb000b16 	bl	57e23fa4 <strcmp>
57e21348:	e3500000 	cmp	r0, #0
57e2134c:	1a00000b 	bne	57e21380 <do_fat_read_at+0x80c>
57e21350:	e1a0700a 	mov	r7, sl
				debug("Mismatch: |%s|%s|\n", s_name, l_name);
				dentptr++;
				continue;
			}

			memcpy(retdent, dentptr, sizeof(dir_entry));
57e21354:	e28d0e93 	add	r0, sp, #2352	; 0x930
57e21358:	e59da01c 	ldr	sl, [sp, #28]
57e2135c:	e280000c 	add	r0, r0, #12
57e21360:	e1a0100b 	mov	r1, fp
57e21364:	e3a02020 	mov	r2, #32
57e21368:	eb000be7 	bl	57e2430c <memcpy>
			if (dols && !isdir)
				ret = 0;
			goto exit;
		}

		if (isdir && !(dentptr->attr & ATTR_DIR))
57e2136c:	e35a0000 	cmp	sl, #0
57e21370:	1a000027 	bne	57e21414 <do_fat_read_at+0x8a0>
57e21374:	ea000029 	b	57e21420 <do_fat_read_at+0x8ac>
				return NULL;
			}
#ifdef CONFIG_SUPPORT_VFAT
			__u8 csum = mkcksum(dentptr->name, dentptr->ext);
			if (dols && csum == prevcksum) {
				prevcksum = 0xffff;
57e21378:	e59f2338 	ldr	r2, [pc, #824]	; 57e216b8 <do_fat_read_at+0xb44>
57e2137c:	e58d202c 	str	r2, [sp, #44]	; 0x2c
			return NULL;
		}

		dentptr = (dir_entry *)get_dentfromdir_block;

		for (i = 0; i < DIRENTSPERCLUST; i++) {
57e21380:	e2877001 	add	r7, r7, #1
57e21384:	e2844020 	add	r4, r4, #32
57e21388:	e28dcc0a 	add	ip, sp, #2560	; 0xa00
57e2138c:	e1dc39b0 	ldrh	r3, [ip, #144]	; 0x90
57e21390:	e1dc29b2 	ldrh	r2, [ip, #146]	; 0x92

__u8 do_fat_read_at_block[MAX_CLUSTSIZE]
	__aligned(ARCH_DMA_MINALIGN);

long
do_fat_read_at(const char *filename, unsigned long pos, void *buffer,
57e21394:	e244b020 	sub	fp, r4, #32
			return NULL;
		}

		dentptr = (dir_entry *)get_dentfromdir_block;

		for (i = 0; i < DIRENTSPERCLUST; i++) {
57e21398:	e0030392 	mul	r3, r2, r3
57e2139c:	e15702a3 	cmp	r7, r3, lsr #5
57e213a0:	3affff7d 	bcc	57e2119c <do_fat_read_at+0x628>
			      (dentptr->attr & ATTR_DIR) ? "(DIR)" : "");

			return retdent;
		}

		curclust = get_fatent(mydata, curclust);
57e213a4:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
57e213a8:	e1a01006 	mov	r1, r6
57e213ac:	e280000c 	add	r0, r0, #12
57e213b0:	ebfffbb0 	bl	57e20278 <get_fatent>
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e213b4:	e3500001 	cmp	r0, #1
			      (dentptr->attr & ATTR_DIR) ? "(DIR)" : "");

			return retdent;
		}

		curclust = get_fatent(mydata, curclust);
57e213b8:	e1a06000 	mov	r6, r0
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e213bc:	9a000005 	bls	57e213d8 <do_fat_read_at+0x864>
57e213c0:	e59d3a80 	ldr	r3, [sp, #2688]	; 0xa80
57e213c4:	e3530020 	cmp	r3, #32
57e213c8:	e59f330c 	ldr	r3, [pc, #780]	; 57e216dc <do_fat_read_at+0xb68>
57e213cc:	03e032ff 	mvneq	r3, #-268435441	; 0xf000000f
57e213d0:	e1500003 	cmp	r0, r3
57e213d4:	3affff62 	bcc	57e21164 <do_fat_read_at+0x5f0>
			debug("curclust: 0x%x\n", curclust);
			printf("Invalid FAT entry\n");
57e213d8:	e59f0300 	ldr	r0, [pc, #768]	; 57e216e0 <do_fat_read_at+0xb6c>
57e213dc:	e1a0700a 	mov	r7, sl
57e213e0:	e59da01c 	ldr	sl, [sp, #28]
57e213e4:	ebffa018 	bl	57e0944c <printf>
57e213e8:	ea000001 	b	57e213f4 <do_fat_read_at+0x880>
57e213ec:	e1a0700a 	mov	r7, sl
57e213f0:	e59da01c 	ldr	sl, [sp, #28]
			}
		}

		if (get_dentfromdir(mydata, startsect, subname, dentptr,
				     isdir ? 0 : dols) == NULL) {
			if (dols && !isdir)
57e213f4:	e27aa001 	rsbs	sl, sl, #1
57e213f8:	33a0a000 	movcc	sl, #0
57e213fc:	e3570000 	cmp	r7, #0
57e21400:	03a0a000 	moveq	sl, #0
	__u16 prevcksum = 0xffff;
	char *subname = "";
	__u32 cursect;
	int idx, isdir = 0;
	int files = 0, dirs = 0;
	long ret = -1;
57e21404:	e35a0000 	cmp	sl, #0
57e21408:	13a04000 	movne	r4, #0
57e2140c:	03e04000 	mvneq	r4, #0
57e21410:	ea00009d 	b	57e2168c <do_fat_read_at+0xb18>
			if (dols && !isdir)
				ret = 0;
			goto exit;
		}

		if (isdir && !(dentptr->attr & ATTR_DIR))
57e21414:	e5dd3947 	ldrb	r3, [sp, #2375]	; 0x947
57e21418:	e3130010 	tst	r3, #16
57e2141c:	0a000099 	beq	57e21688 <do_fat_read_at+0xb14>
			goto exit;

		if (idx >= 0)
57e21420:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
57e21424:	e59d0020 	ldr	r0, [sp, #32]
57e21428:	e3510000 	cmp	r1, #0
			+ START(dentptr) * mydata->clust_size;
		dir_entry dent;
		char *nextname = NULL;

		dent = *dentptr;
		dentptr = &dent;
57e2142c:	e28d4e93 	add	r4, sp, #2352	; 0x930
		}

		if (isdir && !(dentptr->attr & ATTR_DIR))
			goto exit;

		if (idx >= 0)
57e21430:	a1a05000 	movge	r5, r0
			+ START(dentptr) * mydata->clust_size;
		dir_entry dent;
		char *nextname = NULL;

		dent = *dentptr;
		dentptr = &dent;
57e21434:	e284400c 	add	r4, r4, #12
	}
rootdir_done:

	firsttime = 1;

	while (isdir) {
57e21438:	e35a0000 	cmp	sl, #0
57e2143c:	1affff0a 	bne	57e2106c <do_fat_read_at+0x4f8>
get_contents(fsdata *mydata, dir_entry *dentptr, unsigned long pos,
	     __u8 *buffer, unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * mydata->sect_size;
	__u32 curclust = START(dentptr);
57e21440:	e59d1a80 	ldr	r1, [sp, #2688]	; 0xa80

static long
get_contents(fsdata *mydata, dir_entry *dentptr, unsigned long pos,
	     __u8 *buffer, unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
57e21444:	e594501c 	ldr	r5, [r4, #28]
	unsigned int bytesperclust = mydata->clust_size * mydata->sect_size;
	__u32 curclust = START(dentptr);
57e21448:	e3510020 	cmp	r1, #32
57e2144c:	01d4a1b4 	ldrheq	sl, [r4, #20]
	__u32 endclust, newclust;
	unsigned long actsize;

	debug("Filesize: %ld bytes\n", filesize);

	if (pos >= filesize) {
57e21450:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
static long
get_contents(fsdata *mydata, dir_entry *dentptr, unsigned long pos,
	     __u8 *buffer, unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * mydata->sect_size;
57e21454:	e28d2c0a 	add	r2, sp, #2560	; 0xa00
	__u32 curclust = START(dentptr);
57e21458:	01a0a80a 	lsleq	sl, sl, #16
	__u32 endclust, newclust;
	unsigned long actsize;

	debug("Filesize: %ld bytes\n", filesize);

	if (pos >= filesize) {
57e2145c:	e15c0005 	cmp	ip, r5
static long
get_contents(fsdata *mydata, dir_entry *dentptr, unsigned long pos,
	     __u8 *buffer, unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * mydata->sect_size;
57e21460:	e1d279b2 	ldrh	r7, [r2, #146]	; 0x92
	__u32 curclust = START(dentptr);
57e21464:	e1d431ba 	ldrh	r3, [r4, #26]
static long
get_contents(fsdata *mydata, dir_entry *dentptr, unsigned long pos,
	     __u8 *buffer, unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * mydata->sect_size;
57e21468:	e1d229b0 	ldrh	r2, [r2, #144]	; 0x90
	__u32 endclust, newclust;
	unsigned long actsize;

	debug("Filesize: %ld bytes\n", filesize);

	if (pos >= filesize) {
57e2146c:	2a000083 	bcs	57e21680 <do_fat_read_at+0xb0c>
		debug("Read position past EOF: %lu\n", pos);
		return gotsize;
	}

	if (maxsize > 0 && filesize > pos + maxsize)
57e21470:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
57e21474:	e3500000 	cmp	r0, #0
57e21478:	0a000002 	beq	57e21488 <do_fat_read_at+0x914>
57e2147c:	e080100c 	add	r1, r0, ip
57e21480:	e1550001 	cmp	r5, r1
57e21484:	21a05001 	movcs	r5, r1
static long
get_contents(fsdata *mydata, dir_entry *dentptr, unsigned long pos,
	     __u8 *buffer, unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
	unsigned int bytesperclust = mydata->clust_size * mydata->sect_size;
57e21488:	e0070792 	mul	r7, r2, r7
	__u32 curclust = START(dentptr);
57e2148c:	e08aa003 	add	sl, sl, r3
{
	char fnamecopy[2048];
	boot_sector bs;
	volume_info volinfo;
	fsdata datablock;
	fsdata *mydata = &datablock;
57e21490:	e28d9ea7 	add	r9, sp, #2672	; 0xa70
	if (maxsize > 0 && filesize > pos + maxsize)
		filesize = pos + maxsize;

	debug("%ld bytes\n", filesize);

	actsize = bytesperclust;
57e21494:	e1a06007 	mov	r6, r7
{
	char fnamecopy[2048];
	boot_sector bs;
	volume_info volinfo;
	fsdata datablock;
	fsdata *mydata = &datablock;
57e21498:	e289900c 	add	r9, r9, #12
	actsize = bytesperclust;

	/* go to cluster at pos */
	while (actsize <= pos) {
		curclust = get_fatent(mydata, curclust);
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e2149c:	e59f4238 	ldr	r4, [pc, #568]	; 57e216dc <do_fat_read_at+0xb68>
57e214a0:	e1a0100a 	mov	r1, sl
57e214a4:	ea00000b 	b	57e214d8 <do_fat_read_at+0x964>

	actsize = bytesperclust;

	/* go to cluster at pos */
	while (actsize <= pos) {
		curclust = get_fatent(mydata, curclust);
57e214a8:	e1a00009 	mov	r0, r9
57e214ac:	ebfffb71 	bl	57e20278 <get_fatent>
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e214b0:	e3500001 	cmp	r0, #1

	actsize = bytesperclust;

	/* go to cluster at pos */
	while (actsize <= pos) {
		curclust = get_fatent(mydata, curclust);
57e214b4:	e1a01000 	mov	r1, r0
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e214b8:	9a000070 	bls	57e21680 <do_fat_read_at+0xb0c>
57e214bc:	e59d3a80 	ldr	r3, [sp, #2688]	; 0xa80
57e214c0:	e3530020 	cmp	r3, #32
57e214c4:	03e032ff 	mvneq	r3, #-268435441	; 0xf000000f
57e214c8:	11a03004 	movne	r3, r4
57e214cc:	e1500003 	cmp	r0, r3
57e214d0:	2a00006a 	bcs	57e21680 <do_fat_read_at+0xb0c>
			debug("curclust: 0x%x\n", curclust);
			debug("Invalid FAT entry\n");
			return gotsize;
		}
		actsize += bytesperclust;
57e214d4:	e0866007 	add	r6, r6, r7
	debug("%ld bytes\n", filesize);

	actsize = bytesperclust;

	/* go to cluster at pos */
	while (actsize <= pos) {
57e214d8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
57e214dc:	e1560002 	cmp	r6, r2
57e214e0:	9afffff0 	bls	57e214a8 <do_fat_read_at+0x934>
		}
		actsize += bytesperclust;
	}

	/* actsize > pos */
	actsize -= bytesperclust;
57e214e4:	e0676006 	rsb	r6, r7, r6
	filesize -= actsize;
57e214e8:	e0665005 	rsb	r5, r6, r5
	pos -= actsize;

	/* align to beginning of next cluster if any */
	if (pos) {
57e214ec:	e0526006 	subs	r6, r2, r6
57e214f0:	e1a0a001 	mov	sl, r1

		if (idx >= 0)
			subname = nextname;
	}

	ret = get_contents(mydata, dentptr, pos, buffer, maxsize);
57e214f4:	e59d9030 	ldr	r9, [sp, #48]	; 0x30

static long
get_contents(fsdata *mydata, dir_entry *dentptr, unsigned long pos,
	     __u8 *buffer, unsigned long maxsize)
{
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
57e214f8:	01a04006 	moveq	r4, r6
	actsize -= bytesperclust;
	filesize -= actsize;
	pos -= actsize;

	/* align to beginning of next cluster if any */
	if (pos) {
57e214fc:	0a000020 	beq	57e21584 <do_fat_read_at+0xa10>
		actsize = min(filesize, bytesperclust);
		if (get_cluster(mydata, curclust, get_contents_vfatname_block,
57e21500:	e59fb1dc 	ldr	fp, [pc, #476]	; 57e216e4 <do_fat_read_at+0xb70>
	filesize -= actsize;
	pos -= actsize;

	/* align to beginning of next cluster if any */
	if (pos) {
		actsize = min(filesize, bytesperclust);
57e21504:	e1550007 	cmp	r5, r7
57e21508:	31a04005 	movcc	r4, r5
57e2150c:	21a04007 	movcs	r4, r7
		if (get_cluster(mydata, curclust, get_contents_vfatname_block,
57e21510:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
57e21514:	e280000c 	add	r0, r0, #12
57e21518:	e1a0200b 	mov	r2, fp
57e2151c:	e1a03004 	mov	r3, r4
57e21520:	ebfffc71 	bl	57e206ec <get_cluster>
57e21524:	e3500000 	cmp	r0, #0
57e21528:	1a00003d 	bne	57e21624 <do_fat_read_at+0xab0>
				(int)actsize) != 0) {
			printf("Error reading cluster\n");
			return -1;
		}
		filesize -= actsize;
57e2152c:	e0645005 	rsb	r5, r4, r5
		actsize -= pos;
57e21530:	e0664004 	rsb	r4, r6, r4
		memcpy(buffer, get_contents_vfatname_block + pos, actsize);
57e21534:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
57e21538:	e08b1006 	add	r1, fp, r6
57e2153c:	e1a02004 	mov	r2, r4
57e21540:	eb000b71 	bl	57e2430c <memcpy>
		gotsize += actsize;
		if (!filesize)
57e21544:	e3550000 	cmp	r5, #0
57e21548:	0a00004f 	beq	57e2168c <do_fat_read_at+0xb18>
			return gotsize;
		buffer += actsize;

		curclust = get_fatent(mydata, curclust);
57e2154c:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
57e21550:	e1a0100a 	mov	r1, sl
57e21554:	e280000c 	add	r0, r0, #12
57e21558:	ebfffb46 	bl	57e20278 <get_fatent>
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e2155c:	e3500001 	cmp	r0, #1
		gotsize += actsize;
		if (!filesize)
			return gotsize;
		buffer += actsize;

		curclust = get_fatent(mydata, curclust);
57e21560:	e1a0a000 	mov	sl, r0
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e21564:	9a000048 	bls	57e2168c <do_fat_read_at+0xb18>
57e21568:	e59d3a80 	ldr	r3, [sp, #2688]	; 0xa80
57e2156c:	e3530020 	cmp	r3, #32
57e21570:	e59f3164 	ldr	r3, [pc, #356]	; 57e216dc <do_fat_read_at+0xb68>
57e21574:	03e032ff 	mvneq	r3, #-268435441	; 0xf000000f
57e21578:	e1500003 	cmp	r0, r3
		actsize -= pos;
		memcpy(buffer, get_contents_vfatname_block + pos, actsize);
		gotsize += actsize;
		if (!filesize)
			return gotsize;
		buffer += actsize;
57e2157c:	30899004 	addcc	r9, r9, r4

		curclust = get_fatent(mydata, curclust);
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e21580:	2a000041 	bcs	57e2168c <do_fat_read_at+0xb18>
			debug("Invalid FAT entry\n");
			return gotsize;
		}
	}

	actsize = bytesperclust;
57e21584:	e1a06007 	mov	r6, r7
57e21588:	e1a0b00a 	mov	fp, sl
57e2158c:	ea000010 	b	57e215d4 <do_fat_read_at+0xa60>
	endclust = curclust;

	do {
		/* search for consecutive clusters */
		while (actsize < filesize) {
			newclust = get_fatent(mydata, endclust);
57e21590:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
57e21594:	e280000c 	add	r0, r0, #12
57e21598:	e1a0100a 	mov	r1, sl
57e2159c:	ebfffb35 	bl	57e20278 <get_fatent>
			if ((newclust - 1) != endclust)
57e215a0:	e2403001 	sub	r3, r0, #1
57e215a4:	e153000a 	cmp	r3, sl
57e215a8:	1a000015 	bne	57e21604 <do_fat_read_at+0xa90>
				goto getit;
			if (CHECK_CLUST(newclust, mydata->fatsize)) {
57e215ac:	e3500001 	cmp	r0, #1
57e215b0:	9a000035 	bls	57e2168c <do_fat_read_at+0xb18>
57e215b4:	e59d3a80 	ldr	r3, [sp, #2688]	; 0xa80
57e215b8:	e3530020 	cmp	r3, #32
57e215bc:	e59f3118 	ldr	r3, [pc, #280]	; 57e216dc <do_fat_read_at+0xb68>
57e215c0:	03e032ff 	mvneq	r3, #-268435441	; 0xf000000f
57e215c4:	e1500003 	cmp	r0, r3
57e215c8:	2a00002f 	bcs	57e2168c <do_fat_read_at+0xb18>
				debug("curclust: 0x%x\n", newclust);
				debug("Invalid FAT entry\n");
				return gotsize;
			}
			endclust = newclust;
			actsize += bytesperclust;
57e215cc:	e0866007 	add	r6, r6, r7
			printf("Error reading cluster\n");
			return -1;
		}
		gotsize += (int)actsize;
		filesize -= actsize;
		buffer += actsize;
57e215d0:	e1a0a000 	mov	sl, r0
	actsize = bytesperclust;
	endclust = curclust;

	do {
		/* search for consecutive clusters */
		while (actsize < filesize) {
57e215d4:	e1560005 	cmp	r6, r5
57e215d8:	3affffec 	bcc	57e21590 <do_fat_read_at+0xa1c>
			actsize += bytesperclust;
		}

		/* get remaining bytes */
		actsize = filesize;
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
57e215dc:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
57e215e0:	e280000c 	add	r0, r0, #12
57e215e4:	e1a0100b 	mov	r1, fp
57e215e8:	e1a02009 	mov	r2, r9
57e215ec:	e1a03005 	mov	r3, r5
57e215f0:	ebfffc3d 	bl	57e206ec <get_cluster>
57e215f4:	e3500000 	cmp	r0, #0
			printf("Error reading cluster\n");
			return -1;
		}
		gotsize += actsize;
57e215f8:	00854004 	addeq	r4, r5, r4
			actsize += bytesperclust;
		}

		/* get remaining bytes */
		actsize = filesize;
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
57e215fc:	0a000022 	beq	57e2168c <do_fat_read_at+0xb18>
57e21600:	ea000007 	b	57e21624 <do_fat_read_at+0xab0>
			return -1;
		}
		gotsize += actsize;
		return gotsize;
getit:
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
57e21604:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
57e21608:	e280000c 	add	r0, r0, #12
57e2160c:	e1a0100b 	mov	r1, fp
57e21610:	e1a02009 	mov	r2, r9
57e21614:	e1a03006 	mov	r3, r6
57e21618:	ebfffc33 	bl	57e206ec <get_cluster>
57e2161c:	e3500000 	cmp	r0, #0
57e21620:	0a000002 	beq	57e21630 <do_fat_read_at+0xabc>
			printf("Error reading cluster\n");
57e21624:	e59f00bc 	ldr	r0, [pc, #188]	; 57e216e8 <do_fat_read_at+0xb74>
57e21628:	ebff9f87 	bl	57e0944c <printf>
57e2162c:	ea000015 	b	57e21688 <do_fat_read_at+0xb14>
		}
		gotsize += (int)actsize;
		filesize -= actsize;
		buffer += actsize;

		curclust = get_fatent(mydata, endclust);
57e21630:	e28d0ea7 	add	r0, sp, #2672	; 0xa70
57e21634:	e280000c 	add	r0, r0, #12
57e21638:	e1a0100a 	mov	r1, sl
57e2163c:	ebfffb0d 	bl	57e20278 <get_fatent>
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e21640:	e3500001 	cmp	r0, #1
getit:
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
			printf("Error reading cluster\n");
			return -1;
		}
		gotsize += (int)actsize;
57e21644:	e0844006 	add	r4, r4, r6
		filesize -= actsize;
		buffer += actsize;

		curclust = get_fatent(mydata, endclust);
57e21648:	e1a0b000 	mov	fp, r0
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
57e2164c:	9a000008 	bls	57e21674 <do_fat_read_at+0xb00>
57e21650:	e59d3a80 	ldr	r3, [sp, #2688]	; 0xa80
57e21654:	e3530020 	cmp	r3, #32
57e21658:	e59f307c 	ldr	r3, [pc, #124]	; 57e216dc <do_fat_read_at+0xb68>
57e2165c:	03e032ff 	mvneq	r3, #-268435441	; 0xf000000f
57e21660:	e1500003 	cmp	r0, r3
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
			printf("Error reading cluster\n");
			return -1;
		}
		gotsize += (int)actsize;
		filesize -= actsize;
57e21664:	30665005 	rsbcc	r5, r6, r5
		buffer += actsize;
57e21668:	30899006 	addcc	r9, r9, r6
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
			debug("curclust: 0x%x\n", curclust);
			printf("Invalid FAT entry\n");
			return gotsize;
		}
		actsize = bytesperclust;
57e2166c:	31a06007 	movcc	r6, r7
57e21670:	3affffd6 	bcc	57e215d0 <do_fat_read_at+0xa5c>
		buffer += actsize;

		curclust = get_fatent(mydata, endclust);
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
			debug("curclust: 0x%x\n", curclust);
			printf("Invalid FAT entry\n");
57e21674:	e59f0064 	ldr	r0, [pc, #100]	; 57e216e0 <do_fat_read_at+0xb6c>
57e21678:	ebff9f73 	bl	57e0944c <printf>
57e2167c:	ea000002 	b	57e2168c <do_fat_read_at+0xb18>
	while (actsize <= pos) {
		curclust = get_fatent(mydata, curclust);
		if (CHECK_CLUST(curclust, mydata->fatsize)) {
			debug("curclust: 0x%x\n", curclust);
			debug("Invalid FAT entry\n");
			return gotsize;
57e21680:	e3a04000 	mov	r4, #0
57e21684:	ea000000 	b	57e2168c <do_fat_read_at+0xb18>
	__u16 prevcksum = 0xffff;
	char *subname = "";
	__u32 cursect;
	int idx, isdir = 0;
	int files = 0, dirs = 0;
	long ret = -1;
57e21688:	e3e04000 	mvn	r4, #0

	ret = get_contents(mydata, dentptr, pos, buffer, maxsize);
	debug("Size: %d, got: %ld\n", FAT2CPU32(dentptr->size), ret);

exit:
	free(mydata->fatbuf);
57e2168c:	e59d0a7c 	ldr	r0, [sp, #2684]	; 0xa7c
57e21690:	ebffa0c1 	bl	57e0999c <free>
	return ret;
57e21694:	ea000000 	b	57e2169c <do_fat_read_at+0xb28>
	int rootdir_size = 0;
	int j;

	if (read_bootsectandvi(&bs, &volinfo, &mydata->fatsize)) {
		debug("Error: reading boot sector\n");
		return -1;
57e21698:	e3e04000 	mvn	r4, #0
	debug("Size: %d, got: %ld\n", FAT2CPU32(dentptr->size), ret);

exit:
	free(mydata->fatbuf);
	return ret;
}
57e2169c:	e1a00004 	mov	r0, r4
57e216a0:	e28ddfb2 	add	sp, sp, #712	; 0x2c8
57e216a4:	e28ddb02 	add	sp, sp, #2048	; 0x800
57e216a8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e216ac:	57e48fc0 	.word	0x57e48fc0
57e216b0:	57e351f7 	.word	0x57e351f7
57e216b4:	57e302de 	.word	0x57e302de
57e216b8:	0000ffff 	.word	0x0000ffff
57e216bc:	57e59040 	.word	0x57e59040
57e216c0:	57e3522a 	.word	0x57e3522a
57e216c4:	57e3523c 	.word	0x57e3523c
57e216c8:	57e3524a 	.word	0x57e3524a
57e216cc:	0fffffed 	.word	0x0fffffed
57e216d0:	fffffe8e 	.word	0xfffffe8e
57e216d4:	57e69040 	.word	0x57e69040
57e216d8:	57e69060 	.word	0x57e69060
57e216dc:	0000fff0 	.word	0x0000fff0
57e216e0:	57e351b6 	.word	0x57e351b6
57e216e4:	57e49040 	.word	0x57e49040
57e216e8:	57e35263 	.word	0x57e35263

57e216ec <do_fat_read>:

long
do_fat_read(const char *filename, void *buffer, unsigned long maxsize, int dols)
{
57e216ec:	e92d4007 	push	{r0, r1, r2, lr}
57e216f0:	e1a0c002 	mov	ip, r2
57e216f4:	e1a0e001 	mov	lr, r1
	return do_fat_read_at(filename, 0, buffer, maxsize, dols);
57e216f8:	e58d3000 	str	r3, [sp]
57e216fc:	e3a01000 	mov	r1, #0
57e21700:	e1a0200e 	mov	r2, lr
57e21704:	e1a0300c 	mov	r3, ip
57e21708:	ebfffd19 	bl	57e20b74 <do_fat_read_at>
}
57e2170c:	e8bd800e 	pop	{r1, r2, r3, pc}

57e21710 <file_fat_detectfs>:

int file_fat_detectfs(void)
{
57e21710:	e92d4070 	push	{r4, r5, r6, lr}
	boot_sector bs;
	volume_info volinfo;
	int fatsize;
	char vol_label[12];

	if (cur_dev == NULL) {
57e21714:	e59f4110 	ldr	r4, [pc, #272]	; 57e2182c <file_fat_detectfs+0x11c>
{
	return do_fat_read_at(filename, 0, buffer, maxsize, dols);
}

int file_fat_detectfs(void)
{
57e21718:	e24dd070 	sub	sp, sp, #112	; 0x70
	boot_sector bs;
	volume_info volinfo;
	int fatsize;
	char vol_label[12];

	if (cur_dev == NULL) {
57e2171c:	e5943000 	ldr	r3, [r4]
57e21720:	e3530000 	cmp	r3, #0
		printf("No current device\n");
57e21724:	059f0104 	ldreq	r0, [pc, #260]	; 57e21830 <file_fat_detectfs+0x120>
	boot_sector bs;
	volume_info volinfo;
	int fatsize;
	char vol_label[12];

	if (cur_dev == NULL) {
57e21728:	0a00002e 	beq	57e217e8 <file_fat_detectfs+0xd8>
#if defined(CONFIG_CMD_IDE) || \
    defined(CONFIG_CMD_SATA) || \
    defined(CONFIG_CMD_SCSI) || \
    defined(CONFIG_CMD_USB) || \
    defined(CONFIG_MMC)
	printf("Interface:  ");
57e2172c:	e59f0100 	ldr	r0, [pc, #256]	; 57e21834 <file_fat_detectfs+0x124>
57e21730:	ebff9f45 	bl	57e0944c <printf>
	switch (cur_dev->if_type) {
57e21734:	e5943000 	ldr	r3, [r4]
57e21738:	e5933000 	ldr	r3, [r3]
57e2173c:	e2433001 	sub	r3, r3, #1
57e21740:	e3530007 	cmp	r3, #7
57e21744:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e21748:	ea000015 	b	57e217a4 <file_fat_detectfs+0x94>
57e2174c:	57e2176c 	.word	0x57e2176c
57e21750:	57e2177c 	.word	0x57e2177c
57e21754:	57e21784 	.word	0x57e21784
57e21758:	57e2178c 	.word	0x57e2178c
57e2175c:	57e21794 	.word	0x57e21794
57e21760:	57e2179c 	.word	0x57e2179c
57e21764:	57e217a4 	.word	0x57e217a4
57e21768:	57e21774 	.word	0x57e21774
	case IF_TYPE_IDE:
		printf("IDE");
57e2176c:	e59f00c4 	ldr	r0, [pc, #196]	; 57e21838 <file_fat_detectfs+0x128>
57e21770:	ea00000c 	b	57e217a8 <file_fat_detectfs+0x98>
		break;
	case IF_TYPE_SATA:
		printf("SATA");
57e21774:	e59f00c0 	ldr	r0, [pc, #192]	; 57e2183c <file_fat_detectfs+0x12c>
57e21778:	ea00000a 	b	57e217a8 <file_fat_detectfs+0x98>
		break;
	case IF_TYPE_SCSI:
		printf("SCSI");
57e2177c:	e59f00bc 	ldr	r0, [pc, #188]	; 57e21840 <file_fat_detectfs+0x130>
57e21780:	ea000008 	b	57e217a8 <file_fat_detectfs+0x98>
		break;
	case IF_TYPE_ATAPI:
		printf("ATAPI");
57e21784:	e59f00b8 	ldr	r0, [pc, #184]	; 57e21844 <file_fat_detectfs+0x134>
57e21788:	ea000006 	b	57e217a8 <file_fat_detectfs+0x98>
		break;
	case IF_TYPE_USB:
		printf("USB");
57e2178c:	e59f00b4 	ldr	r0, [pc, #180]	; 57e21848 <file_fat_detectfs+0x138>
57e21790:	ea000004 	b	57e217a8 <file_fat_detectfs+0x98>
		break;
	case IF_TYPE_DOC:
		printf("DOC");
57e21794:	e59f00b0 	ldr	r0, [pc, #176]	; 57e2184c <file_fat_detectfs+0x13c>
57e21798:	ea000002 	b	57e217a8 <file_fat_detectfs+0x98>
		break;
	case IF_TYPE_MMC:
		printf("MMC");
57e2179c:	e59f00ac 	ldr	r0, [pc, #172]	; 57e21850 <file_fat_detectfs+0x140>
57e217a0:	ea000000 	b	57e217a8 <file_fat_detectfs+0x98>
		break;
	default:
		printf("Unknown");
57e217a4:	e59f00a8 	ldr	r0, [pc, #168]	; 57e21854 <file_fat_detectfs+0x144>
	}

	printf("\n  Device %d: ", cur_dev->dev);
57e217a8:	e59f407c 	ldr	r4, [pc, #124]	; 57e2182c <file_fat_detectfs+0x11c>
		break;
	case IF_TYPE_MMC:
		printf("MMC");
		break;
	default:
		printf("Unknown");
57e217ac:	ebff9f26 	bl	57e0944c <printf>
	}

	printf("\n  Device %d: ", cur_dev->dev);
57e217b0:	e5943000 	ldr	r3, [r4]
57e217b4:	e59f009c 	ldr	r0, [pc, #156]	; 57e21858 <file_fat_detectfs+0x148>
57e217b8:	e5931004 	ldr	r1, [r3, #4]
57e217bc:	ebff9f22 	bl	57e0944c <printf>
	dev_print(cur_dev);
#endif

	if (read_bootsectandvi(&bs, &volinfo, &fatsize)) {
57e217c0:	e28d5044 	add	r5, sp, #68	; 0x44
	default:
		printf("Unknown");
	}

	printf("\n  Device %d: ", cur_dev->dev);
	dev_print(cur_dev);
57e217c4:	e5940000 	ldr	r0, [r4]
57e217c8:	ebffc5dc 	bl	57e12f40 <dev_print>
#endif

	if (read_bootsectandvi(&bs, &volinfo, &fatsize)) {
57e217cc:	e28d0004 	add	r0, sp, #4
57e217d0:	e1a01005 	mov	r1, r5
57e217d4:	e28d206c 	add	r2, sp, #108	; 0x6c
57e217d8:	ebfffb79 	bl	57e205c4 <read_bootsectandvi>
57e217dc:	e2504000 	subs	r4, r0, #0
57e217e0:	0a000003 	beq	57e217f4 <file_fat_detectfs+0xe4>
		printf("\nNo valid FAT fs found\n");
57e217e4:	e59f0070 	ldr	r0, [pc, #112]	; 57e2185c <file_fat_detectfs+0x14c>
57e217e8:	ebff9f17 	bl	57e0944c <printf>
		return 1;
57e217ec:	e3a00001 	mov	r0, #1
57e217f0:	ea00000b 	b	57e21824 <file_fat_detectfs+0x114>
	}

	memcpy(vol_label, volinfo.volume_label, 11);
57e217f4:	e28d6060 	add	r6, sp, #96	; 0x60
57e217f8:	e2851007 	add	r1, r5, #7
57e217fc:	e3a0200b 	mov	r2, #11
57e21800:	e1a00006 	mov	r0, r6
57e21804:	eb000ac0 	bl	57e2430c <memcpy>
	vol_label[11] = '\0';
	volinfo.fs_type[5] = '\0';

	printf("Filesystem: %s \"%s\"\n", volinfo.fs_type, vol_label);
57e21808:	e59f0050 	ldr	r0, [pc, #80]	; 57e21860 <file_fat_detectfs+0x150>
57e2180c:	e2851012 	add	r1, r5, #18
57e21810:	e1a02006 	mov	r2, r6
		printf("\nNo valid FAT fs found\n");
		return 1;
	}

	memcpy(vol_label, volinfo.volume_label, 11);
	vol_label[11] = '\0';
57e21814:	e5cd406b 	strb	r4, [sp, #107]	; 0x6b
	volinfo.fs_type[5] = '\0';
57e21818:	e5cd405b 	strb	r4, [sp, #91]	; 0x5b

	printf("Filesystem: %s \"%s\"\n", volinfo.fs_type, vol_label);
57e2181c:	ebff9f0a 	bl	57e0944c <printf>

	return 0;
57e21820:	e1a00004 	mov	r0, r4
}
57e21824:	e28dd070 	add	sp, sp, #112	; 0x70
57e21828:	e8bd8070 	pop	{r4, r5, r6, pc}
57e2182c:	57e48fc0 	.word	0x57e48fc0
57e21830:	57e3527a 	.word	0x57e3527a
57e21834:	57e3528d 	.word	0x57e3528d
57e21838:	57e33225 	.word	0x57e33225
57e2183c:	57e33229 	.word	0x57e33229
57e21840:	57e31515 	.word	0x57e31515
57e21844:	57e3322e 	.word	0x57e3322e
57e21848:	57e33234 	.word	0x57e33234
57e2184c:	57e33238 	.word	0x57e33238
57e21850:	57e3323c 	.word	0x57e3323c
57e21854:	57e34068 	.word	0x57e34068
57e21858:	57e3529a 	.word	0x57e3529a
57e2185c:	57e352a9 	.word	0x57e352a9
57e21860:	57e352c1 	.word	0x57e352c1

57e21864 <file_fat_ls>:

int file_fat_ls(const char *dir)
{
	return do_fat_read(dir, NULL, 0, LS_YES);
57e21864:	e3a01000 	mov	r1, #0
57e21868:	e1a02001 	mov	r2, r1
57e2186c:	e3a03001 	mov	r3, #1
57e21870:	eaffff9d 	b	57e216ec <do_fat_read>

57e21874 <file_fat_read_at>:
}

long file_fat_read_at(const char *filename, unsigned long pos, void *buffer,
		      unsigned long maxsize)
{
57e21874:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
57e21878:	e1a04000 	mov	r4, r0
57e2187c:	e1a05001 	mov	r5, r1
	printf("reading %s\n", filename);
57e21880:	e59f002c 	ldr	r0, [pc, #44]	; 57e218b4 <file_fat_read_at+0x40>
57e21884:	e1a01004 	mov	r1, r4
	return do_fat_read(dir, NULL, 0, LS_YES);
}

long file_fat_read_at(const char *filename, unsigned long pos, void *buffer,
		      unsigned long maxsize)
{
57e21888:	e1a06003 	mov	r6, r3
57e2188c:	e1a07002 	mov	r7, r2
	printf("reading %s\n", filename);
57e21890:	ebff9eed 	bl	57e0944c <printf>
	return do_fat_read_at(filename, pos, buffer, maxsize, LS_NO);
57e21894:	e3a03000 	mov	r3, #0
57e21898:	e58d3000 	str	r3, [sp]
57e2189c:	e1a00004 	mov	r0, r4
57e218a0:	e1a01005 	mov	r1, r5
57e218a4:	e1a02007 	mov	r2, r7
57e218a8:	e1a03006 	mov	r3, r6
57e218ac:	ebfffcb0 	bl	57e20b74 <do_fat_read_at>
}
57e218b0:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
57e218b4:	57e352d6 	.word	0x57e352d6

57e218b8 <file_fat_read>:

long file_fat_read(const char *filename, void *buffer, unsigned long maxsize)
{
57e218b8:	e1a0c001 	mov	ip, r1
57e218bc:	e1a03002 	mov	r3, r2
	return file_fat_read_at(filename, 0, buffer, maxsize);
57e218c0:	e3a01000 	mov	r1, #0
57e218c4:	e1a0200c 	mov	r2, ip
57e218c8:	eaffffe9 	b	57e21874 <file_fat_read_at>

57e218cc <file_getfsname>:
{
	if (idx < 0 || idx >= NUM_FILESYS)
		return NULL;

	return filesystems[idx].name;
}
57e218cc:	e59f300c 	ldr	r3, [pc, #12]	; 57e218e0 <file_getfsname+0x14>
57e218d0:	e3500000 	cmp	r0, #0
57e218d4:	01a00003 	moveq	r0, r3
57e218d8:	13a00000 	movne	r0, #0
57e218dc:	e12fff1e 	bx	lr
57e218e0:	57e2cdb4 	.word	0x57e2cdb4

57e218e4 <file_cd>:
	} while (1);
}

int
file_cd(const char *path)
{
57e218e4:	e92d4038 	push	{r3, r4, r5, lr}
	if (ISDIRDELIM(*path)) {
57e218e8:	e5d03000 	ldrb	r3, [r0]
57e218ec:	e353002f 	cmp	r3, #47	; 0x2f
57e218f0:	1353005c 	cmpne	r3, #92	; 0x5c
		while (ISDIRDELIM(*path)) path++;
		strncpy(file_cwd+1, path, CWD_LEN-1);
	} else {
		const char *origpath = path;
		char *tmpstr = file_cwd;
57e218f4:	159f31cc 	ldrne	r3, [pc, #460]	; 57e21ac8 <file_cd+0x1e4>
}

int
file_cd(const char *path)
{
	if (ISDIRDELIM(*path)) {
57e218f8:	1a000008 	bne	57e21920 <file_cd+0x3c>
57e218fc:	e1a01000 	mov	r1, r0
		while (ISDIRDELIM(*path)) path++;
57e21900:	e4d03001 	ldrb	r3, [r0], #1
57e21904:	e353002f 	cmp	r3, #47	; 0x2f
57e21908:	1353005c 	cmpne	r3, #92	; 0x5c
57e2190c:	0afffffa 	beq	57e218fc <file_cd+0x18>
		strncpy(file_cwd+1, path, CWD_LEN-1);
57e21910:	e59f21b4 	ldr	r2, [pc, #436]	; 57e21acc <file_cd+0x1e8>
57e21914:	e59f01b4 	ldr	r0, [pc, #436]	; 57e21ad0 <file_cd+0x1ec>
57e21918:	eb000977 	bl	57e23efc <strncpy>
57e2191c:	ea000067 	b	57e21ac0 <file_cd+0x1dc>
57e21920:	e1a01003 	mov	r1, r3
	} else {
		const char *origpath = path;
		char *tmpstr = file_cwd;
		int back = 0;

		while (*tmpstr != '\0') tmpstr++;
57e21924:	e4d32001 	ldrb	r2, [r3], #1
57e21928:	e3520000 	cmp	r2, #0
57e2192c:	1afffffb 	bne	57e21920 <file_cd+0x3c>
			src++;
	} while (1);
}

int
file_cd(const char *path)
57e21930:	e2411001 	sub	r1, r1, #1
		int back = 0;

		while (*tmpstr != '\0') tmpstr++;
		do {
			tmpstr--;
		} while (ISDIRDELIM(*tmpstr));
57e21934:	e5d12000 	ldrb	r2, [r1]
	} else {
		const char *origpath = path;
		char *tmpstr = file_cwd;
		int back = 0;

		while (*tmpstr != '\0') tmpstr++;
57e21938:	e1a03001 	mov	r3, r1
		do {
			tmpstr--;
		} while (ISDIRDELIM(*tmpstr));
57e2193c:	e352002f 	cmp	r2, #47	; 0x2f
57e21940:	1352005c 	cmpne	r2, #92	; 0x5c
57e21944:	e2411001 	sub	r1, r1, #1
57e21948:	13a02000 	movne	r2, #0
57e2194c:	03a02001 	moveq	r2, #1
57e21950:	0afffff7 	beq	57e21934 <file_cd+0x50>
57e21954:	ea000013 	b	57e219a8 <file_cd+0xc4>

		while (*path == '.') {
			path++;
57e21958:	e280c001 	add	ip, r0, #1
			while (*path == '.') {
57e2195c:	ea000000 	b	57e21964 <file_cd+0x80>
				path++;
				back++;
57e21960:	e2822001 	add	r2, r2, #1
57e21964:	e1a0500c 	mov	r5, ip
			tmpstr--;
		} while (ISDIRDELIM(*tmpstr));

		while (*path == '.') {
			path++;
			while (*path == '.') {
57e21968:	e4dc1001 	ldrb	r1, [ip], #1
57e2196c:	e351002e 	cmp	r1, #46	; 0x2e
57e21970:	0afffffa 	beq	57e21960 <file_cd+0x7c>
				path++;
				back++;
			}
			if (*path != '\0' && !ISDIRDELIM(*path)) {
57e21974:	e3510000 	cmp	r1, #0
57e21978:	1a000001 	bne	57e21984 <file_cd+0xa0>
57e2197c:	e1a01005 	mov	r1, r5
57e21980:	ea000003 	b	57e21994 <file_cd+0xb0>
57e21984:	e351005c 	cmp	r1, #92	; 0x5c
57e21988:	1351002f 	cmpne	r1, #47	; 0x2f
57e2198c:	0afffffa 	beq	57e2197c <file_cd+0x98>
57e21990:	ea000017 	b	57e219f4 <file_cd+0x110>
57e21994:	e1a00001 	mov	r0, r1
				path = origpath;
				back = 0;
				break;
			}
			while (ISDIRDELIM(*path)) path++;
57e21998:	e4d1c001 	ldrb	ip, [r1], #1
57e2199c:	e35c002f 	cmp	ip, #47	; 0x2f
57e219a0:	135c005c 	cmpne	ip, #92	; 0x5c
57e219a4:	0afffffa 	beq	57e21994 <file_cd+0xb0>
		while (*tmpstr != '\0') tmpstr++;
		do {
			tmpstr--;
		} while (ISDIRDELIM(*tmpstr));

		while (*path == '.') {
57e219a8:	e5d04000 	ldrb	r4, [r0]
57e219ac:	e354002e 	cmp	r4, #46	; 0x2e
57e219b0:	0affffe8 	beq	57e21958 <file_cd+0x74>
57e219b4:	ea00000f 	b	57e219f8 <file_cd+0x114>
57e219b8:	e1a01003 	mov	r1, r3
			origpath = path;
		}

		while (back--) {
			/* Strip off path component */
			while (!ISDIRDELIM(*tmpstr)) {
57e219bc:	e453c001 	ldrb	ip, [r3], #-1
57e219c0:	e35c005c 	cmp	ip, #92	; 0x5c
57e219c4:	135c002f 	cmpne	ip, #47	; 0x2f
57e219c8:	1afffffa 	bne	57e219b8 <file_cd+0xd4>
				tmpstr--;
			}
			if (tmpstr == file_cwd) {
57e219cc:	e1510005 	cmp	r1, r5
57e219d0:	0a00000c 	beq	57e21a08 <file_cd+0x124>
				/* Incremented again right after the loop. */
				tmpstr--;
				break;
			}
			/* Skip delimiters */
			while (ISDIRDELIM(*tmpstr)) tmpstr--;
57e219d4:	e5d1c000 	ldrb	ip, [r1]
		while (back--) {
			/* Strip off path component */
			while (!ISDIRDELIM(*tmpstr)) {
				tmpstr--;
			}
			if (tmpstr == file_cwd) {
57e219d8:	e1a03001 	mov	r3, r1
				/* Incremented again right after the loop. */
				tmpstr--;
				break;
			}
			/* Skip delimiters */
			while (ISDIRDELIM(*tmpstr)) tmpstr--;
57e219dc:	e35c002f 	cmp	ip, #47	; 0x2f
57e219e0:	135c005c 	cmpne	ip, #92	; 0x5c
57e219e4:	e2411001 	sub	r1, r1, #1
57e219e8:	0afffff9 	beq	57e219d4 <file_cd+0xf0>
57e219ec:	e2422001 	sub	r2, r2, #1
57e219f0:	ea000001 	b	57e219fc <file_cd+0x118>
				path++;
				back++;
			}
			if (*path != '\0' && !ISDIRDELIM(*path)) {
				path = origpath;
				back = 0;
57e219f4:	e3a02000 	mov	r2, #0
		while (back--) {
			/* Strip off path component */
			while (!ISDIRDELIM(*tmpstr)) {
				tmpstr--;
			}
			if (tmpstr == file_cwd) {
57e219f8:	e59f50c8 	ldr	r5, [pc, #200]	; 57e21ac8 <file_cd+0x1e4>
			}
			while (ISDIRDELIM(*path)) path++;
			origpath = path;
		}

		while (back--) {
57e219fc:	e3520000 	cmp	r2, #0
57e21a00:	1affffec 	bne	57e219b8 <file_cd+0xd4>
57e21a04:	ea000000 	b	57e21a0c <file_cd+0x128>
			while (!ISDIRDELIM(*tmpstr)) {
				tmpstr--;
			}
			if (tmpstr == file_cwd) {
				/* Incremented again right after the loop. */
				tmpstr--;
57e21a08:	e59f30c4 	ldr	r3, [pc, #196]	; 57e21ad4 <file_cd+0x1f0>
			}
			/* Skip delimiters */
			while (ISDIRDELIM(*tmpstr)) tmpstr--;
		}
		tmpstr++;
		if (*path == '\0') {
57e21a0c:	e3540000 	cmp	r4, #0
				break;
			}
			/* Skip delimiters */
			while (ISDIRDELIM(*tmpstr)) tmpstr--;
		}
		tmpstr++;
57e21a10:	e2832001 	add	r2, r3, #1
		if (*path == '\0') {
57e21a14:	1a000006 	bne	57e21a34 <file_cd+0x150>
			if (tmpstr == file_cwd) {
57e21a18:	e59f30a8 	ldr	r3, [pc, #168]	; 57e21ac8 <file_cd+0x1e4>
57e21a1c:	e1520003 	cmp	r2, r3
				*tmpstr = '/';
57e21a20:	03a0302f 	moveq	r3, #47	; 0x2f
57e21a24:	04c23001 	strbeq	r3, [r2], #1
				tmpstr++;
			}
			*tmpstr = '\0';
57e21a28:	e3a03000 	mov	r3, #0
57e21a2c:	e5c23000 	strb	r3, [r2]
			return 0;
57e21a30:	ea000022 	b	57e21ac0 <file_cd+0x1dc>
		}
		*tmpstr = '/';
57e21a34:	e3a0102f 	mov	r1, #47	; 0x2f
pathcpy(char *dest, const char *src)
{
	char *origdest = dest;

	do {
		if (dest-file_cwd >= CWD_LEN) {
57e21a38:	e59f5088 	ldr	r5, [pc, #136]	; 57e21ac8 <file_cd+0x1e4>
57e21a3c:	e59f4088 	ldr	r4, [pc, #136]	; 57e21acc <file_cd+0x1e8>
				tmpstr++;
			}
			*tmpstr = '\0';
			return 0;
		}
		*tmpstr = '/';
57e21a40:	e5c31001 	strb	r1, [r3, #1]
		pathcpy(tmpstr+1, path);
57e21a44:	e2822001 	add	r2, r2, #1
			src++;
	} while (1);
}

int
file_cd(const char *path)
57e21a48:	e2833002 	add	r3, r3, #2
pathcpy(char *dest, const char *src)
{
	char *origdest = dest;

	do {
		if (dest-file_cwd >= CWD_LEN) {
57e21a4c:	e0651003 	rsb	r1, r5, r3
57e21a50:	e1510004 	cmp	r1, r4
			}
			*tmpstr = '\0';
			return 0;
		}
		*tmpstr = '/';
		pathcpy(tmpstr+1, path);
57e21a54:	e1a0c003 	mov	ip, r3
{
	char *origdest = dest;

	do {
		if (dest-file_cwd >= CWD_LEN) {
			*dest = '\0';
57e21a58:	c3a02000 	movgt	r2, #0
57e21a5c:	c5c32000 	strbgt	r2, [r3]
57e21a60:	ca000016 	bgt	57e21ac0 <file_cd+0x1dc>
			return;
		}
		*(dest) = *(src);
57e21a64:	e5d01000 	ldrb	r1, [r0]
57e21a68:	e4c31001 	strb	r1, [r3], #1
		if (*src == '\0') {
57e21a6c:	e5d01000 	ldrb	r1, [r0]
57e21a70:	e3510000 	cmp	r1, #0
57e21a74:	1a000006 	bne	57e21a94 <file_cd+0x1b0>
			if (dest-- != origdest && ISDIRDELIM(*dest)) {
57e21a78:	e15c0002 	cmp	ip, r2
57e21a7c:	0a00000f 	beq	57e21ac0 <file_cd+0x1dc>
57e21a80:	e55c3001 	ldrb	r3, [ip, #-1]
57e21a84:	e353002f 	cmp	r3, #47	; 0x2f
57e21a88:	1353005c 	cmpne	r3, #92	; 0x5c
				*dest = '\0';
57e21a8c:	054c1001 	strbeq	r1, [ip, #-1]
57e21a90:	ea00000a 	b	57e21ac0 <file_cd+0x1dc>
			}
			return;
		}
		++dest;

		if (ISDIRDELIM(*src))
57e21a94:	e351002f 	cmp	r1, #47	; 0x2f
57e21a98:	1351005c 	cmpne	r1, #92	; 0x5c
			while (ISDIRDELIM(*src)) src++;
		else
			src++;
57e21a9c:	12800001 	addne	r0, r0, #1
			}
			return;
		}
		++dest;

		if (ISDIRDELIM(*src))
57e21aa0:	1affffe9 	bne	57e21a4c <file_cd+0x168>
57e21aa4:	e1a01000 	mov	r1, r0
57e21aa8:	e1a00001 	mov	r0, r1
			while (ISDIRDELIM(*src)) src++;
57e21aac:	e4d1c001 	ldrb	ip, [r1], #1
57e21ab0:	e35c002f 	cmp	ip, #47	; 0x2f
57e21ab4:	135c005c 	cmpne	ip, #92	; 0x5c
57e21ab8:	0afffffa 	beq	57e21aa8 <file_cd+0x1c4>
57e21abc:	eaffffe2 	b	57e21a4c <file_cd+0x168>
		*tmpstr = '/';
		pathcpy(tmpstr+1, path);
	}

	return 0;
}
57e21ac0:	e3a00000 	mov	r0, #0
57e21ac4:	e8bd8038 	pop	{r3, r4, r5, pc}
57e21ac8:	57e379bc 	.word	0x57e379bc
57e21acc:	000001fe 	.word	0x000001fe
57e21ad0:	57e379bd 	.word	0x57e379bd
57e21ad4:	57e379bb 	.word	0x57e379bb

57e21ad8 <file_detectfs>:

int
file_detectfs(void)
{
57e21ad8:	e92d4038 	push	{r3, r4, r5, lr}
	int i;

	current_filesystem = FSTYPE_NONE;
57e21adc:	e59f402c 	ldr	r4, [pc, #44]	; 57e21b10 <file_detectfs+0x38>
57e21ae0:	e3e03000 	mvn	r3, #0
57e21ae4:	e5843200 	str	r3, [r4, #512]	; 0x200

	for (i = 0; i < NUM_FILESYS; i++) {
		if (filesystems[i].detect() == 0) {
57e21ae8:	ebffff08 	bl	57e21710 <file_fat_detectfs>
57e21aec:	e2505000 	subs	r5, r0, #0
57e21af0:	1a000003 	bne	57e21b04 <file_detectfs+0x2c>
			strcpy(file_cwd, "/");
57e21af4:	e1a00004 	mov	r0, r4
57e21af8:	e59f1014 	ldr	r1, [pc, #20]	; 57e21b14 <file_detectfs+0x3c>
57e21afc:	eb0008f7 	bl	57e23ee0 <strcpy>
			current_filesystem = i;
57e21b00:	e5845200 	str	r5, [r4, #512]	; 0x200
			break;
		}
	}

	return current_filesystem;
}
57e21b04:	e59f3004 	ldr	r3, [pc, #4]	; 57e21b10 <file_detectfs+0x38>
57e21b08:	e5930200 	ldr	r0, [r3, #512]	; 0x200
57e21b0c:	e8bd8038 	pop	{r3, r4, r5, pc}
57e21b10:	57e379bc 	.word	0x57e379bc
57e21b14:	57e352e2 	.word	0x57e352e2

57e21b18 <file_ls>:

int
file_ls(const char *dir)
{
57e21b18:	e92d4010 	push	{r4, lr}
	char fullpath[1024];
	const char *arg;

	if (current_filesystem == FSTYPE_NONE) {
57e21b1c:	e59f206c 	ldr	r2, [pc, #108]	; 57e21b90 <file_ls+0x78>
	return current_filesystem;
}

int
file_ls(const char *dir)
{
57e21b20:	e24ddb01 	sub	sp, sp, #1024	; 0x400
	char fullpath[1024];
	const char *arg;

	if (current_filesystem == FSTYPE_NONE) {
57e21b24:	e5924200 	ldr	r4, [r2, #512]	; 0x200
	return current_filesystem;
}

int
file_ls(const char *dir)
{
57e21b28:	e1a03000 	mov	r3, r0
	char fullpath[1024];
	const char *arg;

	if (current_filesystem == FSTYPE_NONE) {
57e21b2c:	e3740001 	cmn	r4, #1
57e21b30:	1a000003 	bne	57e21b44 <file_ls+0x2c>
		printf("Can't list files without a filesystem!\n");
57e21b34:	e59f0058 	ldr	r0, [pc, #88]	; 57e21b94 <file_ls+0x7c>
57e21b38:	ebff9e43 	bl	57e0944c <printf>
		return -1;
57e21b3c:	e1a00004 	mov	r0, r4
57e21b40:	ea000010 	b	57e21b88 <file_ls+0x70>
	}

	if (ISDIRDELIM(*dir)) {
57e21b44:	e5d01000 	ldrb	r1, [r0]
57e21b48:	e351002f 	cmp	r1, #47	; 0x2f
57e21b4c:	1351005c 	cmpne	r1, #92	; 0x5c
57e21b50:	01a00000 	moveq	r0, r0
57e21b54:	0a000004 	beq	57e21b6c <file_ls+0x54>
		arg = dir;
	} else {
		sprintf(fullpath, "%s/%s", file_cwd, dir);
57e21b58:	e1a0000d 	mov	r0, sp
57e21b5c:	e59f1034 	ldr	r1, [pc, #52]	; 57e21b98 <file_ls+0x80>
57e21b60:	eb000df8 	bl	57e25348 <sprintf>
57e21b64:	e1a0400d 	mov	r4, sp
		arg = fullpath;
57e21b68:	e1a0000d 	mov	r0, sp
	}
	return filesystems[current_filesystem].ls(arg);
57e21b6c:	e59f301c 	ldr	r3, [pc, #28]	; 57e21b90 <file_ls+0x78>
57e21b70:	e59f2024 	ldr	r2, [pc, #36]	; 57e21b9c <file_ls+0x84>
57e21b74:	e5933200 	ldr	r3, [r3, #512]	; 0x200
57e21b78:	e3a01018 	mov	r1, #24
57e21b7c:	e0232391 	mla	r3, r1, r3, r2
57e21b80:	e5932004 	ldr	r2, [r3, #4]
57e21b84:	e12fff32 	blx	r2
}
57e21b88:	e28ddb01 	add	sp, sp, #1024	; 0x400
57e21b8c:	e8bd8010 	pop	{r4, pc}
57e21b90:	57e379bc 	.word	0x57e379bc
57e21b94:	57e352e4 	.word	0x57e352e4
57e21b98:	57e3530c 	.word	0x57e3530c
57e21b9c:	57e2cda8 	.word	0x57e2cda8

57e21ba0 <file_read>:

long
file_read(const char *filename, void *buffer, unsigned long maxsize)
{
57e21ba0:	e92d4070 	push	{r4, r5, r6, lr}
57e21ba4:	e1a05002 	mov	r5, r2
	char fullpath[1024];
	const char *arg;

	if (current_filesystem == FSTYPE_NONE) {
57e21ba8:	e59f2078 	ldr	r2, [pc, #120]	; 57e21c28 <file_read+0x88>
	return filesystems[current_filesystem].ls(arg);
}

long
file_read(const char *filename, void *buffer, unsigned long maxsize)
{
57e21bac:	e24ddb01 	sub	sp, sp, #1024	; 0x400
	char fullpath[1024];
	const char *arg;

	if (current_filesystem == FSTYPE_NONE) {
57e21bb0:	e5924200 	ldr	r4, [r2, #512]	; 0x200
	return filesystems[current_filesystem].ls(arg);
}

long
file_read(const char *filename, void *buffer, unsigned long maxsize)
{
57e21bb4:	e1a03000 	mov	r3, r0
	char fullpath[1024];
	const char *arg;

	if (current_filesystem == FSTYPE_NONE) {
57e21bb8:	e3740001 	cmn	r4, #1
	return filesystems[current_filesystem].ls(arg);
}

long
file_read(const char *filename, void *buffer, unsigned long maxsize)
{
57e21bbc:	e1a06001 	mov	r6, r1
	char fullpath[1024];
	const char *arg;

	if (current_filesystem == FSTYPE_NONE) {
57e21bc0:	1a000003 	bne	57e21bd4 <file_read+0x34>
		printf("Can't load file without a filesystem!\n");
57e21bc4:	e59f0060 	ldr	r0, [pc, #96]	; 57e21c2c <file_read+0x8c>
57e21bc8:	ebff9e1f 	bl	57e0944c <printf>
		return -1;
57e21bcc:	e1a00004 	mov	r0, r4
57e21bd0:	ea000012 	b	57e21c20 <file_read+0x80>
	}

	if (ISDIRDELIM(*filename)) {
57e21bd4:	e5d01000 	ldrb	r1, [r0]
57e21bd8:	e351002f 	cmp	r1, #47	; 0x2f
57e21bdc:	1351005c 	cmpne	r1, #92	; 0x5c
57e21be0:	01a00000 	moveq	r0, r0
57e21be4:	0a000004 	beq	57e21bfc <file_read+0x5c>
		arg = filename;
	} else {
		sprintf(fullpath, "%s/%s", file_cwd, filename);
57e21be8:	e1a0000d 	mov	r0, sp
57e21bec:	e59f103c 	ldr	r1, [pc, #60]	; 57e21c30 <file_read+0x90>
57e21bf0:	eb000dd4 	bl	57e25348 <sprintf>
57e21bf4:	e1a0400d 	mov	r4, sp
		arg = fullpath;
57e21bf8:	e1a0000d 	mov	r0, sp
	}

	return filesystems[current_filesystem].read(arg, buffer, maxsize);
57e21bfc:	e59f3024 	ldr	r3, [pc, #36]	; 57e21c28 <file_read+0x88>
57e21c00:	e59f202c 	ldr	r2, [pc, #44]	; 57e21c34 <file_read+0x94>
57e21c04:	e5933200 	ldr	r3, [r3, #512]	; 0x200
57e21c08:	e3a01018 	mov	r1, #24
57e21c0c:	e0232391 	mla	r3, r1, r3, r2
57e21c10:	e1a01006 	mov	r1, r6
57e21c14:	e593c008 	ldr	ip, [r3, #8]
57e21c18:	e1a02005 	mov	r2, r5
57e21c1c:	e12fff3c 	blx	ip
}
57e21c20:	e28ddb01 	add	sp, sp, #1024	; 0x400
57e21c24:	e8bd8070 	pop	{r4, r5, r6, pc}
57e21c28:	57e379bc 	.word	0x57e379bc
57e21c2c:	57e35312 	.word	0x57e35312
57e21c30:	57e3530c 	.word	0x57e3530c
57e21c34:	57e2cda8 	.word	0x57e2cda8

57e21c38 <fs_close>:
	printf("** Unrecognized filesystem type **\n");
	return -1;
}

static void fs_close(void)
{
57e21c38:	e92d4008 	push	{r3, lr}
	switch (fs_type) {
57e21c3c:	e59f301c 	ldr	r3, [pc, #28]	; 57e21c60 <fs_close+0x28>
57e21c40:	e5933000 	ldr	r3, [r3]
57e21c44:	e3530002 	cmp	r3, #2
57e21c48:	1a000000 	bne	57e21c50 <fs_close+0x18>
	return 0;
}

static void fs_close_ext(void)
{
	ext4fs_close();
57e21c4c:	ebfff6cd 	bl	57e1f788 <ext4fs_close>
		break;
	default:
		break;
	}

	fs_type = FS_TYPE_ANY;
57e21c50:	e59f3008 	ldr	r3, [pc, #8]	; 57e21c60 <fs_close+0x28>
57e21c54:	e3a02000 	mov	r2, #0
57e21c58:	e5832000 	str	r2, [r3]
}
57e21c5c:	e8bd8008 	pop	{r3, pc}
57e21c60:	57e79040 	.word	0x57e79040

57e21c64 <fs_probe_ext>:
#define fs_read_fat fs_read_unsupported
#endif

#ifdef CONFIG_FS_EXT4
static int fs_probe_ext(void)
{
57e21c64:	e92d4010 	push	{r4, lr}
	ext4fs_set_blk_dev(fs_dev_desc, &fs_partition);
57e21c68:	e59f402c 	ldr	r4, [pc, #44]	; 57e21c9c <fs_probe_ext+0x38>
57e21c6c:	e5940004 	ldr	r0, [r4, #4]
57e21c70:	e2841008 	add	r1, r4, #8
57e21c74:	ebfff8c5 	bl	57e1ff90 <ext4fs_set_blk_dev>

	if (!ext4fs_mount(fs_partition.size)) {
57e21c78:	e594000c 	ldr	r0, [r4, #12]
57e21c7c:	ebfff88b 	bl	57e1feb0 <ext4fs_mount>
57e21c80:	e3500000 	cmp	r0, #0
57e21c84:	1a000002 	bne	57e21c94 <fs_probe_ext+0x30>
		ext4fs_close();
57e21c88:	ebfff6be 	bl	57e1f788 <ext4fs_close>
		return -1;
57e21c8c:	e3e00000 	mvn	r0, #0
57e21c90:	e8bd8010 	pop	{r4, pc}
	}

	return 0;
57e21c94:	e3a00000 	mov	r0, #0
}
57e21c98:	e8bd8010 	pop	{r4, pc}
57e21c9c:	57e79040 	.word	0x57e79040

57e21ca0 <fs_probe_fat>:
}

#ifdef CONFIG_FS_FAT
static int fs_probe_fat(void)
{
	return fat_set_blk_dev(fs_dev_desc, &fs_partition);
57e21ca0:	e59f1008 	ldr	r1, [pc, #8]	; 57e21cb0 <fs_probe_fat+0x10>
57e21ca4:	e5910004 	ldr	r0, [r1, #4]
57e21ca8:	e2811008 	add	r1, r1, #8
57e21cac:	eafffb5b 	b	57e20a20 <fat_set_blk_dev>
57e21cb0:	57e79040 	.word	0x57e79040

57e21cb4 <fs_set_blk_dev>:
		.probe = fs_probe_ext,
	},
};

int fs_set_blk_dev(const char *ifname, const char *dev_part_str, int fstype)
{
57e21cb4:	e92d4013 	push	{r0, r1, r4, lr}
57e21cb8:	e1a04002 	mov	r4, r2
			fstypes[i].probe += gd->reloc_off;
		relocated = 1;
	}
#endif

	part = get_device_and_partition(ifname, dev_part_str, &fs_dev_desc,
57e21cbc:	e59f2088 	ldr	r2, [pc, #136]	; 57e21d4c <fs_set_blk_dev+0x98>
57e21cc0:	e3a03001 	mov	r3, #1
57e21cc4:	e58d3000 	str	r3, [sp]
57e21cc8:	e2823004 	add	r3, r2, #4
57e21ccc:	ebffc58f 	bl	57e13310 <get_device_and_partition>
					&fs_partition, 1);
	if (part < 0)
57e21cd0:	e3500000 	cmp	r0, #0
57e21cd4:	ba00001a 	blt	57e21d44 <fs_set_blk_dev+0x90>
		return -1;

	for (i = 0; i < ARRAY_SIZE(fstypes); i++) {
		if ((fstype != FS_TYPE_ANY) && (fstype != fstypes[i].fstype))
57e21cd8:	e3540000 	cmp	r4, #0
57e21cdc:	1a000003 	bne	57e21cf0 <fs_set_blk_dev+0x3c>
			continue;

		if (!fstypes[i].probe()) {
57e21ce0:	ebffffee 	bl	57e21ca0 <fs_probe_fat>
57e21ce4:	e3500000 	cmp	r0, #0
57e21ce8:	1a000003 	bne	57e21cfc <fs_set_blk_dev+0x48>
57e21cec:	ea00000e 	b	57e21d2c <fs_set_blk_dev+0x78>
					&fs_partition, 1);
	if (part < 0)
		return -1;

	for (i = 0; i < ARRAY_SIZE(fstypes); i++) {
		if ((fstype != FS_TYPE_ANY) && (fstype != fstypes[i].fstype))
57e21cf0:	e3540001 	cmp	r4, #1
57e21cf4:	1a000006 	bne	57e21d14 <fs_set_blk_dev+0x60>
57e21cf8:	eafffff8 	b	57e21ce0 <fs_set_blk_dev+0x2c>
57e21cfc:	e3540000 	cmp	r4, #0
57e21d00:	1a000003 	bne	57e21d14 <fs_set_blk_dev+0x60>
			continue;

		if (!fstypes[i].probe()) {
57e21d04:	ebffffd6 	bl	57e21c64 <fs_probe_ext>
57e21d08:	e3500000 	cmp	r0, #0
57e21d0c:	1a000002 	bne	57e21d1c <fs_set_blk_dev+0x68>
57e21d10:	ea000004 	b	57e21d28 <fs_set_blk_dev+0x74>
					&fs_partition, 1);
	if (part < 0)
		return -1;

	for (i = 0; i < ARRAY_SIZE(fstypes); i++) {
		if ((fstype != FS_TYPE_ANY) && (fstype != fstypes[i].fstype))
57e21d14:	e3540002 	cmp	r4, #2
57e21d18:	0afffff9 	beq	57e21d04 <fs_set_blk_dev+0x50>
			fs_type = fstypes[i].fstype;
			return 0;
		}
	}

	printf("** Unrecognized filesystem type **\n");
57e21d1c:	e59f002c 	ldr	r0, [pc, #44]	; 57e21d50 <fs_set_blk_dev+0x9c>
57e21d20:	ebff9dc9 	bl	57e0944c <printf>
57e21d24:	ea000006 	b	57e21d44 <fs_set_blk_dev+0x90>
	part = get_device_and_partition(ifname, dev_part_str, &fs_dev_desc,
					&fs_partition, 1);
	if (part < 0)
		return -1;

	for (i = 0; i < ARRAY_SIZE(fstypes); i++) {
57e21d28:	e3a00001 	mov	r0, #1
		if ((fstype != FS_TYPE_ANY) && (fstype != fstypes[i].fstype))
			continue;

		if (!fstypes[i].probe()) {
			fs_type = fstypes[i].fstype;
57e21d2c:	e59f3020 	ldr	r3, [pc, #32]	; 57e21d54 <fs_set_blk_dev+0xa0>
57e21d30:	e7932180 	ldr	r2, [r3, r0, lsl #3]
57e21d34:	e59f301c 	ldr	r3, [pc, #28]	; 57e21d58 <fs_set_blk_dev+0xa4>
			return 0;
57e21d38:	e3a00000 	mov	r0, #0
	for (i = 0; i < ARRAY_SIZE(fstypes); i++) {
		if ((fstype != FS_TYPE_ANY) && (fstype != fstypes[i].fstype))
			continue;

		if (!fstypes[i].probe()) {
			fs_type = fstypes[i].fstype;
57e21d3c:	e5832000 	str	r2, [r3]
			return 0;
57e21d40:	ea000000 	b	57e21d48 <fs_set_blk_dev+0x94>
#endif

	part = get_device_and_partition(ifname, dev_part_str, &fs_dev_desc,
					&fs_partition, 1);
	if (part < 0)
		return -1;
57e21d44:	e3e00000 	mvn	r0, #0
		}
	}

	printf("** Unrecognized filesystem type **\n");
	return -1;
}
57e21d48:	e8bd801c 	pop	{r2, r3, r4, pc}
57e21d4c:	57e79044 	.word	0x57e79044
57e21d50:	57e35339 	.word	0x57e35339
57e21d54:	57e2cdc0 	.word	0x57e2cdc0
57e21d58:	57e79040 	.word	0x57e79040

57e21d5c <fs_ls>:

int fs_ls(const char *dirname)
{
	int ret;

	switch (fs_type) {
57e21d5c:	e59f3044 	ldr	r3, [pc, #68]	; 57e21da8 <fs_ls+0x4c>

	fs_type = FS_TYPE_ANY;
}

int fs_ls(const char *dirname)
{
57e21d60:	e92d4010 	push	{r4, lr}
	int ret;

	switch (fs_type) {
57e21d64:	e5933000 	ldr	r3, [r3]
57e21d68:	e3530001 	cmp	r3, #1
57e21d6c:	0a000002 	beq	57e21d7c <fs_ls+0x20>
57e21d70:	e3530002 	cmp	r3, #2
57e21d74:	1a000005 	bne	57e21d90 <fs_ls+0x34>
57e21d78:	ea000001 	b	57e21d84 <fs_ls+0x28>
	case FS_TYPE_FAT:
		ret = fs_ls_fat(dirname);
57e21d7c:	ebfffeb8 	bl	57e21864 <file_fat_ls>
57e21d80:	ea000000 	b	57e21d88 <fs_ls+0x2c>
		break;
	case FS_TYPE_EXT:
		ret = fs_ls_ext(dirname);
57e21d84:	ebfff3d6 	bl	57e1ece4 <ext4fs_ls>
57e21d88:	e1a04000 	mov	r4, r0
		break;
57e21d8c:	ea000002 	b	57e21d9c <fs_ls+0x40>
static disk_partition_t fs_partition;
static int fs_type = FS_TYPE_ANY;

static inline int fs_ls_unsupported(const char *dirname)
{
	printf("** Unrecognized filesystem type **\n");
57e21d90:	e59f0014 	ldr	r0, [pc, #20]	; 57e21dac <fs_ls+0x50>
57e21d94:	ebff9dac 	bl	57e0944c <printf>
		break;
	case FS_TYPE_EXT:
		ret = fs_ls_ext(dirname);
		break;
	default:
		ret = fs_ls_unsupported(dirname);
57e21d98:	e3e04000 	mvn	r4, #0
		break;
	}

	fs_close();
57e21d9c:	ebffffa5 	bl	57e21c38 <fs_close>

	return ret;
}
57e21da0:	e1a00004 	mov	r0, r4
57e21da4:	e8bd8010 	pop	{r4, pc}
57e21da8:	57e79040 	.word	0x57e79040
57e21dac:	57e35339 	.word	0x57e35339

57e21db0 <fs_read>:

int fs_read(const char *filename, ulong addr, int offset, int len)
{
57e21db0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e21db4:	e1a05001 	mov	r5, r1
	int ret;

	switch (fs_type) {
57e21db8:	e59f10bc 	ldr	r1, [pc, #188]	; 57e21e7c <fs_read+0xcc>

	return ret;
}

int fs_read(const char *filename, ulong addr, int offset, int len)
{
57e21dbc:	e1a04000 	mov	r4, r0
	int ret;

	switch (fs_type) {
57e21dc0:	e5911000 	ldr	r1, [r1]

	return ret;
}

int fs_read(const char *filename, ulong addr, int offset, int len)
{
57e21dc4:	e1a07003 	mov	r7, r3
	int ret;

	switch (fs_type) {
57e21dc8:	e3510001 	cmp	r1, #1
57e21dcc:	0a000003 	beq	57e21de0 <fs_read+0x30>
57e21dd0:	e3510002 	cmp	r1, #2
}

static inline int fs_read_unsupported(const char *filename, ulong addr,
				      int offset, int len)
{
	printf("** Unrecognized filesystem type **\n");
57e21dd4:	159f00a4 	ldrne	r0, [pc, #164]	; 57e21e80 <fs_read+0xd0>

int fs_read(const char *filename, ulong addr, int offset, int len)
{
	int ret;

	switch (fs_type) {
57e21dd8:	1a000022 	bne	57e21e68 <fs_read+0xb8>
57e21ddc:	ea000009 	b	57e21e08 <fs_read+0x58>

static int fs_read_fat(const char *filename, ulong addr, int offset, int len)
{
	int len_read;

	len_read = file_fat_read_at(filename, offset,
57e21de0:	e1a01002 	mov	r1, r2
57e21de4:	e1a02005 	mov	r2, r5
57e21de8:	ebfffea1 	bl	57e21874 <file_fat_read_at>
				    (unsigned char *)addr, len);
	if (len_read == -1) {
57e21dec:	e3700001 	cmn	r0, #1

static int fs_read_fat(const char *filename, ulong addr, int offset, int len)
{
	int len_read;

	len_read = file_fat_read_at(filename, offset,
57e21df0:	e1a05000 	mov	r5, r0
				    (unsigned char *)addr, len);
	if (len_read == -1) {
57e21df4:	1a00001d 	bne	57e21e70 <fs_read+0xc0>
		printf("** Unable to read file %s **\n", filename);
57e21df8:	e1a01004 	mov	r1, r4
57e21dfc:	e59f0080 	ldr	r0, [pc, #128]	; 57e21e84 <fs_read+0xd4>
57e21e00:	ebff9d91 	bl	57e0944c <printf>
57e21e04:	ea000019 	b	57e21e70 <fs_read+0xc0>
static int fs_read_ext(const char *filename, ulong addr, int offset, int len)
{
	int file_len;
	int len_read;

	if (offset != 0) {
57e21e08:	e3520000 	cmp	r2, #0
		printf("** Cannot support non-zero offset **\n");
57e21e0c:	159f0074 	ldrne	r0, [pc, #116]	; 57e21e88 <fs_read+0xd8>
static int fs_read_ext(const char *filename, ulong addr, int offset, int len)
{
	int file_len;
	int len_read;

	if (offset != 0) {
57e21e10:	1a000014 	bne	57e21e68 <fs_read+0xb8>
		printf("** Cannot support non-zero offset **\n");
		return -1;
	}

	file_len = ext4fs_open(filename);
57e21e14:	ebfff800 	bl	57e1fe1c <ext4fs_open>
	if (file_len < 0) {
57e21e18:	e2506000 	subs	r6, r0, #0
57e21e1c:	aa000004 	bge	57e21e34 <fs_read+0x84>
		printf("** File not found %s **\n", filename);
57e21e20:	e1a01004 	mov	r1, r4
57e21e24:	e59f0060 	ldr	r0, [pc, #96]	; 57e21e8c <fs_read+0xdc>
57e21e28:	ebff9d87 	bl	57e0944c <printf>
		ext4fs_close();
57e21e2c:	ebfff655 	bl	57e1f788 <ext4fs_close>
57e21e30:	ea00000d 	b	57e21e6c <fs_read+0xbc>
		return -1;
	}

	if (len == 0)
57e21e34:	e3570000 	cmp	r7, #0
57e21e38:	11a06007 	movne	r6, r7
		len = file_len;

	len_read = ext4fs_read((char *)addr, len);
57e21e3c:	e1a00005 	mov	r0, r5
57e21e40:	e1a01006 	mov	r1, r6
57e21e44:	ebfff3c3 	bl	57e1ed58 <ext4fs_read>
57e21e48:	e1a05000 	mov	r5, r0
	ext4fs_close();
57e21e4c:	ebfff64d 	bl	57e1f788 <ext4fs_close>

	if (len_read != len) {
57e21e50:	e1550006 	cmp	r5, r6
57e21e54:	0a000005 	beq	57e21e70 <fs_read+0xc0>
		printf("** Unable to read file %s **\n", filename);
57e21e58:	e1a01004 	mov	r1, r4
57e21e5c:	e59f0020 	ldr	r0, [pc, #32]	; 57e21e84 <fs_read+0xd4>
57e21e60:	ebff9d79 	bl	57e0944c <printf>
57e21e64:	ea000000 	b	57e21e6c <fs_read+0xbc>
}

static inline int fs_read_unsupported(const char *filename, ulong addr,
				      int offset, int len)
{
	printf("** Unrecognized filesystem type **\n");
57e21e68:	ebff9d77 	bl	57e0944c <printf>
		break;
	case FS_TYPE_EXT:
		ret = fs_read_ext(filename, addr, offset, len);
		break;
	default:
		ret = fs_read_unsupported(filename, addr, offset, len);
57e21e6c:	e3e05000 	mvn	r5, #0
		break;
	}

	fs_close();
57e21e70:	ebffff70 	bl	57e21c38 <fs_close>

	return ret;
}
57e21e74:	e1a00005 	mov	r0, r5
57e21e78:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e21e7c:	57e79040 	.word	0x57e79040
57e21e80:	57e35339 	.word	0x57e35339
57e21e84:	57e3535d 	.word	0x57e3535d
57e21e88:	57e3537b 	.word	0x57e3537b
57e21e8c:	57e353a1 	.word	0x57e353a1

57e21e90 <do_load>:

int do_load(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
		int fstype, int cmdline_base)
{
57e21e90:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned long pos;
	int len_read;
	char buf[12];
	unsigned long time;

	if (argc < 2)
57e21e94:	e3520001 	cmp	r2, #1
	return ret;
}

int do_load(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
		int fstype, int cmdline_base)
{
57e21e98:	e1a04002 	mov	r4, r2
57e21e9c:	e1a05003 	mov	r5, r3
57e21ea0:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
	unsigned long pos;
	int len_read;
	char buf[12];
	unsigned long time;

	if (argc < 2)
57e21ea4:	da000060 	ble	57e2202c <do_load+0x19c>
		return CMD_RET_USAGE;
	if (argc > 7)
57e21ea8:	e3520007 	cmp	r2, #7
57e21eac:	ca00005e 	bgt	57e2202c <do_load+0x19c>
		return CMD_RET_USAGE;

	if (fs_set_blk_dev(argv[1], (argc >= 3) ? argv[2] : NULL, fstype))
57e21eb0:	e3520002 	cmp	r2, #2
57e21eb4:	15931008 	ldrne	r1, [r3, #8]
57e21eb8:	03a01000 	moveq	r1, #0
57e21ebc:	e5930004 	ldr	r0, [r3, #4]
57e21ec0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
57e21ec4:	ebffff7a 	bl	57e21cb4 <fs_set_blk_dev>
57e21ec8:	e2506000 	subs	r6, r0, #0
57e21ecc:	1a000058 	bne	57e22034 <do_load+0x1a4>
		return 1;

	if (argc >= 4) {
57e21ed0:	e3540003 	cmp	r4, #3
57e21ed4:	da000007 	ble	57e21ef8 <do_load+0x68>
		addr = simple_strtoul(argv[3], NULL, cmdline_base);
57e21ed8:	e595000c 	ldr	r0, [r5, #12]
57e21edc:	e1a01006 	mov	r1, r6
57e21ee0:	e1a02009 	mov	r2, r9
57e21ee4:	eb000c6e 	bl	57e250a4 <simple_strtoul>
		if (addr_str != NULL)
			addr = simple_strtoul(addr_str, NULL, 16);
		else
			addr = CONFIG_SYS_LOAD_ADDR;
	}
	if (argc >= 5) {
57e21ee8:	e3540004 	cmp	r4, #4

	if (fs_set_blk_dev(argv[1], (argc >= 3) ? argv[2] : NULL, fstype))
		return 1;

	if (argc >= 4) {
		addr = simple_strtoul(argv[3], NULL, cmdline_base);
57e21eec:	e1a0a000 	mov	sl, r0
		if (addr_str != NULL)
			addr = simple_strtoul(addr_str, NULL, 16);
		else
			addr = CONFIG_SYS_LOAD_ADDR;
	}
	if (argc >= 5) {
57e21ef0:	1a00000a 	bne	57e21f20 <do_load+0x90>
57e21ef4:	ea00000d 	b	57e21f30 <do_load+0xa0>
		return 1;

	if (argc >= 4) {
		addr = simple_strtoul(argv[3], NULL, cmdline_base);
	} else {
		addr_str = getenv("loadaddr");
57e21ef8:	e59f014c 	ldr	r0, [pc, #332]	; 57e2204c <do_load+0x1bc>
57e21efc:	ebff95f9 	bl	57e076e8 <getenv>
		if (addr_str != NULL)
57e21f00:	e3500000 	cmp	r0, #0
			addr = simple_strtoul(addr_str, NULL, 16);
		else
			addr = CONFIG_SYS_LOAD_ADDR;
57e21f04:	03a0a205 	moveq	sl, #1342177280	; 0x50000000

	if (argc >= 4) {
		addr = simple_strtoul(argv[3], NULL, cmdline_base);
	} else {
		addr_str = getenv("loadaddr");
		if (addr_str != NULL)
57e21f08:	0a000008 	beq	57e21f30 <do_load+0xa0>
			addr = simple_strtoul(addr_str, NULL, 16);
57e21f0c:	e1a01006 	mov	r1, r6
57e21f10:	e3a02010 	mov	r2, #16
57e21f14:	eb000c62 	bl	57e250a4 <simple_strtoul>
57e21f18:	e1a0a000 	mov	sl, r0
57e21f1c:	ea000003 	b	57e21f30 <do_load+0xa0>
		if (!filename) {
			puts("** No boot file defined **\n");
			return 1;
		}
	}
	if (argc >= 6)
57e21f20:	e3540005 	cmp	r4, #5
			addr = simple_strtoul(addr_str, NULL, 16);
		else
			addr = CONFIG_SYS_LOAD_ADDR;
	}
	if (argc >= 5) {
		filename = argv[4];
57e21f24:	e595b010 	ldr	fp, [r5, #16]
		if (!filename) {
			puts("** No boot file defined **\n");
			return 1;
		}
	}
	if (argc >= 6)
57e21f28:	0a000044 	beq	57e22040 <do_load+0x1b0>
57e21f2c:	ea000006 	b	57e21f4c <do_load+0xbc>
			addr = CONFIG_SYS_LOAD_ADDR;
	}
	if (argc >= 5) {
		filename = argv[4];
	} else {
		filename = getenv("bootfile");
57e21f30:	e59f0118 	ldr	r0, [pc, #280]	; 57e22050 <do_load+0x1c0>
57e21f34:	ebff95eb 	bl	57e076e8 <getenv>
		if (!filename) {
57e21f38:	e250b000 	subs	fp, r0, #0
57e21f3c:	1a00003f 	bne	57e22040 <do_load+0x1b0>
			puts("** No boot file defined **\n");
57e21f40:	e59f010c 	ldr	r0, [pc, #268]	; 57e22054 <do_load+0x1c4>
57e21f44:	ebff9d36 	bl	57e09424 <puts>
57e21f48:	ea000039 	b	57e22034 <do_load+0x1a4>
			return 1;
		}
	}
	if (argc >= 6)
		bytes = simple_strtoul(argv[5], NULL, cmdline_base);
57e21f4c:	e5950014 	ldr	r0, [r5, #20]
57e21f50:	e1a01006 	mov	r1, r6
57e21f54:	e1a02009 	mov	r2, r9
57e21f58:	eb000c51 	bl	57e250a4 <simple_strtoul>
	else
		bytes = 0;
	if (argc >= 7)
57e21f5c:	e3540007 	cmp	r4, #7
			puts("** No boot file defined **\n");
			return 1;
		}
	}
	if (argc >= 6)
		bytes = simple_strtoul(argv[5], NULL, cmdline_base);
57e21f60:	e1a07000 	mov	r7, r0
	else
		bytes = 0;
	if (argc >= 7)
57e21f64:	1a000004 	bne	57e21f7c <do_load+0xec>
		pos = simple_strtoul(argv[6], NULL, cmdline_base);
57e21f68:	e1a01006 	mov	r1, r6
57e21f6c:	e5950018 	ldr	r0, [r5, #24]
57e21f70:	e1a02009 	mov	r2, r9
57e21f74:	eb000c4a 	bl	57e250a4 <simple_strtoul>
57e21f78:	e1a06000 	mov	r6, r0
	else
		pos = 0;

	time = get_timer(0);
57e21f7c:	e3a00000 	mov	r0, #0
57e21f80:	ebff7ae1 	bl	57e00b0c <get_timer>
	len_read = fs_read(filename, addr, pos, bytes);
57e21f84:	e1a0100a 	mov	r1, sl
	if (argc >= 7)
		pos = simple_strtoul(argv[6], NULL, cmdline_base);
	else
		pos = 0;

	time = get_timer(0);
57e21f88:	e1a04000 	mov	r4, r0
	len_read = fs_read(filename, addr, pos, bytes);
57e21f8c:	e1a02006 	mov	r2, r6
57e21f90:	e1a03007 	mov	r3, r7
57e21f94:	e1a0000b 	mov	r0, fp
57e21f98:	ebffff84 	bl	57e21db0 <fs_read>
57e21f9c:	e1a05000 	mov	r5, r0
	time = get_timer(time);
57e21fa0:	e1a00004 	mov	r0, r4
57e21fa4:	ebff7ad8 	bl	57e00b0c <get_timer>
	if (len_read <= 0)
57e21fa8:	e3550000 	cmp	r5, #0
	else
		pos = 0;

	time = get_timer(0);
	len_read = fs_read(filename, addr, pos, bytes);
	time = get_timer(time);
57e21fac:	e1a04000 	mov	r4, r0
	if (len_read <= 0)
57e21fb0:	da00001f 	ble	57e22034 <do_load+0x1a4>
		return 1;

	printf("%d bytes read in %lu ms", len_read, time);
57e21fb4:	e59f009c 	ldr	r0, [pc, #156]	; 57e22058 <do_load+0x1c8>
57e21fb8:	e1a01005 	mov	r1, r5
57e21fbc:	e1a02004 	mov	r2, r4
57e21fc0:	ebff9d21 	bl	57e0944c <printf>
	if (time > 0) {
57e21fc4:	e3540000 	cmp	r4, #0
57e21fc8:	0a00000b 	beq	57e21ffc <do_load+0x16c>
		puts(" (");
57e21fcc:	e59f0088 	ldr	r0, [pc, #136]	; 57e2205c <do_load+0x1cc>
57e21fd0:	ebff9d13 	bl	57e09424 <puts>
		print_size(len_read / time * 1000, "/s");
57e21fd4:	e1a01004 	mov	r1, r4
57e21fd8:	e1a00005 	mov	r0, r5
57e21fdc:	eb0025f3 	bl	57e2b7b0 <__udivsi3>
57e21fe0:	e3a03ffa 	mov	r3, #1000	; 0x3e8
57e21fe4:	e0000093 	mul	r0, r3, r0
57e21fe8:	e3a01000 	mov	r1, #0
57e21fec:	e59f206c 	ldr	r2, [pc, #108]	; 57e22060 <do_load+0x1d0>
57e21ff0:	eb00009e 	bl	57e22270 <print_size>
		puts(")");
57e21ff4:	e59f0068 	ldr	r0, [pc, #104]	; 57e22064 <do_load+0x1d4>
57e21ff8:	ebff9d09 	bl	57e09424 <puts>
	}
	puts("\n");
57e21ffc:	e59f0064 	ldr	r0, [pc, #100]	; 57e22068 <do_load+0x1d8>

	sprintf(buf, "0x%x", len_read);
57e22000:	e28d4004 	add	r4, sp, #4
	if (time > 0) {
		puts(" (");
		print_size(len_read / time * 1000, "/s");
		puts(")");
	}
	puts("\n");
57e22004:	ebff9d06 	bl	57e09424 <puts>

	sprintf(buf, "0x%x", len_read);
57e22008:	e59f105c 	ldr	r1, [pc, #92]	; 57e2206c <do_load+0x1dc>
57e2200c:	e1a02005 	mov	r2, r5
57e22010:	e1a00004 	mov	r0, r4
57e22014:	eb000ccb 	bl	57e25348 <sprintf>
	setenv("filesize", buf);
57e22018:	e59f0050 	ldr	r0, [pc, #80]	; 57e22070 <do_load+0x1e0>
57e2201c:	e1a01004 	mov	r1, r4
57e22020:	ebff94a2 	bl	57e072b0 <setenv>

	return 0;
57e22024:	e3a00000 	mov	r0, #0
57e22028:	ea000002 	b	57e22038 <do_load+0x1a8>
	unsigned long time;

	if (argc < 2)
		return CMD_RET_USAGE;
	if (argc > 7)
		return CMD_RET_USAGE;
57e2202c:	e3e00000 	mvn	r0, #0
57e22030:	ea000000 	b	57e22038 <do_load+0x1a8>

	time = get_timer(0);
	len_read = fs_read(filename, addr, pos, bytes);
	time = get_timer(time);
	if (len_read <= 0)
		return 1;
57e22034:	e3a00001 	mov	r0, #1

	sprintf(buf, "0x%x", len_read);
	setenv("filesize", buf);

	return 0;
}
57e22038:	e28dd010 	add	sp, sp, #16
57e2203c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	else
		bytes = 0;
	if (argc >= 7)
		pos = simple_strtoul(argv[6], NULL, cmdline_base);
	else
		pos = 0;
57e22040:	e3a07000 	mov	r7, #0
57e22044:	e1a06007 	mov	r6, r7
57e22048:	eaffffcb 	b	57e21f7c <do_load+0xec>
57e2204c:	57e2e096 	.word	0x57e2e096
57e22050:	57e2f001 	.word	0x57e2f001
57e22054:	57e353ba 	.word	0x57e353ba
57e22058:	57e353d6 	.word	0x57e353d6
57e2205c:	57e353ee 	.word	0x57e353ee
57e22060:	57e31548 	.word	0x57e31548
57e22064:	57e306f2 	.word	0x57e306f2
57e22068:	57e32390 	.word	0x57e32390
57e2206c:	57e353f1 	.word	0x57e353f1
57e22070:	57e2ea14 	.word	0x57e2ea14

57e22074 <do_ls>:
}

int do_ls(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
	int fstype)
{
	if (argc < 2)
57e22074:	e3520001 	cmp	r2, #1
	return 0;
}

int do_ls(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
	int fstype)
{
57e22078:	e92d4038 	push	{r3, r4, r5, lr}
57e2207c:	e1a04002 	mov	r4, r2
57e22080:	e1a05003 	mov	r5, r3
	if (argc < 2)
57e22084:	da000010 	ble	57e220cc <do_ls+0x58>
		return CMD_RET_USAGE;
	if (argc > 4)
57e22088:	e3520004 	cmp	r2, #4
57e2208c:	ca00000e 	bgt	57e220cc <do_ls+0x58>
		return CMD_RET_USAGE;

	if (fs_set_blk_dev(argv[1], (argc >= 3) ? argv[2] : NULL, fstype))
57e22090:	e3520002 	cmp	r2, #2
57e22094:	15931008 	ldrne	r1, [r3, #8]
57e22098:	03a01000 	moveq	r1, #0
57e2209c:	e5930004 	ldr	r0, [r3, #4]
57e220a0:	e59d2010 	ldr	r2, [sp, #16]
57e220a4:	ebffff02 	bl	57e21cb4 <fs_set_blk_dev>
57e220a8:	e3500000 	cmp	r0, #0
57e220ac:	1a000008 	bne	57e220d4 <do_ls+0x60>
		return 1;

	if (fs_ls(argc >= 4 ? argv[3] : "/"))
57e220b0:	e3540004 	cmp	r4, #4
57e220b4:	0595000c 	ldreq	r0, [r5, #12]
57e220b8:	159f001c 	ldrne	r0, [pc, #28]	; 57e220dc <do_ls+0x68>
57e220bc:	ebffff26 	bl	57e21d5c <fs_ls>

int do_ls(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
	int fstype)
{
	if (argc < 2)
		return CMD_RET_USAGE;
57e220c0:	e2500000 	subs	r0, r0, #0
57e220c4:	13a00001 	movne	r0, #1
57e220c8:	e8bd8038 	pop	{r3, r4, r5, pc}
	if (argc > 4)
		return CMD_RET_USAGE;
57e220cc:	e3e00000 	mvn	r0, #0
57e220d0:	e8bd8038 	pop	{r3, r4, r5, pc}

	if (fs_set_blk_dev(argv[1], (argc >= 3) ? argv[2] : NULL, fstype))
		return 1;
57e220d4:	e3a00001 	mov	r0, #1

	if (fs_ls(argc >= 4 ? argv[3] : "/"))
		return 1;

	return 0;
}
57e220d8:	e8bd8038 	pop	{r3, r4, r5, pc}
57e220dc:	57e352e2 	.word	0x57e352e2

57e220e0 <cyg_crc16>:
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
57e220e0:	e1a03000 	mov	r3, r0
    int i;
    uint16_t cksum;

    cksum = 0;
57e220e4:	e3a00000 	mov	r0, #0
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
57e220e8:	e92d4010 	push	{r4, lr}
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
57e220ec:	e1a02000 	mov	r2, r0
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
57e220f0:	e59fc02c 	ldr	ip, [pc, #44]	; 57e22124 <cyg_crc16+0x44>
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
57e220f4:	ea000007 	b	57e22118 <cyg_crc16+0x38>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
57e220f8:	e7d34002 	ldrb	r4, [r3, r2]
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
57e220fc:	e2822001 	add	r2, r2, #1
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
57e22100:	e0244420 	eor	r4, r4, r0, lsr #8
57e22104:	e1a04084 	lsl	r4, r4, #1
57e22108:	e19c40b4 	ldrh	r4, [ip, r4]
57e2210c:	e0240400 	eor	r0, r4, r0, lsl #8
57e22110:	e1a00800 	lsl	r0, r0, #16
57e22114:	e1a00820 	lsr	r0, r0, #16
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
57e22118:	e1520001 	cmp	r2, r1
57e2211c:	bafffff5 	blt	57e220f8 <cyg_crc16+0x18>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
    }
    return cksum;
}
57e22120:	e8bd8010 	pop	{r4, pc}
57e22124:	57e2cdd0 	.word	0x57e2cdd0

57e22128 <crc32_no_comp>:
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
57e22128:	e211c003 	ands	ip, r1, #3
57e2212c:	13a0c001 	movne	ip, #1
57e22130:	e3520000 	cmp	r2, #0
57e22134:	03a0c000 	moveq	ip, #0
57e22138:	120cc001 	andne	ip, ip, #1
57e2213c:	e35c0000 	cmp	ip, #0

/* No ones complement version. JFFS2 (and other things ?)
 * don't use ones compliment in their CRC calculations.
 */
uint32_t ZEXPORT crc32_no_comp(uint32_t crc, const Bytef *buf, uInt len)
{
57e22140:	e92d4070 	push	{r4, r5, r6, lr}
    const uint32_t *tab = crc_table;
    const uint32_t *b =(const uint32_t *)buf;
57e22144:	e1a03001 	mov	r3, r1
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
57e22148:	0a00000a 	beq	57e22178 <crc32_no_comp+0x50>
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
57e2214c:	e59f30b8 	ldr	r3, [pc, #184]	; 57e2220c <crc32_no_comp+0xe4>
57e22150:	e4d1c001 	ldrb	ip, [r1], #1
	 } while ((--len) && ((long)p)&3);
57e22154:	e2522001 	subs	r2, r2, #1
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
57e22158:	e020c00c 	eor	ip, r0, ip
57e2215c:	e20cc0ff 	and	ip, ip, #255	; 0xff
57e22160:	e793c10c 	ldr	ip, [r3, ip, lsl #2]
57e22164:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while ((--len) && ((long)p)&3);
57e22168:	0a000001 	beq	57e22174 <crc32_no_comp+0x4c>
57e2216c:	e3110003 	tst	r1, #3
57e22170:	1afffff6 	bne	57e22150 <crc32_no_comp+0x28>
	 b = (uint32_t *)p;
57e22174:	e1a03001 	mov	r3, r1
    }

    rem_len = len & 3;
57e22178:	e2025003 	and	r5, r2, #3
    len = len >> 2;
57e2217c:	e1a02122 	lsr	r2, r2, #2
    for (--b; len; --len) {
57e22180:	e2431004 	sub	r1, r3, #4
	 } while ((--len) && ((long)p)&3);
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
57e22184:	e1a04002 	mov	r4, r2
    for (--b; len; --len) {
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
	 DO_CRC(0);
57e22188:	e59fc07c 	ldr	ip, [pc, #124]	; 57e2220c <crc32_no_comp+0xe4>
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
57e2218c:	ea00000e 	b	57e221cc <crc32_no_comp+0xa4>
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
57e22190:	e4936004 	ldr	r6, [r3], #4
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
57e22194:	e2444001 	sub	r4, r4, #1
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
57e22198:	e0200006 	eor	r0, r0, r6
	 DO_CRC(0);
57e2219c:	e20060ff 	and	r6, r0, #255	; 0xff
57e221a0:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
57e221a4:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
57e221a8:	e20060ff 	and	r6, r0, #255	; 0xff
57e221ac:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
57e221b0:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
57e221b4:	e20060ff 	and	r6, r0, #255	; 0xff
57e221b8:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
57e221bc:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
57e221c0:	e20060ff 	and	r6, r0, #255	; 0xff
57e221c4:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
57e221c8:	e0260420 	eor	r0, r6, r0, lsr #8
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
57e221cc:	e3540000 	cmp	r4, #0
57e221d0:	1affffee 	bne	57e22190 <crc32_no_comp+0x68>
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
57e221d4:	e3550000 	cmp	r5, #0
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
57e221d8:	e0812102 	add	r2, r1, r2, lsl #2
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
57e221dc:	08bd8070 	popeq	{r4, r5, r6, pc}
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
57e221e0:	e59f1024 	ldr	r1, [pc, #36]	; 57e2220c <crc32_no_comp+0xe4>
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
57e221e4:	e2822003 	add	r2, r2, #3
57e221e8:	e1a03005 	mov	r3, r5
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
57e221ec:	e5f2c001 	ldrb	ip, [r2, #1]!
	 } while (--len);
57e221f0:	e2533001 	subs	r3, r3, #1
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
57e221f4:	e020c00c 	eor	ip, r0, ip
57e221f8:	e20cc0ff 	and	ip, ip, #255	; 0xff
57e221fc:	e791c10c 	ldr	ip, [r1, ip, lsl #2]
57e22200:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while (--len);
57e22204:	1afffff8 	bne	57e221ec <crc32_no_comp+0xc4>
    }

    return le32_to_cpu(crc);
}
57e22208:	e8bd8070 	pop	{r4, r5, r6, pc}
57e2220c:	57e2cfd0 	.word	0x57e2cfd0

57e22210 <crc32>:
#undef DO_CRC

uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *p, uInt len)
{
57e22210:	e92d4008 	push	{r3, lr}
     return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL;
57e22214:	e1e00000 	mvn	r0, r0
57e22218:	ebffffc2 	bl	57e22128 <crc32_no_comp>
}
57e2221c:	e1e00000 	mvn	r0, r0
57e22220:	e8bd8008 	pop	{r3, pc}

57e22224 <crc32_wd>:
		crc = crc32 (crc, curr, chunk);
		curr += chunk;
		WATCHDOG_RESET ();
	}
#else
	crc = crc32 (crc, buf, len);
57e22224:	eafffff9 	b	57e22210 <crc32>

57e22228 <crc7>:

extern const u8 crc7_syndrome_table[256];

static inline u8 crc7_byte(u8 crc, u8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
57e22228:	e59f301c 	ldr	r3, [pc, #28]	; 57e2224c <crc7+0x24>
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
57e2222c:	ea000003 	b	57e22240 <crc7+0x18>
		crc = crc7_byte(crc, *buffer++);
57e22230:	e4d1c001 	ldrb	ip, [r1], #1
57e22234:	e2422001 	sub	r2, r2, #1
57e22238:	e02c0080 	eor	r0, ip, r0, lsl #1
57e2223c:	e7d30000 	ldrb	r0, [r3, r0]
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
57e22240:	e3520000 	cmp	r2, #0
57e22244:	1afffff9 	bne	57e22230 <crc7+0x8>
		crc = crc7_byte(crc, *buffer++);
	return crc;
}
57e22248:	e12fff1e 	bx	lr
57e2224c:	57e2d3d0 	.word	0x57e2d3d0

57e22250 <display_options>:
#include <version.h>
#include <linux/ctype.h>
#include <asm/io.h>

int display_options (void)
{
57e22250:	e92d4008 	push	{r3, lr}
#if defined(BUILD_TAG)
	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
#else
	printf ("\n\n%s\n\n", version_string);
57e22254:	e59f100c 	ldr	r1, [pc, #12]	; 57e22268 <display_options+0x18>
57e22258:	e59f000c 	ldr	r0, [pc, #12]	; 57e2226c <display_options+0x1c>
57e2225c:	ebff9c7a 	bl	57e0944c <printf>
#endif
	return 0;
}
57e22260:	e3a00000 	mov	r0, #0
57e22264:	e8bd8008 	pop	{r3, pc}
57e22268:	57e2bdc0 	.word	0x57e2bdc0
57e2226c:	57e2e04c 	.word	0x57e2e04c

57e22270 <print_size>:
 * print sizes as "xxx KiB", "xxx.y KiB", "xxx MiB", "xxx.y MiB",
 * xxx GiB, xxx.y GiB, etc as needed; allow for optional trailing string
 * (like "\n")
 */
void print_size(unsigned long long size, const char *s)
{
57e22270:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
57e22274:	e1a06000 	mov	r6, r0
57e22278:	e1a07001 	mov	r7, r1
57e2227c:	e1a09002 	mov	r9, r2
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
57e22280:	e3a0a000 	mov	sl, #0
void print_size(unsigned long long size, const char *s)
{
	unsigned long m = 0, n;
	unsigned long long f;
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
57e22284:	e3a0403c 	mov	r4, #60	; 0x3c
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
		if (size >> d) {
57e22288:	e1a00006 	mov	r0, r6
57e2228c:	e1a01007 	mov	r1, r7
57e22290:	e1a02004 	mov	r2, r4
57e22294:	eb002658 	bl	57e2bbfc <__lshrdi3>
57e22298:	e1901001 	orrs	r1, r0, r1
57e2229c:	0a000004 	beq	57e222b4 <print_size+0x44>
			c = names[i];
57e222a0:	e59f30e4 	ldr	r3, [pc, #228]	; 57e2238c <print_size+0x11c>
57e222a4:	e7d3a00a 	ldrb	sl, [r3, sl]
			break;
		}
	}

	if (!c) {
57e222a8:	e35a0000 	cmp	sl, #0
57e222ac:	1a00000b 	bne	57e222e0 <print_size+0x70>
57e222b0:	ea000003 	b	57e222c4 <print_size+0x54>
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
57e222b4:	e28aa001 	add	sl, sl, #1
57e222b8:	e35a0006 	cmp	sl, #6
57e222bc:	1244400a 	subne	r4, r4, #10
57e222c0:	1afffff0 	bne	57e22288 <print_size+0x18>
			break;
		}
	}

	if (!c) {
		printf("%llu Bytes%s", size, s);
57e222c4:	e1a02006 	mov	r2, r6
57e222c8:	e1a03007 	mov	r3, r7
57e222cc:	e59f00bc 	ldr	r0, [pc, #188]	; 57e22390 <print_size+0x120>
57e222d0:	e58d9000 	str	r9, [sp]
57e222d4:	ebff9c5c 	bl	57e0944c <printf>
	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
}
57e222d8:	e28dd00c 	add	sp, sp, #12
57e222dc:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
	f = size & ((1ULL << d) - 1);
57e222e0:	e1a02004 	mov	r2, r4
	if (!c) {
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
57e222e4:	e1a05000 	mov	r5, r0
	f = size & ((1ULL << d) - 1);
57e222e8:	e3a01000 	mov	r1, #0
57e222ec:	e3a00001 	mov	r0, #1
57e222f0:	eb00264f 	bl	57e2bc34 <__ashldi3>
57e222f4:	e3e02000 	mvn	r2, #0
57e222f8:	e0922000 	adds	r2, r2, r0
57e222fc:	e3e03000 	mvn	r3, #0
57e22300:	e0a33001 	adc	r3, r3, r1
57e22304:	e0022006 	and	r2, r2, r6
57e22308:	e0033007 	and	r3, r3, r7

	/* If there's a remainder, deal with it */
	if (f) {
57e2230c:	e1921003 	orrs	r1, r2, r3
 * xxx GiB, xxx.y GiB, etc as needed; allow for optional trailing string
 * (like "\n")
 */
void print_size(unsigned long long size, const char *s)
{
	unsigned long m = 0, n;
57e22310:	01a04001 	moveq	r4, r1

	n = size >> d;
	f = size & ((1ULL << d) - 1);

	/* If there's a remainder, deal with it */
	if (f) {
57e22314:	0a00000e 	beq	57e22354 <print_size+0xe4>
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
57e22318:	e3a0100a 	mov	r1, #10
57e2231c:	e0876192 	umull	r6, r7, r2, r1
57e22320:	e3a00001 	mov	r0, #1
57e22324:	e0277391 	mla	r7, r1, r3, r7
57e22328:	e2442001 	sub	r2, r4, #1
57e2232c:	e3a01000 	mov	r1, #0
57e22330:	eb00263f 	bl	57e2bc34 <__ashldi3>
57e22334:	e0900006 	adds	r0, r0, r6
57e22338:	e0a11007 	adc	r1, r1, r7
57e2233c:	e1a02004 	mov	r2, r4
57e22340:	eb00262d 	bl	57e2bbfc <__lshrdi3>

		if (m >= 10) {
57e22344:	e3500009 	cmp	r0, #9
	n = size >> d;
	f = size & ((1ULL << d) - 1);

	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
57e22348:	e1a04000 	mov	r4, r0

		if (m >= 10) {
			m -= 10;
			n += 1;
57e2234c:	82855001 	addhi	r5, r5, #1
	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;

		if (m >= 10) {
			m -= 10;
57e22350:	8240400a 	subhi	r4, r0, #10
			n += 1;
		}
	}

	printf ("%lu", n);
57e22354:	e59f0038 	ldr	r0, [pc, #56]	; 57e22394 <print_size+0x124>
57e22358:	e1a01005 	mov	r1, r5
57e2235c:	ebff9c3a 	bl	57e0944c <printf>
	if (m) {
57e22360:	e3540000 	cmp	r4, #0
57e22364:	0a000002 	beq	57e22374 <print_size+0x104>
		printf (".%ld", m);
57e22368:	e59f0028 	ldr	r0, [pc, #40]	; 57e22398 <print_size+0x128>
57e2236c:	e1a01004 	mov	r1, r4
57e22370:	ebff9c35 	bl	57e0944c <printf>
	}
	printf (" %ciB%s", c, s);
57e22374:	e59f0020 	ldr	r0, [pc, #32]	; 57e2239c <print_size+0x12c>
57e22378:	e1a0100a 	mov	r1, sl
57e2237c:	e1a02009 	mov	r2, r9
}
57e22380:	e28dd00c 	add	sp, sp, #12
57e22384:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}

	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
57e22388:	eaff9c2f 	b	57e0944c <printf>
57e2238c:	57e2d5d0 	.word	0x57e2d5d0
57e22390:	57e353f6 	.word	0x57e353f6
57e22394:	57e35403 	.word	0x57e35403
57e22398:	57e35407 	.word	0x57e35407
57e2239c:	57e3540c 	.word	0x57e3540c

57e223a0 <print_buffer>:
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
57e223a0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e223a4:	e24dd050 	sub	sp, sp, #80	; 0x50
57e223a8:	e59d5070 	ldr	r5, [sp, #112]	; 0x70
57e223ac:	e1a07003 	mov	r7, r3
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
57e223b0:	e0030592 	mul	r3, r2, r5
57e223b4:	e3530040 	cmp	r3, #64	; 0x40
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
57e223b8:	e1a0b000 	mov	fp, r0
57e223bc:	e1a09001 	mov	r9, r1
57e223c0:	e1a04002 	mov	r4, r2
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
57e223c4:	9a000003 	bls	57e223d8 <print_buffer+0x38>
		linelen = MAX_LINE_LENGTH_BYTES / width;
57e223c8:	e3a00040 	mov	r0, #64	; 0x40
57e223cc:	e1a01002 	mov	r1, r2
57e223d0:	eb0024f6 	bl	57e2b7b0 <__udivsi3>
57e223d4:	e1a05000 	mov	r5, r0
	if (linelen < 1)
57e223d8:	e3550000 	cmp	r5, #0
57e223dc:	1a00003d 	bne	57e224d8 <print_buffer+0x138>
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;
57e223e0:	e3a00010 	mov	r0, #16
57e223e4:	e1a01004 	mov	r1, r4
57e223e8:	eb0024f0 	bl	57e2b7b0 <__udivsi3>
57e223ec:	e1a05000 	mov	r5, r0
57e223f0:	ea000038 	b	57e224d8 <print_buffer+0x138>

	while (count) {
		printf("%08lx:", addr);
57e223f4:	e59f0100 	ldr	r0, [pc, #256]	; 57e224fc <print_buffer+0x15c>
57e223f8:	e1a0100b 	mov	r1, fp
57e223fc:	ebff9c12 	bl	57e0944c <printf>
57e22400:	e1550007 	cmp	r5, r7
57e22404:	21a05007 	movcs	r5, r7
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
57e22408:	e1a0a009 	mov	sl, r9
57e2240c:	e3a06000 	mov	r6, #0
57e22410:	ea000011 	b	57e2245c <print_buffer+0xbc>
			uint32_t x;
			if (width == 4)
57e22414:	e3540004 	cmp	r4, #4
				x = lb.ui[i] = *(volatile uint32_t *)data;
57e22418:	059a2000 	ldreq	r2, [sl]
57e2241c:	028d300c 	addeq	r3, sp, #12
57e22420:	07832106 	streq	r2, [r3, r6, lsl #2]
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
57e22424:	0a000007 	beq	57e22448 <print_buffer+0xa8>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
57e22428:	e3540002 	cmp	r4, #2
				x = lb.us[i] = *(volatile uint16_t *)data;
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
57e2242c:	15da2000 	ldrbne	r2, [sl]
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
57e22430:	01da20b0 	ldrheq	r2, [sl]
57e22434:	e28d300c 	add	r3, sp, #12
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
57e22438:	01a01086 	lsleq	r1, r6, #1
			if (width == 4)
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
57e2243c:	120220ff 	andne	r2, r2, #255	; 0xff
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
57e22440:	018320b1 	strheq	r2, [r3, r1]
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
57e22444:	17c32006 	strbne	r2, [r3, r6]
			printf(" %0*x", width * 2, x);
57e22448:	e59f00b0 	ldr	r0, [pc, #176]	; 57e22500 <print_buffer+0x160>
57e2244c:	e59d1004 	ldr	r1, [sp, #4]
57e22450:	ebff9bfd 	bl	57e0944c <printf>
			data += width;
57e22454:	e08aa004 	add	sl, sl, r4
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
57e22458:	e2866001 	add	r6, r6, #1
57e2245c:	e1560005 	cmp	r6, r5
57e22460:	3affffeb 	bcc	57e22414 <print_buffer+0x74>
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
57e22464:	e0060594 	mul	r6, r4, r5
57e22468:	e28d300c 	add	r3, sp, #12
57e2246c:	e0899006 	add	r9, r9, r6
57e22470:	e0861003 	add	r1, r6, r3
57e22474:	ea000008 	b	57e2249c <print_buffer+0xfc>
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
57e22478:	e4d32001 	ldrb	r2, [r3], #1
57e2247c:	e59fc080 	ldr	ip, [pc, #128]	; 57e22504 <print_buffer+0x164>
57e22480:	e7dc0002 	ldrb	r0, [ip, r2]
57e22484:	e3100097 	tst	r0, #151	; 0x97
57e22488:	0a000001 	beq	57e22494 <print_buffer+0xf4>
57e2248c:	e3120080 	tst	r2, #128	; 0x80
57e22490:	0a000001 	beq	57e2249c <print_buffer+0xfc>
				lb.uc[i] = '.';
57e22494:	e3a0202e 	mov	r2, #46	; 0x2e
57e22498:	e5432001 	strb	r2, [r3, #-1]
			printf(" %0*x", width * 2, x);
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
57e2249c:	e1530001 	cmp	r3, r1
57e224a0:	1afffff4 	bne	57e22478 <print_buffer+0xd8>
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
				lb.uc[i] = '.';
		}
		lb.uc[i] = '\0';
57e224a4:	e28dc050 	add	ip, sp, #80	; 0x50
57e224a8:	e08c3006 	add	r3, ip, r6
57e224ac:	e3a02000 	mov	r2, #0
57e224b0:	e5432044 	strb	r2, [r3, #-68]	; 0x44
		printf("    %s\n", lb.uc);
57e224b4:	e28d100c 	add	r1, sp, #12
57e224b8:	e59f0048 	ldr	r0, [pc, #72]	; 57e22508 <print_buffer+0x168>
57e224bc:	ebff9be2 	bl	57e0944c <printf>

		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
57e224c0:	ebff9c06 	bl	57e094e0 <ctrlc>
57e224c4:	e3500000 	cmp	r0, #0
57e224c8:	1a000008 	bne	57e224f0 <print_buffer+0x150>
		}
		lb.uc[i] = '\0';
		printf("    %s\n", lb.uc);

		/* update references */
		addr += linelen * width;
57e224cc:	e08bb006 	add	fp, fp, r6
		count -= linelen;
57e224d0:	e0657007 	rsb	r7, r5, r7
57e224d4:	ea000001 	b	57e224e0 <print_buffer+0x140>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
			printf(" %0*x", width * 2, x);
57e224d8:	e1a03084 	lsl	r3, r4, #1
57e224dc:	e58d3004 	str	r3, [sp, #4]
	if (linelen*width > MAX_LINE_LENGTH_BYTES)
		linelen = MAX_LINE_LENGTH_BYTES / width;
	if (linelen < 1)
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;

	while (count) {
57e224e0:	e3570000 	cmp	r7, #0
57e224e4:	1affffc2 	bne	57e223f4 <print_buffer+0x54>

		if (ctrlc())
			return -1;
	}

	return 0;
57e224e8:	e1a00007 	mov	r0, r7
57e224ec:	ea000000 	b	57e224f4 <print_buffer+0x154>
		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
			return -1;
57e224f0:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
57e224f4:	e28dd050 	add	sp, sp, #80	; 0x50
57e224f8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e224fc:	57e303c6 	.word	0x57e303c6
57e22500:	57e35414 	.word	0x57e35414
57e22504:	57e2d4d0 	.word	0x57e2d4d0
57e22508:	57e3541a 	.word	0x57e3541a

57e2250c <__div64_32>:
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
57e2250c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	uint64_t rem = *n;
57e22510:	e89000c0 	ldm	r0, {r6, r7}
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
57e22514:	e1510007 	cmp	r1, r7
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
57e22518:	e1a09000 	mov	r9, r0
57e2251c:	e1a0a001 	mov	sl, r1
	uint64_t rem = *n;
	uint64_t b = base;
57e22520:	e1a04001 	mov	r4, r1
57e22524:	e3a05000 	mov	r5, #0
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
57e22528:	83a0b000 	movhi	fp, #0
57e2252c:	83a0c000 	movhi	ip, #0
	if (high >= base) {
57e22530:	8a000008 	bhi	57e22558 <__div64_32+0x4c>
		high /= base;
57e22534:	e1a00007 	mov	r0, r7
57e22538:	eb00249c 	bl	57e2b7b0 <__udivsi3>
		res = (uint64_t) high << 32;
57e2253c:	e3a03000 	mov	r3, #0
57e22540:	e1a0b003 	mov	fp, r3
		rem -= (uint64_t) (high*base) << 32;
57e22544:	e003009a 	mul	r3, sl, r0
57e22548:	e1a0200b 	mov	r2, fp

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
57e2254c:	e1a0c000 	mov	ip, r0
		rem -= (uint64_t) (high*base) << 32;
57e22550:	e0566002 	subs	r6, r6, r2
57e22554:	e0c77003 	sbc	r7, r7, r3
	uint64_t b = base;
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
57e22558:	e3a02001 	mov	r2, #1
57e2255c:	e3a03000 	mov	r3, #0
57e22560:	ea000003 	b	57e22574 <__div64_32+0x68>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
		b = b+b;
57e22564:	e0944004 	adds	r4, r4, r4
57e22568:	e0a55005 	adc	r5, r5, r5
		d = d+d;
57e2256c:	e0922002 	adds	r2, r2, r2
57e22570:	e0a33003 	adc	r3, r3, r3
		high /= base;
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
57e22574:	e1a01fc5 	asr	r1, r5, #31
57e22578:	e58d1000 	str	r1, [sp]
57e2257c:	e58d1004 	str	r1, [sp, #4]
57e22580:	e89d0003 	ldm	sp, {r0, r1}
57e22584:	e0500004 	subs	r0, r0, r4
57e22588:	e0c11005 	sbc	r1, r1, r5
57e2258c:	e1570005 	cmp	r7, r5
57e22590:	e1a00fa1 	lsr	r0, r1, #31
57e22594:	e3a01001 	mov	r1, #1
57e22598:	8a000003 	bhi	57e225ac <__div64_32+0xa0>
57e2259c:	1a000001 	bne	57e225a8 <__div64_32+0x9c>
57e225a0:	e1560004 	cmp	r6, r4
57e225a4:	8a000000 	bhi	57e225ac <__div64_32+0xa0>
57e225a8:	e3a01000 	mov	r1, #0
57e225ac:	e1100001 	tst	r0, r1
57e225b0:	1affffeb 	bne	57e22564 <__div64_32+0x58>
		b = b+b;
		d = d+d;
	}

	do {
		if (rem >= b) {
57e225b4:	e1550007 	cmp	r5, r7
57e225b8:	8a000006 	bhi	57e225d8 <__div64_32+0xcc>
57e225bc:	1a000001 	bne	57e225c8 <__div64_32+0xbc>
57e225c0:	e1540006 	cmp	r4, r6
57e225c4:	8a000003 	bhi	57e225d8 <__div64_32+0xcc>
			rem -= b;
57e225c8:	e0566004 	subs	r6, r6, r4
57e225cc:	e0c77005 	sbc	r7, r7, r5
			res += d;
57e225d0:	e09bb002 	adds	fp, fp, r2
57e225d4:	e0acc003 	adc	ip, ip, r3
		}
		b >>= 1;
		d >>= 1;
57e225d8:	e1b030a3 	lsrs	r3, r3, #1
57e225dc:	e1a02062 	rrx	r2, r2
	} while (d);
57e225e0:	e1921003 	orrs	r1, r2, r3
57e225e4:	0a000002 	beq	57e225f4 <__div64_32+0xe8>
	do {
		if (rem >= b) {
			rem -= b;
			res += d;
		}
		b >>= 1;
57e225e8:	e1b050a5 	lsrs	r5, r5, #1
57e225ec:	e1a04064 	rrx	r4, r4
57e225f0:	eaffffef 	b	57e225b4 <__div64_32+0xa8>
		d >>= 1;
	} while (d);

	*n = res;
57e225f4:	e8891800 	stm	r9, {fp, ip}
	return rem;
}
57e225f8:	e1a00006 	mov	r0, r6
57e225fc:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

57e22600 <gzfree>:
	return (p);
}

void gzfree(void *x, void *addr, unsigned nb)
{
	free (addr);
57e22600:	e1a00001 	mov	r0, r1
57e22604:	eaff9ce4 	b	57e0999c <free>

57e22608 <gzalloc>:

void *gzalloc(void *x, unsigned items, unsigned size)
{
	void *p;

	size *= items;
57e22608:	e0020291 	mul	r2, r1, r2
	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
57e2260c:	e282000f 	add	r0, r2, #15

	p = malloc (size);
57e22610:	e3c0000f 	bic	r0, r0, #15
57e22614:	eaff9d6a 	b	57e09bc4 <malloc>

57e22618 <zunzip>:
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
57e22618:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e2261c:	e1a04003 	mov	r4, r3
	z_stream s;
	int r;

	s.zalloc = gzalloc;
57e22620:	e59f30e4 	ldr	r3, [pc, #228]	; 57e2270c <zunzip+0xf4>
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
57e22624:	e24dd040 	sub	sp, sp, #64	; 0x40
	z_stream s;
	int r;

	s.zalloc = gzalloc;
57e22628:	e58d3024 	str	r3, [sp, #36]	; 0x24
	s.zfree = gzfree;
57e2262c:	e59f30dc 	ldr	r3, [pc, #220]	; 57e22710 <zunzip+0xf8>

	r = inflateInit2(&s, -MAX_WBITS);
57e22630:	e28da004 	add	sl, sp, #4
{
	z_stream s;
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;
57e22634:	e58d3028 	str	r3, [sp, #40]	; 0x28
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
57e22638:	e1a05000 	mov	r5, r0
57e2263c:	e1a07001 	mov	r7, r1
57e22640:	e1a09002 	mov	r9, r2
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
57e22644:	e3e0100e 	mvn	r1, #14
57e22648:	e1a0000a 	mov	r0, sl
57e2264c:	e59f20c0 	ldr	r2, [pc, #192]	; 57e22714 <zunzip+0xfc>
57e22650:	e3a0303c 	mov	r3, #60	; 0x3c
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
57e22654:	e59db060 	ldr	fp, [sp, #96]	; 0x60
57e22658:	e59d6064 	ldr	r6, [sp, #100]	; 0x64
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
57e2265c:	eb000e4c 	bl	57e25f94 <inflateInit2_>
	if (r != Z_OK) {
57e22660:	e2501000 	subs	r1, r0, #0
57e22664:	0a000002 	beq	57e22674 <zunzip+0x5c>
		printf ("Error: inflateInit2() returned %d\n", r);
57e22668:	e59f00a8 	ldr	r0, [pc, #168]	; 57e22718 <zunzip+0x100>
57e2266c:	ebff9b76 	bl	57e0944c <printf>
57e22670:	ea000013 	b	57e226c4 <zunzip+0xac>
		return -1;
	}
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
57e22674:	e5943000 	ldr	r3, [r4]
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
57e22678:	e0899006 	add	r9, r9, r6
	s.avail_in = *lenp - offset;
57e2267c:	e0663003 	rsb	r3, r6, r3
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
57e22680:	e58d9004 	str	r9, [sp, #4]
	s.avail_in = *lenp - offset;
57e22684:	e58d3008 	str	r3, [sp, #8]
	s.next_out = dst;
57e22688:	e58d5010 	str	r5, [sp, #16]
	s.avail_out = dstlen;
57e2268c:	e58d7014 	str	r7, [sp, #20]
	do {
		r = inflate(&s, Z_FINISH);
57e22690:	e3a01004 	mov	r1, #4
57e22694:	e1a0000a 	mov	r0, sl
57e22698:	eb000f5e 	bl	57e26418 <inflate>
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
57e2269c:	e3500001 	cmp	r0, #1
57e226a0:	13700005 	cmnne	r0, #5
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
	s.next_out = dst;
	s.avail_out = dstlen;
	do {
		r = inflate(&s, Z_FINISH);
57e226a4:	e1a01000 	mov	r1, r0
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
57e226a8:	0a000007 	beq	57e226cc <zunzip+0xb4>
57e226ac:	e35b0001 	cmp	fp, #1
57e226b0:	1a000005 	bne	57e226cc <zunzip+0xb4>
			printf("Error: inflate() returned %d\n", r);
57e226b4:	e59f0060 	ldr	r0, [pc, #96]	; 57e2271c <zunzip+0x104>
57e226b8:	ebff9b63 	bl	57e0944c <printf>
			inflateEnd(&s);
57e226bc:	e1a0000a 	mov	r0, sl
57e226c0:	eb000e7a 	bl	57e260b0 <inflateEnd>
			return -1;
57e226c4:	e3e00000 	mvn	r0, #0
57e226c8:	ea00000d 	b	57e22704 <zunzip+0xec>
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
57e226cc:	e59d3010 	ldr	r3, [sp, #16]
57e226d0:	e5942000 	ldr	r2, [r4]
57e226d4:	e0630005 	rsb	r0, r3, r5
57e226d8:	e0802002 	add	r2, r0, r2
57e226dc:	e0662002 	rsb	r2, r6, r2
		s.avail_out = dstlen;
	} while (r == Z_BUF_ERROR);
57e226e0:	e3710005 	cmn	r1, #5
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
			printf("Error: inflate() returned %d\n", r);
			inflateEnd(&s);
			return -1;
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
57e226e4:	e58d2008 	str	r2, [sp, #8]
		s.avail_out = dstlen;
57e226e8:	e58d7014 	str	r7, [sp, #20]
	} while (r == Z_BUF_ERROR);
57e226ec:	0affffe7 	beq	57e22690 <zunzip+0x78>
	*lenp = s.next_out - (unsigned char *) dst;
57e226f0:	e0655003 	rsb	r5, r5, r3
57e226f4:	e5845000 	str	r5, [r4]
	inflateEnd(&s);
57e226f8:	e28d0004 	add	r0, sp, #4
57e226fc:	eb000e6b 	bl	57e260b0 <inflateEnd>

	return 0;
57e22700:	e3a00000 	mov	r0, #0
}
57e22704:	e28dd040 	add	sp, sp, #64	; 0x40
57e22708:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e2270c:	57e22608 	.word	0x57e22608
57e22710:	57e22600 	.word	0x57e22600
57e22714:	57e35422 	.word	0x57e35422
57e22718:	57e35428 	.word	0x57e35428
57e2271c:	57e3544b 	.word	0x57e3544b

57e22720 <gunzip>:
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
57e22720:	e5d2c002 	ldrb	ip, [r2, #2]
{
	free (addr);
}

int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
57e22724:	e92d4013 	push	{r0, r1, r4, lr}
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
57e22728:	e35c0008 	cmp	ip, #8
{
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
57e2272c:	e5d2e003 	ldrb	lr, [r2, #3]
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
57e22730:	1a000001 	bne	57e2273c <gunzip+0x1c>
57e22734:	e31e00e0 	tst	lr, #224	; 0xe0
57e22738:	0a000001 	beq	57e22744 <gunzip+0x24>
		puts ("Error: Bad gzipped data\n");
57e2273c:	e59f0080 	ldr	r0, [pc, #128]	; 57e227c4 <gunzip+0xa4>
57e22740:	ea000017 	b	57e227a4 <gunzip+0x84>
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
57e22744:	e31e0004 	tst	lr, #4
		i = 12 + src[10] + (src[11] << 8);
57e22748:	15d2c00a 	ldrbne	ip, [r2, #10]
57e2274c:	15d2400b 	ldrbne	r4, [r2, #11]
57e22750:	128cc00c 	addne	ip, ip, #12
57e22754:	108cc404 	addne	ip, ip, r4, lsl #8
int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
	int i, flags;

	/* skip header */
	i = 10;
57e22758:	03a0c00a 	moveq	ip, #10
		puts ("Error: Bad gzipped data\n");
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
		i = 12 + src[10] + (src[11] << 8);
	if ((flags & ORIG_NAME) != 0)
57e2275c:	e31e0008 	tst	lr, #8
57e22760:	0a000003 	beq	57e22774 <gunzip+0x54>
		while (src[i++] != 0)
57e22764:	e7d2400c 	ldrb	r4, [r2, ip]
57e22768:	e28cc001 	add	ip, ip, #1
57e2276c:	e3540000 	cmp	r4, #0
57e22770:	1afffffb 	bne	57e22764 <gunzip+0x44>
			;
	if ((flags & COMMENT) != 0)
57e22774:	e31e0010 	tst	lr, #16
57e22778:	0a000003 	beq	57e2278c <gunzip+0x6c>
		while (src[i++] != 0)
57e2277c:	e7d2400c 	ldrb	r4, [r2, ip]
57e22780:	e28cc001 	add	ip, ip, #1
57e22784:	e3540000 	cmp	r4, #0
57e22788:	1afffffb 	bne	57e2277c <gunzip+0x5c>
			;
	if ((flags & HEAD_CRC) != 0)
57e2278c:	e31e0002 	tst	lr, #2
		i += 2;
	if (i >= *lenp) {
57e22790:	e593e000 	ldr	lr, [r3]
			;
	if ((flags & COMMENT) != 0)
		while (src[i++] != 0)
			;
	if ((flags & HEAD_CRC) != 0)
		i += 2;
57e22794:	128cc002 	addne	ip, ip, #2
	if (i >= *lenp) {
57e22798:	e15c000e 	cmp	ip, lr
57e2279c:	3a000003 	bcc	57e227b0 <gunzip+0x90>
		puts ("Error: gunzip out of data in header\n");
57e227a0:	e59f0020 	ldr	r0, [pc, #32]	; 57e227c8 <gunzip+0xa8>
57e227a4:	ebff9b1e 	bl	57e09424 <puts>
		return (-1);
57e227a8:	e3e00000 	mvn	r0, #0
57e227ac:	ea000003 	b	57e227c0 <gunzip+0xa0>
	}

	return zunzip(dst, dstlen, src, lenp, 1, i);
57e227b0:	e3a0e001 	mov	lr, #1
57e227b4:	e58de000 	str	lr, [sp]
57e227b8:	e58dc004 	str	ip, [sp, #4]
57e227bc:	ebffff95 	bl	57e22618 <zunzip>
}
57e227c0:	e8bd801c 	pop	{r2, r3, r4, pc}
57e227c4:	57e35469 	.word	0x57e35469
57e227c8:	57e35482 	.word	0x57e35482

57e227cc <drop_var_from_set>:
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
57e227cc:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
57e227d0:	e251a000 	subs	sl, r1, #0
57e227d4:	13a05000 	movne	r5, #0
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
57e227d8:	e1a04000 	mov	r4, r0
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
57e227dc:	11a07002 	movne	r7, r2
57e227e0:	11a06005 	movne	r6, r5
57e227e4:	1a000009 	bne	57e22810 <drop_var_from_set+0x44>
57e227e8:	ea00000b 	b	57e2281c <drop_var_from_set+0x50>
		return 1;

	for (i = 0; i < nvars; i++) {
		if (vars[i] == NULL)
57e227ec:	e4971004 	ldr	r1, [r7], #4
57e227f0:	e3510000 	cmp	r1, #0
57e227f4:	0a000004 	beq	57e2280c <drop_var_from_set+0x40>
			continue;
		/* If we found it, delete all of them */
		if (!strcmp(name, vars[i])) {
57e227f8:	e1a00004 	mov	r0, r4
57e227fc:	eb0005e8 	bl	57e23fa4 <strcmp>
57e22800:	e3500000 	cmp	r0, #0
			vars[i] = NULL;
57e22804:	05070004 	streq	r0, [r7, #-4]
			res = 1;
57e22808:	03a05001 	moveq	r5, #1

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;

	for (i = 0; i < nvars; i++) {
57e2280c:	e2866001 	add	r6, r6, #1
57e22810:	e156000a 	cmp	r6, sl
57e22814:	bafffff4 	blt	57e227ec <drop_var_from_set+0x20>
57e22818:	ea000000 	b	57e22820 <drop_var_from_set+0x54>
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;
57e2281c:	e3a05001 	mov	r5, #1
	}
	if (!res)
		debug("Skipping non-listed variable %s\n", name);

	return res;
}
57e22820:	e1a00005 	mov	r0, r5
57e22824:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

57e22828 <cmpkey>:
static int cmpkey(const void *p1, const void *p2)
{
	ENTRY *e1 = *(ENTRY **) p1;
	ENTRY *e2 = *(ENTRY **) p2;

	return (strcmp(e1->key, e2->key));
57e22828:	e5902000 	ldr	r2, [r0]
57e2282c:	e5913000 	ldr	r3, [r1]
57e22830:	e5920000 	ldr	r0, [r2]
57e22834:	e5931000 	ldr	r1, [r3]
57e22838:	ea0005d9 	b	57e23fa4 <strcmp>

57e2283c <hcreate_r>:
 * The contents of the table is zeroed, especially the field used
 * becomes zero.
 */

int hcreate_r(size_t nel, struct hsearch_data *htab)
{
57e2283c:	e92d4070 	push	{r4, r5, r6, lr}
	/* Test for correct arguments.  */
	if (htab == NULL) {
57e22840:	e2516000 	subs	r6, r1, #0
57e22844:	1a000004 	bne	57e2285c <hcreate_r+0x20>
		__set_errno(EINVAL);
57e22848:	e59f3094 	ldr	r3, [pc, #148]	; 57e228e4 <hcreate_r+0xa8>
57e2284c:	e3a02016 	mov	r2, #22
57e22850:	e5832000 	str	r2, [r3]
		return 0;
57e22854:	e1a00006 	mov	r0, r6
57e22858:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
57e2285c:	e5963000 	ldr	r3, [r6]
57e22860:	e3530000 	cmp	r3, #0
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
57e22864:	03804001 	orreq	r4, r0, #1
		__set_errno(EINVAL);
		return 0;
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
57e22868:	1a00001b 	bne	57e228dc <hcreate_r+0xa0>
57e2286c:	ea000000 	b	57e22874 <hcreate_r+0x38>
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;
57e22870:	e2844002 	add	r4, r4, #2
 * b)  the number is small because the table must fit in the core
 * */
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;
57e22874:	e3a05003 	mov	r5, #3
57e22878:	ea000000 	b	57e22880 <hcreate_r+0x44>

	while (div * div < number && number % div != 0)
		div += 2;
57e2287c:	e2855002 	add	r5, r5, #2
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;

	while (div * div < number && number % div != 0)
57e22880:	e0030595 	mul	r3, r5, r5
57e22884:	e1530004 	cmp	r3, r4
57e22888:	2a000004 	bcs	57e228a0 <hcreate_r+0x64>
57e2288c:	e1a00004 	mov	r0, r4
57e22890:	e1a01005 	mov	r1, r5
57e22894:	eb002440 	bl	57e2b99c <__aeabi_uidivmod>
57e22898:	e3510000 	cmp	r1, #0
57e2289c:	1afffff6 	bne	57e2287c <hcreate_r+0x40>
		div += 2;

	return number % div != 0;
57e228a0:	e1a00004 	mov	r0, r4
57e228a4:	e1a01005 	mov	r1, r5
57e228a8:	eb00243b 	bl	57e2b99c <__aeabi_uidivmod>
	if (htab->table != NULL)
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
57e228ac:	e3510000 	cmp	r1, #0
57e228b0:	0affffee 	beq	57e22870 <hcreate_r+0x34>
		nel += 2;

	htab->size = nel;
	htab->filled = 0;
57e228b4:	e3a03000 	mov	r3, #0
	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;

	htab->size = nel;
57e228b8:	e5864004 	str	r4, [r6, #4]
	htab->filled = 0;
57e228bc:	e5863008 	str	r3, [r6, #8]

	/* allocate memory and zero out */
	htab->table = (_ENTRY *) calloc(htab->size + 1, sizeof(_ENTRY));
57e228c0:	e2840001 	add	r0, r4, #1
57e228c4:	e3a01014 	mov	r1, #20
57e228c8:	ebff9e2b 	bl	57e0a17c <calloc>
57e228cc:	e5860000 	str	r0, [r6]
int hcreate_r(size_t nel, struct hsearch_data *htab)
{
	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
		return 0;
57e228d0:	e2500000 	subs	r0, r0, #0
57e228d4:	13a00001 	movne	r0, #1
57e228d8:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
		return 0;
57e228dc:	e3a00000 	mov	r0, #0
	if (htab->table == NULL)
		return 0;

	/* everything went alright */
	return 1;
}
57e228e0:	e8bd8070 	pop	{r4, r5, r6, pc}
57e228e4:	57e79098 	.word	0x57e79098

57e228e8 <hdestroy_r>:
 * After using the hash table it has to be destroyed. The used memory can
 * be freed and the local static variable can be marked as not used.
 */

void hdestroy_r(struct hsearch_data *htab)
{
57e228e8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
57e228ec:	e2504000 	subs	r4, r0, #0
57e228f0:	13a05014 	movne	r5, #20
57e228f4:	13a06001 	movne	r6, #1
57e228f8:	1a00000e 	bne	57e22938 <hdestroy_r+0x50>
		__set_errno(EINVAL);
57e228fc:	e59f3054 	ldr	r3, [pc, #84]	; 57e22958 <hdestroy_r+0x70>
57e22900:	e3a02016 	mov	r2, #22
57e22904:	e5832000 	str	r2, [r3]
		return;
57e22908:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
		if (htab->table[i].used > 0) {
57e2290c:	e5943000 	ldr	r3, [r4]
57e22910:	e0837005 	add	r7, r3, r5
57e22914:	e7933005 	ldr	r3, [r3, r5]
57e22918:	e3530000 	cmp	r3, #0
57e2291c:	da000003 	ble	57e22930 <hdestroy_r+0x48>
			ENTRY *ep = &htab->table[i].entry;

			free((void *)ep->key);
57e22920:	e5970004 	ldr	r0, [r7, #4]
57e22924:	ebff9c1c 	bl	57e0999c <free>
			free(ep->data);
57e22928:	e5970008 	ldr	r0, [r7, #8]
57e2292c:	ebff9c1a 	bl	57e0999c <free>
		__set_errno(EINVAL);
		return;
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
57e22930:	e2866001 	add	r6, r6, #1
57e22934:	e2855014 	add	r5, r5, #20
57e22938:	e5943004 	ldr	r3, [r4, #4]
57e2293c:	e1560003 	cmp	r6, r3
57e22940:	9afffff1 	bls	57e2290c <hdestroy_r+0x24>

			free((void *)ep->key);
			free(ep->data);
		}
	}
	free(htab->table);
57e22944:	e5940000 	ldr	r0, [r4]
57e22948:	ebff9c13 	bl	57e0999c <free>

	/* the sign for an existing table is an value != NULL in htable */
	htab->table = NULL;
57e2294c:	e3a03000 	mov	r3, #0
57e22950:	e5843000 	str	r3, [r4]
57e22954:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e22958:	57e79098 	.word	0x57e79098

57e2295c <hstrstr_r>:
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
57e2295c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
57e22960:	e2817001 	add	r7, r1, #1
57e22964:	e3a06014 	mov	r6, #20
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
57e22968:	e1a04000 	mov	r4, r0
57e2296c:	e1a05002 	mov	r5, r2
57e22970:	e1a0a003 	mov	sl, r3
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
57e22974:	e0060697 	mul	r6, r7, r6
57e22978:	ea000018 	b	57e229e0 <hstrstr_r+0x84>
		if (htab->table[idx].used <= 0)
57e2297c:	e59a3000 	ldr	r3, [sl]
57e22980:	e0832006 	add	r2, r3, r6
57e22984:	e7933006 	ldr	r3, [r3, r6]
57e22988:	e3530000 	cmp	r3, #0
57e2298c:	da000011 	ble	57e229d8 <hstrstr_r+0x7c>
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
57e22990:	e5920004 	ldr	r0, [r2, #4]
57e22994:	e1a01004 	mov	r1, r4
57e22998:	eb0006a6 	bl	57e24438 <strstr>
57e2299c:	e3500000 	cmp	r0, #0
57e229a0:	1a000006 	bne	57e229c0 <hstrstr_r+0x64>
		    strstr(htab->table[idx].entry.data, match)) {
57e229a4:	e59a3000 	ldr	r3, [sl]
57e229a8:	e1a01004 	mov	r1, r4
57e229ac:	e0833006 	add	r3, r3, r6
57e229b0:	e5930008 	ldr	r0, [r3, #8]
57e229b4:	eb00069f 	bl	57e24438 <strstr>
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
57e229b8:	e3500000 	cmp	r0, #0
57e229bc:	0a000005 	beq	57e229d8 <hstrstr_r+0x7c>
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
57e229c0:	e59a3000 	ldr	r3, [sl]
			return idx;
57e229c4:	e1a00007 	mov	r0, r7
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
57e229c8:	e0836006 	add	r6, r3, r6
57e229cc:	e2866004 	add	r6, r6, #4
57e229d0:	e5856000 	str	r6, [r5]
			return idx;
57e229d4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
57e229d8:	e2877001 	add	r7, r7, #1
57e229dc:	e2866014 	add	r6, r6, #20
57e229e0:	e59a3004 	ldr	r3, [sl, #4]
57e229e4:	e1570003 	cmp	r7, r3
57e229e8:	3affffe3 	bcc	57e2297c <hstrstr_r+0x20>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
57e229ec:	e59f3010 	ldr	r3, [pc, #16]	; 57e22a04 <hstrstr_r+0xa8>
57e229f0:	e3a02003 	mov	r2, #3
	*retval = NULL;
57e229f4:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
57e229f8:	e5832000 	str	r2, [r3]
	*retval = NULL;
57e229fc:	e5850000 	str	r0, [r5]
	return 0;
}
57e22a00:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e22a04:	57e79098 	.word	0x57e79098

57e22a08 <hmatch_r>:

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
57e22a08:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
57e22a0c:	e1a05001 	mov	r5, r1
57e22a10:	e1a09000 	mov	r9, r0
57e22a14:	e1a04002 	mov	r4, r2
57e22a18:	e1a07003 	mov	r7, r3
	unsigned int idx;
	size_t key_len = strlen(match);
57e22a1c:	eb00058b 	bl	57e24050 <strlen>

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
57e22a20:	e2855001 	add	r5, r5, #1
57e22a24:	e3a06014 	mov	r6, #20

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);
57e22a28:	e1a0a000 	mov	sl, r0

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
57e22a2c:	e0060695 	mul	r6, r5, r6
57e22a30:	ea000012 	b	57e22a80 <hmatch_r+0x78>
		if (htab->table[idx].used <= 0)
57e22a34:	e5972000 	ldr	r2, [r7]
57e22a38:	e0823006 	add	r3, r2, r6
57e22a3c:	e7922006 	ldr	r2, [r2, r6]
57e22a40:	e3520000 	cmp	r2, #0
57e22a44:	da00000b 	ble	57e22a78 <hmatch_r+0x70>
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
57e22a48:	e1a00009 	mov	r0, r9
57e22a4c:	e5931004 	ldr	r1, [r3, #4]
57e22a50:	e1a0200a 	mov	r2, sl
57e22a54:	eb00055e 	bl	57e23fd4 <strncmp>
57e22a58:	e3500000 	cmp	r0, #0
57e22a5c:	1a000005 	bne	57e22a78 <hmatch_r+0x70>
			*retval = &htab->table[idx].entry;
57e22a60:	e5973000 	ldr	r3, [r7]
			return idx;
57e22a64:	e1a00005 	mov	r0, r5

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
			*retval = &htab->table[idx].entry;
57e22a68:	e0836006 	add	r6, r3, r6
57e22a6c:	e2866004 	add	r6, r6, #4
57e22a70:	e5846000 	str	r6, [r4]
			return idx;
57e22a74:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
57e22a78:	e2855001 	add	r5, r5, #1
57e22a7c:	e2866014 	add	r6, r6, #20
57e22a80:	e5973004 	ldr	r3, [r7, #4]
57e22a84:	e1550003 	cmp	r5, r3
57e22a88:	3affffe9 	bcc	57e22a34 <hmatch_r+0x2c>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
57e22a8c:	e59f3010 	ldr	r3, [pc, #16]	; 57e22aa4 <hmatch_r+0x9c>
57e22a90:	e3a02003 	mov	r2, #3
	*retval = NULL;
57e22a94:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
57e22a98:	e5832000 	str	r2, [r3]
	*retval = NULL;
57e22a9c:	e5840000 	str	r0, [r4]
	return 0;
}
57e22aa0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
57e22aa4:	57e79098 	.word	0x57e79098

57e22aa8 <hsearch_r>:
	return -1;
}

int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab, int flag)
{
57e22aa8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e22aac:	e24dd020 	sub	sp, sp, #32
57e22ab0:	e28dc010 	add	ip, sp, #16
57e22ab4:	e88c000f 	stm	ip, {r0, r1, r2, r3}
57e22ab8:	e59d7044 	ldr	r7, [sp, #68]	; 0x44
57e22abc:	e59d4048 	ldr	r4, [sp, #72]	; 0x48
			    &htab->table[idx].entry, item.data,
			    env_op_overwrite, flag)) {
				debug("change_ok() rejected setting variable "
					"%s, skipping it!\n", item.key);
				__set_errno(EPERM);
				*retval = NULL;
57e22ac0:	e58d0004 	str	r0, [sp, #4]
57e22ac4:	e59d9014 	ldr	r9, [sp, #20]
int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab, int flag)
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
57e22ac8:	eb000560 	bl	57e24050 <strlen>
57e22acc:	e1a0a000 	mov	sl, r0
	int ret;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
57e22ad0:	ea000003 	b	57e22ae4 <hsearch_r+0x3c>
		hval <<= 4;
		hval += item.key[count];
57e22ad4:	e59d2004 	ldr	r2, [sp, #4]
	int ret;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
57e22ad8:	e24aa001 	sub	sl, sl, #1
		hval <<= 4;
		hval += item.key[count];
57e22adc:	e7d2300a 	ldrb	r3, [r2, sl]
57e22ae0:	e0830200 	add	r0, r3, r0, lsl #4
	int ret;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
57e22ae4:	e35a0000 	cmp	sl, #0
57e22ae8:	1afffff9 	bne	57e22ad4 <hsearch_r+0x2c>

	/*
	 * First hash function:
	 * simply take the modul but prevent zero.
	 */
	hval %= htab->size;
57e22aec:	e5941004 	ldr	r1, [r4, #4]
57e22af0:	eb0023a9 	bl	57e2b99c <__aeabi_uidivmod>
	if (hval == 0)
		++hval;
57e22af4:	e3510000 	cmp	r1, #0
57e22af8:	11a0b001 	movne	fp, r1
57e22afc:	03a0b001 	moveq	fp, #1

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
57e22b00:	e3a06014 	mov	r6, #20
57e22b04:	e006069b 	mul	r6, fp, r6
57e22b08:	e5942000 	ldr	r2, [r4]
57e22b0c:	e7925006 	ldr	r5, [r2, r6]
57e22b10:	e0823006 	add	r3, r2, r6
57e22b14:	e3550000 	cmp	r5, #0
57e22b18:	01a0600b 	moveq	r6, fp
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
57e22b1c:	058da008 	streq	sl, [sp, #8]
		++hval;

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
57e22b20:	0a0000a5 	beq	57e22dbc <hsearch_r+0x314>
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
57e22b24:	e3750001 	cmn	r5, #1
57e22b28:	01a0200b 	moveq	r2, fp
57e22b2c:	13a02000 	movne	r2, #0
 */
static inline int _compare_and_overwrite_entry(ENTRY item, ACTION action,
	ENTRY **retval, struct hsearch_data *htab, int flag,
	unsigned int hval, unsigned int idx)
{
	if (htab->table[idx].used == hval
57e22b30:	e155000b 	cmp	r5, fp
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
57e22b34:	e58d2008 	str	r2, [sp, #8]
 */
static inline int _compare_and_overwrite_entry(ENTRY item, ACTION action,
	ENTRY **retval, struct hsearch_data *htab, int flag,
	unsigned int hval, unsigned int idx)
{
	if (htab->table[idx].used == hval
57e22b38:	1a000041 	bne	57e22c44 <hsearch_r+0x19c>
	    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
57e22b3c:	e59d0004 	ldr	r0, [sp, #4]
57e22b40:	e5931004 	ldr	r1, [r3, #4]
57e22b44:	eb000516 	bl	57e23fa4 <strcmp>
57e22b48:	e3500000 	cmp	r0, #0
57e22b4c:	1a00003c 	bne	57e22c44 <hsearch_r+0x19c>
		/* Overwrite existing value? */
		if ((action == ENTER) && (item.data != NULL)) {
57e22b50:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
57e22b54:	e3530001 	cmp	r3, #1
57e22b58:	1a000033 	bne	57e22c2c <hsearch_r+0x184>
57e22b5c:	e3590000 	cmp	r9, #0
57e22b60:	0a000031 	beq	57e22c2c <hsearch_r+0x184>
			/* check for permission */
			if (htab->change_ok != NULL && htab->change_ok(
57e22b64:	e594c00c 	ldr	ip, [r4, #12]
57e22b68:	e35c0000 	cmp	ip, #0
57e22b6c:	0a00000e 	beq	57e22bac <hsearch_r+0x104>
			    &htab->table[idx].entry, item.data,
57e22b70:	e5940000 	ldr	r0, [r4]
	if (htab->table[idx].used == hval
	    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
		/* Overwrite existing value? */
		if ((action == ENTER) && (item.data != NULL)) {
			/* check for permission */
			if (htab->change_ok != NULL && htab->change_ok(
57e22b74:	e1a01009 	mov	r1, r9
			    &htab->table[idx].entry, item.data,
57e22b78:	e0800006 	add	r0, r0, r6
	if (htab->table[idx].used == hval
	    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
		/* Overwrite existing value? */
		if ((action == ENTER) && (item.data != NULL)) {
			/* check for permission */
			if (htab->change_ok != NULL && htab->change_ok(
57e22b7c:	e2800004 	add	r0, r0, #4
57e22b80:	e3a02002 	mov	r2, #2
57e22b84:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
57e22b88:	e12fff3c 	blx	ip
57e22b8c:	e3500000 	cmp	r0, #0
57e22b90:	0a000005 	beq	57e22bac <hsearch_r+0x104>
			    &htab->table[idx].entry, item.data,
			    env_op_overwrite, flag)) {
				debug("change_ok() rejected setting variable "
					"%s, skipping it!\n", item.key);
				__set_errno(EPERM);
57e22b94:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
57e22b98:	e59f33e8 	ldr	r3, [pc, #1000]	; 57e22f88 <hsearch_r+0x4e0>
				*retval = NULL;
57e22b9c:	e1a0500a 	mov	r5, sl
			if (htab->change_ok != NULL && htab->change_ok(
			    &htab->table[idx].entry, item.data,
			    env_op_overwrite, flag)) {
				debug("change_ok() rejected setting variable "
					"%s, skipping it!\n", item.key);
				__set_errno(EPERM);
57e22ba0:	e5832000 	str	r2, [r3]
				*retval = NULL;
57e22ba4:	e587a000 	str	sl, [r7]
57e22ba8:	ea0000f3 	b	57e22f7c <hsearch_r+0x4d4>
				return 0;
			}

			/* If there is a callback, call it */
			if (htab->table[idx].entry.callback &&
57e22bac:	e5943000 	ldr	r3, [r4]
57e22bb0:	e0833006 	add	r3, r3, r6
57e22bb4:	e593c00c 	ldr	ip, [r3, #12]
57e22bb8:	e35c0000 	cmp	ip, #0
57e22bbc:	0a000006 	beq	57e22bdc <hsearch_r+0x134>
			    htab->table[idx].entry.callback(item.key,
57e22bc0:	e59d0004 	ldr	r0, [sp, #4]
57e22bc4:	e1a01009 	mov	r1, r9
57e22bc8:	e3a02002 	mov	r2, #2
57e22bcc:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
57e22bd0:	e12fff3c 	blx	ip
				*retval = NULL;
				return 0;
			}

			/* If there is a callback, call it */
			if (htab->table[idx].entry.callback &&
57e22bd4:	e3500000 	cmp	r0, #0
57e22bd8:	1a000056 	bne	57e22d38 <hsearch_r+0x290>
				__set_errno(EINVAL);
				*retval = NULL;
				return 0;
			}

			free(htab->table[idx].entry.data);
57e22bdc:	e5943000 	ldr	r3, [r4]
57e22be0:	e0833006 	add	r3, r3, r6
57e22be4:	e5930008 	ldr	r0, [r3, #8]
57e22be8:	ebff9b6b 	bl	57e0999c <free>
			htab->table[idx].entry.data = strdup(item.data);
57e22bec:	e1a00009 	mov	r0, r9
57e22bf0:	e594a000 	ldr	sl, [r4]
57e22bf4:	eb000535 	bl	57e240d0 <strdup>
			if (!htab->table[idx].entry.data) {
57e22bf8:	e5943000 	ldr	r3, [r4]
				*retval = NULL;
				return 0;
			}

			free(htab->table[idx].entry.data);
			htab->table[idx].entry.data = strdup(item.data);
57e22bfc:	e08aa006 	add	sl, sl, r6
57e22c00:	e58a0008 	str	r0, [sl, #8]
			if (!htab->table[idx].entry.data) {
57e22c04:	e0833006 	add	r3, r3, r6
57e22c08:	e5933008 	ldr	r3, [r3, #8]
57e22c0c:	e3530000 	cmp	r3, #0
57e22c10:	1a000005 	bne	57e22c2c <hsearch_r+0x184>
				__set_errno(ENOMEM);
57e22c14:	e59f236c 	ldr	r2, [pc, #876]	; 57e22f88 <hsearch_r+0x4e0>
57e22c18:	e3a0100c 	mov	r1, #12
57e22c1c:	e5821000 	str	r1, [r2]
				*retval = NULL;
57e22c20:	e1a05003 	mov	r5, r3
57e22c24:	e5873000 	str	r3, [r7]
57e22c28:	ea0000d3 	b	57e22f7c <hsearch_r+0x4d4>
				return 0;
			}
		}
		/* return found entry */
		*retval = &htab->table[idx].entry;
57e22c2c:	e5943000 	ldr	r3, [r4]
		    && !first_deleted)
			first_deleted = idx;

		ret = _compare_and_overwrite_entry(item, action, retval, htab,
			flag, hval, idx);
		if (ret != -1)
57e22c30:	e3750001 	cmn	r5, #1
				*retval = NULL;
				return 0;
			}
		}
		/* return found entry */
		*retval = &htab->table[idx].entry;
57e22c34:	e0836006 	add	r6, r3, r6
57e22c38:	e2866004 	add	r6, r6, #4
57e22c3c:	e5876000 	str	r6, [r7]
		    && !first_deleted)
			first_deleted = idx;

		ret = _compare_and_overwrite_entry(item, action, retval, htab,
			flag, hval, idx);
		if (ret != -1)
57e22c40:	1a0000cd 	bne	57e22f7c <hsearch_r+0x4d4>

		/*
		 * Second hash function:
		 * as suggested in [Knuth]
		 */
		hval2 = 1 + hval % (htab->size - 2);
57e22c44:	e5941004 	ldr	r1, [r4, #4]
57e22c48:	e1a0000b 	mov	r0, fp
57e22c4c:	e2411002 	sub	r1, r1, #2
57e22c50:	eb002351 	bl	57e2b99c <__aeabi_uidivmod>
57e22c54:	e2811001 	add	r1, r1, #1
57e22c58:	e58d100c 	str	r1, [sp, #12]
57e22c5c:	e1a0600b 	mov	r6, fp
 */
static inline int _compare_and_overwrite_entry(ENTRY item, ACTION action,
	ENTRY **retval, struct hsearch_data *htab, int flag,
	unsigned int hval, unsigned int idx)
{
	if (htab->table[idx].used == hval
57e22c60:	e1a0a007 	mov	sl, r7
		do {
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
57e22c64:	e59d300c 	ldr	r3, [sp, #12]
57e22c68:	e1560003 	cmp	r6, r3
				idx = htab->size + idx - hval2;
57e22c6c:	95943004 	ldrls	r3, [r4, #4]
57e22c70:	959d200c 	ldrls	r2, [sp, #12]
			else
				idx -= hval2;
57e22c74:	859d300c 	ldrhi	r3, [sp, #12]
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
				idx = htab->size + idx - hval2;
57e22c78:	90623003 	rsbls	r3, r2, r3
57e22c7c:	90866003 	addls	r6, r6, r3
			else
				idx -= hval2;
57e22c80:	80636006 	rsbhi	r6, r3, r6

			/*
			 * If we visited all entries leave the loop
			 * unsuccessfully.
			 */
			if (idx == hval)
57e22c84:	e156000b 	cmp	r6, fp
57e22c88:	0a00004a 	beq	57e22db8 <hsearch_r+0x310>
 */
static inline int _compare_and_overwrite_entry(ENTRY item, ACTION action,
	ENTRY **retval, struct hsearch_data *htab, int flag,
	unsigned int hval, unsigned int idx)
{
	if (htab->table[idx].used == hval
57e22c8c:	e3a02014 	mov	r2, #20
57e22c90:	e0070692 	mul	r7, r2, r6
57e22c94:	e5942000 	ldr	r2, [r4]
57e22c98:	e0823007 	add	r3, r2, r7
57e22c9c:	e7922007 	ldr	r2, [r2, r7]
57e22ca0:	e152000b 	cmp	r2, fp
57e22ca4:	1a00003f 	bne	57e22da8 <hsearch_r+0x300>
	    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
57e22ca8:	e59d0004 	ldr	r0, [sp, #4]
57e22cac:	e5931004 	ldr	r1, [r3, #4]
57e22cb0:	eb0004bb 	bl	57e23fa4 <strcmp>
57e22cb4:	e2505000 	subs	r5, r0, #0
57e22cb8:	1a00003a 	bne	57e22da8 <hsearch_r+0x300>
		/* Overwrite existing value? */
		if ((action == ENTER) && (item.data != NULL)) {
57e22cbc:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
57e22cc0:	e3530001 	cmp	r3, #1
57e22cc4:	1a000030 	bne	57e22d8c <hsearch_r+0x2e4>
57e22cc8:	e3590000 	cmp	r9, #0
57e22ccc:	0a00002e 	beq	57e22d8c <hsearch_r+0x2e4>
			/* check for permission */
			if (htab->change_ok != NULL && htab->change_ok(
57e22cd0:	e594c00c 	ldr	ip, [r4, #12]
57e22cd4:	e35c0000 	cmp	ip, #0
57e22cd8:	0a000009 	beq	57e22d04 <hsearch_r+0x25c>
			    &htab->table[idx].entry, item.data,
57e22cdc:	e5940000 	ldr	r0, [r4]
	if (htab->table[idx].used == hval
	    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
		/* Overwrite existing value? */
		if ((action == ENTER) && (item.data != NULL)) {
			/* check for permission */
			if (htab->change_ok != NULL && htab->change_ok(
57e22ce0:	e1a01009 	mov	r1, r9
			    &htab->table[idx].entry, item.data,
57e22ce4:	e0800007 	add	r0, r0, r7
	if (htab->table[idx].used == hval
	    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
		/* Overwrite existing value? */
		if ((action == ENTER) && (item.data != NULL)) {
			/* check for permission */
			if (htab->change_ok != NULL && htab->change_ok(
57e22ce8:	e2800004 	add	r0, r0, #4
57e22cec:	e3a02002 	mov	r2, #2
57e22cf0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
57e22cf4:	e12fff3c 	blx	ip
57e22cf8:	e3500000 	cmp	r0, #0
57e22cfc:	11a0700a 	movne	r7, sl
57e22d00:	1a000073 	bne	57e22ed4 <hsearch_r+0x42c>
				*retval = NULL;
				return 0;
			}

			/* If there is a callback, call it */
			if (htab->table[idx].entry.callback &&
57e22d04:	e5943000 	ldr	r3, [r4]
57e22d08:	e0833007 	add	r3, r3, r7
57e22d0c:	e593c00c 	ldr	ip, [r3, #12]
57e22d10:	e35c0000 	cmp	ip, #0
57e22d14:	0a000009 	beq	57e22d40 <hsearch_r+0x298>
			    htab->table[idx].entry.callback(item.key,
57e22d18:	e59d0004 	ldr	r0, [sp, #4]
57e22d1c:	e1a01009 	mov	r1, r9
57e22d20:	e3a02002 	mov	r2, #2
57e22d24:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
57e22d28:	e12fff3c 	blx	ip
				*retval = NULL;
				return 0;
			}

			/* If there is a callback, call it */
			if (htab->table[idx].entry.callback &&
57e22d2c:	e3500000 	cmp	r0, #0
57e22d30:	0a000002 	beq	57e22d40 <hsearch_r+0x298>
57e22d34:	e1a0700a 	mov	r7, sl
			    htab->table[idx].entry.callback(item.key,
			    item.data, env_op_overwrite, flag)) {
				debug("callback() rejected setting variable "
					"%s, skipping it!\n", item.key);
				__set_errno(EINVAL);
57e22d38:	e3a02016 	mov	r2, #22
57e22d3c:	ea00008a 	b	57e22f6c <hsearch_r+0x4c4>
				*retval = NULL;
				return 0;
			}

			free(htab->table[idx].entry.data);
57e22d40:	e5943000 	ldr	r3, [r4]
57e22d44:	e0833007 	add	r3, r3, r7
57e22d48:	e5930008 	ldr	r0, [r3, #8]
57e22d4c:	ebff9b12 	bl	57e0999c <free>
			htab->table[idx].entry.data = strdup(item.data);
57e22d50:	e1a00009 	mov	r0, r9
57e22d54:	e5945000 	ldr	r5, [r4]
57e22d58:	eb0004dc 	bl	57e240d0 <strdup>
			if (!htab->table[idx].entry.data) {
57e22d5c:	e5943000 	ldr	r3, [r4]
				*retval = NULL;
				return 0;
			}

			free(htab->table[idx].entry.data);
			htab->table[idx].entry.data = strdup(item.data);
57e22d60:	e0855007 	add	r5, r5, r7
57e22d64:	e5850008 	str	r0, [r5, #8]
			if (!htab->table[idx].entry.data) {
57e22d68:	e0833007 	add	r3, r3, r7
57e22d6c:	e5935008 	ldr	r5, [r3, #8]
57e22d70:	e3550000 	cmp	r5, #0
57e22d74:	1a000004 	bne	57e22d8c <hsearch_r+0x2e4>
57e22d78:	e1a0700a 	mov	r7, sl
				__set_errno(ENOMEM);
57e22d7c:	e3a0200c 	mov	r2, #12
57e22d80:	e59f3200 	ldr	r3, [pc, #512]	; 57e22f88 <hsearch_r+0x4e0>
57e22d84:	e5832000 	str	r2, [r3]
57e22d88:	ea00007a 	b	57e22f78 <hsearch_r+0x4d0>
				*retval = NULL;
				return 0;
			}
		}
		/* return found entry */
		*retval = &htab->table[idx].entry;
57e22d8c:	e5943000 	ldr	r3, [r4]
				break;

			/* If entry is found use it. */
			ret = _compare_and_overwrite_entry(item, action, retval,
				htab, flag, hval, idx);
			if (ret != -1)
57e22d90:	e3760001 	cmn	r6, #1
				*retval = NULL;
				return 0;
			}
		}
		/* return found entry */
		*retval = &htab->table[idx].entry;
57e22d94:	e0833007 	add	r3, r3, r7
57e22d98:	e2833004 	add	r3, r3, #4
57e22d9c:	e58a3000 	str	r3, [sl]
		return idx;
57e22da0:	e1a05006 	mov	r5, r6
				break;

			/* If entry is found use it. */
			ret = _compare_and_overwrite_entry(item, action, retval,
				htab, flag, hval, idx);
			if (ret != -1)
57e22da4:	1a000074 	bne	57e22f7c <hsearch_r+0x4d4>
				return ret;
		}
		while (htab->table[idx].used);
57e22da8:	e5943000 	ldr	r3, [r4]
57e22dac:	e7933007 	ldr	r3, [r3, r7]
57e22db0:	e3530000 	cmp	r3, #0
57e22db4:	1affffaa 	bne	57e22c64 <hsearch_r+0x1bc>
57e22db8:	e1a0700a 	mov	r7, sl
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
57e22dbc:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
57e22dc0:	e3530001 	cmp	r3, #1
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
57e22dc4:	13a02003 	movne	r2, #3
		}
		while (htab->table[idx].used);
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
57e22dc8:	1a000067 	bne	57e22f6c <hsearch_r+0x4c4>
		/*
		 * If table is full and another entry should be
		 * entered return with error.
		 */
		if (htab->filled == htab->size) {
57e22dcc:	e5942008 	ldr	r2, [r4, #8]
57e22dd0:	e5943004 	ldr	r3, [r4, #4]
57e22dd4:	e1520003 	cmp	r2, r3
57e22dd8:	0a000017 	beq	57e22e3c <hsearch_r+0x394>

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
57e22ddc:	e59d2008 	ldr	r2, [sp, #8]
			idx = first_deleted;

		htab->table[idx].used = hval;
57e22de0:	e3a03014 	mov	r3, #20

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
57e22de4:	e3520000 	cmp	r2, #0
57e22de8:	11a06002 	movne	r6, r2
			idx = first_deleted;

		htab->table[idx].used = hval;
57e22dec:	e0060693 	mul	r6, r3, r6
57e22df0:	e5943000 	ldr	r3, [r4]
		htab->table[idx].entry.key = strdup(item.key);
57e22df4:	e59d0004 	ldr	r0, [sp, #4]
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
57e22df8:	e783b006 	str	fp, [r3, r6]
57e22dfc:	e0835006 	add	r5, r3, r6
		htab->table[idx].entry.key = strdup(item.key);
57e22e00:	eb0004b2 	bl	57e240d0 <strdup>
57e22e04:	e5850004 	str	r0, [r5, #4]
		htab->table[idx].entry.data = strdup(item.data);
57e22e08:	e1a00009 	mov	r0, r9
57e22e0c:	e5945000 	ldr	r5, [r4]
57e22e10:	eb0004ae 	bl	57e240d0 <strdup>
57e22e14:	e0855006 	add	r5, r5, r6
57e22e18:	e5850008 	str	r0, [r5, #8]
		if (!htab->table[idx].entry.key ||
57e22e1c:	e5940000 	ldr	r0, [r4]
57e22e20:	e0800006 	add	r0, r0, r6
57e22e24:	e5903004 	ldr	r3, [r0, #4]
57e22e28:	e3530000 	cmp	r3, #0
57e22e2c:	0a000002 	beq	57e22e3c <hsearch_r+0x394>
57e22e30:	e5903008 	ldr	r3, [r0, #8]
57e22e34:	e3530000 	cmp	r3, #0
57e22e38:	1a000001 	bne	57e22e44 <hsearch_r+0x39c>
		    !htab->table[idx].entry.data) {
			__set_errno(ENOMEM);
57e22e3c:	e3a0200c 	mov	r2, #12
57e22e40:	ea000049 	b	57e22f6c <hsearch_r+0x4c4>
			*retval = NULL;
			return 0;
		}

		++htab->filled;
57e22e44:	e5943008 	ldr	r3, [r4, #8]

		/* This is a new entry, so look up a possible callback */
		env_callback_init(&htab->table[idx].entry);
57e22e48:	e2800004 	add	r0, r0, #4
			__set_errno(ENOMEM);
			*retval = NULL;
			return 0;
		}

		++htab->filled;
57e22e4c:	e2833001 	add	r3, r3, #1
57e22e50:	e5843008 	str	r3, [r4, #8]

		/* This is a new entry, so look up a possible callback */
		env_callback_init(&htab->table[idx].entry);
57e22e54:	ebff9f88 	bl	57e0ac7c <env_callback_init>
		/* Also look for flags */
		env_flags_init(&htab->table[idx].entry);
57e22e58:	e5940000 	ldr	r0, [r4]
57e22e5c:	e0800006 	add	r0, r0, r6
57e22e60:	e2800004 	add	r0, r0, #4
57e22e64:	ebffa106 	bl	57e0b284 <env_flags_init>

		/* check for permission */
		if (htab->change_ok != NULL && htab->change_ok(
57e22e68:	e594c00c 	ldr	ip, [r4, #12]
57e22e6c:	e35c0000 	cmp	ip, #0
57e22e70:	0a00001a 	beq	57e22ee0 <hsearch_r+0x438>
		    &htab->table[idx].entry, item.data, env_op_create, flag)) {
57e22e74:	e5940000 	ldr	r0, [r4]
		env_callback_init(&htab->table[idx].entry);
		/* Also look for flags */
		env_flags_init(&htab->table[idx].entry);

		/* check for permission */
		if (htab->change_ok != NULL && htab->change_ok(
57e22e78:	e1a01009 	mov	r1, r9
		    &htab->table[idx].entry, item.data, env_op_create, flag)) {
57e22e7c:	e0800006 	add	r0, r0, r6
		env_callback_init(&htab->table[idx].entry);
		/* Also look for flags */
		env_flags_init(&htab->table[idx].entry);

		/* check for permission */
		if (htab->change_ok != NULL && htab->change_ok(
57e22e80:	e2800004 	add	r0, r0, #4
57e22e84:	e3a02000 	mov	r2, #0
57e22e88:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
57e22e8c:	e12fff3c 	blx	ip
57e22e90:	e3500000 	cmp	r0, #0
57e22e94:	0a000011 	beq	57e22ee0 <hsearch_r+0x438>
		    &htab->table[idx].entry, item.data, env_op_create, flag)) {
			debug("change_ok() rejected setting variable "
				"%s, skipping it!\n", item.key);
			_hdelete(item.key, htab, &htab->table[idx].entry, idx);
57e22e98:	e594a000 	ldr	sl, [r4]
{
	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	free((void *)ep->key);
	free(ep->data);
	ep->callback = NULL;
57e22e9c:	e3a05000 	mov	r5, #0
		/* check for permission */
		if (htab->change_ok != NULL && htab->change_ok(
		    &htab->table[idx].entry, item.data, env_op_create, flag)) {
			debug("change_ok() rejected setting variable "
				"%s, skipping it!\n", item.key);
			_hdelete(item.key, htab, &htab->table[idx].entry, idx);
57e22ea0:	e08aa006 	add	sl, sl, r6
static void _hdelete(const char *key, struct hsearch_data *htab, ENTRY *ep,
	int idx)
{
	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	free((void *)ep->key);
57e22ea4:	e59a0004 	ldr	r0, [sl, #4]
57e22ea8:	ebff9abb 	bl	57e0999c <free>
	free(ep->data);
57e22eac:	e59a0008 	ldr	r0, [sl, #8]
57e22eb0:	ebff9ab9 	bl	57e0999c <free>
	ep->callback = NULL;
	ep->flags = 0;
	htab->table[idx].used = -1;
57e22eb4:	e5943000 	ldr	r3, [r4]
57e22eb8:	e3e02000 	mvn	r2, #0
57e22ebc:	e7832006 	str	r2, [r3, r6]

	--htab->filled;
57e22ec0:	e5943008 	ldr	r3, [r4, #8]
{
	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	free((void *)ep->key);
	free(ep->data);
	ep->callback = NULL;
57e22ec4:	e58a500c 	str	r5, [sl, #12]
	ep->flags = 0;
	htab->table[idx].used = -1;

	--htab->filled;
57e22ec8:	e0833002 	add	r3, r3, r2
	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	free((void *)ep->key);
	free(ep->data);
	ep->callback = NULL;
	ep->flags = 0;
57e22ecc:	e58a5010 	str	r5, [sl, #16]
	htab->table[idx].used = -1;

	--htab->filled;
57e22ed0:	e5843008 	str	r3, [r4, #8]
		if (htab->change_ok != NULL && htab->change_ok(
		    &htab->table[idx].entry, item.data, env_op_create, flag)) {
			debug("change_ok() rejected setting variable "
				"%s, skipping it!\n", item.key);
			_hdelete(item.key, htab, &htab->table[idx].entry, idx);
			__set_errno(EPERM);
57e22ed4:	e59f30ac 	ldr	r3, [pc, #172]	; 57e22f88 <hsearch_r+0x4e0>
57e22ed8:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
57e22edc:	eaffffa8 	b	57e22d84 <hsearch_r+0x2dc>
			*retval = NULL;
			return 0;
		}

		/* If there is a callback, call it */
		if (htab->table[idx].entry.callback &&
57e22ee0:	e5943000 	ldr	r3, [r4]
57e22ee4:	e0833006 	add	r3, r3, r6
57e22ee8:	e593c00c 	ldr	ip, [r3, #12]
57e22eec:	e35c0000 	cmp	ip, #0
57e22ef0:	0a000017 	beq	57e22f54 <hsearch_r+0x4ac>
		    htab->table[idx].entry.callback(item.key, item.data,
57e22ef4:	e59d0004 	ldr	r0, [sp, #4]
57e22ef8:	e1a01009 	mov	r1, r9
57e22efc:	e3a02000 	mov	r2, #0
57e22f00:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
57e22f04:	e12fff3c 	blx	ip
			*retval = NULL;
			return 0;
		}

		/* If there is a callback, call it */
		if (htab->table[idx].entry.callback &&
57e22f08:	e3500000 	cmp	r0, #0
57e22f0c:	0a000010 	beq	57e22f54 <hsearch_r+0x4ac>
		    htab->table[idx].entry.callback(item.key, item.data,
		    env_op_create, flag)) {
			debug("callback() rejected setting variable "
				"%s, skipping it!\n", item.key);
			_hdelete(item.key, htab, &htab->table[idx].entry, idx);
57e22f10:	e594a000 	ldr	sl, [r4]
{
	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	free((void *)ep->key);
	free(ep->data);
	ep->callback = NULL;
57e22f14:	e3a05000 	mov	r5, #0
		if (htab->table[idx].entry.callback &&
		    htab->table[idx].entry.callback(item.key, item.data,
		    env_op_create, flag)) {
			debug("callback() rejected setting variable "
				"%s, skipping it!\n", item.key);
			_hdelete(item.key, htab, &htab->table[idx].entry, idx);
57e22f18:	e08aa006 	add	sl, sl, r6
static void _hdelete(const char *key, struct hsearch_data *htab, ENTRY *ep,
	int idx)
{
	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	free((void *)ep->key);
57e22f1c:	e59a0004 	ldr	r0, [sl, #4]
57e22f20:	ebff9a9d 	bl	57e0999c <free>
	free(ep->data);
57e22f24:	e59a0008 	ldr	r0, [sl, #8]
57e22f28:	ebff9a9b 	bl	57e0999c <free>
	ep->callback = NULL;
	ep->flags = 0;
	htab->table[idx].used = -1;
57e22f2c:	e5943000 	ldr	r3, [r4]
57e22f30:	e3e02000 	mvn	r2, #0
57e22f34:	e7832006 	str	r2, [r3, r6]

	--htab->filled;
57e22f38:	e5943008 	ldr	r3, [r4, #8]
{
	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	free((void *)ep->key);
	free(ep->data);
	ep->callback = NULL;
57e22f3c:	e58a500c 	str	r5, [sl, #12]
	ep->flags = 0;
	htab->table[idx].used = -1;

	--htab->filled;
57e22f40:	e0833002 	add	r3, r3, r2
	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	free((void *)ep->key);
	free(ep->data);
	ep->callback = NULL;
	ep->flags = 0;
57e22f44:	e58a5010 	str	r5, [sl, #16]
		    htab->table[idx].entry.callback(item.key, item.data,
		    env_op_create, flag)) {
			debug("callback() rejected setting variable "
				"%s, skipping it!\n", item.key);
			_hdelete(item.key, htab, &htab->table[idx].entry, idx);
			__set_errno(EINVAL);
57e22f48:	e2822017 	add	r2, r2, #23
	free(ep->data);
	ep->callback = NULL;
	ep->flags = 0;
	htab->table[idx].used = -1;

	--htab->filled;
57e22f4c:	e5843008 	str	r3, [r4, #8]
57e22f50:	eaffff8a 	b	57e22d80 <hsearch_r+0x2d8>
			*retval = NULL;
			return 0;
		}

		/* return new entry */
		*retval = &htab->table[idx].entry;
57e22f54:	e5943000 	ldr	r3, [r4]
		return 1;
57e22f58:	e3a05001 	mov	r5, #1
			*retval = NULL;
			return 0;
		}

		/* return new entry */
		*retval = &htab->table[idx].entry;
57e22f5c:	e0836006 	add	r6, r3, r6
57e22f60:	e2866004 	add	r6, r6, #4
57e22f64:	e5876000 	str	r6, [r7]
		return 1;
57e22f68:	ea000003 	b	57e22f7c <hsearch_r+0x4d4>
	}

	__set_errno(ESRCH);
57e22f6c:	e59f3014 	ldr	r3, [pc, #20]	; 57e22f88 <hsearch_r+0x4e0>
	*retval = NULL;
57e22f70:	e3a05000 	mov	r5, #0
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
57e22f74:	e5832000 	str	r2, [r3]
	*retval = NULL;
57e22f78:	e5875000 	str	r5, [r7]
	return 0;
}
57e22f7c:	e1a00005 	mov	r0, r5
57e22f80:	e28dd020 	add	sp, sp, #32
57e22f84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e22f88:	57e79098 	.word	0x57e79098

57e22f8c <hdelete_r>:

	--htab->filled;
}

int hdelete_r(const char *key, struct hsearch_data *htab, int flag)
{
57e22f8c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e22f90:	e24dd028 	sub	sp, sp, #40	; 0x28

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;

	idx = hsearch_r(e, FIND, &ep, htab, 0);
57e22f94:	e3a05000 	mov	r5, #0
57e22f98:	e28d3024 	add	r3, sp, #36	; 0x24
57e22f9c:	e58d3004 	str	r3, [sp, #4]
	ENTRY e, *ep;
	int idx;

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;
57e22fa0:	e58d0014 	str	r0, [sp, #20]

	idx = hsearch_r(e, FIND, &ep, htab, 0);
57e22fa4:	e58d5000 	str	r5, [sp]
57e22fa8:	e58d1008 	str	r1, [sp, #8]
57e22fac:	e58d500c 	str	r5, [sp, #12]
57e22fb0:	e28d3014 	add	r3, sp, #20

	--htab->filled;
}

int hdelete_r(const char *key, struct hsearch_data *htab, int flag)
{
57e22fb4:	e1a07000 	mov	r7, r0
57e22fb8:	e1a04001 	mov	r4, r1
57e22fbc:	e1a0a002 	mov	sl, r2

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;

	idx = hsearch_r(e, FIND, &ep, htab, 0);
57e22fc0:	e893000f 	ldm	r3, {r0, r1, r2, r3}
57e22fc4:	ebfffeb7 	bl	57e22aa8 <hsearch_r>
	if (idx == 0) {
57e22fc8:	e2506000 	subs	r6, r0, #0
		__set_errno(ESRCH);
57e22fcc:	059f30d0 	ldreq	r3, [pc, #208]	; 57e230a4 <hdelete_r+0x118>
57e22fd0:	03a02003 	moveq	r2, #3
57e22fd4:	05832000 	streq	r2, [r3]
		return 0;	/* not found */
57e22fd8:	01a00006 	moveq	r0, r6
57e22fdc:	0a00002e 	beq	57e2309c <hdelete_r+0x110>
	}

	/* Check for permission */
	if (htab->change_ok != NULL &&
57e22fe0:	e594c00c 	ldr	ip, [r4, #12]
57e22fe4:	e35c0000 	cmp	ip, #0
57e22fe8:	0a00000a 	beq	57e23018 <hdelete_r+0x8c>
	    htab->change_ok(ep, NULL, env_op_delete, flag)) {
57e22fec:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
57e22ff0:	e1a01005 	mov	r1, r5
57e22ff4:	e3a02001 	mov	r2, #1
57e22ff8:	e1a0300a 	mov	r3, sl
57e22ffc:	e12fff3c 	blx	ip
		__set_errno(ESRCH);
		return 0;	/* not found */
	}

	/* Check for permission */
	if (htab->change_ok != NULL &&
57e23000:	e3500000 	cmp	r0, #0
	    htab->change_ok(ep, NULL, env_op_delete, flag)) {
		debug("change_ok() rejected deleting variable "
			"%s, skipping it!\n", key);
		__set_errno(EPERM);
57e23004:	159f3098 	ldrne	r3, [pc, #152]	; 57e230a4 <hdelete_r+0x118>
57e23008:	13a02001 	movne	r2, #1
57e2300c:	15832000 	strne	r2, [r3]
		return 0;
57e23010:	11a00005 	movne	r0, r5
57e23014:	1a000020 	bne	57e2309c <hdelete_r+0x110>
	}

	/* If there is a callback, call it */
	if (htab->table[idx].entry.callback &&
57e23018:	e3a05014 	mov	r5, #20
57e2301c:	e0060695 	mul	r6, r5, r6
57e23020:	e5943000 	ldr	r3, [r4]
57e23024:	e0833006 	add	r3, r3, r6
57e23028:	e593c00c 	ldr	ip, [r3, #12]
57e2302c:	e35c0000 	cmp	ip, #0
57e23030:	0a00000a 	beq	57e23060 <hdelete_r+0xd4>
	    htab->table[idx].entry.callback(key, NULL, env_op_delete, flag)) {
57e23034:	e1a00007 	mov	r0, r7
57e23038:	e3a01000 	mov	r1, #0
57e2303c:	e3a02001 	mov	r2, #1
57e23040:	e1a0300a 	mov	r3, sl
57e23044:	e12fff3c 	blx	ip
		__set_errno(EPERM);
		return 0;
	}

	/* If there is a callback, call it */
	if (htab->table[idx].entry.callback &&
57e23048:	e3500000 	cmp	r0, #0
	    htab->table[idx].entry.callback(key, NULL, env_op_delete, flag)) {
		debug("callback() rejected deleting variable "
			"%s, skipping it!\n", key);
		__set_errno(EINVAL);
57e2304c:	159f3050 	ldrne	r3, [pc, #80]	; 57e230a4 <hdelete_r+0x118>
57e23050:	13a02016 	movne	r2, #22
57e23054:	15832000 	strne	r2, [r3]
		return 0;
57e23058:	13a00000 	movne	r0, #0
57e2305c:	1a00000e 	bne	57e2309c <hdelete_r+0x110>
	}

	_hdelete(key, htab, ep, idx);
57e23060:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
static void _hdelete(const char *key, struct hsearch_data *htab, ENTRY *ep,
	int idx)
{
	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	free((void *)ep->key);
57e23064:	e5950000 	ldr	r0, [r5]
57e23068:	ebff9a4b 	bl	57e0999c <free>
	free(ep->data);
57e2306c:	e5950004 	ldr	r0, [r5, #4]
57e23070:	ebff9a49 	bl	57e0999c <free>
	ep->callback = NULL;
57e23074:	e3a03000 	mov	r3, #0
57e23078:	e5853008 	str	r3, [r5, #8]
	ep->flags = 0;
57e2307c:	e585300c 	str	r3, [r5, #12]
	htab->table[idx].used = -1;
57e23080:	e5943000 	ldr	r3, [r4]
57e23084:	e3e02000 	mvn	r2, #0
57e23088:	e7832006 	str	r2, [r3, r6]

	--htab->filled;
57e2308c:	e5943008 	ldr	r3, [r4, #8]
		return 0;
	}

	_hdelete(key, htab, ep, idx);

	return 1;
57e23090:	e3a00001 	mov	r0, #1
	free(ep->data);
	ep->callback = NULL;
	ep->flags = 0;
	htab->table[idx].used = -1;

	--htab->filled;
57e23094:	e0833002 	add	r3, r3, r2
57e23098:	e5843008 	str	r3, [r4, #8]
	}

	_hdelete(key, htab, ep, idx);

	return 1;
}
57e2309c:	e28dd028 	add	sp, sp, #40	; 0x28
57e230a0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e230a4:	57e79098 	.word	0x57e79098

57e230a8 <hexport_r>:
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep, int flag,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
57e230a8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e230ac:	e28db01c 	add	fp, sp, #28
57e230b0:	e24dd020 	sub	sp, sp, #32
57e230b4:	e1a07001 	mov	r7, r1
	ENTRY *list[htab->size];
57e230b8:	e5901004 	ldr	r1, [r0, #4]
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
57e230bc:	e3530000 	cmp	r3, #0

ssize_t hexport_r(struct hsearch_data *htab, const char sep, int flag,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
	ENTRY *list[htab->size];
57e230c0:	e1a01101 	lsl	r1, r1, #2
57e230c4:	e281100e 	add	r1, r1, #14
57e230c8:	e3c11007 	bic	r1, r1, #7
57e230cc:	e04dd001 	sub	sp, sp, r1
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep, int flag,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
57e230d0:	e1a05000 	mov	r5, r0
57e230d4:	e59b6004 	ldr	r6, [fp, #4]
	ENTRY *list[htab->size];
57e230d8:	e50bd028 	str	sp, [fp, #-40]	; 0x28
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
57e230dc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
57e230e0:	0a000008 	beq	57e23108 <hexport_r+0x60>
57e230e4:	e3a04000 	mov	r4, #0
57e230e8:	e3a01001 	mov	r1, #1
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			if ((flag & H_HIDE_DOT) && ep->key[0] == '.')
57e230ec:	e2022008 	and	r2, r2, #8
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
57e230f0:	e3a09014 	mov	r9, #20
57e230f4:	e50b1024 	str	r1, [fp, #-36]	; 0x24
57e230f8:	e50b4020 	str	r4, [fp, #-32]
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			if ((flag & H_HIDE_DOT) && ep->key[0] == '.')
57e230fc:	e50b2030 	str	r2, [fp, #-48]	; 0x30
57e23100:	e50b6034 	str	r6, [fp, #-52]	; 0x34
57e23104:	ea000048 	b	57e2322c <hexport_r+0x184>
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
		__set_errno(EINVAL);
57e23108:	e3a02016 	mov	r2, #22
57e2310c:	ea00005b 	b	57e23280 <hexport_r+0x1d8>
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
57e23110:	e5953000 	ldr	r3, [r5]
57e23114:	e0836009 	add	r6, r3, r9
57e23118:	e7933009 	ldr	r3, [r3, r9]
57e2311c:	e3530000 	cmp	r3, #0
57e23120:	da00003d 	ble	57e2321c <hexport_r+0x174>
57e23124:	e59b300c 	ldr	r3, [fp, #12]
57e23128:	e1a02004 	mov	r2, r4
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
57e2312c:	e3a0a000 	mov	sl, #0
57e23130:	e1a04003 	mov	r4, r3
57e23134:	ea000007 	b	57e23158 <hexport_r+0xb0>
				if (strcmp(argv[arg], ep->key) == 0) {
57e23138:	e4940004 	ldr	r0, [r4], #4
57e2313c:	e5961004 	ldr	r1, [r6, #4]
57e23140:	e50b2038 	str	r2, [fp, #-56]	; 0x38
57e23144:	eb000396 	bl	57e23fa4 <strcmp>
57e23148:	e3500000 	cmp	r0, #0
57e2314c:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
57e23150:	0a000006 	beq	57e23170 <hexport_r+0xc8>

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
57e23154:	e28aa001 	add	sl, sl, #1
57e23158:	e59b3008 	ldr	r3, [fp, #8]
57e2315c:	e15a0003 	cmp	sl, r3
57e23160:	bafffff4 	blt	57e23138 <hexport_r+0x90>
57e23164:	e1a04002 	mov	r4, r2
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;
57e23168:	e3a03000 	mov	r3, #0
57e2316c:	ea000001 	b	57e23178 <hexport_r+0xd0>
57e23170:	e1a04002 	mov	r4, r2

			for (arg = 0; arg < argc; ++arg) {
				if (strcmp(argv[arg], ep->key) == 0) {
					found = 1;
57e23174:	e3a03001 	mov	r3, #1
					break;
				}
			}
			if ((argc > 0) && (found == 0))
57e23178:	e59b1008 	ldr	r1, [fp, #8]
57e2317c:	e2233001 	eor	r3, r3, #1
57e23180:	e3510000 	cmp	r1, #0
57e23184:	d3a03000 	movle	r3, #0
57e23188:	c2033001 	andgt	r3, r3, #1
57e2318c:	e3530000 	cmp	r3, #0
57e23190:	1a000021 	bne	57e2321c <hexport_r+0x174>
				continue;

			if ((flag & H_HIDE_DOT) && ep->key[0] == '.')
57e23194:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
57e23198:	e3520000 	cmp	r2, #0
57e2319c:	0a000003 	beq	57e231b0 <hexport_r+0x108>
57e231a0:	e5963004 	ldr	r3, [r6, #4]
57e231a4:	e5d33000 	ldrb	r3, [r3]
57e231a8:	e353002e 	cmp	r3, #46	; 0x2e
57e231ac:	0a00001a 	beq	57e2321c <hexport_r+0x174>
				continue;

			list[n++] = ep;
57e231b0:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
57e231b4:	e2863004 	add	r3, r6, #4
				continue;

			if ((flag & H_HIDE_DOT) && ep->key[0] == '.')
				continue;

			list[n++] = ep;
57e231b8:	e7813104 	str	r3, [r1, r4, lsl #2]

			totlen += strlen(ep->key) + 2;
57e231bc:	e5960004 	ldr	r0, [r6, #4]
57e231c0:	eb0003a2 	bl	57e24050 <strlen>
57e231c4:	e51b2020 	ldr	r2, [fp, #-32]

			if (sep == '\0') {
57e231c8:	e3570000 	cmp	r7, #0
			if ((flag & H_HIDE_DOT) && ep->key[0] == '.')
				continue;

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;
57e231cc:	e282a002 	add	sl, r2, #2
				continue;

			if ((flag & H_HIDE_DOT) && ep->key[0] == '.')
				continue;

			list[n++] = ep;
57e231d0:	e2844001 	add	r4, r4, #1

			totlen += strlen(ep->key) + 2;
57e231d4:	e08aa000 	add	sl, sl, r0

			if (sep == '\0') {
				totlen += strlen(ep->data);
57e231d8:	15962008 	ldrne	r2, [r6, #8]

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;

			if (sep == '\0') {
57e231dc:	1a000009 	bne	57e23208 <hexport_r+0x160>
				totlen += strlen(ep->data);
57e231e0:	e5960008 	ldr	r0, [r6, #8]
57e231e4:	eb000399 	bl	57e24050 <strlen>
57e231e8:	e08aa000 	add	sl, sl, r0
57e231ec:	ea000008 	b	57e23214 <hexport_r+0x16c>
				char *s = ep->data;

				while (*s) {
					++totlen;
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
57e231f0:	e1530007 	cmp	r3, r7
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
					++totlen;
57e231f4:	e28aa001 	add	sl, sl, #1
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
57e231f8:	0a000001 	beq	57e23204 <hexport_r+0x15c>
57e231fc:	e353005c 	cmp	r3, #92	; 0x5c
57e23200:	1a000000 	bne	57e23208 <hexport_r+0x160>
						++totlen;
57e23204:	e28aa001 	add	sl, sl, #1
			if (sep == '\0') {
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
57e23208:	e4d23001 	ldrb	r3, [r2], #1
57e2320c:	e3530000 	cmp	r3, #0
57e23210:	1afffff6 	bne	57e231f0 <hexport_r+0x148>
					if ((*s == sep) || (*s == '\\'))
						++totlen;
					++s;
				}
			}
			totlen += 2;	/* for '=' and 'sep' char */
57e23214:	e28aa002 	add	sl, sl, #2
57e23218:	e50ba020 	str	sl, [fp, #-32]
	/*
	 * Pass 1:
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {
57e2321c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
57e23220:	e2899014 	add	r9, r9, #20
57e23224:	e2833001 	add	r3, r3, #1
57e23228:	e50b3024 	str	r3, [fp, #-36]	; 0x24
57e2322c:	e5953004 	ldr	r3, [r5, #4]
57e23230:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
57e23234:	e1510003 	cmp	r1, r3
57e23238:	9affffb4 	bls	57e23110 <hexport_r+0x68>
		       i, list[i], list[i]->key, list[i]->data);
	}
#endif

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);
57e2323c:	e3a02004 	mov	r2, #4
57e23240:	e59f3124 	ldr	r3, [pc, #292]	; 57e2336c <hexport_r+0x2c4>
57e23244:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
57e23248:	e1a01004 	mov	r1, r4
57e2324c:	e51b6034 	ldr	r6, [fp, #-52]	; 0x34
57e23250:	eb0002c3 	bl	57e23d64 <qsort>
57e23254:	e51b3020 	ldr	r3, [fp, #-32]

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
57e23258:	e3560000 	cmp	r6, #0
57e2325c:	e2832001 	add	r2, r3, #1
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
			return (-1);
		}
	} else {
		size = totlen + 1;
57e23260:	01a06002 	moveq	r6, r2

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
57e23264:	0a000009 	beq	57e23290 <hexport_r+0x1e8>
		if (size < totlen + 1) {	/* provided buffer too small */
57e23268:	e1560002 	cmp	r6, r2
57e2326c:	2a000007 	bcs	57e23290 <hexport_r+0x1e8>
			printf("Env export buffer too small: %zu, "
57e23270:	e59f00f8 	ldr	r0, [pc, #248]	; 57e23370 <hexport_r+0x2c8>
57e23274:	e1a01006 	mov	r1, r6
57e23278:	ebff9873 	bl	57e0944c <printf>
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
57e2327c:	e3a0200c 	mov	r2, #12
57e23280:	e59f30ec 	ldr	r3, [pc, #236]	; 57e23374 <hexport_r+0x2cc>
			return (-1);
57e23284:	e3e00000 	mvn	r0, #0
	/* Check if the user supplied buffer size is sufficient */
	if (size) {
		if (size < totlen + 1) {	/* provided buffer too small */
			printf("Env export buffer too small: %zu, "
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
57e23288:	e5832000 	str	r2, [r3]
57e2328c:	ea000034 	b	57e23364 <hexport_r+0x2bc>
	} else {
		size = totlen + 1;
	}

	/* Check if the user provided a buffer */
	if (*resp) {
57e23290:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
57e23294:	e5915000 	ldr	r5, [r1]
57e23298:	e3550000 	cmp	r5, #0
57e2329c:	0a000008 	beq	57e232c4 <hexport_r+0x21c>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
57e232a0:	e1a00005 	mov	r0, r5
57e232a4:	e3a01000 	mov	r1, #0
57e232a8:	e1a02006 	mov	r2, r6
57e232ac:	eb0003f2 	bl	57e2427c <memset>
57e232b0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
		if (res == NULL) {
57e232b4:	e3a03000 	mov	r3, #0
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
57e232b8:	e3a0a03d 	mov	sl, #61	; 0x3d

		s = list[i]->data;

		while (*s) {
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
57e232bc:	e3a0905c 	mov	r9, #92	; 0x5c
57e232c0:	ea000022 	b	57e23350 <hexport_r+0x2a8>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
57e232c4:	e3a00001 	mov	r0, #1
57e232c8:	e1a01006 	mov	r1, r6
57e232cc:	ebff9baa 	bl	57e0a17c <calloc>
57e232d0:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
		if (res == NULL) {
57e232d4:	e3500000 	cmp	r0, #0
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
57e232d8:	e5820000 	str	r0, [r2]
		if (res == NULL) {
57e232dc:	11a05000 	movne	r5, r0
57e232e0:	1afffff2 	bne	57e232b0 <hexport_r+0x208>
57e232e4:	eaffffe4 	b	57e2327c <hexport_r+0x1d4>
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
57e232e8:	e4921004 	ldr	r1, [r2], #4
57e232ec:	e5911000 	ldr	r1, [r1]
		while (*s)
57e232f0:	ea000001 	b	57e232fc <hexport_r+0x254>
			*p++ = *s++;
57e232f4:	e5c50000 	strb	r0, [r5]
57e232f8:	e1a0500c 	mov	r5, ip
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
		while (*s)
57e232fc:	e4d10001 	ldrb	r0, [r1], #1
57e23300:	e285c001 	add	ip, r5, #1
57e23304:	e3500000 	cmp	r0, #0
57e23308:	1afffff9 	bne	57e232f4 <hexport_r+0x24c>
			*p++ = *s++;
		*p++ = '=';
57e2330c:	e5c5a000 	strb	sl, [r5]

		s = list[i]->data;
57e23310:	e5121004 	ldr	r1, [r2, #-4]
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
57e23314:	e1a0500c 	mov	r5, ip
57e23318:	e5911004 	ldr	r1, [r1, #4]

		s = list[i]->data;

		while (*s) {
57e2331c:	ea000006 	b	57e2333c <hexport_r+0x294>
			if ((*s == sep) || (*s == '\\'))
57e23320:	e1500007 	cmp	r0, r7
57e23324:	0a000001 	beq	57e23330 <hexport_r+0x288>
57e23328:	e350005c 	cmp	r0, #92	; 0x5c
57e2332c:	1a000000 	bne	57e23334 <hexport_r+0x28c>
				*p++ = '\\';	/* escape */
57e23330:	e4c59001 	strb	r9, [r5], #1
			*p++ = *s++;
57e23334:	e5510001 	ldrb	r0, [r1, #-1]
57e23338:	e4c50001 	strb	r0, [r5], #1
			*p++ = *s++;
		*p++ = '=';

		s = list[i]->data;

		while (*s) {
57e2333c:	e4d10001 	ldrb	r0, [r1], #1
57e23340:	e3500000 	cmp	r0, #0
57e23344:	1afffff5 	bne	57e23320 <hexport_r+0x278>
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
57e23348:	e4c57001 	strb	r7, [r5], #1
	}
	/*
	 * Pass 2:
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
57e2334c:	e2833001 	add	r3, r3, #1
57e23350:	e1530004 	cmp	r3, r4
57e23354:	baffffe3 	blt	57e232e8 <hexport_r+0x240>
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
	}
	*p = '\0';		/* terminate result */
57e23358:	e3a03000 	mov	r3, #0
57e2335c:	e5c53000 	strb	r3, [r5]

	return size;
57e23360:	e1a00006 	mov	r0, r6
}
57e23364:	e24bd01c 	sub	sp, fp, #28
57e23368:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e2336c:	57e22828 	.word	0x57e22828
57e23370:	57e354a7 	.word	0x57e354a7
57e23374:	57e79098 	.word	0x57e79098

57e23378 <himport_r>:
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[])
{
57e23378:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e2337c:	e28db01c 	add	fp, sp, #28
57e23380:	e24dd030 	sub	sp, sp, #48	; 0x30
57e23384:	e1a06002 	mov	r6, r2
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
57e23388:	e59b2008 	ldr	r2, [fp, #8]
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[])
{
57e2338c:	e1a0a003 	mov	sl, r3
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
57e23390:	e1a04102 	lsl	r4, r2, #2
57e23394:	e284300e 	add	r3, r4, #14
57e23398:	e3c33007 	bic	r3, r3, #7
57e2339c:	e04dd003 	sub	sp, sp, r3
57e233a0:	e28d3010 	add	r3, sp, #16
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
57e233a4:	e2505000 	subs	r5, r0, #0
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[])
{
57e233a8:	e1a07001 	mov	r7, r1
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
57e233ac:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
57e233b0:	059f32c0 	ldreq	r3, [pc, #704]	; 57e23678 <himport_r+0x300>
57e233b4:	03a02016 	moveq	r2, #22
57e233b8:	05832000 	streq	r2, [r3]
		return 0;
57e233bc:	01a00005 	moveq	r0, r5
57e233c0:	0a0000aa 	beq	57e23670 <himport_r+0x2f8>
	}

	/* we allocate new space to make sure we can write to the array */
	if ((data = malloc(size)) == NULL) {
57e233c4:	e1a00006 	mov	r0, r6
57e233c8:	ebff99fd 	bl	57e09bc4 <malloc>
57e233cc:	e2509000 	subs	r9, r0, #0
		debug("himport_r: can't malloc %zu bytes\n", size);
		__set_errno(ENOMEM);
57e233d0:	059f32a0 	ldreq	r3, [pc, #672]	; 57e23678 <himport_r+0x300>
57e233d4:	03a0200c 	moveq	r2, #12
57e233d8:	05832000 	streq	r2, [r3]
		return 0;
57e233dc:	01a00009 	moveq	r0, r9
57e233e0:	0a0000a2 	beq	57e23670 <himport_r+0x2f8>
	}
	memcpy(data, env, size);
57e233e4:	e1a02006 	mov	r2, r6
57e233e8:	e1a01007 	mov	r1, r7
57e233ec:	eb0003c6 	bl	57e2430c <memcpy>
	dp = data;

	/* make a local copy of the list of variables */
	if (nvars)
57e233f0:	e59b2008 	ldr	r2, [fp, #8]
57e233f4:	e3520000 	cmp	r2, #0
57e233f8:	0a000003 	beq	57e2340c <himport_r+0x94>
		memcpy(localvars, vars, sizeof(vars[0]) * nvars);
57e233fc:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
57e23400:	e59b100c 	ldr	r1, [fp, #12]
57e23404:	e1a02004 	mov	r2, r4
57e23408:	eb0003bf 	bl	57e2430c <memcpy>

	if ((flag & H_NOCLEAR) == 0) {
57e2340c:	e59b3004 	ldr	r3, [fp, #4]
57e23410:	e3130001 	tst	r3, #1
57e23414:	1a000004 	bne	57e2342c <himport_r+0xb4>
		/* Destroy old hash table if one exists */
		debug("Destroy Hash Table: %p table = %p\n", htab,
		       htab->table);
		if (htab->table)
57e23418:	e5953000 	ldr	r3, [r5]
57e2341c:	e3530000 	cmp	r3, #0
57e23420:	0a000001 	beq	57e2342c <himport_r+0xb4>
			hdestroy_r(htab);
57e23424:	e1a00005 	mov	r0, r5
57e23428:	ebfffd2e 	bl	57e228e8 <hdestroy_r>
	 * On the other hand we need to add some more entries for free
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
57e2342c:	e5953000 	ldr	r3, [r5]
57e23430:	e3530000 	cmp	r3, #0
57e23434:	0a000004 	beq	57e2344c <himport_r+0xd4>
				name, value);

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
57e23438:	e0896006 	add	r6, r9, r6
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[])
{
57e2343c:	e1a04009 	mov	r4, r9
				name, value);

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
57e23440:	e50b603c 	str	r6, [fp, #-60]	; 0x3c
57e23444:	e1a07005 	mov	r7, r5
57e23448:	ea00000c 	b	57e23480 <himport_r+0x108>
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
		int nent = CONFIG_ENV_MIN_ENTRIES + size / 8;
57e2344c:	e1a001a6 	lsr	r0, r6, #3
57e23450:	e2800040 	add	r0, r0, #64	; 0x40
		if (nent > CONFIG_ENV_MAX_ENTRIES)
			nent = CONFIG_ENV_MAX_ENTRIES;

		debug("Create Hash Table: N=%d\n", nent);

		if (hcreate_r(nent, htab) == 0) {
57e23454:	e3500c02 	cmp	r0, #512	; 0x200
57e23458:	a3a00c02 	movge	r0, #512	; 0x200
57e2345c:	e1a01005 	mov	r1, r5
57e23460:	ebfffcf5 	bl	57e2283c <hcreate_r>
57e23464:	e2504000 	subs	r4, r0, #0
57e23468:	1afffff2 	bne	57e23438 <himport_r+0xc0>
			free(data);
57e2346c:	e1a00009 	mov	r0, r9
57e23470:	ebff9949 	bl	57e0999c <free>
			return 0;
57e23474:	e1a00004 	mov	r0, r4
57e23478:	ea00007c 	b	57e23670 <himport_r+0x2f8>
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[])
{
57e2347c:	e1a04005 	mov	r4, r5
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
57e23480:	e5d43000 	ldrb	r3, [r4]
57e23484:	e3530020 	cmp	r3, #32
57e23488:	13530009 	cmpne	r3, #9
			++dp;
57e2348c:	02845001 	addeq	r5, r4, #1
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
57e23490:	0afffff9 	beq	57e2347c <himport_r+0x104>
			++dp;

		/* skip comment lines */
		if (*dp == '#') {
57e23494:	e3530023 	cmp	r3, #35	; 0x23
57e23498:	11a02004 	movne	r2, r4
57e2349c:	1a000007 	bne	57e234c0 <himport_r+0x148>
57e234a0:	e1a05004 	mov	r5, r4
			while (*dp && (*dp != sep))
57e234a4:	e4d43001 	ldrb	r3, [r4], #1
57e234a8:	e3530000 	cmp	r3, #0
57e234ac:	0a000001 	beq	57e234b8 <himport_r+0x140>
57e234b0:	e153000a 	cmp	r3, sl
57e234b4:	1afffff9 	bne	57e234a0 <himport_r+0x128>
				++dp;
			++dp;
57e234b8:	e2855001 	add	r5, r5, #1
			continue;
57e234bc:	ea00004f 	b	57e23600 <himport_r+0x288>
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
57e234c0:	e5d23000 	ldrb	r3, [r2]
		/* skip comment lines */
		if (*dp == '#') {
			while (*dp && (*dp != sep))
				++dp;
			++dp;
			continue;
57e234c4:	e1a05002 	mov	r5, r2
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
57e234c8:	e3530000 	cmp	r3, #0
57e234cc:	1353003d 	cmpne	r3, #61	; 0x3d
57e234d0:	e2822001 	add	r2, r2, #1
57e234d4:	1a000002 	bne	57e234e4 <himport_r+0x16c>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
57e234d8:	e3530000 	cmp	r3, #0
57e234dc:	0a00000e 	beq	57e2351c <himport_r+0x1a4>
57e234e0:	ea000001 	b	57e234ec <himport_r+0x174>
			++dp;
			continue;
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
57e234e4:	e153000a 	cmp	r3, sl
57e234e8:	1afffff4 	bne	57e234c0 <himport_r+0x148>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
57e234ec:	e5d52001 	ldrb	r2, [r5, #1]
57e234f0:	e2856001 	add	r6, r5, #1
57e234f4:	e3520000 	cmp	r2, #0
57e234f8:	0a000003 	beq	57e2350c <himport_r+0x194>
57e234fc:	e153000a 	cmp	r3, sl
57e23500:	0a000001 	beq	57e2350c <himport_r+0x194>
		    *dp == sep || *(dp + 1) == sep) {
57e23504:	e152000a 	cmp	r2, sl
57e23508:	1a000010 	bne	57e23550 <himport_r+0x1d8>
			if (*dp == '=')
57e2350c:	e353003d 	cmp	r3, #61	; 0x3d
				*dp++ = '\0';
57e23510:	03a02000 	moveq	r2, #0
57e23514:	05c52000 	strbeq	r2, [r5]
57e23518:	01a05006 	moveq	r5, r6
			*dp++ = '\0';	/* terminate name */
57e2351c:	e3a03000 	mov	r3, #0
57e23520:	e4c53001 	strb	r3, [r5], #1

			debug("DELETE CANDIDATE: \"%s\"\n", name);
			if (!drop_var_from_set(name, nvars, localvars))
57e23524:	e1a00004 	mov	r0, r4
57e23528:	e59b1008 	ldr	r1, [fp, #8]
57e2352c:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
57e23530:	ebfffca5 	bl	57e227cc <drop_var_from_set>
57e23534:	e3500000 	cmp	r0, #0
57e23538:	0a000030 	beq	57e23600 <himport_r+0x288>
				continue;

			if (hdelete_r(name, htab, flag) == 0)
57e2353c:	e1a00004 	mov	r0, r4
57e23540:	e1a01007 	mov	r1, r7
57e23544:	e59b2004 	ldr	r2, [fp, #4]
57e23548:	ebfffe8f 	bl	57e22f8c <hdelete_r>
				debug("DELETE ERROR ##############################\n");

			continue;
57e2354c:	ea00002b 	b	57e23600 <himport_r+0x288>
		}
		*dp++ = '\0';	/* terminate name */
57e23550:	e3a02000 	mov	r2, #0
57e23554:	e5c52000 	strb	r2, [r5]

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
57e23558:	e1a03006 	mov	r3, r6
57e2355c:	e1a05006 	mov	r5, r6
57e23560:	ea000006 	b	57e23580 <himport_r+0x208>
			if ((*dp == '\\') && *(dp + 1))
57e23564:	e352005c 	cmp	r2, #92	; 0x5c
57e23568:	1a000002 	bne	57e23578 <himport_r+0x200>
57e2356c:	e5d52001 	ldrb	r2, [r5, #1]
57e23570:	e3520000 	cmp	r2, #0
57e23574:	12855001 	addne	r5, r5, #1
				++dp;
			*sp++ = *dp;
57e23578:	e4d52001 	ldrb	r2, [r5], #1
57e2357c:	e4c32001 	strb	r2, [r3], #1
			continue;
		}
		*dp++ = '\0';	/* terminate name */

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
57e23580:	e5d52000 	ldrb	r2, [r5]
57e23584:	e3520000 	cmp	r2, #0
57e23588:	0a000001 	beq	57e23594 <himport_r+0x21c>
57e2358c:	e152000a 	cmp	r2, sl
57e23590:	1afffff3 	bne	57e23564 <himport_r+0x1ec>
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
57e23594:	e3a02000 	mov	r2, #0
57e23598:	e5c32000 	strb	r2, [r3]
		++dp;

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
57e2359c:	e1a00004 	mov	r0, r4
57e235a0:	e59b1008 	ldr	r1, [fp, #8]
57e235a4:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
57e235a8:	ebfffc87 	bl	57e227cc <drop_var_from_set>
57e235ac:	e3500000 	cmp	r0, #0
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
		++dp;
57e235b0:	e2855001 	add	r5, r5, #1

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
57e235b4:	0a000011 	beq	57e23600 <himport_r+0x288>

		/* enter into hash table */
		e.key = name;
		e.data = value;

		hsearch_r(e, ENTER, &rv, htab, flag);
57e235b8:	e3a03001 	mov	r3, #1
57e235bc:	e58d3000 	str	r3, [sp]
57e235c0:	e59b3004 	ldr	r3, [fp, #4]
57e235c4:	e24b2020 	sub	r2, fp, #32
57e235c8:	e58d300c 	str	r3, [sp, #12]
		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
			continue;

		/* enter into hash table */
		e.key = name;
57e235cc:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		e.data = value;
57e235d0:	e50b602c 	str	r6, [fp, #-44]	; 0x2c

		hsearch_r(e, ENTER, &rv, htab, flag);
57e235d4:	e98d0084 	stmib	sp, {r2, r7}
57e235d8:	e24b3030 	sub	r3, fp, #48	; 0x30
57e235dc:	e893000f 	ldm	r3, {r0, r1, r2, r3}
57e235e0:	ebfffd30 	bl	57e22aa8 <hsearch_r>
		if (rv == NULL)
57e235e4:	e51b3020 	ldr	r3, [fp, #-32]
57e235e8:	e3530000 	cmp	r3, #0
57e235ec:	1a000003 	bne	57e23600 <himport_r+0x288>
			printf("himport_r: can't insert \"%s=%s\" into hash table\n",
57e235f0:	e59f0084 	ldr	r0, [pc, #132]	; 57e2367c <himport_r+0x304>
57e235f4:	e1a01004 	mov	r1, r4
57e235f8:	e1a02006 	mov	r2, r6
57e235fc:	ebff9792 	bl	57e0944c <printf>
				name, value);

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
57e23600:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
57e23604:	e1550002 	cmp	r5, r2
57e23608:	2a000002 	bcs	57e23618 <himport_r+0x2a0>
57e2360c:	e5d53000 	ldrb	r3, [r5]
57e23610:	e3530000 	cmp	r3, #0
57e23614:	1affff98 	bne	57e2347c <himport_r+0x104>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
57e23618:	e1a00009 	mov	r0, r9
57e2361c:	ebff98de 	bl	57e0999c <free>
57e23620:	e1a05007 	mov	r5, r7
57e23624:	e51b4038 	ldr	r4, [fp, #-56]	; 0x38

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
57e23628:	e3a06000 	mov	r6, #0
57e2362c:	ea00000b 	b	57e23660 <himport_r+0x2e8>
		if (localvars[i] == NULL)
57e23630:	e4940004 	ldr	r0, [r4], #4
57e23634:	e3500000 	cmp	r0, #0
57e23638:	0a000007 	beq	57e2365c <himport_r+0x2e4>
		 * This could mean two things:
		 * a) if the variable was present in current env, we delete it
		 * b) if the variable was not present in current env, we notify
		 *    it might be a typo
		 */
		if (hdelete_r(localvars[i], htab, flag) == 0)
57e2363c:	e1a01005 	mov	r1, r5
57e23640:	e59b2004 	ldr	r2, [fp, #4]
57e23644:	ebfffe50 	bl	57e22f8c <hdelete_r>
57e23648:	e3500000 	cmp	r0, #0
			printf("WARNING: '%s' neither in running nor in imported env!\n", localvars[i]);
57e2364c:	059f002c 	ldreq	r0, [pc, #44]	; 57e23680 <himport_r+0x308>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
57e23650:	159f002c 	ldrne	r0, [pc, #44]	; 57e23684 <himport_r+0x30c>
57e23654:	e5141004 	ldr	r1, [r4, #-4]
57e23658:	ebff977b 	bl	57e0944c <printf>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
57e2365c:	e2866001 	add	r6, r6, #1
57e23660:	e59b3008 	ldr	r3, [fp, #8]
57e23664:	e1560003 	cmp	r6, r3
57e23668:	bafffff0 	blt	57e23630 <himport_r+0x2b8>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
	}

	debug("INSERT: done\n");
	return 1;		/* everything OK */
57e2366c:	e3a00001 	mov	r0, #1
}
57e23670:	e24bd01c 	sub	sp, fp, #28
57e23674:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e23678:	57e79098 	.word	0x57e79098
57e2367c:	57e354d7 	.word	0x57e354d7
57e23680:	57e35508 	.word	0x57e35508
57e23684:	57e3553f 	.word	0x57e3553f

57e23688 <hwalk_r>:
/*
 * Walk all of the entries in the hash, calling the callback for each one.
 * this allows some generic operation to be performed on each element.
 */
int hwalk_r(struct hsearch_data *htab, int (*callback)(ENTRY *))
{
57e23688:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e2368c:	e1a04000 	mov	r4, r0
57e23690:	e1a07001 	mov	r7, r1
	int i;
	int retval;

	for (i = 1; i <= htab->size; ++i) {
57e23694:	e3a05014 	mov	r5, #20
57e23698:	e3a06001 	mov	r6, #1
57e2369c:	ea00000a 	b	57e236cc <hwalk_r+0x44>
		if (htab->table[i].used > 0) {
57e236a0:	e5943000 	ldr	r3, [r4]
57e236a4:	e0830005 	add	r0, r3, r5
57e236a8:	e7933005 	ldr	r3, [r3, r5]
57e236ac:	e3530000 	cmp	r3, #0
57e236b0:	da000003 	ble	57e236c4 <hwalk_r+0x3c>
			retval = callback(&htab->table[i].entry);
57e236b4:	e2800004 	add	r0, r0, #4
57e236b8:	e12fff37 	blx	r7
			if (retval)
57e236bc:	e3500000 	cmp	r0, #0
57e236c0:	18bd80f8 	popne	{r3, r4, r5, r6, r7, pc}
int hwalk_r(struct hsearch_data *htab, int (*callback)(ENTRY *))
{
	int i;
	int retval;

	for (i = 1; i <= htab->size; ++i) {
57e236c4:	e2866001 	add	r6, r6, #1
57e236c8:	e2855014 	add	r5, r5, #20
57e236cc:	e5943004 	ldr	r3, [r4, #4]
57e236d0:	e1560003 	cmp	r6, r3
57e236d4:	9afffff1 	bls	57e236a0 <hwalk_r+0x18>
			if (retval)
				return retval;
		}
	}

	return 0;
57e236d8:	e3a00000 	mov	r0, #0
}
57e236dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e236e0 <ldiv>:
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
57e236e0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e236e4:	e1a05001 	mov	r5, r1
57e236e8:	e1a04000 	mov	r4, r0
  ldiv_t result;

  result.quot = numer / denom;
57e236ec:	e1a00001 	mov	r0, r1
57e236f0:	e1a01002 	mov	r1, r2
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
57e236f4:	e1a07002 	mov	r7, r2
  ldiv_t result;

  result.quot = numer / denom;
57e236f8:	eb0020af 	bl	57e2b9bc <__divsi3>
  result.rem = numer % denom;
57e236fc:	e1a01007 	mov	r1, r7
ldiv_t
ldiv (long int numer, long int denom)
{
  ldiv_t result;

  result.quot = numer / denom;
57e23700:	e1a06000 	mov	r6, r0
  result.rem = numer % denom;
57e23704:	e1a00005 	mov	r0, r5
57e23708:	eb002133 	bl	57e2bbdc <__aeabi_idivmod>
     RESULT will always be positive.  This all boils down to: if
     NUMER >= 0, but REM < 0, we got the wrong answer.  In that
     case, to get the right answer, add 1 to QUOT and subtract
     DENOM from REM.  */

  if (numer >= 0 && result.rem < 0)
57e2370c:	e3550000 	cmp	r5, #0
57e23710:	ba000002 	blt	57e23720 <ldiv+0x40>
57e23714:	e3510000 	cmp	r1, #0
    {
      ++result.quot;
57e23718:	b2866001 	addlt	r6, r6, #1
      result.rem -= denom;
57e2371c:	b0671001 	rsblt	r1, r7, r1
57e23720:	e5846000 	str	r6, [r4]
57e23724:	e5841004 	str	r1, [r4, #4]
    }

  return result;
}
57e23728:	e1a00004 	mov	r0, r4
57e2372c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e23730 <skip_spaces>:
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
	while (isspace(*str))
57e23730:	e59f2018 	ldr	r2, [pc, #24]	; 57e23750 <skip_spaces+0x20>
 * @str: The string to be stripped.
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
57e23734:	e1a03000 	mov	r3, r0
	while (isspace(*str))
57e23738:	e1a00003 	mov	r0, r3
57e2373c:	e4d31001 	ldrb	r1, [r3], #1
57e23740:	e7d21001 	ldrb	r1, [r2, r1]
57e23744:	e3110020 	tst	r1, #32
57e23748:	1afffffa 	bne	57e23738 <skip_spaces+0x8>
		++str;
	return (char *)str;
}
57e2374c:	e12fff1e 	bx	lr
57e23750:	57e2d4d0 	.word	0x57e2d4d0

57e23754 <strim>:
 * Note that the first trailing whitespace is replaced with a %NUL-terminator
 * in the given string @s. Returns a pointer to the first non-whitespace
 * character in @s.
 */
char *strim(char *s)
{
57e23754:	e92d4010 	push	{r4, lr}
	size_t size;
	char *end;

	s = skip_spaces(s);
57e23758:	ebfffff4 	bl	57e23730 <skip_spaces>
57e2375c:	e1a04000 	mov	r4, r0
	size = strlen(s);
57e23760:	eb00023a 	bl	57e24050 <strlen>
	if (!size)
57e23764:	e2503000 	subs	r3, r0, #0
57e23768:	0a00000b 	beq	57e2379c <strim+0x48>
		return s;

	end = s + size - 1;
57e2376c:	e2433001 	sub	r3, r3, #1
	while (end >= s && isspace(*end))
57e23770:	e59f102c 	ldr	r1, [pc, #44]	; 57e237a4 <strim+0x50>
	s = skip_spaces(s);
	size = strlen(s);
	if (!size)
		return s;

	end = s + size - 1;
57e23774:	e0843003 	add	r3, r4, r3
	while (end >= s && isspace(*end))
57e23778:	e1530004 	cmp	r3, r4
57e2377c:	e1a02003 	mov	r2, r3
57e23780:	3a000003 	bcc	57e23794 <strim+0x40>
57e23784:	e4530001 	ldrb	r0, [r3], #-1
57e23788:	e7d10000 	ldrb	r0, [r1, r0]
57e2378c:	e3100020 	tst	r0, #32
57e23790:	1afffff8 	bne	57e23778 <strim+0x24>
		end--;
	*(end + 1) = '\0';
57e23794:	e3a03000 	mov	r3, #0
57e23798:	e5c23001 	strb	r3, [r2, #1]

	return s;
}
57e2379c:	e1a00004 	mov	r0, r4
57e237a0:	e8bd8010 	pop	{r4, pc}
57e237a4:	57e2d4d0 	.word	0x57e2d4d0

57e237a8 <lmb_add_region>:
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
57e237a8:	e590c000 	ldr	ip, [r0]
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
57e237ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
57e237b0:	e35c0001 	cmp	ip, #1
57e237b4:	1a000005 	bne	57e237d0 <lmb_add_region+0x28>
57e237b8:	e590500c 	ldr	r5, [r0, #12]
57e237bc:	e3550000 	cmp	r5, #0
		rgn->region[0].base = base;
57e237c0:	05801008 	streq	r1, [r0, #8]
		rgn->region[0].size = size;
57e237c4:	0580200c 	streq	r2, [r0, #12]
		return 0;
57e237c8:	01a00005 	moveq	r0, r5
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
57e237cc:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
57e237d0:	e1a04000 	mov	r4, r0
static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
		return 1;
	else if (base1 == base2 + size2)
57e237d4:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
57e237d8:	e0827001 	add	r7, r2, r1
57e237dc:	ea000019 	b	57e23848 <lmb_add_region+0xa0>
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
		phys_addr_t rgnbase = rgn->region[i].base;
57e237e0:	e5946008 	ldr	r6, [r4, #8]
		phys_size_t rgnsize = rgn->region[i].size;
57e237e4:	e594500c 	ldr	r5, [r4, #12]

		if ((rgnbase == base) && (rgnsize == size))
57e237e8:	e1550002 	cmp	r5, r2
57e237ec:	01560001 	cmpeq	r6, r1
57e237f0:	0a000054 	beq	57e23948 <lmb_add_region+0x1a0>
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
57e237f4:	e1560007 	cmp	r6, r7
57e237f8:	0a000005 	beq	57e23814 <lmb_add_region+0x6c>
		return 1;
	else if (base1 == base2 + size2)
57e237fc:	e0856006 	add	r6, r5, r6
57e23800:	e1510006 	cmp	r1, r6
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
57e23804:	e2844008 	add	r4, r4, #8
57e23808:	e2836001 	add	r6, r3, #1
		return 1;
	else if (base1 == base2 + size2)
57e2380c:	1a000051 	bne	57e23958 <lmb_add_region+0x1b0>
57e23810:	ea000007 	b	57e23834 <lmb_add_region+0x8c>
			/* Already have this region, so we're done */
			return 0;

		adjacent = lmb_addrs_adjacent(base,size,rgnbase,rgnsize);
		if ( adjacent > 0 ) {
			rgn->region[i].base -= size;
57e23814:	e2834001 	add	r4, r3, #1
57e23818:	e0627007 	rsb	r7, r2, r7
57e2381c:	e7807184 	str	r7, [r0, r4, lsl #3]
			rgn->region[i].size += size;
57e23820:	e0804184 	add	r4, r0, r4, lsl #3
57e23824:	e5945004 	ldr	r5, [r4, #4]
57e23828:	e0825005 	add	r5, r2, r5
57e2382c:	e5845004 	str	r5, [r4, #4]
57e23830:	ea000002 	b	57e23840 <lmb_add_region+0x98>
			coalesced++;
			break;
		}
		else if ( adjacent < 0 ) {
			rgn->region[i].size += size;
57e23834:	e0806186 	add	r6, r0, r6, lsl #3
57e23838:	e0855002 	add	r5, r5, r2
57e2383c:	e5865004 	str	r5, [r6, #4]
			coalesced++;
57e23840:	e3a05001 	mov	r5, #1
			break;
57e23844:	ea000002 	b	57e23854 <lmb_add_region+0xac>
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
57e23848:	e153000c 	cmp	r3, ip
57e2384c:	3affffe3 	bcc	57e237e0 <lmb_add_region+0x38>
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
57e23850:	e3a05000 	mov	r5, #0
			coalesced++;
			break;
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
57e23854:	e24c4001 	sub	r4, ip, #1
57e23858:	e1530004 	cmp	r3, r4
57e2385c:	2a00001e 	bcs	57e238dc <lmb_add_region+0x134>
57e23860:	e2836001 	add	r6, r3, #1

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
57e23864:	e080a186 	add	sl, r0, r6, lsl #3
}

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
57e23868:	e7907186 	ldr	r7, [r0, r6, lsl #3]
	phys_size_t size1 = rgn->region[r1].size;
57e2386c:	e59ab004 	ldr	fp, [sl, #4]
	phys_addr_t base2 = rgn->region[r2].base;
57e23870:	e2866001 	add	r6, r6, #1
57e23874:	e790a186 	ldr	sl, [r0, r6, lsl #3]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
57e23878:	e08b9007 	add	r9, fp, r7
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
57e2387c:	e0806186 	add	r6, r0, r6, lsl #3
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
57e23880:	e15a0009 	cmp	sl, r9
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
57e23884:	e5966004 	ldr	r6, [r6, #4]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
57e23888:	0a000002 	beq	57e23898 <lmb_add_region+0xf0>
		return 1;
	else if (base1 == base2 + size2)
57e2388c:	e086a00a 	add	sl, r6, sl
57e23890:	e157000a 	cmp	r7, sl
57e23894:	1a000010 	bne	57e238dc <lmb_add_region+0x134>

/* Assumption: base addr of region 1 < base addr of region 2 */
static void lmb_coalesce_regions(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	rgn->region[r1].size += rgn->region[r2].size;
57e23898:	e0802183 	add	r2, r0, r3, lsl #3
57e2389c:	e086600b 	add	r6, r6, fp
57e238a0:	e582600c 	str	r6, [r2, #12]
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
57e238a4:	e2832003 	add	r2, r3, #3
57e238a8:	e0802182 	add	r2, r0, r2, lsl #3
57e238ac:	ea000003 	b	57e238c0 <lmb_add_region+0x118>
static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
		rgn->region[i].base = rgn->region[i + 1].base;
57e238b0:	e5121008 	ldr	r1, [r2, #-8]
57e238b4:	e5021010 	str	r1, [r2, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
57e238b8:	e5121004 	ldr	r1, [r2, #-4]
57e238bc:	e502100c 	str	r1, [r2, #-12]
57e238c0:	e2833001 	add	r3, r3, #1

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
57e238c4:	e1530004 	cmp	r3, r4
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
57e238c8:	e2822008 	add	r2, r2, #8

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
57e238cc:	3afffff7 	bcc	57e238b0 <lmb_add_region+0x108>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
57e238d0:	e5804000 	str	r4, [r0]
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
		lmb_coalesce_regions(rgn, i, i+1);
		coalesced++;
57e238d4:	e2850001 	add	r0, r5, #1
57e238d8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
57e238dc:	e3550000 	cmp	r5, #0
57e238e0:	13a00001 	movne	r0, #1
57e238e4:	18bd8ef0 	popne	{r4, r5, r6, r7, r9, sl, fp, pc}
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
57e238e8:	e35c0007 	cmp	ip, #7
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
57e238ec:	928c3001 	addls	r3, ip, #1
57e238f0:	90803183 	addls	r3, r0, r3, lsl #3
		coalesced++;
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
57e238f4:	9a00000b 	bls	57e23928 <lmb_add_region+0x180>
57e238f8:	ea000014 	b	57e23950 <lmb_add_region+0x1a8>
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
		if (base < rgn->region[i].base) {
57e238fc:	e5335008 	ldr	r5, [r3, #-8]!
57e23900:	e1510005 	cmp	r1, r5
			rgn->region[i+1].base = rgn->region[i].base;
57e23904:	35835008 	strcc	r5, [r3, #8]
			rgn->region[i+1].size = rgn->region[i].size;
57e23908:	35935004 	ldrcc	r5, [r3, #4]
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
57e2390c:	32444001 	subcc	r4, r4, #1
		if (base < rgn->region[i].base) {
			rgn->region[i+1].base = rgn->region[i].base;
			rgn->region[i+1].size = rgn->region[i].size;
57e23910:	3583500c 	strcc	r5, [r3, #12]
		} else {
			rgn->region[i+1].base = base;
57e23914:	22844002 	addcs	r4, r4, #2
57e23918:	27801184 	strcs	r1, [r0, r4, lsl #3]
			rgn->region[i+1].size = size;
57e2391c:	20804184 	addcs	r4, r0, r4, lsl #3
57e23920:	25842004 	strcs	r2, [r4, #4]
			break;
57e23924:	2a000001 	bcs	57e23930 <lmb_add_region+0x188>
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
57e23928:	e3540000 	cmp	r4, #0
57e2392c:	aafffff2 	bge	57e238fc <lmb_add_region+0x154>
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
57e23930:	e5903008 	ldr	r3, [r0, #8]
		rgn->region[0].base = base;
		rgn->region[0].size = size;
	}

	rgn->cnt++;
57e23934:	e28cc001 	add	ip, ip, #1
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
57e23938:	e1510003 	cmp	r1, r3
		rgn->region[0].base = base;
57e2393c:	35801008 	strcc	r1, [r0, #8]
		rgn->region[0].size = size;
57e23940:	3580200c 	strcc	r2, [r0, #12]
	}

	rgn->cnt++;
57e23944:	e580c000 	str	ip, [r0]
		phys_addr_t rgnbase = rgn->region[i].base;
		phys_size_t rgnsize = rgn->region[i].size;

		if ((rgnbase == base) && (rgnsize == size))
			/* Already have this region, so we're done */
			return 0;
57e23948:	e3a00000 	mov	r0, #0
57e2394c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;
57e23950:	e3e00000 	mvn	r0, #0
	}

	rgn->cnt++;

	return 0;
}
57e23954:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
57e23958:	e1a03006 	mov	r3, r6
57e2395c:	eaffffb9 	b	57e23848 <lmb_add_region+0xa0>

57e23960 <lmb_dump_all>:
			(long long unsigned)lmb->reserved.region[i].base);
		debug("		     .size = 0x%llx\n",
			(long long unsigned)lmb->reserved.region[i].size);
	}
#endif /* DEBUG */
}
57e23960:	e12fff1e 	bx	lr

57e23964 <lmb_init>:
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
57e23964:	e3a03000 	mov	r3, #0
	lmb->memory.region[0].size = 0;
	lmb->memory.cnt = 1;
57e23968:	e3a02001 	mov	r2, #1
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
57e2396c:	e5803008 	str	r3, [r0, #8]
	lmb->memory.region[0].size = 0;
57e23970:	e580300c 	str	r3, [r0, #12]
	lmb->memory.cnt = 1;
57e23974:	e880000c 	stm	r0, {r2, r3}
	lmb->memory.size = 0;

	/* Ditto. */
	lmb->reserved.region[0].base = 0;
57e23978:	e5803058 	str	r3, [r0, #88]	; 0x58
	lmb->reserved.region[0].size = 0;
57e2397c:	e580305c 	str	r3, [r0, #92]	; 0x5c
	lmb->reserved.cnt = 1;
57e23980:	e5802050 	str	r2, [r0, #80]	; 0x50
	lmb->reserved.size = 0;
57e23984:	e5803054 	str	r3, [r0, #84]	; 0x54
}
57e23988:	e12fff1e 	bx	lr

57e2398c <lmb_add>:
/* This routine may be called with relocation disabled. */
long lmb_add(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
57e2398c:	eaffff85 	b	57e237a8 <lmb_add_region>

57e23990 <lmb_free>:
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
57e23990:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
57e23994:	e3a04000 	mov	r4, #0

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
57e23998:	e082c001 	add	ip, r2, r1
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
57e2399c:	e5907050 	ldr	r7, [r0, #80]	; 0x50
57e239a0:	e1a06000 	mov	r6, r0
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */
57e239a4:	e1a03004 	mov	r3, r4
57e239a8:	e1a05004 	mov	r5, r4

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
57e239ac:	ea000007 	b	57e239d0 <lmb_free+0x40>
		rgnbegin = rgn->region[i].base;
57e239b0:	e5965058 	ldr	r5, [r6, #88]	; 0x58
		rgnend = rgnbegin + rgn->region[i].size;
57e239b4:	e596305c 	ldr	r3, [r6, #92]	; 0x5c
57e239b8:	e2866008 	add	r6, r6, #8
57e239bc:	e0853003 	add	r3, r5, r3

		if ((rgnbegin <= base) && (end <= rgnend))
57e239c0:	e15c0003 	cmp	ip, r3
57e239c4:	91550001 	cmpls	r5, r1
57e239c8:	9a000003 	bls	57e239dc <lmb_free+0x4c>
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
57e239cc:	e2844001 	add	r4, r4, #1
57e239d0:	e1540007 	cmp	r4, r7
57e239d4:	e1a0a004 	mov	sl, r4
57e239d8:	3afffff4 	bcc	57e239b0 <lmb_free+0x20>
		if ((rgnbegin <= base) && (end <= rgnend))
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
57e239dc:	e1540007 	cmp	r4, r7
57e239e0:	0a000032 	beq	57e23ab0 <lmb_free+0x120>
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
57e239e4:	e1550001 	cmp	r5, r1
57e239e8:	13a05000 	movne	r5, #0
57e239ec:	03a05001 	moveq	r5, #1
57e239f0:	e153000c 	cmp	r3, ip
57e239f4:	13a06000 	movne	r6, #0
57e239f8:	03a06001 	moveq	r6, #1
57e239fc:	e0169005 	ands	r9, r6, r5
57e23a00:	0a00000e 	beq	57e23a40 <lmb_free+0xb0>
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
57e23a04:	e284400c 	add	r4, r4, #12
57e23a08:	e0804184 	add	r4, r0, r4, lsl #3

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
57e23a0c:	e2477001 	sub	r7, r7, #1
57e23a10:	ea000004 	b	57e23a28 <lmb_free+0x98>
		rgn->region[i].base = rgn->region[i + 1].base;
57e23a14:	e5143008 	ldr	r3, [r4, #-8]
57e23a18:	e28aa001 	add	sl, sl, #1
57e23a1c:	e5043010 	str	r3, [r4, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
57e23a20:	e5143004 	ldr	r3, [r4, #-4]
57e23a24:	e504300c 	str	r3, [r4, #-12]

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
57e23a28:	e15a0007 	cmp	sl, r7
57e23a2c:	e2844008 	add	r4, r4, #8
57e23a30:	3afffff7 	bcc	57e23a14 <lmb_free+0x84>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
57e23a34:	e5807050 	str	r7, [r0, #80]	; 0x50
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
		lmb_remove_region(rgn, i);
		return 0;
57e23a38:	e3a00000 	mov	r0, #0
57e23a3c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if region is matching at the front */
	if (rgnbegin == base) {
57e23a40:	e3550000 	cmp	r5, #0
57e23a44:	0a000007 	beq	57e23a68 <lmb_free+0xd8>
		rgn->region[i].base = end;
57e23a48:	e284400b 	add	r4, r4, #11
57e23a4c:	e780c184 	str	ip, [r0, r4, lsl #3]
		rgn->region[i].size -= size;
57e23a50:	e0800184 	add	r0, r0, r4, lsl #3
57e23a54:	e5903004 	ldr	r3, [r0, #4]
57e23a58:	e0622003 	rsb	r2, r2, r3
57e23a5c:	e5802004 	str	r2, [r0, #4]
		return 0;
57e23a60:	e1a00009 	mov	r0, r9
57e23a64:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
57e23a68:	e3560000 	cmp	r6, #0
57e23a6c:	e284400b 	add	r4, r4, #11
57e23a70:	0a000005 	beq	57e23a8c <lmb_free+0xfc>
		rgn->region[i].size -= size;
57e23a74:	e0804184 	add	r4, r0, r4, lsl #3
57e23a78:	e5943004 	ldr	r3, [r4, #4]
		return 0;
57e23a7c:	e1a00005 	mov	r0, r5
		return 0;
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
		rgn->region[i].size -= size;
57e23a80:	e0622003 	rsb	r2, r2, r3
57e23a84:	e5842004 	str	r2, [r4, #4]
		return 0;
57e23a88:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
57e23a8c:	e0802184 	add	r2, r0, r4, lsl #3
57e23a90:	e7904184 	ldr	r4, [r0, r4, lsl #3]
	return lmb_add_region(rgn, end, rgnend - end);
57e23a94:	e2800050 	add	r0, r0, #80	; 0x50

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
57e23a98:	e0641001 	rsb	r1, r4, r1
57e23a9c:	e5821004 	str	r1, [r2, #4]
	return lmb_add_region(rgn, end, rgnend - end);
57e23aa0:	e1a0100c 	mov	r1, ip
57e23aa4:	e06c2003 	rsb	r2, ip, r3
}
57e23aa8:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
57e23aac:	eaffff3d 	b	57e237a8 <lmb_add_region>
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
		return -1;
57e23ab0:	e3e00000 	mvn	r0, #0
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
}
57e23ab4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

57e23ab8 <lmb_reserve>:

long lmb_reserve(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->reserved);

	return lmb_add_region(_rgn, base, size);
57e23ab8:	e2800050 	add	r0, r0, #80	; 0x50
57e23abc:	eaffff39 	b	57e237a8 <lmb_add_region>

57e23ac0 <lmb_overlaps_region>:
}

long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
57e23ac0:	e92d4030 	push	{r4, r5, lr}
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
57e23ac4:	e590c000 	ldr	ip, [r0]
57e23ac8:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
57e23acc:	e0822001 	add	r2, r2, r1
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
57e23ad0:	ea000008 	b	57e23af8 <lmb_overlaps_region+0x38>
		phys_addr_t rgnbase = rgn->region[i].base;
57e23ad4:	e5904008 	ldr	r4, [r0, #8]
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
57e23ad8:	e590500c 	ldr	r5, [r0, #12]
57e23adc:	e0845005 	add	r5, r4, r5
57e23ae0:	e1510005 	cmp	r1, r5
57e23ae4:	2a000007 	bcs	57e23b08 <lmb_overlaps_region+0x48>
57e23ae8:	e1540002 	cmp	r4, r2
57e23aec:	2a000005 	bcs	57e23b08 <lmb_overlaps_region+0x48>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
57e23af0:	e1a00003 	mov	r0, r3
57e23af4:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
57e23af8:	e153000c 	cmp	r3, ip
57e23afc:	3afffff4 	bcc	57e23ad4 <lmb_overlaps_region+0x14>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
57e23b00:	e3e00000 	mvn	r0, #0
}
57e23b04:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
57e23b08:	e2833001 	add	r3, r3, #1
57e23b0c:	e2800008 	add	r0, r0, #8
57e23b10:	eafffff8 	b	57e23af8 <lmb_overlaps_region+0x38>

57e23b14 <__lmb_alloc_base>:
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
57e23b14:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
57e23b18:	e5907000 	ldr	r7, [r0]
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
57e23b1c:	e1a09003 	mov	r9, r3
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
57e23b20:	e2803050 	add	r3, r0, #80	; 0x50
57e23b24:	e58d300c 	str	r3, [sp, #12]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
57e23b28:	e2623000 	rsb	r3, r2, #0
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
57e23b2c:	e1a0c002 	mov	ip, r2
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
57e23b30:	e247b001 	sub	fp, r7, #1
57e23b34:	e1a02003 	mov	r2, r3
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
57e23b38:	e2877001 	add	r7, r7, #1
{
57e23b3c:	e1a04001 	mov	r4, r1
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
57e23b40:	e0807187 	add	r7, r0, r7, lsl #3
57e23b44:	e1a03000 	mov	r3, r0
57e23b48:	e1a05002 	mov	r5, r2
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
57e23b4c:	ea000036 	b	57e23c2c <__lmb_alloc_base+0x118>
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;
57e23b50:	e5176004 	ldr	r6, [r7, #-4]
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
		phys_addr_t lmbbase = lmb->memory.region[i].base;
57e23b54:	e517a008 	ldr	sl, [r7, #-8]
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
57e23b58:	e1560004 	cmp	r6, r4
57e23b5c:	3a000030 	bcc	57e23c24 <__lmb_alloc_base+0x110>
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
57e23b60:	e3590000 	cmp	r9, #0
			base = lmb_align_down(lmbbase + lmbsize - size, align);
57e23b64:	0086600a 	addeq	r6, r6, sl
57e23b68:	00646006 	rsbeq	r6, r4, r6
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
57e23b6c:	0a000005 	beq	57e23b88 <__lmb_alloc_base+0x74>
			base = lmb_align_down(lmbbase + lmbsize - size, align);
		else if (lmbbase < max_addr) {
57e23b70:	e15a0009 	cmp	sl, r9
57e23b74:	2a00002a 	bcs	57e23c24 <__lmb_alloc_base+0x110>
			base = min(lmbbase + lmbsize, max_addr);
57e23b78:	e086600a 	add	r6, r6, sl
			base = lmb_align_down(base - size, align);
57e23b7c:	e1590006 	cmp	r9, r6
57e23b80:	90646009 	rsbls	r6, r4, r9
57e23b84:	80646006 	rsbhi	r6, r4, r6
57e23b88:	e58db008 	str	fp, [sp, #8]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
57e23b8c:	e0066005 	and	r6, r6, r5
57e23b90:	e1a0b007 	mov	fp, r7
57e23b94:	e1a07003 	mov	r7, r3
57e23b98:	ea000017 	b	57e23bfc <__lmb_alloc_base+0xe8>
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
57e23b9c:	e59d000c 	ldr	r0, [sp, #12]
57e23ba0:	e1a01006 	mov	r1, r6
57e23ba4:	e1a02004 	mov	r2, r4
57e23ba8:	e58dc004 	str	ip, [sp, #4]
57e23bac:	ebffffc3 	bl	57e23ac0 <lmb_overlaps_region>
			if (j < 0) {
57e23bb0:	e3500000 	cmp	r0, #0
57e23bb4:	e59dc004 	ldr	ip, [sp, #4]
57e23bb8:	aa000009 	bge	57e23be4 <__lmb_alloc_base+0xd0>
	return addr & ~(size - 1);
}

static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
57e23bbc:	e2444001 	sub	r4, r4, #1
57e23bc0:	e26c2000 	rsb	r2, ip, #0
57e23bc4:	e084c00c 	add	ip, r4, ip

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
			if (j < 0) {
				/* This area isn't reserved, take it */
				if (lmb_add_region(&lmb->reserved, base,
57e23bc8:	e1a01006 	mov	r1, r6
57e23bcc:	e59d000c 	ldr	r0, [sp, #12]
57e23bd0:	e002200c 	and	r2, r2, ip
57e23bd4:	ebfffef3 	bl	57e237a8 <lmb_add_region>
							lmb_align_up(size,
								align)) < 0)
					return 0;
57e23bd8:	e3500000 	cmp	r0, #0
57e23bdc:	b3a06000 	movlt	r6, #0
57e23be0:	ea000014 	b	57e23c38 <__lmb_alloc_base+0x124>
				return base;
			}
			res_base = lmb->reserved.region[j].base;
57e23be4:	e280000b 	add	r0, r0, #11
57e23be8:	e7976180 	ldr	r6, [r7, r0, lsl #3]
			if (res_base < size)
57e23bec:	e1560004 	cmp	r6, r4
57e23bf0:	3a000008 	bcc	57e23c18 <__lmb_alloc_base+0x104>
				break;
			base = lmb_align_down(res_base - size, align);
57e23bf4:	e0646006 	rsb	r6, r4, r6
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
57e23bf8:	e0056006 	and	r6, r5, r6
			base = min(lmbbase + lmbsize, max_addr);
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
57e23bfc:	e15a0006 	cmp	sl, r6
57e23c00:	83a02000 	movhi	r2, #0
57e23c04:	93a02001 	movls	r2, #1
57e23c08:	e3560000 	cmp	r6, #0
57e23c0c:	03a02000 	moveq	r2, #0
57e23c10:	e3520000 	cmp	r2, #0
57e23c14:	1affffe0 	bne	57e23b9c <__lmb_alloc_base+0x88>
57e23c18:	e1a03007 	mov	r3, r7
57e23c1c:	e1a0700b 	mov	r7, fp
57e23c20:	e59db008 	ldr	fp, [sp, #8]
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
57e23c24:	e24bb001 	sub	fp, fp, #1
57e23c28:	e2477008 	sub	r7, r7, #8
57e23c2c:	e35b0000 	cmp	fp, #0
57e23c30:	aaffffc6 	bge	57e23b50 <__lmb_alloc_base+0x3c>
			if (res_base < size)
				break;
			base = lmb_align_down(res_base - size, align);
		}
	}
	return 0;
57e23c34:	e3a06000 	mov	r6, #0
}
57e23c38:	e1a00006 	mov	r0, r6
57e23c3c:	e28dd010 	add	sp, sp, #16
57e23c40:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e23c44 <lmb_alloc_base>:
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
}

phys_addr_t lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
57e23c44:	e92d4070 	push	{r4, r5, r6, lr}
57e23c48:	e1a05001 	mov	r5, r1
57e23c4c:	e1a04003 	mov	r4, r3
	phys_addr_t alloc;

	alloc = __lmb_alloc_base(lmb, size, align, max_addr);
57e23c50:	ebffffaf 	bl	57e23b14 <__lmb_alloc_base>

	if (alloc == 0)
57e23c54:	e2506000 	subs	r6, r0, #0
57e23c58:	1a000003 	bne	57e23c6c <lmb_alloc_base+0x28>
		printf("ERROR: Failed to allocate 0x%lx bytes below 0x%lx.\n",
57e23c5c:	e59f0010 	ldr	r0, [pc, #16]	; 57e23c74 <lmb_alloc_base+0x30>
57e23c60:	e1a01005 	mov	r1, r5
57e23c64:	e1a02004 	mov	r2, r4
57e23c68:	ebff95f7 	bl	57e0944c <printf>
		      (ulong)size, (ulong)max_addr);

	return alloc;
}
57e23c6c:	e1a00006 	mov	r0, r6
57e23c70:	e8bd8070 	pop	{r4, r5, r6, pc}
57e23c74:	57e35570 	.word	0x57e35570

57e23c78 <lmb_alloc>:
	return (i < rgn->cnt) ? i : -1;
}

phys_addr_t lmb_alloc(struct lmb *lmb, phys_size_t size, ulong align)
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
57e23c78:	e3a03000 	mov	r3, #0
57e23c7c:	eafffff0 	b	57e23c44 <lmb_alloc_base>

57e23c80 <lmb_is_reserved>:
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
57e23c80:	e92d4010 	push	{r4, lr}
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
57e23c84:	e590c050 	ldr	ip, [r0, #80]	; 0x50
57e23c88:	e3a03000 	mov	r3, #0
57e23c8c:	ea00000d 	b	57e23cc8 <lmb_is_reserved+0x48>
		}
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
57e23c90:	e1a04000 	mov	r4, r0
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
57e23c94:	e5902058 	ldr	r2, [r0, #88]	; 0x58
57e23c98:	e594405c 	ldr	r4, [r4, #92]	; 0x5c
57e23c9c:	e2800008 	add	r0, r0, #8
57e23ca0:	e0824004 	add	r4, r2, r4
57e23ca4:	e2444001 	sub	r4, r4, #1
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
57e23ca8:	e1510004 	cmp	r1, r4
57e23cac:	83a04000 	movhi	r4, #0
57e23cb0:	93a04001 	movls	r4, #1
57e23cb4:	e1510002 	cmp	r1, r2
57e23cb8:	33a04000 	movcc	r4, #0
57e23cbc:	e3540000 	cmp	r4, #0
57e23cc0:	1a000004 	bne	57e23cd8 <lmb_is_reserved+0x58>

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
57e23cc4:	e2833001 	add	r3, r3, #1
57e23cc8:	e153000c 	cmp	r3, ip
57e23ccc:	3affffef 	bcc	57e23c90 <lmb_is_reserved+0x10>
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
	}
	return 0;
57e23cd0:	e3a00000 	mov	r0, #0
57e23cd4:	e8bd8010 	pop	{r4, pc}

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
57e23cd8:	e3a00001 	mov	r0, #1
	}
	return 0;
}
57e23cdc:	e8bd8010 	pop	{r4, pc}

57e23ce0 <__board_lmb_reserve>:

void __board_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific board_lmb_reserve() */
}
57e23ce0:	e12fff1e 	bx	lr

57e23ce4 <__arch_lmb_reserve>:
void board_lmb_reserve(struct lmb *lmb) __attribute__((weak, alias("__board_lmb_reserve")));

void __arch_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific arch_lmb_reserve() */
}
57e23ce4:	e12fff1e 	bx	lr

57e23ce8 <string_to_ip>:
 */

#include <common.h>

IPaddr_t string_to_ip(const char *s)
{
57e23ce8:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
57e23cec:	e2504000 	subs	r4, r0, #0
		return(0);
57e23cf0:	01a00004 	moveq	r0, r4
{
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
57e23cf4:	0a000019 	beq	57e23d60 <string_to_ip+0x78>
57e23cf8:	e3a06004 	mov	r6, #4
57e23cfc:	e3a05000 	mov	r5, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
57e23d00:	e08d7006 	add	r7, sp, r6
57e23d04:	e3540000 	cmp	r4, #0
57e23d08:	01a00004 	moveq	r0, r4
57e23d0c:	0a000003 	beq	57e23d20 <string_to_ip+0x38>
57e23d10:	e1a00004 	mov	r0, r4
57e23d14:	e1a01007 	mov	r1, r7
57e23d18:	e3a0200a 	mov	r2, #10
57e23d1c:	eb0004e0 	bl	57e250a4 <simple_strtoul>
		addr <<= 8;
		addr |= (val & 0xFF);
57e23d20:	e20000ff 	and	r0, r0, #255	; 0xff
		if (s) {
57e23d24:	e3540000 	cmp	r4, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
		addr <<= 8;
		addr |= (val & 0xFF);
57e23d28:	e1805405 	orr	r5, r0, r5, lsl #8
		if (s) {
57e23d2c:	0a000003 	beq	57e23d40 <string_to_ip+0x58>
			s = (*e) ? e+1 : e;
57e23d30:	e59d4004 	ldr	r4, [sp, #4]
57e23d34:	e5d43000 	ldrb	r3, [r4]
57e23d38:	e3530000 	cmp	r3, #0
57e23d3c:	12844001 	addne	r4, r4, #1
	int i;

	if (s == NULL)
		return(0);

	for (addr=0, i=0; i<4; ++i) {
57e23d40:	e2566001 	subs	r6, r6, #1
57e23d44:	1affffee 	bne	57e23d04 <string_to_ip+0x1c>
57e23d48:	e1a00c05 	lsl	r0, r5, #24
57e23d4c:	e1800c25 	orr	r0, r0, r5, lsr #24
57e23d50:	e2054cff 	and	r4, r5, #65280	; 0xff00
57e23d54:	e1800404 	orr	r0, r0, r4, lsl #8
57e23d58:	e20558ff 	and	r5, r5, #16711680	; 0xff0000
57e23d5c:	e1800425 	orr	r0, r0, r5, lsr #8
			s = (*e) ? e+1 : e;
		}
	}

	return (htonl(addr));
}
57e23d60:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

57e23d64 <qsort>:

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
57e23d64:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
57e23d68:	e3520000 	cmp	r2, #0
57e23d6c:	13510001 	cmpne	r1, #1

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
57e23d70:	e58d0008 	str	r0, [sp, #8]
57e23d74:	e1a06001 	mov	r6, r1
57e23d78:	e58d300c 	str	r3, [sp, #12]
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
57e23d7c:	e1a04002 	mov	r4, r2
57e23d80:	9a000031 	bls	57e23e4c <qsort+0xe8>
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
57e23d84:	e2410001 	sub	r0, r1, #1
57e23d88:	e3a01003 	mov	r1, #3
57e23d8c:	eb001e87 	bl	57e2b7b0 <__udivsi3>
57e23d90:	e3a05000 	mov	r5, #0

	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
57e23d94:	e0855085 	add	r5, r5, r5, lsl #1
57e23d98:	e2855001 	add	r5, r5, #1
		} while (wgap < (nel-1)/3);
57e23d9c:	e1550000 	cmp	r5, r0
57e23da0:	3afffffb 	bcc	57e23d94 <qsort+0x30>
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
57e23da4:	e0020496 	mul	r2, r6, r4
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
57e23da8:	e0050594 	mul	r5, r4, r5
		nel *= width;			/* Convert nel to 'wnel' */
57e23dac:	e58d2004 	str	r2, [sp, #4]

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
57e23db0:	e2653000 	rsb	r3, r5, #0
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
57e23db4:	e0859004 	add	r9, r5, r4
	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
57e23db8:	e3a07000 	mov	r7, #0

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
57e23dbc:	e1a0b003 	mov	fp, r3
57e23dc0:	e59d3008 	ldr	r3, [sp, #8]
57e23dc4:	e0836007 	add	r6, r3, r7
57e23dc8:	e1a03007 	mov	r3, r7
57e23dcc:	e086a005 	add	sl, r6, r5
					register char *b;

					j -= wgap;
					a = j + ((char *)base);
					b = a + wgap;
					if ((*comp)(a, b) <= 0) {
57e23dd0:	e58d3000 	str	r3, [sp]
57e23dd4:	e1a00006 	mov	r0, r6
57e23dd8:	e1a0100a 	mov	r1, sl
57e23ddc:	e59d200c 	ldr	r2, [sp, #12]
57e23de0:	e12fff32 	blx	r2
57e23de4:	e3500000 	cmp	r0, #0
57e23de8:	e59d3000 	ldr	r3, [sp]
57e23dec:	da00000b 	ble	57e23e20 <qsort+0xbc>
57e23df0:	e3a02000 	mov	r2, #0
						break;
					}
					k = width;
					do {
						tmp = *a;
57e23df4:	e7d61002 	ldrb	r1, [r6, r2]
						*a++ = *b;
57e23df8:	e7da0002 	ldrb	r0, [sl, r2]
57e23dfc:	e7c60002 	strb	r0, [r6, r2]
						*b++ = tmp;
57e23e00:	e7ca1002 	strb	r1, [sl, r2]
57e23e04:	e2822001 	add	r2, r2, #1
					} while (--k);
57e23e08:	e1540002 	cmp	r4, r2
57e23e0c:	1afffff8 	bne	57e23df4 <qsort+0x90>
57e23e10:	e087700b 	add	r7, r7, fp
				} while (j >= wgap);
57e23e14:	e1770005 	cmn	r7, r5
					k = width;
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
57e23e18:	e086600b 	add	r6, r6, fp
				} while (j >= wgap);
57e23e1c:	3affffea 	bcc	57e23dcc <qsort+0x68>
57e23e20:	e0899004 	add	r9, r9, r4
				i += width;
			} while (i < nel);
57e23e24:	e59d2004 	ldr	r2, [sp, #4]
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
				} while (j >= wgap);
57e23e28:	e0837004 	add	r7, r3, r4
				i += width;
			} while (i < nel);
57e23e2c:	e0643009 	rsb	r3, r4, r9
57e23e30:	e1530002 	cmp	r3, r2
57e23e34:	3affffe1 	bcc	57e23dc0 <qsort+0x5c>
			wgap = (wgap - width)/3;
57e23e38:	e0640005 	rsb	r0, r4, r5
57e23e3c:	e3a01003 	mov	r1, #3
57e23e40:	eb001e5a 	bl	57e2b7b0 <__udivsi3>
		} while (wgap);
57e23e44:	e2505000 	subs	r5, r0, #0
57e23e48:	1affffd8 	bne	57e23db0 <qsort+0x4c>
	}
}
57e23e4c:	e8bd8eff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

57e23e50 <strcmp_compar>:

int strcmp_compar(const void *p1, const void *p2)
{
	return strcmp(*(const char **)p1, *(const char **)p2);
57e23e50:	e5900000 	ldr	r0, [r0]
57e23e54:	e5911000 	ldr	r1, [r1]
57e23e58:	ea000051 	b	57e23fa4 <strcmp>

57e23e5c <strncasecmp>:
{
	/* Yes, Virginia, it had better be unsigned */
	unsigned char c1, c2;

	c1 = 0;	c2 = 0;
	if (len) {
57e23e5c:	e3520000 	cmp	r2, #0
int strncasecmp(const char *s1, const char *s2, size_t len)
{
	/* Yes, Virginia, it had better be unsigned */
	unsigned char c1, c2;

	c1 = 0;	c2 = 0;
57e23e60:	01a03002 	moveq	r3, r2
 * @s1: One string
 * @s2: The other string
 * @len: the maximum number of characters to compare
 */
int strncasecmp(const char *s1, const char *s2, size_t len)
{
57e23e64:	e92d4070 	push	{r4, r5, r6, lr}
	/* Yes, Virginia, it had better be unsigned */
	unsigned char c1, c2;

	c1 = 0;	c2 = 0;
57e23e68:	01a0c003 	moveq	ip, r3
	if (len) {
57e23e6c:	0a000016 	beq	57e23ecc <strncasecmp+0x70>
#define isascii(c) (((unsigned char)(c))<=0x7f)
#define toascii(c) (((unsigned char)(c))&0x7f)

static inline unsigned char __tolower(unsigned char c)
{
	if (isupper(c))
57e23e70:	e59f505c 	ldr	r5, [pc, #92]	; 57e23ed4 <strncasecmp+0x78>
57e23e74:	e3a04000 	mov	r4, #0
		do {
			c1 = *s1; c2 = *s2;
57e23e78:	e7d0c004 	ldrb	ip, [r0, r4]
57e23e7c:	e7d13004 	ldrb	r3, [r1, r4]
			s1++; s2++;
			if (!c1)
57e23e80:	e35c0000 	cmp	ip, #0
57e23e84:	0a000010 	beq	57e23ecc <strncasecmp+0x70>
				break;
			if (!c2)
57e23e88:	e3530000 	cmp	r3, #0
57e23e8c:	0a00000e 	beq	57e23ecc <strncasecmp+0x70>
				break;
			if (c1 == c2)
57e23e90:	e15c0003 	cmp	ip, r3
57e23e94:	0a000009 	beq	57e23ec0 <strncasecmp+0x64>
57e23e98:	e7d5600c 	ldrb	r6, [r5, ip]
57e23e9c:	e3160001 	tst	r6, #1
57e23ea0:	e7d56003 	ldrb	r6, [r5, r3]
		c -= 'A'-'a';
57e23ea4:	128cc020 	addne	ip, ip, #32
57e23ea8:	120cc0ff 	andne	ip, ip, #255	; 0xff
#define isascii(c) (((unsigned char)(c))<=0x7f)
#define toascii(c) (((unsigned char)(c))&0x7f)

static inline unsigned char __tolower(unsigned char c)
{
	if (isupper(c))
57e23eac:	e3160001 	tst	r6, #1
		c -= 'A'-'a';
57e23eb0:	12833020 	addne	r3, r3, #32
57e23eb4:	120330ff 	andne	r3, r3, #255	; 0xff
				continue;
			c1 = tolower(c1);
			c2 = tolower(c2);
			if (c1 != c2)
57e23eb8:	e15c0003 	cmp	ip, r3
57e23ebc:	1a000002 	bne	57e23ecc <strncasecmp+0x70>
57e23ec0:	e2844001 	add	r4, r4, #1
				break;
		} while (--len);
57e23ec4:	e1520004 	cmp	r2, r4
57e23ec8:	1affffea 	bne	57e23e78 <strncasecmp+0x1c>
	}
	return (int)c1 - (int)c2;
}
57e23ecc:	e063000c 	rsb	r0, r3, ip
57e23ed0:	e8bd8070 	pop	{r4, r5, r6, pc}
57e23ed4:	57e2d4d0 	.word	0x57e2d4d0

57e23ed8 <strcasecmp>:
 * @s1: One string
 * @s2: The other string
 */
int strcasecmp(const char *s1, const char *s2)
{
	return strncasecmp(s1, s2, -1U);
57e23ed8:	e3e02000 	mvn	r2, #0
57e23edc:	eaffffde 	b	57e23e5c <strncasecmp>

57e23ee0 <strcpy>:
 */
char * strcpy(char * dest,const char *src)
{
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
57e23ee0:	e3a03000 	mov	r3, #0
57e23ee4:	e7d12003 	ldrb	r2, [r1, r3]
57e23ee8:	e3520000 	cmp	r2, #0
57e23eec:	e7c02003 	strb	r2, [r0, r3]
57e23ef0:	e2833001 	add	r3, r3, #1
57e23ef4:	1afffffa 	bne	57e23ee4 <strcpy+0x4>
		/* nothing */;
	return tmp;
}
57e23ef8:	e12fff1e 	bx	lr

57e23efc <strncpy>:
 */
char * strncpy(char * dest,const char *src,size_t count)
{
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
57e23efc:	e3a03000 	mov	r3, #0
57e23f00:	e3520000 	cmp	r2, #0
57e23f04:	012fff1e 	bxeq	lr
57e23f08:	e7d1c003 	ldrb	ip, [r1, r3]
57e23f0c:	e2422001 	sub	r2, r2, #1
57e23f10:	e35c0000 	cmp	ip, #0
57e23f14:	e7c0c003 	strb	ip, [r0, r3]
57e23f18:	e2833001 	add	r3, r3, #1
57e23f1c:	1afffff7 	bne	57e23f00 <strncpy+0x4>
		/* nothing */;

	return tmp;
}
57e23f20:	e12fff1e 	bx	lr

57e23f24 <strcat>:
 */
char * strcat(char * dest, const char * src)
{
	char *tmp = dest;

	while (*dest)
57e23f24:	e1a0c000 	mov	ip, r0
57e23f28:	e5dc3000 	ldrb	r3, [ip]
57e23f2c:	e1a0200c 	mov	r2, ip
57e23f30:	e3530000 	cmp	r3, #0
57e23f34:	e28cc001 	add	ip, ip, #1
57e23f38:	1afffffa 	bne	57e23f28 <strcat+0x4>
		dest++;
	while ((*dest++ = *src++) != '\0')
57e23f3c:	e7d1c003 	ldrb	ip, [r1, r3]
57e23f40:	e35c0000 	cmp	ip, #0
57e23f44:	e7c2c003 	strb	ip, [r2, r3]
57e23f48:	e2833001 	add	r3, r3, #1
57e23f4c:	1afffffa 	bne	57e23f3c <strcat+0x18>
		;

	return tmp;
}
57e23f50:	e12fff1e 	bx	lr

57e23f54 <strncat>:
 */
char * strncat(char *dest, const char *src, size_t count)
{
	char *tmp = dest;

	if (count) {
57e23f54:	e3520000 	cmp	r2, #0
 *
 * Note that in contrast to strncpy, strncat ensures the result is
 * terminated.
 */
char * strncat(char *dest, const char *src, size_t count)
{
57e23f58:	e92d4010 	push	{r4, lr}
	char *tmp = dest;

	if (count) {
57e23f5c:	08bd8010 	popeq	{r4, pc}
57e23f60:	e1a04000 	mov	r4, r0
57e23f64:	e1a0c004 	mov	ip, r4
		while (*dest)
57e23f68:	e4d43001 	ldrb	r3, [r4], #1
57e23f6c:	e3530000 	cmp	r3, #0
57e23f70:	1afffffb 	bne	57e23f64 <strncat+0x10>
57e23f74:	ea000005 	b	57e23f90 <strncat+0x3c>
57e23f78:	e2833001 	add	r3, r3, #1
			dest++;
		while ((*dest++ = *src++)) {
			if (--count == 0) {
57e23f7c:	e1520003 	cmp	r2, r3
57e23f80:	1a000002 	bne	57e23f90 <strncat+0x3c>
				*dest = '\0';
57e23f84:	e3a03000 	mov	r3, #0
57e23f88:	e5cc3000 	strb	r3, [ip]
				break;
57e23f8c:	e8bd8010 	pop	{r4, pc}
	char *tmp = dest;

	if (count) {
		while (*dest)
			dest++;
		while ((*dest++ = *src++)) {
57e23f90:	e7d14003 	ldrb	r4, [r1, r3]
57e23f94:	e3540000 	cmp	r4, #0
57e23f98:	e4cc4001 	strb	r4, [ip], #1
57e23f9c:	1afffff5 	bne	57e23f78 <strncat+0x24>
			}
		}
	}

	return tmp;
}
57e23fa0:	e8bd8010 	pop	{r4, pc}

57e23fa4 <strcmp>:
 * strcmp - Compare two strings
 * @cs: One string
 * @ct: Another string
 */
int strcmp(const char * cs,const char * ct)
{
57e23fa4:	e3a03000 	mov	r3, #0
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
57e23fa8:	e7d02003 	ldrb	r2, [r0, r3]
57e23fac:	e7d1c003 	ldrb	ip, [r1, r3]
57e23fb0:	e06cc002 	rsb	ip, ip, r2
57e23fb4:	e21cc0ff 	ands	ip, ip, #255	; 0xff
57e23fb8:	1a000002 	bne	57e23fc8 <strcmp+0x24>
57e23fbc:	e3520000 	cmp	r2, #0
57e23fc0:	e2833001 	add	r3, r3, #1
57e23fc4:	1afffff7 	bne	57e23fa8 <strcmp+0x4>
			break;
	}

	return __res;
57e23fc8:	e1a00c0c 	lsl	r0, ip, #24
}
57e23fcc:	e1a00c40 	asr	r0, r0, #24
57e23fd0:	e12fff1e 	bx	lr

57e23fd4 <strncmp>:
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
57e23fd4:	e92d4010 	push	{r4, lr}
	register signed char __res = 0;

	while (count) {
57e23fd8:	e3a03000 	mov	r3, #0
57e23fdc:	ea000008 	b	57e24004 <strncmp+0x30>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
57e23fe0:	e7d04003 	ldrb	r4, [r0, r3]
57e23fe4:	e7d1c003 	ldrb	ip, [r1, r3]
57e23fe8:	e06cc004 	rsb	ip, ip, r4
57e23fec:	e21cc0ff 	ands	ip, ip, #255	; 0xff
57e23ff0:	1a000006 	bne	57e24010 <strncmp+0x3c>
57e23ff4:	e3540000 	cmp	r4, #0
57e23ff8:	e2833001 	add	r3, r3, #1
57e23ffc:	0a000003 	beq	57e24010 <strncmp+0x3c>
			break;
		count--;
57e24000:	e2422001 	sub	r2, r2, #1
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
	register signed char __res = 0;

	while (count) {
57e24004:	e3520000 	cmp	r2, #0
57e24008:	1afffff4 	bne	57e23fe0 <strncmp+0xc>
57e2400c:	e1a0c002 	mov	ip, r2
		if ((__res = *cs - *ct++) != 0 || !*cs++)
			break;
		count--;
	}

	return __res;
57e24010:	e1a00c0c 	lsl	r0, ip, #24
}
57e24014:	e1a00c40 	asr	r0, r0, #24
57e24018:	e8bd8010 	pop	{r4, pc}

57e2401c <strchr>:
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
57e2401c:	e20110ff 	and	r1, r1, #255	; 0xff
57e24020:	ea000001 	b	57e2402c <strchr+0x10>
		if (*s == '\0')
57e24024:	e3520000 	cmp	r2, #0
57e24028:	0a000005 	beq	57e24044 <strchr+0x28>
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
57e2402c:	e5d02000 	ldrb	r2, [r0]
		if (*s == '\0')
57e24030:	e1a03000 	mov	r3, r0
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
57e24034:	e1520001 	cmp	r2, r1
57e24038:	e2800001 	add	r0, r0, #1
57e2403c:	1afffff8 	bne	57e24024 <strchr+0x8>
57e24040:	ea000000 	b	57e24048 <strchr+0x2c>
		if (*s == '\0')
			return NULL;
57e24044:	e1a03002 	mov	r3, r2
	return (char *) s;
}
57e24048:	e1a00003 	mov	r0, r3
57e2404c:	e12fff1e 	bx	lr

57e24050 <strlen>:
/**
 * strlen - Find the length of a string
 * @s: The string to be sized
 */
size_t strlen(const char * s)
{
57e24050:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
57e24054:	e1a02003 	mov	r2, r3
57e24058:	e4d31001 	ldrb	r1, [r3], #1
57e2405c:	e3510000 	cmp	r1, #0
57e24060:	1afffffb 	bne	57e24054 <strlen+0x4>
		/* nothing */;
	return sc - s;
}
57e24064:	e0600002 	rsb	r0, r0, r2
57e24068:	e12fff1e 	bx	lr

57e2406c <strrchr>:
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
57e2406c:	e92d4038 	push	{r3, r4, r5, lr}
57e24070:	e1a04000 	mov	r4, r0
57e24074:	e1a05001 	mov	r5, r1
       const char *p = s + strlen(s);
57e24078:	ebfffff4 	bl	57e24050 <strlen>
       do {
	   if (*p == (char)c)
57e2407c:	e20550ff 	and	r5, r5, #255	; 0xff
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
57e24080:	e0843000 	add	r3, r4, r0
       do {
	   if (*p == (char)c)
57e24084:	e5d32000 	ldrb	r2, [r3]
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
57e24088:	e1a00003 	mov	r0, r3
       do {
	   if (*p == (char)c)
57e2408c:	e1520005 	cmp	r2, r5
57e24090:	e2433001 	sub	r3, r3, #1
57e24094:	08bd8038 	popeq	{r3, r4, r5, pc}
	       return (char *)p;
       } while (--p >= s);
57e24098:	e1540003 	cmp	r4, r3
57e2409c:	9afffff8 	bls	57e24084 <strrchr+0x18>
       return NULL;
57e240a0:	e3a00000 	mov	r0, #0
}
57e240a4:	e8bd8038 	pop	{r3, r4, r5, pc}

57e240a8 <strnlen>:
 * strnlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
size_t strnlen(const char * s, size_t count)
{
57e240a8:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
57e240ac:	e3510000 	cmp	r1, #0
57e240b0:	e1a02003 	mov	r2, r3
57e240b4:	0a000003 	beq	57e240c8 <strnlen+0x20>
57e240b8:	e4d3c001 	ldrb	ip, [r3], #1
57e240bc:	e2411001 	sub	r1, r1, #1
57e240c0:	e35c0000 	cmp	ip, #0
57e240c4:	1afffff8 	bne	57e240ac <strnlen+0x4>
		/* nothing */;
	return sc - s;
}
57e240c8:	e0600002 	rsb	r0, r0, r2
57e240cc:	e12fff1e 	bx	lr

57e240d0 <strdup>:
#endif

#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
57e240d0:	e92d4038 	push	{r3, r4, r5, lr}
	char *new;

	if ((s == NULL)	||
57e240d4:	e2505000 	subs	r5, r0, #0
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
57e240d8:	01a04005 	moveq	r4, r5
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
57e240dc:	0a000006 	beq	57e240fc <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
57e240e0:	ebffffda 	bl	57e24050 <strlen>
57e240e4:	e2800001 	add	r0, r0, #1
57e240e8:	ebff96b5 	bl	57e09bc4 <malloc>
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
57e240ec:	e2504000 	subs	r4, r0, #0
57e240f0:	0a000001 	beq	57e240fc <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
	}

	strcpy (new, s);
57e240f4:	e1a01005 	mov	r1, r5
57e240f8:	ebffff78 	bl	57e23ee0 <strcpy>
	return new;
}
57e240fc:	e1a00004 	mov	r0, r4
57e24100:	e8bd8038 	pop	{r3, r4, r5, pc}

57e24104 <strspn>:
 *	contain letters in @accept
 * @s: The string to be searched
 * @accept: The string to search for
 */
size_t strspn(const char *s, const char *accept)
{
57e24104:	e1a03000 	mov	r3, r0
57e24108:	e92d4010 	push	{r4, lr}
	const char *p;
	const char *a;
	size_t count = 0;
57e2410c:	e3a00000 	mov	r0, #0

	for (p = s; *p != '\0'; ++p) {
57e24110:	ea000006 	b	57e24130 <strspn+0x2c>
		for (a = accept; *a != '\0'; ++a) {
			if (*p == *a)
57e24114:	e15c0004 	cmp	ip, r4
				break;
		}
		if (*a == '\0')
			return count;
		++count;
57e24118:	02800001 	addeq	r0, r0, #1
57e2411c:	0a000003 	beq	57e24130 <strspn+0x2c>
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
57e24120:	e4d24001 	ldrb	r4, [r2], #1
57e24124:	e3540000 	cmp	r4, #0
57e24128:	1afffff9 	bne	57e24114 <strspn+0x10>
57e2412c:	e8bd8010 	pop	{r4, pc}
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
57e24130:	e7d3c000 	ldrb	ip, [r3, r0]
57e24134:	e35c0000 	cmp	ip, #0
57e24138:	08bd8010 	popeq	{r4, pc}
57e2413c:	e1a02001 	mov	r2, r1
57e24140:	eafffff6 	b	57e24120 <strspn+0x1c>

57e24144 <strpbrk>:
 * strpbrk - Find the first occurrence of a set of characters
 * @cs: The string to be searched
 * @ct: The characters to search for
 */
char * strpbrk(const char * cs,const char * ct)
{
57e24144:	e92d4010 	push	{r4, lr}
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
57e24148:	e1a02000 	mov	r2, r0
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
57e2414c:	ea000004 	b	57e24164 <strpbrk+0x20>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
57e24150:	e1530004 	cmp	r3, r4
57e24154:	08bd8010 	popeq	{r4, pc}
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
57e24158:	e4dc4001 	ldrb	r4, [ip], #1
57e2415c:	e3540000 	cmp	r4, #0
57e24160:	1afffffa 	bne	57e24150 <strpbrk+0xc>
57e24164:	e1a00002 	mov	r0, r2
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
57e24168:	e4d23001 	ldrb	r3, [r2], #1
57e2416c:	e3530000 	cmp	r3, #0
57e24170:	11a0c001 	movne	ip, r1
57e24174:	1afffff7 	bne	57e24158 <strpbrk+0x14>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
57e24178:	e1a00003 	mov	r0, r3
}
57e2417c:	e8bd8010 	pop	{r4, pc}

57e24180 <strtok>:
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
57e24180:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
57e24184:	e2504000 	subs	r4, r0, #0
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
57e24188:	e1a05001 	mov	r5, r1
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
57e2418c:	1a000003 	bne	57e241a0 <strtok+0x20>
57e24190:	e59f3060 	ldr	r3, [pc, #96]	; 57e241f8 <strtok+0x78>
57e24194:	e5934000 	ldr	r4, [r3]
	if (!sbegin) {
57e24198:	e3540000 	cmp	r4, #0
57e2419c:	0a000013 	beq	57e241f0 <strtok+0x70>
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
57e241a0:	e1a00004 	mov	r0, r4
57e241a4:	e1a01005 	mov	r1, r5
57e241a8:	ebffffd5 	bl	57e24104 <strspn>
	if (*sbegin == '\0') {
57e241ac:	e7f43000 	ldrb	r3, [r4, r0]!
57e241b0:	e3530000 	cmp	r3, #0
		___strtok = NULL;
57e241b4:	059f203c 	ldreq	r2, [pc, #60]	; 57e241f8 <strtok+0x78>
		return( NULL );
57e241b8:	01a04003 	moveq	r4, r3
	if (!sbegin) {
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
	if (*sbegin == '\0') {
		___strtok = NULL;
57e241bc:	05823000 	streq	r3, [r2]
		return( NULL );
57e241c0:	0a00000a 	beq	57e241f0 <strtok+0x70>
	}
	send = strpbrk( sbegin, ct);
57e241c4:	e1a00004 	mov	r0, r4
57e241c8:	e1a01005 	mov	r1, r5
57e241cc:	ebffffdc 	bl	57e24144 <strpbrk>
	if (send && *send != '\0')
57e241d0:	e3500000 	cmp	r0, #0
57e241d4:	0a000003 	beq	57e241e8 <strtok+0x68>
57e241d8:	e5d03000 	ldrb	r3, [r0]
57e241dc:	e3530000 	cmp	r3, #0
		*send++ = '\0';
57e241e0:	13a03000 	movne	r3, #0
57e241e4:	14c03001 	strbne	r3, [r0], #1
	___strtok = send;
57e241e8:	e59f3008 	ldr	r3, [pc, #8]	; 57e241f8 <strtok+0x78>
57e241ec:	e5830000 	str	r0, [r3]
	return (sbegin);
}
57e241f0:	e1a00004 	mov	r0, r4
57e241f4:	e8bd8038 	pop	{r3, r4, r5, pc}
57e241f8:	57e7909c 	.word	0x57e7909c

57e241fc <strsep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
57e241fc:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin = *s, *end;
57e24200:	e5904000 	ldr	r4, [r0]
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
57e24204:	e1a05000 	mov	r5, r0
	char *sbegin = *s, *end;

	if (sbegin == NULL)
57e24208:	e3540000 	cmp	r4, #0
57e2420c:	0a000005 	beq	57e24228 <strsep+0x2c>
		return NULL;

	end = strpbrk(sbegin, ct);
57e24210:	e1a00004 	mov	r0, r4
57e24214:	ebffffca 	bl	57e24144 <strpbrk>
	if (end)
57e24218:	e3500000 	cmp	r0, #0
		*end++ = '\0';
57e2421c:	13a03000 	movne	r3, #0
57e24220:	14c03001 	strbne	r3, [r0], #1
	*s = end;
57e24224:	e5850000 	str	r0, [r5]

	return sbegin;
}
57e24228:	e1a00004 	mov	r0, r4
57e2422c:	e8bd8038 	pop	{r3, r4, r5, pc}

57e24230 <strswab>:
 */
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
57e24230:	e3500000 	cmp	r0, #0
57e24234:	012fff1e 	bxeq	lr
57e24238:	e5d03000 	ldrb	r3, [r0]
57e2423c:	e3530000 	cmp	r3, #0
57e24240:	11a03000 	movne	r3, r0
57e24244:	1a000002 	bne	57e24254 <strswab+0x24>
57e24248:	ea000009 	b	57e24274 <strswab+0x44>

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
		char  tmp;

		tmp = *p;
		*p  = *q;
57e2424c:	e5432002 	strb	r2, [r3, #-2]
		*q  = tmp;
57e24250:	e5431001 	strb	r1, [r3, #-1]

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
57e24254:	e5d31000 	ldrb	r1, [r3]
57e24258:	e3510000 	cmp	r1, #0
57e2425c:	012fff1e 	bxeq	lr
57e24260:	e5d32001 	ldrb	r2, [r3, #1]
57e24264:	e2833002 	add	r3, r3, #2
57e24268:	e3520000 	cmp	r2, #0
57e2426c:	1afffff6 	bne	57e2424c <strswab+0x1c>
57e24270:	e12fff1e 	bx	lr
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
57e24274:	e1a00003 	mov	r0, r3
		*p  = *q;
		*q  = tmp;
	}

	return (char *) s;
}
57e24278:	e12fff1e 	bx	lr

57e2427c <memset>:
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
57e2427c:	e210c003 	ands	ip, r0, #3
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
{
57e24280:	e92d4010 	push	{r4, lr}
	unsigned long *sl = (unsigned long *) s;
57e24284:	e1a03000 	mov	r3, r0
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
57e24288:	1a000012 	bne	57e242d8 <memset+0x5c>
57e2428c:	e1a0300c 	mov	r3, ip
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
57e24290:	e20140ff 	and	r4, r1, #255	; 0xff
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
57e24294:	e2833001 	add	r3, r3, #1
57e24298:	e3530004 	cmp	r3, #4
			cl <<= 8;
			cl |= c & 0xff;
57e2429c:	e184c40c 	orr	ip, r4, ip, lsl #8
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
57e242a0:	1afffffb 	bne	57e24294 <memset+0x18>
57e242a4:	e1a04000 	mov	r4, r0
57e242a8:	e1a03002 	mov	r3, r2
57e242ac:	ea000001 	b	57e242b8 <memset+0x3c>
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
			*sl++ = cl;
57e242b0:	e484c004 	str	ip, [r4], #4
			count -= sizeof(*sl);
57e242b4:	e2433004 	sub	r3, r3, #4
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
57e242b8:	e3530003 	cmp	r3, #3
57e242bc:	8afffffb 	bhi	57e242b0 <memset+0x34>
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
57e242c0:	e3c23003 	bic	r3, r2, #3
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
57e242c4:	e0803003 	add	r3, r0, r3
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
57e242c8:	e2022003 	and	r2, r2, #3
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
57e242cc:	ea000001 	b	57e242d8 <memset+0x5c>
		*s8++ = c;
57e242d0:	e4c31001 	strb	r1, [r3], #1
57e242d4:	e2422001 	sub	r2, r2, #1
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
57e242d8:	e3520000 	cmp	r2, #0
57e242dc:	1afffffb 	bne	57e242d0 <memset+0x54>
		*s8++ = c;

	return s;
}
57e242e0:	e8bd8010 	pop	{r4, pc}

57e242e4 <bcopy>:
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
char * bcopy(const char * src, char * dest, int count)
{
57e242e4:	e1a03000 	mov	r3, r0
	char *tmp = dest;

	while (count--)
57e242e8:	e3a00000 	mov	r0, #0
57e242ec:	ea000002 	b	57e242fc <bcopy+0x18>
		*tmp++ = *src++;
57e242f0:	e7d3c000 	ldrb	ip, [r3, r0]
57e242f4:	e7c1c000 	strb	ip, [r1, r0]
57e242f8:	e2800001 	add	r0, r0, #1
 */
char * bcopy(const char * src, char * dest, int count)
{
	char *tmp = dest;

	while (count--)
57e242fc:	e2522001 	subs	r2, r2, #1
57e24300:	2afffffa 	bcs	57e242f0 <bcopy+0xc>
		*tmp++ = *src++;

	return dest;
}
57e24304:	e1a00001 	mov	r0, r1
57e24308:	e12fff1e 	bx	lr

57e2430c <memcpy>:
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
57e2430c:	e1510000 	cmp	r1, r0
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
57e24310:	e92d4010 	push	{r4, lr}
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
57e24314:	08bd8010 	popeq	{r4, pc}
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
57e24318:	e1813000 	orr	r3, r1, r0
57e2431c:	e2133003 	ands	r3, r3, #3
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
57e24320:	e1a0c000 	mov	ip, r0
57e24324:	e1a04001 	mov	r4, r1

	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
57e24328:	01a0c002 	moveq	ip, r2
57e2432c:	0a000004 	beq	57e24344 <memcpy+0x38>
57e24330:	ea000009 	b	57e2435c <memcpy+0x50>
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
57e24334:	e7914003 	ldr	r4, [r1, r3]
			count -= sizeof(*dl);
57e24338:	e24cc004 	sub	ip, ip, #4
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
57e2433c:	e7804003 	str	r4, [r0, r3]
			count -= sizeof(*dl);
57e24340:	e2833004 	add	r3, r3, #4
	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
57e24344:	e35c0003 	cmp	ip, #3
57e24348:	8afffff9 	bhi	57e24334 <memcpy+0x28>
 * @count: The size of the area.
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
57e2434c:	e3c24003 	bic	r4, r2, #3
57e24350:	e080c004 	add	ip, r0, r4
57e24354:	e2022003 	and	r2, r2, #3
57e24358:	e0814004 	add	r4, r1, r4
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
57e2435c:	e3a03000 	mov	r3, #0
57e24360:	ea000003 	b	57e24374 <memcpy+0x68>
		*d8++ = *s8++;
57e24364:	e7d41003 	ldrb	r1, [r4, r3]
57e24368:	e2422001 	sub	r2, r2, #1
57e2436c:	e7cc1003 	strb	r1, [ip, r3]
57e24370:	e2833001 	add	r3, r3, #1
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
57e24374:	e3520000 	cmp	r2, #0
57e24378:	1afffff9 	bne	57e24364 <memcpy+0x58>
		*d8++ = *s8++;

	return dest;
}
57e2437c:	e8bd8010 	pop	{r4, pc}

57e24380 <memmove>:
 */
void * memmove(void * dest,const void *src,size_t count)
{
	char *tmp, *s;

	if (src == dest)
57e24380:	e1510000 	cmp	r1, r0
57e24384:	012fff1e 	bxeq	lr
		return dest;

	if (dest <= src) {
57e24388:	e1500001 	cmp	r0, r1
57e2438c:	93a03000 	movls	r3, #0
57e24390:	9a000004 	bls	57e243a8 <memmove+0x28>
57e24394:	ea000006 	b	57e243b4 <memmove+0x34>
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
57e24398:	e7d1c003 	ldrb	ip, [r1, r3]
57e2439c:	e2422001 	sub	r2, r2, #1
57e243a0:	e7c0c003 	strb	ip, [r0, r3]
57e243a4:	e2833001 	add	r3, r3, #1
		return dest;

	if (dest <= src) {
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
57e243a8:	e3520000 	cmp	r2, #0
57e243ac:	1afffff9 	bne	57e24398 <memmove+0x18>
57e243b0:	e12fff1e 	bx	lr
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
57e243b4:	e0811002 	add	r1, r1, r2
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
57e243b8:	e0803002 	add	r3, r0, r2
		s = (char *) src + count;
		while (count--)
57e243bc:	ea000002 	b	57e243cc <memmove+0x4c>
			*--tmp = *--s;
57e243c0:	e571c001 	ldrb	ip, [r1, #-1]!
57e243c4:	e2422001 	sub	r2, r2, #1
57e243c8:	e563c001 	strb	ip, [r3, #-1]!
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
		while (count--)
57e243cc:	e3520000 	cmp	r2, #0
57e243d0:	1afffffa 	bne	57e243c0 <memmove+0x40>
			*--tmp = *--s;
		}

	return dest;
}
57e243d4:	e12fff1e 	bx	lr

57e243d8 <memcmp>:
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
int memcmp(const void * cs,const void * ct,size_t count)
{
57e243d8:	e92d4010 	push	{r4, lr}
57e243dc:	e1a03000 	mov	r3, r0
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
57e243e0:	e3a0c000 	mov	ip, #0
57e243e4:	ea000005 	b	57e24400 <memcmp+0x28>
		if ((res = *su1 - *su2) != 0)
57e243e8:	e7d3400c 	ldrb	r4, [r3, ip]
57e243ec:	e7d1000c 	ldrb	r0, [r1, ip]
57e243f0:	e28cc001 	add	ip, ip, #1
57e243f4:	e0540000 	subs	r0, r4, r0
57e243f8:	18bd8010 	popne	{r4, pc}
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
57e243fc:	e2422001 	sub	r2, r2, #1
57e24400:	e3520000 	cmp	r2, #0
57e24404:	1afffff7 	bne	57e243e8 <memcmp+0x10>
57e24408:	e1a00002 	mov	r0, r2
		if ((res = *su1 - *su2) != 0)
			break;
	return res;
}
57e2440c:	e8bd8010 	pop	{r4, pc}

57e24410 <memscan>:
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * memscan(void * addr, int c, size_t size)
{
57e24410:	e1a03000 	mov	r3, r0
	unsigned char * p = (unsigned char *) addr;

	while (size) {
57e24414:	ea000003 	b	57e24428 <memscan+0x18>
		if (*p == c)
57e24418:	e4d3c001 	ldrb	ip, [r3], #1
57e2441c:	e15c0001 	cmp	ip, r1
57e24420:	012fff1e 	bxeq	lr
			return (void *) p;
		p++;
		size--;
57e24424:	e2422001 	sub	r2, r2, #1
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
57e24428:	e3520000 	cmp	r2, #0
		if (*p == c)
			return (void *) p;
		p++;
		size--;
57e2442c:	e1a00003 	mov	r0, r3
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
57e24430:	1afffff8 	bne	57e24418 <memscan+0x8>
			return (void *) p;
		p++;
		size--;
	}
	return (void *) p;
}
57e24434:	e12fff1e 	bx	lr

57e24438 <strstr>:
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
57e24438:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
57e2443c:	e1a04000 	mov	r4, r0
	int l1, l2;

	l2 = strlen(s2);
57e24440:	e1a00001 	mov	r0, r1
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
57e24444:	e1a07001 	mov	r7, r1
	int l1, l2;

	l2 = strlen(s2);
57e24448:	ebffff00 	bl	57e24050 <strlen>
	if (!l2)
57e2444c:	e2506000 	subs	r6, r0, #0
57e24450:	0a00000e 	beq	57e24490 <strstr+0x58>
		return (char *) s1;
	l1 = strlen(s1);
57e24454:	e1a00004 	mov	r0, r4
57e24458:	ebfffefc 	bl	57e24050 <strlen>
57e2445c:	e1a05000 	mov	r5, r0
	while (l1 >= l2) {
57e24460:	ea000007 	b	57e24484 <strstr+0x4c>
		l1--;
		if (!memcmp(s1,s2,l2))
57e24464:	e1a00004 	mov	r0, r4
57e24468:	e1a01007 	mov	r1, r7
57e2446c:	e1a02006 	mov	r2, r6
57e24470:	ebffffd8 	bl	57e243d8 <memcmp>
57e24474:	e3500000 	cmp	r0, #0
57e24478:	0a000004 	beq	57e24490 <strstr+0x58>
	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
57e2447c:	e2455001 	sub	r5, r5, #1
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
57e24480:	e2844001 	add	r4, r4, #1

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
57e24484:	e1550006 	cmp	r5, r6
57e24488:	aafffff5 	bge	57e24464 <strstr+0x2c>
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
	}
	return NULL;
57e2448c:	e3a04000 	mov	r4, #0
}
57e24490:	e1a00004 	mov	r0, r4
57e24494:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

57e24498 <memchr>:
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
57e24498:	e20110ff 	and	r1, r1, #255	; 0xff
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
57e2449c:	ea000003 	b	57e244b0 <memchr+0x18>
		if ((unsigned char)c == *p++) {
57e244a0:	e4d0c001 	ldrb	ip, [r0], #1
57e244a4:	e2422001 	sub	r2, r2, #1
57e244a8:	e151000c 	cmp	r1, ip
57e244ac:	0a000004 	beq	57e244c4 <memchr+0x2c>
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
57e244b0:	e3520000 	cmp	r2, #0
		if ((unsigned char)c == *p++) {
57e244b4:	e1a03000 	mov	r3, r0
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
57e244b8:	1afffff8 	bne	57e244a0 <memchr+0x8>
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
		}
	}
	return NULL;
57e244bc:	e1a00002 	mov	r0, r2
57e244c0:	e12fff1e 	bx	lr
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
57e244c4:	e1a00003 	mov	r0, r3
		}
	}
	return NULL;
}
57e244c8:	e12fff1e 	bx	lr

57e244cc <strmhz>:
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
57e244cc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
57e244d0:	e2815f7d 	add	r5, r1, #500	; 0x1f4
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
57e244d4:	e1a04000 	mov	r4, r0
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
57e244d8:	e59f1048 	ldr	r1, [pc, #72]	; 57e24528 <strmhz+0x5c>
57e244dc:	e1a00005 	mov	r0, r5
57e244e0:	eb001cb2 	bl	57e2b7b0 <__udivsi3>
57e244e4:	e1a06000 	mov	r6, r0
	l = sprintf (buf, "%ld", n);
57e244e8:	e1a02006 	mov	r2, r6
57e244ec:	e59f1038 	ldr	r1, [pc, #56]	; 57e2452c <strmhz+0x60>
57e244f0:	e1a00004 	mov	r0, r4
57e244f4:	eb000393 	bl	57e25348 <sprintf>
57e244f8:	e1a07000 	mov	r7, r0

	hz -= n * 1000000L;
	m = DIV_ROUND(hz, 1000L);
57e244fc:	e59f002c 	ldr	r0, [pc, #44]	; 57e24530 <strmhz+0x64>
57e24500:	e3a01ffa 	mov	r1, #1000	; 0x3e8
57e24504:	e0205096 	mla	r0, r6, r0, r5
57e24508:	eb001ca8 	bl	57e2b7b0 <__udivsi3>
	if (m != 0)
57e2450c:	e2502000 	subs	r2, r0, #0
57e24510:	0a000002 	beq	57e24520 <strmhz+0x54>
		sprintf (buf + l, ".%03ld", m);
57e24514:	e0840007 	add	r0, r4, r7
57e24518:	e59f1014 	ldr	r1, [pc, #20]	; 57e24534 <strmhz+0x68>
57e2451c:	eb000389 	bl	57e25348 <sprintf>
	return (buf);
}
57e24520:	e1a00004 	mov	r0, r4
57e24524:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e24528:	000f4240 	.word	0x000f4240
57e2452c:	57e35408 	.word	0x57e35408
57e24530:	fff0bdc0 	.word	0xfff0bdc0
57e24534:	57e355a4 	.word	0x57e355a4

57e24538 <udelay>:
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
57e24538:	e92d4070 	push	{r4, r5, r6, lr}
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
57e2453c:	e59f6020 	ldr	r6, [pc, #32]	; 57e24564 <udelay+0x2c>
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
57e24540:	e1a04000 	mov	r4, r0
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
57e24544:	e1540006 	cmp	r4, r6
57e24548:	31a05004 	movcc	r5, r4
57e2454c:	21a05006 	movcs	r5, r6
		__udelay (kv);
57e24550:	e1a00005 	mov	r0, r5
57e24554:	ebff7171 	bl	57e00b20 <__udelay>
		usec -= kv;
	} while(usec);
57e24558:	e0544005 	subs	r4, r4, r5
57e2455c:	1afffff8 	bne	57e24544 <udelay+0xc>
}
57e24560:	e8bd8070 	pop	{r4, r5, r6, pc}
57e24564:	00989680 	.word	0x00989680

57e24568 <mdelay>:

void mdelay(unsigned long msec)
{
57e24568:	e92d4010 	push	{r4, lr}
57e2456c:	e1a04000 	mov	r4, r0
	while (msec--)
57e24570:	ea000002 	b	57e24580 <mdelay+0x18>
		udelay(1000);
57e24574:	e3a00ffa 	mov	r0, #1000	; 0x3e8
57e24578:	ebffffee 	bl	57e24538 <udelay>
57e2457c:	e2444001 	sub	r4, r4, #1
	} while(usec);
}

void mdelay(unsigned long msec)
{
	while (msec--)
57e24580:	e3540000 	cmp	r4, #0
57e24584:	1afffffa 	bne	57e24574 <mdelay+0xc>
		udelay(1000);
}
57e24588:	e8bd8010 	pop	{r4, pc}

57e2458c <put_dec_trunc>:

/* Formats correctly any integer in [0,99999].
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char *put_dec_trunc(char *buf, unsigned q)
{
57e2458c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
57e24590:	e1a07221 	lsr	r7, r1, #4
	d2 = (q>>8) & 0xf;
57e24594:	e1a04421 	lsr	r4, r1, #8
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char *put_dec_trunc(char *buf, unsigned q)
{
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
57e24598:	e207700f 	and	r7, r7, #15
	d2 = (q>>8) & 0xf;
57e2459c:	e204400f 	and	r4, r4, #15
	d3 = (q>>12);
57e245a0:	e1a02621 	lsr	r2, r1, #12

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
57e245a4:	e087c004 	add	ip, r7, r4

/* Formats correctly any integer in [0,99999].
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char *put_dec_trunc(char *buf, unsigned q)
{
57e245a8:	e1a03000 	mov	r3, r0
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
57e245ac:	e08cc002 	add	ip, ip, r2
57e245b0:	e201000f 	and	r0, r1, #15
57e245b4:	e3a01006 	mov	r1, #6
57e245b8:	e021019c 	mla	r1, ip, r1, r0
	q = (d0 * 0xcd) >> 11;
57e245bc:	e3a050cd 	mov	r5, #205	; 0xcd
57e245c0:	e0060195 	mul	r6, r5, r1
	d0 = d0 - 10*q;
57e245c4:	e3a0c00a 	mov	ip, #10
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
57e245c8:	e1a065a6 	lsr	r6, r6, #11
	d0 = d0 - 10*q;
57e245cc:	e000069c 	mul	r0, ip, r6
57e245d0:	e0601001 	rsb	r1, r0, r1
	*buf++ = d0 + '0'; /* least significant digit */
57e245d4:	e2811030 	add	r1, r1, #48	; 0x30
57e245d8:	e1a00003 	mov	r0, r3
57e245dc:	e4c01001 	strb	r1, [r0], #1
	d1 = q + 9*d3 + 5*d2 + d1;
57e245e0:	e0821182 	add	r1, r2, r2, lsl #3
57e245e4:	e0811007 	add	r1, r1, r7
57e245e8:	e084a104 	add	sl, r4, r4, lsl #2
57e245ec:	e081100a 	add	r1, r1, sl
	if (d1 != 0) {
57e245f0:	e0916006 	adds	r6, r1, r6
57e245f4:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
		q = (d1 * 0xcd) >> 11;
57e245f8:	e0010695 	mul	r1, r5, r6
57e245fc:	e1a015a1 	lsr	r1, r1, #11
		d1 = d1 - 10*q;
57e24600:	e007019c 	mul	r7, ip, r1
57e24604:	e0676006 	rsb	r6, r7, r6
		*buf++ = d1 + '0'; /* next digit */
57e24608:	e2866030 	add	r6, r6, #48	; 0x30

		d2 = q + 2*d2;
57e2460c:	e0814084 	add	r4, r1, r4, lsl #1
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
57e24610:	e5c36001 	strb	r6, [r3, #1]

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
57e24614:	e1943002 	orrs	r3, r4, r2
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
57e24618:	e2800001 	add	r0, r0, #1

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
57e2461c:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
			q = (d2 * 0xd) >> 7;
57e24620:	e3a0300d 	mov	r3, #13
57e24624:	e0030394 	mul	r3, r4, r3
57e24628:	e1a033a3 	lsr	r3, r3, #7
			d2 = d2 - 10*q;
57e2462c:	e001039c 	mul	r1, ip, r3
57e24630:	e0614004 	rsb	r4, r1, r4
			*buf++ = d2 + '0'; /* next digit */
57e24634:	e2844030 	add	r4, r4, #48	; 0x30

			d3 = q + 4*d3;
			if (d3 != 0) {
57e24638:	e0932102 	adds	r2, r3, r2, lsl #2

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0'; /* next digit */
57e2463c:	e4c04001 	strb	r4, [r0], #1

			d3 = q + 4*d3;
			if (d3 != 0) {
57e24640:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
				q = (d3 * 0xcd) >> 11;
57e24644:	e0030295 	mul	r3, r5, r2
57e24648:	e1a035a3 	lsr	r3, r3, #11
				d3 = d3 - 10*q;
57e2464c:	e00c0c93 	mul	ip, r3, ip
57e24650:	e06c2002 	rsb	r2, ip, r2
				*buf++ = d3 + '0';  /* next digit */
				if (q != 0)
57e24654:	e3530000 	cmp	r3, #0

			d3 = q + 4*d3;
			if (d3 != 0) {
				q = (d3 * 0xcd) >> 11;
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';  /* next digit */
57e24658:	e2822030 	add	r2, r2, #48	; 0x30
57e2465c:	e4c02001 	strb	r2, [r0], #1
				if (q != 0)
					*buf++ = q + '0'; /* most sign. digit */
57e24660:	12833030 	addne	r3, r3, #48	; 0x30
57e24664:	14c03001 	strbne	r3, [r0], #1
			}
		}
	}
	return buf;
}
57e24668:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

57e2466c <put_dec>:
					*buf++ = q + '0';
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char *put_dec(char *buf, u64 num)
{
57e2466c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e24670:	e28d5008 	add	r5, sp, #8
57e24674:	e925000c 	stmdb	r5!, {r2, r3}
57e24678:	e1a04000 	mov	r4, r0
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
57e2467c:	e3a090cd 	mov	r9, #205	; 0xcd
	d0 = d0 - 10*q;
57e24680:	e3a0a00a 	mov	sl, #10
/* No inlining helps gcc to use registers better */
static noinline char *put_dec(char *buf, u64 num)
{
	while (1) {
		unsigned rem;
		if (num < 100000)
57e24684:	e89d0880 	ldm	sp, {r7, fp}
57e24688:	e35b0000 	cmp	fp, #0
57e2468c:	1a00000f 	bne	57e246d0 <put_dec+0x64>
57e24690:	e59f0100 	ldr	r0, [pc, #256]	; 57e24798 <put_dec+0x12c>
57e24694:	e1570000 	cmp	r7, r0
57e24698:	8a000003 	bhi	57e246ac <put_dec+0x40>
			return put_dec_trunc(buf, num);
57e2469c:	e1a00004 	mov	r0, r4
57e246a0:	e1a01007 	mov	r1, r7
57e246a4:	ebffffb8 	bl	57e2458c <put_dec_trunc>
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
}
57e246a8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
{
	while (1) {
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
57e246ac:	e1a00007 	mov	r0, r7
57e246b0:	e59f10e4 	ldr	r1, [pc, #228]	; 57e2479c <put_dec+0x130>
57e246b4:	eb001cb8 	bl	57e2b99c <__aeabi_uidivmod>
57e246b8:	e1a00007 	mov	r0, r7
57e246bc:	e1a06001 	mov	r6, r1
57e246c0:	e59f10d4 	ldr	r1, [pc, #212]	; 57e2479c <put_dec+0x130>
57e246c4:	eb001c39 	bl	57e2b7b0 <__udivsi3>
57e246c8:	e88d0801 	stm	sp, {r0, fp}
57e246cc:	ea000003 	b	57e246e0 <put_dec+0x74>
57e246d0:	e1a0000d 	mov	r0, sp
57e246d4:	e59f10c0 	ldr	r1, [pc, #192]	; 57e2479c <put_dec+0x130>
57e246d8:	ebfff78b 	bl	57e2250c <__div64_32>
57e246dc:	e1a06000 	mov	r6, r0
static char *put_dec_full(char *buf, unsigned q)
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
57e246e0:	e1a0c226 	lsr	ip, r6, #4
	d2 = (q>>8) & 0xf;
57e246e4:	e1a02426 	lsr	r2, r6, #8
static char *put_dec_full(char *buf, unsigned q)
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
57e246e8:	e20cc00f 	and	ip, ip, #15
	d2 = (q>>8) & 0xf;
57e246ec:	e202200f 	and	r2, r2, #15
	d3 = (q>>12);
57e246f0:	e1a03626 	lsr	r3, r6, #12
	 * (x * 0x34) >> 9:    110100 - same
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
57e246f4:	e08c1002 	add	r1, ip, r2
57e246f8:	e0811003 	add	r1, r1, r3
57e246fc:	e3a00006 	mov	r0, #6
57e24700:	e206600f 	and	r6, r6, #15
57e24704:	e0266190 	mla	r6, r0, r1, r6
	q = (d0 * 0xcd) >> 11;
57e24708:	e0010699 	mul	r1, r9, r6
57e2470c:	e1a015a1 	lsr	r1, r1, #11
	d0 = d0 - 10*q;
57e24710:	e000019a 	mul	r0, sl, r1
57e24714:	e0606006 	rsb	r6, r0, r6
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
57e24718:	e0830183 	add	r0, r3, r3, lsl #3
57e2471c:	e080000c 	add	r0, r0, ip
57e24720:	e082e102 	add	lr, r2, r2, lsl #2
57e24724:	e080000e 	add	r0, r0, lr
57e24728:	e0800001 	add	r0, r0, r1
		q = (d1 * 0xcd) >> 11;
57e2472c:	e0010099 	mul	r1, r9, r0
57e24730:	e1a015a1 	lsr	r1, r1, #11
		d1 = d1 - 10*q;
57e24734:	e00c019a 	mul	ip, sl, r1
57e24738:	e06c0000 	rsb	r0, ip, r0
		*buf++ = d1 + '0';
57e2473c:	e2800030 	add	r0, r0, #48	; 0x30
57e24740:	e5c40001 	strb	r0, [r4, #1]

		d2 = q + 2*d2;
57e24744:	e0812082 	add	r2, r1, r2, lsl #1
			q = (d2 * 0xd) >> 7;
57e24748:	e3a0000d 	mov	r0, #13
57e2474c:	e0010290 	mul	r1, r0, r2
57e24750:	e1a013a1 	lsr	r1, r1, #7
			d2 = d2 - 10*q;
57e24754:	e000019a 	mul	r0, sl, r1
57e24758:	e0602002 	rsb	r2, r0, r2
			*buf++ = d2 + '0';

			d3 = q + 4*d3;
57e2475c:	e0813103 	add	r3, r1, r3, lsl #2
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0';
57e24760:	e2822030 	add	r2, r2, #48	; 0x30
57e24764:	e5c42002 	strb	r2, [r4, #2]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
57e24768:	e0020399 	mul	r2, r9, r3
57e2476c:	e1a025a2 	lsr	r2, r2, #11
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
57e24770:	e001029a 	mul	r1, sl, r2
57e24774:	e0613003 	rsb	r3, r1, r3
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
57e24778:	e2866030 	add	r6, r6, #48	; 0x30

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
57e2477c:	e2833030 	add	r3, r3, #48	; 0x30
					*buf++ = q + '0';
57e24780:	e2822030 	add	r2, r2, #48	; 0x30
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
57e24784:	e5c46000 	strb	r6, [r4]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
57e24788:	e5c43003 	strb	r3, [r4, #3]
					*buf++ = q + '0';
57e2478c:	e5c42004 	strb	r2, [r4, #4]
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char *put_dec(char *buf, u64 num)
57e24790:	e2844005 	add	r4, r4, #5
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
57e24794:	eaffffba 	b	57e24684 <put_dec+0x18>
57e24798:	0001869f 	.word	0x0001869f
57e2479c:	000186a0 	.word	0x000186a0

57e247a0 <string.clone.0>:
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
57e247a0:	e92d4070 	push	{r4, r5, r6, lr}
		int precision, int flags)
{
	int len, i;

	if (s == NULL)
		s = "<NULL>";
57e247a4:	e3510000 	cmp	r1, #0
57e247a8:	e59f607c 	ldr	r6, [pc, #124]	; 57e2482c <string.clone.0+0x8c>
57e247ac:	11a06001 	movne	r6, r1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
57e247b0:	e1a04000 	mov	r4, r0
	int len, i;

	if (s == NULL)
		s = "<NULL>";

	len = strnlen(s, precision);
57e247b4:	e1a01003 	mov	r1, r3
57e247b8:	e1a00006 	mov	r0, r6
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
57e247bc:	e1a05002 	mov	r5, r2
	int len, i;

	if (s == NULL)
		s = "<NULL>";

	len = strnlen(s, precision);
57e247c0:	ebfffe38 	bl	57e240a8 <strnlen>

	if (!(flags & LEFT))
57e247c4:	e59d3010 	ldr	r3, [sp, #16]
57e247c8:	e3130010 	tst	r3, #16
57e247cc:	1a000007 	bne	57e247f0 <string.clone.0+0x50>
57e247d0:	ea000001 	b	57e247dc <string.clone.0+0x3c>
		while (len < field_width--)
			ADDCH(buf, ' ');
57e247d4:	e4c43001 	strb	r3, [r4], #1
57e247d8:	ea000000 	b	57e247e0 <string.clone.0+0x40>
57e247dc:	e3a03020 	mov	r3, #32
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
57e247e0:	e2455001 	sub	r5, r5, #1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
57e247e4:	e2852001 	add	r2, r5, #1
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
57e247e8:	e1500002 	cmp	r0, r2
57e247ec:	bafffff8 	blt	57e247d4 <string.clone.0+0x34>
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
57e247f0:	e3a03000 	mov	r3, #0
57e247f4:	ea000002 	b	57e24804 <string.clone.0+0x64>
		ADDCH(buf, *s++);
57e247f8:	e7d62003 	ldrb	r2, [r6, r3]
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
57e247fc:	e2833001 	add	r3, r3, #1
		ADDCH(buf, *s++);
57e24800:	e4c42001 	strb	r2, [r4], #1
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
57e24804:	e1530000 	cmp	r3, r0
57e24808:	bafffffa 	blt	57e247f8 <string.clone.0+0x58>
		ADDCH(buf, *s++);
	while (len < field_width--)
		ADDCH(buf, ' ');
57e2480c:	e3a03020 	mov	r3, #32
57e24810:	ea000001 	b	57e2481c <string.clone.0+0x7c>
57e24814:	e4c43001 	strb	r3, [r4], #1
57e24818:	e2455001 	sub	r5, r5, #1
	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
		ADDCH(buf, *s++);
	while (len < field_width--)
57e2481c:	e1500005 	cmp	r0, r5
57e24820:	bafffffb 	blt	57e24814 <string.clone.0+0x74>
		ADDCH(buf, ' ');
	return buf;
}
57e24824:	e1a00004 	mov	r0, r4
57e24828:	e8bd8070 	pop	{r4, r5, r6, pc}
57e2482c:	57e355ab 	.word	0x57e355ab

57e24830 <number.clone.4>:
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, u64 num,
57e24830:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e24834:	e24dd058 	sub	sp, sp, #88	; 0x58
57e24838:	e59d5084 	ldr	r5, [sp, #132]	; 0x84
57e2483c:	e59d9078 	ldr	r9, [sp, #120]	; 0x78
	static const char digits[16] = "0123456789ABCDEF";

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
57e24840:	e3150040 	tst	r5, #64	; 0x40
57e24844:	03a0b000 	moveq	fp, #0
57e24848:	13a0b001 	movne	fp, #1
57e2484c:	e359000a 	cmp	r9, #10
57e24850:	03a0b000 	moveq	fp, #0
57e24854:	120bb001 	andne	fp, fp, #1
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
	if (type & LEFT)
57e24858:	e3150010 	tst	r5, #16
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
57e2485c:	e2051020 	and	r1, r5, #32
	if (type & LEFT)
		type &= ~ZEROPAD;
57e24860:	13c55001 	bicne	r5, r5, #1
	sign = 0;
	if (type & SIGN) {
57e24864:	e2157002 	ands	r7, r5, #2
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, u64 num,
57e24868:	e1a04000 	mov	r4, r0
57e2486c:	e59d607c 	ldr	r6, [sp, #124]	; 0x7c
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
57e24870:	e58d1004 	str	r1, [sp, #4]
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
57e24874:	0a00000f 	beq	57e248b8 <number.clone.4+0x88>
		if ((s64) num < 0) {
57e24878:	e3530000 	cmp	r3, #0
57e2487c:	ba000002 	blt	57e2488c <number.clone.4+0x5c>
			sign = '-';
			num = -(s64) num;
			size--;
		} else if (type & PLUS) {
57e24880:	e3150004 	tst	r5, #4
57e24884:	0a000008 	beq	57e248ac <number.clone.4+0x7c>
57e24888:	ea000004 	b	57e248a0 <number.clone.4+0x70>
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((s64) num < 0) {
			sign = '-';
			num = -(s64) num;
57e2488c:	e2722000 	rsbs	r2, r2, #0
57e24890:	e2e33000 	rsc	r3, r3, #0
			size--;
57e24894:	e2466001 	sub	r6, r6, #1
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((s64) num < 0) {
			sign = '-';
57e24898:	e3a0702d 	mov	r7, #45	; 0x2d
57e2489c:	ea000005 	b	57e248b8 <number.clone.4+0x88>
			num = -(s64) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
57e248a0:	e2466001 	sub	r6, r6, #1
		if ((s64) num < 0) {
			sign = '-';
			num = -(s64) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
57e248a4:	e3a0702b 	mov	r7, #43	; 0x2b
57e248a8:	ea000002 	b	57e248b8 <number.clone.4+0x88>
			size--;
		} else if (type & SPACE) {
57e248ac:	e2157008 	ands	r7, r5, #8
			sign = ' ';
			size--;
57e248b0:	12466001 	subne	r6, r6, #1
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
		} else if (type & SPACE) {
			sign = ' ';
57e248b4:	13a07020 	movne	r7, #32
			size--;
		}
	}
	if (need_pfx) {
57e248b8:	e35b0000 	cmp	fp, #0
57e248bc:	0a000002 	beq	57e248cc <number.clone.4+0x9c>
		size--;
57e248c0:	e2466001 	sub	r6, r6, #1
		if (base == 16)
57e248c4:	e3590010 	cmp	r9, #16
			size--;
57e248c8:	02466001 	subeq	r6, r6, #1
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
57e248cc:	e1921003 	orrs	r1, r2, r3
		tmp[i++] = '0';
57e248d0:	03a03030 	moveq	r3, #48	; 0x30
57e248d4:	05cd3014 	strbeq	r3, [sp, #20]
57e248d8:	03a0a001 	moveq	sl, #1
			size--;
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
57e248dc:	0a000023 	beq	57e24970 <number.clone.4+0x140>
	/* Generic code, for any base:
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
57e248e0:	e359000a 	cmp	r9, #10
57e248e4:	0a00001d 	beq	57e24960 <number.clone.4+0x130>
		int mask = base - 1;
		int shift = 3;
57e248e8:	e3590010 	cmp	r9, #16
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
57e248ec:	e2491001 	sub	r1, r9, #1
		int shift = 3;
57e248f0:	03a0c004 	moveq	ip, #4
57e248f4:	13a0c003 	movne	ip, #3
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
57e248f8:	e58d1008 	str	r1, [sp, #8]

		if (base == 16)
			shift = 4;

		do {
			tmp[i++] = (digits[((unsigned char)num) & mask]
57e248fc:	e58db00c 	str	fp, [sp, #12]
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
		int shift = 3;

		if (base == 16)
			shift = 4;
57e24900:	e3a0a000 	mov	sl, #0

		do {
			tmp[i++] = (digits[((unsigned char)num) & mask]
57e24904:	e1a0b007 	mov	fp, r7
57e24908:	e1a00002 	mov	r0, r2
57e2490c:	e1a07004 	mov	r7, r4
57e24910:	e1a01003 	mov	r1, r3
57e24914:	e1a0400c 	mov	r4, ip
57e24918:	e59d3008 	ldr	r3, [sp, #8]
57e2491c:	e20020ff 	and	r2, r0, #255	; 0xff
57e24920:	e0022003 	and	r2, r2, r3
57e24924:	e59f311c 	ldr	r3, [pc, #284]	; 57e24a48 <number.clone.4+0x218>
57e24928:	e7d3c002 	ldrb	ip, [r3, r2]
57e2492c:	e59d3004 	ldr	r3, [sp, #4]
57e24930:	e28d2014 	add	r2, sp, #20
57e24934:	e183c00c 	orr	ip, r3, ip
57e24938:	e7c2c00a 	strb	ip, [r2, sl]
					| locase);
			num >>= shift;
57e2493c:	e1a02004 	mov	r2, r4
57e24940:	eb001cad 	bl	57e2bbfc <__lshrdi3>
		} while (num);
57e24944:	e1903001 	orrs	r3, r0, r1

		if (base == 16)
			shift = 4;

		do {
			tmp[i++] = (digits[((unsigned char)num) & mask]
57e24948:	e28aa001 	add	sl, sl, #1
					| locase);
			num >>= shift;
		} while (num);
57e2494c:	1afffff1 	bne	57e24918 <number.clone.4+0xe8>
57e24950:	e1a04007 	mov	r4, r7
57e24954:	e1a0700b 	mov	r7, fp
57e24958:	e59db00c 	ldr	fp, [sp, #12]
57e2495c:	ea000003 	b	57e24970 <number.clone.4+0x140>
	} else { /* base 10 */
		i = put_dec(tmp, num) - tmp;
57e24960:	e28da014 	add	sl, sp, #20
57e24964:	e1a0000a 	mov	r0, sl
57e24968:	ebffff3f 	bl	57e2466c <put_dec>
57e2496c:	e06aa000 	rsb	sl, sl, r0
57e24970:	e59d3080 	ldr	r3, [sp, #128]	; 0x80
57e24974:	e15a0003 	cmp	sl, r3
57e24978:	a1a0300a 	movge	r3, sl
57e2497c:	b1a03003 	movlt	r3, r3
	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
57e24980:	e3150011 	tst	r5, #17

	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
57e24984:	e0636006 	rsb	r6, r3, r6
	if (!(type & (ZEROPAD + LEFT))) {
57e24988:	1a000005 	bne	57e249a4 <number.clone.4+0x174>
57e2498c:	ea000001 	b	57e24998 <number.clone.4+0x168>
		while (--size >= 0)
			ADDCH(buf, ' ');
57e24990:	e4c42001 	strb	r2, [r4], #1
57e24994:	ea000000 	b	57e2499c <number.clone.4+0x16c>
57e24998:	e3a02020 	mov	r2, #32
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
		while (--size >= 0)
57e2499c:	e2566001 	subs	r6, r6, #1
57e249a0:	5afffffa 	bpl	57e24990 <number.clone.4+0x160>
			ADDCH(buf, ' ');
	}
	/* sign */
	if (sign)
57e249a4:	e3570000 	cmp	r7, #0
		ADDCH(buf, sign);
57e249a8:	14c47001 	strbne	r7, [r4], #1
	/* "0x" / "0" prefix */
	if (need_pfx) {
57e249ac:	e35b0000 	cmp	fp, #0
57e249b0:	0a000005 	beq	57e249cc <number.clone.4+0x19c>
		ADDCH(buf, '0');
57e249b4:	e3a02030 	mov	r2, #48	; 0x30
57e249b8:	e4c42001 	strb	r2, [r4], #1
		if (base == 16)
57e249bc:	e3590010 	cmp	r9, #16
			ADDCH(buf, 'X' | locase);
57e249c0:	059d1004 	ldreq	r1, [sp, #4]
57e249c4:	03812058 	orreq	r2, r1, #88	; 0x58
57e249c8:	04c42001 	strbeq	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
57e249cc:	e3150010 	tst	r5, #16
57e249d0:	1a000009 	bne	57e249fc <number.clone.4+0x1cc>
		char c = (type & ZEROPAD) ? '0' : ' ';
57e249d4:	e3150001 	tst	r5, #1
57e249d8:	03a02020 	moveq	r2, #32
57e249dc:	13a02030 	movne	r2, #48	; 0x30
57e249e0:	ea000000 	b	57e249e8 <number.clone.4+0x1b8>

		while (--size >= 0)
			ADDCH(buf, c);
57e249e4:	e4c42001 	strb	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
		char c = (type & ZEROPAD) ? '0' : ' ';

		while (--size >= 0)
57e249e8:	e2566001 	subs	r6, r6, #1
57e249ec:	5afffffc 	bpl	57e249e4 <number.clone.4+0x1b4>
57e249f0:	ea000001 	b	57e249fc <number.clone.4+0x1cc>
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
57e249f4:	e4c42001 	strb	r2, [r4], #1
57e249f8:	ea000000 	b	57e24a00 <number.clone.4+0x1d0>
57e249fc:	e3a02030 	mov	r2, #48	; 0x30

		while (--size >= 0)
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
57e24a00:	e2433001 	sub	r3, r3, #1
57e24a04:	e15a0003 	cmp	sl, r3
57e24a08:	dafffff9 	ble	57e249f4 <number.clone.4+0x1c4>
57e24a0c:	ea000002 	b	57e24a1c <number.clone.4+0x1ec>
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
57e24a10:	e28d3014 	add	r3, sp, #20
57e24a14:	e7d3300a 	ldrb	r3, [r3, sl]
57e24a18:	e4c43001 	strb	r3, [r4], #1
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
57e24a1c:	e25aa001 	subs	sl, sl, #1
57e24a20:	5afffffa 	bpl	57e24a10 <number.clone.4+0x1e0>
57e24a24:	ea000001 	b	57e24a30 <number.clone.4+0x200>
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
		ADDCH(buf, ' ');
57e24a28:	e4c43001 	strb	r3, [r4], #1
57e24a2c:	ea000000 	b	57e24a34 <number.clone.4+0x204>
57e24a30:	e3a03020 	mov	r3, #32
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
57e24a34:	e2566001 	subs	r6, r6, #1
57e24a38:	5afffffa 	bpl	57e24a28 <number.clone.4+0x1f8>
		ADDCH(buf, ' ');
	return buf;
}
57e24a3c:	e1a00004 	mov	r0, r4
57e24a40:	e28dd058 	add	sp, sp, #88	; 0x58
57e24a44:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e24a48:	57e2d5d8 	.word	0x57e2d5d8

57e24a4c <vsnprintf_internal.clone.6>:
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
57e24a4c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e24a50:	e24dd058 	sub	sp, sp, #88	; 0x58
57e24a54:	e58d0020 	str	r0, [sp, #32]
	if (end < buf) {
		end = ((void *)-1);
		size = end - buf;
	}
#endif
	str = buf;
57e24a58:	e1a0a000 	mov	sl, r0
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
57e24a5c:	e28d0054 	add	r0, sp, #84	; 0x54
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
57e24a60:	e1a04001 	mov	r4, r1
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
57e24a64:	e58d0014 	str	r0, [sp, #20]
57e24a68:	ea000183 	b	57e2507c <vsnprintf_internal.clone.6+0x630>
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
57e24a6c:	e3530025 	cmp	r3, #37	; 0x25
57e24a70:	1a000149 	bne	57e24f9c <vsnprintf_internal.clone.6+0x550>
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
57e24a74:	e2841001 	add	r1, r4, #1
57e24a78:	e3a07000 	mov	r7, #0
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
			ADDCH(str, *fmt);
57e24a7c:	e1a04001 	mov	r4, r1

		/* process flags */
		flags = 0;
repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
57e24a80:	e4d13001 	ldrb	r3, [r1], #1
57e24a84:	e353002b 	cmp	r3, #43	; 0x2b
57e24a88:	0a00000c 	beq	57e24ac0 <vsnprintf_internal.clone.6+0x74>
57e24a8c:	8a000004 	bhi	57e24aa4 <vsnprintf_internal.clone.6+0x58>
57e24a90:	e3530020 	cmp	r3, #32
57e24a94:	0a00000b 	beq	57e24ac8 <vsnprintf_internal.clone.6+0x7c>
57e24a98:	e3530023 	cmp	r3, #35	; 0x23
57e24a9c:	1a00000f 	bne	57e24ae0 <vsnprintf_internal.clone.6+0x94>
57e24aa0:	ea00000a 	b	57e24ad0 <vsnprintf_internal.clone.6+0x84>
57e24aa4:	e353002d 	cmp	r3, #45	; 0x2d
57e24aa8:	0a000002 	beq	57e24ab8 <vsnprintf_internal.clone.6+0x6c>
57e24aac:	e3530030 	cmp	r3, #48	; 0x30
57e24ab0:	1a00000a 	bne	57e24ae0 <vsnprintf_internal.clone.6+0x94>
57e24ab4:	ea000007 	b	57e24ad8 <vsnprintf_internal.clone.6+0x8c>
			case '-':
				flags |= LEFT;
57e24ab8:	e3877010 	orr	r7, r7, #16
57e24abc:	eaffffee 	b	57e24a7c <vsnprintf_internal.clone.6+0x30>
				goto repeat;
			case '+':
				flags |= PLUS;
57e24ac0:	e3877004 	orr	r7, r7, #4
57e24ac4:	eaffffec 	b	57e24a7c <vsnprintf_internal.clone.6+0x30>
				goto repeat;
			case ' ':
				flags |= SPACE;
57e24ac8:	e3877008 	orr	r7, r7, #8
57e24acc:	eaffffea 	b	57e24a7c <vsnprintf_internal.clone.6+0x30>
				goto repeat;
			case '#':
				flags |= SPECIAL;
57e24ad0:	e3877040 	orr	r7, r7, #64	; 0x40
57e24ad4:	eaffffe8 	b	57e24a7c <vsnprintf_internal.clone.6+0x30>
				goto repeat;
			case '0':
				flags |= ZEROPAD;
57e24ad8:	e3877001 	orr	r7, r7, #1
57e24adc:	eaffffe6 	b	57e24a7c <vsnprintf_internal.clone.6+0x30>
				goto repeat;
			}

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
57e24ae0:	e2431030 	sub	r1, r3, #48	; 0x30
57e24ae4:	e3510009 	cmp	r1, #9
57e24ae8:	91a03004 	movls	r3, r4
57e24aec:	93a09000 	movls	r9, #0
static int skip_atoi(const char **s)
{
	int i = 0;

	while (is_digit(**s))
		i = i * 10 + *((*s)++) - '0';
57e24af0:	93a0000a 	movls	r0, #10
				goto repeat;
			}

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
57e24af4:	9a000001 	bls	57e24b00 <vsnprintf_internal.clone.6+0xb4>
57e24af8:	ea000007 	b	57e24b1c <vsnprintf_internal.clone.6+0xd0>
static int skip_atoi(const char **s)
{
	int i = 0;

	while (is_digit(**s))
		i = i * 10 + *((*s)++) - '0';
57e24afc:	e0291990 	mla	r9, r0, r9, r1
57e24b00:	e1a04003 	mov	r4, r3

static int skip_atoi(const char **s)
{
	int i = 0;

	while (is_digit(**s))
57e24b04:	e4d31001 	ldrb	r1, [r3], #1
57e24b08:	e2411030 	sub	r1, r1, #48	; 0x30
57e24b0c:	e201c0ff 	and	ip, r1, #255	; 0xff
57e24b10:	e35c0009 	cmp	ip, #9
57e24b14:	9afffff8 	bls	57e24afc <vsnprintf_internal.clone.6+0xb0>
57e24b18:	ea000009 	b	57e24b44 <vsnprintf_internal.clone.6+0xf8>

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
57e24b1c:	e353002a 	cmp	r3, #42	; 0x2a
				flags |= ZEROPAD;
				goto repeat;
			}

		/* get field width */
		field_width = -1;
57e24b20:	13e09000 	mvnne	r9, #0
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
57e24b24:	1a000006 	bne	57e24b44 <vsnprintf_internal.clone.6+0xf8>
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
57e24b28:	e5929000 	ldr	r9, [r2]
57e24b2c:	e2823004 	add	r3, r2, #4
			if (field_width < 0) {
57e24b30:	e3590000 	cmp	r9, #0
		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
57e24b34:	e2844001 	add	r4, r4, #1
			/* it's the next argument */
			field_width = va_arg(args, int);
			if (field_width < 0) {
				field_width = -field_width;
57e24b38:	b2699000 	rsblt	r9, r9, #0
				flags |= LEFT;
57e24b3c:	b3877010 	orrlt	r7, r7, #16
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
57e24b40:	e1a02003 	mov	r2, r3
			}
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
57e24b44:	e5d43000 	ldrb	r3, [r4]
57e24b48:	e353002e 	cmp	r3, #46	; 0x2e
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
57e24b4c:	13e05000 	mvnne	r5, #0
		if (*fmt == '.') {
57e24b50:	1a00001c 	bne	57e24bc8 <vsnprintf_internal.clone.6+0x17c>
			++fmt;
			if (is_digit(*fmt))
57e24b54:	e5f43001 	ldrb	r3, [r4, #1]!
57e24b58:	e2431030 	sub	r1, r3, #48	; 0x30
57e24b5c:	e3510009 	cmp	r1, #9
57e24b60:	91a03004 	movls	r3, r4
57e24b64:	93a05000 	movls	r5, #0
static int skip_atoi(const char **s)
{
	int i = 0;

	while (is_digit(**s))
		i = i * 10 + *((*s)++) - '0';
57e24b68:	93a0000a 	movls	r0, #10

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
57e24b6c:	9a000001 	bls	57e24b78 <vsnprintf_internal.clone.6+0x12c>
57e24b70:	ea000009 	b	57e24b9c <vsnprintf_internal.clone.6+0x150>
static int skip_atoi(const char **s)
{
	int i = 0;

	while (is_digit(**s))
		i = i * 10 + *((*s)++) - '0';
57e24b74:	e0251590 	mla	r5, r0, r5, r1

static int skip_atoi(const char **s)
{
	int i = 0;

	while (is_digit(**s))
57e24b78:	e5d31000 	ldrb	r1, [r3]
		i = i * 10 + *((*s)++) - '0';
57e24b7c:	e1a04003 	mov	r4, r3

static int skip_atoi(const char **s)
{
	int i = 0;

	while (is_digit(**s))
57e24b80:	e2411030 	sub	r1, r1, #48	; 0x30
57e24b84:	e201c0ff 	and	ip, r1, #255	; 0xff
57e24b88:	e35c0009 	cmp	ip, #9
57e24b8c:	e2833001 	add	r3, r3, #1
57e24b90:	9afffff7 	bls	57e24b74 <vsnprintf_internal.clone.6+0x128>
57e24b94:	e1a03002 	mov	r3, r2
57e24b98:	ea000006 	b	57e24bb8 <vsnprintf_internal.clone.6+0x16c>
		precision = -1;
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
57e24b9c:	e353002a 	cmp	r3, #42	; 0x2a
57e24ba0:	1a000007 	bne	57e24bc4 <vsnprintf_internal.clone.6+0x178>
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
57e24ba4:	e5925000 	ldr	r5, [r2]
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
57e24ba8:	e2844001 	add	r4, r4, #1
				/* it's the next argument */
				precision = va_arg(args, int);
			}
			if (precision < 0)
57e24bac:	e3550000 	cmp	r5, #0
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
57e24bb0:	e2823004 	add	r3, r2, #4
			}
			if (precision < 0)
57e24bb4:	ba000001 	blt	57e24bc0 <vsnprintf_internal.clone.6+0x174>
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
57e24bb8:	e1a02003 	mov	r2, r3
57e24bbc:	ea000001 	b	57e24bc8 <vsnprintf_internal.clone.6+0x17c>
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
57e24bc0:	e1a02003 	mov	r2, r3
			}
			if (precision < 0)
				precision = 0;
57e24bc4:	e3a05000 	mov	r5, #0
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
57e24bc8:	e5d41000 	ldrb	r1, [r4]
57e24bcc:	e3510068 	cmp	r1, #104	; 0x68
57e24bd0:	1351006c 	cmpne	r1, #108	; 0x6c
57e24bd4:	0a000008 	beq	57e24bfc <vsnprintf_internal.clone.6+0x1b0>
57e24bd8:	e351004c 	cmp	r1, #76	; 0x4c
57e24bdc:	0a000006 	beq	57e24bfc <vsnprintf_internal.clone.6+0x1b0>
57e24be0:	e351005a 	cmp	r1, #90	; 0x5a
57e24be4:	0a000004 	beq	57e24bfc <vsnprintf_internal.clone.6+0x1b0>
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
57e24be8:	e351007a 	cmp	r1, #122	; 0x7a
57e24bec:	0a000002 	beq	57e24bfc <vsnprintf_internal.clone.6+0x1b0>
57e24bf0:	e3510074 	cmp	r1, #116	; 0x74
			if (precision < 0)
				precision = 0;
		}

		/* get the conversion qualifier */
		qualifier = -1;
57e24bf4:	13e01000 	mvnne	r1, #0
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
57e24bf8:	1a000006 	bne	57e24c18 <vsnprintf_internal.clone.6+0x1cc>
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
57e24bfc:	e351006c 	cmp	r1, #108	; 0x6c
		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
57e24c00:	e2844001 	add	r4, r4, #1
			if (qualifier == 'l' && *fmt == 'l') {
57e24c04:	1a000003 	bne	57e24c18 <vsnprintf_internal.clone.6+0x1cc>
57e24c08:	e5d43000 	ldrb	r3, [r4]
57e24c0c:	e353006c 	cmp	r3, #108	; 0x6c
				qualifier = 'L';
				++fmt;
57e24c10:	02844001 	addeq	r4, r4, #1
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
				qualifier = 'L';
57e24c14:	03a0104c 	moveq	r1, #76	; 0x4c
		}

		/* default base */
		base = 10;

		switch (*fmt) {
57e24c18:	e5d43000 	ldrb	r3, [r4]
57e24c1c:	e353006e 	cmp	r3, #110	; 0x6e
57e24c20:	0a0000cb 	beq	57e24f54 <vsnprintf_internal.clone.6+0x508>
57e24c24:	8a00000c 	bhi	57e24c5c <vsnprintf_internal.clone.6+0x210>
57e24c28:	e3530063 	cmp	r3, #99	; 0x63
57e24c2c:	0a000017 	beq	57e24c90 <vsnprintf_internal.clone.6+0x244>
57e24c30:	8a000004 	bhi	57e24c48 <vsnprintf_internal.clone.6+0x1fc>
57e24c34:	e3530025 	cmp	r3, #37	; 0x25
57e24c38:	0a0000d7 	beq	57e24f9c <vsnprintf_internal.clone.6+0x550>
57e24c3c:	e3530058 	cmp	r3, #88	; 0x58
57e24c40:	1a0000cf 	bne	57e24f84 <vsnprintf_internal.clone.6+0x538>
57e24c44:	ea0000d8 	b	57e24fac <vsnprintf_internal.clone.6+0x560>
57e24c48:	e3530064 	cmp	r3, #100	; 0x64
57e24c4c:	0a0000ca 	beq	57e24f7c <vsnprintf_internal.clone.6+0x530>
57e24c50:	e3530069 	cmp	r3, #105	; 0x69
57e24c54:	1a0000ca 	bne	57e24f84 <vsnprintf_internal.clone.6+0x538>
57e24c58:	ea0000c7 	b	57e24f7c <vsnprintf_internal.clone.6+0x530>
57e24c5c:	e3530073 	cmp	r3, #115	; 0x73
57e24c60:	0a00001e 	beq	57e24ce0 <vsnprintf_internal.clone.6+0x294>
57e24c64:	8a000004 	bhi	57e24c7c <vsnprintf_internal.clone.6+0x230>
57e24c68:	e353006f 	cmp	r3, #111	; 0x6f
57e24c6c:	0a0000be 	beq	57e24f6c <vsnprintf_internal.clone.6+0x520>
57e24c70:	e3530070 	cmp	r3, #112	; 0x70
57e24c74:	1a0000c2 	bne	57e24f84 <vsnprintf_internal.clone.6+0x538>
57e24c78:	ea000020 	b	57e24d00 <vsnprintf_internal.clone.6+0x2b4>
57e24c7c:	e3530075 	cmp	r3, #117	; 0x75
57e24c80:	0a0000c7 	beq	57e24fa4 <vsnprintf_internal.clone.6+0x558>
57e24c84:	e3530078 	cmp	r3, #120	; 0x78
57e24c88:	1a0000bd 	bne	57e24f84 <vsnprintf_internal.clone.6+0x538>
57e24c8c:	ea0000b8 	b	57e24f74 <vsnprintf_internal.clone.6+0x528>
		case 'c':
			if (!(flags & LEFT)) {
57e24c90:	e3170010 	tst	r7, #16
57e24c94:	1a000006 	bne	57e24cb4 <vsnprintf_internal.clone.6+0x268>
57e24c98:	ea000001 	b	57e24ca4 <vsnprintf_internal.clone.6+0x258>
				while (--field_width > 0)
					ADDCH(str, ' ');
57e24c9c:	e4ca3001 	strb	r3, [sl], #1
57e24ca0:	ea000000 	b	57e24ca8 <vsnprintf_internal.clone.6+0x25c>
57e24ca4:	e3a03020 	mov	r3, #32
		base = 10;

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
57e24ca8:	e2499001 	sub	r9, r9, #1
57e24cac:	e3590000 	cmp	r9, #0
57e24cb0:	cafffff9 	bgt	57e24c9c <vsnprintf_internal.clone.6+0x250>
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
57e24cb4:	e2823004 	add	r3, r2, #4
57e24cb8:	e5922000 	ldr	r2, [r2]
57e24cbc:	e4ca2001 	strb	r2, [sl], #1
			while (--field_width > 0)
				ADDCH(str, ' ');
57e24cc0:	e3a02020 	mov	r2, #32
57e24cc4:	ea000000 	b	57e24ccc <vsnprintf_internal.clone.6+0x280>
57e24cc8:	e4ca2001 	strb	r2, [sl], #1
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
			while (--field_width > 0)
57e24ccc:	e2499001 	sub	r9, r9, #1
57e24cd0:	e3590000 	cmp	r9, #0
57e24cd4:	cafffffb 	bgt	57e24cc8 <vsnprintf_internal.clone.6+0x27c>
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
57e24cd8:	e1a02003 	mov	r2, r3
57e24cdc:	ea0000e5 	b	57e25078 <vsnprintf_internal.clone.6+0x62c>
			while (--field_width > 0)
				ADDCH(str, ' ');
			continue;

		case 's':
			str = string(str, end, va_arg(args, char *),
57e24ce0:	e58d7000 	str	r7, [sp]
57e24ce4:	e2826004 	add	r6, r2, #4
57e24ce8:	e5921000 	ldr	r1, [r2]
57e24cec:	e1a0000a 	mov	r0, sl
57e24cf0:	e1a02009 	mov	r2, r9
57e24cf4:	e1a03005 	mov	r3, r5
57e24cf8:	ebfffea8 	bl	57e247a0 <string.clone.0>
57e24cfc:	ea0000db 	b	57e25070 <vsnprintf_internal.clone.6+0x624>
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt + 1, str, end,
57e24d00:	e2823004 	add	r3, r2, #4
57e24d04:	e58d3024 	str	r3, [sp, #36]	; 0x24
		return string(buf, end, "(null)", field_width, precision,
			      flags);
#endif

#ifdef CONFIG_CMD_NET
	switch (*fmt) {
57e24d08:	e5d43001 	ldrb	r3, [r4, #1]
			str = string(str, end, va_arg(args, char *),
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt + 1, str, end,
57e24d0c:	e2841001 	add	r1, r4, #1
		return string(buf, end, "(null)", field_width, precision,
			      flags);
#endif

#ifdef CONFIG_CMD_NET
	switch (*fmt) {
57e24d10:	e353004d 	cmp	r3, #77	; 0x4d
			str = string(str, end, va_arg(args, char *),
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt + 1, str, end,
57e24d14:	e5922000 	ldr	r2, [r2]
		return string(buf, end, "(null)", field_width, precision,
			      flags);
#endif

#ifdef CONFIG_CMD_NET
	switch (*fmt) {
57e24d18:	0a000008 	beq	57e24d40 <vsnprintf_internal.clone.6+0x2f4>
57e24d1c:	8a000002 	bhi	57e24d2c <vsnprintf_internal.clone.6+0x2e0>
57e24d20:	e3530049 	cmp	r3, #73	; 0x49
57e24d24:	1a000074 	bne	57e24efc <vsnprintf_internal.clone.6+0x4b0>
57e24d28:	ea00001d 	b	57e24da4 <vsnprintf_internal.clone.6+0x358>
57e24d2c:	e3530069 	cmp	r3, #105	; 0x69
57e24d30:	0a00001a 	beq	57e24da0 <vsnprintf_internal.clone.6+0x354>
57e24d34:	e353006d 	cmp	r3, #109	; 0x6d
57e24d38:	1a00006f 	bne	57e24efc <vsnprintf_internal.clone.6+0x4b0>
	case 'm':
		flags |= SPECIAL;
57e24d3c:	e3877040 	orr	r7, r7, #64	; 0x40
static char *mac_address_string(char *buf, char *end, u8 *addr, int field_width,
				int precision, int flags)
{
	/* (6 * 2 hex digits), 5 colons and trailing zero */
	char mac_addr[6 * 3];
	char *p = mac_addr;
57e24d40:	e28d302c 	add	r3, sp, #44	; 0x2c
	int i;

	for (i = 0; i < 6; i++) {
57e24d44:	e3a01000 	mov	r1, #0
		p = pack_hex_byte(p, addr[i]);
		if (!(flags & SPECIAL) && i != 5)
57e24d48:	e207e040 	and	lr, r7, #64	; 0x40
	char mac_addr[6 * 3];
	char *p = mac_addr;
	int i;

	for (i = 0; i < 6; i++) {
		p = pack_hex_byte(p, addr[i]);
57e24d4c:	e7d2c001 	ldrb	ip, [r2, r1]
#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
57e24d50:	e59fb344 	ldr	fp, [pc, #836]	; 57e2509c <vsnprintf_internal.clone.6+0x650>
57e24d54:	e1a00003 	mov	r0, r3
57e24d58:	e7db622c 	ldrb	r6, [fp, ip, lsr #4]
	*buf++ = hex_asc_lo(byte);
57e24d5c:	e20cc00f 	and	ip, ip, #15
#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
57e24d60:	e4c06001 	strb	r6, [r0], #1
	*buf++ = hex_asc_lo(byte);
57e24d64:	e7dbc00c 	ldrb	ip, [fp, ip]
57e24d68:	e5c3c001 	strb	ip, [r3, #1]
	char *p = mac_addr;
	int i;

	for (i = 0; i < 6; i++) {
		p = pack_hex_byte(p, addr[i]);
		if (!(flags & SPECIAL) && i != 5)
57e24d6c:	e251c005 	subs	ip, r1, #5
57e24d70:	13a0c001 	movne	ip, #1
57e24d74:	e35e0000 	cmp	lr, #0
57e24d78:	13a0c000 	movne	ip, #0
57e24d7c:	e35c0000 	cmp	ip, #0
			*p++ = ':';
57e24d80:	13a0c03a 	movne	ip, #58	; 0x3a
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
	*buf++ = hex_asc_lo(byte);
57e24d84:	e2803001 	add	r3, r0, #1
	/* (6 * 2 hex digits), 5 colons and trailing zero */
	char mac_addr[6 * 3];
	char *p = mac_addr;
	int i;

	for (i = 0; i < 6; i++) {
57e24d88:	e2811001 	add	r1, r1, #1
		p = pack_hex_byte(p, addr[i]);
		if (!(flags & SPECIAL) && i != 5)
			*p++ = ':';
57e24d8c:	15c0c001 	strbne	ip, [r0, #1]
57e24d90:	12833001 	addne	r3, r3, #1
	/* (6 * 2 hex digits), 5 colons and trailing zero */
	char mac_addr[6 * 3];
	char *p = mac_addr;
	int i;

	for (i = 0; i < 6; i++) {
57e24d94:	e3510006 	cmp	r1, #6
57e24d98:	1affffeb 	bne	57e24d4c <vsnprintf_internal.clone.6+0x300>
57e24d9c:	ea000025 	b	57e24e38 <vsnprintf_internal.clone.6+0x3ec>
		/* Fallthrough */
	case 'M':
		return mac_address_string(buf, end, ptr, field_width,
					  precision, flags);
	case 'i':
		flags |= SPECIAL;
57e24da0:	e3877040 	orr	r7, r7, #64	; 0x40
		/* Fallthrough */
	case 'I':
		if (fmt[1] == '6')
57e24da4:	e5d13001 	ldrb	r3, [r1, #1]
57e24da8:	e3530036 	cmp	r3, #54	; 0x36
57e24dac:	1a000024 	bne	57e24e44 <vsnprintf_internal.clone.6+0x3f8>
static char *ip6_addr_string(char *buf, char *end, u8 *addr, int field_width,
			 int precision, int flags)
{
	/* (8 * 4 hex digits), 7 colons and trailing zero */
	char ip6_addr[8 * 5];
	char *p = ip6_addr;
57e24db0:	e28d302c 	add	r3, sp, #44	; 0x2c
	int i;

	for (i = 0; i < 8; i++) {
57e24db4:	e3a01000 	mov	r1, #0
		p = pack_hex_byte(p, addr[2 * i]);
		p = pack_hex_byte(p, addr[2 * i + 1]);
		if (!(flags & SPECIAL) && i != 7)
57e24db8:	e207c040 	and	ip, r7, #64	; 0x40
	char ip6_addr[8 * 5];
	char *p = ip6_addr;
	int i;

	for (i = 0; i < 8; i++) {
		p = pack_hex_byte(p, addr[2 * i]);
57e24dbc:	e5d2e000 	ldrb	lr, [r2]
#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
57e24dc0:	e59f02d4 	ldr	r0, [pc, #724]	; 57e2509c <vsnprintf_internal.clone.6+0x650>
	*buf++ = hex_asc_lo(byte);
57e24dc4:	e59fb2d0 	ldr	fp, [pc, #720]	; 57e2509c <vsnprintf_internal.clone.6+0x650>
#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
57e24dc8:	e7d0622e 	ldrb	r6, [r0, lr, lsr #4]
57e24dcc:	e1a00003 	mov	r0, r3
57e24dd0:	e4c06001 	strb	r6, [r0], #1
	*buf++ = hex_asc_lo(byte);
57e24dd4:	e59f62c0 	ldr	r6, [pc, #704]	; 57e2509c <vsnprintf_internal.clone.6+0x650>
57e24dd8:	e20ee00f 	and	lr, lr, #15
57e24ddc:	e7d6e00e 	ldrb	lr, [r6, lr]
57e24de0:	e5c3e001 	strb	lr, [r3, #1]
	char *p = ip6_addr;
	int i;

	for (i = 0; i < 8; i++) {
		p = pack_hex_byte(p, addr[2 * i]);
		p = pack_hex_byte(p, addr[2 * i + 1]);
57e24de4:	e5d2e001 	ldrb	lr, [r2, #1]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
	*buf++ = hex_asc_lo(byte);
57e24de8:	e2803001 	add	r3, r0, #1
#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
57e24dec:	e7d6622e 	ldrb	r6, [r6, lr, lsr #4]
	*buf++ = hex_asc_lo(byte);
57e24df0:	e20ee00f 	and	lr, lr, #15
#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
57e24df4:	e5c06001 	strb	r6, [r0, #1]
	*buf++ = hex_asc_lo(byte);
57e24df8:	e7dbe00e 	ldrb	lr, [fp, lr]
#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
57e24dfc:	e2830001 	add	r0, r3, #1
	*buf++ = hex_asc_lo(byte);
57e24e00:	e5c3e001 	strb	lr, [r3, #1]
	int i;

	for (i = 0; i < 8; i++) {
		p = pack_hex_byte(p, addr[2 * i]);
		p = pack_hex_byte(p, addr[2 * i + 1]);
		if (!(flags & SPECIAL) && i != 7)
57e24e04:	e251e007 	subs	lr, r1, #7
57e24e08:	13a0e001 	movne	lr, #1
57e24e0c:	e35c0000 	cmp	ip, #0
57e24e10:	13a0e000 	movne	lr, #0
57e24e14:	e35e0000 	cmp	lr, #0
			*p++ = ':';
57e24e18:	13a0e03a 	movne	lr, #58	; 0x3a
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
	*buf++ = hex_asc_lo(byte);
57e24e1c:	e2803001 	add	r3, r0, #1
	/* (8 * 4 hex digits), 7 colons and trailing zero */
	char ip6_addr[8 * 5];
	char *p = ip6_addr;
	int i;

	for (i = 0; i < 8; i++) {
57e24e20:	e2811001 	add	r1, r1, #1
		p = pack_hex_byte(p, addr[2 * i]);
		p = pack_hex_byte(p, addr[2 * i + 1]);
		if (!(flags & SPECIAL) && i != 7)
			*p++ = ':';
57e24e24:	15c0e001 	strbne	lr, [r0, #1]
57e24e28:	12833001 	addne	r3, r3, #1
	/* (8 * 4 hex digits), 7 colons and trailing zero */
	char ip6_addr[8 * 5];
	char *p = ip6_addr;
	int i;

	for (i = 0; i < 8; i++) {
57e24e2c:	e3510008 	cmp	r1, #8
57e24e30:	e2822002 	add	r2, r2, #2
57e24e34:	1affffe0 	bne	57e24dbc <vsnprintf_internal.clone.6+0x370>
		p = pack_hex_byte(p, addr[2 * i]);
		p = pack_hex_byte(p, addr[2 * i + 1]);
		if (!(flags & SPECIAL) && i != 7)
			*p++ = ':';
	}
	*p = '\0';
57e24e38:	e3a02000 	mov	r2, #0
57e24e3c:	e5c32000 	strb	r2, [r3]
57e24e40:	ea000025 	b	57e24edc <vsnprintf_internal.clone.6+0x490>
		/* Fallthrough */
	case 'I':
		if (fmt[1] == '6')
			return ip6_addr_string(buf, end, ptr, field_width,
					       precision, flags);
		if (fmt[1] == '4')
57e24e44:	e3530034 	cmp	r3, #52	; 0x34
			return ip4_addr_string(buf, end, ptr, field_width,
					       precision, flags);
		flags &= ~SPECIAL;
57e24e48:	13c77040 	bicne	r7, r7, #64	; 0x40
		/* Fallthrough */
	case 'I':
		if (fmt[1] == '6')
			return ip6_addr_string(buf, end, ptr, field_width,
					       precision, flags);
		if (fmt[1] == '4')
57e24e4c:	1a00002a 	bne	57e24efc <vsnprintf_internal.clone.6+0x4b0>
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
			*p++ = temp[digits];
		if (i != 3)
			*p++ = '.';
57e24e50:	e1a01002 	mov	r1, r2
			 int precision, int flags)
{
	/* (4 * 3 decimal digits), 3 dots and trailing zero */
	char ip4_addr[4 * 4];
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
57e24e54:	e28d602c 	add	r6, sp, #44	; 0x2c
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
			*p++ = temp[digits];
		if (i != 3)
			*p++ = '.';
57e24e58:	e1a0200a 	mov	r2, sl
	char ip4_addr[4 * 4];
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
57e24e5c:	e3a0b000 	mov	fp, #0
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
			*p++ = temp[digits];
		if (i != 3)
			*p++ = '.';
57e24e60:	e1a0a007 	mov	sl, r7
57e24e64:	e3a0302e 	mov	r3, #46	; 0x2e
57e24e68:	e1a07001 	mov	r7, r1
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
57e24e6c:	e7d7100b 	ldrb	r1, [r7, fp]
57e24e70:	e28d0054 	add	r0, sp, #84	; 0x54
57e24e74:	e58d2018 	str	r2, [sp, #24]
57e24e78:	e58d301c 	str	r3, [sp, #28]
57e24e7c:	ebfffdc2 	bl	57e2458c <put_dec_trunc>
57e24e80:	e59d1014 	ldr	r1, [sp, #20]
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
57e24e84:	e28dc054 	add	ip, sp, #84	; 0x54
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
57e24e88:	e0610000 	rsb	r0, r1, r0
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
57e24e8c:	e08c1000 	add	r1, ip, r0
57e24e90:	e59d2018 	ldr	r2, [sp, #24]
57e24e94:	e1a0c006 	mov	ip, r6
57e24e98:	e59d301c 	ldr	r3, [sp, #28]
57e24e9c:	ea000001 	b	57e24ea8 <vsnprintf_internal.clone.6+0x45c>

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
			*p++ = temp[digits];
57e24ea0:	e571e001 	ldrb	lr, [r1, #-1]!
57e24ea4:	e4cce001 	strb	lr, [ip], #1
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
57e24ea8:	e59de014 	ldr	lr, [sp, #20]
57e24eac:	e151000e 	cmp	r1, lr
57e24eb0:	1afffffa 	bne	57e24ea0 <vsnprintf_internal.clone.6+0x454>
			*p++ = temp[digits];
		if (i != 3)
57e24eb4:	e35b0003 	cmp	fp, #3
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
57e24eb8:	e0866000 	add	r6, r6, r0
	char ip4_addr[4 * 4];
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
57e24ebc:	e28bb001 	add	fp, fp, #1
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
			*p++ = temp[digits];
		if (i != 3)
			*p++ = '.';
57e24ec0:	14c63001 	strbne	r3, [r6], #1
	char ip4_addr[4 * 4];
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
57e24ec4:	e35b0004 	cmp	fp, #4
57e24ec8:	1affffe7 	bne	57e24e6c <vsnprintf_internal.clone.6+0x420>
		while (digits--)
			*p++ = temp[digits];
		if (i != 3)
			*p++ = '.';
	}
	*p = '\0';
57e24ecc:	e3a03000 	mov	r3, #0
57e24ed0:	e1a0700a 	mov	r7, sl
57e24ed4:	e5c63000 	strb	r3, [r6]
57e24ed8:	e1a0a002 	mov	sl, r2

	return string(buf, end, ip4_addr, field_width, precision,
57e24edc:	e3c77040 	bic	r7, r7, #64	; 0x40
57e24ee0:	e1a0000a 	mov	r0, sl
57e24ee4:	e28d102c 	add	r1, sp, #44	; 0x2c
57e24ee8:	e1a02009 	mov	r2, r9
57e24eec:	e1a03005 	mov	r3, r5
57e24ef0:	e58d7000 	str	r7, [sp]
57e24ef4:	ebfffe29 	bl	57e247a0 <string.clone.0>
57e24ef8:	ea00000a 	b	57e24f28 <vsnprintf_internal.clone.6+0x4dc>
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
	if (field_width == -1) {
57e24efc:	e3790001 	cmn	r9, #1
					       precision, flags);
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
57e24f00:	e3873020 	orr	r3, r7, #32
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
		flags |= ZEROPAD;
57e24f04:	03873021 	orreq	r3, r7, #33	; 0x21
		break;
	}
#endif
	flags |= SMALL;
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
57e24f08:	02899009 	addeq	r9, r9, #9
		flags |= ZEROPAD;
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
57e24f0c:	e3a01010 	mov	r1, #16
57e24f10:	e58d300c 	str	r3, [sp, #12]
57e24f14:	e1a0000a 	mov	r0, sl
57e24f18:	e3a03000 	mov	r3, #0
57e24f1c:	e88d0202 	stm	sp, {r1, r9}
57e24f20:	e58d5008 	str	r5, [sp, #8]
57e24f24:	ebfffe41 	bl	57e24830 <number.clone.4>
57e24f28:	e1a0a000 	mov	sl, r0
57e24f2c:	e1a03004 	mov	r3, r4
		case 'p':
			str = pointer(fmt + 1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
57e24f30:	e5d32001 	ldrb	r2, [r3, #1]
57e24f34:	e59f0164 	ldr	r0, [pc, #356]	; 57e250a0 <vsnprintf_internal.clone.6+0x654>
	flags |= SMALL;
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
		flags |= ZEROPAD;
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
57e24f38:	e1a04003 	mov	r4, r3
		case 'p':
			str = pointer(fmt + 1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
57e24f3c:	e7d02002 	ldrb	r2, [r0, r2]
57e24f40:	e2833001 	add	r3, r3, #1
57e24f44:	e3120007 	tst	r2, #7
57e24f48:	1afffff8 	bne	57e24f30 <vsnprintf_internal.clone.6+0x4e4>
			str = string(str, end, va_arg(args, char *),
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt + 1, str, end,
57e24f4c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
57e24f50:	ea000048 	b	57e25078 <vsnprintf_internal.clone.6+0x62c>
57e24f54:	e59d1020 	ldr	r1, [sp, #32]
57e24f58:	e2826004 	add	r6, r2, #4
			if (qualifier == 'l') {
				long *ip = va_arg(args, long *);
				*ip = (str - buf);
			} else {
				int *ip = va_arg(args, int *);
				*ip = (str - buf);
57e24f5c:	e5922000 	ldr	r2, [r2]
57e24f60:	e061300a 	rsb	r3, r1, sl
57e24f64:	e5823000 	str	r3, [r2]
57e24f68:	ea000041 	b	57e25074 <vsnprintf_internal.clone.6+0x628>
			ADDCH(str, '%');
			continue;

		/* integer number formats - set up the flags and "break" */
		case 'o':
			base = 8;
57e24f6c:	e3a00008 	mov	r0, #8
57e24f70:	ea00000e 	b	57e24fb0 <vsnprintf_internal.clone.6+0x564>
			break;

		case 'x':
			flags |= SMALL;
57e24f74:	e3877020 	orr	r7, r7, #32
57e24f78:	ea00000b 	b	57e24fac <vsnprintf_internal.clone.6+0x560>
			base = 16;
			break;

		case 'd':
		case 'i':
			flags |= SIGN;
57e24f7c:	e3877002 	orr	r7, r7, #2
57e24f80:	ea000007 	b	57e24fa4 <vsnprintf_internal.clone.6+0x558>
		case 'u':
			break;

		default:
			ADDCH(str, '%');
57e24f84:	e3a03025 	mov	r3, #37	; 0x25
57e24f88:	e4ca3001 	strb	r3, [sl], #1
			if (*fmt)
57e24f8c:	e5d43000 	ldrb	r3, [r4]
57e24f90:	e3530000 	cmp	r3, #0
				ADDCH(str, *fmt);
			else
				--fmt;
57e24f94:	02444001 	subeq	r4, r4, #1
		case 'u':
			break;

		default:
			ADDCH(str, '%');
			if (*fmt)
57e24f98:	0a000036 	beq	57e25078 <vsnprintf_internal.clone.6+0x62c>
				ADDCH(str, *fmt);
57e24f9c:	e4ca3001 	strb	r3, [sl], #1
57e24fa0:	ea000034 	b	57e25078 <vsnprintf_internal.clone.6+0x62c>
				++fmt;
			}
		}

		/* default base */
		base = 10;
57e24fa4:	e3a0000a 	mov	r0, #10
57e24fa8:	ea000000 	b	57e24fb0 <vsnprintf_internal.clone.6+0x564>
			break;

		case 'x':
			flags |= SMALL;
		case 'X':
			base = 16;
57e24fac:	e3a00010 	mov	r0, #16
				ADDCH(str, *fmt);
			else
				--fmt;
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
57e24fb0:	e351004c 	cmp	r1, #76	; 0x4c
			num = va_arg(args, unsigned long long);
57e24fb4:	02822007 	addeq	r2, r2, #7
57e24fb8:	03c22007 	biceq	r2, r2, #7
57e24fbc:	02826008 	addeq	r6, r2, #8
57e24fc0:	0892000c 	ldmeq	r2, {r2, r3}
57e24fc4:	0a000023 	beq	57e25058 <vsnprintf_internal.clone.6+0x60c>
		else if (qualifier == 'l') {
57e24fc8:	e351006c 	cmp	r1, #108	; 0x6c
57e24fcc:	1a000005 	bne	57e24fe8 <vsnprintf_internal.clone.6+0x59c>
			num = va_arg(args, unsigned long);
57e24fd0:	e2826004 	add	r6, r2, #4
57e24fd4:	e5922000 	ldr	r2, [r2]
			if (flags & SIGN)
57e24fd8:	e3170002 	tst	r7, #2
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
57e24fdc:	e3a03000 	mov	r3, #0
			if (flags & SIGN)
57e24fe0:	0a00001c 	beq	57e25058 <vsnprintf_internal.clone.6+0x60c>
57e24fe4:	ea00001a 	b	57e25054 <vsnprintf_internal.clone.6+0x608>
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
57e24fe8:	e351005a 	cmp	r1, #90	; 0x5a
57e24fec:	1351007a 	cmpne	r1, #122	; 0x7a
			num = va_arg(args, size_t);
57e24ff0:	02826004 	addeq	r6, r2, #4
57e24ff4:	05922000 	ldreq	r2, [r2]
57e24ff8:	03a03000 	moveq	r3, #0
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
57e24ffc:	0a000015 	beq	57e25058 <vsnprintf_internal.clone.6+0x60c>
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
57e25000:	e3510074 	cmp	r1, #116	; 0x74
			num = va_arg(args, ptrdiff_t);
57e25004:	02826004 	addeq	r6, r2, #4
57e25008:	05922000 	ldreq	r2, [r2]
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
57e2500c:	0a000010 	beq	57e25054 <vsnprintf_internal.clone.6+0x608>
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
57e25010:	e3510068 	cmp	r1, #104	; 0x68
57e25014:	e2826004 	add	r6, r2, #4
57e25018:	e2071002 	and	r1, r7, #2
57e2501c:	e5922000 	ldr	r2, [r2]
57e25020:	1a000008 	bne	57e25048 <vsnprintf_internal.clone.6+0x5fc>
			num = (unsigned short) va_arg(args, int);
57e25024:	e1a02802 	lsl	r2, r2, #16
57e25028:	e1a0c822 	lsr	ip, r2, #16
			if (flags & SIGN)
57e2502c:	e3510000 	cmp	r1, #0
		} else if (qualifier == 'Z' || qualifier == 'z') {
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
57e25030:	e1a0200c 	mov	r2, ip
57e25034:	e3a03000 	mov	r3, #0
			if (flags & SIGN)
				num = (signed short) num;
57e25038:	11a0280c 	lslne	r2, ip, #16
57e2503c:	11a02842 	asrne	r2, r2, #16
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
57e25040:	1a000003 	bne	57e25054 <vsnprintf_internal.clone.6+0x608>
57e25044:	ea000003 	b	57e25058 <vsnprintf_internal.clone.6+0x60c>
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
			if (flags & SIGN)
57e25048:	e3510000 	cmp	r1, #0
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
57e2504c:	e3a03000 	mov	r3, #0
			if (flags & SIGN)
57e25050:	0a000000 	beq	57e25058 <vsnprintf_internal.clone.6+0x60c>
				num = (signed int) num;
57e25054:	e1a03fc2 	asr	r3, r2, #31
		}
		str = number(str, end, num, base, field_width, precision,
57e25058:	e58d0000 	str	r0, [sp]
57e2505c:	e1a0000a 	mov	r0, sl
57e25060:	e58d9004 	str	r9, [sp, #4]
57e25064:	e58d5008 	str	r5, [sp, #8]
57e25068:	e58d700c 	str	r7, [sp, #12]
57e2506c:	ebfffdef 	bl	57e24830 <number.clone.4>
57e25070:	e1a0a000 	mov	sl, r0
57e25074:	e1a02006 	mov	r2, r6
		size = end - buf;
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
57e25078:	e2844001 	add	r4, r4, #1
57e2507c:	e5d43000 	ldrb	r3, [r4]
57e25080:	e3530000 	cmp	r3, #0
57e25084:	1afffe78 	bne	57e24a6c <vsnprintf_internal.clone.6+0x20>
		ADDCH(str, '\0');
		if (str > end)
			end[-1] = '\0';
	}
#else
	*str = '\0';
57e25088:	e5ca3000 	strb	r3, [sl]
#endif
	/* the trailing null byte doesn't count towards the total */
	return str - buf;
}
57e2508c:	e59d3020 	ldr	r3, [sp, #32]
57e25090:	e063000a 	rsb	r0, r3, sl
57e25094:	e28dd058 	add	sp, sp, #88	; 0x58
57e25098:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e2509c:	57e355b2 	.word	0x57e355b2
57e250a0:	57e2d4d0 	.word	0x57e2d4d0

57e250a4 <simple_strtoul>:
	return buf;
}

unsigned long simple_strtoul(const char *cp, char **endp,
				unsigned int base)
{
57e250a4:	e92d4070 	push	{r4, r5, r6, lr}
	unsigned long result = 0;
	unsigned long value;

	if (*cp == '0') {
57e250a8:	e5d03000 	ldrb	r3, [r0]
57e250ac:	e3530030 	cmp	r3, #48	; 0x30
57e250b0:	1a00000d 	bne	57e250ec <simple_strtoul+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
57e250b4:	e5f03001 	ldrb	r3, [r0, #1]!
57e250b8:	e3530078 	cmp	r3, #120	; 0x78
57e250bc:	1a000007 	bne	57e250e0 <simple_strtoul+0x3c>
57e250c0:	e5d0c001 	ldrb	ip, [r0, #1]
57e250c4:	e59f4080 	ldr	r4, [pc, #128]	; 57e2514c <simple_strtoul+0xa8>
57e250c8:	e2803001 	add	r3, r0, #1
57e250cc:	e7d4c00c 	ldrb	ip, [r4, ip]
57e250d0:	e31c0044 	tst	ip, #68	; 0x44
57e250d4:	11a00003 	movne	r0, r3
			base = 16;
57e250d8:	13a02010 	movne	r2, #16
	unsigned long result = 0;
	unsigned long value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
57e250dc:	1a000004 	bne	57e250f4 <simple_strtoul+0x50>
			base = 16;
			cp++;
		}

		if (!base)
			base = 8;
57e250e0:	e3520000 	cmp	r2, #0
57e250e4:	03a02008 	moveq	r2, #8
57e250e8:	ea000001 	b	57e250f4 <simple_strtoul+0x50>
	}

	if (!base)
		base = 10;
57e250ec:	e3520000 	cmp	r2, #0
57e250f0:	03a0200a 	moveq	r2, #10

		if (!base)
			base = 8;
	}

	if (!base)
57e250f4:	e1a0c000 	mov	ip, r0
		base = 10;

	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
57e250f8:	e59f604c 	ldr	r6, [pc, #76]	; 57e2514c <simple_strtoul+0xa8>
		if (!base)
			base = 8;
	}

	if (!base)
		base = 10;
57e250fc:	e3a00000 	mov	r0, #0
57e25100:	ea000000 	b	57e25108 <simple_strtoul+0x64>

	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
57e25104:	e0203092 	mla	r0, r2, r0, r3
57e25108:	e1a0500c 	mov	r5, ip
	}

	if (!base)
		base = 10;

	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
57e2510c:	e4dc3001 	ldrb	r3, [ip], #1
57e25110:	e7d64003 	ldrb	r4, [r6, r3]
57e25114:	e3140044 	tst	r4, #68	; 0x44
57e25118:	0a000008 	beq	57e25140 <simple_strtoul+0x9c>
57e2511c:	e3140004 	tst	r4, #4
57e25120:	12433030 	subne	r3, r3, #48	; 0x30
57e25124:	1a000003 	bne	57e25138 <simple_strtoul+0x94>
57e25128:	e3140002 	tst	r4, #2
}

static inline unsigned char __toupper(unsigned char c)
{
	if (islower(c))
		c -= 'a'-'A';
57e2512c:	12433020 	subne	r3, r3, #32
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
57e25130:	120330ff 	andne	r3, r3, #255	; 0xff
57e25134:	e2433037 	sub	r3, r3, #55	; 0x37
	}

	if (!base)
		base = 10;

	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
57e25138:	e1530002 	cmp	r3, r2
57e2513c:	3afffff0 	bcc	57e25104 <simple_strtoul+0x60>
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
		cp++;
	}

	if (endp)
57e25140:	e3510000 	cmp	r1, #0
		*endp = (char *)cp;
57e25144:	15815000 	strne	r5, [r1]

	return result;
}
57e25148:	e8bd8070 	pop	{r4, r5, r6, pc}
57e2514c:	57e2d4d0 	.word	0x57e2d4d0

57e25150 <strict_strtoul>:
{
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
57e25150:	e3a03000 	mov	r3, #0

	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
57e25154:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
57e25158:	e5823000 	str	r3, [r2]

	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
57e2515c:	e1a04000 	mov	r4, r0
57e25160:	e1a07001 	mov	r7, r1
57e25164:	e1a05002 	mov	r5, r2
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
	len = strlen(cp);
57e25168:	ebfffbb8 	bl	57e24050 <strlen>
	if (len == 0)
57e2516c:	e2506000 	subs	r6, r0, #0
57e25170:	0a000012 	beq	57e251c0 <strict_strtoul+0x70>
		return -EINVAL;

	val = simple_strtoul(cp, &tail, base);
57e25174:	e1a00004 	mov	r0, r4
57e25178:	e28d1004 	add	r1, sp, #4
57e2517c:	e1a02007 	mov	r2, r7
57e25180:	ebffffc7 	bl	57e250a4 <simple_strtoul>
	if (tail == cp)
57e25184:	e59d3004 	ldr	r3, [sp, #4]
57e25188:	e1530004 	cmp	r3, r4
57e2518c:	0a00000b 	beq	57e251c0 <strict_strtoul+0x70>
		return -EINVAL;

	if ((*tail == '\0') ||
57e25190:	e5d32000 	ldrb	r2, [r3]
57e25194:	e3520000 	cmp	r2, #0
57e25198:	0a000005 	beq	57e251b4 <strict_strtoul+0x64>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
57e2519c:	e0643003 	rsb	r3, r4, r3
57e251a0:	e2833001 	add	r3, r3, #1

	val = simple_strtoul(cp, &tail, base);
	if (tail == cp)
		return -EINVAL;

	if ((*tail == '\0') ||
57e251a4:	e1560003 	cmp	r6, r3
57e251a8:	1a000004 	bne	57e251c0 <strict_strtoul+0x70>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
57e251ac:	e352000a 	cmp	r2, #10
57e251b0:	1a000002 	bne	57e251c0 <strict_strtoul+0x70>
		*res = val;
57e251b4:	e5850000 	str	r0, [r5]
		return 0;
57e251b8:	e3a00000 	mov	r0, #0
57e251bc:	ea000000 	b	57e251c4 <strict_strtoul+0x74>
	}

	return -EINVAL;
57e251c0:	e3e00015 	mvn	r0, #21
}
57e251c4:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

57e251c8 <simple_strtol>:

long simple_strtol(const char *cp, char **endp, unsigned int base)
{
57e251c8:	e92d4010 	push	{r4, lr}
	if (*cp == '-')
57e251cc:	e5d0c000 	ldrb	ip, [r0]
57e251d0:	e35c002d 	cmp	ip, #45	; 0x2d
57e251d4:	1a000003 	bne	57e251e8 <simple_strtol+0x20>
		return -simple_strtoul(cp + 1, endp, base);
57e251d8:	e2800001 	add	r0, r0, #1
57e251dc:	ebffffb0 	bl	57e250a4 <simple_strtoul>

	return simple_strtoul(cp, endp, base);
}
57e251e0:	e2600000 	rsb	r0, r0, #0
57e251e4:	e8bd8010 	pop	{r4, pc}
57e251e8:	e8bd4010 	pop	{r4, lr}
long simple_strtol(const char *cp, char **endp, unsigned int base)
{
	if (*cp == '-')
		return -simple_strtoul(cp + 1, endp, base);

	return simple_strtoul(cp, endp, base);
57e251ec:	eaffffac 	b	57e250a4 <simple_strtoul>

57e251f0 <ustrtoul>:
}

unsigned long ustrtoul(const char *cp, char **endp, unsigned int base)
{
57e251f0:	e92d4010 	push	{r4, lr}
57e251f4:	e1a04001 	mov	r4, r1
	unsigned long result = simple_strtoul(cp, endp, base);
57e251f8:	ebffffa9 	bl	57e250a4 <simple_strtoul>
	switch (**endp) {
57e251fc:	e5943000 	ldr	r3, [r4]
57e25200:	e5d32000 	ldrb	r2, [r3]
57e25204:	e352004b 	cmp	r2, #75	; 0x4b
57e25208:	0a00000a 	beq	57e25238 <ustrtoul+0x48>
57e2520c:	8a000002 	bhi	57e2521c <ustrtoul+0x2c>
57e25210:	e3520047 	cmp	r2, #71	; 0x47
57e25214:	18bd8010 	popne	{r4, pc}
57e25218:	ea000004 	b	57e25230 <ustrtoul+0x40>
57e2521c:	e352004d 	cmp	r2, #77	; 0x4d
57e25220:	0a000003 	beq	57e25234 <ustrtoul+0x44>
57e25224:	e352006b 	cmp	r2, #107	; 0x6b
57e25228:	18bd8010 	popne	{r4, pc}
57e2522c:	ea000001 	b	57e25238 <ustrtoul+0x48>
	case 'G':
		result *= 1024;
57e25230:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'M':
		result *= 1024;
57e25234:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
		if ((*endp)[1] == 'i') {
57e25238:	e5d32001 	ldrb	r2, [r3, #1]
	case 'M':
		result *= 1024;
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
57e2523c:	e1a00500 	lsl	r0, r0, #10
		if ((*endp)[1] == 'i') {
57e25240:	e3520069 	cmp	r2, #105	; 0x69
57e25244:	18bd8010 	popne	{r4, pc}
			if ((*endp)[2] == 'B')
57e25248:	e5d31002 	ldrb	r1, [r3, #2]
57e2524c:	e2832002 	add	r2, r3, #2
57e25250:	e3510042 	cmp	r1, #66	; 0x42
				(*endp) += 3;
57e25254:	02833003 	addeq	r3, r3, #3
57e25258:	05843000 	streq	r3, [r4]
			else
				(*endp) += 2;
57e2525c:	15842000 	strne	r2, [r4]
		}
	}
	return result;
}
57e25260:	e8bd8010 	pop	{r4, pc}

57e25264 <simple_strtoull>:

unsigned long long simple_strtoull(const char *cp, char **endp,
					unsigned int base)
{
57e25264:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	unsigned long long result = 0, value;

	if (*cp == '0') {
57e25268:	e5d03000 	ldrb	r3, [r0]
57e2526c:	e3530030 	cmp	r3, #48	; 0x30
57e25270:	1a00000d 	bne	57e252ac <simple_strtoull+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
57e25274:	e5f03001 	ldrb	r3, [r0, #1]!
57e25278:	e3530078 	cmp	r3, #120	; 0x78
57e2527c:	1a000007 	bne	57e252a0 <simple_strtoull+0x3c>
57e25280:	e5d0c001 	ldrb	ip, [r0, #1]
57e25284:	e59f50b4 	ldr	r5, [pc, #180]	; 57e25340 <simple_strtoull+0xdc>
57e25288:	e2803001 	add	r3, r0, #1
57e2528c:	e7d5c00c 	ldrb	ip, [r5, ip]
57e25290:	e31c0044 	tst	ip, #68	; 0x44
57e25294:	11a00003 	movne	r0, r3
			base = 16;
57e25298:	13a02010 	movne	r2, #16
{
	unsigned long long result = 0, value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
57e2529c:	1a000004 	bne	57e252b4 <simple_strtoull+0x50>
			base = 16;
			cp++;
		}

		if (!base)
			base = 8;
57e252a0:	e3520000 	cmp	r2, #0
57e252a4:	03a02008 	moveq	r2, #8
57e252a8:	ea000001 	b	57e252b4 <simple_strtoull+0x50>
	}

	if (!base)
		base = 10;
57e252ac:	e3520000 	cmp	r2, #0
57e252b0:	03a0200a 	moveq	r2, #10
57e252b4:	e3a03000 	mov	r3, #0
57e252b8:	e3a04000 	mov	r4, #0

	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0'
57e252bc:	e59fa07c 	ldr	sl, [pc, #124]	; 57e25340 <simple_strtoull+0xdc>
		: (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
57e252c0:	e3a07000 	mov	r7, #0
57e252c4:	ea000004 	b	57e252dc <simple_strtoull+0x78>
		result = result * base + value;
57e252c8:	e0865293 	umull	r5, r6, r3, r2
57e252cc:	e0266492 	mla	r6, r2, r4, r6
57e252d0:	e89d0018 	ldm	sp, {r3, r4}
57e252d4:	e0933005 	adds	r3, r3, r5
57e252d8:	e0a44006 	adc	r4, r4, r6
57e252dc:	e1a09000 	mov	r9, r0
	}

	if (!base)
		base = 10;

	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0'
57e252e0:	e4d0c001 	ldrb	ip, [r0], #1
57e252e4:	e7da500c 	ldrb	r5, [sl, ip]
57e252e8:	e3150044 	tst	r5, #68	; 0x44
57e252ec:	0a00000d 	beq	57e25328 <simple_strtoull+0xc4>
57e252f0:	e3150004 	tst	r5, #4
57e252f4:	124cc030 	subne	ip, ip, #48	; 0x30
57e252f8:	1a000003 	bne	57e2530c <simple_strtoull+0xa8>
57e252fc:	e3150002 	tst	r5, #2
57e25300:	124cc020 	subne	ip, ip, #32
		: (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
57e25304:	120cc0ff 	andne	ip, ip, #255	; 0xff
	}

	if (!base)
		base = 10;

	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0'
57e25308:	e24cc037 	sub	ip, ip, #55	; 0x37
57e2530c:	e1a0500c 	mov	r5, ip
57e25310:	e1a06fc5 	asr	r6, r5, #31
57e25314:	e1570006 	cmp	r7, r6
57e25318:	e88d0060 	stm	sp, {r5, r6}
57e2531c:	1a000001 	bne	57e25328 <simple_strtoull+0xc4>
57e25320:	e152000c 	cmp	r2, ip
57e25324:	8affffe7 	bhi	57e252c8 <simple_strtoull+0x64>
		: (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
		result = result * base + value;
		cp++;
	}

	if (endp)
57e25328:	e3510000 	cmp	r1, #0
		*endp = (char *) cp;
57e2532c:	15819000 	strne	r9, [r1]

	return result;
}
57e25330:	e1a00003 	mov	r0, r3
57e25334:	e1a01004 	mov	r1, r4
57e25338:	e28dd00c 	add	sp, sp, #12
57e2533c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
57e25340:	57e2d4d0 	.word	0x57e2d4d0

57e25344 <vsprintf>:
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
57e25344:	eafffdc0 	b	57e24a4c <vsnprintf_internal.clone.6>

57e25348 <sprintf>:
}

int sprintf(char *buf, const char *fmt, ...)
{
57e25348:	e92d000e 	push	{r1, r2, r3}
57e2534c:	e92d4003 	push	{r0, r1, lr}
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
57e25350:	e59d100c 	ldr	r1, [sp, #12]
int sprintf(char *buf, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
57e25354:	e28d2010 	add	r2, sp, #16
57e25358:	e58d2004 	str	r2, [sp, #4]
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
57e2535c:	ebfffdba 	bl	57e24a4c <vsnprintf_internal.clone.6>

	va_start(args, fmt);
	i = vsprintf(buf, fmt, args);
	va_end(args);
	return i;
}
57e25360:	e8bd400c 	pop	{r2, r3, lr}
57e25364:	e28dd00c 	add	sp, sp, #12
57e25368:	e12fff1e 	bx	lr

57e2536c <panic>:

void panic(const char *fmt, ...)
{
57e2536c:	e92d000f 	push	{r0, r1, r2, r3}
57e25370:	e92d4007 	push	{r0, r1, r2, lr}
	va_list args;
	va_start(args, fmt);
	vprintf(fmt, args);
57e25374:	e59d0010 	ldr	r0, [sp, #16]
}

void panic(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
57e25378:	e28d1014 	add	r1, sp, #20
57e2537c:	e58d1004 	str	r1, [sp, #4]
	vprintf(fmt, args);
57e25380:	ebff9045 	bl	57e0949c <vprintf>
	putc('\n');
57e25384:	e3a0000a 	mov	r0, #10
57e25388:	ebff901b 	bl	57e093fc <putc>
	va_end(args);
#if defined(CONFIG_PANIC_HANG)
	hang();
#else
	udelay(100000);	/* allow messages to go out */
57e2538c:	e59f0018 	ldr	r0, [pc, #24]	; 57e253ac <panic+0x40>
57e25390:	ebfffc68 	bl	57e24538 <udelay>
	do_reset(NULL, 0, 0, NULL);
57e25394:	e3a00000 	mov	r0, #0
57e25398:	e1a01000 	mov	r1, r0
57e2539c:	e1a02000 	mov	r2, r0
57e253a0:	e1a03000 	mov	r3, r0
57e253a4:	ebff6ff3 	bl	57e01378 <do_reset>
57e253a8:	eafffffe 	b	57e253a8 <panic+0x3c>
57e253ac:	000186a0 	.word	0x000186a0

57e253b0 <__assert_fail>:
		;
}

void __assert_fail(const char *assertion, const char *file, unsigned line,
		   const char *function)
{
57e253b0:	e92d4007 	push	{r0, r1, r2, lr}
	/* This will not return */
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
57e253b4:	e58d0000 	str	r0, [sp]
57e253b8:	e59f0000 	ldr	r0, [pc, #0]	; 57e253c0 <__assert_fail+0x10>
57e253bc:	ebffffea 	bl	57e2536c <panic>
57e253c0:	57e355c3 	.word	0x57e355c3

57e253c4 <simple_itoa>:
	      assertion);
}

char *simple_itoa(ulong i)
{
57e253c4:	e92d4070 	push	{r4, r5, r6, lr}
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
57e253c8:	e59f4048 	ldr	r4, [pc, #72]	; 57e25418 <simple_itoa+0x54>
57e253cc:	e3a03000 	mov	r3, #0
57e253d0:	e5c43015 	strb	r3, [r4, #21]
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
	      assertion);
}

char *simple_itoa(ulong i)
{
57e253d4:	e1a05000 	mov	r5, r0
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
57e253d8:	e2844014 	add	r4, r4, #20
57e253dc:	ea000000 	b	57e253e4 <simple_itoa+0x20>
	do {
		*p-- = '0' + i % 10;
57e253e0:	e1a04006 	mov	r4, r6
57e253e4:	e1a00005 	mov	r0, r5
57e253e8:	e3a0100a 	mov	r1, #10
57e253ec:	eb00196a 	bl	57e2b99c <__aeabi_uidivmod>
57e253f0:	e1a06004 	mov	r6, r4
57e253f4:	e2811030 	add	r1, r1, #48	; 0x30
57e253f8:	e4461001 	strb	r1, [r6], #-1
		i /= 10;
57e253fc:	e1a00005 	mov	r0, r5
57e25400:	e3a0100a 	mov	r1, #10
57e25404:	eb0018e9 	bl	57e2b7b0 <__udivsi3>
	} while (i > 0);
57e25408:	e2505000 	subs	r5, r0, #0
57e2540c:	1afffff3 	bne	57e253e0 <simple_itoa+0x1c>
	return p + 1;
}
57e25410:	e1a00004 	mov	r0, r4
57e25414:	e8bd8070 	pop	{r4, r5, r6, pc}
57e25418:	57e790a0 	.word	0x57e790a0

57e2541c <zcfree>:
		(voidpf)calloc(items, size);
}

void  zcfree(voidpf opaque, voidpf ptr, unsigned nb)
{
	free(ptr);
57e2541c:	e1a00001 	mov	r0, r1
57e25420:	eaff915d 	b	57e0999c <free>

57e25424 <zcalloc>:

voidpf zcalloc(voidpf opaque, unsigned items, unsigned size)
{
	if (opaque)
		items += size - size; /* make compiler happy */
	return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
57e25424:	e0000291 	mul	r0, r1, r2
57e25428:	eaff91e5 	b	57e09bc4 <malloc>

57e2542c <inflate_fast>:
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void inflate_fast(z_streamp strm, unsigned start)
/* start: inflate()'s starting value for strm->avail_out */
{
57e2542c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
57e25430:	e5903004 	ldr	r3, [r0, #4]
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
57e25434:	e5904000 	ldr	r4, [r0]
    last = in + (strm->avail_in - 5);
57e25438:	e2432005 	sub	r2, r3, #5
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
57e2543c:	e2444001 	sub	r4, r4, #1
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void inflate_fast(z_streamp strm, unsigned start)
/* start: inflate()'s starting value for strm->avail_out */
{
57e25440:	e24dd048 	sub	sp, sp, #72	; 0x48

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
57e25444:	e0942002 	adds	r2, r4, r2
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
57e25448:	e590501c 	ldr	r5, [r0, #28]
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
57e2544c:	e58d201c 	str	r2, [sp, #28]
57e25450:	3a000005 	bcc	57e2546c <inflate_fast+0x40>
57e25454:	e3530005 	cmp	r3, #5
        /*
         * overflow detected, limit strm->avail_in to the
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
57e25458:	81e03004 	mvnhi	r3, r4
57e2545c:	85803004 	strhi	r3, [r0, #4]
        last = in + (strm->avail_in - 5);
57e25460:	82433005 	subhi	r3, r3, #5
57e25464:	80843003 	addhi	r3, r4, r3
57e25468:	858d301c 	strhi	r3, [sp, #28]
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
57e2546c:	e595602c 	ldr	r6, [r5, #44]	; 0x2c
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
57e25470:	e595c050 	ldr	ip, [r5, #80]	; 0x50
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
57e25474:	e58d6038 	str	r6, [sp, #56]	; 0x38
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
57e25478:	e5956054 	ldr	r6, [r5, #84]	; 0x54
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
57e2547c:	e58dc024 	str	ip, [sp, #36]	; 0x24
    lmask = (1U << state->lenbits) - 1;
57e25480:	e3a0c001 	mov	ip, #1
57e25484:	e1a0661c 	lsl	r6, ip, r6
57e25488:	e2466001 	sub	r6, r6, #1
57e2548c:	e58d603c 	str	r6, [sp, #60]	; 0x3c
    dmask = (1U << state->distbits) - 1;
57e25490:	e5956058 	ldr	r6, [r5, #88]	; 0x58
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
57e25494:	e5902010 	ldr	r2, [r0, #16]
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
57e25498:	e1a0661c 	lsl	r6, ip, r6
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
57e2549c:	e590300c 	ldr	r3, [r0, #12]
    beg = out - (start - strm->avail_out);
57e254a0:	e0611002 	rsb	r1, r1, r2
    end = out + (strm->avail_out - 257);
57e254a4:	e2422c01 	sub	r2, r2, #256	; 0x100
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
57e254a8:	e2433001 	sub	r3, r3, #1
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
57e254ac:	e2422001 	sub	r2, r2, #1
57e254b0:	e0832002 	add	r2, r3, r2
57e254b4:	e58d2028 	str	r2, [sp, #40]	; 0x28
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
57e254b8:	e5952028 	ldr	r2, [r5, #40]	; 0x28
    whave = state->whave;
    write = state->write;
    window = state->window;
57e254bc:	e5959034 	ldr	r9, [r5, #52]	; 0x34
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
57e254c0:	e58d202c 	str	r2, [sp, #44]	; 0x2c
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
57e254c4:	e2466001 	sub	r6, r6, #1
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
57e254c8:	e5957030 	ldr	r7, [r5, #48]	; 0x30
    window = state->window;
57e254cc:	e58d9030 	str	r9, [sp, #48]	; 0x30
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
57e254d0:	e58d6040 	str	r6, [sp, #64]	; 0x40
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
57e254d4:	e2496001 	sub	r6, r9, #1
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
57e254d8:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
57e254dc:	e0831001 	add	r1, r3, r1
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
57e254e0:	e595a04c 	ldr	sl, [r5, #76]	; 0x4c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
57e254e4:	e58d1034 	str	r1, [sp, #52]	; 0x34
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
57e254e8:	e0879009 	add	r9, r7, r9
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
57e254ec:	e5951038 	ldr	r1, [r5, #56]	; 0x38
    bits = state->bits;
57e254f0:	e595203c 	ldr	r2, [r5, #60]	; 0x3c
    lcode = state->lencode;
57e254f4:	e58da020 	str	sl, [sp, #32]
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
57e254f8:	e58d600c 	str	r6, [sp, #12]
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
57e254fc:	e58d9044 	str	r9, [sp, #68]	; 0x44
57e25500:	e58d5010 	str	r5, [sp, #16]
57e25504:	e58d0014 	str	r0, [sp, #20]
    dmask = (1U << state->distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
57e25508:	e352000e 	cmp	r2, #14
57e2550c:	8a000007 	bhi	57e25530 <inflate_fast+0x104>
            hold += (unsigned long)(PUP(in)) << bits;
57e25510:	e5d4c001 	ldrb	ip, [r4, #1]
57e25514:	e2840001 	add	r0, r4, #1
57e25518:	e081121c 	add	r1, r1, ip, lsl r2
            bits += 8;
            hold += (unsigned long)(PUP(in)) << bits;
57e2551c:	e2804001 	add	r4, r0, #1
57e25520:	e5d00001 	ldrb	r0, [r0, #1]
    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
57e25524:	e2822008 	add	r2, r2, #8
            hold += (unsigned long)(PUP(in)) << bits;
57e25528:	e0811210 	add	r1, r1, r0, lsl r2
            bits += 8;
57e2552c:	e2822008 	add	r2, r2, #8
        }
        this = lcode[hold & lmask];
57e25530:	e59da03c 	ldr	sl, [sp, #60]	; 0x3c
57e25534:	e59d5020 	ldr	r5, [sp, #32]
57e25538:	e001000a 	and	r0, r1, sl
57e2553c:	e085c100 	add	ip, r5, r0, lsl #2
57e25540:	e7d56100 	ldrb	r6, [r5, r0, lsl #2]
57e25544:	e5dc0001 	ldrb	r0, [ip, #1]
57e25548:	e1dcc0b2 	ldrh	ip, [ip, #2]
57e2554c:	e1a0a005 	mov	sl, r5
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
        bits -= op;
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
57e25550:	e3560000 	cmp	r6, #0
            bits += 8;
        }
        this = lcode[hold & lmask];
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
57e25554:	e1a01031 	lsr	r1, r1, r0
        bits -= op;
57e25558:	e0602002 	rsb	r2, r0, r2
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
57e2555c:	05e3c001 	strbeq	ip, [r3, #1]!
57e25560:	0a0000ed 	beq	57e2591c <inflate_fast+0x4f0>
        }
        else if (op & 16) {                     /* length base */
57e25564:	e3160010 	tst	r6, #16
57e25568:	0a0000d8 	beq	57e258d0 <inflate_fast+0x4a4>
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
57e2556c:	e216600f 	ands	r6, r6, #15
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
        }
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
57e25570:	e1a0000c 	mov	r0, ip
            op &= 15;                           /* number of extra bits */
            if (op) {
57e25574:	0a00000a 	beq	57e255a4 <inflate_fast+0x178>
                if (bits < op) {
57e25578:	e1520006 	cmp	r2, r6
                    hold += (unsigned long)(PUP(in)) << bits;
57e2557c:	35f40001 	ldrbcc	r0, [r4, #1]!
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
57e25580:	e3a09001 	mov	r9, #1
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
57e25584:	30811210 	addcc	r1, r1, r0, lsl r2
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
57e25588:	e1a00619 	lsl	r0, r9, r6
57e2558c:	e2400001 	sub	r0, r0, #1
57e25590:	e0010000 	and	r0, r1, r0
                hold >>= op;
57e25594:	e1a01631 	lsr	r1, r1, r6
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
57e25598:	32822008 	addcc	r2, r2, #8
                }
                len += (unsigned)hold & ((1U << op) - 1);
57e2559c:	e08c0000 	add	r0, ip, r0
                hold >>= op;
                bits -= op;
57e255a0:	e0662002 	rsb	r2, r6, r2
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
57e255a4:	e352000e 	cmp	r2, #14
57e255a8:	8a000007 	bhi	57e255cc <inflate_fast+0x1a0>
                hold += (unsigned long)(PUP(in)) << bits;
57e255ac:	e284c001 	add	ip, r4, #1
57e255b0:	e5d44001 	ldrb	r4, [r4, #1]
57e255b4:	e0811214 	add	r1, r1, r4, lsl r2
                bits += 8;
                hold += (unsigned long)(PUP(in)) << bits;
57e255b8:	e28c4001 	add	r4, ip, #1
57e255bc:	e5dcc001 	ldrb	ip, [ip, #1]
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
57e255c0:	e2822008 	add	r2, r2, #8
                hold += (unsigned long)(PUP(in)) << bits;
57e255c4:	e081121c 	add	r1, r1, ip, lsl r2
                bits += 8;
57e255c8:	e2822008 	add	r2, r2, #8
            }
            this = dcode[hold & dmask];
57e255cc:	e59da040 	ldr	sl, [sp, #64]	; 0x40
57e255d0:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
57e255d4:	e001c00a 	and	ip, r1, sl
57e255d8:	e085610c 	add	r6, r5, ip, lsl #2
57e255dc:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
57e255e0:	e7d5c10c 	ldrb	ip, [r5, ip, lsl #2]
57e255e4:	e5d65001 	ldrb	r5, [r6, #1]
57e255e8:	e1d660b2 	ldrh	r6, [r6, #2]
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
            bits -= op;
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
57e255ec:	e31c0010 	tst	ip, #16
                bits += 8;
            }
            this = dcode[hold & dmask];
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
57e255f0:	e1a01531 	lsr	r1, r1, r5
            bits -= op;
57e255f4:	e0652002 	rsb	r2, r5, r2
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
57e255f8:	0a0000a1 	beq	57e25884 <inflate_fast+0x458>
                dist = (unsigned)(this.val);
                op &= 15;                       /* number of extra bits */
57e255fc:	e20cc00f 	and	ip, ip, #15
                if (bits < op) {
57e25600:	e152000c 	cmp	r2, ip
57e25604:	2a000006 	bcs	57e25624 <inflate_fast+0x1f8>
                    hold += (unsigned long)(PUP(in)) << bits;
57e25608:	e5f45001 	ldrb	r5, [r4, #1]!
57e2560c:	e0811215 	add	r1, r1, r5, lsl r2
                    bits += 8;
57e25610:	e2822008 	add	r2, r2, #8
                    if (bits < op) {
57e25614:	e152000c 	cmp	r2, ip
                        hold += (unsigned long)(PUP(in)) << bits;
57e25618:	35f45001 	ldrbcc	r5, [r4, #1]!
57e2561c:	30811215 	addcc	r1, r1, r5, lsl r2
                        bits += 8;
57e25620:	32822008 	addcc	r2, r2, #8
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
57e25624:	e3a09001 	mov	r9, #1
57e25628:	e1a05c19 	lsl	r5, r9, ip
                }
#endif
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
57e2562c:	e59da034 	ldr	sl, [sp, #52]	; 0x34
                    if (bits < op) {
                        hold += (unsigned long)(PUP(in)) << bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
57e25630:	e2455001 	sub	r5, r5, #1
57e25634:	e0015005 	and	r5, r1, r5
57e25638:	e0855006 	add	r5, r5, r6
                    strm->msg = (char *)"invalid distance too far back";
                    state->mode = BAD;
                    break;
                }
#endif
                hold >>= op;
57e2563c:	e1a01c31 	lsr	r1, r1, ip
                bits -= op;
57e25640:	e06c2002 	rsb	r2, ip, r2
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
57e25644:	e06ac003 	rsb	ip, sl, r3
                if (dist > op) {                /* see if copy from window */
57e25648:	e155000c 	cmp	r5, ip
57e2564c:	9a000062 	bls	57e257dc <inflate_fast+0x3b0>
                    op = dist - op;             /* distance back in window */
                    if (op > whave) {
57e25650:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
57e25654:	e06cc005 	rsb	ip, ip, r5
                    if (op > whave) {
57e25658:	e15c0006 	cmp	ip, r6
57e2565c:	859d5010 	ldrhi	r5, [sp, #16]
57e25660:	859d0014 	ldrhi	r0, [sp, #20]
                        strm->msg = (char *)"invalid distance too far back";
57e25664:	859fc328 	ldrhi	ip, [pc, #808]	; 57e25994 <inflate_fast+0x568>
57e25668:	8a000094 	bhi	57e258c0 <inflate_fast+0x494>
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
57e2566c:	e3570000 	cmp	r7, #0
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
57e25670:	e59da00c 	ldr	sl, [sp, #12]
                    if (write == 0) {           /* very common case */
57e25674:	1a000010 	bne	57e256bc <inflate_fast+0x290>
                        from += wsize - op;
57e25678:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
57e2567c:	e59d600c 	ldr	r6, [sp, #12]
57e25680:	e06ca009 	rsb	sl, ip, r9
                        if (op < len) {         /* some from window */
57e25684:	e15c0000 	cmp	ip, r0
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
57e25688:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
57e2568c:	2a000008 	bcs	57e256b4 <inflate_fast+0x288>
                            len -= op;
57e25690:	e06c0000 	rsb	r0, ip, r0
57e25694:	e1a06003 	mov	r6, r3
57e25698:	e1a0b00c 	mov	fp, ip
57e2569c:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
57e256a0:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
57e256a4:	e25bb001 	subs	fp, fp, #1
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
57e256a8:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
57e256ac:	1afffffb 	bne	57e256a0 <inflate_fast+0x274>
57e256b0:	ea000033 	b	57e25784 <inflate_fast+0x358>
                            from = out - dist;  /* rest from output */
57e256b4:	e1a0c003 	mov	ip, r3
57e256b8:	ea00003b 	b	57e257ac <inflate_fast+0x380>
                        }
                    }
                    else if (write < op) {      /* wrap around window */
57e256bc:	e157000c 	cmp	r7, ip
57e256c0:	2a000022 	bcs	57e25750 <inflate_fast+0x324>
                        from += wsize + write - op;
57e256c4:	e59d9044 	ldr	r9, [sp, #68]	; 0x44
57e256c8:	e59d600c 	ldr	r6, [sp, #12]
57e256cc:	e06cb009 	rsb	fp, ip, r9
                        op -= write;
57e256d0:	e067c00c 	rsb	ip, r7, ip
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
57e256d4:	e086b00b 	add	fp, r6, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
57e256d8:	e15c0000 	cmp	ip, r0
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
57e256dc:	21a0a00b 	movcs	sl, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
57e256e0:	2afffff3 	bcs	57e256b4 <inflate_fast+0x288>
                            len -= op;
57e256e4:	e06c0000 	rsb	r0, ip, r0
57e256e8:	e58d3018 	str	r3, [sp, #24]
57e256ec:	e1a0600c 	mov	r6, ip
57e256f0:	e1a09004 	mov	r9, r4
57e256f4:	e58d3004 	str	r3, [sp, #4]
                            do {
                                PUP(out) = PUP(from);
57e256f8:	e5fb4001 	ldrb	r4, [fp, #1]!
57e256fc:	e59d3018 	ldr	r3, [sp, #24]
                            } while (--op);
57e25700:	e2566001 	subs	r6, r6, #1
                        from += wsize + write - op;
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
57e25704:	e5e34001 	strb	r4, [r3, #1]!
57e25708:	e58d3018 	str	r3, [sp, #24]
                            } while (--op);
57e2570c:	1afffff9 	bne	57e256f8 <inflate_fast+0x2cc>
57e25710:	e59d3004 	ldr	r3, [sp, #4]
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
57e25714:	e1570000 	cmp	r7, r0
57e25718:	e1a04009 	mov	r4, r9
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
57e2571c:	e083300c 	add	r3, r3, ip
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
57e25720:	2affffe3 	bcs	57e256b4 <inflate_fast+0x288>
                                op = write;
                                len -= op;
57e25724:	e0670000 	rsb	r0, r7, r0
57e25728:	e1a0c003 	mov	ip, r3
                                do {
                                    PUP(out) = PUP(from);
57e2572c:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
57e25730:	e7d9a006 	ldrb	sl, [r9, r6]
57e25734:	e2866001 	add	r6, r6, #1
                                } while (--op);
57e25738:	e1570006 	cmp	r7, r6
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
                                op = write;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
57e2573c:	e5eca001 	strb	sl, [ip, #1]!
                                } while (--op);
57e25740:	1afffff9 	bne	57e2572c <inflate_fast+0x300>
57e25744:	e0833007 	add	r3, r3, r7
                                from = out - dist;      /* rest from output */
57e25748:	e065a003 	rsb	sl, r5, r3
57e2574c:	eaffffd8 	b	57e256b4 <inflate_fast+0x288>
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
57e25750:	e59d600c 	ldr	r6, [sp, #12]
57e25754:	e06ca007 	rsb	sl, ip, r7
                        if (op < len) {         /* some from window */
57e25758:	e15c0000 	cmp	ip, r0
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
57e2575c:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
57e25760:	2affffd3 	bcs	57e256b4 <inflate_fast+0x288>
                            len -= op;
57e25764:	e06c0000 	rsb	r0, ip, r0
57e25768:	e1a06003 	mov	r6, r3
57e2576c:	e1a0b00c 	mov	fp, ip
57e25770:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
57e25774:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
57e25778:	e25bb001 	subs	fp, fp, #1
                    else {                      /* contiguous in window */
                        from += write - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
57e2577c:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
57e25780:	1afffffb 	bne	57e25774 <inflate_fast+0x348>
57e25784:	e1a04009 	mov	r4, r9
57e25788:	e083300c 	add	r3, r3, ip
57e2578c:	eaffffed 	b	57e25748 <inflate_fast+0x31c>
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
57e25790:	e5da3001 	ldrb	r3, [sl, #1]
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
57e25794:	e2400003 	sub	r0, r0, #3
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
57e25798:	e5cc3001 	strb	r3, [ip, #1]
                        PUP(out) = PUP(from);
57e2579c:	e5da3002 	ldrb	r3, [sl, #2]
57e257a0:	e5cc3002 	strb	r3, [ip, #2]
                        PUP(out) = PUP(from);
57e257a4:	e5fa3003 	ldrb	r3, [sl, #3]!
57e257a8:	e5ec3003 	strb	r3, [ip, #3]!
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
57e257ac:	e3500002 	cmp	r0, #2
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
57e257b0:	e1a0300c 	mov	r3, ip
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
57e257b4:	8afffff5 	bhi	57e25790 <inflate_fast+0x364>
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
57e257b8:	e3500000 	cmp	r0, #0
57e257bc:	0a000056 	beq	57e2591c <inflate_fast+0x4f0>
                        PUP(out) = PUP(from);
57e257c0:	e5da5001 	ldrb	r5, [sl, #1]
57e257c4:	e28ac001 	add	ip, sl, #1
57e257c8:	e5e35001 	strb	r5, [r3, #1]!
                        if (len > 1)
57e257cc:	e3500002 	cmp	r0, #2
                            PUP(out) = PUP(from);
57e257d0:	05dc0001 	ldrbeq	r0, [ip, #1]
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
57e257d4:	0a000028 	beq	57e2587c <inflate_fast+0x450>
57e257d8:	ea00004f 	b	57e2591c <inflate_fast+0x4f0>
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
57e257dc:	e3130001 	tst	r3, #1
                }
                else {
		    unsigned short *sout;
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
57e257e0:	e0656003 	rsb	r6, r5, r3
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
57e257e4:	05f6c001 	ldrbeq	ip, [r6, #1]!
			len--;
57e257e8:	02400001 	subeq	r0, r0, #1

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
57e257ec:	05e3c001 	strbeq	ip, [r3, #1]!
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
57e257f0:	e3550002 	cmp	r5, #2
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
57e257f4:	e243c001 	sub	ip, r3, #1
		    if (dist > 2 ) {
57e257f8:	9a000010 	bls	57e25840 <inflate_fast+0x414>
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
57e257fc:	e2469001 	sub	r9, r6, #1
			loops = len >> 1;
57e25800:	e1a030a0 	lsr	r3, r0, #1
57e25804:	e1a05006 	mov	r5, r6
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
57e25808:	e58d9018 	str	r9, [sp, #24]
			loops = len >> 1;
57e2580c:	e1a0a00c 	mov	sl, ip
57e25810:	e1a06003 	mov	r6, r3

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
57e25814:	e5d5b002 	ldrb	fp, [r5, #2]
57e25818:	e5d59001 	ldrb	r9, [r5, #1]
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
57e2581c:	e2566001 	subs	r6, r6, #1
57e25820:	e189940b 	orr	r9, r9, fp, lsl #8
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
57e25824:	e1ea90b2 	strh	r9, [sl, #2]!
			while (--loops);
57e25828:	e2855002 	add	r5, r5, #2
57e2582c:	1afffff8 	bne	57e25814 <inflate_fast+0x3e8>
    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void inflate_fast(z_streamp strm, unsigned start)
57e25830:	e59da018 	ldr	sl, [sp, #24]
57e25834:	e08a6083 	add	r6, sl, r3, lsl #1

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
57e25838:	e2866001 	add	r6, r6, #1
57e2583c:	ea000009 	b	57e25868 <inflate_fast+0x43c>
			out = (unsigned char *)sout + OFF;
			from = (unsigned char *)sfrom + OFF;
		    } else { /* dist == 1 or dist == 2 */
			unsigned short pat16;

			pat16 = *(sout-2+2*OFF);
57e25840:	e153a0b1 	ldrh	sl, [r3, #-1]
			if (dist == 1)
57e25844:	e3550001 	cmp	r5, #1
#if defined(__BIG_ENDIAN)
			    pat16 = (pat16 & 0xff) | ((pat16 & 0xff ) << 8);
#elif defined(__LITTLE_ENDIAN)
			    pat16 = (pat16 & 0xff00) | ((pat16 & 0xff00 ) >> 8);
57e25848:	03ca30ff 	biceq	r3, sl, #255	; 0xff
57e2584c:	0183a42a 	orreq	sl, r3, sl, lsr #8
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
57e25850:	e1a030a0 	lsr	r3, r0, #1
57e25854:	e1a0900c 	mov	r9, ip
57e25858:	e1a05003 	mov	r5, r3
			do
			    PUP(sout) = pat16;
			while (--loops);
57e2585c:	e2555001 	subs	r5, r5, #1
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
57e25860:	e1e9a0b2 	strh	sl, [r9, #2]!
			while (--loops);
57e25864:	1afffffc 	bne	57e2585c <inflate_fast+0x430>
			out = (unsigned char *)sout + OFF;
57e25868:	e08c3083 	add	r3, ip, r3, lsl #1
		    }
		    if (len & 1)
57e2586c:	e3100001 	tst	r0, #1
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
			while (--loops);
			out = (unsigned char *)sout + OFF;
57e25870:	e2833001 	add	r3, r3, #1
		    }
		    if (len & 1)
57e25874:	0a000028 	beq	57e2591c <inflate_fast+0x4f0>
			PUP(out) = PUP(from);
57e25878:	e5d60001 	ldrb	r0, [r6, #1]
57e2587c:	e5e30001 	strb	r0, [r3, #1]!
57e25880:	ea000025 	b	57e2591c <inflate_fast+0x4f0>
                }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
57e25884:	e31c0040 	tst	ip, #64	; 0x40
57e25888:	1a000009 	bne	57e258b4 <inflate_fast+0x488>
                this = dcode[this.val + (hold & ((1U << op) - 1))];
57e2588c:	e3a05001 	mov	r5, #1
57e25890:	e1a0cc15 	lsl	ip, r5, ip
57e25894:	e24cc001 	sub	ip, ip, #1
57e25898:	e00cc001 	and	ip, ip, r1
57e2589c:	e08c6006 	add	r6, ip, r6
57e258a0:	e089a106 	add	sl, r9, r6, lsl #2
57e258a4:	e7d9c106 	ldrb	ip, [r9, r6, lsl #2]
57e258a8:	e5da5001 	ldrb	r5, [sl, #1]
57e258ac:	e1da60b2 	ldrh	r6, [sl, #2]
                goto dodist;
57e258b0:	eaffff4d 	b	57e255ec <inflate_fast+0x1c0>
57e258b4:	e59d5010 	ldr	r5, [sp, #16]
57e258b8:	e59d0014 	ldr	r0, [sp, #20]
            }
            else {
                strm->msg = (char *)"invalid distance code";
57e258bc:	e59fc0d4 	ldr	ip, [pc, #212]	; 57e25998 <inflate_fast+0x56c>
57e258c0:	e580c018 	str	ip, [r0, #24]
                state->mode = BAD;
57e258c4:	e3a0c01b 	mov	ip, #27
57e258c8:	e585c000 	str	ip, [r5]
                break;
57e258cc:	ea000019 	b	57e25938 <inflate_fast+0x50c>
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
57e258d0:	e3160040 	tst	r6, #64	; 0x40
57e258d4:	1a000009 	bne	57e25900 <inflate_fast+0x4d4>
            this = lcode[this.val + (hold & ((1U << op) - 1))];
57e258d8:	e3a09001 	mov	r9, #1
57e258dc:	e1a06619 	lsl	r6, r9, r6
57e258e0:	e2466001 	sub	r6, r6, #1
57e258e4:	e0066001 	and	r6, r6, r1
57e258e8:	e086c00c 	add	ip, r6, ip
57e258ec:	e08a510c 	add	r5, sl, ip, lsl #2
57e258f0:	e7da610c 	ldrb	r6, [sl, ip, lsl #2]
57e258f4:	e5d50001 	ldrb	r0, [r5, #1]
57e258f8:	e1d5c0b2 	ldrh	ip, [r5, #2]
            goto dolen;
57e258fc:	eaffff13 	b	57e25550 <inflate_fast+0x124>
        }
        else if (op & 32) {                     /* end-of-block */
57e25900:	e3160020 	tst	r6, #32
57e25904:	e59d5010 	ldr	r5, [sp, #16]
57e25908:	e59d0014 	ldr	r0, [sp, #20]
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
57e2590c:	13a0c00b 	movne	ip, #11
            break;
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
57e25910:	059fc084 	ldreq	ip, [pc, #132]	; 57e2599c <inflate_fast+0x570>
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            this = lcode[this.val + (hold & ((1U << op) - 1))];
            goto dolen;
        }
        else if (op & 32) {                     /* end-of-block */
57e25914:	0affffe9 	beq	57e258c0 <inflate_fast+0x494>
57e25918:	eaffffea 	b	57e258c8 <inflate_fast+0x49c>
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);
57e2591c:	e59da028 	ldr	sl, [sp, #40]	; 0x28
57e25920:	e59dc01c 	ldr	ip, [sp, #28]
57e25924:	e153000a 	cmp	r3, sl
57e25928:	3154000c 	cmpcc	r4, ip
57e2592c:	3afffef5 	bcc	57e25508 <inflate_fast+0xdc>
57e25930:	e59d5010 	ldr	r5, [sp, #16]
57e25934:	e59d0014 	ldr	r0, [sp, #20]

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
57e25938:	e1a0c1a2 	lsr	ip, r2, #3
    in -= len;
57e2593c:	e06c4004 	rsb	r4, ip, r4
    bits -= len << 3;
57e25940:	e1a0c18c 	lsl	ip, ip, #3
57e25944:	e06c2002 	rsb	r2, ip, r2
    hold &= (1U << bits) - 1;
57e25948:	e3e0c000 	mvn	ip, #0
57e2594c:	e1c1121c 	bic	r1, r1, ip, lsl r2
57e25950:	e59d601c 	ldr	r6, [sp, #28]

    /* update state and return */
    strm->next_in = in + OFF;
57e25954:	e284c001 	add	ip, r4, #1
57e25958:	e580c000 	str	ip, [r0]
57e2595c:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
    strm->next_out = out + OFF;
57e25960:	e283c001 	add	ip, r3, #1
57e25964:	e580c00c 	str	ip, [r0, #12]
57e25968:	e286c005 	add	ip, r6, #5
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
57e2596c:	e064400c 	rsb	r4, r4, ip
57e25970:	e289cc01 	add	ip, r9, #256	; 0x100
57e25974:	e28cc001 	add	ip, ip, #1
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
57e25978:	e063300c 	rsb	r3, r3, ip
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
    strm->next_out = out + OFF;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
57e2597c:	e5804004 	str	r4, [r0, #4]
    strm->avail_out = (unsigned)(out < end ?
57e25980:	e5803010 	str	r3, [r0, #16]
                                 257 + (end - out) : 257 - (out - end));
    state->hold = hold;
57e25984:	e5851038 	str	r1, [r5, #56]	; 0x38
    state->bits = bits;
57e25988:	e585203c 	str	r2, [r5, #60]	; 0x3c
    return;
}
57e2598c:	e28dd048 	add	sp, sp, #72	; 0x48
57e25990:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e25994:	57e355e5 	.word	0x57e355e5
57e25998:	57e35603 	.word	0x57e35603
57e2599c:	57e35619 	.word	0x57e35619

57e259a0 <inflate_table>:
   longest code or if it is less than the shortest code.
 */
int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
		  code FAR * FAR *table, unsigned FAR *bits,
		  unsigned short FAR *work)
{
57e259a0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
57e259a4:	e24dd088 	sub	sp, sp, #136	; 0x88
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
57e259a8:	e28d4068 	add	r4, sp, #104	; 0x68
   longest code or if it is less than the shortest code.
 */
int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
		  code FAR * FAR *table, unsigned FAR *bits,
		  unsigned short FAR *work)
{
57e259ac:	e58d1030 	str	r1, [sp, #48]	; 0x30
57e259b0:	e59d10ac 	ldr	r1, [sp, #172]	; 0xac
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
57e259b4:	e28dc066 	add	ip, sp, #102	; 0x66
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
57e259b8:	e1a05004 	mov	r5, r4
57e259bc:	e284701e 	add	r7, r4, #30
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
57e259c0:	e3a06000 	mov	r6, #0
57e259c4:	e1ec60b2 	strh	r6, [ip, #2]!
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
57e259c8:	e15c0007 	cmp	ip, r7
57e259cc:	1afffffb 	bne	57e259c0 <inflate_table+0x20>
57e259d0:	e59db030 	ldr	fp, [sp, #48]	; 0x30
57e259d4:	e3a0c000 	mov	ip, #0
57e259d8:	e1a0600b 	mov	r6, fp
57e259dc:	ea000006 	b	57e259fc <inflate_table+0x5c>
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;
57e259e0:	e0d690b2 	ldrh	r9, [r6], #2
57e259e4:	e28da088 	add	sl, sp, #136	; 0x88
57e259e8:	e08a9089 	add	r9, sl, r9, lsl #1
57e259ec:	e159a2b0 	ldrh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
57e259f0:	e28cc001 	add	ip, ip, #1
        count[lens[sym]]++;
57e259f4:	e28aa001 	add	sl, sl, #1
57e259f8:	e149a2b0 	strh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
57e259fc:	e15c0002 	cmp	ip, r2
57e25a00:	3afffff6 	bcc	57e259e0 <inflate_table+0x40>
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
57e25a04:	e59d60a8 	ldr	r6, [sp, #168]	; 0xa8
57e25a08:	e28da088 	add	sl, sp, #136	; 0x88
57e25a0c:	e596c000 	ldr	ip, [r6]
    for (max = MAXBITS; max >= 1; max--)
57e25a10:	e3a0600f 	mov	r6, #15
        if (count[max] != 0) break;
57e25a14:	e17a90b2 	ldrh	r9, [sl, #-2]!
57e25a18:	e3590000 	cmp	r9, #0
57e25a1c:	0a000004 	beq	57e25a34 <inflate_table+0x94>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
57e25a20:	e3560000 	cmp	r6, #0
57e25a24:	11a0a004 	movne	sl, r4
57e25a28:	13a04001 	movne	r4, #1
57e25a2c:	1a000013 	bne	57e25a80 <inflate_table+0xe0>
57e25a30:	ea000001 	b	57e25a3c <inflate_table+0x9c>
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
57e25a34:	e2566001 	subs	r6, r6, #1
57e25a38:	1afffff5 	bne	57e25a14 <inflate_table+0x74>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
57e25a3c:	e5932000 	ldr	r2, [r3]
57e25a40:	e3a01001 	mov	r1, #1
57e25a44:	e2820004 	add	r0, r2, #4
57e25a48:	e3a0c040 	mov	ip, #64	; 0x40
57e25a4c:	e5c21001 	strb	r1, [r2, #1]
57e25a50:	e5c2c000 	strb	ip, [r2]
57e25a54:	e5c01001 	strb	r1, [r0, #1]
57e25a58:	e5c2c004 	strb	ip, [r2, #4]
57e25a5c:	e3a07000 	mov	r7, #0
        *(*table)++ = this;
        *bits = 1;
57e25a60:	e59d90a8 	ldr	r9, [sp, #168]	; 0xa8
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
57e25a64:	e1c270b2 	strh	r7, [r2, #2]
57e25a68:	e1c070b2 	strh	r7, [r0, #2]
        *(*table)++ = this;
57e25a6c:	e2800004 	add	r0, r0, #4
57e25a70:	e5830000 	str	r0, [r3]
        *bits = 1;
57e25a74:	e5891000 	str	r1, [r9]
        return 0;     /* no symbols, but wait for decoding to report error */
57e25a78:	e3a00000 	mov	r0, #0
57e25a7c:	ea00011f 	b	57e25f00 <inflate_table+0x560>
    }
    for (min = 1; min <= MAXBITS; min++)
        if (count[min] != 0) break;
57e25a80:	e1fa90b2 	ldrh	r9, [sl, #2]!
57e25a84:	e3590000 	cmp	r9, #0
57e25a88:	1a000004 	bne	57e25aa0 <inflate_table+0x100>
        *(*table)++ = this;             /* make a table to force an error */
        *(*table)++ = this;
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min <= MAXBITS; min++)
57e25a8c:	e2844001 	add	r4, r4, #1
57e25a90:	e3540010 	cmp	r4, #16
57e25a94:	1afffff9 	bne	57e25a80 <inflate_table+0xe0>
57e25a98:	e1a0c004 	mov	ip, r4
57e25a9c:	ea000003 	b	57e25ab0 <inflate_table+0x110>
57e25aa0:	e156000c 	cmp	r6, ip
57e25aa4:	31a0c006 	movcc	ip, r6
        if (count[min] != 0) break;
    if (root < min) root = min;
57e25aa8:	e15c0004 	cmp	ip, r4
57e25aac:	31a0c004 	movcc	ip, r4

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
57e25ab0:	e3a09001 	mov	r9, #1
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
57e25ab4:	e1a0a089 	lsl	sl, r9, #1
        left -= count[len];
57e25ab8:	e1f590b2 	ldrh	r9, [r5, #2]!
        if (left < 0) return -1;        /* over-subscribed */
57e25abc:	e05a9009 	subs	r9, sl, r9
57e25ac0:	4a00010b 	bmi	57e25ef4 <inflate_table+0x554>
        if (count[min] != 0) break;
    if (root < min) root = min;

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
57e25ac4:	e1550007 	cmp	r5, r7
57e25ac8:	1afffff9 	bne	57e25ab4 <inflate_table+0x114>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
57e25acc:	e3590000 	cmp	r9, #0
57e25ad0:	0a000005 	beq	57e25aec <inflate_table+0x14c>
57e25ad4:	e2705001 	rsbs	r5, r0, #1
57e25ad8:	33a05000 	movcc	r5, #0
57e25adc:	e3560001 	cmp	r6, #1
57e25ae0:	13855001 	orrne	r5, r5, #1
57e25ae4:	e3550000 	cmp	r5, #0
57e25ae8:	1a000101 	bne	57e25ef4 <inflate_table+0x554>
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
57e25aec:	e3a0a000 	mov	sl, #0
57e25af0:	e1cda4ba 	strh	sl, [sp, #74]	; 0x4a
57e25af4:	e28d7048 	add	r7, sp, #72	; 0x48
57e25af8:	e3a05000 	mov	r5, #0
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
57e25afc:	e2855002 	add	r5, r5, #2
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];
57e25b00:	e28da068 	add	sl, sp, #104	; 0x68
57e25b04:	e19a90b5 	ldrh	r9, [sl, r5]
57e25b08:	e1d7a0b2 	ldrh	sl, [r7, #2]
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
57e25b0c:	e355001c 	cmp	r5, #28
        offs[len + 1] = offs[len] + count[len];
57e25b10:	e089a00a 	add	sl, r9, sl
57e25b14:	e1c7a0b4 	strh	sl, [r7, #4]
57e25b18:	e2877002 	add	r7, r7, #2
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
57e25b1c:	1afffff6 	bne	57e25afc <inflate_table+0x15c>
57e25b20:	e3a05000 	mov	r5, #0
57e25b24:	ea00000a 	b	57e25b54 <inflate_table+0x1b4>
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
57e25b28:	e0db90b2 	ldrh	r9, [fp], #2
57e25b2c:	e3590000 	cmp	r9, #0
57e25b30:	0a000006 	beq	57e25b50 <inflate_table+0x1b0>
57e25b34:	e28d7088 	add	r7, sp, #136	; 0x88
57e25b38:	e0879089 	add	r9, r7, r9, lsl #1
57e25b3c:	e15974b0 	ldrh	r7, [r9, #-64]	; 0xffffffc0
57e25b40:	e1a0a087 	lsl	sl, r7, #1
57e25b44:	e2877001 	add	r7, r7, #1
57e25b48:	e18150ba 	strh	r5, [r1, sl]
57e25b4c:	e14974b0 	strh	r7, [r9, #-64]	; 0xffffffc0
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
57e25b50:	e2855001 	add	r5, r5, #1
57e25b54:	e1550002 	cmp	r5, r2
57e25b58:	3afffff2 	bcc	57e25b28 <inflate_table+0x188>
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
57e25b5c:	e3500000 	cmp	r0, #0
57e25b60:	0a00000f 	beq	57e25ba4 <inflate_table+0x204>
57e25b64:	e3500001 	cmp	r0, #1
57e25b68:	1a000006 	bne	57e25b88 <inflate_table+0x1e8>
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
57e25b6c:	e59fa394 	ldr	sl, [pc, #916]	; 57e25f08 <inflate_table+0x568>
        end = 256;
57e25b70:	e3a09c01 	mov	r9, #256	; 0x100
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
57e25b74:	e28a2040 	add	r2, sl, #64	; 0x40
        extra = lext;
        extra -= 257;
        end = 256;
57e25b78:	e58d9020 	str	r9, [sp, #32]
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
57e25b7c:	e58da010 	str	sl, [sp, #16]
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
57e25b80:	e58d201c 	str	r2, [sp, #28]
57e25b84:	ea00000a 	b	57e25bb4 <inflate_table+0x214>
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
57e25b88:	e59f737c 	ldr	r7, [pc, #892]	; 57e25f0c <inflate_table+0x56c>
        end = -1;
57e25b8c:	e3e05000 	mvn	r5, #0
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
57e25b90:	e2879040 	add	r9, r7, #64	; 0x40
        extra = dext;
        end = -1;
57e25b94:	e58d5020 	str	r5, [sp, #32]
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
57e25b98:	e58d7010 	str	r7, [sp, #16]
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
57e25b9c:	e58d901c 	str	r9, [sp, #28]
57e25ba0:	ea000003 	b	57e25bb4 <inflate_table+0x214>

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
        end = 19;
57e25ba4:	e3a0a013 	mov	sl, #19
     */

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
57e25ba8:	e58d1010 	str	r1, [sp, #16]
57e25bac:	e58d101c 	str	r1, [sp, #28]
        end = 19;
57e25bb0:	e58da020 	str	sl, [sp, #32]
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
57e25bb4:	e3a0a001 	mov	sl, #1
57e25bb8:	e1a02c1a 	lsl	r2, sl, ip
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
57e25bbc:	e150000a 	cmp	r0, sl
57e25bc0:	13a00000 	movne	r0, #0
57e25bc4:	03a00001 	moveq	r0, #1

    /* initialize state for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
57e25bc8:	e5937000 	ldr	r7, [r3]
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
57e25bcc:	e58d200c 	str	r2, [sp, #12]
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
57e25bd0:	e58d0038 	str	r0, [sp, #56]	; 0x38
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
57e25bd4:	e2425001 	sub	r5, r2, #1

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
57e25bd8:	e59f0330 	ldr	r0, [pc, #816]	; 57e25f10 <inflate_table+0x570>
57e25bdc:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
57e25be0:	e59d900c 	ldr	r9, [sp, #12]
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
57e25be4:	e58d5034 	str	r5, [sp, #52]	; 0x34

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
57e25be8:	e1590000 	cmp	r9, r0
57e25bec:	93a02000 	movls	r2, #0
57e25bf0:	82022001 	andhi	r2, r2, #1
57e25bf4:	e3520000 	cmp	r2, #0
        return 1;
57e25bf8:	11a0000a 	movne	r0, sl
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
57e25bfc:	1a0000bf 	bne	57e25f00 <inflate_table+0x560>
57e25c00:	e58d1018 	str	r1, [sp, #24]
57e25c04:	e3e01000 	mvn	r1, #0
57e25c08:	e58d1014 	str	r1, [sp, #20]
57e25c0c:	e1a0500c 	mov	r5, ip
57e25c10:	e1a01002 	mov	r1, r2
57e25c14:	e1a0b006 	mov	fp, r6
57e25c18:	ea000000 	b	57e25c20 <inflate_table+0x280>
57e25c1c:	e58d0014 	str	r0, [sp, #20]

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
57e25c20:	e59d6018 	ldr	r6, [sp, #24]
57e25c24:	e59d9020 	ldr	r9, [sp, #32]
57e25c28:	e0d6a0b2 	ldrh	sl, [r6], #2
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
57e25c2c:	e0610004 	rsb	r0, r1, r4
        if ((int)(work[sym]) < end) {
57e25c30:	e15a0009 	cmp	sl, r9
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
57e25c34:	e20000ff 	and	r0, r0, #255	; 0xff
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
57e25c38:	b3a09000 	movlt	r9, #0
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
57e25c3c:	e58d003c 	str	r0, [sp, #60]	; 0x3c
        if ((int)(work[sym]) < end) {
57e25c40:	e58d6018 	str	r6, [sp, #24]
            this.op = (unsigned char)0;
57e25c44:	b58d902c 	strlt	r9, [sp, #44]	; 0x2c

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
57e25c48:	ba000008 	blt	57e25c70 <inflate_table+0x2d0>
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
57e25c4c:	c59d0010 	ldrgt	r0, [sp, #16]
57e25c50:	c1a0a08a 	lslgt	sl, sl, #1
            this.val = base[work[sym]];
57e25c54:	c59d601c 	ldrgt	r6, [sp, #28]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
57e25c58:	c7d0000a 	ldrbgt	r0, [r0, sl]
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
57e25c5c:	d3a00060 	movle	r0, #96	; 0x60
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
57e25c60:	c196a0ba 	ldrhgt	sl, [r6, sl]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
57e25c64:	c58d002c 	strgt	r0, [sp, #44]	; 0x2c
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
            this.val = 0;
57e25c68:	d3a0a000 	movle	sl, #0
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
57e25c6c:	d58d002c 	strle	r0, [sp, #44]	; 0x2c
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
57e25c70:	e3a09001 	mov	r9, #1
57e25c74:	e0616004 	rsb	r6, r1, r4
57e25c78:	e1a06619 	lsl	r6, r9, r6
        fill = 1U << curr;
57e25c7c:	e1a00519 	lsl	r0, r9, r5
57e25c80:	e58d0024 	str	r0, [sp, #36]	; 0x24
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
57e25c84:	e0660000 	rsb	r0, r6, r0
57e25c88:	e2669000 	rsb	r9, r6, #0
57e25c8c:	e58d0028 	str	r0, [sp, #40]	; 0x28
57e25c90:	e3e00003 	mvn	r0, #3
57e25c94:	e58d9040 	str	r9, [sp, #64]	; 0x40
57e25c98:	e0090690 	mul	r9, r0, r6
57e25c9c:	e58d9044 	str	r9, [sp, #68]	; 0x44
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
57e25ca0:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
57e25ca4:	e58d3004 	str	r3, [sp, #4]
57e25ca8:	e0890132 	add	r0, r9, r2, lsr r1
57e25cac:	e0660000 	rsb	r0, r6, r0
57e25cb0:	e0870100 	add	r0, r7, r0, lsl #2
57e25cb4:	e1a0900c 	mov	r9, ip
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
57e25cb8:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
57e25cbc:	e5c0c000 	strb	ip, [r0]
57e25cc0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
57e25cc4:	e1c0a0b2 	strh	sl, [r0, #2]
57e25cc8:	e5c03001 	strb	r3, [r0, #1]
57e25ccc:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
57e25cd0:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
57e25cd4:	e08cc003 	add	ip, ip, r3
57e25cd8:	e58dc028 	str	ip, [sp, #40]	; 0x28
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
57e25cdc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
57e25ce0:	e59dc044 	ldr	ip, [sp, #68]	; 0x44
57e25ce4:	e080000c 	add	r0, r0, ip
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
57e25ce8:	e083c006 	add	ip, r3, r6
57e25cec:	e35c0000 	cmp	ip, #0
57e25cf0:	1afffff0 	bne	57e25cb8 <inflate_table+0x318>

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
57e25cf4:	e2440001 	sub	r0, r4, #1
57e25cf8:	e3a06001 	mov	r6, #1
57e25cfc:	e1a0c009 	mov	ip, r9
57e25d00:	e59d3004 	ldr	r3, [sp, #4]
57e25d04:	e1a00016 	lsl	r0, r6, r0
        while (huff & incr)
57e25d08:	ea000000 	b	57e25d10 <inflate_table+0x370>
            incr >>= 1;
57e25d0c:	e1a000a0 	lsr	r0, r0, #1
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
57e25d10:	e1100002 	tst	r0, r2
57e25d14:	1afffffc 	bne	57e25d0c <inflate_table+0x36c>
            incr >>= 1;
        if (incr != 0) {
57e25d18:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
57e25d1c:	12406001 	subne	r6, r0, #1
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
57e25d20:	e28d9088 	add	r9, sp, #136	; 0x88
        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
57e25d24:	10062002 	andne	r2, r6, r2
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
57e25d28:	e0896084 	add	r6, r9, r4, lsl #1
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
57e25d2c:	10822000 	addne	r2, r2, r0
        }
        else
            huff = 0;
57e25d30:	01a02000 	moveq	r2, r0

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
57e25d34:	e15602b0 	ldrh	r0, [r6, #-32]	; 0xffffffe0
57e25d38:	e2400001 	sub	r0, r0, #1
57e25d3c:	e1a00800 	lsl	r0, r0, #16
57e25d40:	e1a00820 	lsr	r0, r0, #16
57e25d44:	e3500000 	cmp	r0, #0
57e25d48:	e14602b0 	strh	r0, [r6, #-32]	; 0xffffffe0
57e25d4c:	1a000006 	bne	57e25d6c <inflate_table+0x3cc>
            if (len == max) break;
57e25d50:	e154000b 	cmp	r4, fp
57e25d54:	0a000058 	beq	57e25ebc <inflate_table+0x51c>
            len = lens[work[sym]];
57e25d58:	e59da018 	ldr	sl, [sp, #24]
57e25d5c:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
57e25d60:	e1da00b0 	ldrh	r0, [sl]
57e25d64:	e1a00080 	lsl	r0, r0, #1
57e25d68:	e19640b0 	ldrh	r4, [r6, r0]
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) != low) {
57e25d6c:	e154000c 	cmp	r4, ip
57e25d70:	959d0014 	ldrls	r0, [sp, #20]
57e25d74:	9affffa8 	bls	57e25c1c <inflate_table+0x27c>
57e25d78:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
57e25d7c:	e59da014 	ldr	sl, [sp, #20]
57e25d80:	e0020009 	and	r0, r2, r9
57e25d84:	e150000a 	cmp	r0, sl
57e25d88:	0affffa3 	beq	57e25c1c <inflate_table+0x27c>
            /* if first time, transition to sub-tables */
            if (drop == 0)
57e25d8c:	e3510000 	cmp	r1, #0
57e25d90:	01a0100c 	moveq	r1, ip

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
57e25d94:	e0615004 	rsb	r5, r1, r4
            left = (int)(1 << curr);
57e25d98:	e3a09001 	mov	r9, #1
57e25d9c:	e1a06519 	lsl	r6, r9, r5
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(codetype type, unsigned short FAR *lens, unsigned codes,
57e25da0:	e2419001 	sub	r9, r1, #1
57e25da4:	e28da068 	add	sl, sp, #104	; 0x68
57e25da8:	e0899005 	add	r9, r9, r5
57e25dac:	e08a9089 	add	r9, sl, r9, lsl #1
57e25db0:	e1a0a00c 	mov	sl, ip
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
57e25db4:	ea000005 	b	57e25dd0 <inflate_table+0x430>
                left -= count[curr + drop];
57e25db8:	e1f9c0b2 	ldrh	ip, [r9, #2]!
57e25dbc:	e06c6006 	rsb	r6, ip, r6
                if (left <= 0) break;
57e25dc0:	e3560000 	cmp	r6, #0
57e25dc4:	da000004 	ble	57e25ddc <inflate_table+0x43c>
                curr++;
57e25dc8:	e2855001 	add	r5, r5, #1
                left <<= 1;
57e25dcc:	e1a06086 	lsl	r6, r6, #1
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
57e25dd0:	e085c001 	add	ip, r5, r1
57e25dd4:	e15c000b 	cmp	ip, fp
57e25dd8:	3afffff6 	bcc	57e25db8 <inflate_table+0x418>
                curr++;
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
57e25ddc:	e59d600c 	ldr	r6, [sp, #12]
57e25de0:	e3a09001 	mov	r9, #1
57e25de4:	e0866519 	add	r6, r6, r9, lsl r5
57e25de8:	e58d600c 	str	r6, [sp, #12]
57e25dec:	e1a0c00a 	mov	ip, sl
            if (type == LENS && used >= ENOUGH - MAXD)
57e25df0:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
57e25df4:	e59da00c 	ldr	sl, [sp, #12]
57e25df8:	e59f9110 	ldr	r9, [pc, #272]	; 57e25f10 <inflate_table+0x570>
57e25dfc:	e15a0009 	cmp	sl, r9
57e25e00:	93a06000 	movls	r6, #0
57e25e04:	82066001 	andhi	r6, r6, #1
57e25e08:	e3560000 	cmp	r6, #0
57e25e0c:	1a00003a 	bne	57e25efc <inflate_table+0x55c>
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
57e25e10:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
57e25e14:	e59da024 	ldr	sl, [sp, #36]	; 0x24
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
57e25e18:	e7c65100 	strb	r5, [r6, r0, lsl #2]
            (*table)[low].bits = (unsigned char)root;
57e25e1c:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
57e25e20:	e087710a 	add	r7, r7, sl, lsl #2
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
57e25e24:	e1a0a100 	lsl	sl, r0, #2
            (*table)[low].bits = (unsigned char)root;
57e25e28:	e086600a 	add	r6, r6, sl
57e25e2c:	e5c6c001 	strb	ip, [r6, #1]
            (*table)[low].val = (unsigned short)(next - *table);
57e25e30:	e5936000 	ldr	r6, [r3]
57e25e34:	e086a00a 	add	sl, r6, sl
57e25e38:	e0666007 	rsb	r6, r6, r7
57e25e3c:	e1a06146 	asr	r6, r6, #2
57e25e40:	e1ca60b2 	strh	r6, [sl, #2]
57e25e44:	eaffff74 	b	57e25c1c <inflate_table+0x27c>
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
57e25e48:	e3510000 	cmp	r1, #0
57e25e4c:	0a000007 	beq	57e25e70 <inflate_table+0x4d0>
57e25e50:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
57e25e54:	e0020009 	and	r0, r2, r9
57e25e58:	e59d9014 	ldr	r9, [sp, #20]
57e25e5c:	e1500009 	cmp	r0, r9
            drop = 0;
            len = root;
            next = *table;
57e25e60:	15937000 	ldrne	r7, [r3]
            this.bits = (unsigned char)len;
57e25e64:	11a0b00a 	movne	fp, sl
57e25e68:	11a0400c 	movne	r4, ip
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
57e25e6c:	13a01000 	movne	r1, #0
            next = *table;
            this.bits = (unsigned char)len;
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
57e25e70:	e1a09132 	lsr	r9, r2, r1
57e25e74:	e0870109 	add	r0, r7, r9, lsl #2
57e25e78:	e7c76109 	strb	r6, [r7, r9, lsl #2]
57e25e7c:	e3a09000 	mov	r9, #0
57e25e80:	e5c0b001 	strb	fp, [r0, #1]
57e25e84:	e1c090b2 	strh	r9, [r0, #2]

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
57e25e88:	e2440001 	sub	r0, r4, #1
57e25e8c:	e1a00015 	lsl	r0, r5, r0
        while (huff & incr)
57e25e90:	ea000000 	b	57e25e98 <inflate_table+0x4f8>
            incr >>= 1;
57e25e94:	e1a000a0 	lsr	r0, r0, #1
        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
57e25e98:	e1100002 	tst	r0, r2
57e25e9c:	1afffffc 	bne	57e25e94 <inflate_table+0x4f4>
            incr >>= 1;
        if (incr != 0) {
57e25ea0:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
57e25ea4:	12409001 	subne	r9, r0, #1
57e25ea8:	10092002 	andne	r2, r9, r2
            huff += incr;
57e25eac:	10822000 	addne	r2, r2, r0
57e25eb0:	1a000005 	bne	57e25ecc <inflate_table+0x52c>
        }
        else
            huff = 0;
57e25eb4:	e1a02000 	mov	r2, r0
57e25eb8:	ea000005 	b	57e25ed4 <inflate_table+0x534>

        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
57e25ebc:	e59db03c 	ldr	fp, [sp, #60]	; 0x3c
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
            len = root;
            next = *table;
            this.bits = (unsigned char)len;
57e25ec0:	e20ca0ff 	and	sl, ip, #255	; 0xff
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
57e25ec4:	e3a06040 	mov	r6, #64	; 0x40

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
57e25ec8:	e3a05001 	mov	r5, #1
       drops back to the root table to fill in any remaining entries there.
     */
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
57e25ecc:	e3520000 	cmp	r2, #0
57e25ed0:	1affffdc 	bne	57e25e48 <inflate_table+0x4a8>
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
57e25ed4:	e5931000 	ldr	r1, [r3]
57e25ed8:	e59da00c 	ldr	sl, [sp, #12]
    *bits = root;
57e25edc:	e59d00a8 	ldr	r0, [sp, #168]	; 0xa8
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
57e25ee0:	e081110a 	add	r1, r1, sl, lsl #2
57e25ee4:	e5831000 	str	r1, [r3]
    *bits = root;
57e25ee8:	e580c000 	str	ip, [r0]
    return 0;
57e25eec:	e1a00002 	mov	r0, r2
57e25ef0:	ea000002 	b	57e25f00 <inflate_table+0x560>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */
57e25ef4:	e3e00000 	mvn	r0, #0
57e25ef8:	ea000000 	b	57e25f00 <inflate_table+0x560>
            }

            /* check for enough space */
            used += 1U << curr;
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;
57e25efc:	e3a00001 	mov	r0, #1

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}
57e25f00:	e28dd088 	add	sp, sp, #136	; 0x88
57e25f04:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e25f08:	57e2d3ea 	.word	0x57e2d3ea
57e25f0c:	57e2d66c 	.word	0x57e2d66c
57e25f10:	000005af 	.word	0x000005af

57e25f14 <inflateReset>:

int ZEXPORT inflateReset(z_streamp strm)
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
57e25f14:	e3500000 	cmp	r0, #0
57e25f18:	03e00001 	mvneq	r0, #1
57e25f1c:	012fff1e 	bxeq	lr
57e25f20:	e590301c 	ldr	r3, [r0, #28]
57e25f24:	e3530000 	cmp	r3, #0
57e25f28:	0a000017 	beq	57e25f8c <inflateReset+0x78>
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
57e25f2c:	e3a02000 	mov	r2, #0
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
57e25f30:	e3a01001 	mov	r1, #1
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
57e25f34:	e583201c 	str	r2, [r3, #28]
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
57e25f38:	e5801034 	str	r1, [r0, #52]	; 0x34
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
57e25f3c:	e3a01902 	mov	r1, #32768	; 0x8000
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
57e25f40:	e5802014 	str	r2, [r0, #20]
57e25f44:	e5802008 	str	r2, [r0, #8]
    strm->msg = Z_NULL;
57e25f48:	e5802018 	str	r2, [r0, #24]
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
57e25f4c:	e5831014 	str	r1, [r3, #20]
    state->wsize = 0;
    state->whave = 0;
    state->write = 0;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
57e25f50:	e2831e53 	add	r1, r3, #1328	; 0x530
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
57e25f54:	e5832000 	str	r2, [r3]
    state->last = 0;
57e25f58:	e5832004 	str	r2, [r3, #4]
    state->havedict = 0;
57e25f5c:	e583200c 	str	r2, [r3, #12]
    state->dmax = 32768U;
    state->head = Z_NULL;
57e25f60:	e5832020 	str	r2, [r3, #32]
    state->wsize = 0;
57e25f64:	e5832028 	str	r2, [r3, #40]	; 0x28
    state->whave = 0;
57e25f68:	e583202c 	str	r2, [r3, #44]	; 0x2c
    state->write = 0;
57e25f6c:	e5832030 	str	r2, [r3, #48]	; 0x30
    state->hold = 0;
57e25f70:	e5832038 	str	r2, [r3, #56]	; 0x38
    state->bits = 0;
57e25f74:	e583203c 	str	r2, [r3, #60]	; 0x3c
    state->lencode = state->distcode = state->next = state->codes;
57e25f78:	e583106c 	str	r1, [r3, #108]	; 0x6c
57e25f7c:	e5831050 	str	r1, [r3, #80]	; 0x50
57e25f80:	e583104c 	str	r1, [r3, #76]	; 0x4c
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
57e25f84:	e1a00002 	mov	r0, r2
57e25f88:	e12fff1e 	bx	lr

int ZEXPORT inflateReset(z_streamp strm)
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
57e25f8c:	e3e00001 	mvn	r0, #1
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}
57e25f90:	e12fff1e 	bx	lr

57e25f94 <inflateInit2_>:
int ZEXPORT inflateInit2_(z_streamp strm, int windowBits, const char *version,
			  int stream_size)
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
57e25f94:	e3520000 	cmp	r2, #0
    return Z_OK;
}

int ZEXPORT inflateInit2_(z_streamp strm, int windowBits, const char *version,
			  int stream_size)
{
57e25f98:	e92d4070 	push	{r4, r5, r6, lr}
57e25f9c:	e1a04000 	mov	r4, r0
57e25fa0:	e1a05001 	mov	r5, r1
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
57e25fa4:	0a000033 	beq	57e26078 <inflateInit2_+0xe4>
57e25fa8:	e5d22000 	ldrb	r2, [r2]
57e25fac:	e3520031 	cmp	r2, #49	; 0x31
57e25fb0:	0353003c 	cmpeq	r3, #60	; 0x3c
57e25fb4:	03a03000 	moveq	r3, #0
57e25fb8:	13a03001 	movne	r3, #1
57e25fbc:	1a00002d 	bne	57e26078 <inflateInit2_+0xe4>
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
57e25fc0:	e3500000 	cmp	r0, #0
57e25fc4:	0a00002d 	beq	57e26080 <inflateInit2_+0xec>
    strm->msg = Z_NULL;                 /* in case we return an error */
57e25fc8:	e5803018 	str	r3, [r0, #24]
    if (strm->zalloc == (alloc_func)0) {
57e25fcc:	e5903020 	ldr	r3, [r0, #32]
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
57e25fd0:	e3a01001 	mov	r1, #1
    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
57e25fd4:	e3530000 	cmp	r3, #0
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
57e25fd8:	05803028 	streq	r3, [r0, #40]	; 0x28
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
57e25fdc:	059f20ac 	ldreq	r2, [pc, #172]	; 57e26090 <inflateInit2_+0xfc>
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
57e25fe0:	e5903024 	ldr	r3, [r0, #36]	; 0x24
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
57e25fe4:	05802020 	streq	r2, [r0, #32]
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
57e25fe8:	e3530000 	cmp	r3, #0
57e25fec:	059f30a0 	ldreq	r3, [pc, #160]	; 57e26094 <inflateInit2_+0x100>
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
57e25ff0:	e59f20a0 	ldr	r2, [pc, #160]	; 57e26098 <inflateInit2_+0x104>
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
57e25ff4:	05803024 	streq	r3, [r0, #36]	; 0x24
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
57e25ff8:	e5903020 	ldr	r3, [r0, #32]
57e25ffc:	e5900028 	ldr	r0, [r0, #40]	; 0x28
57e26000:	e12fff33 	blx	r3
    if (state == Z_NULL) return Z_MEM_ERROR;
57e26004:	e2501000 	subs	r1, r0, #0
57e26008:	0a00001e 	beq	57e26088 <inflateInit2_+0xf4>
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
57e2600c:	e3550000 	cmp	r5, #0
        state->wrap = 0;
57e26010:	b3a03000 	movlt	r3, #0
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
57e26014:	e584101c 	str	r1, [r4, #28]
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
57e26018:	b2655000 	rsblt	r5, r5, #0
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
        state->wrap = 0;
57e2601c:	b5813008 	strlt	r3, [r1, #8]
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
57e26020:	ba000004 	blt	57e26038 <inflateInit2_+0xa4>
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
57e26024:	e1a03245 	asr	r3, r5, #4
57e26028:	e2833001 	add	r3, r3, #1
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
57e2602c:	e355002f 	cmp	r5, #47	; 0x2f
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
57e26030:	e5813008 	str	r3, [r1, #8]
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
57e26034:	d205500f 	andle	r5, r5, #15
#endif
    }
    if (windowBits < 8 || windowBits > 15) {
57e26038:	e2453008 	sub	r3, r5, #8
57e2603c:	e3530007 	cmp	r3, #7
57e26040:	9a000006 	bls	57e26060 <inflateInit2_+0xcc>
        ZFREE(strm, state);
57e26044:	e5943024 	ldr	r3, [r4, #36]	; 0x24
57e26048:	e5940028 	ldr	r0, [r4, #40]	; 0x28
57e2604c:	e3a02000 	mov	r2, #0
57e26050:	e12fff33 	blx	r3
        strm->state = Z_NULL;
57e26054:	e3a03000 	mov	r3, #0
57e26058:	e584301c 	str	r3, [r4, #28]
57e2605c:	ea000007 	b	57e26080 <inflateInit2_+0xec>
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
57e26060:	e3a03000 	mov	r3, #0
    return inflateReset(strm);
57e26064:	e1a00004 	mov	r0, r4
    if (windowBits < 8 || windowBits > 15) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
57e26068:	e5815024 	str	r5, [r1, #36]	; 0x24
    state->window = Z_NULL;
57e2606c:	e5813034 	str	r3, [r1, #52]	; 0x34
    return inflateReset(strm);
}
57e26070:	e8bd4070 	pop	{r4, r5, r6, lr}
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
57e26074:	eaffffa6 	b	57e25f14 <inflateReset>
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
57e26078:	e3e00005 	mvn	r0, #5
57e2607c:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (strm == Z_NULL) return Z_STREAM_ERROR;
57e26080:	e3e00001 	mvn	r0, #1
57e26084:	e8bd8070 	pop	{r4, r5, r6, pc}
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
57e26088:	e3e00003 	mvn	r0, #3
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
}
57e2608c:	e8bd8070 	pop	{r4, r5, r6, pc}
57e26090:	57e25424 	.word	0x57e25424
57e26094:	57e2541c 	.word	0x57e2541c
57e26098:	00002530 	.word	0x00002530

57e2609c <inflateInit_>:

int ZEXPORT inflateInit_(z_streamp strm, const char *version, int stream_size)
{
57e2609c:	e1a0c001 	mov	ip, r1
57e260a0:	e1a03002 	mov	r3, r2
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
57e260a4:	e3a0100f 	mov	r1, #15
57e260a8:	e1a0200c 	mov	r2, ip
57e260ac:	eaffffb8 	b	57e25f94 <inflateInit2_>

57e260b0 <inflateEnd>:
        ret = Z_BUF_ERROR;
    return ret;
}

int ZEXPORT inflateEnd(z_streamp strm)
{
57e260b0:	e92d4010 	push	{r4, lr}
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
57e260b4:	e2504000 	subs	r4, r0, #0
57e260b8:	0a000013 	beq	57e2610c <inflateEnd+0x5c>
57e260bc:	e594201c 	ldr	r2, [r4, #28]
57e260c0:	e3520000 	cmp	r2, #0
57e260c4:	0a000010 	beq	57e2610c <inflateEnd+0x5c>
57e260c8:	e5943024 	ldr	r3, [r4, #36]	; 0x24
57e260cc:	e3530000 	cmp	r3, #0
57e260d0:	0a00000f 	beq	57e26114 <inflateEnd+0x64>
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) {
57e260d4:	e5921034 	ldr	r1, [r2, #52]	; 0x34
57e260d8:	e3510000 	cmp	r1, #0
57e260dc:	0a000002 	beq	57e260ec <inflateEnd+0x3c>
	WATCHDOG_RESET();
	ZFREE(strm, state->window);
57e260e0:	e5940028 	ldr	r0, [r4, #40]	; 0x28
57e260e4:	e3a02000 	mov	r2, #0
57e260e8:	e12fff33 	blx	r3
    }
    ZFREE(strm, strm->state);
57e260ec:	e5940028 	ldr	r0, [r4, #40]	; 0x28
57e260f0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
57e260f4:	e594101c 	ldr	r1, [r4, #28]
57e260f8:	e3a02000 	mov	r2, #0
57e260fc:	e12fff33 	blx	r3
    strm->state = Z_NULL;
57e26100:	e3a00000 	mov	r0, #0
57e26104:	e584001c 	str	r0, [r4, #28]
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
57e26108:	e8bd8010 	pop	{r4, pc}

int ZEXPORT inflateEnd(z_streamp strm)
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
57e2610c:	e3e00001 	mvn	r0, #1
57e26110:	e8bd8010 	pop	{r4, pc}
57e26114:	e3e00001 	mvn	r0, #1
    }
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}
57e26118:	e8bd8010 	pop	{r4, pc}

57e2611c <adler32>:
#  define MOD4(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len)
{
57e2611c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
57e26120:	e3520001 	cmp	r2, #1
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;
57e26124:	e1a05800 	lsl	r5, r0, #16
#  define MOD4(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len)
{
57e26128:	e1a04001 	mov	r4, r1
57e2612c:	e1a07002 	mov	r7, r2
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
57e26130:	e1a06820 	lsr	r6, r0, #16
    adler &= 0xffff;
57e26134:	e1a05825 	lsr	r5, r5, #16

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
57e26138:	1a00000b 	bne	57e2616c <adler32+0x50>
        adler += buf[0];
57e2613c:	e5d13000 	ldrb	r3, [r1]
57e26140:	e0835005 	add	r5, r3, r5
        if (adler >= BASE)
57e26144:	e59f32bc 	ldr	r3, [pc, #700]	; 57e26408 <adler32+0x2ec>
57e26148:	e1550003 	cmp	r5, r3
            adler -= BASE;
57e2614c:	82455cff 	subhi	r5, r5, #65280	; 0xff00
57e26150:	824550f1 	subhi	r5, r5, #241	; 0xf1
        sum2 += adler;
        if (sum2 >= BASE)
57e26154:	e59f32ac 	ldr	r3, [pc, #684]	; 57e26408 <adler32+0x2ec>
    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
        adler += buf[0];
        if (adler >= BASE)
            adler -= BASE;
        sum2 += adler;
57e26158:	e0856006 	add	r6, r5, r6
        if (sum2 >= BASE)
57e2615c:	e1560003 	cmp	r6, r3
            sum2 -= BASE;
57e26160:	82466cff 	subhi	r6, r6, #65280	; 0xff00
57e26164:	824660f1 	subhi	r6, r6, #241	; 0xf1
57e26168:	ea0000a2 	b	57e263f8 <adler32+0x2dc>
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
57e2616c:	e3510000 	cmp	r1, #0
57e26170:	0a0000a2 	beq	57e26400 <adler32+0x2e4>
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
57e26174:	e352000f 	cmp	r2, #15
57e26178:	9a000004 	bls	57e26190 <adler32+0x74>
57e2617c:	ea000050 	b	57e262c4 <adler32+0x1a8>
        while (len--) {
            adler += *buf++;
57e26180:	e4d43001 	ldrb	r3, [r4], #1
            sum2 += adler;
57e26184:	e2477001 	sub	r7, r7, #1
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
57e26188:	e0855003 	add	r5, r5, r3
            sum2 += adler;
57e2618c:	e0866005 	add	r6, r6, r5
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
57e26190:	e3570000 	cmp	r7, #0
57e26194:	1afffff9 	bne	57e26180 <adler32+0x64>
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
57e26198:	e59f3268 	ldr	r3, [pc, #616]	; 57e26408 <adler32+0x2ec>
            adler -= BASE;
        MOD4(sum2);             /* only added so many BASE's */
57e2619c:	e1a00006 	mov	r0, r6
    if (len < 16) {
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
57e261a0:	e1550003 	cmp	r5, r3
            adler -= BASE;
57e261a4:	82455cff 	subhi	r5, r5, #65280	; 0xff00
        MOD4(sum2);             /* only added so many BASE's */
57e261a8:	e59f125c 	ldr	r1, [pc, #604]	; 57e2640c <adler32+0x2f0>
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
57e261ac:	824550f1 	subhi	r5, r5, #241	; 0xf1
        MOD4(sum2);             /* only added so many BASE's */
57e261b0:	eb0015f9 	bl	57e2b99c <__aeabi_uidivmod>
        return adler | (sum2 << 16);
57e261b4:	e1850801 	orr	r0, r5, r1, lsl #16
57e261b8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
57e261bc:	e2477d56 	sub	r7, r7, #5504	; 0x1580
        n = NMAX / 16;          /* NMAX is divisible by 16 */
57e261c0:	e59f2248 	ldr	r2, [pc, #584]	; 57e26410 <adler32+0x2f4>
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
57e261c4:	e2477030 	sub	r7, r7, #48	; 0x30
57e261c8:	e1a03004 	mov	r3, r4
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
57e261cc:	e5d31000 	ldrb	r1, [r3]
            buf += 16;
        } while (--n);
57e261d0:	e2522001 	subs	r2, r2, #1
    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
57e261d4:	e0855001 	add	r5, r5, r1
57e261d8:	e5d31001 	ldrb	r1, [r3, #1]
57e261dc:	e0856006 	add	r6, r5, r6
57e261e0:	e0855001 	add	r5, r5, r1
57e261e4:	e5d31002 	ldrb	r1, [r3, #2]
57e261e8:	e0866005 	add	r6, r6, r5
57e261ec:	e0855001 	add	r5, r5, r1
57e261f0:	e5d31003 	ldrb	r1, [r3, #3]
57e261f4:	e0866005 	add	r6, r6, r5
57e261f8:	e0855001 	add	r5, r5, r1
57e261fc:	e5d31004 	ldrb	r1, [r3, #4]
57e26200:	e0866005 	add	r6, r6, r5
57e26204:	e0855001 	add	r5, r5, r1
57e26208:	e5d31005 	ldrb	r1, [r3, #5]
57e2620c:	e0866005 	add	r6, r6, r5
57e26210:	e0855001 	add	r5, r5, r1
57e26214:	e5d31006 	ldrb	r1, [r3, #6]
57e26218:	e0866005 	add	r6, r6, r5
57e2621c:	e0855001 	add	r5, r5, r1
57e26220:	e5d31007 	ldrb	r1, [r3, #7]
57e26224:	e0866005 	add	r6, r6, r5
57e26228:	e0855001 	add	r5, r5, r1
57e2622c:	e5d31008 	ldrb	r1, [r3, #8]
57e26230:	e0866005 	add	r6, r6, r5
57e26234:	e0855001 	add	r5, r5, r1
57e26238:	e5d31009 	ldrb	r1, [r3, #9]
57e2623c:	e0866005 	add	r6, r6, r5
57e26240:	e0855001 	add	r5, r5, r1
57e26244:	e5d3100a 	ldrb	r1, [r3, #10]
57e26248:	e0866005 	add	r6, r6, r5
57e2624c:	e0855001 	add	r5, r5, r1
57e26250:	e5d3100b 	ldrb	r1, [r3, #11]
57e26254:	e0866005 	add	r6, r6, r5
57e26258:	e0855001 	add	r5, r5, r1
57e2625c:	e5d3100c 	ldrb	r1, [r3, #12]
57e26260:	e0866005 	add	r6, r6, r5
57e26264:	e0855001 	add	r5, r5, r1
57e26268:	e5d3100d 	ldrb	r1, [r3, #13]
57e2626c:	e0866005 	add	r6, r6, r5
57e26270:	e0855001 	add	r5, r5, r1
57e26274:	e5d3100e 	ldrb	r1, [r3, #14]
57e26278:	e0866005 	add	r6, r6, r5
57e2627c:	e0855001 	add	r5, r5, r1
57e26280:	e5d3100f 	ldrb	r1, [r3, #15]
57e26284:	e0866005 	add	r6, r6, r5
57e26288:	e0855001 	add	r5, r5, r1
57e2628c:	e0866005 	add	r6, r6, r5
            buf += 16;
57e26290:	e2833010 	add	r3, r3, #16
        } while (--n);
57e26294:	1affffcc 	bne	57e261cc <adler32+0xb0>
        MOD(adler);
57e26298:	e1a00005 	mov	r0, r5
57e2629c:	e59f1168 	ldr	r1, [pc, #360]	; 57e2640c <adler32+0x2f0>
57e262a0:	eb0015bd 	bl	57e2b99c <__aeabi_uidivmod>
        MOD(sum2);
57e262a4:	e1a00006 	mov	r0, r6
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
57e262a8:	e1a05001 	mov	r5, r1
        MOD(sum2);
57e262ac:	e59f1158 	ldr	r1, [pc, #344]	; 57e2640c <adler32+0x2f0>
57e262b0:	eb0015b9 	bl	57e2b99c <__aeabi_uidivmod>
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
57e262b4:	e2844d56 	add	r4, r4, #5504	; 0x1580
57e262b8:	e2844030 	add	r4, r4, #48	; 0x30
        MOD(adler);
        MOD(sum2);
57e262bc:	e1a06001 	mov	r6, r1
57e262c0:	ea000000 	b	57e262c8 <adler32+0x1ac>
        MOD4(sum2);             /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
57e262c4:	e59fa148 	ldr	sl, [pc, #328]	; 57e26414 <adler32+0x2f8>
57e262c8:	e157000a 	cmp	r7, sl
57e262cc:	8affffba 	bhi	57e261bc <adler32+0xa0>
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
57e262d0:	e2573000 	subs	r3, r7, #0
57e262d4:	11a02004 	movne	r2, r4
57e262d8:	1a000031 	bne	57e263a4 <adler32+0x288>
57e262dc:	ea000045 	b	57e263f8 <adler32+0x2dc>
        while (len >= 16) {
            len -= 16;
            DO16(buf);
57e262e0:	e5521010 	ldrb	r1, [r2, #-16]
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
57e262e4:	e2477010 	sub	r7, r7, #16
            DO16(buf);
57e262e8:	e0855001 	add	r5, r5, r1
57e262ec:	e552100f 	ldrb	r1, [r2, #-15]
57e262f0:	e0856006 	add	r6, r5, r6
57e262f4:	e0855001 	add	r5, r5, r1
57e262f8:	e552100e 	ldrb	r1, [r2, #-14]
57e262fc:	e0866005 	add	r6, r6, r5
57e26300:	e0855001 	add	r5, r5, r1
57e26304:	e552100d 	ldrb	r1, [r2, #-13]
57e26308:	e0866005 	add	r6, r6, r5
57e2630c:	e0855001 	add	r5, r5, r1
57e26310:	e552100c 	ldrb	r1, [r2, #-12]
57e26314:	e0866005 	add	r6, r6, r5
57e26318:	e0855001 	add	r5, r5, r1
57e2631c:	e552100b 	ldrb	r1, [r2, #-11]
57e26320:	e0866005 	add	r6, r6, r5
57e26324:	e0855001 	add	r5, r5, r1
57e26328:	e552100a 	ldrb	r1, [r2, #-10]
57e2632c:	e0866005 	add	r6, r6, r5
57e26330:	e0855001 	add	r5, r5, r1
57e26334:	e5521009 	ldrb	r1, [r2, #-9]
57e26338:	e0866005 	add	r6, r6, r5
57e2633c:	e0855001 	add	r5, r5, r1
57e26340:	e5521008 	ldrb	r1, [r2, #-8]
57e26344:	e0866005 	add	r6, r6, r5
57e26348:	e0855001 	add	r5, r5, r1
57e2634c:	e5521007 	ldrb	r1, [r2, #-7]
57e26350:	e0866005 	add	r6, r6, r5
57e26354:	e0855001 	add	r5, r5, r1
57e26358:	e5521006 	ldrb	r1, [r2, #-6]
57e2635c:	e0866005 	add	r6, r6, r5
57e26360:	e0855001 	add	r5, r5, r1
57e26364:	e5521005 	ldrb	r1, [r2, #-5]
57e26368:	e0866005 	add	r6, r6, r5
57e2636c:	e0855001 	add	r5, r5, r1
57e26370:	e5521004 	ldrb	r1, [r2, #-4]
57e26374:	e0866005 	add	r6, r6, r5
57e26378:	e0855001 	add	r5, r5, r1
57e2637c:	e5521003 	ldrb	r1, [r2, #-3]
57e26380:	e0866005 	add	r6, r6, r5
57e26384:	e0855001 	add	r5, r5, r1
57e26388:	e5521002 	ldrb	r1, [r2, #-2]
57e2638c:	e0866005 	add	r6, r6, r5
57e26390:	e0855001 	add	r5, r5, r1
57e26394:	e5521001 	ldrb	r1, [r2, #-1]
57e26398:	e0866005 	add	r6, r6, r5
57e2639c:	e0855001 	add	r5, r5, r1
57e263a0:	e0866005 	add	r6, r6, r5
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
57e263a4:	e357000f 	cmp	r7, #15
            len -= 16;
            DO16(buf);
57e263a8:	e2822010 	add	r2, r2, #16
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
57e263ac:	8affffcb 	bhi	57e262e0 <adler32+0x1c4>
#  define MOD(a) a %= BASE
#  define MOD4(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len)
57e263b0:	e3c3200f 	bic	r2, r3, #15
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
57e263b4:	e0844002 	add	r4, r4, r2
57e263b8:	e203300f 	and	r3, r3, #15
57e263bc:	ea000003 	b	57e263d0 <adler32+0x2b4>
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
57e263c0:	e4d42001 	ldrb	r2, [r4], #1
            sum2 += adler;
57e263c4:	e2433001 	sub	r3, r3, #1
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
57e263c8:	e0855002 	add	r5, r5, r2
            sum2 += adler;
57e263cc:	e0866005 	add	r6, r6, r5
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
57e263d0:	e3530000 	cmp	r3, #0
57e263d4:	1afffff9 	bne	57e263c0 <adler32+0x2a4>
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
57e263d8:	e1a00005 	mov	r0, r5
57e263dc:	e59f1028 	ldr	r1, [pc, #40]	; 57e2640c <adler32+0x2f0>
57e263e0:	eb00156d 	bl	57e2b99c <__aeabi_uidivmod>
        MOD(sum2);
57e263e4:	e1a00006 	mov	r0, r6
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
57e263e8:	e1a05001 	mov	r5, r1
        MOD(sum2);
57e263ec:	e59f1018 	ldr	r1, [pc, #24]	; 57e2640c <adler32+0x2f0>
57e263f0:	eb001569 	bl	57e2b99c <__aeabi_uidivmod>
57e263f4:	e1a06001 	mov	r6, r1
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
57e263f8:	e1850806 	orr	r0, r5, r6, lsl #16
57e263fc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;
57e26400:	e3a00001 	mov	r0, #1
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}
57e26404:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e26408:	0000fff0 	.word	0x0000fff0
57e2640c:	0000fff1 	.word	0x0000fff1
57e26410:	0000015b 	.word	0x0000015b
57e26414:	000015af 	.word	0x000015af

57e26418 <inflate>:
   stream available.  So the only thing the flush parameter actually does is:
   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(z_streamp strm, int flush)
{
57e26418:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
57e2641c:	e250a000 	subs	sl, r0, #0
   stream available.  So the only thing the flush parameter actually does is:
   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(z_streamp strm, int flush)
{
57e26420:	e24dd048 	sub	sp, sp, #72	; 0x48
57e26424:	e58d103c 	str	r1, [sp, #60]	; 0x3c
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
57e26428:	03e01001 	mvneq	r1, #1
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
57e2642c:	0a000595 	beq	57e27a88 <inflate+0x1670>
57e26430:	e59a401c 	ldr	r4, [sl, #28]
57e26434:	e3540000 	cmp	r4, #0
57e26438:	0a000594 	beq	57e27a90 <inflate+0x1678>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
57e2643c:	e59a9000 	ldr	r9, [sl]
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
57e26440:	e3590000 	cmp	r9, #0
57e26444:	1a000003 	bne	57e26458 <inflate+0x40>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
57e26448:	e59a3004 	ldr	r3, [sl, #4]
57e2644c:	e3530000 	cmp	r3, #0
        return Z_STREAM_ERROR;
57e26450:	13e03001 	mvnne	r3, #1
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
57e26454:	1a000590 	bne	57e27a9c <inflate+0x1684>
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
57e26458:	e5943000 	ldr	r3, [r4]
    LOAD();
57e2645c:	e59a1004 	ldr	r1, [sl, #4]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
57e26460:	e353000b 	cmp	r3, #11
    LOAD();
57e26464:	e59a000c 	ldr	r0, [sl, #12]
57e26468:	e59ab010 	ldr	fp, [sl, #16]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
57e2646c:	02833001 	addeq	r3, r3, #1
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
57e26470:	e3a02000 	mov	r2, #0
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
57e26474:	e5946038 	ldr	r6, [r4, #56]	; 0x38
57e26478:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
57e2647c:	05843000 	streq	r3, [r4]
    LOAD();
57e26480:	e58d0020 	str	r0, [sp, #32]
57e26484:	e58d1038 	str	r1, [sp, #56]	; 0x38
    in = have;
    out = left;
57e26488:	e58db02c 	str	fp, [sp, #44]	; 0x2c
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
57e2648c:	e1a07001 	mov	r7, r1
    in = have;
    out = left;
    ret = Z_OK;
57e26490:	e58d201c 	str	r2, [sp, #28]
    for (;;)
        switch (state->mode) {
57e26494:	e5943000 	ldr	r3, [r4]
57e26498:	e353001c 	cmp	r3, #28
57e2649c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e264a0:	ea00057f 	b	57e27aa4 <inflate+0x168c>
57e264a4:	57e26538 	.word	0x57e26538
57e264a8:	57e26530 	.word	0x57e26530
57e264ac:	57e26720 	.word	0x57e26720
57e264b0:	57e267a4 	.word	0x57e267a4
57e264b4:	57e26824 	.word	0x57e26824
57e264b8:	57e268bc 	.word	0x57e268bc
57e264bc:	57e26980 	.word	0x57e26980
57e264c0:	57e26a3c 	.word	0x57e26a3c
57e264c4:	57e26af0 	.word	0x57e26af0
57e264c8:	57e26528 	.word	0x57e26528
57e264cc:	57e26bd0 	.word	0x57e26bd0
57e264d0:	57e26c20 	.word	0x57e26c20
57e264d4:	57e26c2c 	.word	0x57e26c2c
57e264d8:	57e26ce4 	.word	0x57e26ce4
57e264dc:	57e26d50 	.word	0x57e26d50
57e264e0:	57e26520 	.word	0x57e26520
57e264e4:	57e26e3c 	.word	0x57e26e3c
57e264e8:	57e26f30 	.word	0x57e26f30
57e264ec:	57e271d8 	.word	0x57e271d8
57e264f0:	57e27378 	.word	0x57e27378
57e264f4:	57e273dc 	.word	0x57e273dc
57e264f8:	57e27504 	.word	0x57e27504
57e264fc:	57e275e4 	.word	0x57e275e4
57e26500:	57e2768c 	.word	0x57e2768c
57e26504:	57e276b0 	.word	0x57e276b0
57e26508:	57e277ac 	.word	0x57e277ac
57e2650c:	57e27838 	.word	0x57e27838
57e26510:	57e2782c 	.word	0x57e2782c
57e26514:	57e26518 	.word	0x57e26518
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
57e26518:	e3e03003 	mvn	r3, #3
57e2651c:	ea00055e 	b	57e27a9c <inflate+0x1684>
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
57e26520:	e1a03009 	mov	r3, r9
57e26524:	ea000228 	b	57e26dcc <inflate+0x9b4>
57e26528:	e1a03009 	mov	r3, r9
57e2652c:	ea000197 	b	57e26b90 <inflate+0x778>
57e26530:	e1a03009 	mov	r3, r9
57e26534:	ea00005a 	b	57e266a4 <inflate+0x28c>
        case HEAD:
            if (state->wrap == 0) {
57e26538:	e5943008 	ldr	r3, [r4, #8]
57e2653c:	e3530000 	cmp	r3, #0
57e26540:	11a02009 	movne	r2, r9
                state->mode = TYPEDO;
57e26544:	03a0300c 	moveq	r3, #12
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
        case HEAD:
            if (state->wrap == 0) {
57e26548:	1a000006 	bne	57e26568 <inflate+0x150>
57e2654c:	ea0004ad 	b	57e27808 <inflate+0x13f0>
                state->mode = TYPEDO;
                break;
            }
            NEEDBITS(16);
57e26550:	e3570000 	cmp	r7, #0
57e26554:	0a0004b9 	beq	57e27840 <inflate+0x1428>
57e26558:	e4d21001 	ldrb	r1, [r2], #1
57e2655c:	e2477001 	sub	r7, r7, #1
57e26560:	e0866511 	add	r6, r6, r1, lsl r5
57e26564:	e2855008 	add	r5, r5, #8
57e26568:	e355000f 	cmp	r5, #15
57e2656c:	e1a09002 	mov	r9, r2
57e26570:	9afffff6 	bls	57e26550 <inflate+0x138>
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
57e26574:	e3130002 	tst	r3, #2
57e26578:	e59f1f98 	ldr	r1, [pc, #3992]	; 57e27518 <inflate+0x1100>
57e2657c:	03a02000 	moveq	r2, #0
57e26580:	13a02001 	movne	r2, #1
57e26584:	e1560001 	cmp	r6, r1
57e26588:	13a02000 	movne	r2, #0
57e2658c:	02022001 	andeq	r2, r2, #1
57e26590:	e3520000 	cmp	r2, #0
57e26594:	0a000010 	beq	57e265dc <inflate+0x1c4>
                state->check = crc32(0L, Z_NULL, 0);
57e26598:	e3a00000 	mov	r0, #0
57e2659c:	e1a01000 	mov	r1, r0
57e265a0:	e1a02000 	mov	r2, r0
57e265a4:	ebffef19 	bl	57e22210 <crc32>
                CRC2(state->check, hold);
57e265a8:	e3a0301f 	mov	r3, #31
57e265ac:	e5cd3044 	strb	r3, [sp, #68]	; 0x44
                break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
57e265b0:	e5840018 	str	r0, [r4, #24]
                CRC2(state->check, hold);
57e265b4:	e3e03074 	mvn	r3, #116	; 0x74
57e265b8:	e28d1044 	add	r1, sp, #68	; 0x44
57e265bc:	e3a02002 	mov	r2, #2
57e265c0:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
57e265c4:	ebffef11 	bl	57e22210 <crc32>
                INITBITS();
                state->mode = FLAGS;
57e265c8:	e3a0c001 	mov	ip, #1
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
57e265cc:	e5840018 	str	r0, [r4, #24]
                INITBITS();
                state->mode = FLAGS;
57e265d0:	e584c000 	str	ip, [r4]
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
                INITBITS();
57e265d4:	e3a05000 	mov	r5, #0
57e265d8:	ea000029 	b	57e26684 <inflate+0x26c>
                state->mode = FLAGS;
                break;
            }
            state->flags = 0;           /* expect zlib header */
57e265dc:	e5842010 	str	r2, [r4, #16]
            if (state->head != Z_NULL)
57e265e0:	e5942020 	ldr	r2, [r4, #32]
57e265e4:	e3520000 	cmp	r2, #0
                state->head->done = -1;
57e265e8:	13e01000 	mvnne	r1, #0
57e265ec:	15821030 	strne	r1, [r2, #48]	; 0x30
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
57e265f0:	e3130001 	tst	r3, #1
57e265f4:	0a000006 	beq	57e26614 <inflate+0x1fc>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
57e265f8:	e1a03426 	lsr	r3, r6, #8
57e265fc:	e1a00c06 	lsl	r0, r6, #24
57e26600:	e0830820 	add	r0, r3, r0, lsr #16
57e26604:	e3a0101f 	mov	r1, #31
57e26608:	eb0014e3 	bl	57e2b99c <__aeabi_uidivmod>
                break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != Z_NULL)
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
57e2660c:	e2513000 	subs	r3, r1, #0
57e26610:	0a000001 	beq	57e2661c <inflate+0x204>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                strm->msg = (char *)"incorrect header check";
57e26614:	e59f3f00 	ldr	r3, [pc, #3840]	; 57e2751c <inflate+0x1104>
57e26618:	ea000478 	b	57e27800 <inflate+0x13e8>
                state->mode = BAD;
                break;
            }
            if (BITS(4) != Z_DEFLATED) {
57e2661c:	e206200f 	and	r2, r6, #15
57e26620:	e3520008 	cmp	r2, #8
57e26624:	1a000025 	bne	57e266c0 <inflate+0x2a8>
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
57e26628:	e1a06226 	lsr	r6, r6, #4
            len = BITS(4) + 8;
57e2662c:	e206000f 	and	r0, r6, #15
            if (len > state->wbits) {
57e26630:	e5942024 	ldr	r2, [r4, #36]	; 0x24
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
            len = BITS(4) + 8;
57e26634:	e2800008 	add	r0, r0, #8
            if (len > state->wbits) {
57e26638:	e1500002 	cmp	r0, r2
            if (BITS(4) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
57e2663c:	82455004 	subhi	r5, r5, #4
            len = BITS(4) + 8;
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
57e26640:	859f3ed8 	ldrhi	r3, [pc, #3800]	; 57e27520 <inflate+0x1108>
57e26644:	8a00046d 	bhi	57e27800 <inflate+0x13e8>
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
57e26648:	e3a02001 	mov	r2, #1
57e2664c:	e1a00012 	lsl	r0, r2, r0
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
57e26650:	e1a02003 	mov	r2, r3
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
57e26654:	e5840014 	str	r0, [r4, #20]
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
57e26658:	e1a00003 	mov	r0, r3
57e2665c:	e58d3014 	str	r3, [sp, #20]
57e26660:	ebfffead 	bl	57e2611c <adler32>
            state->mode = hold & 0x200 ? DICTID : TYPE;
57e26664:	e3160c02 	tst	r6, #512	; 0x200
            INITBITS();
57e26668:	e59d3014 	ldr	r3, [sp, #20]
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = hold & 0x200 ? DICTID : TYPE;
57e2666c:	03a0200b 	moveq	r2, #11
57e26670:	13a02009 	movne	r2, #9
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
57e26674:	e5840018 	str	r0, [r4, #24]
            state->mode = hold & 0x200 ? DICTID : TYPE;
            INITBITS();
57e26678:	e1a05003 	mov	r5, r3
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
57e2667c:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = hold & 0x200 ? DICTID : TYPE;
57e26680:	e5842000 	str	r2, [r4]
            INITBITS();
57e26684:	e1a06005 	mov	r6, r5
            break;
57e26688:	eaffff81 	b	57e26494 <inflate+0x7c>
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
57e2668c:	e3570000 	cmp	r7, #0
57e26690:	0a00046a 	beq	57e27840 <inflate+0x1428>
57e26694:	e4d32001 	ldrb	r2, [r3], #1
57e26698:	e2477001 	sub	r7, r7, #1
57e2669c:	e0866512 	add	r6, r6, r2, lsl r5
57e266a0:	e2855008 	add	r5, r5, #8
57e266a4:	e355000f 	cmp	r5, #15
57e266a8:	e1a09003 	mov	r9, r3
57e266ac:	9afffff6 	bls	57e2668c <inflate+0x274>
            state->flags = (int)(hold);
            if ((state->flags & 0xff) != Z_DEFLATED) {
57e266b0:	e20630ff 	and	r3, r6, #255	; 0xff
57e266b4:	e3530008 	cmp	r3, #8
            INITBITS();
            break;
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
            state->flags = (int)(hold);
57e266b8:	e5846010 	str	r6, [r4, #16]
            if ((state->flags & 0xff) != Z_DEFLATED) {
57e266bc:	0a000001 	beq	57e266c8 <inflate+0x2b0>
                strm->msg = (char *)"unknown compression method";
57e266c0:	e59f3e5c 	ldr	r3, [pc, #3676]	; 57e27524 <inflate+0x110c>
57e266c4:	ea00044d 	b	57e27800 <inflate+0x13e8>
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
57e266c8:	e3160a0e 	tst	r6, #57344	; 0xe000
                strm->msg = (char *)"unknown header flags set";
57e266cc:	159f3e54 	ldrne	r3, [pc, #3668]	; 57e27528 <inflate+0x1110>
            if ((state->flags & 0xff) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
57e266d0:	1a00044a 	bne	57e27800 <inflate+0x13e8>
                strm->msg = (char *)"unknown header flags set";
                state->mode = BAD;
                break;
            }
            if (state->head != Z_NULL)
57e266d4:	e5943020 	ldr	r3, [r4, #32]
57e266d8:	e3530000 	cmp	r3, #0
                state->head->text = (int)((hold >> 8) & 1);
57e266dc:	11a02426 	lsrne	r2, r6, #8
57e266e0:	12022001 	andne	r2, r2, #1
57e266e4:	15832000 	strne	r2, [r3]
            if (state->flags & 0x0200) CRC2(state->check, hold);
57e266e8:	e3160c02 	tst	r6, #512	; 0x200
57e266ec:	0a000007 	beq	57e26710 <inflate+0x2f8>
57e266f0:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
57e266f4:	e1a06426 	lsr	r6, r6, #8
57e266f8:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
57e266fc:	e5940018 	ldr	r0, [r4, #24]
57e26700:	e28d1044 	add	r1, sp, #68	; 0x44
57e26704:	e3a02002 	mov	r2, #2
57e26708:	ebffeec0 	bl	57e22210 <crc32>
57e2670c:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = TIME;
57e26710:	e3a03002 	mov	r3, #2
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
57e26714:	e3a05000 	mov	r5, #0
            state->mode = TIME;
57e26718:	e5843000 	str	r3, [r4]
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
57e2671c:	e1a06005 	mov	r6, r5
            state->mode = TIME;
57e26720:	e1a03009 	mov	r3, r9
57e26724:	ea000005 	b	57e26740 <inflate+0x328>
        case TIME:
            NEEDBITS(32);
57e26728:	e3570000 	cmp	r7, #0
57e2672c:	0a000443 	beq	57e27840 <inflate+0x1428>
57e26730:	e4d32001 	ldrb	r2, [r3], #1
57e26734:	e2477001 	sub	r7, r7, #1
57e26738:	e0866512 	add	r6, r6, r2, lsl r5
57e2673c:	e2855008 	add	r5, r5, #8
57e26740:	e355001f 	cmp	r5, #31
57e26744:	e1a09003 	mov	r9, r3
57e26748:	9afffff6 	bls	57e26728 <inflate+0x310>
            if (state->head != Z_NULL)
57e2674c:	e5943020 	ldr	r3, [r4, #32]
57e26750:	e3530000 	cmp	r3, #0
                state->head->time = hold;
57e26754:	15836004 	strne	r6, [r3, #4]
            if (state->flags & 0x0200) CRC4(state->check, hold);
57e26758:	e5943010 	ldr	r3, [r4, #16]
57e2675c:	e3130c02 	tst	r3, #512	; 0x200
57e26760:	0a00000b 	beq	57e26794 <inflate+0x37c>
57e26764:	e1a03426 	lsr	r3, r6, #8
57e26768:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
57e2676c:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
57e26770:	e1a03826 	lsr	r3, r6, #16
57e26774:	e1a06c26 	lsr	r6, r6, #24
57e26778:	e5cd3046 	strb	r3, [sp, #70]	; 0x46
57e2677c:	e5cd6047 	strb	r6, [sp, #71]	; 0x47
57e26780:	e5940018 	ldr	r0, [r4, #24]
57e26784:	e28d1044 	add	r1, sp, #68	; 0x44
57e26788:	e3a02004 	mov	r2, #4
57e2678c:	ebffee9f 	bl	57e22210 <crc32>
57e26790:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = OS;
57e26794:	e3a03003 	mov	r3, #3
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
57e26798:	e3a05000 	mov	r5, #0
            state->mode = OS;
57e2679c:	e5843000 	str	r3, [r4]
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
57e267a0:	e1a06005 	mov	r6, r5
            state->mode = OS;
57e267a4:	e1a03009 	mov	r3, r9
57e267a8:	ea000005 	b	57e267c4 <inflate+0x3ac>
        case OS:
            NEEDBITS(16);
57e267ac:	e3570000 	cmp	r7, #0
57e267b0:	0a000422 	beq	57e27840 <inflate+0x1428>
57e267b4:	e4d32001 	ldrb	r2, [r3], #1
57e267b8:	e2477001 	sub	r7, r7, #1
57e267bc:	e0866512 	add	r6, r6, r2, lsl r5
57e267c0:	e2855008 	add	r5, r5, #8
57e267c4:	e355000f 	cmp	r5, #15
57e267c8:	e1a09003 	mov	r9, r3
57e267cc:	9afffff6 	bls	57e267ac <inflate+0x394>
            if (state->head != Z_NULL) {
57e267d0:	e5943020 	ldr	r3, [r4, #32]
57e267d4:	e3530000 	cmp	r3, #0
                state->head->xflags = (int)(hold & 0xff);
57e267d8:	120620ff 	andne	r2, r6, #255	; 0xff
57e267dc:	15832008 	strne	r2, [r3, #8]
                state->head->os = (int)(hold >> 8);
57e267e0:	11a02426 	lsrne	r2, r6, #8
57e267e4:	1583200c 	strne	r2, [r3, #12]
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
57e267e8:	e5943010 	ldr	r3, [r4, #16]
57e267ec:	e3130c02 	tst	r3, #512	; 0x200
57e267f0:	0a000007 	beq	57e26814 <inflate+0x3fc>
57e267f4:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
57e267f8:	e1a06426 	lsr	r6, r6, #8
57e267fc:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
57e26800:	e5940018 	ldr	r0, [r4, #24]
57e26804:	e28d1044 	add	r1, sp, #68	; 0x44
57e26808:	e3a02002 	mov	r2, #2
57e2680c:	ebffee7f 	bl	57e22210 <crc32>
57e26810:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = EXLEN;
57e26814:	e3a03004 	mov	r3, #4
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
57e26818:	e3a05000 	mov	r5, #0
            state->mode = EXLEN;
57e2681c:	e5843000 	str	r3, [r4]
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
57e26820:	e1a06005 	mov	r6, r5
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
57e26824:	e5943010 	ldr	r3, [r4, #16]
57e26828:	e2132b01 	ands	r2, r3, #1024	; 0x400
57e2682c:	11a02009 	movne	r2, r9
57e26830:	1a000006 	bne	57e26850 <inflate+0x438>
57e26834:	ea000019 	b	57e268a0 <inflate+0x488>
                NEEDBITS(16);
57e26838:	e3570000 	cmp	r7, #0
57e2683c:	0a0003ff 	beq	57e27840 <inflate+0x1428>
57e26840:	e4d21001 	ldrb	r1, [r2], #1
57e26844:	e2477001 	sub	r7, r7, #1
57e26848:	e0866511 	add	r6, r6, r1, lsl r5
57e2684c:	e2855008 	add	r5, r5, #8
57e26850:	e355000f 	cmp	r5, #15
57e26854:	e1a09002 	mov	r9, r2
57e26858:	9afffff6 	bls	57e26838 <inflate+0x420>
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
57e2685c:	e5942020 	ldr	r2, [r4, #32]
            INITBITS();
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
57e26860:	e5846040 	str	r6, [r4, #64]	; 0x40
                if (state->head != Z_NULL)
57e26864:	e3520000 	cmp	r2, #0
                    state->head->extra_len = (unsigned)hold;
57e26868:	15826014 	strne	r6, [r2, #20]
                if (state->flags & 0x0200) CRC2(state->check, hold);
57e2686c:	e2133c02 	ands	r3, r3, #512	; 0x200
                INITBITS();
57e26870:	01a06003 	moveq	r6, r3
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
57e26874:	0a00000d 	beq	57e268b0 <inflate+0x498>
57e26878:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
57e2687c:	e1a06426 	lsr	r6, r6, #8
57e26880:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
57e26884:	e5940018 	ldr	r0, [r4, #24]
57e26888:	e28d1044 	add	r1, sp, #68	; 0x44
57e2688c:	e3a02002 	mov	r2, #2
57e26890:	ebffee5e 	bl	57e22210 <crc32>
                INITBITS();
57e26894:	e3a06000 	mov	r6, #0
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
57e26898:	e5840018 	str	r0, [r4, #24]
57e2689c:	ea000003 	b	57e268b0 <inflate+0x498>
                INITBITS();
            }
            else if (state->head != Z_NULL)
57e268a0:	e5943020 	ldr	r3, [r4, #32]
57e268a4:	e3530000 	cmp	r3, #0
                state->head->extra = Z_NULL;
57e268a8:	15832010 	strne	r2, [r3, #16]
57e268ac:	ea000000 	b	57e268b4 <inflate+0x49c>
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
57e268b0:	e1a05006 	mov	r5, r6
            }
            else if (state->head != Z_NULL)
                state->head->extra = Z_NULL;
            state->mode = EXTRA;
57e268b4:	e3a03005 	mov	r3, #5
57e268b8:	e5843000 	str	r3, [r4]
        case EXTRA:
            if (state->flags & 0x0400) {
57e268bc:	e5943010 	ldr	r3, [r4, #16]
57e268c0:	e3130b01 	tst	r3, #1024	; 0x400
57e268c4:	0a000029 	beq	57e26970 <inflate+0x558>
                copy = state->length;
57e268c8:	e5942040 	ldr	r2, [r4, #64]	; 0x40
57e268cc:	e1570002 	cmp	r7, r2
57e268d0:	31a03007 	movcc	r3, r7
57e268d4:	21a03002 	movcs	r3, r2
                if (copy > have) copy = have;
                if (copy) {
57e268d8:	e3530000 	cmp	r3, #0
57e268dc:	0a000020 	beq	57e26964 <inflate+0x54c>
                    if (state->head != Z_NULL &&
57e268e0:	e5941020 	ldr	r1, [r4, #32]
57e268e4:	e3510000 	cmp	r1, #0
57e268e8:	0a00000e 	beq	57e26928 <inflate+0x510>
                        state->head->extra != Z_NULL) {
57e268ec:	e5910010 	ldr	r0, [r1, #16]
        case EXTRA:
            if (state->flags & 0x0400) {
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
57e268f0:	e3500000 	cmp	r0, #0
57e268f4:	0a00000b 	beq	57e26928 <inflate+0x510>
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
57e268f8:	e591c014 	ldr	ip, [r1, #20]
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
57e268fc:	e5911018 	ldr	r1, [r1, #24]
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
57e26900:	e062200c 	rsb	r2, r2, ip
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
57e26904:	e083c002 	add	ip, r3, r2
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
                        zmemcpy(state->head->extra + len, next,
57e26908:	e15c0001 	cmp	ip, r1
57e2690c:	e0800002 	add	r0, r0, r2
57e26910:	80622001 	rsbhi	r2, r2, r1
57e26914:	91a02003 	movls	r2, r3
57e26918:	e1a01009 	mov	r1, r9
57e2691c:	e58d3014 	str	r3, [sp, #20]
57e26920:	ebfff679 	bl	57e2430c <memcpy>
57e26924:	e59d3014 	ldr	r3, [sp, #20]
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
57e26928:	e5942010 	ldr	r2, [r4, #16]
57e2692c:	e3120c02 	tst	r2, #512	; 0x200
57e26930:	0a000006 	beq	57e26950 <inflate+0x538>
                        state->check = crc32(state->check, next, copy);
57e26934:	e5940018 	ldr	r0, [r4, #24]
57e26938:	e1a02003 	mov	r2, r3
57e2693c:	e1a01009 	mov	r1, r9
57e26940:	e58d3014 	str	r3, [sp, #20]
57e26944:	ebffee31 	bl	57e22210 <crc32>
57e26948:	e59d3014 	ldr	r3, [sp, #20]
57e2694c:	e5840018 	str	r0, [r4, #24]
                    have -= copy;
                    next += copy;
                    state->length -= copy;
57e26950:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
                        state->check = crc32(state->check, next, copy);
                    have -= copy;
57e26954:	e0637007 	rsb	r7, r3, r7
                    next += copy;
57e26958:	e0899003 	add	r9, r9, r3
                    state->length -= copy;
57e2695c:	e0633002 	rsb	r3, r3, r2
57e26960:	e5843040 	str	r3, [r4, #64]	; 0x40
                }
                if (state->length) goto inf_leave;
57e26964:	e5943040 	ldr	r3, [r4, #64]	; 0x40
57e26968:	e3530000 	cmp	r3, #0
57e2696c:	1a0003b3 	bne	57e27840 <inflate+0x1428>
            }
            state->length = 0;
57e26970:	e3a03000 	mov	r3, #0
57e26974:	e5843040 	str	r3, [r4, #64]	; 0x40
            state->mode = NAME;
57e26978:	e2833006 	add	r3, r3, #6
57e2697c:	e5843000 	str	r3, [r4]
        case NAME:
            if (state->flags & 0x0800) {
57e26980:	e5942010 	ldr	r2, [r4, #16]
57e26984:	e2122b02 	ands	r2, r2, #2048	; 0x800
57e26988:	0a000024 	beq	57e26a20 <inflate+0x608>
                if (have == 0) goto inf_leave;
57e2698c:	e3570000 	cmp	r7, #0
57e26990:	0a0003aa 	beq	57e27840 <inflate+0x1428>
57e26994:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
57e26998:	e5941020 	ldr	r1, [r4, #32]
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
57e2699c:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
57e269a0:	e3510000 	cmp	r1, #0
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
57e269a4:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
57e269a8:	0a000008 	beq	57e269d0 <inflate+0x5b8>
                            state->head->name != Z_NULL &&
57e269ac:	e591001c 	ldr	r0, [r1, #28]
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
57e269b0:	e3500000 	cmp	r0, #0
57e269b4:	0a000005 	beq	57e269d0 <inflate+0x5b8>
                            state->head->name != Z_NULL &&
                            state->length < state->head->name_max)
57e269b8:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->name != Z_NULL &&
57e269bc:	e5911020 	ldr	r1, [r1, #32]
57e269c0:	e1520001 	cmp	r2, r1
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
57e269c4:	37c0c002 	strbcc	ip, [r0, r2]
57e269c8:	32822001 	addcc	r2, r2, #1
57e269cc:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
57e269d0:	e35c0000 	cmp	ip, #0
57e269d4:	11530007 	cmpne	r3, r7
57e269d8:	3affffee 	bcc	57e26998 <inflate+0x580>
                if (state->flags & 0x0200)
57e269dc:	e5942010 	ldr	r2, [r4, #16]
57e269e0:	e3120c02 	tst	r2, #512	; 0x200
57e269e4:	0a000008 	beq	57e26a0c <inflate+0x5f4>
                    state->check = crc32(state->check, next, copy);
57e269e8:	e5940018 	ldr	r0, [r4, #24]
57e269ec:	e1a02003 	mov	r2, r3
57e269f0:	e1a01009 	mov	r1, r9
57e269f4:	e58d3014 	str	r3, [sp, #20]
57e269f8:	e58dc018 	str	ip, [sp, #24]
57e269fc:	ebffee03 	bl	57e22210 <crc32>
57e26a00:	e59dc018 	ldr	ip, [sp, #24]
57e26a04:	e59d3014 	ldr	r3, [sp, #20]
57e26a08:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
57e26a0c:	e35c0000 	cmp	ip, #0
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
57e26a10:	e0637007 	rsb	r7, r3, r7
                next += copy;
57e26a14:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
57e26a18:	0a000003 	beq	57e26a2c <inflate+0x614>
57e26a1c:	ea000387 	b	57e27840 <inflate+0x1428>
            }
            else if (state->head != Z_NULL)
57e26a20:	e5943020 	ldr	r3, [r4, #32]
57e26a24:	e3530000 	cmp	r3, #0
                state->head->name = Z_NULL;
57e26a28:	1583201c 	strne	r2, [r3, #28]
            state->length = 0;
57e26a2c:	e3a0c000 	mov	ip, #0
            state->mode = COMMENT;
57e26a30:	e3a03007 	mov	r3, #7
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->name = Z_NULL;
            state->length = 0;
57e26a34:	e584c040 	str	ip, [r4, #64]	; 0x40
            state->mode = COMMENT;
57e26a38:	e5843000 	str	r3, [r4]
        case COMMENT:
            if (state->flags & 0x1000) {
57e26a3c:	e5942010 	ldr	r2, [r4, #16]
57e26a40:	e2122a01 	ands	r2, r2, #4096	; 0x1000
57e26a44:	0a000024 	beq	57e26adc <inflate+0x6c4>
                if (have == 0) goto inf_leave;
57e26a48:	e3570000 	cmp	r7, #0
57e26a4c:	0a00037b 	beq	57e27840 <inflate+0x1428>
57e26a50:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
57e26a54:	e5941020 	ldr	r1, [r4, #32]
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
57e26a58:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
57e26a5c:	e3510000 	cmp	r1, #0
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
57e26a60:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
57e26a64:	0a000008 	beq	57e26a8c <inflate+0x674>
                            state->head->comment != Z_NULL &&
57e26a68:	e5910024 	ldr	r0, [r1, #36]	; 0x24
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
57e26a6c:	e3500000 	cmp	r0, #0
57e26a70:	0a000005 	beq	57e26a8c <inflate+0x674>
                            state->head->comment != Z_NULL &&
                            state->length < state->head->comm_max)
57e26a74:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->comment != Z_NULL &&
57e26a78:	e5911028 	ldr	r1, [r1, #40]	; 0x28
57e26a7c:	e1520001 	cmp	r2, r1
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
57e26a80:	37c0c002 	strbcc	ip, [r0, r2]
57e26a84:	32822001 	addcc	r2, r2, #1
57e26a88:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
57e26a8c:	e35c0000 	cmp	ip, #0
57e26a90:	11530007 	cmpne	r3, r7
57e26a94:	3affffee 	bcc	57e26a54 <inflate+0x63c>
                if (state->flags & 0x0200)
57e26a98:	e5942010 	ldr	r2, [r4, #16]
57e26a9c:	e3120c02 	tst	r2, #512	; 0x200
57e26aa0:	0a000008 	beq	57e26ac8 <inflate+0x6b0>
                    state->check = crc32(state->check, next, copy);
57e26aa4:	e5940018 	ldr	r0, [r4, #24]
57e26aa8:	e1a02003 	mov	r2, r3
57e26aac:	e1a01009 	mov	r1, r9
57e26ab0:	e58d3014 	str	r3, [sp, #20]
57e26ab4:	e58dc018 	str	ip, [sp, #24]
57e26ab8:	ebffedd4 	bl	57e22210 <crc32>
57e26abc:	e59dc018 	ldr	ip, [sp, #24]
57e26ac0:	e59d3014 	ldr	r3, [sp, #20]
57e26ac4:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
57e26ac8:	e35c0000 	cmp	ip, #0
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
57e26acc:	e0637007 	rsb	r7, r3, r7
                next += copy;
57e26ad0:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
57e26ad4:	0a000003 	beq	57e26ae8 <inflate+0x6d0>
57e26ad8:	ea000358 	b	57e27840 <inflate+0x1428>
            }
            else if (state->head != Z_NULL)
57e26adc:	e5943020 	ldr	r3, [r4, #32]
57e26ae0:	e3530000 	cmp	r3, #0
                state->head->comment = Z_NULL;
57e26ae4:	15832024 	strne	r2, [r3, #36]	; 0x24
            state->mode = HCRC;
57e26ae8:	e3a03008 	mov	r3, #8
57e26aec:	e5843000 	str	r3, [r4]
        case HCRC:
            if (state->flags & 0x0200) {
57e26af0:	e5942010 	ldr	r2, [r4, #16]
57e26af4:	e3120c02 	tst	r2, #512	; 0x200
57e26af8:	11a03009 	movne	r3, r9
57e26afc:	1a000006 	bne	57e26b1c <inflate+0x704>
57e26b00:	ea00000e 	b	57e26b40 <inflate+0x728>
                NEEDBITS(16);
57e26b04:	e3570000 	cmp	r7, #0
57e26b08:	0a00034c 	beq	57e27840 <inflate+0x1428>
57e26b0c:	e4d31001 	ldrb	r1, [r3], #1
57e26b10:	e2477001 	sub	r7, r7, #1
57e26b14:	e0866511 	add	r6, r6, r1, lsl r5
57e26b18:	e2855008 	add	r5, r5, #8
57e26b1c:	e355000f 	cmp	r5, #15
57e26b20:	e1a09003 	mov	r9, r3
57e26b24:	9afffff6 	bls	57e26b04 <inflate+0x6ec>
                if (hold != (state->check & 0xffff)) {
57e26b28:	e1d431b8 	ldrh	r3, [r4, #24]
57e26b2c:	e1560003 	cmp	r6, r3
                    strm->msg = (char *)"header crc mismatch";
57e26b30:	159f39f4 	ldrne	r3, [pc, #2548]	; 57e2752c <inflate+0x1114>
                state->head->comment = Z_NULL;
            state->mode = HCRC;
        case HCRC:
            if (state->flags & 0x0200) {
                NEEDBITS(16);
                if (hold != (state->check & 0xffff)) {
57e26b34:	1a000331 	bne	57e27800 <inflate+0x13e8>
                    strm->msg = (char *)"header crc mismatch";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
57e26b38:	e3a05000 	mov	r5, #0
57e26b3c:	e1a06005 	mov	r6, r5
            }
            if (state->head != Z_NULL) {
57e26b40:	e5943020 	ldr	r3, [r4, #32]
57e26b44:	e3530000 	cmp	r3, #0
                state->head->hcrc = (int)((state->flags >> 9) & 1);
57e26b48:	11a024c2 	asrne	r2, r2, #9
                state->head->done = 1;
57e26b4c:	13a00001 	movne	r0, #1
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
57e26b50:	12022001 	andne	r2, r2, #1
                state->head->done = 1;
57e26b54:	15830030 	strne	r0, [r3, #48]	; 0x30
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
57e26b58:	e3a00000 	mov	r0, #0
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
57e26b5c:	1583202c 	strne	r2, [r3, #44]	; 0x2c
                state->head->done = 1;
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
57e26b60:	e1a01000 	mov	r1, r0
57e26b64:	e1a02000 	mov	r2, r0
57e26b68:	ebffeda8 	bl	57e22210 <crc32>
57e26b6c:	e5840018 	str	r0, [r4, #24]
57e26b70:	e58a0034 	str	r0, [sl, #52]	; 0x34
57e26b74:	ea0001f6 	b	57e27354 <inflate+0xf3c>
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
57e26b78:	e3570000 	cmp	r7, #0
57e26b7c:	0a00032f 	beq	57e27840 <inflate+0x1428>
57e26b80:	e4d32001 	ldrb	r2, [r3], #1
57e26b84:	e2477001 	sub	r7, r7, #1
57e26b88:	e0866512 	add	r6, r6, r2, lsl r5
57e26b8c:	e2855008 	add	r5, r5, #8
57e26b90:	e355001f 	cmp	r5, #31
57e26b94:	e1a09003 	mov	r9, r3
57e26b98:	9afffff6 	bls	57e26b78 <inflate+0x760>
            strm->adler = state->check = REVERSE(hold);
57e26b9c:	e1a02c26 	lsr	r2, r6, #24
57e26ba0:	e1a03426 	lsr	r3, r6, #8
57e26ba4:	e0822c06 	add	r2, r2, r6, lsl #24
57e26ba8:	e2033cff 	and	r3, r3, #65280	; 0xff00
57e26bac:	e2066cff 	and	r6, r6, #65280	; 0xff00
57e26bb0:	e0823003 	add	r3, r2, r3
57e26bb4:	e0833406 	add	r3, r3, r6, lsl #8
57e26bb8:	e5843018 	str	r3, [r4, #24]
            INITBITS();
57e26bbc:	e3a06000 	mov	r6, #0
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
57e26bc0:	e58a3034 	str	r3, [sl, #52]	; 0x34
            INITBITS();
            state->mode = DICT;
57e26bc4:	e3a0300a 	mov	r3, #10
57e26bc8:	e5843000 	str	r3, [r4]
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
57e26bcc:	e1a05006 	mov	r5, r6
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
57e26bd0:	e594300c 	ldr	r3, [r4, #12]
57e26bd4:	e3530000 	cmp	r3, #0
57e26bd8:	1a000008 	bne	57e26c00 <inflate+0x7e8>
                RESTORE();
57e26bdc:	e59d1020 	ldr	r1, [sp, #32]
57e26be0:	e58ab010 	str	fp, [sl, #16]
57e26be4:	e58a100c 	str	r1, [sl, #12]
57e26be8:	e58a9000 	str	r9, [sl]
57e26bec:	e58a7004 	str	r7, [sl, #4]
                return Z_NEED_DICT;
57e26bf0:	e3a02002 	mov	r2, #2
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
57e26bf4:	e5846038 	str	r6, [r4, #56]	; 0x38
57e26bf8:	e584503c 	str	r5, [r4, #60]	; 0x3c
57e26bfc:	ea0003a4 	b	57e27a94 <inflate+0x167c>
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
57e26c00:	e3a00000 	mov	r0, #0
57e26c04:	e1a01000 	mov	r1, r0
57e26c08:	e1a02000 	mov	r2, r0
57e26c0c:	ebfffd42 	bl	57e2611c <adler32>
            state->mode = TYPE;
57e26c10:	e3a0300b 	mov	r3, #11
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
57e26c14:	e5840018 	str	r0, [r4, #24]
57e26c18:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = TYPE;
57e26c1c:	e5843000 	str	r3, [r4]
        case TYPE:
	    WATCHDOG_RESET();
            if (flush == Z_BLOCK) goto inf_leave;
57e26c20:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
57e26c24:	e3530005 	cmp	r3, #5
57e26c28:	0a000304 	beq	57e27840 <inflate+0x1428>
        case TYPEDO:
            if (state->last) {
57e26c2c:	e5943004 	ldr	r3, [r4, #4]
57e26c30:	e3530000 	cmp	r3, #0
57e26c34:	01a03009 	moveq	r3, r9
57e26c38:	0a00000a 	beq	57e26c68 <inflate+0x850>
                BYTEBITS();
57e26c3c:	e2053007 	and	r3, r5, #7
57e26c40:	e1a06336 	lsr	r6, r6, r3
57e26c44:	e3c55007 	bic	r5, r5, #7
                state->mode = CHECK;
57e26c48:	e3a03018 	mov	r3, #24
57e26c4c:	ea0002ed 	b	57e27808 <inflate+0x13f0>
                break;
            }
            NEEDBITS(3);
57e26c50:	e3570000 	cmp	r7, #0
57e26c54:	0a0002f9 	beq	57e27840 <inflate+0x1428>
57e26c58:	e4d32001 	ldrb	r2, [r3], #1
57e26c5c:	e2477001 	sub	r7, r7, #1
57e26c60:	e0866512 	add	r6, r6, r2, lsl r5
57e26c64:	e2855008 	add	r5, r5, #8
57e26c68:	e3550002 	cmp	r5, #2
57e26c6c:	e1a09003 	mov	r9, r3
57e26c70:	9afffff6 	bls	57e26c50 <inflate+0x838>
            state->last = BITS(1);
57e26c74:	e2063001 	and	r3, r6, #1
            DROPBITS(1);
57e26c78:	e1a060a6 	lsr	r6, r6, #1
                BYTEBITS();
                state->mode = CHECK;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
57e26c7c:	e5843004 	str	r3, [r4, #4]
            DROPBITS(1);
            switch (BITS(2)) {
57e26c80:	e2063003 	and	r3, r6, #3
57e26c84:	e3530002 	cmp	r3, #2
                state->mode = LEN;              /* decode codes */
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
57e26c88:	03a0300f 	moveq	r3, #15
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
57e26c8c:	0a000010 	beq	57e26cd4 <inflate+0x8bc>
57e26c90:	e3530003 	cmp	r3, #3
57e26c94:	0a00000b 	beq	57e26cc8 <inflate+0x8b0>
57e26c98:	e3530001 	cmp	r3, #1
}

local void fixedtables(struct inflate_state FAR *state)
{
    state->lencode = lenfix;
    state->lenbits = 9;
57e26c9c:	03a03009 	moveq	r3, #9
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
}

local void fixedtables(struct inflate_state FAR *state)
{
    state->lencode = lenfix;
57e26ca0:	059fc888 	ldreq	ip, [pc, #2184]	; 57e27530 <inflate+0x1118>
    state->lenbits = 9;
    state->distcode = distfix;
57e26ca4:	059f0888 	ldreq	r0, [pc, #2184]	; 57e27534 <inflate+0x111c>
}

local void fixedtables(struct inflate_state FAR *state)
{
    state->lencode = lenfix;
    state->lenbits = 9;
57e26ca8:	05843054 	streq	r3, [r4, #84]	; 0x54
    state->distcode = distfix;
    state->distbits = 5;
57e26cac:	03a03005 	moveq	r3, #5
57e26cb0:	05843058 	streq	r3, [r4, #88]	; 0x58
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
57e26cb4:	13a0300d 	movne	r3, #13
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
}

local void fixedtables(struct inflate_state FAR *state)
{
    state->lencode = lenfix;
57e26cb8:	0584c04c 	streq	ip, [r4, #76]	; 0x4c
    state->lenbits = 9;
    state->distcode = distfix;
57e26cbc:	05840050 	streq	r0, [r4, #80]	; 0x50
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN;              /* decode codes */
57e26cc0:	0283300d 	addeq	r3, r3, #13
57e26cc4:	ea000002 	b	57e26cd4 <inflate+0x8bc>
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
57e26cc8:	e59f3868 	ldr	r3, [pc, #2152]	; 57e27538 <inflate+0x1120>
57e26ccc:	e58a3018 	str	r3, [sl, #24]
                state->mode = BAD;
57e26cd0:	e3a0301b 	mov	r3, #27
57e26cd4:	e5843000 	str	r3, [r4]
            }
            DROPBITS(2);
57e26cd8:	e1a06126 	lsr	r6, r6, #2
57e26cdc:	e2455003 	sub	r5, r5, #3
            break;
57e26ce0:	eafffdeb 	b	57e26494 <inflate+0x7c>
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
57e26ce4:	e2053007 	and	r3, r5, #7
57e26ce8:	e1a06336 	lsr	r6, r6, r3
57e26cec:	e3c55007 	bic	r5, r5, #7
57e26cf0:	e1a03009 	mov	r3, r9
            NEEDBITS(32);
57e26cf4:	ea000005 	b	57e26d10 <inflate+0x8f8>
57e26cf8:	e3570000 	cmp	r7, #0
57e26cfc:	0a0002cf 	beq	57e27840 <inflate+0x1428>
57e26d00:	e4d32001 	ldrb	r2, [r3], #1
57e26d04:	e2477001 	sub	r7, r7, #1
57e26d08:	e0866512 	add	r6, r6, r2, lsl r5
57e26d0c:	e2855008 	add	r5, r5, #8
57e26d10:	e355001f 	cmp	r5, #31
57e26d14:	e1a09003 	mov	r9, r3
57e26d18:	9afffff6 	bls	57e26cf8 <inflate+0x8e0>
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
57e26d1c:	e1a02826 	lsr	r2, r6, #16
57e26d20:	e1a03806 	lsl	r3, r6, #16
57e26d24:	e2222cff 	eor	r2, r2, #65280	; 0xff00
57e26d28:	e1a03823 	lsr	r3, r3, #16
57e26d2c:	e22220ff 	eor	r2, r2, #255	; 0xff
57e26d30:	e1530002 	cmp	r3, r2
                strm->msg = (char *)"invalid stored block lengths";
57e26d34:	159f3800 	ldrne	r3, [pc, #2048]	; 57e2753c <inflate+0x1124>
            DROPBITS(2);
            break;
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
57e26d38:	1a0002b0 	bne	57e27800 <inflate+0x13e8>
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
57e26d3c:	e5843040 	str	r3, [r4, #64]	; 0x40
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
57e26d40:	e3a05000 	mov	r5, #0
            state->mode = COPY;
57e26d44:	e3a0300e 	mov	r3, #14
57e26d48:	e5843000 	str	r3, [r4]
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
57e26d4c:	e1a06005 	mov	r6, r5
            state->mode = COPY;
        case COPY:
            copy = state->length;
57e26d50:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy) {
57e26d54:	e3530000 	cmp	r3, #0
57e26d58:	0a00017d 	beq	57e27354 <inflate+0xf3c>
57e26d5c:	e15b0003 	cmp	fp, r3
57e26d60:	31a0300b 	movcc	r3, fp
57e26d64:	e1530007 	cmp	r3, r7
57e26d68:	21a03007 	movcs	r3, r7
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
57e26d6c:	e3530000 	cmp	r3, #0
57e26d70:	0a0002b2 	beq	57e27840 <inflate+0x1428>
                zmemcpy(put, next, copy);
57e26d74:	e1a01009 	mov	r1, r9
57e26d78:	e1a02003 	mov	r2, r3
57e26d7c:	e59d0020 	ldr	r0, [sp, #32]
57e26d80:	e58d3014 	str	r3, [sp, #20]
57e26d84:	ebfff560 	bl	57e2430c <memcpy>
                have -= copy;
57e26d88:	e59d3014 	ldr	r3, [sp, #20]
                next += copy;
                left -= copy;
                put += copy;
57e26d8c:	e59d1020 	ldr	r1, [sp, #32]
                state->length -= copy;
57e26d90:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
57e26d94:	e0811003 	add	r1, r1, r3
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
57e26d98:	e0637007 	rsb	r7, r3, r7
                next += copy;
57e26d9c:	e0899003 	add	r9, r9, r3
                left -= copy;
57e26da0:	e063b00b 	rsb	fp, r3, fp
                put += copy;
                state->length -= copy;
57e26da4:	e0633002 	rsb	r3, r3, r2
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
57e26da8:	e58d1020 	str	r1, [sp, #32]
                state->length -= copy;
57e26dac:	e5843040 	str	r3, [r4, #64]	; 0x40
                break;
57e26db0:	eafffdb7 	b	57e26494 <inflate+0x7c>
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
57e26db4:	e3570000 	cmp	r7, #0
57e26db8:	0a0002a0 	beq	57e27840 <inflate+0x1428>
57e26dbc:	e4d32001 	ldrb	r2, [r3], #1
57e26dc0:	e2477001 	sub	r7, r7, #1
57e26dc4:	e0866512 	add	r6, r6, r2, lsl r5
57e26dc8:	e2855008 	add	r5, r5, #8
57e26dcc:	e355000d 	cmp	r5, #13
57e26dd0:	e1a09003 	mov	r9, r3
57e26dd4:	9afffff6 	bls	57e26db4 <inflate+0x99c>
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
57e26dd8:	e1a01526 	lsr	r1, r6, #10
            state->ncode = BITS(4) + 4;
57e26ddc:	e201100f 	and	r1, r1, #15
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
57e26de0:	e206201f 	and	r2, r6, #31
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
57e26de4:	e2811004 	add	r1, r1, #4
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
57e26de8:	e1a032a6 	lsr	r3, r6, #5
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
57e26dec:	e2822c01 	add	r2, r2, #256	; 0x100
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
57e26df0:	e584105c 	str	r1, [r4, #92]	; 0x5c
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
57e26df4:	e59f1744 	ldr	r1, [pc, #1860]	; 57e27540 <inflate+0x1128>
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
57e26df8:	e2822001 	add	r2, r2, #1
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
57e26dfc:	e203301f 	and	r3, r3, #31
57e26e00:	e2833001 	add	r3, r3, #1
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
57e26e04:	e1520001 	cmp	r2, r1
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
57e26e08:	e5842060 	str	r2, [r4, #96]	; 0x60
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
57e26e0c:	e5843064 	str	r3, [r4, #100]	; 0x64
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
57e26e10:	e1a06726 	lsr	r6, r6, #14
57e26e14:	e245500e 	sub	r5, r5, #14
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
57e26e18:	8a000001 	bhi	57e26e24 <inflate+0xa0c>
57e26e1c:	e353001e 	cmp	r3, #30
57e26e20:	9a000001 	bls	57e26e2c <inflate+0xa14>
                strm->msg = (char *)"too many length or distance symbols";
57e26e24:	e59f3718 	ldr	r3, [pc, #1816]	; 57e27544 <inflate+0x112c>
57e26e28:	ea000274 	b	57e27800 <inflate+0x13e8>
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
57e26e2c:	e3a02000 	mov	r2, #0
            state->mode = LENLENS;
57e26e30:	e3a03010 	mov	r3, #16
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
57e26e34:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = LENLENS;
57e26e38:	e5843000 	str	r3, [r4]
        case LENLENS:
            while (state->have < state->ncode) {
57e26e3c:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
57e26e40:	ea000013 	b	57e26e94 <inflate+0xa7c>
                NEEDBITS(3);
57e26e44:	e3570000 	cmp	r7, #0
57e26e48:	0a00027c 	beq	57e27840 <inflate+0x1428>
57e26e4c:	e4d10001 	ldrb	r0, [r1], #1
57e26e50:	e2477001 	sub	r7, r7, #1
57e26e54:	e0866510 	add	r6, r6, r0, lsl r5
57e26e58:	e2855008 	add	r5, r5, #8
57e26e5c:	e3550002 	cmp	r5, #2
57e26e60:	e1a09001 	mov	r9, r1
57e26e64:	9afffff6 	bls	57e26e44 <inflate+0xa2c>
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
57e26e68:	e59fc6d8 	ldr	ip, [pc, #1752]	; 57e27548 <inflate+0x1130>
57e26e6c:	e2060007 	and	r0, r6, #7
57e26e70:	e08c1083 	add	r1, ip, r3, lsl #1
57e26e74:	e2811d26 	add	r1, r1, #2432	; 0x980
57e26e78:	e1d110b0 	ldrh	r1, [r1]
57e26e7c:	e2833001 	add	r3, r3, #1
57e26e80:	e0841081 	add	r1, r4, r1, lsl #1
57e26e84:	e1c107b0 	strh	r0, [r1, #112]	; 0x70
57e26e88:	e5843068 	str	r3, [r4, #104]	; 0x68
                DROPBITS(3);
57e26e8c:	e1a061a6 	lsr	r6, r6, #3
57e26e90:	e2455003 	sub	r5, r5, #3
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
            state->mode = LENLENS;
        case LENLENS:
            while (state->have < state->ncode) {
57e26e94:	e5943068 	ldr	r3, [r4, #104]	; 0x68
57e26e98:	e1530002 	cmp	r3, r2
57e26e9c:	2a00000a 	bcs	57e26ecc <inflate+0xab4>
57e26ea0:	e1a01009 	mov	r1, r9
57e26ea4:	eaffffec 	b	57e26e5c <inflate+0xa44>
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
57e26ea8:	e59f0698 	ldr	r0, [pc, #1688]	; 57e27548 <inflate+0x1130>
57e26eac:	e3a01000 	mov	r1, #0
57e26eb0:	e0802083 	add	r2, r0, r3, lsl #1
57e26eb4:	e2822d26 	add	r2, r2, #2432	; 0x980
57e26eb8:	e1d220b0 	ldrh	r2, [r2]
57e26ebc:	e2833001 	add	r3, r3, #1
57e26ec0:	e0842082 	add	r2, r4, r2, lsl #1
57e26ec4:	e1c217b0 	strh	r1, [r2, #112]	; 0x70
57e26ec8:	e5843068 	str	r3, [r4, #104]	; 0x68
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
57e26ecc:	e5943068 	ldr	r3, [r4, #104]	; 0x68
57e26ed0:	e3530012 	cmp	r3, #18
57e26ed4:	9afffff3 	bls	57e26ea8 <inflate+0xa90>
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
57e26ed8:	e2843e53 	add	r3, r4, #1328	; 0x530
57e26edc:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
57e26ee0:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 7;
57e26ee4:	e3a03007 	mov	r3, #7
57e26ee8:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
57e26eec:	e2843054 	add	r3, r4, #84	; 0x54
57e26ef0:	e58d3000 	str	r3, [sp]
57e26ef4:	e2843e2f 	add	r3, r4, #752	; 0x2f0
57e26ef8:	e58d3004 	str	r3, [sp, #4]
57e26efc:	e3a00000 	mov	r0, #0
57e26f00:	e284306c 	add	r3, r4, #108	; 0x6c
57e26f04:	e2841070 	add	r1, r4, #112	; 0x70
57e26f08:	e3a02013 	mov	r2, #19
57e26f0c:	ebfffaa3 	bl	57e259a0 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
57e26f10:	e3500000 	cmp	r0, #0
57e26f14:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid code lengths set";
57e26f18:	159f362c 	ldrne	r3, [pc, #1580]	; 57e2754c <inflate+0x1134>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
57e26f1c:	1a000237 	bne	57e27800 <inflate+0x13e8>
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
57e26f20:	e59d201c 	ldr	r2, [sp, #28]
            state->mode = CODELENS;
57e26f24:	e3a03011 	mov	r3, #17
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
57e26f28:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = CODELENS;
57e26f2c:	e5843000 	str	r3, [r4]
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
57e26f30:	e5942064 	ldr	r2, [r4, #100]	; 0x64
57e26f34:	e5943060 	ldr	r3, [r4, #96]	; 0x60
57e26f38:	e0823003 	add	r3, r2, r3
57e26f3c:	e58d3024 	str	r3, [sp, #36]	; 0x24
57e26f40:	ea000075 	b	57e2711c <inflate+0xd04>
                for (;;) {
                    this = state->lencode[BITS(state->lenbits)];
57e26f44:	e5943054 	ldr	r3, [r4, #84]	; 0x54
57e26f48:	e3a00001 	mov	r0, #1
57e26f4c:	e1a03310 	lsl	r3, r0, r3
57e26f50:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
57e26f54:	e2433001 	sub	r3, r3, #1
57e26f58:	e58d3028 	str	r3, [sp, #40]	; 0x28
57e26f5c:	e1a02009 	mov	r2, r9
57e26f60:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
57e26f64:	e1a09002 	mov	r9, r2
57e26f68:	e0060003 	and	r0, r6, r3
57e26f6c:	e08c0100 	add	r0, ip, r0, lsl #2
57e26f70:	e5d03001 	ldrb	r3, [r0, #1]
57e26f74:	e1d000b2 	ldrh	r0, [r0, #2]
                    if ((unsigned)(this.bits) <= bits) break;
57e26f78:	e1530005 	cmp	r3, r5
57e26f7c:	9a000006 	bls	57e26f9c <inflate+0xb84>
                    PULLBYTE();
57e26f80:	e3570000 	cmp	r7, #0
57e26f84:	0a00022d 	beq	57e27840 <inflate+0x1428>
57e26f88:	e4d23001 	ldrb	r3, [r2], #1
57e26f8c:	e2477001 	sub	r7, r7, #1
57e26f90:	e0866513 	add	r6, r6, r3, lsl r5
57e26f94:	e2855008 	add	r5, r5, #8
                }
57e26f98:	eafffff0 	b	57e26f60 <inflate+0xb48>
                if (this.val < 16) {
57e26f9c:	e350000f 	cmp	r0, #15
57e26fa0:	8a000010 	bhi	57e26fe8 <inflate+0xbd0>
57e26fa4:	ea000005 	b	57e26fc0 <inflate+0xba8>
                    NEEDBITS(this.bits);
57e26fa8:	e3570000 	cmp	r7, #0
57e26fac:	0a000223 	beq	57e27840 <inflate+0x1428>
57e26fb0:	e4d2c001 	ldrb	ip, [r2], #1
57e26fb4:	e2477001 	sub	r7, r7, #1
57e26fb8:	e086651c 	add	r6, r6, ip, lsl r5
57e26fbc:	e2855008 	add	r5, r5, #8
57e26fc0:	e1550003 	cmp	r5, r3
57e26fc4:	e1a09002 	mov	r9, r2
57e26fc8:	3afffff6 	bcc	57e26fa8 <inflate+0xb90>
                    DROPBITS(this.bits);
57e26fcc:	e1a06336 	lsr	r6, r6, r3
57e26fd0:	e0635005 	rsb	r5, r3, r5
                    state->lens[state->have++] = this.val;
57e26fd4:	e0843081 	add	r3, r4, r1, lsl #1
57e26fd8:	e2811001 	add	r1, r1, #1
57e26fdc:	e1c307b0 	strh	r0, [r3, #112]	; 0x70
57e26fe0:	e5841068 	str	r1, [r4, #104]	; 0x68
57e26fe4:	ea00004c 	b	57e2711c <inflate+0xd04>
                }
                else {
                    if (this.val == 16) {
57e26fe8:	e3500010 	cmp	r0, #16
                        NEEDBITS(this.bits + 2);
57e26fec:	02830002 	addeq	r0, r3, #2
                    NEEDBITS(this.bits);
                    DROPBITS(this.bits);
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
57e26ff0:	1a000014 	bne	57e27048 <inflate+0xc30>
57e26ff4:	ea000005 	b	57e27010 <inflate+0xbf8>
                        NEEDBITS(this.bits + 2);
57e26ff8:	e3570000 	cmp	r7, #0
57e26ffc:	0a00020f 	beq	57e27840 <inflate+0x1428>
57e27000:	e4d2c001 	ldrb	ip, [r2], #1
57e27004:	e2477001 	sub	r7, r7, #1
57e27008:	e086651c 	add	r6, r6, ip, lsl r5
57e2700c:	e2855008 	add	r5, r5, #8
57e27010:	e1550000 	cmp	r5, r0
57e27014:	e1a09002 	mov	r9, r2
57e27018:	3afffff6 	bcc	57e26ff8 <inflate+0xbe0>
                        DROPBITS(this.bits);
                        if (state->have == 0) {
57e2701c:	e3510000 	cmp	r1, #0
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
                        NEEDBITS(this.bits + 2);
                        DROPBITS(this.bits);
57e27020:	e1a06336 	lsr	r6, r6, r3
57e27024:	e0635005 	rsb	r5, r3, r5
                        if (state->have == 0) {
57e27028:	0a00002f 	beq	57e270ec <inflate+0xcd4>
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
57e2702c:	e2062003 	and	r2, r6, #3
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
57e27030:	e0843081 	add	r3, r4, r1, lsl #1
57e27034:	e1d336be 	ldrh	r3, [r3, #110]	; 0x6e
                        copy = 3 + BITS(2);
57e27038:	e2822003 	add	r2, r2, #3
                        DROPBITS(2);
57e2703c:	e1a06126 	lsr	r6, r6, #2
57e27040:	e2455002 	sub	r5, r5, #2
57e27044:	ea000024 	b	57e270dc <inflate+0xcc4>
                    }
                    else if (this.val == 17) {
57e27048:	e3500011 	cmp	r0, #17
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
57e2704c:	12830007 	addne	r0, r3, #7
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
57e27050:	02830003 	addeq	r0, r3, #3
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
57e27054:	1a000015 	bne	57e270b0 <inflate+0xc98>
57e27058:	ea000005 	b	57e27074 <inflate+0xc5c>
                        NEEDBITS(this.bits + 3);
57e2705c:	e3570000 	cmp	r7, #0
57e27060:	0a0001f6 	beq	57e27840 <inflate+0x1428>
57e27064:	e4d2c001 	ldrb	ip, [r2], #1
57e27068:	e2477001 	sub	r7, r7, #1
57e2706c:	e086651c 	add	r6, r6, ip, lsl r5
57e27070:	e2855008 	add	r5, r5, #8
57e27074:	e1550000 	cmp	r5, r0
57e27078:	e1a09002 	mov	r9, r2
57e2707c:	3afffff6 	bcc	57e2705c <inflate+0xc44>
                        DROPBITS(this.bits);
57e27080:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 3 + BITS(3);
57e27084:	e2062007 	and	r2, r6, #7
57e27088:	e2822003 	add	r2, r2, #3
                        DROPBITS(3);
57e2708c:	e1a061a6 	lsr	r6, r6, #3
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
                        DROPBITS(this.bits);
57e27090:	e3e00002 	mvn	r0, #2
57e27094:	ea00000d 	b	57e270d0 <inflate+0xcb8>
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
57e27098:	e3570000 	cmp	r7, #0
57e2709c:	0a0001e7 	beq	57e27840 <inflate+0x1428>
57e270a0:	e4d2c001 	ldrb	ip, [r2], #1
57e270a4:	e2477001 	sub	r7, r7, #1
57e270a8:	e086651c 	add	r6, r6, ip, lsl r5
57e270ac:	e2855008 	add	r5, r5, #8
57e270b0:	e1550000 	cmp	r5, r0
57e270b4:	e1a09002 	mov	r9, r2
57e270b8:	3afffff6 	bcc	57e27098 <inflate+0xc80>
                        DROPBITS(this.bits);
57e270bc:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 11 + BITS(7);
57e270c0:	e206207f 	and	r2, r6, #127	; 0x7f
57e270c4:	e282200b 	add	r2, r2, #11
                        DROPBITS(7);
57e270c8:	e1a063a6 	lsr	r6, r6, #7
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
57e270cc:	e3e00006 	mvn	r0, #6
57e270d0:	e0630000 	rsb	r0, r3, r0
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
57e270d4:	e0855000 	add	r5, r5, r0
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
                        len = 0;
57e270d8:	e3a03000 	mov	r3, #0
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
57e270dc:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
57e270e0:	e0821001 	add	r1, r2, r1
57e270e4:	e151000c 	cmp	r1, ip
57e270e8:	9a000004 	bls	57e27100 <inflate+0xce8>
                        strm->msg = (char *)"invalid bit length repeat";
57e270ec:	e59f345c 	ldr	r3, [pc, #1116]	; 57e27550 <inflate+0x1138>
57e270f0:	e58a3018 	str	r3, [sl, #24]
                        state->mode = BAD;
57e270f4:	e3a0301b 	mov	r3, #27
57e270f8:	e5843000 	str	r3, [r4]
                        break;
57e270fc:	ea00000a 	b	57e2712c <inflate+0xd14>
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
57e27100:	e5941068 	ldr	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
57e27104:	e2522001 	subs	r2, r2, #1
                        state->lens[state->have++] = (unsigned short)len;
57e27108:	e0840081 	add	r0, r4, r1, lsl #1
57e2710c:	e2811001 	add	r1, r1, #1
57e27110:	e1c037b0 	strh	r3, [r0, #112]	; 0x70
57e27114:	e5841068 	str	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
57e27118:	1afffff8 	bne	57e27100 <inflate+0xce8>
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
            state->mode = CODELENS;
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
57e2711c:	e5941068 	ldr	r1, [r4, #104]	; 0x68
57e27120:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
57e27124:	e1510000 	cmp	r1, r0
57e27128:	3affff85 	bcc	57e26f44 <inflate+0xb2c>
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;
57e2712c:	e5943000 	ldr	r3, [r4]
57e27130:	e353001b 	cmp	r3, #27
57e27134:	0afffcd6 	beq	57e26494 <inflate+0x7c>

            /* build code tables */
            state->next = state->codes;
57e27138:	e2843e53 	add	r3, r4, #1328	; 0x530
57e2713c:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
57e27140:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 9;
57e27144:	e3a03009 	mov	r3, #9
57e27148:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
57e2714c:	e284ce2f 	add	ip, r4, #752	; 0x2f0
57e27150:	e284106c 	add	r1, r4, #108	; 0x6c
57e27154:	e2843054 	add	r3, r4, #84	; 0x54
57e27158:	e58d1024 	str	r1, [sp, #36]	; 0x24
57e2715c:	e88d1008 	stm	sp, {r3, ip}
57e27160:	e5942060 	ldr	r2, [r4, #96]	; 0x60
57e27164:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e27168:	e3a00001 	mov	r0, #1
57e2716c:	e2841070 	add	r1, r4, #112	; 0x70
57e27170:	e58dc018 	str	ip, [sp, #24]
57e27174:	ebfffa09 	bl	57e259a0 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
57e27178:	e3500000 	cmp	r0, #0
57e2717c:	e58d001c 	str	r0, [sp, #28]
57e27180:	e59dc018 	ldr	ip, [sp, #24]
                strm->msg = (char *)"invalid literal/lengths set";
57e27184:	159f33c8 	ldrne	r3, [pc, #968]	; 57e27554 <inflate+0x113c>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
57e27188:	1a00019c 	bne	57e27800 <inflate+0x13e8>
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
57e2718c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
57e27190:	e5941060 	ldr	r1, [r4, #96]	; 0x60
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
57e27194:	e5843050 	str	r3, [r4, #80]	; 0x50
            state->distbits = 6;
57e27198:	e3a03006 	mov	r3, #6
57e2719c:	e5843058 	str	r3, [r4, #88]	; 0x58
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
57e271a0:	e2843058 	add	r3, r4, #88	; 0x58
57e271a4:	e88d1008 	stm	sp, {r3, ip}
57e271a8:	e2811038 	add	r1, r1, #56	; 0x38
57e271ac:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
57e271b0:	e3a00002 	mov	r0, #2
57e271b4:	e0841081 	add	r1, r4, r1, lsl #1
57e271b8:	e5942064 	ldr	r2, [r4, #100]	; 0x64
57e271bc:	ebfff9f7 	bl	57e259a0 <inflate_table>
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
57e271c0:	e3500000 	cmp	r0, #0
57e271c4:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid distances set";
57e271c8:	159f3388 	ldrne	r3, [pc, #904]	; 57e27558 <inflate+0x1140>
            }
            state->distcode = (code const FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
57e271cc:	1a00018b 	bne	57e27800 <inflate+0x13e8>
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
57e271d0:	e3a03012 	mov	r3, #18
57e271d4:	e5843000 	str	r3, [r4]
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
57e271d8:	e59f337c 	ldr	r3, [pc, #892]	; 57e2755c <inflate+0x1144>
57e271dc:	e3570005 	cmp	r7, #5
57e271e0:	815b0003 	cmphi	fp, r3
57e271e4:	9a000011 	bls	57e27230 <inflate+0xe18>
                RESTORE();
57e271e8:	e59d2020 	ldr	r2, [sp, #32]
57e271ec:	e58ab010 	str	fp, [sl, #16]
57e271f0:	e58a9000 	str	r9, [sl]
57e271f4:	e58a7004 	str	r7, [sl, #4]
57e271f8:	e58a200c 	str	r2, [sl, #12]
                inflate_fast(strm, out);
57e271fc:	e1a0000a 	mov	r0, sl
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
                RESTORE();
57e27200:	e5846038 	str	r6, [r4, #56]	; 0x38
57e27204:	e584503c 	str	r5, [r4, #60]	; 0x3c
                inflate_fast(strm, out);
57e27208:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
57e2720c:	ebfff886 	bl	57e2542c <inflate_fast>
                LOAD();
57e27210:	e59a300c 	ldr	r3, [sl, #12]
57e27214:	e59ab010 	ldr	fp, [sl, #16]
57e27218:	e58d3020 	str	r3, [sp, #32]
57e2721c:	e59a9000 	ldr	r9, [sl]
57e27220:	e59a7004 	ldr	r7, [sl, #4]
57e27224:	e5946038 	ldr	r6, [r4, #56]	; 0x38
57e27228:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
                break;
57e2722c:	eafffc98 	b	57e26494 <inflate+0x7c>
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
57e27230:	e5943054 	ldr	r3, [r4, #84]	; 0x54
57e27234:	e3a00001 	mov	r0, #1
57e27238:	e1a03310 	lsl	r3, r0, r3
57e2723c:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
57e27240:	e2433001 	sub	r3, r3, #1
57e27244:	e58dc00c 	str	ip, [sp, #12]
57e27248:	e58d3028 	str	r3, [sp, #40]	; 0x28
57e2724c:	e1a00009 	mov	r0, r9
57e27250:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
57e27254:	e1a09000 	mov	r9, r0
57e27258:	e0063001 	and	r3, r6, r1
57e2725c:	e08c1103 	add	r1, ip, r3, lsl #2
57e27260:	e5d12001 	ldrb	r2, [r1, #1]
57e27264:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
57e27268:	e1520005 	cmp	r2, r5
                inflate_fast(strm, out);
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
57e2726c:	e58d1024 	str	r1, [sp, #36]	; 0x24
57e27270:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                if ((unsigned)(this.bits) <= bits) break;
57e27274:	e1a01002 	mov	r1, r2
57e27278:	9a000006 	bls	57e27298 <inflate+0xe80>
                PULLBYTE();
57e2727c:	e3570000 	cmp	r7, #0
57e27280:	0a00016e 	beq	57e27840 <inflate+0x1428>
57e27284:	e4d03001 	ldrb	r3, [r0], #1
57e27288:	e2477001 	sub	r7, r7, #1
57e2728c:	e0866513 	add	r6, r6, r3, lsl r5
57e27290:	e2855008 	add	r5, r5, #8
            }
57e27294:	eaffffed 	b	57e27250 <inflate+0xe38>
57e27298:	e58dc00c 	str	ip, [sp, #12]
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
57e2729c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
57e272a0:	e3530000 	cmp	r3, #0
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
57e272a4:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
57e272a8:	0a000020 	beq	57e27330 <inflate+0xf18>
57e272ac:	e31300f0 	tst	r3, #240	; 0xf0
57e272b0:	1a00001e 	bne	57e27330 <inflate+0xf18>
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
57e272b4:	e0823003 	add	r3, r2, r3
57e272b8:	e3a02001 	mov	r2, #1
57e272bc:	e1a03312 	lsl	r3, r2, r3
57e272c0:	e59dc00c 	ldr	ip, [sp, #12]
57e272c4:	e2433001 	sub	r3, r3, #1
57e272c8:	e58d3030 	str	r3, [sp, #48]	; 0x30
57e272cc:	e58d0028 	str	r0, [sp, #40]	; 0x28
57e272d0:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
57e272d4:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
57e272d8:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
57e272dc:	e0823133 	add	r3, r2, r3, lsr r1
57e272e0:	e08c0103 	add	r0, ip, r3, lsl #2
57e272e4:	e5d02001 	ldrb	r2, [r0, #1]
57e272e8:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
57e272ec:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
57e272f0:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
57e272f4:	e0810002 	add	r0, r1, r2
57e272f8:	e1500005 	cmp	r0, r5
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
57e272fc:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
57e27300:	9a000008 	bls	57e27328 <inflate+0xf10>
                    PULLBYTE();
57e27304:	e3570000 	cmp	r7, #0
57e27308:	0a00014c 	beq	57e27840 <inflate+0x1428>
57e2730c:	e1a00009 	mov	r0, r9
57e27310:	e4d03001 	ldrb	r3, [r0], #1
57e27314:	e2477001 	sub	r7, r7, #1
57e27318:	e0866513 	add	r6, r6, r3, lsl r5
57e2731c:	e58d0028 	str	r0, [sp, #40]	; 0x28
57e27320:	e2855008 	add	r5, r5, #8
                }
57e27324:	eaffffe9 	b	57e272d0 <inflate+0xeb8>
                DROPBITS(last.bits);
57e27328:	e1a06136 	lsr	r6, r6, r1
57e2732c:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
57e27330:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            if ((int)(this.op) == 0) {
57e27334:	e3530000 	cmp	r3, #0
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
57e27338:	e1a06236 	lsr	r6, r6, r2
57e2733c:	e0625005 	rsb	r5, r2, r5
            state->length = (unsigned)this.val;
57e27340:	e5841040 	str	r1, [r4, #64]	; 0x40
            if ((int)(this.op) == 0) {
                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
57e27344:	02833017 	addeq	r3, r3, #23
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
            if ((int)(this.op) == 0) {
57e27348:	0a00012e 	beq	57e27808 <inflate+0x13f0>
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
                break;
            }
            if (this.op & 32) {
57e2734c:	e3130020 	tst	r3, #32
57e27350:	0a000001 	beq	57e2735c <inflate+0xf44>
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
57e27354:	e3a0300b 	mov	r3, #11
57e27358:	ea00012a 	b	57e27808 <inflate+0x13f0>
                break;
            }
            if (this.op & 64) {
57e2735c:	e3130040 	tst	r3, #64	; 0x40
                strm->msg = (char *)"invalid literal/length code";
57e27360:	159f31f8 	ldrne	r3, [pc, #504]	; 57e27560 <inflate+0x1148>
            if (this.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
                break;
            }
            if (this.op & 64) {
57e27364:	1a000125 	bne	57e27800 <inflate+0x13e8>
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }
            state->extra = (unsigned)(this.op) & 15;
57e27368:	e203300f 	and	r3, r3, #15
57e2736c:	e5843048 	str	r3, [r4, #72]	; 0x48
            state->mode = LENEXT;
57e27370:	e3a03013 	mov	r3, #19
57e27374:	e5843000 	str	r3, [r4]
        case LENEXT:
            if (state->extra) {
57e27378:	e5943048 	ldr	r3, [r4, #72]	; 0x48
57e2737c:	e3530000 	cmp	r3, #0
57e27380:	11a02009 	movne	r2, r9
57e27384:	1a000006 	bne	57e273a4 <inflate+0xf8c>
57e27388:	ea000011 	b	57e273d4 <inflate+0xfbc>
                NEEDBITS(state->extra);
57e2738c:	e3570000 	cmp	r7, #0
57e27390:	0a00012a 	beq	57e27840 <inflate+0x1428>
57e27394:	e4d21001 	ldrb	r1, [r2], #1
57e27398:	e2477001 	sub	r7, r7, #1
57e2739c:	e0866511 	add	r6, r6, r1, lsl r5
57e273a0:	e2855008 	add	r5, r5, #8
57e273a4:	e1550003 	cmp	r5, r3
57e273a8:	e1a09002 	mov	r9, r2
57e273ac:	3afffff6 	bcc	57e2738c <inflate+0xf74>
                state->length += BITS(state->extra);
57e273b0:	e3a0c001 	mov	ip, #1
57e273b4:	e1a0231c 	lsl	r2, ip, r3
57e273b8:	e2422001 	sub	r2, r2, #1
57e273bc:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
57e273c0:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
57e273c4:	e5941040 	ldr	r1, [r4, #64]	; 0x40
                DROPBITS(state->extra);
57e273c8:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
57e273cc:	e0812002 	add	r2, r1, r2
57e273d0:	e5842040 	str	r2, [r4, #64]	; 0x40
                DROPBITS(state->extra);
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
57e273d4:	e3a03014 	mov	r3, #20
57e273d8:	e5843000 	str	r3, [r4]
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
57e273dc:	e5943058 	ldr	r3, [r4, #88]	; 0x58
57e273e0:	e3a01001 	mov	r1, #1
57e273e4:	e1a03311 	lsl	r3, r1, r3
57e273e8:	e5940050 	ldr	r0, [r4, #80]	; 0x50
57e273ec:	e2433001 	sub	r3, r3, #1
57e273f0:	e58d000c 	str	r0, [sp, #12]
57e273f4:	e59dc00c 	ldr	ip, [sp, #12]
57e273f8:	e58d3028 	str	r3, [sp, #40]	; 0x28
57e273fc:	e1a00009 	mov	r0, r9
57e27400:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
57e27404:	e1a09000 	mov	r9, r0
57e27408:	e0063002 	and	r3, r6, r2
57e2740c:	e08c1103 	add	r1, ip, r3, lsl #2
57e27410:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
57e27414:	e5d13001 	ldrb	r3, [r1, #1]
57e27418:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
57e2741c:	e1530005 	cmp	r3, r5
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
57e27420:	e58d1024 	str	r1, [sp, #36]	; 0x24
                if ((unsigned)(this.bits) <= bits) break;
57e27424:	e1a01003 	mov	r1, r3
57e27428:	9a000006 	bls	57e27448 <inflate+0x1030>
                PULLBYTE();
57e2742c:	e3570000 	cmp	r7, #0
57e27430:	0a000102 	beq	57e27840 <inflate+0x1428>
57e27434:	e4d03001 	ldrb	r3, [r0], #1
57e27438:	e2477001 	sub	r7, r7, #1
57e2743c:	e0866513 	add	r6, r6, r3, lsl r5
57e27440:	e2855008 	add	r5, r5, #8
            }
57e27444:	eaffffed 	b	57e27400 <inflate+0xfe8>
57e27448:	e58dc00c 	str	ip, [sp, #12]
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
57e2744c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
57e27450:	e31200f0 	tst	r2, #240	; 0xf0
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
57e27454:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
57e27458:	1a00001e 	bne	57e274d8 <inflate+0x10c0>
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
57e2745c:	e0832002 	add	r2, r3, r2
57e27460:	e3a03001 	mov	r3, #1
57e27464:	e1a02213 	lsl	r2, r3, r2
57e27468:	e59dc00c 	ldr	ip, [sp, #12]
57e2746c:	e2422001 	sub	r2, r2, #1
57e27470:	e58d2030 	str	r2, [sp, #48]	; 0x30
57e27474:	e58d0028 	str	r0, [sp, #40]	; 0x28
57e27478:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
57e2747c:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
57e27480:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
57e27484:	e0823133 	add	r3, r2, r3, lsr r1
57e27488:	e08c0103 	add	r0, ip, r3, lsl #2
57e2748c:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
57e27490:	e5d03001 	ldrb	r3, [r0, #1]
57e27494:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
57e27498:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
57e2749c:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
57e274a0:	e0810003 	add	r0, r1, r3
57e274a4:	e1500005 	cmp	r0, r5
57e274a8:	9a000008 	bls	57e274d0 <inflate+0x10b8>
                    PULLBYTE();
57e274ac:	e3570000 	cmp	r7, #0
57e274b0:	0a0000e2 	beq	57e27840 <inflate+0x1428>
57e274b4:	e1a00009 	mov	r0, r9
57e274b8:	e4d03001 	ldrb	r3, [r0], #1
57e274bc:	e2477001 	sub	r7, r7, #1
57e274c0:	e0866513 	add	r6, r6, r3, lsl r5
57e274c4:	e58d0028 	str	r0, [sp, #40]	; 0x28
57e274c8:	e2855008 	add	r5, r5, #8
                }
57e274cc:	eaffffe9 	b	57e27478 <inflate+0x1060>
                DROPBITS(last.bits);
57e274d0:	e1a06136 	lsr	r6, r6, r1
57e274d4:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
57e274d8:	e3120040 	tst	r2, #64	; 0x40
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
57e274dc:	e1a06336 	lsr	r6, r6, r3
57e274e0:	e0635005 	rsb	r5, r3, r5
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
57e274e4:	159f3078 	ldrne	r3, [pc, #120]	; 57e27564 <inflate+0x114c>
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
57e274e8:	1a0000c4 	bne	57e27800 <inflate+0x13e8>
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
57e274ec:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            state->extra = (unsigned)(this.op) & 15;
57e274f0:	e202200f 	and	r2, r2, #15
            state->mode = DISTEXT;
57e274f4:	e3a03015 	mov	r3, #21
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
57e274f8:	e5841044 	str	r1, [r4, #68]	; 0x44
            state->extra = (unsigned)(this.op) & 15;
57e274fc:	e5842048 	str	r2, [r4, #72]	; 0x48
            state->mode = DISTEXT;
57e27500:	e5843000 	str	r3, [r4]
        case DISTEXT:
            if (state->extra) {
57e27504:	e5943048 	ldr	r3, [r4, #72]	; 0x48
57e27508:	e3530000 	cmp	r3, #0
57e2750c:	11a02009 	movne	r2, r9
57e27510:	1a00001d 	bne	57e2758c <inflate+0x1174>
57e27514:	ea000028 	b	57e275bc <inflate+0x11a4>
57e27518:	00008b1f 	.word	0x00008b1f
57e2751c:	57e35635 	.word	0x57e35635
57e27520:	57e35667 	.word	0x57e35667
57e27524:	57e3564c 	.word	0x57e3564c
57e27528:	57e3567b 	.word	0x57e3567b
57e2752c:	57e35694 	.word	0x57e35694
57e27530:	57e2d6ec 	.word	0x57e2d6ec
57e27534:	57e2deec 	.word	0x57e2deec
57e27538:	57e356a8 	.word	0x57e356a8
57e2753c:	57e356bb 	.word	0x57e356bb
57e27540:	0000011e 	.word	0x0000011e
57e27544:	57e356d8 	.word	0x57e356d8
57e27548:	57e2d5ec 	.word	0x57e2d5ec
57e2754c:	57e356fc 	.word	0x57e356fc
57e27550:	57e35715 	.word	0x57e35715
57e27554:	57e3572f 	.word	0x57e3572f
57e27558:	57e3574b 	.word	0x57e3574b
57e2755c:	00000101 	.word	0x00000101
57e27560:	57e35619 	.word	0x57e35619
57e27564:	57e35603 	.word	0x57e35603
57e27568:	57e355e5 	.word	0x57e355e5
57e2756c:	57e35761 	.word	0x57e35761
57e27570:	57e35776 	.word	0x57e35776
                NEEDBITS(state->extra);
57e27574:	e3570000 	cmp	r7, #0
57e27578:	0a0000b0 	beq	57e27840 <inflate+0x1428>
57e2757c:	e4d21001 	ldrb	r1, [r2], #1
57e27580:	e2477001 	sub	r7, r7, #1
57e27584:	e0866511 	add	r6, r6, r1, lsl r5
57e27588:	e2855008 	add	r5, r5, #8
57e2758c:	e1550003 	cmp	r5, r3
57e27590:	e1a09002 	mov	r9, r2
57e27594:	3afffff6 	bcc	57e27574 <inflate+0x115c>
                state->offset += BITS(state->extra);
57e27598:	e3a0c001 	mov	ip, #1
57e2759c:	e1a0231c 	lsl	r2, ip, r3
57e275a0:	e2422001 	sub	r2, r2, #1
57e275a4:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
57e275a8:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
57e275ac:	e5941044 	ldr	r1, [r4, #68]	; 0x44
                DROPBITS(state->extra);
57e275b0:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
57e275b4:	e0812002 	add	r2, r1, r2
57e275b8:	e5842044 	str	r2, [r4, #68]	; 0x44
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
57e275bc:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
57e275c0:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
57e275c4:	e5942044 	ldr	r2, [r4, #68]	; 0x44
57e275c8:	e0803003 	add	r3, r0, r3
57e275cc:	e06b3003 	rsb	r3, fp, r3
57e275d0:	e1520003 	cmp	r2, r3
                strm->msg = (char *)"invalid distance too far back";
57e275d4:	851f3074 	ldrhi	r3, [pc, #-116]	; 57e27568 <inflate+0x1150>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
57e275d8:	8a000088 	bhi	57e27800 <inflate+0x13e8>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
57e275dc:	e3a03016 	mov	r3, #22
57e275e0:	e5843000 	str	r3, [r4]
        case MATCH:
            if (left == 0) goto inf_leave;
57e275e4:	e35b0000 	cmp	fp, #0
57e275e8:	0a000094 	beq	57e27840 <inflate+0x1428>
            copy = out - left;
57e275ec:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
57e275f0:	e06b2001 	rsb	r2, fp, r1
            if (state->offset > copy) {         /* copy from window */
57e275f4:	e5941044 	ldr	r1, [r4, #68]	; 0x44
57e275f8:	e1510002 	cmp	r1, r2
                else
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
57e275fc:	959d2020 	ldrls	r2, [sp, #32]
57e27600:	90611002 	rsbls	r1, r1, r2
                copy = state->length;
57e27604:	95942040 	ldrls	r2, [r4, #64]	; 0x40
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
57e27608:	9a00000b 	bls	57e2763c <inflate+0x1224>
                copy = state->offset - copy;
                if (copy > state->write) {
57e2760c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
57e27610:	e0622001 	rsb	r2, r2, r1
                if (copy > state->write) {
57e27614:	e1520003 	cmp	r2, r3
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
57e27618:	85941028 	ldrhi	r1, [r4, #40]	; 0x28
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
57e2761c:	80632002 	rsbhi	r2, r3, r2
                    from = state->window + (state->wsize - copy);
                }
                else
                    from = state->window + (state->write - copy);
57e27620:	90621003 	rsbls	r1, r2, r3
57e27624:	e5940034 	ldr	r0, [r4, #52]	; 0x34
                if (copy > state->length) copy = state->length;
57e27628:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
57e2762c:	80621001 	rsbhi	r1, r2, r1
                }
                else
                    from = state->window + (state->write - copy);
57e27630:	e0801001 	add	r1, r0, r1
                if (copy > state->length) copy = state->length;
57e27634:	e1520003 	cmp	r2, r3
57e27638:	21a02003 	movcs	r2, r3
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
57e2763c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
57e27640:	e152000b 	cmp	r2, fp
57e27644:	21a0200b 	movcs	r2, fp
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
57e27648:	e0623003 	rsb	r3, r2, r3
57e2764c:	e5843040 	str	r3, [r4, #64]	; 0x40
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
57e27650:	e062b00b 	rsb	fp, r2, fp
            state->length -= copy;
57e27654:	e3a03000 	mov	r3, #0
            do {
                *put++ = *from++;
57e27658:	e7d10003 	ldrb	r0, [r1, r3]
57e2765c:	e59dc020 	ldr	ip, [sp, #32]
57e27660:	e7cc0003 	strb	r0, [ip, r3]
57e27664:	e2833001 	add	r3, r3, #1
            } while (--copy);
57e27668:	e1520003 	cmp	r2, r3
57e2766c:	1afffff9 	bne	57e27658 <inflate+0x1240>
            if (state->length == 0) state->mode = LEN;
57e27670:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
57e27674:	e08cc002 	add	ip, ip, r2
            if (state->length == 0) state->mode = LEN;
57e27678:	e3530000 	cmp	r3, #0
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
57e2767c:	e58dc020 	str	ip, [sp, #32]
            if (state->length == 0) state->mode = LEN;
57e27680:	02833012 	addeq	r3, r3, #18
57e27684:	0a00005f 	beq	57e27808 <inflate+0x13f0>
57e27688:	eafffb81 	b	57e26494 <inflate+0x7c>
            break;
        case LIT:
            if (left == 0) goto inf_leave;
57e2768c:	e35b0000 	cmp	fp, #0
57e27690:	0a00006a 	beq	57e27840 <inflate+0x1428>
            *put++ = (unsigned char)(state->length);
57e27694:	e5943040 	ldr	r3, [r4, #64]	; 0x40
57e27698:	e59d0020 	ldr	r0, [sp, #32]
            left--;
57e2769c:	e24bb001 	sub	fp, fp, #1
            } while (--copy);
            if (state->length == 0) state->mode = LEN;
            break;
        case LIT:
            if (left == 0) goto inf_leave;
            *put++ = (unsigned char)(state->length);
57e276a0:	e4c03001 	strb	r3, [r0], #1
57e276a4:	e58d0020 	str	r0, [sp, #32]
            left--;
            state->mode = LEN;
57e276a8:	e3a03012 	mov	r3, #18
57e276ac:	ea000055 	b	57e27808 <inflate+0x13f0>
            break;
        case CHECK:
            if (state->wrap) {
57e276b0:	e5943008 	ldr	r3, [r4, #8]
57e276b4:	e3530000 	cmp	r3, #0
57e276b8:	11a03009 	movne	r3, r9
57e276bc:	1a000006 	bne	57e276dc <inflate+0x12c4>
57e276c0:	ea000037 	b	57e277a4 <inflate+0x138c>
                NEEDBITS(32);
57e276c4:	e3570000 	cmp	r7, #0
57e276c8:	0a00005c 	beq	57e27840 <inflate+0x1428>
57e276cc:	e4d32001 	ldrb	r2, [r3], #1
57e276d0:	e2477001 	sub	r7, r7, #1
57e276d4:	e0866512 	add	r6, r6, r2, lsl r5
57e276d8:	e2855008 	add	r5, r5, #8
57e276dc:	e355001f 	cmp	r5, #31
57e276e0:	e1a09003 	mov	r9, r3
57e276e4:	9afffff6 	bls	57e276c4 <inflate+0x12ac>
                out -= left;
57e276e8:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
                strm->total_out += out;
57e276ec:	e59a3014 	ldr	r3, [sl, #20]
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
57e276f0:	e06b2001 	rsb	r2, fp, r1
                strm->total_out += out;
57e276f4:	e0833002 	add	r3, r3, r2
57e276f8:	e58a3014 	str	r3, [sl, #20]
                state->total += out;
57e276fc:	e594301c 	ldr	r3, [r4, #28]
                if (out)
57e27700:	e3520000 	cmp	r2, #0
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
57e27704:	e0833002 	add	r3, r3, r2
57e27708:	e584301c 	str	r3, [r4, #28]
                if (out)
57e2770c:	0a00000e 	beq	57e2774c <inflate+0x1334>
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
57e27710:	e5943010 	ldr	r3, [r4, #16]
57e27714:	e2621000 	rsb	r1, r2, #0
57e27718:	e3530000 	cmp	r3, #0
57e2771c:	0a000004 	beq	57e27734 <inflate+0x131c>
57e27720:	e59d3020 	ldr	r3, [sp, #32]
57e27724:	e5940018 	ldr	r0, [r4, #24]
57e27728:	e0831001 	add	r1, r3, r1
57e2772c:	ebffeab7 	bl	57e22210 <crc32>
57e27730:	ea000003 	b	57e27744 <inflate+0x132c>
57e27734:	e59dc020 	ldr	ip, [sp, #32]
57e27738:	e5940018 	ldr	r0, [r4, #24]
57e2773c:	e08c1001 	add	r1, ip, r1
57e27740:	ebfffa75 	bl	57e2611c <adler32>
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
                if (out)
                    strm->adler = state->check =
57e27744:	e5840018 	str	r0, [r4, #24]
57e27748:	e58a0034 	str	r0, [sl, #52]	; 0x34
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
57e2774c:	e5943010 	ldr	r3, [r4, #16]
57e27750:	e3530000 	cmp	r3, #0
#endif
                     REVERSE(hold)) != state->check) {
57e27754:	01a02426 	lsreq	r2, r6, #8
57e27758:	01a01c26 	lsreq	r1, r6, #24
57e2775c:	02022cff 	andeq	r2, r2, #65280	; 0xff00
57e27760:	00811c06 	addeq	r1, r1, r6, lsl #24
57e27764:	02063cff 	andeq	r3, r6, #65280	; 0xff00
57e27768:	00812002 	addeq	r2, r1, r2
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
57e2776c:	00823403 	addeq	r3, r2, r3, lsl #8
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
57e27770:	e5942018 	ldr	r2, [r4, #24]
#ifdef GUNZIP
                     state->flags ? hold :
57e27774:	11a03006 	movne	r3, r6
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
57e27778:	e1530002 	cmp	r3, r2
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
57e2777c:	03a05000 	moveq	r5, #0
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
57e27780:	058db02c 	streq	fp, [sp, #44]	; 0x2c
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
57e27784:	01a06005 	moveq	r6, r5
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
57e27788:	0a000005 	beq	57e277a4 <inflate+0x138c>
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
57e2778c:	e51f3228 	ldr	r3, [pc, #-552]	; 57e2756c <inflate+0x1154>
                    state->mode = BAD;
                    break;
57e27790:	e58db02c 	str	fp, [sp, #44]	; 0x2c
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
57e27794:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
57e27798:	e3a0301b 	mov	r3, #27
57e2779c:	e5843000 	str	r3, [r4]
                    break;
57e277a0:	eafffb3b 	b	57e26494 <inflate+0x7c>
                }
                INITBITS();
                Tracev((stderr, "inflate:   check matches trailer\n"));
            }
#ifdef GUNZIP
            state->mode = LENGTH;
57e277a4:	e3a03019 	mov	r3, #25
57e277a8:	e5843000 	str	r3, [r4]
        case LENGTH:
            if (state->wrap && state->flags) {
57e277ac:	e5943008 	ldr	r3, [r4, #8]
57e277b0:	e3530000 	cmp	r3, #0
57e277b4:	0a000017 	beq	57e27818 <inflate+0x1400>
57e277b8:	e5943010 	ldr	r3, [r4, #16]
57e277bc:	e3530000 	cmp	r3, #0
57e277c0:	0a000014 	beq	57e27818 <inflate+0x1400>
57e277c4:	e1a03009 	mov	r3, r9
57e277c8:	ea000005 	b	57e277e4 <inflate+0x13cc>
                NEEDBITS(32);
57e277cc:	e3570000 	cmp	r7, #0
57e277d0:	0a00001a 	beq	57e27840 <inflate+0x1428>
57e277d4:	e4d32001 	ldrb	r2, [r3], #1
57e277d8:	e2477001 	sub	r7, r7, #1
57e277dc:	e0866512 	add	r6, r6, r2, lsl r5
57e277e0:	e2855008 	add	r5, r5, #8
57e277e4:	e355001f 	cmp	r5, #31
57e277e8:	e1a09003 	mov	r9, r3
57e277ec:	9afffff6 	bls	57e277cc <inflate+0x13b4>
                if (hold != (state->total & 0xffffffffUL)) {
57e277f0:	e594301c 	ldr	r3, [r4, #28]
57e277f4:	e1560003 	cmp	r6, r3
57e277f8:	0a000004 	beq	57e27810 <inflate+0x13f8>
                    strm->msg = (char *)"incorrect length check";
57e277fc:	e51f3294 	ldr	r3, [pc, #-660]	; 57e27570 <inflate+0x1158>
57e27800:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
57e27804:	e3a0301b 	mov	r3, #27
57e27808:	e5843000 	str	r3, [r4]
57e2780c:	eafffb20 	b	57e26494 <inflate+0x7c>
                    break;
                }
                INITBITS();
57e27810:	e3a05000 	mov	r5, #0
57e27814:	e1a06005 	mov	r6, r5
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
57e27818:	e3a0301a 	mov	r3, #26
        case DONE:
            ret = Z_STREAM_END;
57e2781c:	e3a00001 	mov	r0, #1
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
57e27820:	e5843000 	str	r3, [r4]
        case DONE:
            ret = Z_STREAM_END;
57e27824:	e58d001c 	str	r0, [sp, #28]
57e27828:	ea000004 	b	57e27840 <inflate+0x1428>
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
57e2782c:	e3e01002 	mvn	r1, #2
57e27830:	e58d101c 	str	r1, [sp, #28]
57e27834:	ea000001 	b	57e27840 <inflate+0x1428>
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
        case DONE:
            ret = Z_STREAM_END;
57e27838:	e3a02001 	mov	r2, #1
57e2783c:	e58d201c 	str	r2, [sp, #28]
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
57e27840:	e59d3020 	ldr	r3, [sp, #32]
57e27844:	e58ab010 	str	fp, [sl, #16]
57e27848:	e58a300c 	str	r3, [sl, #12]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
57e2784c:	e5943028 	ldr	r3, [r4, #40]	; 0x28
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
57e27850:	e58a9000 	str	r9, [sl]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
57e27854:	e3530000 	cmp	r3, #0
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
57e27858:	e58a7004 	str	r7, [sl, #4]
57e2785c:	e5846038 	str	r6, [r4, #56]	; 0x38
57e27860:	e584503c 	str	r5, [r4, #60]	; 0x3c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
57e27864:	1a000005 	bne	57e27880 <inflate+0x1468>
57e27868:	e5943000 	ldr	r3, [r4]
57e2786c:	e3530017 	cmp	r3, #23
57e27870:	8a000048 	bhi	57e27998 <inflate+0x1580>
57e27874:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
57e27878:	e15c000b 	cmp	ip, fp
57e2787c:	0a000045 	beq	57e27998 <inflate+0x1580>
local int updatewindow(z_streamp strm, unsigned out)
{
    struct inflate_state FAR *state;
    unsigned copy, dist;

    state = (struct inflate_state FAR *)strm->state;
57e27880:	e59a501c 	ldr	r5, [sl, #28]

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
57e27884:	e5953034 	ldr	r3, [r5, #52]	; 0x34
57e27888:	e3530000 	cmp	r3, #0
57e2788c:	1a000008 	bne	57e278b4 <inflate+0x149c>
        state->window = (unsigned char FAR *)
                        ZALLOC(strm, 1U << state->wbits,
57e27890:	e5951024 	ldr	r1, [r5, #36]	; 0x24
57e27894:	e3a02001 	mov	r2, #1
57e27898:	e59a3020 	ldr	r3, [sl, #32]
57e2789c:	e59a0028 	ldr	r0, [sl, #40]	; 0x28
57e278a0:	e1a01112 	lsl	r1, r2, r1
57e278a4:	e12fff33 	blx	r3
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
57e278a8:	e3500000 	cmp	r0, #0

    state = (struct inflate_state FAR *)strm->state;

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
        state->window = (unsigned char FAR *)
57e278ac:	e5850034 	str	r0, [r5, #52]	; 0x34
                        ZALLOC(strm, 1U << state->wbits,
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
57e278b0:	0a000034 	beq	57e27988 <inflate+0x1570>
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
57e278b4:	e5953028 	ldr	r3, [r5, #40]	; 0x28
57e278b8:	e3530000 	cmp	r3, #0
57e278bc:	1a000005 	bne	57e278d8 <inflate+0x14c0>
        state->wsize = 1U << state->wbits;
57e278c0:	e5952024 	ldr	r2, [r5, #36]	; 0x24
57e278c4:	e3a01001 	mov	r1, #1
57e278c8:	e1a02211 	lsl	r2, r1, r2
        state->write = 0;
57e278cc:	e5853030 	str	r3, [r5, #48]	; 0x30
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
        state->wsize = 1U << state->wbits;
57e278d0:	e5852028 	str	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
57e278d4:	e585302c 	str	r3, [r5, #44]	; 0x2c
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
57e278d8:	e59a6010 	ldr	r6, [sl, #16]
57e278dc:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    if (copy >= state->wsize) {
57e278e0:	e5952028 	ldr	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
57e278e4:	e0666000 	rsb	r6, r6, r0
    if (copy >= state->wsize) {
57e278e8:	e1560002 	cmp	r6, r2
57e278ec:	e59a100c 	ldr	r1, [sl, #12]
57e278f0:	3a000005 	bcc	57e2790c <inflate+0x14f4>
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
57e278f4:	e5950034 	ldr	r0, [r5, #52]	; 0x34
57e278f8:	e0621001 	rsb	r1, r2, r1
57e278fc:	ebfff282 	bl	57e2430c <memcpy>
        state->write = 0;
57e27900:	e3a03000 	mov	r3, #0
57e27904:	e5853030 	str	r3, [r5, #48]	; 0x30
57e27908:	ea000010 	b	57e27950 <inflate+0x1538>
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
57e2790c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
57e27910:	e5950034 	ldr	r0, [r5, #52]	; 0x34
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
        state->write = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
57e27914:	e0637002 	rsb	r7, r3, r2
57e27918:	e1560007 	cmp	r6, r7
57e2791c:	31a07006 	movcc	r7, r6
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
57e27920:	e0661001 	rsb	r1, r6, r1
57e27924:	e0800003 	add	r0, r0, r3
57e27928:	e1a02007 	mov	r2, r7
57e2792c:	ebfff276 	bl	57e2430c <memcpy>
        copy -= dist;
        if (copy) {
57e27930:	e0566007 	subs	r6, r6, r7
57e27934:	0a000008 	beq	57e2795c <inflate+0x1544>
            zmemcpy(state->window, strm->next_out - copy, copy);
57e27938:	e59a100c 	ldr	r1, [sl, #12]
57e2793c:	e5950034 	ldr	r0, [r5, #52]	; 0x34
57e27940:	e0661001 	rsb	r1, r6, r1
57e27944:	e1a02006 	mov	r2, r6
57e27948:	ebfff26f 	bl	57e2430c <memcpy>
            state->write = copy;
57e2794c:	e5856030 	str	r6, [r5, #48]	; 0x30
            state->whave = state->wsize;
57e27950:	e5953028 	ldr	r3, [r5, #40]	; 0x28
57e27954:	e585302c 	str	r3, [r5, #44]	; 0x2c
57e27958:	ea00000e 	b	57e27998 <inflate+0x1580>
        }
        else {
            state->write += dist;
57e2795c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
57e27960:	e5952028 	ldr	r2, [r5, #40]	; 0x28
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
57e27964:	e0873003 	add	r3, r7, r3
            if (state->write == state->wsize) state->write = 0;
57e27968:	e1530002 	cmp	r3, r2
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
57e2796c:	e5853030 	str	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
            if (state->whave < state->wsize) state->whave += dist;
57e27970:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
            if (state->write == state->wsize) state->write = 0;
57e27974:	05856030 	streq	r6, [r5, #48]	; 0x30
            if (state->whave < state->wsize) state->whave += dist;
57e27978:	e1530002 	cmp	r3, r2
57e2797c:	30877003 	addcc	r7, r7, r3
57e27980:	3585702c 	strcc	r7, [r5, #44]	; 0x2c
57e27984:	ea000003 	b	57e27998 <inflate+0x1580>
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
57e27988:	e3a0301c 	mov	r3, #28
57e2798c:	e5843000 	str	r3, [r4]
            return Z_MEM_ERROR;
57e27990:	e3e01003 	mvn	r1, #3
57e27994:	ea00003b 	b	57e27a88 <inflate+0x1670>
        }
    in -= strm->avail_in;
    out -= strm->avail_out;
57e27998:	e59a6010 	ldr	r6, [sl, #16]
57e2799c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
57e279a0:	e59a5004 	ldr	r5, [sl, #4]
57e279a4:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    out -= strm->avail_out;
57e279a8:	e0666003 	rsb	r6, r6, r3
    strm->total_in += in;
57e279ac:	e59a3008 	ldr	r3, [sl, #8]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
57e279b0:	e0655002 	rsb	r5, r5, r2
    out -= strm->avail_out;
    strm->total_in += in;
57e279b4:	e0833005 	add	r3, r3, r5
57e279b8:	e58a3008 	str	r3, [sl, #8]
    strm->total_out += out;
57e279bc:	e59a3014 	ldr	r3, [sl, #20]
57e279c0:	e0833006 	add	r3, r3, r6
57e279c4:	e58a3014 	str	r3, [sl, #20]
    state->total += out;
57e279c8:	e594301c 	ldr	r3, [r4, #28]
57e279cc:	e0833006 	add	r3, r3, r6
57e279d0:	e584301c 	str	r3, [r4, #28]
    if (state->wrap && out)
57e279d4:	e5943008 	ldr	r3, [r4, #8]
57e279d8:	e3560000 	cmp	r6, #0
57e279dc:	13530000 	cmpne	r3, #0
57e279e0:	0a00000f 	beq	57e27a24 <inflate+0x160c>
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
57e279e4:	e5943010 	ldr	r3, [r4, #16]
57e279e8:	e59a100c 	ldr	r1, [sl, #12]
57e279ec:	e3530000 	cmp	r3, #0
57e279f0:	e2663000 	rsb	r3, r6, #0
57e279f4:	0a000004 	beq	57e27a0c <inflate+0x15f4>
57e279f8:	e5940018 	ldr	r0, [r4, #24]
57e279fc:	e0811003 	add	r1, r1, r3
57e27a00:	e1a02006 	mov	r2, r6
57e27a04:	ebffea01 	bl	57e22210 <crc32>
57e27a08:	ea000003 	b	57e27a1c <inflate+0x1604>
57e27a0c:	e5940018 	ldr	r0, [r4, #24]
57e27a10:	e0811003 	add	r1, r1, r3
57e27a14:	e1a02006 	mov	r2, r6
57e27a18:	ebfff9bf 	bl	57e2611c <adler32>
    out -= strm->avail_out;
    strm->total_in += in;
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
57e27a1c:	e5840018 	str	r0, [r4, #24]
57e27a20:	e58a0034 	str	r0, [sl, #52]	; 0x34
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
57e27a24:	e5943004 	ldr	r3, [r4, #4]
57e27a28:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
57e27a2c:	e3530000 	cmp	r3, #0
57e27a30:	13a03040 	movne	r3, #64	; 0x40
57e27a34:	03a03000 	moveq	r3, #0
57e27a38:	e0833002 	add	r3, r3, r2
57e27a3c:	e5942000 	ldr	r2, [r4]
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
57e27a40:	e59dc03c 	ldr	ip, [sp, #60]	; 0x3c
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
57e27a44:	e352000b 	cmp	r2, #11
57e27a48:	03a02080 	moveq	r2, #128	; 0x80
57e27a4c:	13a02000 	movne	r2, #0
57e27a50:	e0833002 	add	r3, r3, r2
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
57e27a54:	e1966005 	orrs	r6, r6, r5
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
57e27a58:	e58a302c 	str	r3, [sl, #44]	; 0x2c
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
57e27a5c:	13a03000 	movne	r3, #0
57e27a60:	03a03001 	moveq	r3, #1
57e27a64:	e35c0004 	cmp	ip, #4
57e27a68:	03833001 	orreq	r3, r3, #1
57e27a6c:	e3530000 	cmp	r3, #0
57e27a70:	0a00000d 	beq	57e27aac <inflate+0x1694>
        ret = Z_BUF_ERROR;
57e27a74:	e59d001c 	ldr	r0, [sp, #28]
57e27a78:	e3500000 	cmp	r0, #0
57e27a7c:	03e00004 	mvneq	r0, #4
57e27a80:	e58d001c 	str	r0, [sp, #28]
57e27a84:	ea000008 	b	57e27aac <inflate+0x1694>
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
57e27a88:	e58d101c 	str	r1, [sp, #28]
57e27a8c:	ea000006 	b	57e27aac <inflate+0x1694>
57e27a90:	e3e02001 	mvn	r2, #1
57e27a94:	e58d201c 	str	r2, [sp, #28]
57e27a98:	ea000003 	b	57e27aac <inflate+0x1694>
57e27a9c:	e58d301c 	str	r3, [sp, #28]
57e27aa0:	ea000001 	b	57e27aac <inflate+0x1694>
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        default:
            return Z_STREAM_ERROR;
57e27aa4:	e3e0c001 	mvn	ip, #1
57e27aa8:	e58dc01c 	str	ip, [sp, #28]
    strm->data_type = state->bits + (state->last ? 64 : 0) +
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}
57e27aac:	e59d001c 	ldr	r0, [sp, #28]
57e27ab0:	e28dd048 	add	sp, sp, #72	; 0x48
57e27ab4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

57e27ab8 <ArpInit>:
static uchar	NetArpPacketBuf[PKTSIZE_ALIGN + PKTALIGN];

void ArpInit(void)
{
	/* XXX problem with bss workaround */
	NetArpWaitPacketMAC = NULL;
57e27ab8:	e59f3020 	ldr	r3, [pc, #32]	; 57e27ae0 <ArpInit+0x28>
57e27abc:	e3a02000 	mov	r2, #0
57e27ac0:	e5832000 	str	r2, [r3]
	NetArpWaitPacketIP = 0;
57e27ac4:	e5832004 	str	r2, [r3, #4]
	NetArpWaitReplyIP = 0;
57e27ac8:	e5832008 	str	r2, [r3, #8]
	NetArpWaitTxPacketSize = 0;
57e27acc:	e583200c 	str	r2, [r3, #12]
	NetArpTxPacket = &NetArpPacketBuf[0] + (PKTALIGN - 1);
57e27ad0:	e2832053 	add	r2, r3, #83	; 0x53
	NetArpTxPacket -= (ulong)NetArpTxPacket % PKTALIGN;
57e27ad4:	e3c2203f 	bic	r2, r2, #63	; 0x3f
57e27ad8:	e5832010 	str	r2, [r3, #16]
}
57e27adc:	e12fff1e 	bx	lr
57e27ae0:	57e790b8 	.word	0x57e790b8

57e27ae4 <arp_raw_request>:

void arp_raw_request(IPaddr_t sourceIP, const uchar *targetEther,
	IPaddr_t targetIP)
{
57e27ae4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	struct arp_hdr *arp;
	int eth_hdr_size;

	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;
57e27ae8:	e59f90b4 	ldr	r9, [pc, #180]	; 57e27ba4 <arp_raw_request+0xc0>
	NetArpTxPacket -= (ulong)NetArpTxPacket % PKTALIGN;
}

void arp_raw_request(IPaddr_t sourceIP, const uchar *targetEther,
	IPaddr_t targetIP)
{
57e27aec:	e1a0c002 	mov	ip, r2
	struct arp_hdr *arp;
	int eth_hdr_size;

	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;
57e27af0:	e5995010 	ldr	r5, [r9, #16]
	NetArpTxPacket -= (ulong)NetArpTxPacket % PKTALIGN;
}

void arp_raw_request(IPaddr_t sourceIP, const uchar *targetEther,
	IPaddr_t targetIP)
{
57e27af4:	e1a03001 	mov	r3, r1
57e27af8:	e1a0b000 	mov	fp, r0

	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
57e27afc:	e59f10a4 	ldr	r1, [pc, #164]	; 57e27ba8 <arp_raw_request+0xc4>
57e27b00:	e1a00005 	mov	r0, r5
57e27b04:	e59f20a0 	ldr	r2, [pc, #160]	; 57e27bac <arp_raw_request+0xc8>
57e27b08:	e58dc000 	str	ip, [sp]
57e27b0c:	e58d3004 	str	r3, [sp, #4]
57e27b10:	eb000633 	bl	57e293e4 <NetSetEther>

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
57e27b14:	e3a0a006 	mov	sl, #6
	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
	pkt += eth_hdr_size;
57e27b18:	e0854000 	add	r4, r5, r0
	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
	arp->ar_pln = ARP_PLEN;
57e27b1c:	e3a07004 	mov	r7, #4
	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
	pkt += eth_hdr_size;

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
57e27b20:	e3a02c01 	mov	r2, #256	; 0x100
	arp->ar_pro = htons(PROT_IP);
57e27b24:	e3a01008 	mov	r1, #8
	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
	pkt += eth_hdr_size;

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
57e27b28:	e18520b0 	strh	r2, [r5, r0]

	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
57e27b2c:	e1a06000 	mov	r6, r0
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
	arp->ar_pln = ARP_PLEN;
	arp->ar_op = htons(ARPOP_REQUEST);

	memcpy(&arp->ar_sha, NetOurEther, ARP_HLEN);	/* source ET addr */
57e27b30:	e28d5010 	add	r5, sp, #16
	pkt += eth_hdr_size;

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
57e27b34:	e1c410b2 	strh	r1, [r4, #2]
	arp->ar_hln = ARP_HLEN;
	arp->ar_pln = ARP_PLEN;
	arp->ar_op = htons(ARPOP_REQUEST);
57e27b38:	e1c420b6 	strh	r2, [r4, #6]

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
57e27b3c:	e5c4a004 	strb	sl, [r4, #4]
	arp->ar_pln = ARP_PLEN;
	arp->ar_op = htons(ARPOP_REQUEST);

	memcpy(&arp->ar_sha, NetOurEther, ARP_HLEN);	/* source ET addr */
57e27b40:	e1a0200a 	mov	r2, sl
	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
	arp->ar_pln = ARP_PLEN;
57e27b44:	e5c47005 	strb	r7, [r4, #5]
	arp->ar_op = htons(ARPOP_REQUEST);

	memcpy(&arp->ar_sha, NetOurEther, ARP_HLEN);	/* source ET addr */
57e27b48:	e2840008 	add	r0, r4, #8
57e27b4c:	e59f105c 	ldr	r1, [pc, #92]	; 57e27bb0 <arp_raw_request+0xcc>
57e27b50:	ebfff1ed 	bl	57e2430c <memcpy>
57e27b54:	e525b004 	str	fp, [r5, #-4]!
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
	memcpy(to, (void *)&ip, sizeof(ip));
57e27b58:	e1a01005 	mov	r1, r5
57e27b5c:	e1a02007 	mov	r2, r7
57e27b60:	e284000e 	add	r0, r4, #14
57e27b64:	ebfff1e8 	bl	57e2430c <memcpy>
	NetWriteIP(&arp->ar_spa, sourceIP);		/* source IP addr */
	memcpy(&arp->ar_tha, targetEther, ARP_HLEN);	/* target ET addr */
57e27b68:	e59d3004 	ldr	r3, [sp, #4]
57e27b6c:	e1a0200a 	mov	r2, sl
57e27b70:	e1a01003 	mov	r1, r3
57e27b74:	e2840012 	add	r0, r4, #18
57e27b78:	ebfff1e3 	bl	57e2430c <memcpy>
57e27b7c:	e59dc000 	ldr	ip, [sp]
57e27b80:	e1a01005 	mov	r1, r5
57e27b84:	e2840018 	add	r0, r4, #24
57e27b88:	e1a02007 	mov	r2, r7
57e27b8c:	e58dc00c 	str	ip, [sp, #12]
57e27b90:	ebfff1dd 	bl	57e2430c <memcpy>
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
57e27b94:	e5990010 	ldr	r0, [r9, #16]
57e27b98:	e286101c 	add	r1, r6, #28
57e27b9c:	eb000412 	bl	57e28bec <eth_send>
	NetWriteIP(&arp->ar_tpa, targetIP);		/* target IP addr */

	NetSendPacket(NetArpTxPacket, eth_hdr_size + ARP_HDR_SIZE);
}
57e27ba0:	e8bd8eff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e27ba4:	57e790b8 	.word	0x57e790b8
57e27ba8:	57e37bc4 	.word	0x57e37bc4
57e27bac:	00000806 	.word	0x00000806
57e27bb0:	57e79768 	.word	0x57e79768

57e27bb4 <ArpRequest>:

void ArpRequest(void)
{
	if ((NetArpWaitPacketIP & NetOurSubnetMask) !=
57e27bb4:	e59f205c 	ldr	r2, [pc, #92]	; 57e27c18 <ArpRequest+0x64>

	NetSendPacket(NetArpTxPacket, eth_hdr_size + ARP_HDR_SIZE);
}

void ArpRequest(void)
{
57e27bb8:	e92d4010 	push	{r4, lr}
	if ((NetArpWaitPacketIP & NetOurSubnetMask) !=
57e27bbc:	e59f4058 	ldr	r4, [pc, #88]	; 57e27c1c <ArpRequest+0x68>
57e27bc0:	e5921000 	ldr	r1, [r2]
57e27bc4:	e59f2054 	ldr	r2, [pc, #84]	; 57e27c20 <ArpRequest+0x6c>
57e27bc8:	e5943004 	ldr	r3, [r4, #4]
57e27bcc:	e5922000 	ldr	r2, [r2]
57e27bd0:	e0231001 	eor	r1, r3, r1
57e27bd4:	e1110002 	tst	r1, r2
57e27bd8:	0a000006 	beq	57e27bf8 <ArpRequest+0x44>
	    (NetOurIP & NetOurSubnetMask)) {
		if (NetOurGatewayIP == 0) {
57e27bdc:	e59f3040 	ldr	r3, [pc, #64]	; 57e27c24 <ArpRequest+0x70>
57e27be0:	e5933000 	ldr	r3, [r3]
57e27be4:	e3530000 	cmp	r3, #0
57e27be8:	1a000002 	bne	57e27bf8 <ArpRequest+0x44>
			puts("## Warning: gatewayip needed but not set\n");
57e27bec:	e59f0034 	ldr	r0, [pc, #52]	; 57e27c28 <ArpRequest+0x74>
57e27bf0:	ebff860b 	bl	57e09424 <puts>
			NetArpWaitReplyIP = NetArpWaitPacketIP;
57e27bf4:	e5943004 	ldr	r3, [r4, #4]
		} else {
			NetArpWaitReplyIP = NetOurGatewayIP;
		}
	} else {
		NetArpWaitReplyIP = NetArpWaitPacketIP;
57e27bf8:	e5843008 	str	r3, [r4, #8]
	}

	arp_raw_request(NetOurIP, NetEtherNullAddr, NetArpWaitReplyIP);
57e27bfc:	e59f3014 	ldr	r3, [pc, #20]	; 57e27c18 <ArpRequest+0x64>
57e27c00:	e59f1024 	ldr	r1, [pc, #36]	; 57e27c2c <ArpRequest+0x78>
57e27c04:	e5930000 	ldr	r0, [r3]
57e27c08:	e59f300c 	ldr	r3, [pc, #12]	; 57e27c1c <ArpRequest+0x68>
57e27c0c:	e5932008 	ldr	r2, [r3, #8]
}
57e27c10:	e8bd4010 	pop	{r4, lr}
		}
	} else {
		NetArpWaitReplyIP = NetArpWaitPacketIP;
	}

	arp_raw_request(NetOurIP, NetEtherNullAddr, NetArpWaitReplyIP);
57e27c14:	eaffffb2 	b	57e27ae4 <arp_raw_request>
57e27c18:	57e79764 	.word	0x57e79764
57e27c1c:	57e790b8 	.word	0x57e790b8
57e27c20:	57e79808 	.word	0x57e79808
57e27c24:	57e79804 	.word	0x57e79804
57e27c28:	57e35801 	.word	0x57e35801
57e27c2c:	57e79778 	.word	0x57e79778

57e27c30 <ArpTimeoutCheck>:
}

void ArpTimeoutCheck(void)
{
57e27c30:	e92d4010 	push	{r4, lr}
	ulong t;

	if (!NetArpWaitPacketIP)
57e27c34:	e59f405c 	ldr	r4, [pc, #92]	; 57e27c98 <ArpTimeoutCheck+0x68>
57e27c38:	e5943004 	ldr	r3, [r4, #4]
57e27c3c:	e3530000 	cmp	r3, #0
57e27c40:	08bd8010 	popeq	{r4, pc}
		return;

	t = get_timer(0);
57e27c44:	e3a00000 	mov	r0, #0
57e27c48:	ebff63af 	bl	57e00b0c <get_timer>

	/* check for arp timeout */
	if ((t - NetArpWaitTimerStart) > ARP_TIMEOUT) {
57e27c4c:	e5942654 	ldr	r2, [r4, #1620]	; 0x654
57e27c50:	e59f3044 	ldr	r3, [pc, #68]	; 57e27c9c <ArpTimeoutCheck+0x6c>
57e27c54:	e0622000 	rsb	r2, r2, r0
57e27c58:	e1520003 	cmp	r2, r3
57e27c5c:	98bd8010 	popls	{r4, pc}
		NetArpWaitTry++;
57e27c60:	e5943658 	ldr	r3, [r4, #1624]	; 0x658
57e27c64:	e2833001 	add	r3, r3, #1

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
57e27c68:	e3530004 	cmp	r3, #4

	t = get_timer(0);

	/* check for arp timeout */
	if ((t - NetArpWaitTimerStart) > ARP_TIMEOUT) {
		NetArpWaitTry++;
57e27c6c:	e5843658 	str	r3, [r4, #1624]	; 0x658

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
57e27c70:	da000005 	ble	57e27c8c <ArpTimeoutCheck+0x5c>
			puts("\nARP Retry count exceeded; starting again\n");
57e27c74:	e59f0024 	ldr	r0, [pc, #36]	; 57e27ca0 <ArpTimeoutCheck+0x70>
57e27c78:	ebff85e9 	bl	57e09424 <puts>
			NetArpWaitTry = 0;
57e27c7c:	e3a03000 	mov	r3, #0
57e27c80:	e5843658 	str	r3, [r4, #1624]	; 0x658
		} else {
			NetArpWaitTimerStart = t;
			ArpRequest();
		}
	}
}
57e27c84:	e8bd4010 	pop	{r4, lr}
		NetArpWaitTry++;

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
			puts("\nARP Retry count exceeded; starting again\n");
			NetArpWaitTry = 0;
			NetStartAgain();
57e27c88:	ea0004b3 	b	57e28f5c <NetStartAgain>
		} else {
			NetArpWaitTimerStart = t;
57e27c8c:	e5840654 	str	r0, [r4, #1620]	; 0x654
			ArpRequest();
		}
	}
}
57e27c90:	e8bd4010 	pop	{r4, lr}
			puts("\nARP Retry count exceeded; starting again\n");
			NetArpWaitTry = 0;
			NetStartAgain();
		} else {
			NetArpWaitTimerStart = t;
			ArpRequest();
57e27c94:	eaffffc6 	b	57e27bb4 <ArpRequest>
57e27c98:	57e790b8 	.word	0x57e790b8
57e27c9c:	00001388 	.word	0x00001388
57e27ca0:	57e3582b 	.word	0x57e3582b

57e27ca4 <ArpReceive>:
		}
	}
}

void ArpReceive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
57e27ca4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 *   the server ethernet address
	 */
	debug_cond(DEBUG_NET_PKT, "Got ARP\n");

	arp = (struct arp_hdr *)ip;
	if (len < ARP_HDR_SIZE) {
57e27ca8:	e352001b 	cmp	r2, #27
		}
	}
}

void ArpReceive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
57e27cac:	e24dd018 	sub	sp, sp, #24
57e27cb0:	e1a09000 	mov	r9, r0
57e27cb4:	e1a05001 	mov	r5, r1
57e27cb8:	e1a0b002 	mov	fp, r2
	 *   the server ethernet address
	 */
	debug_cond(DEBUG_NET_PKT, "Got ARP\n");

	arp = (struct arp_hdr *)ip;
	if (len < ARP_HDR_SIZE) {
57e27cbc:	ca000004 	bgt	57e27cd4 <ArpReceive+0x30>
		printf("bad length %d < %d\n", len, ARP_HDR_SIZE);
57e27cc0:	e1a01002 	mov	r1, r2
57e27cc4:	e59f01cc 	ldr	r0, [pc, #460]	; 57e27e98 <ArpReceive+0x1f4>
57e27cc8:	e3a0201c 	mov	r2, #28
57e27ccc:	ebff85de 	bl	57e0944c <printf>
		return;
57e27cd0:	ea00006e 	b	57e27e90 <ArpReceive+0x1ec>
	}
	if (ntohs(arp->ar_hrd) != ARP_ETHER)
57e27cd4:	e1d130b0 	ldrh	r3, [r1]
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
57e27cd8:	e1a02423 	lsr	r2, r3, #8
57e27cdc:	e1823403 	orr	r3, r2, r3, lsl #8
57e27ce0:	e1a03803 	lsl	r3, r3, #16
57e27ce4:	e3530801 	cmp	r3, #65536	; 0x10000
57e27ce8:	1a000068 	bne	57e27e90 <ArpReceive+0x1ec>
		return;
	if (ntohs(arp->ar_pro) != PROT_IP)
57e27cec:	e1d130b2 	ldrh	r3, [r1, #2]
57e27cf0:	e1a02423 	lsr	r2, r3, #8
57e27cf4:	e1823403 	orr	r3, r2, r3, lsl #8
57e27cf8:	e1a03803 	lsl	r3, r3, #16
57e27cfc:	e3530302 	cmp	r3, #134217728	; 0x8000000
57e27d00:	1a000062 	bne	57e27e90 <ArpReceive+0x1ec>
		return;
	if (arp->ar_hln != ARP_HLEN)
57e27d04:	e5d1a004 	ldrb	sl, [r1, #4]
57e27d08:	e35a0006 	cmp	sl, #6
57e27d0c:	1a00005f 	bne	57e27e90 <ArpReceive+0x1ec>
		return;
	if (arp->ar_pln != ARP_PLEN)
57e27d10:	e5d16005 	ldrb	r6, [r1, #5]
57e27d14:	e3560004 	cmp	r6, #4
57e27d18:	1a00005c 	bne	57e27e90 <ArpReceive+0x1ec>
		return;

	if (NetOurIP == 0)
57e27d1c:	e59f7178 	ldr	r7, [pc, #376]	; 57e27e9c <ArpReceive+0x1f8>
57e27d20:	e5973000 	ldr	r3, [r7]
57e27d24:	e3530000 	cmp	r3, #0
57e27d28:	0a000058 	beq	57e27e90 <ArpReceive+0x1ec>
		return;

	if (NetReadIP(&arp->ar_tpa) != NetOurIP)
57e27d2c:	e2813018 	add	r3, r1, #24
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
57e27d30:	e1a02006 	mov	r2, r6
57e27d34:	e2814008 	add	r4, r1, #8
57e27d38:	e28d0014 	add	r0, sp, #20
57e27d3c:	e1a01003 	mov	r1, r3
57e27d40:	e58d300c 	str	r3, [sp, #12]
57e27d44:	ebfff170 	bl	57e2430c <memcpy>
57e27d48:	e5973000 	ldr	r3, [r7]
57e27d4c:	e59d2014 	ldr	r2, [sp, #20]
57e27d50:	e1520003 	cmp	r2, r3
57e27d54:	1a00004d 	bne	57e27e90 <ArpReceive+0x1ec>
		return;

	switch (ntohs(arp->ar_op)) {
57e27d58:	e1d530b6 	ldrh	r3, [r5, #6]
57e27d5c:	e1a02423 	lsr	r2, r3, #8
57e27d60:	e1823403 	orr	r3, r2, r3, lsl #8
57e27d64:	e1a03803 	lsl	r3, r3, #16
57e27d68:	e1a03823 	lsr	r3, r3, #16
57e27d6c:	e3530001 	cmp	r3, #1
57e27d70:	0a000002 	beq	57e27d80 <ArpReceive+0xdc>
57e27d74:	e3530002 	cmp	r3, #2
57e27d78:	1a000044 	bne	57e27e90 <ArpReceive+0x1ec>
57e27d7c:	ea00001b 	b	57e27df0 <ArpReceive+0x14c>
	case ARPOP_REQUEST:
		/* reply with our IP address */
		debug_cond(DEBUG_DEV_PKT, "Got ARP REQUEST, return our IP\n");
		pkt = (uchar *)et;
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_ARP);
57e27d80:	e2891006 	add	r1, r9, #6
57e27d84:	e1a00009 	mov	r0, r9
57e27d88:	e59f2110 	ldr	r2, [pc, #272]	; 57e27ea0 <ArpReceive+0x1fc>
57e27d8c:	eb0005bd 	bl	57e29488 <net_update_ether>
		pkt += eth_hdr_size;
		arp->ar_op = htons(ARPOP_REPLY);
57e27d90:	e3a03c02 	mov	r3, #512	; 0x200
57e27d94:	e1c530b6 	strh	r3, [r5, #6]
	switch (ntohs(arp->ar_op)) {
	case ARPOP_REQUEST:
		/* reply with our IP address */
		debug_cond(DEBUG_DEV_PKT, "Got ARP REQUEST, return our IP\n");
		pkt = (uchar *)et;
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_ARP);
57e27d98:	e1a0b000 	mov	fp, r0
		pkt += eth_hdr_size;
		arp->ar_op = htons(ARPOP_REPLY);
		memcpy(&arp->ar_tha, &arp->ar_sha, ARP_HLEN);
57e27d9c:	e1a01004 	mov	r1, r4
57e27da0:	e1a0200a 	mov	r2, sl
57e27da4:	e2850012 	add	r0, r5, #18
		NetCopyIP(&arp->ar_tpa, &arp->ar_spa);
57e27da8:	e285500e 	add	r5, r5, #14
		debug_cond(DEBUG_DEV_PKT, "Got ARP REQUEST, return our IP\n");
		pkt = (uchar *)et;
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_ARP);
		pkt += eth_hdr_size;
		arp->ar_op = htons(ARPOP_REPLY);
		memcpy(&arp->ar_tha, &arp->ar_sha, ARP_HLEN);
57e27dac:	ebfff156 	bl	57e2430c <memcpy>
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy((void *)to, from, sizeof(IPaddr_t));
57e27db0:	e1a01005 	mov	r1, r5
57e27db4:	e1a02006 	mov	r2, r6
57e27db8:	e59d000c 	ldr	r0, [sp, #12]
57e27dbc:	ebfff152 	bl	57e2430c <memcpy>
		NetCopyIP(&arp->ar_tpa, &arp->ar_spa);
		memcpy(&arp->ar_sha, NetOurEther, ARP_HLEN);
57e27dc0:	e1a0200a 	mov	r2, sl
57e27dc4:	e1a00004 	mov	r0, r4
57e27dc8:	e59f10d4 	ldr	r1, [pc, #212]	; 57e27ea4 <ArpReceive+0x200>
57e27dcc:	ebfff14e 	bl	57e2430c <memcpy>
57e27dd0:	e1a01007 	mov	r1, r7
57e27dd4:	e1a00005 	mov	r0, r5
57e27dd8:	e1a02006 	mov	r2, r6
57e27ddc:	ebfff14a 	bl	57e2430c <memcpy>
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
57e27de0:	e1a00009 	mov	r0, r9
57e27de4:	e28b101c 	add	r1, fp, #28
57e27de8:	eb00037f 	bl	57e28bec <eth_send>
57e27dec:	ea000027 	b	57e27e90 <ArpReceive+0x1ec>
		NetSendPacket((uchar *)et, eth_hdr_size + ARP_HDR_SIZE);
		return;

	case ARPOP_REPLY:		/* arp reply */
		/* are we waiting for a reply */
		if (!NetArpWaitPacketIP)
57e27df0:	e59f30b0 	ldr	r3, [pc, #176]	; 57e27ea8 <ArpReceive+0x204>
57e27df4:	e5933004 	ldr	r3, [r3, #4]
57e27df8:	e3530000 	cmp	r3, #0
57e27dfc:	0a000023 	beq	57e27e90 <ArpReceive+0x1ec>
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
57e27e00:	e3a02004 	mov	r2, #4
57e27e04:	e28d0014 	add	r0, sp, #20
57e27e08:	e2841006 	add	r1, r4, #6
57e27e0c:	ebfff13e 	bl	57e2430c <memcpy>
#endif

		reply_ip_addr = NetReadIP(&arp->ar_spa);

		/* matched waiting packet's address */
		if (reply_ip_addr == NetArpWaitReplyIP) {
57e27e10:	e59f3090 	ldr	r3, [pc, #144]	; 57e27ea8 <ArpReceive+0x204>
	return ip;
57e27e14:	e59d6014 	ldr	r6, [sp, #20]
57e27e18:	e5932008 	ldr	r2, [r3, #8]
57e27e1c:	e1560002 	cmp	r6, r2
57e27e20:	1a00001a 	bne	57e27e90 <ArpReceive+0x1ec>
			debug_cond(DEBUG_DEV_PKT,
				"Got ARP REPLY, set eth addr (%pM)\n",
				arp->ar_data);

			/* save address for later use */
			if (NetArpWaitPacketMAC != NULL)
57e27e24:	e5930000 	ldr	r0, [r3]
57e27e28:	e3500000 	cmp	r0, #0
57e27e2c:	0a000002 	beq	57e27e3c <ArpReceive+0x198>
				memcpy(NetArpWaitPacketMAC,
57e27e30:	e1a01004 	mov	r1, r4
57e27e34:	e3a02006 	mov	r2, #6
57e27e38:	ebfff133 	bl	57e2430c <memcpy>
				       &arp->ar_sha, ARP_HLEN);

			net_get_arp_handler()((uchar *)arp, 0, reply_ip_addr,
57e27e3c:	eb00042b 	bl	57e28ef0 <net_get_arp_handler>
57e27e40:	e3a01000 	mov	r1, #0
57e27e44:	e1a03001 	mov	r3, r1
57e27e48:	e1a0c000 	mov	ip, r0
57e27e4c:	e1a02006 	mov	r2, r6
57e27e50:	e1a00005 	mov	r0, r5
57e27e54:	e58db000 	str	fp, [sp]
				0, len);

			/* set the mac address in the waiting packet's header
			   and transmit it */
			memcpy(((struct ethernet_hdr *)NetTxPacket)->et_dest,
57e27e58:	e59f504c 	ldr	r5, [pc, #76]	; 57e27eac <ArpReceive+0x208>
			/* save address for later use */
			if (NetArpWaitPacketMAC != NULL)
				memcpy(NetArpWaitPacketMAC,
				       &arp->ar_sha, ARP_HLEN);

			net_get_arp_handler()((uchar *)arp, 0, reply_ip_addr,
57e27e5c:	e12fff3c 	blx	ip
				0, len);

			/* set the mac address in the waiting packet's header
			   and transmit it */
			memcpy(((struct ethernet_hdr *)NetTxPacket)->et_dest,
57e27e60:	e1a01004 	mov	r1, r4
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
57e27e64:	e59f403c 	ldr	r4, [pc, #60]	; 57e27ea8 <ArpReceive+0x204>
57e27e68:	e3a02006 	mov	r2, #6
57e27e6c:	e5950000 	ldr	r0, [r5]
57e27e70:	ebfff125 	bl	57e2430c <memcpy>
57e27e74:	e5950000 	ldr	r0, [r5]
57e27e78:	e594100c 	ldr	r1, [r4, #12]
57e27e7c:	eb00035a 	bl	57e28bec <eth_send>
				&arp->ar_sha, ARP_HLEN);
			NetSendPacket(NetTxPacket, NetArpWaitTxPacketSize);

			/* no arp request pending now */
			NetArpWaitPacketIP = 0;
57e27e80:	e3a03000 	mov	r3, #0
57e27e84:	e5843004 	str	r3, [r4, #4]
			NetArpWaitTxPacketSize = 0;
57e27e88:	e584300c 	str	r3, [r4, #12]
			NetArpWaitPacketMAC = NULL;
57e27e8c:	e5843000 	str	r3, [r4]
	default:
		debug("Unexpected ARP opcode 0x%x\n",
		      ntohs(arp->ar_op));
		return;
	}
}
57e27e90:	e28dd018 	add	sp, sp, #24
57e27e94:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e27e98:	57e35856 	.word	0x57e35856
57e27e9c:	57e79764 	.word	0x57e79764
57e27ea0:	00000806 	.word	0x00000806
57e27ea4:	57e79768 	.word	0x57e79768
57e27ea8:	57e790b8 	.word	0x57e790b8
57e27eac:	57e79774 	.word	0x57e79774

57e27eb0 <BootpHandler>:
 *	Handle a BOOTP received packet.
 */
static void
BootpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	     unsigned len)
{
57e27eb0:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
static int BootpCheckPkt(uchar *pkt, unsigned dest, unsigned src, unsigned len)
{
	struct Bootp_t *bp = (struct Bootp_t *) pkt;
	int retval = 0;

	if (dest != PORT_BOOTPC || src != PORT_BOOTPS)
57e27eb4:	e3510044 	cmp	r1, #68	; 0x44
57e27eb8:	03530043 	cmpeq	r3, #67	; 0x43
 *	Handle a BOOTP received packet.
 */
static void
BootpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	     unsigned len)
{
57e27ebc:	e1a04000 	mov	r4, r0
57e27ec0:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
static int BootpCheckPkt(uchar *pkt, unsigned dest, unsigned src, unsigned len)
{
	struct Bootp_t *bp = (struct Bootp_t *) pkt;
	int retval = 0;

	if (dest != PORT_BOOTPC || src != PORT_BOOTPS)
57e27ec4:	1a0000c7 	bne	57e281e8 <BootpHandler+0x338>
		retval = -1;
	else if (len < sizeof(struct Bootp_t) - OPT_FIELD_SIZE)
57e27ec8:	e35900eb 	cmp	r9, #235	; 0xeb
57e27ecc:	9a0000c5 	bls	57e281e8 <BootpHandler+0x338>
		retval = -2;
	else if (bp->bp_op != OP_BOOTREQUEST &&
57e27ed0:	e5d03000 	ldrb	r3, [r0]
			bp->bp_op != OP_BOOTREPLY &&
			bp->bp_op != DHCP_OFFER &&
57e27ed4:	e2432001 	sub	r2, r3, #1

	if (dest != PORT_BOOTPC || src != PORT_BOOTPS)
		retval = -1;
	else if (len < sizeof(struct Bootp_t) - OPT_FIELD_SIZE)
		retval = -2;
	else if (bp->bp_op != OP_BOOTREQUEST &&
57e27ed8:	e3530005 	cmp	r3, #5
57e27edc:	13520001 	cmpne	r2, #1
57e27ee0:	9a000001 	bls	57e27eec <BootpHandler+0x3c>
			bp->bp_op != OP_BOOTREPLY &&
			bp->bp_op != DHCP_OFFER &&
			bp->bp_op != DHCP_ACK &&
57e27ee4:	e3530006 	cmp	r3, #6
57e27ee8:	1a0000be 	bne	57e281e8 <BootpHandler+0x338>
			bp->bp_op != DHCP_NAK)
		retval = -3;
	else if (bp->bp_htype != HWT_ETHER)
57e27eec:	e5d43001 	ldrb	r3, [r4, #1]
57e27ef0:	e3530001 	cmp	r3, #1
57e27ef4:	1a0000bb 	bne	57e281e8 <BootpHandler+0x338>
		retval = -4;
	else if (bp->bp_hlen != HWL_ETHER)
57e27ef8:	e5d43002 	ldrb	r3, [r4, #2]
57e27efc:	e3530006 	cmp	r3, #6
57e27f00:	1a0000b8 	bne	57e281e8 <BootpHandler+0x338>
/* return ulong *in network byteorder* */
static inline ulong NetReadLong(ulong *from)
{
	ulong l;

	memcpy((void *)&l, (void *)from, sizeof(l));
57e27f04:	e3a02004 	mov	r2, #4
57e27f08:	e1a0000d 	mov	r0, sp
57e27f0c:	e2841004 	add	r1, r4, #4
57e27f10:	ebfff0fd 	bl	57e2430c <memcpy>
		retval = -5;
	else if (NetReadLong((ulong *)&bp->bp_id) != BootpID)
57e27f14:	e59f32d0 	ldr	r3, [pc, #720]	; 57e281ec <BootpHandler+0x33c>
57e27f18:	e59d2000 	ldr	r2, [sp]
57e27f1c:	e5933000 	ldr	r3, [r3]
57e27f20:	e1520003 	cmp	r2, r3
57e27f24:	1a0000af 	bne	57e281e8 <BootpHandler+0x338>
57e27f28:	ea0000a5 	b	57e281c4 <BootpHandler+0x314>
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy((void *)to, from, sizeof(IPaddr_t));
57e27f2c:	e59f02bc 	ldr	r0, [pc, #700]	; 57e281f0 <BootpHandler+0x340>
57e27f30:	e1a01005 	mov	r1, r5
57e27f34:	e3a02004 	mov	r2, #4
57e27f38:	ebfff0f3 	bl	57e2430c <memcpy>
	IPaddr_t tmp_ip;

	NetCopyIP(&tmp_ip, &bp->bp_siaddr);
	if (tmp_ip != 0)
		NetCopyIP(&NetServerIP, &bp->bp_siaddr);
	memcpy(NetServerEther, ((struct ethernet_hdr *)NetRxPacket)->et_src, 6);
57e27f3c:	e59f32b0 	ldr	r3, [pc, #688]	; 57e281f4 <BootpHandler+0x344>
57e27f40:	e3a02006 	mov	r2, #6
57e27f44:	e5931000 	ldr	r1, [r3]
57e27f48:	e59f02a8 	ldr	r0, [pc, #680]	; 57e281f8 <BootpHandler+0x348>
57e27f4c:	e2811006 	add	r1, r1, #6
57e27f50:	ebfff0ed 	bl	57e2430c <memcpy>
#endif
	NetCopyIP(&NetOurIP, &bp->bp_yiaddr);
	if (strlen(bp->bp_file) > 0)
57e27f54:	e284506c 	add	r5, r4, #108	; 0x6c
57e27f58:	e2841010 	add	r1, r4, #16
57e27f5c:	e3a02004 	mov	r2, #4
57e27f60:	e59f0294 	ldr	r0, [pc, #660]	; 57e281fc <BootpHandler+0x34c>
57e27f64:	ebfff0e8 	bl	57e2430c <memcpy>
57e27f68:	e1a00005 	mov	r0, r5
57e27f6c:	ebfff037 	bl	57e24050 <strlen>
57e27f70:	e3500000 	cmp	r0, #0
57e27f74:	0a000003 	beq	57e27f88 <BootpHandler+0xd8>
		copy_filename(BootFile, bp->bp_file, sizeof(BootFile));
57e27f78:	e59f0280 	ldr	r0, [pc, #640]	; 57e28200 <BootpHandler+0x350>
57e27f7c:	e1a01005 	mov	r1, r5
57e27f80:	e3a02080 	mov	r2, #128	; 0x80
57e27f84:	eb0005ef 	bl	57e29748 <copy_filename>

	/* Propagate to environment:
	 * don't delete exising entry when BOOTP / DHCP reply does
	 * not contain a new value
	 */
	if (*BootFile)
57e27f88:	e59f1270 	ldr	r1, [pc, #624]	; 57e28200 <BootpHandler+0x350>
57e27f8c:	e5d13000 	ldrb	r3, [r1]
57e27f90:	e3530000 	cmp	r3, #0
57e27f94:	0a000001 	beq	57e27fa0 <BootpHandler+0xf0>
		setenv("bootfile", BootFile);
57e27f98:	e59f0264 	ldr	r0, [pc, #612]	; 57e28204 <BootpHandler+0x354>
57e27f9c:	ebff7cc3 	bl	57e072b0 <setenv>
/* return ulong *in network byteorder* */
static inline ulong NetReadLong(ulong *from)
{
	ulong l;

	memcpy((void *)&l, (void *)from, sizeof(l));
57e27fa0:	e3a02004 	mov	r2, #4
57e27fa4:	e1a0000d 	mov	r0, sp
57e27fa8:	e28410ec 	add	r1, r4, #236	; 0xec
57e27fac:	ebfff0d6 	bl	57e2430c <memcpy>
#endif

	BootpCopyNetParams(bp);		/* Store net parameters from reply */

	/* Retrieve extended information (we must parse the vendor area) */
	if (NetReadLong((ulong *)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
57e27fb0:	e59d2000 	ldr	r2, [sp]
57e27fb4:	e59f324c 	ldr	r3, [pc, #588]	; 57e28208 <BootpHandler+0x358>
57e27fb8:	e1520003 	cmp	r2, r3
57e27fbc:	1a00007b 	bne	57e281b0 <BootpHandler+0x300>
		BootpVendorProcess((uchar *)&bp->bp_vend[4], len);
57e27fc0:	e28440f0 	add	r4, r4, #240	; 0xf0
	}
}

static void BootpVendorProcess(u8 *ext, int size)
{
	u8 *end = ext + size;
57e27fc4:	e0849009 	add	r9, r4, r9
	int size = *(ext + 1);

	debug("[BOOTP] Processing extension %d... (%d bytes)\n", *ext,
		*(ext + 1));

	NetBootFileSize = 0;
57e27fc8:	e59f523c 	ldr	r5, [pc, #572]	; 57e2820c <BootpHandler+0x35c>
	case 10:		/* Impress server - Not yet supported */
		break;
	case 11:		/* RPL server - Not yet supported */
		break;
	case 12:		/* Host name */
		if (NetOurHostName[0] == 0) {
57e27fcc:	e59fb23c 	ldr	fp, [pc, #572]	; 57e28210 <BootpHandler+0x360>
			size = truncate_sz("Host Name",
				sizeof(NetOurHostName), size);
			memcpy(&NetOurHostName, ext + 2, size);
			NetOurHostName[size] = 0;
57e27fd0:	e3a07000 	mov	r7, #0
57e27fd4:	ea000070 	b	57e2819c <BootpHandler+0x2ec>
	u8 *end = ext + size;

	debug("[BOOTP] Checking extension (%d bytes)...\n", size);

	while ((ext < end) && (*ext != 0xff)) {
		if (*ext == 0) {
57e27fd8:	e3530000 	cmp	r3, #0
			ext++;
57e27fdc:	0284a001 	addeq	sl, r4, #1
	u8 *end = ext + size;

	debug("[BOOTP] Checking extension (%d bytes)...\n", size);

	while ((ext < end) && (*ext != 0xff)) {
		if (*ext == 0) {
57e27fe0:	0a00006c 	beq	57e28198 <BootpHandler+0x2e8>
			ext++;
		} else {
			u8 *opt = ext;

			ext += ext[1] + 2;
57e27fe4:	e5d42001 	ldrb	r2, [r4, #1]
57e27fe8:	e282a002 	add	sl, r2, #2
57e27fec:	e084a00a 	add	sl, r4, sl
			if (ext <= end)
57e27ff0:	e15a0009 	cmp	sl, r9
57e27ff4:	8a000067 	bhi	57e28198 <BootpHandler+0x2e8>
	int size = *(ext + 1);

	debug("[BOOTP] Processing extension %d... (%d bytes)\n", *ext,
		*(ext + 1));

	NetBootFileSize = 0;
57e27ff8:	e3a01000 	mov	r1, #0
57e27ffc:	e1c510b0 	strh	r1, [r5]

	switch (*ext) {
57e28000:	e5d43000 	ldrb	r3, [r4]

#if !defined(CONFIG_CMD_DHCP)

static void BootpVendorFieldProcess(u8 *ext)
{
	int size = *(ext + 1);
57e28004:	e1a06002 	mov	r6, r2
	debug("[BOOTP] Processing extension %d... (%d bytes)\n", *ext,
		*(ext + 1));

	NetBootFileSize = 0;

	switch (*ext) {
57e28008:	e353000c 	cmp	r3, #12
57e2800c:	0a00001f 	beq	57e28090 <BootpHandler+0x1e0>
57e28010:	8a000006 	bhi	57e28030 <BootpHandler+0x180>
57e28014:	e3530003 	cmp	r3, #3
57e28018:	0a00000d 	beq	57e28054 <BootpHandler+0x1a4>
57e2801c:	e3530006 	cmp	r3, #6
57e28020:	0a000011 	beq	57e2806c <BootpHandler+0x1bc>
57e28024:	e3530001 	cmp	r3, #1
57e28028:	1a00005a 	bne	57e28198 <BootpHandler+0x2e8>
57e2802c:	ea000006 	b	57e2804c <BootpHandler+0x19c>
57e28030:	e3530011 	cmp	r3, #17
57e28034:	0a000035 	beq	57e28110 <BootpHandler+0x260>
57e28038:	e3530028 	cmp	r3, #40	; 0x28
57e2803c:	0a000044 	beq	57e28154 <BootpHandler+0x2a4>
57e28040:	e353000d 	cmp	r3, #13
57e28044:	1a000053 	bne	57e28198 <BootpHandler+0x2e8>
57e28048:	ea000020 	b	57e280d0 <BootpHandler+0x220>
		/* Fixed length fields */
	case 1:			/* Subnet mask */
		if (NetOurSubnetMask == 0)
57e2804c:	e59f21c0 	ldr	r2, [pc, #448]	; 57e28214 <BootpHandler+0x364>
57e28050:	ea000006 	b	57e28070 <BootpHandler+0x1c0>
		break;
	case 2:			/* Time offset - Not yet supported */
		break;
		/* Variable length fields */
	case 3:			/* Gateways list */
		if (NetOurGatewayIP == 0)
57e28054:	e59f11bc 	ldr	r1, [pc, #444]	; 57e28218 <BootpHandler+0x368>
57e28058:	e5913000 	ldr	r3, [r1]
57e2805c:	e3530000 	cmp	r3, #0
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy((void *)to, from, sizeof(IPaddr_t));
57e28060:	01a00001 	moveq	r0, r1
57e28064:	1a00004b 	bne	57e28198 <BootpHandler+0x2e8>
57e28068:	ea000004 	b	57e28080 <BootpHandler+0x1d0>
	case 4:			/* Time server - Not yet supported */
		break;
	case 5:			/* IEN-116 name server - Not yet supported */
		break;
	case 6:
		if (NetOurDNSIP == 0)
57e2806c:	e59f21a8 	ldr	r2, [pc, #424]	; 57e2821c <BootpHandler+0x36c>
57e28070:	e5923000 	ldr	r3, [r2]
57e28074:	e3530000 	cmp	r3, #0
57e28078:	1a000046 	bne	57e28198 <BootpHandler+0x2e8>
57e2807c:	e1a00002 	mov	r0, r2
57e28080:	e2841002 	add	r1, r4, #2
57e28084:	e3a02004 	mov	r2, #4
57e28088:	ebfff09f 	bl	57e2430c <memcpy>
57e2808c:	ea000041 	b	57e28198 <BootpHandler+0x2e8>
	case 10:		/* Impress server - Not yet supported */
		break;
	case 11:		/* RPL server - Not yet supported */
		break;
	case 12:		/* Host name */
		if (NetOurHostName[0] == 0) {
57e28090:	e5db3000 	ldrb	r3, [fp]
57e28094:	e3530000 	cmp	r3, #0
57e28098:	1a00003e 	bne	57e28198 <BootpHandler+0x2e8>
		setenv("bootfile", BootFile);
}

static int truncate_sz(const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
57e2809c:	e352001f 	cmp	r2, #31
57e280a0:	da000004 	ble	57e280b8 <BootpHandler+0x208>
		printf("*** WARNING: %s is too long (%d - max: %d)"
57e280a4:	e59f0174 	ldr	r0, [pc, #372]	; 57e28220 <BootpHandler+0x370>
57e280a8:	e59f1174 	ldr	r1, [pc, #372]	; 57e28224 <BootpHandler+0x374>
57e280ac:	e2833020 	add	r3, r3, #32
57e280b0:	ebff84e5 	bl	57e0944c <printf>
			" - truncated\n", name, curlen, maxlen);
		curlen = maxlen - 1;
57e280b4:	e3a0601f 	mov	r6, #31
		break;
	case 12:		/* Host name */
		if (NetOurHostName[0] == 0) {
			size = truncate_sz("Host Name",
				sizeof(NetOurHostName), size);
			memcpy(&NetOurHostName, ext + 2, size);
57e280b8:	e59f0150 	ldr	r0, [pc, #336]	; 57e28210 <BootpHandler+0x360>
57e280bc:	e2841002 	add	r1, r4, #2
57e280c0:	e1a02006 	mov	r2, r6
57e280c4:	ebfff090 	bl	57e2430c <memcpy>
			NetOurHostName[size] = 0;
57e280c8:	e7cb7006 	strb	r7, [fp, r6]
57e280cc:	ea000031 	b	57e28198 <BootpHandler+0x2e8>
		}
		break;
	case 13:		/* Boot file size */
		if (size == 2)
57e280d0:	e3520002 	cmp	r2, #2
			NetBootFileSize = ntohs(*(ushort *) (ext + 2));
57e280d4:	01d430b2 	ldrheq	r3, [r4, #2]
57e280d8:	01a02423 	lsreq	r2, r3, #8
57e280dc:	01823403 	orreq	r3, r2, r3, lsl #8
			memcpy(&NetOurHostName, ext + 2, size);
			NetOurHostName[size] = 0;
		}
		break;
	case 13:		/* Boot file size */
		if (size == 2)
57e280e0:	0a000008 	beq	57e28108 <BootpHandler+0x258>
			NetBootFileSize = ntohs(*(ushort *) (ext + 2));
		else if (size == 4)
57e280e4:	e3520004 	cmp	r2, #4
57e280e8:	1a00002a 	bne	57e28198 <BootpHandler+0x2e8>
			NetBootFileSize = ntohl(*(ulong *) (ext + 2));
57e280ec:	e5943002 	ldr	r3, [r4, #2]
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
57e280f0:	e1a02c03 	lsl	r2, r3, #24
57e280f4:	e1822c23 	orr	r2, r2, r3, lsr #24
57e280f8:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e280fc:	e1822401 	orr	r2, r2, r1, lsl #8
57e28100:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e28104:	e1823423 	orr	r3, r2, r3, lsr #8
57e28108:	e1c530b0 	strh	r3, [r5]
57e2810c:	ea000021 	b	57e28198 <BootpHandler+0x2e8>
	case 15:		/* Domain name - Not yet supported */
		break;
	case 16:		/* Swap server - Not yet supported */
		break;
	case 17:		/* Root path */
		if (NetOurRootPath[0] == 0) {
57e28110:	e59f1110 	ldr	r1, [pc, #272]	; 57e28228 <BootpHandler+0x378>
57e28114:	e5d13000 	ldrb	r3, [r1]
57e28118:	e3530000 	cmp	r3, #0
57e2811c:	1a00001d 	bne	57e28198 <BootpHandler+0x2e8>
		setenv("bootfile", BootFile);
}

static int truncate_sz(const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
57e28120:	e352003f 	cmp	r2, #63	; 0x3f
57e28124:	da000004 	ble	57e2813c <BootpHandler+0x28c>
		printf("*** WARNING: %s is too long (%d - max: %d)"
57e28128:	e59f00f0 	ldr	r0, [pc, #240]	; 57e28220 <BootpHandler+0x370>
57e2812c:	e59f10f8 	ldr	r1, [pc, #248]	; 57e2822c <BootpHandler+0x37c>
57e28130:	e2833040 	add	r3, r3, #64	; 0x40
57e28134:	ebff84c4 	bl	57e0944c <printf>
			" - truncated\n", name, curlen, maxlen);
		curlen = maxlen - 1;
57e28138:	e3a0603f 	mov	r6, #63	; 0x3f
		break;
	case 17:		/* Root path */
		if (NetOurRootPath[0] == 0) {
			size = truncate_sz("Root Path",
				sizeof(NetOurRootPath), size);
			memcpy(&NetOurRootPath, ext + 2, size);
57e2813c:	e1a02006 	mov	r2, r6
57e28140:	e59f00e0 	ldr	r0, [pc, #224]	; 57e28228 <BootpHandler+0x378>
57e28144:	e2841002 	add	r1, r4, #2
57e28148:	ebfff06f 	bl	57e2430c <memcpy>
			NetOurRootPath[size] = 0;
57e2814c:	e59f20d4 	ldr	r2, [pc, #212]	; 57e28228 <BootpHandler+0x378>
57e28150:	ea00000f 	b	57e28194 <BootpHandler+0x2e4>
		 * access via TFTP.
		 */
		break;
		/* IP host layer fields */
	case 40:		/* NIS Domain name */
		if (NetOurNISDomain[0] == 0) {
57e28154:	e59f10d4 	ldr	r1, [pc, #212]	; 57e28230 <BootpHandler+0x380>
57e28158:	e5d13000 	ldrb	r3, [r1]
57e2815c:	e3530000 	cmp	r3, #0
57e28160:	1a00000c 	bne	57e28198 <BootpHandler+0x2e8>
		setenv("bootfile", BootFile);
}

static int truncate_sz(const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
57e28164:	e352001f 	cmp	r2, #31
57e28168:	da000004 	ble	57e28180 <BootpHandler+0x2d0>
		printf("*** WARNING: %s is too long (%d - max: %d)"
57e2816c:	e59f00ac 	ldr	r0, [pc, #172]	; 57e28220 <BootpHandler+0x370>
57e28170:	e59f10bc 	ldr	r1, [pc, #188]	; 57e28234 <BootpHandler+0x384>
57e28174:	e2833020 	add	r3, r3, #32
57e28178:	ebff84b3 	bl	57e0944c <printf>
			" - truncated\n", name, curlen, maxlen);
		curlen = maxlen - 1;
57e2817c:	e3a0601f 	mov	r6, #31
		/* IP host layer fields */
	case 40:		/* NIS Domain name */
		if (NetOurNISDomain[0] == 0) {
			size = truncate_sz("NIS Domain Name",
				sizeof(NetOurNISDomain), size);
			memcpy(&NetOurNISDomain, ext + 2, size);
57e28180:	e1a02006 	mov	r2, r6
57e28184:	e59f00a4 	ldr	r0, [pc, #164]	; 57e28230 <BootpHandler+0x380>
57e28188:	e2841002 	add	r1, r4, #2
57e2818c:	ebfff05e 	bl	57e2430c <memcpy>
			NetOurNISDomain[size] = 0;
57e28190:	e59f2098 	ldr	r2, [pc, #152]	; 57e28230 <BootpHandler+0x380>
57e28194:	e7c27006 	strb	r7, [r2, r6]
static int truncate_sz(const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
		printf("*** WARNING: %s is too long (%d - max: %d)"
			" - truncated\n", name, curlen, maxlen);
		curlen = maxlen - 1;
57e28198:	e1a0400a 	mov	r4, sl
{
	u8 *end = ext + size;

	debug("[BOOTP] Checking extension (%d bytes)...\n", size);

	while ((ext < end) && (*ext != 0xff)) {
57e2819c:	e1540009 	cmp	r4, r9
57e281a0:	2a000002 	bcs	57e281b0 <BootpHandler+0x300>
57e281a4:	e5d43000 	ldrb	r3, [r4]
57e281a8:	e35300ff 	cmp	r3, #255	; 0xff
57e281ac:	1affff89 	bne	57e27fd8 <BootpHandler+0x128>

	/* Retrieve extended information (we must parse the vendor area) */
	if (NetReadLong((ulong *)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
		BootpVendorProcess((uchar *)&bp->bp_vend[4], len);

	NetSetTimeout(0, (thand_f *)0);
57e281b0:	e3a00000 	mov	r0, #0
57e281b4:	e1a01000 	mov	r1, r0
57e281b8:	eb000358 	bl	57e28f20 <NetSetTimeout>
	bootstage_mark_name(BOOTSTAGE_ID_BOOTP_STOP, "bootp_stop");

	debug("Got good BOOTP\n");

	net_auto_load();
57e281bc:	eb000326 	bl	57e28e5c <net_auto_load>
57e281c0:	ea000008 	b	57e281e8 <BootpHandler+0x338>
static void BootpCopyNetParams(struct Bootp_t *bp)
{
#if !defined(CONFIG_BOOTP_SERVERIP)
	IPaddr_t tmp_ip;

	NetCopyIP(&tmp_ip, &bp->bp_siaddr);
57e281c4:	e2845014 	add	r5, r4, #20
57e281c8:	e28d0004 	add	r0, sp, #4
57e281cc:	e1a01005 	mov	r1, r5
57e281d0:	e3a02004 	mov	r2, #4
57e281d4:	ebfff04c 	bl	57e2430c <memcpy>
	if (tmp_ip != 0)
57e281d8:	e59d3004 	ldr	r3, [sp, #4]
57e281dc:	e3530000 	cmp	r3, #0
57e281e0:	0affff55 	beq	57e27f3c <BootpHandler+0x8c>
57e281e4:	eaffff50 	b	57e27f2c <BootpHandler+0x7c>
	bootstage_mark_name(BOOTSTAGE_ID_BOOTP_STOP, "bootp_stop");

	debug("Got good BOOTP\n");

	net_auto_load();
}
57e281e8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e281ec:	57e79714 	.word	0x57e79714
57e281f0:	57e7980c 	.word	0x57e7980c
57e281f4:	57e7975c 	.word	0x57e7975c
57e281f8:	57e7b6ec 	.word	0x57e7b6ec
57e281fc:	57e79764 	.word	0x57e79764
57e28200:	57e79780 	.word	0x57e79780
57e28204:	57e2f001 	.word	0x57e2f001
57e28208:	63538263 	.word	0x63538263
57e2820c:	57e7b6e8 	.word	0x57e7b6e8
57e28210:	57e7b684 	.word	0x57e7b684
57e28214:	57e79808 	.word	0x57e79808
57e28218:	57e79804 	.word	0x57e79804
57e2821c:	57e7b6e4 	.word	0x57e7b6e4
57e28220:	57e3586a 	.word	0x57e3586a
57e28224:	57e358a2 	.word	0x57e358a2
57e28228:	57e7b6a4 	.word	0x57e7b6a4
57e2822c:	57e358ac 	.word	0x57e358ac
57e28230:	57e7b664 	.word	0x57e7b664
57e28234:	57e358b6 	.word	0x57e358b6

57e28238 <BootpRequest>:
}
#endif

void
BootpRequest(void)
{
57e28238:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	for (i = 0; i < rand_ms; i++)
		udelay(1000); /*Wait 1ms*/

#endif	/* CONFIG_BOOTP_RANDOM_DELAY */

	printf("BOOTP broadcast %d\n", ++BootpTry);
57e2823c:	e59f71d4 	ldr	r7, [pc, #468]	; 57e28418 <BootpRequest+0x1e0>
	pkt = NetTxPacket;
57e28240:	e59fb1d4 	ldr	fp, [pc, #468]	; 57e2841c <BootpRequest+0x1e4>
	for (i = 0; i < rand_ms; i++)
		udelay(1000); /*Wait 1ms*/

#endif	/* CONFIG_BOOTP_RANDOM_DELAY */

	printf("BOOTP broadcast %d\n", ++BootpTry);
57e28244:	e5971004 	ldr	r1, [r7, #4]
}
#endif

void
BootpRequest(void)
{
57e28248:	e24dd018 	sub	sp, sp, #24
	for (i = 0; i < rand_ms; i++)
		udelay(1000); /*Wait 1ms*/

#endif	/* CONFIG_BOOTP_RANDOM_DELAY */

	printf("BOOTP broadcast %d\n", ++BootpTry);
57e2824c:	e2811001 	add	r1, r1, #1
57e28250:	e59f01c8 	ldr	r0, [pc, #456]	; 57e28420 <BootpRequest+0x1e8>
57e28254:	e5871004 	str	r1, [r7, #4]
57e28258:	ebff847b 	bl	57e0944c <printf>
	pkt = NetTxPacket;
57e2825c:	e59b4000 	ldr	r4, [fp]
	memset((void *)pkt, 0, PKTSIZE);
57e28260:	e3a01000 	mov	r1, #0
57e28264:	e1a00004 	mov	r0, r4
57e28268:	e59f21b4 	ldr	r2, [pc, #436]	; 57e28424 <BootpRequest+0x1ec>
57e2826c:	ebfff002 	bl	57e2427c <memset>

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_IP);
57e28270:	e3a02b02 	mov	r2, #2048	; 0x800
57e28274:	e59f11ac 	ldr	r1, [pc, #428]	; 57e28428 <BootpRequest+0x1f0>
57e28278:	e1a00004 	mov	r0, r4
57e2827c:	eb000458 	bl	57e293e4 <NetSetEther>
	pkt += eth_hdr_size;
57e28280:	e0844000 	add	r4, r4, r0
	 * C. Hallinan, DS4.COM, Inc.
	 */
	/* net_set_udp_header(pkt, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC,
		sizeof (struct Bootp_t)); */
	iphdr = pkt;	/* We need this later for net_set_udp_header() */
	pkt += IP_UDP_HDR_SIZE;
57e28284:	e284501c 	add	r5, r4, #28

	bp = (struct Bootp_t *)pkt;
	bp->bp_op = OP_BOOTREQUEST;
	bp->bp_htype = HWT_ETHER;
	bp->bp_hlen = HWL_ETHER;
	bp->bp_hops = 0;
57e28288:	e3a06000 	mov	r6, #0
		sizeof (struct Bootp_t)); */
	iphdr = pkt;	/* We need this later for net_set_udp_header() */
	pkt += IP_UDP_HDR_SIZE;

	bp = (struct Bootp_t *)pkt;
	bp->bp_op = OP_BOOTREQUEST;
57e2828c:	e3a03001 	mov	r3, #1
	bp->bp_htype = HWT_ETHER;
	bp->bp_hlen = HWL_ETHER;
57e28290:	e3a09006 	mov	r9, #6

	printf("BOOTP broadcast %d\n", ++BootpTry);
	pkt = NetTxPacket;
	memset((void *)pkt, 0, PKTSIZE);

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_IP);
57e28294:	e1a0c000 	mov	ip, r0
		sizeof (struct Bootp_t)); */
	iphdr = pkt;	/* We need this later for net_set_udp_header() */
	pkt += IP_UDP_HDR_SIZE;

	bp = (struct Bootp_t *)pkt;
	bp->bp_op = OP_BOOTREQUEST;
57e28298:	e5c4301c 	strb	r3, [r4, #28]
	bp->bp_htype = HWT_ETHER;
57e2829c:	e5c53001 	strb	r3, [r5, #1]
	bp->bp_hlen = HWL_ETHER;
57e282a0:	e5c59002 	strb	r9, [r5, #2]
	bp->bp_hops = 0;
57e282a4:	e5c56003 	strb	r6, [r5, #3]
	bp->bp_secs = htons(get_timer(0) / 1000);
57e282a8:	e1a00006 	mov	r0, r6
57e282ac:	e58dc00c 	str	ip, [sp, #12]
57e282b0:	ebff6215 	bl	57e00b0c <get_timer>
57e282b4:	e3a01ffa 	mov	r1, #1000	; 0x3e8
57e282b8:	eb000d3c 	bl	57e2b7b0 <__udivsi3>
57e282bc:	e1a00800 	lsl	r0, r0, #16
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
57e282c0:	e1a03c20 	lsr	r3, r0, #24
57e282c4:	e1830420 	orr	r0, r3, r0, lsr #8
57e282c8:	e28da018 	add	sl, sp, #24
57e282cc:	e1c500b8 	strh	r0, [r5, #8]
57e282d0:	e52a6004 	str	r6, [sl, #-4]!
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
	memcpy(to, (void *)&ip, sizeof(ip));
57e282d4:	e1a0100a 	mov	r1, sl
57e282d8:	e2840028 	add	r0, r4, #40	; 0x28
57e282dc:	e3a02004 	mov	r2, #4
57e282e0:	ebfff009 	bl	57e2430c <memcpy>
57e282e4:	e1a0100a 	mov	r1, sl
57e282e8:	e284002c 	add	r0, r4, #44	; 0x2c
57e282ec:	e3a02004 	mov	r2, #4
57e282f0:	e58d6014 	str	r6, [sp, #20]
57e282f4:	ebfff004 	bl	57e2430c <memcpy>
57e282f8:	e1a0100a 	mov	r1, sl
57e282fc:	e2840030 	add	r0, r4, #48	; 0x30
57e28300:	e3a02004 	mov	r2, #4
57e28304:	e58d6014 	str	r6, [sp, #20]
57e28308:	ebffefff 	bl	57e2430c <memcpy>
57e2830c:	e1a0100a 	mov	r1, sl
	NetWriteIP(&bp->bp_ciaddr, 0);
	NetWriteIP(&bp->bp_yiaddr, 0);
	NetWriteIP(&bp->bp_siaddr, 0);
	NetWriteIP(&bp->bp_giaddr, 0);
	memcpy(bp->bp_chaddr, NetOurEther, 6);
57e28310:	e59fa114 	ldr	sl, [pc, #276]	; 57e2842c <BootpRequest+0x1f4>
57e28314:	e2840034 	add	r0, r4, #52	; 0x34
57e28318:	e3a02004 	mov	r2, #4
57e2831c:	e58d6014 	str	r6, [sp, #20]
57e28320:	ebffeff9 	bl	57e2430c <memcpy>
57e28324:	e1a0100a 	mov	r1, sl
57e28328:	e1a02009 	mov	r2, r9
57e2832c:	e2840038 	add	r0, r4, #56	; 0x38
57e28330:	ebffeff5 	bl	57e2430c <memcpy>
	copy_filename(bp->bp_file, BootFile, sizeof(bp->bp_file));
57e28334:	e2840088 	add	r0, r4, #136	; 0x88
57e28338:	e59f10f0 	ldr	r1, [pc, #240]	; 57e28430 <BootpRequest+0x1f8>
57e2833c:	e3a02080 	mov	r2, #128	; 0x80
57e28340:	eb000500 	bl	57e29748 <copy_filename>
 */
static int BootpExtended(u8 *e)
{
	u8 *start = e;

	*e++ = 99;		/* RFC1048 Magic Cookie */
57e28344:	e3a03063 	mov	r3, #99	; 0x63
	*e++ = 130;
57e28348:	e3e0207d 	mvn	r2, #125	; 0x7d
 */
static int BootpExtended(u8 *e)
{
	u8 *start = e;

	*e++ = 99;		/* RFC1048 Magic Cookie */
57e2834c:	e5c530ec 	strb	r3, [r5, #236]	; 0xec
	*e++ = 42;
	*e++ = 4;
	e   += 4;
#endif

	*e++ = 255;		/* End of the list */
57e28350:	e3e09000 	mvn	r9, #0
static int BootpExtended(u8 *e)
{
	u8 *start = e;

	*e++ = 99;		/* RFC1048 Magic Cookie */
	*e++ = 130;
57e28354:	e5c42109 	strb	r2, [r4, #265]	; 0x109
	*e++ = 83;
57e28358:	e28220d1 	add	r2, r2, #209	; 0xd1
57e2835c:	e5c4210a 	strb	r2, [r4, #266]	; 0x10a
	*e++ = 99;
57e28360:	e5c4310b 	strb	r3, [r4, #267]	; 0x10b
	*e++ = 42;
	*e++ = 4;
	e   += 4;
#endif

	*e++ = 255;		/* End of the list */
57e28364:	e5c590f0 	strb	r9, [r5, #240]	; 0xf0
	/*
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in ms.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
		| ((ulong)NetOurEther[3] << 16)
57e28368:	e5da3003 	ldrb	r3, [sl, #3]

	/*
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in ms.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
57e2836c:	e5da2002 	ldrb	r2, [sl, #2]
		| ((ulong)NetOurEther[3] << 16)
57e28370:	e1a03803 	lsl	r3, r3, #16
57e28374:	e1833c02 	orr	r3, r3, r2, lsl #24
		| ((ulong)NetOurEther[4] << 8)
		| (ulong)NetOurEther[5];
57e28378:	e5da2005 	ldrb	r2, [sl, #5]
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in ms.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
		| ((ulong)NetOurEther[3] << 16)
		| ((ulong)NetOurEther[4] << 8)
57e2837c:	e5daa004 	ldrb	sl, [sl, #4]
57e28380:	e1833002 	orr	r3, r3, r2
		| (ulong)NetOurEther[5];
57e28384:	e183a40a 	orr	sl, r3, sl, lsl #8
	BootpID += get_timer(0);
57e28388:	e1a00006 	mov	r0, r6

	/*
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in ms.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
57e2838c:	e587a000 	str	sl, [r7]
		| ((ulong)NetOurEther[3] << 16)
		| ((ulong)NetOurEther[4] << 8)
		| (ulong)NetOurEther[5];
	BootpID += get_timer(0);
57e28390:	ebff61dd 	bl	57e00b0c <get_timer>
57e28394:	e080a00a 	add	sl, r0, sl
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
57e28398:	e1a03c0a 	lsl	r3, sl, #24
57e2839c:	e20a2cff 	and	r2, sl, #65280	; 0xff00
57e283a0:	e1833c2a 	orr	r3, r3, sl, lsr #24
57e283a4:	e1833402 	orr	r3, r3, r2, lsl #8

	/* Request additional information from the BOOTP/DHCP server */
#if defined(CONFIG_CMD_DHCP)
	extlen = DhcpExtended((u8 *)bp->bp_vend, DHCP_DISCOVER, 0, 0);
#else
	extlen = BootpExtended((u8 *)bp->bp_vend);
57e283a8:	e0645005 	rsb	r5, r4, r5
57e283ac:	e20aa8ff 	and	sl, sl, #16711680	; 0xff0000
57e283b0:	e183a42a 	orr	sl, r3, sl, lsr #8
}

/* copy ulong */
static inline void NetCopyLong(ulong *to, ulong *from)
{
	memcpy((void *)to, (void *)from, sizeof(ulong));
57e283b4:	e1a01007 	mov	r1, r7
57e283b8:	e2840020 	add	r0, r4, #32
57e283bc:	e3a02004 	mov	r2, #4
	e   += 4;
#endif

	*e++ = 255;		/* End of the list */

	return e - start;
57e283c0:	e2455017 	sub	r5, r5, #23
	BootpID = ((ulong)NetOurEther[2] << 24)
		| ((ulong)NetOurEther[3] << 16)
		| ((ulong)NetOurEther[4] << 8)
		| (ulong)NetOurEther[5];
	BootpID += get_timer(0);
	BootpID	 = htonl(BootpID);
57e283c4:	e587a000 	str	sl, [r7]
57e283c8:	ebffefcf 	bl	57e2430c <memcpy>

	/*
	 * Calculate proper packet lengths taking into account the
	 * variable size of the options field
	 */
	iplen = BOOTP_HDR_SIZE - OPT_FIELD_SIZE + extlen;
57e283cc:	e28530ec 	add	r3, r5, #236	; 0xec
	pktlen = eth_hdr_size + IP_UDP_HDR_SIZE + iplen;
	net_set_udp_header(iphdr, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC, iplen);
57e283d0:	e3a02043 	mov	r2, #67	; 0x43
57e283d4:	e58d3000 	str	r3, [sp]
57e283d8:	e1a00004 	mov	r0, r4
57e283dc:	e3a03044 	mov	r3, #68	; 0x44
57e283e0:	e1a01009 	mov	r1, r9
57e283e4:	eb00046d 	bl	57e295a0 <net_set_udp_header>
	NetSetTimeout(SELECT_TIMEOUT, BootpTimeout);
57e283e8:	e59f1044 	ldr	r1, [pc, #68]	; 57e28434 <BootpRequest+0x1fc>
57e283ec:	e59f0044 	ldr	r0, [pc, #68]	; 57e28438 <BootpRequest+0x200>
57e283f0:	eb0002ca 	bl	57e28f20 <NetSetTimeout>

#if defined(CONFIG_CMD_DHCP)
	dhcp_state = SELECTING;
	net_set_udp_handler(DhcpHandler);
#else
	net_set_udp_handler(BootpHandler);
57e283f4:	e59f0040 	ldr	r0, [pc, #64]	; 57e2843c <BootpRequest+0x204>
57e283f8:	eb0002b4 	bl	57e28ed0 <net_set_udp_handler>
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
57e283fc:	e59dc00c 	ldr	ip, [sp, #12]
	/*
	 * Calculate proper packet lengths taking into account the
	 * variable size of the options field
	 */
	iplen = BOOTP_HDR_SIZE - OPT_FIELD_SIZE + extlen;
	pktlen = eth_hdr_size + IP_UDP_HDR_SIZE + iplen;
57e28400:	e2855f42 	add	r5, r5, #264	; 0x108
57e28404:	e59b0000 	ldr	r0, [fp]
57e28408:	e085100c 	add	r1, r5, ip
57e2840c:	eb0001f6 	bl	57e28bec <eth_send>
	net_set_udp_handler(DhcpHandler);
#else
	net_set_udp_handler(BootpHandler);
#endif
	NetSendPacket(NetTxPacket, pktlen);
}
57e28410:	e28dd018 	add	sp, sp, #24
57e28414:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
57e28418:	57e79714 	.word	0x57e79714
57e2841c:	57e79774 	.word	0x57e79774
57e28420:	57e358c6 	.word	0x57e358c6
57e28424:	000005ee 	.word	0x000005ee
57e28428:	57e37bc4 	.word	0x57e37bc4
57e2842c:	57e79768 	.word	0x57e79768
57e28430:	57e79780 	.word	0x57e79780
57e28434:	57e28440 	.word	0x57e28440
57e28438:	00000bb8 	.word	0x00000bb8
57e2843c:	57e27eb0 	.word	0x57e27eb0

57e28440 <BootpTimeout>:
 *	Timeout on BOOTP/DHCP request.
 */
static void
BootpTimeout(void)
{
	if (BootpTry >= TIMEOUT_COUNT) {
57e28440:	e59f3030 	ldr	r3, [pc, #48]	; 57e28478 <BootpTimeout+0x38>
/*
 *	Timeout on BOOTP/DHCP request.
 */
static void
BootpTimeout(void)
{
57e28444:	e92d4010 	push	{r4, lr}
	if (BootpTry >= TIMEOUT_COUNT) {
57e28448:	e5933004 	ldr	r3, [r3, #4]
57e2844c:	e3530004 	cmp	r3, #4
57e28450:	da000003 	ble	57e28464 <BootpTimeout+0x24>
#ifdef CONFIG_BOOTP_MAY_FAIL
		puts("\nRetry count exceeded\n");
		net_set_state(NETLOOP_FAIL);
#else
		puts("\nRetry count exceeded; starting again\n");
57e28454:	e59f0020 	ldr	r0, [pc, #32]	; 57e2847c <BootpTimeout+0x3c>
57e28458:	ebff83f1 	bl	57e09424 <puts>
#endif
	} else {
		NetSetTimeout(TIMEOUT, BootpTimeout);
		BootpRequest();
	}
}
57e2845c:	e8bd4010 	pop	{r4, lr}
#ifdef CONFIG_BOOTP_MAY_FAIL
		puts("\nRetry count exceeded\n");
		net_set_state(NETLOOP_FAIL);
#else
		puts("\nRetry count exceeded; starting again\n");
		NetStartAgain();
57e28460:	ea0002bd 	b	57e28f5c <NetStartAgain>
#endif
	} else {
		NetSetTimeout(TIMEOUT, BootpTimeout);
57e28464:	e59f0014 	ldr	r0, [pc, #20]	; 57e28480 <BootpTimeout+0x40>
57e28468:	e59f1014 	ldr	r1, [pc, #20]	; 57e28484 <BootpTimeout+0x44>
57e2846c:	eb0002ab 	bl	57e28f20 <NetSetTimeout>
		BootpRequest();
	}
}
57e28470:	e8bd4010 	pop	{r4, lr}
		puts("\nRetry count exceeded; starting again\n");
		NetStartAgain();
#endif
	} else {
		NetSetTimeout(TIMEOUT, BootpTimeout);
		BootpRequest();
57e28474:	eaffff6f 	b	57e28238 <BootpRequest>
57e28478:	57e79714 	.word	0x57e79714
57e2847c:	57e358da 	.word	0x57e358da
57e28480:	00001388 	.word	0x00001388
57e28484:	57e28440 	.word	0x57e28440

57e28488 <cpu_eth_init>:
 * signals caller to move on
 */
static int __def_eth_init(bd_t *bis)
{
	return -1;
}
57e28488:	e3e00000 	mvn	r0, #0
57e2848c:	e12fff1e 	bx	lr

57e28490 <eth_current_changed>:

	return eth_current->index;
}

static void eth_current_changed(void)
{
57e28490:	e92d4010 	push	{r4, lr}
	char *act = getenv("ethact");
57e28494:	e59f0048 	ldr	r0, [pc, #72]	; 57e284e4 <eth_current_changed+0x54>
57e28498:	ebff7c92 	bl	57e076e8 <getenv>
	/* update current ethernet name */
	if (eth_current) {
57e2849c:	e59f2044 	ldr	r2, [pc, #68]	; 57e284e8 <eth_current_changed+0x58>
57e284a0:	e5921000 	ldr	r1, [r2]
57e284a4:	e3510000 	cmp	r1, #0
57e284a8:	0a000008 	beq	57e284d0 <eth_current_changed+0x40>
		if (act == NULL || strcmp(act, eth_current->name) != 0)
57e284ac:	e3500000 	cmp	r0, #0
57e284b0:	0a000002 	beq	57e284c0 <eth_current_changed+0x30>
57e284b4:	ebffeeba 	bl	57e23fa4 <strcmp>
57e284b8:	e3500000 	cmp	r0, #0
57e284bc:	08bd8010 	popeq	{r4, pc}
			setenv("ethact", eth_current->name);
57e284c0:	e59f3020 	ldr	r3, [pc, #32]	; 57e284e8 <eth_current_changed+0x58>
57e284c4:	e59f0018 	ldr	r0, [pc, #24]	; 57e284e4 <eth_current_changed+0x54>
57e284c8:	e5931000 	ldr	r1, [r3]
57e284cc:	ea000002 	b	57e284dc <eth_current_changed+0x4c>
	}
	/*
	 * remove the variable completely if there is no active
	 * interface
	 */
	else if (act != NULL)
57e284d0:	e3500000 	cmp	r0, #0
57e284d4:	08bd8010 	popeq	{r4, pc}
		setenv("ethact", NULL);
57e284d8:	e59f0004 	ldr	r0, [pc, #4]	; 57e284e4 <eth_current_changed+0x54>
}
57e284dc:	e8bd4010 	pop	{r4, lr}
	/*
	 * remove the variable completely if there is no active
	 * interface
	 */
	else if (act != NULL)
		setenv("ethact", NULL);
57e284e0:	eaff7b72 	b	57e072b0 <setenv>
57e284e4:	57e35901 	.word	0x57e35901
57e284e8:	57e7971c 	.word	0x57e7971c

57e284ec <eth_parse_enetaddr>:
#include <net.h>
#include <miiphy.h>
#include <phy.h>

void eth_parse_enetaddr(const char *addr, uchar *enetaddr)
{
57e284ec:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
57e284f0:	e1a04000 	mov	r4, r0
57e284f4:	e1a06001 	mov	r6, r1
57e284f8:	e3a05006 	mov	r5, #6
	char *end;
	int i;

	for (i = 0; i < 6; ++i) {
		enetaddr[i] = addr ? simple_strtoul(addr, &end, 16) : 0;
57e284fc:	e28d7004 	add	r7, sp, #4
57e28500:	e3540000 	cmp	r4, #0
57e28504:	01a00004 	moveq	r0, r4
57e28508:	0a000004 	beq	57e28520 <eth_parse_enetaddr+0x34>
57e2850c:	e1a00004 	mov	r0, r4
57e28510:	e1a01007 	mov	r1, r7
57e28514:	e3a02010 	mov	r2, #16
57e28518:	ebfff2e1 	bl	57e250a4 <simple_strtoul>
57e2851c:	e20000ff 	and	r0, r0, #255	; 0xff
		if (addr)
57e28520:	e3540000 	cmp	r4, #0
{
	char *end;
	int i;

	for (i = 0; i < 6; ++i) {
		enetaddr[i] = addr ? simple_strtoul(addr, &end, 16) : 0;
57e28524:	e4c60001 	strb	r0, [r6], #1
		if (addr)
57e28528:	0a000003 	beq	57e2853c <eth_parse_enetaddr+0x50>
			addr = (*end) ? end + 1 : end;
57e2852c:	e59d4004 	ldr	r4, [sp, #4]
57e28530:	e5d43000 	ldrb	r3, [r4]
57e28534:	e3530000 	cmp	r3, #0
57e28538:	12844001 	addne	r4, r4, #1
void eth_parse_enetaddr(const char *addr, uchar *enetaddr)
{
	char *end;
	int i;

	for (i = 0; i < 6; ++i) {
57e2853c:	e2555001 	subs	r5, r5, #1
57e28540:	1affffee 	bne	57e28500 <eth_parse_enetaddr+0x14>
		enetaddr[i] = addr ? simple_strtoul(addr, &end, 16) : 0;
		if (addr)
			addr = (*end) ? end + 1 : end;
	}
}
57e28544:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

57e28548 <eth_getenv_enetaddr>:

int eth_getenv_enetaddr(char *name, uchar *enetaddr)
{
57e28548:	e92d4010 	push	{r4, lr}
57e2854c:	e1a04001 	mov	r4, r1
	eth_parse_enetaddr(getenv(name), enetaddr);
57e28550:	ebff7c64 	bl	57e076e8 <getenv>
57e28554:	e1a01004 	mov	r1, r4
57e28558:	ebffffe3 	bl	57e284ec <eth_parse_enetaddr>
}

char *eth_get_name(void)
{
	return eth_current ? eth_current->name : "unknown";
}
57e2855c:	e5d43000 	ldrb	r3, [r4]
 */
static inline int is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
57e28560:	e3130001 	tst	r3, #1
57e28564:	1a00000c 	bne	57e2859c <eth_getenv_enetaddr+0x54>
 *
 * Return true if the address is all zeroes.
 */
static inline int is_zero_ether_addr(const u8 *addr)
{
	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
57e28568:	e5d41001 	ldrb	r1, [r4, #1]
57e2856c:	e5d42002 	ldrb	r2, [r4, #2]
57e28570:	e1812002 	orr	r2, r1, r2
57e28574:	e1833002 	orr	r3, r3, r2
57e28578:	e5d42003 	ldrb	r2, [r4, #3]
57e2857c:	e1833002 	orr	r3, r3, r2
57e28580:	e5d42004 	ldrb	r2, [r4, #4]
57e28584:	e1833002 	orr	r3, r3, r2
57e28588:	e5d42005 	ldrb	r2, [r4, #5]
 */
static inline int is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
57e2858c:	e1932002 	orrs	r2, r3, r2
57e28590:	03a00000 	moveq	r0, #0
57e28594:	13a00001 	movne	r0, #1
57e28598:	e8bd8010 	pop	{r4, pc}
57e2859c:	e3a00000 	mov	r0, #0

int eth_getenv_enetaddr(char *name, uchar *enetaddr)
{
	eth_parse_enetaddr(getenv(name), enetaddr);
	return is_valid_ether_addr(enetaddr);
}
57e285a0:	e8bd8010 	pop	{r4, pc}

57e285a4 <eth_setenv_enetaddr>:

int eth_setenv_enetaddr(char *name, const uchar *enetaddr)
{
57e285a4:	e92d4030 	push	{r4, r5, lr}
57e285a8:	e24dd01c 	sub	sp, sp, #28
	char buf[20];

	sprintf(buf, "%pM", enetaddr);
57e285ac:	e28d4004 	add	r4, sp, #4
	eth_parse_enetaddr(getenv(name), enetaddr);
	return is_valid_ether_addr(enetaddr);
}

int eth_setenv_enetaddr(char *name, const uchar *enetaddr)
{
57e285b0:	e1a05000 	mov	r5, r0
57e285b4:	e1a02001 	mov	r2, r1
	char buf[20];

	sprintf(buf, "%pM", enetaddr);
57e285b8:	e1a00004 	mov	r0, r4
57e285bc:	e59f1014 	ldr	r1, [pc, #20]	; 57e285d8 <eth_setenv_enetaddr+0x34>
57e285c0:	ebfff360 	bl	57e25348 <sprintf>

	return setenv(name, buf);
57e285c4:	e1a00005 	mov	r0, r5
57e285c8:	e1a01004 	mov	r1, r4
57e285cc:	ebff7b37 	bl	57e072b0 <setenv>
}
57e285d0:	e28dd01c 	add	sp, sp, #28
57e285d4:	e8bd8030 	pop	{r4, r5, pc}
57e285d8:	57e35908 	.word	0x57e35908

57e285dc <eth_getenv_enetaddr_by_index>:

int eth_getenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
57e285dc:	e92d4030 	push	{r4, r5, lr}
57e285e0:	e1a05002 	mov	r5, r2
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
57e285e4:	e59fe03c 	ldr	lr, [pc, #60]	; 57e28628 <eth_getenv_enetaddr_by_index+0x4c>
57e285e8:	e59f203c 	ldr	r2, [pc, #60]	; 57e2862c <eth_getenv_enetaddr_by_index+0x50>
	return setenv(name, buf);
}

int eth_getenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
57e285ec:	e24dd024 	sub	sp, sp, #36	; 0x24
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
57e285f0:	e3510000 	cmp	r1, #0
	return setenv(name, buf);
}

int eth_getenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
57e285f4:	e1a0c000 	mov	ip, r0
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
57e285f8:	e1a03001 	mov	r3, r1
57e285fc:	e1a0000d 	mov	r0, sp
57e28600:	11a01002 	movne	r1, r2
57e28604:	01a0100e 	moveq	r1, lr
57e28608:	e1a0200c 	mov	r2, ip
57e2860c:	ebfff34d 	bl	57e25348 <sprintf>
	return eth_getenv_enetaddr(enetvar, enetaddr);
57e28610:	e1a0000d 	mov	r0, sp
57e28614:	e1a01005 	mov	r1, r5

int eth_getenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
57e28618:	e1a0400d 	mov	r4, sp
	return eth_getenv_enetaddr(enetvar, enetaddr);
57e2861c:	ebffffc9 	bl	57e28548 <eth_getenv_enetaddr>
}
57e28620:	e28dd024 	add	sp, sp, #36	; 0x24
57e28624:	e8bd8030 	pop	{r4, r5, pc}
57e28628:	57e35915 	.word	0x57e35915
57e2862c:	57e3590c 	.word	0x57e3590c

57e28630 <eth_get_dev_by_name>:

static struct eth_device *eth_devices;
struct eth_device *eth_current;

struct eth_device *eth_get_dev_by_name(const char *devname)
{
57e28630:	e92d4070 	push	{r4, r5, r6, lr}
	struct eth_device *dev, *target_dev;

	BUG_ON(devname == NULL);
57e28634:	e2506000 	subs	r6, r0, #0
57e28638:	1a000006 	bne	57e28658 <eth_get_dev_by_name+0x28>
57e2863c:	e59f005c 	ldr	r0, [pc, #92]	; 57e286a0 <eth_get_dev_by_name+0x70>
57e28640:	e59f105c 	ldr	r1, [pc, #92]	; 57e286a4 <eth_get_dev_by_name+0x74>
57e28644:	e3a02083 	mov	r2, #131	; 0x83
57e28648:	e59f3058 	ldr	r3, [pc, #88]	; 57e286a8 <eth_get_dev_by_name+0x78>
57e2864c:	ebff837e 	bl	57e0944c <printf>
57e28650:	e59f0054 	ldr	r0, [pc, #84]	; 57e286ac <eth_get_dev_by_name+0x7c>
57e28654:	ebfff344 	bl	57e2536c <panic>

	if (!eth_devices)
57e28658:	e59f5050 	ldr	r5, [pc, #80]	; 57e286b0 <eth_get_dev_by_name+0x80>
57e2865c:	e5954004 	ldr	r4, [r5, #4]
57e28660:	e3540000 	cmp	r4, #0
		return NULL;
57e28664:	01a00004 	moveq	r0, r4
{
	struct eth_device *dev, *target_dev;

	BUG_ON(devname == NULL);

	if (!eth_devices)
57e28668:	08bd8070 	popeq	{r4, r5, r6, pc}
		return NULL;

	dev = eth_devices;
	target_dev = NULL;
	do {
		if (strcmp(devname, dev->name) == 0) {
57e2866c:	e1a00006 	mov	r0, r6
57e28670:	e1a01004 	mov	r1, r4
57e28674:	ebffee4a 	bl	57e23fa4 <strcmp>
57e28678:	e3500000 	cmp	r0, #0
57e2867c:	0a000005 	beq	57e28698 <eth_get_dev_by_name+0x68>
			target_dev = dev;
			break;
		}
		dev = dev->next;
57e28680:	e5944034 	ldr	r4, [r4, #52]	; 0x34
	} while (dev != eth_devices);
57e28684:	e5953004 	ldr	r3, [r5, #4]
57e28688:	e1540003 	cmp	r4, r3
57e2868c:	1afffff6 	bne	57e2866c <eth_get_dev_by_name+0x3c>

	if (!eth_devices)
		return NULL;

	dev = eth_devices;
	target_dev = NULL;
57e28690:	e3a00000 	mov	r0, #0
57e28694:	e8bd8070 	pop	{r4, r5, r6, pc}
	do {
		if (strcmp(devname, dev->name) == 0) {
57e28698:	e1a00004 	mov	r0, r4
		}
		dev = dev->next;
	} while (dev != eth_devices);

	return target_dev;
}
57e2869c:	e8bd8070 	pop	{r4, r5, r6, pc}
57e286a0:	57e33a28 	.word	0x57e33a28
57e286a4:	57e3591c 	.word	0x57e3591c
57e286a8:	57e2dfbc 	.word	0x57e2dfbc
57e286ac:	57e33a50 	.word	0x57e33a50
57e286b0:	57e7971c 	.word	0x57e7971c

57e286b4 <eth_get_dev_by_index>:

struct eth_device *eth_get_dev_by_index(int index)
{
	struct eth_device *dev, *target_dev;

	if (!eth_devices)
57e286b4:	e59f3038 	ldr	r3, [pc, #56]	; 57e286f4 <eth_get_dev_by_index+0x40>
57e286b8:	e5932004 	ldr	r2, [r3, #4]
57e286bc:	e3520000 	cmp	r2, #0
		return NULL;
57e286c0:	01a00002 	moveq	r0, r2

struct eth_device *eth_get_dev_by_index(int index)
{
	struct eth_device *dev, *target_dev;

	if (!eth_devices)
57e286c4:	012fff1e 	bxeq	lr
57e286c8:	e1a03002 	mov	r3, r2
		return NULL;

	dev = eth_devices;
	target_dev = NULL;
	do {
		if (dev->index == index) {
57e286cc:	e5931038 	ldr	r1, [r3, #56]	; 0x38
57e286d0:	e1510000 	cmp	r1, r0
57e286d4:	0a000004 	beq	57e286ec <eth_get_dev_by_index+0x38>
			target_dev = dev;
			break;
		}
		dev = dev->next;
57e286d8:	e5933034 	ldr	r3, [r3, #52]	; 0x34
	} while (dev != eth_devices);
57e286dc:	e1530002 	cmp	r3, r2
57e286e0:	1afffff9 	bne	57e286cc <eth_get_dev_by_index+0x18>

	if (!eth_devices)
		return NULL;

	dev = eth_devices;
	target_dev = NULL;
57e286e4:	e3a00000 	mov	r0, #0
57e286e8:	e12fff1e 	bx	lr
	do {
		if (dev->index == index) {
57e286ec:	e1a00003 	mov	r0, r3
		}
		dev = dev->next;
	} while (dev != eth_devices);

	return target_dev;
}
57e286f0:	e12fff1e 	bx	lr
57e286f4:	57e7971c 	.word	0x57e7971c

57e286f8 <eth_get_dev_index>:

int eth_get_dev_index(void)
{
	if (!eth_current)
57e286f8:	e59f3010 	ldr	r3, [pc, #16]	; 57e28710 <eth_get_dev_index+0x18>
57e286fc:	e5933000 	ldr	r3, [r3]
57e28700:	e3530000 	cmp	r3, #0
		return -1;

	return eth_current->index;
57e28704:	15930038 	ldrne	r0, [r3, #56]	; 0x38
}

int eth_get_dev_index(void)
{
	if (!eth_current)
		return -1;
57e28708:	03e00000 	mvneq	r0, #0

	return eth_current->index;
}
57e2870c:	e12fff1e 	bx	lr
57e28710:	57e7971c 	.word	0x57e7971c

57e28714 <eth_write_hwaddr>:
		setenv("ethact", NULL);
}

int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
		   int eth_number)
{
57e28714:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e28718:	e24dd028 	sub	sp, sp, #40	; 0x28
	unsigned char env_enetaddr[6];
	int ret = 0;

	eth_getenv_enetaddr_by_index(base_name, eth_number, env_enetaddr);
57e2871c:	e28d7020 	add	r7, sp, #32
		setenv("ethact", NULL);
}

int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
		   int eth_number)
{
57e28720:	e1a04000 	mov	r4, r0
57e28724:	e1a0a001 	mov	sl, r1
	unsigned char env_enetaddr[6];
	int ret = 0;

	eth_getenv_enetaddr_by_index(base_name, eth_number, env_enetaddr);
57e28728:	e1a00001 	mov	r0, r1
		setenv("ethact", NULL);
}

int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
		   int eth_number)
{
57e2872c:	e1a05002 	mov	r5, r2
	unsigned char env_enetaddr[6];
	int ret = 0;

	eth_getenv_enetaddr_by_index(base_name, eth_number, env_enetaddr);
57e28730:	e1a01002 	mov	r1, r2
57e28734:	e1a02007 	mov	r2, r7
57e28738:	ebffffa7 	bl	57e285dc <eth_getenv_enetaddr_by_index>

	if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6)) {
57e2873c:	e1a00007 	mov	r0, r7
57e28740:	e59f1184 	ldr	r1, [pc, #388]	; 57e288cc <eth_write_hwaddr+0x1b8>
57e28744:	e3a02006 	mov	r2, #6
57e28748:	ebffef22 	bl	57e243d8 <memcmp>
57e2874c:	e3500000 	cmp	r0, #0
57e28750:	0a00001a 	beq	57e287c0 <eth_write_hwaddr+0xac>
		if (memcmp(dev->enetaddr, "\0\0\0\0\0\0", 6) &&
57e28754:	e2846010 	add	r6, r4, #16
57e28758:	e1a00006 	mov	r0, r6
57e2875c:	e59f1168 	ldr	r1, [pc, #360]	; 57e288cc <eth_write_hwaddr+0x1b8>
57e28760:	e3a02006 	mov	r2, #6
57e28764:	ebffef1b 	bl	57e243d8 <memcmp>
57e28768:	e3500000 	cmp	r0, #0
57e2876c:	0a00000e 	beq	57e287ac <eth_write_hwaddr+0x98>
				memcmp(dev->enetaddr, env_enetaddr, 6)) {
57e28770:	e1a00006 	mov	r0, r6
57e28774:	e1a01007 	mov	r1, r7
57e28778:	e3a02006 	mov	r2, #6
57e2877c:	ebffef15 	bl	57e243d8 <memcmp>
	int ret = 0;

	eth_getenv_enetaddr_by_index(base_name, eth_number, env_enetaddr);

	if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6)) {
		if (memcmp(dev->enetaddr, "\0\0\0\0\0\0", 6) &&
57e28780:	e3500000 	cmp	r0, #0
57e28784:	0a000008 	beq	57e287ac <eth_write_hwaddr+0x98>
				memcmp(dev->enetaddr, env_enetaddr, 6)) {
			printf("\nWarning: %s MAC addresses don't match:\n",
57e28788:	e1a01004 	mov	r1, r4
57e2878c:	e59f013c 	ldr	r0, [pc, #316]	; 57e288d0 <eth_write_hwaddr+0x1bc>
57e28790:	ebff832d 	bl	57e0944c <printf>
				dev->name);
			printf("Address in SROM is         %pM\n",
57e28794:	e1a01006 	mov	r1, r6
57e28798:	e59f0134 	ldr	r0, [pc, #308]	; 57e288d4 <eth_write_hwaddr+0x1c0>
57e2879c:	ebff832a 	bl	57e0944c <printf>
				dev->enetaddr);
			printf("Address in environment is  %pM\n",
57e287a0:	e59f0130 	ldr	r0, [pc, #304]	; 57e288d8 <eth_write_hwaddr+0x1c4>
57e287a4:	e1a01007 	mov	r1, r7
57e287a8:	ebff8327 	bl	57e0944c <printf>
				env_enetaddr);
		}

		memcpy(dev->enetaddr, env_enetaddr, 6);
57e287ac:	e1a00006 	mov	r0, r6
57e287b0:	e28d1020 	add	r1, sp, #32
57e287b4:	e3a02006 	mov	r2, #6
57e287b8:	ebffeed3 	bl	57e2430c <memcpy>
57e287bc:	ea00001d 	b	57e28838 <eth_write_hwaddr+0x124>
}

char *eth_get_name(void)
{
	return eth_current ? eth_current->name : "unknown";
}
57e287c0:	e5d43010 	ldrb	r3, [r4, #16]
57e287c4:	e3130001 	tst	r3, #1
57e287c8:	1a00001a 	bne	57e28838 <eth_write_hwaddr+0x124>
 *
 * Return true if the address is all zeroes.
 */
static inline int is_zero_ether_addr(const u8 *addr)
{
	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
57e287cc:	e5d42011 	ldrb	r2, [r4, #17]
57e287d0:	e1833002 	orr	r3, r3, r2
57e287d4:	e5d42012 	ldrb	r2, [r4, #18]
57e287d8:	e1833002 	orr	r3, r3, r2
57e287dc:	e5d42013 	ldrb	r2, [r4, #19]
57e287e0:	e1833002 	orr	r3, r3, r2
57e287e4:	e5d42014 	ldrb	r2, [r4, #20]
57e287e8:	e1833002 	orr	r3, r3, r2
57e287ec:	e5d42015 	ldrb	r2, [r4, #21]
 */
static inline int is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
57e287f0:	e1932002 	orrs	r2, r3, r2
57e287f4:	0a00000f 	beq	57e28838 <eth_write_hwaddr+0x124>

static inline int eth_setenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
57e287f8:	e59f30dc 	ldr	r3, [pc, #220]	; 57e288dc <eth_write_hwaddr+0x1c8>
57e287fc:	e3550000 	cmp	r5, #0
57e28800:	e59f10d8 	ldr	r1, [pc, #216]	; 57e288e0 <eth_write_hwaddr+0x1cc>
57e28804:	e1a0200a 	mov	r2, sl
57e28808:	11a01003 	movne	r1, r3
				env_enetaddr);
		}

		memcpy(dev->enetaddr, env_enetaddr, 6);
	} else if (is_valid_ether_addr(dev->enetaddr)) {
		eth_setenv_enetaddr_by_index(base_name, eth_number,
57e2880c:	e2847010 	add	r7, r4, #16

static inline int eth_setenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
57e28810:	e1a03005 	mov	r3, r5
57e28814:	e1a0000d 	mov	r0, sp
57e28818:	ebfff2ca 	bl	57e25348 <sprintf>
	return eth_setenv_enetaddr(enetvar, enetaddr);
57e2881c:	e1a01007 	mov	r1, r7
57e28820:	e1a0000d 	mov	r0, sp
57e28824:	ebffff5e 	bl	57e285a4 <eth_setenv_enetaddr>

		memcpy(dev->enetaddr, env_enetaddr, 6);
	} else if (is_valid_ether_addr(dev->enetaddr)) {
		eth_setenv_enetaddr_by_index(base_name, eth_number,
					     dev->enetaddr);
		printf("\nWarning: %s using MAC address from net device\n",
57e28828:	e59f00b4 	ldr	r0, [pc, #180]	; 57e288e4 <eth_write_hwaddr+0x1d0>
57e2882c:	e1a01004 	mov	r1, r4

static inline int eth_setenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
57e28830:	e1a0600d 	mov	r6, sp

		memcpy(dev->enetaddr, env_enetaddr, 6);
	} else if (is_valid_ether_addr(dev->enetaddr)) {
		eth_setenv_enetaddr_by_index(base_name, eth_number,
					     dev->enetaddr);
		printf("\nWarning: %s using MAC address from net device\n",
57e28834:	ebff8304 	bl	57e0944c <printf>
			dev->name);
	}

	if (dev->write_hwaddr &&
57e28838:	e5940030 	ldr	r0, [r4, #48]	; 0x30
57e2883c:	e3500000 	cmp	r0, #0
57e28840:	0a00001f 	beq	57e288c4 <eth_write_hwaddr+0x1b0>

static int eth_mac_skip(int index)
{
	char enetvar[15];
	char *skip_state;
	sprintf(enetvar, index ? "eth%dmacskip" : "ethmacskip", index);
57e28844:	e59f309c 	ldr	r3, [pc, #156]	; 57e288e8 <eth_write_hwaddr+0x1d4>
57e28848:	e3550000 	cmp	r5, #0
57e2884c:	e59f1098 	ldr	r1, [pc, #152]	; 57e288ec <eth_write_hwaddr+0x1d8>
57e28850:	e1a02005 	mov	r2, r5
57e28854:	11a01003 	movne	r1, r3
57e28858:	e1a0000d 	mov	r0, sp
57e2885c:	ebfff2b9 	bl	57e25348 <sprintf>
	return ((skip_state = getenv(enetvar)) != NULL);
57e28860:	e1a0000d 	mov	r0, sp
57e28864:	ebff7b9f 	bl	57e076e8 <getenv>
					     dev->enetaddr);
		printf("\nWarning: %s using MAC address from net device\n",
			dev->name);
	}

	if (dev->write_hwaddr &&
57e28868:	e3500000 	cmp	r0, #0

static int eth_mac_skip(int index)
{
	char enetvar[15];
	char *skip_state;
	sprintf(enetvar, index ? "eth%dmacskip" : "ethmacskip", index);
57e2886c:	e1a0600d 	mov	r6, sp

int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
		   int eth_number)
{
	unsigned char env_enetaddr[6];
	int ret = 0;
57e28870:	13a00000 	movne	r0, #0
					     dev->enetaddr);
		printf("\nWarning: %s using MAC address from net device\n",
			dev->name);
	}

	if (dev->write_hwaddr &&
57e28874:	1a000012 	bne	57e288c4 <eth_write_hwaddr+0x1b0>
}

char *eth_get_name(void)
{
	return eth_current ? eth_current->name : "unknown";
}
57e28878:	e5d43010 	ldrb	r3, [r4, #16]
57e2887c:	e3130001 	tst	r3, #1
57e28880:	1a00000e 	bne	57e288c0 <eth_write_hwaddr+0x1ac>
 *
 * Return true if the address is all zeroes.
 */
static inline int is_zero_ether_addr(const u8 *addr)
{
	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
57e28884:	e5d42011 	ldrb	r2, [r4, #17]
57e28888:	e1833002 	orr	r3, r3, r2
57e2888c:	e5d42012 	ldrb	r2, [r4, #18]
57e28890:	e1833002 	orr	r3, r3, r2
57e28894:	e5d42013 	ldrb	r2, [r4, #19]
57e28898:	e1833002 	orr	r3, r3, r2
57e2889c:	e5d42014 	ldrb	r2, [r4, #20]
57e288a0:	e1833002 	orr	r3, r3, r2
57e288a4:	e5d42015 	ldrb	r2, [r4, #21]
 */
static inline int is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
57e288a8:	e1932002 	orrs	r2, r3, r2
57e288ac:	0a000003 	beq	57e288c0 <eth_write_hwaddr+0x1ac>
	if (dev->write_hwaddr &&
			!eth_mac_skip(eth_number)) {
		if (!is_valid_ether_addr(dev->enetaddr))
			return -1;

		ret = dev->write_hwaddr(dev);
57e288b0:	e5943030 	ldr	r3, [r4, #48]	; 0x30
57e288b4:	e1a00004 	mov	r0, r4
57e288b8:	e12fff33 	blx	r3
57e288bc:	ea000000 	b	57e288c4 <eth_write_hwaddr+0x1b0>
	}

	if (dev->write_hwaddr &&
			!eth_mac_skip(eth_number)) {
		if (!is_valid_ether_addr(dev->enetaddr))
			return -1;
57e288c0:	e3e00000 	mvn	r0, #0

		ret = dev->write_hwaddr(dev);
	}

	return ret;
}
57e288c4:	e28dd028 	add	sp, sp, #40	; 0x28
57e288c8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e288cc:	57e2dfd0 	.word	0x57e2dfd0
57e288d0:	57e3593a 	.word	0x57e3593a
57e288d4:	57e35963 	.word	0x57e35963
57e288d8:	57e35983 	.word	0x57e35983
57e288dc:	57e3590c 	.word	0x57e3590c
57e288e0:	57e35915 	.word	0x57e35915
57e288e4:	57e359a3 	.word	0x57e359a3
57e288e8:	57e35922 	.word	0x57e35922
57e288ec:	57e3592f 	.word	0x57e3592f

57e288f0 <eth_register>:

int eth_register(struct eth_device *dev)
{
57e288f0:	e92d4010 	push	{r4, lr}
57e288f4:	e1a04000 	mov	r4, r0
	struct eth_device *d;
	static int index;

	assert(strlen(dev->name) < sizeof(dev->name));
57e288f8:	ebffedd4 	bl	57e24050 <strlen>

	if (!eth_devices) {
57e288fc:	e59f3058 	ldr	r3, [pc, #88]	; 57e2895c <eth_register+0x6c>
57e28900:	e5932004 	ldr	r2, [r3, #4]
57e28904:	e3520000 	cmp	r2, #0
57e28908:	11a03002 	movne	r3, r2
57e2890c:	1a000004 	bne	57e28924 <eth_register+0x34>
		eth_current = eth_devices = dev;
57e28910:	e5834004 	str	r4, [r3, #4]
57e28914:	e5834000 	str	r4, [r3]
		eth_current_changed();
57e28918:	ebfffedc 	bl	57e28490 <eth_current_changed>
57e2891c:	ea000004 	b	57e28934 <eth_register+0x44>
	} else {
		for (d = eth_devices; d->next != eth_devices; d = d->next)
57e28920:	e1a03001 	mov	r3, r1
57e28924:	e5931034 	ldr	r1, [r3, #52]	; 0x34
57e28928:	e1510002 	cmp	r1, r2
57e2892c:	1afffffb 	bne	57e28920 <eth_register+0x30>
			;
		d->next = dev;
57e28930:	e5834034 	str	r4, [r3, #52]	; 0x34
	}

	dev->state = ETH_STATE_INIT;
	dev->next  = eth_devices;
57e28934:	e59f3020 	ldr	r3, [pc, #32]	; 57e2895c <eth_register+0x6c>
		for (d = eth_devices; d->next != eth_devices; d = d->next)
			;
		d->next = dev;
	}

	dev->state = ETH_STATE_INIT;
57e28938:	e3a00000 	mov	r0, #0
	dev->next  = eth_devices;
57e2893c:	e5932004 	ldr	r2, [r3, #4]
		for (d = eth_devices; d->next != eth_devices; d = d->next)
			;
		d->next = dev;
	}

	dev->state = ETH_STATE_INIT;
57e28940:	e584001c 	str	r0, [r4, #28]
	dev->next  = eth_devices;
57e28944:	e5842034 	str	r2, [r4, #52]	; 0x34
	dev->index = index++;
57e28948:	e5932008 	ldr	r2, [r3, #8]
57e2894c:	e5842038 	str	r2, [r4, #56]	; 0x38
57e28950:	e2822001 	add	r2, r2, #1
57e28954:	e5832008 	str	r2, [r3, #8]

	return 0;
}
57e28958:	e8bd8010 	pop	{r4, pc}
57e2895c:	57e7971c 	.word	0x57e7971c

57e28960 <eth_unregister>:

int eth_unregister(struct eth_device *dev)
{
57e28960:	e92d4008 	push	{r3, lr}
	struct eth_device *cur;

	/* No device */
	if (!eth_devices)
57e28964:	e59f308c 	ldr	r3, [pc, #140]	; 57e289f8 <eth_unregister+0x98>
57e28968:	e5933004 	ldr	r3, [r3, #4]
57e2896c:	e3530000 	cmp	r3, #0
57e28970:	11a01003 	movne	r1, r3
57e28974:	0a00001b 	beq	57e289e8 <eth_unregister+0x88>
57e28978:	ea000000 	b	57e28980 <eth_unregister+0x20>
		return -1;

	for (cur = eth_devices; cur->next != eth_devices && cur->next != dev;
57e2897c:	e1a01002 	mov	r1, r2
57e28980:	e5912034 	ldr	r2, [r1, #52]	; 0x34
57e28984:	e1520003 	cmp	r2, r3
57e28988:	0a000002 	beq	57e28998 <eth_unregister+0x38>
57e2898c:	e1520000 	cmp	r2, r0
57e28990:	1afffff9 	bne	57e2897c <eth_unregister+0x1c>
57e28994:	ea000001 	b	57e289a0 <eth_unregister+0x40>
	     cur = cur->next)
		;

	/* Device not found */
	if (cur->next != dev)
57e28998:	e1530000 	cmp	r3, r0
57e2899c:	1a000011 	bne	57e289e8 <eth_unregister+0x88>
		return -1;

	cur->next = dev->next;
57e289a0:	e592c034 	ldr	ip, [r2, #52]	; 0x34

	if (eth_devices == dev)
57e289a4:	e1530002 	cmp	r3, r2

	/* Device not found */
	if (cur->next != dev)
		return -1;

	cur->next = dev->next;
57e289a8:	e581c034 	str	ip, [r1, #52]	; 0x34

	if (eth_devices == dev)
57e289ac:	1a000004 	bne	57e289c4 <eth_unregister+0x64>
		eth_devices = dev->next == eth_devices ? NULL : dev->next;
57e289b0:	e5932034 	ldr	r2, [r3, #52]	; 0x34
57e289b4:	e1520003 	cmp	r2, r3
57e289b8:	e59f3038 	ldr	r3, [pc, #56]	; 57e289f8 <eth_unregister+0x98>
57e289bc:	03a02000 	moveq	r2, #0
57e289c0:	e5832004 	str	r2, [r3, #4]

	if (eth_current == dev) {
57e289c4:	e59f302c 	ldr	r3, [pc, #44]	; 57e289f8 <eth_unregister+0x98>
57e289c8:	e5932000 	ldr	r2, [r3]
57e289cc:	e1520000 	cmp	r2, r0
57e289d0:	1a000006 	bne	57e289f0 <eth_unregister+0x90>
		eth_current = eth_devices;
57e289d4:	e5932004 	ldr	r2, [r3, #4]
57e289d8:	e5832000 	str	r2, [r3]
		eth_current_changed();
57e289dc:	ebfffeab 	bl	57e28490 <eth_current_changed>
	}

	return 0;
57e289e0:	e3a00000 	mov	r0, #0
57e289e4:	e8bd8008 	pop	{r3, pc}
	     cur = cur->next)
		;

	/* Device not found */
	if (cur->next != dev)
		return -1;
57e289e8:	e3e00000 	mvn	r0, #0
57e289ec:	e8bd8008 	pop	{r3, pc}
	if (eth_current == dev) {
		eth_current = eth_devices;
		eth_current_changed();
	}

	return 0;
57e289f0:	e3a00000 	mov	r0, #0
}
57e289f4:	e8bd8008 	pop	{r3, pc}
57e289f8:	57e7971c 	.word	0x57e7971c

57e289fc <eth_initialize>:
	if ((s = getenv("bootfile")) != NULL)
		copy_filename(BootFile, s, sizeof(BootFile));
}

int eth_initialize(bd_t *bis)
{
57e289fc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int num_devices = 0;
	eth_devices = NULL;
57e28a00:	e59f3170 	ldr	r3, [pc, #368]	; 57e28b78 <eth_initialize+0x17c>
57e28a04:	e3a02000 	mov	r2, #0
57e28a08:	e5832004 	str	r2, [r3, #4]
	eth_current = NULL;
57e28a0c:	e5832000 	str	r2, [r3]
	if ((s = getenv("bootfile")) != NULL)
		copy_filename(BootFile, s, sizeof(BootFile));
}

int eth_initialize(bd_t *bis)
{
57e28a10:	e1a04000 	mov	r4, r0
57e28a14:	e3a00040 	mov	r0, #64	; 0x40
57e28a18:	ebff97d1 	bl	57e0e964 <__show_boot_progress>

static void eth_env_init(bd_t *bis)
{
	const char *s;

	if ((s = getenv("bootfile")) != NULL)
57e28a1c:	e59f0158 	ldr	r0, [pc, #344]	; 57e28b7c <eth_initialize+0x180>
57e28a20:	ebff7b30 	bl	57e076e8 <getenv>
57e28a24:	e2501000 	subs	r1, r0, #0
57e28a28:	0a000002 	beq	57e28a38 <eth_initialize+0x3c>
		copy_filename(BootFile, s, sizeof(BootFile));
57e28a2c:	e59f014c 	ldr	r0, [pc, #332]	; 57e28b80 <eth_initialize+0x184>
57e28a30:	e3a02080 	mov	r2, #128	; 0x80
57e28a34:	eb000343 	bl	57e29748 <copy_filename>

	/*
	 * If board-specific initialization exists, call it.
	 * If not, call a CPU-specific one
	 */
	if (board_eth_init != __def_eth_init) {
57e28a38:	e59f3144 	ldr	r3, [pc, #324]	; 57e28b84 <eth_initialize+0x188>
57e28a3c:	e59f2144 	ldr	r2, [pc, #324]	; 57e28b88 <eth_initialize+0x18c>
57e28a40:	e1530002 	cmp	r3, r2
57e28a44:	0a000005 	beq	57e28a60 <eth_initialize+0x64>
		if (board_eth_init(bis) < 0)
57e28a48:	e1a00004 	mov	r0, r4
57e28a4c:	eb000b4a 	bl	57e2b77c <board_eth_init>
57e28a50:	e3500000 	cmp	r0, #0
			printf("Board Net Initialization Failed\n");
57e28a54:	b59f0130 	ldrlt	r0, [pc, #304]	; 57e28b8c <eth_initialize+0x190>
	/*
	 * If board-specific initialization exists, call it.
	 * If not, call a CPU-specific one
	 */
	if (board_eth_init != __def_eth_init) {
		if (board_eth_init(bis) < 0)
57e28a58:	aa00000b 	bge	57e28a8c <eth_initialize+0x90>
57e28a5c:	ea000009 	b	57e28a88 <eth_initialize+0x8c>
			printf("Board Net Initialization Failed\n");
	} else if (cpu_eth_init != __def_eth_init) {
57e28a60:	e59f2128 	ldr	r2, [pc, #296]	; 57e28b90 <eth_initialize+0x194>
57e28a64:	e1520003 	cmp	r2, r3
57e28a68:	0a000005 	beq	57e28a84 <eth_initialize+0x88>
		if (cpu_eth_init(bis) < 0)
57e28a6c:	e1a00004 	mov	r0, r4
57e28a70:	ebfffe84 	bl	57e28488 <cpu_eth_init>
57e28a74:	e3500000 	cmp	r0, #0
			printf("CPU Net Initialization Failed\n");
57e28a78:	b59f0114 	ldrlt	r0, [pc, #276]	; 57e28b94 <eth_initialize+0x198>
	 */
	if (board_eth_init != __def_eth_init) {
		if (board_eth_init(bis) < 0)
			printf("Board Net Initialization Failed\n");
	} else if (cpu_eth_init != __def_eth_init) {
		if (cpu_eth_init(bis) < 0)
57e28a7c:	aa000002 	bge	57e28a8c <eth_initialize+0x90>
57e28a80:	ea000000 	b	57e28a88 <eth_initialize+0x8c>
			printf("CPU Net Initialization Failed\n");
	} else
		printf("Net Initialization Skipped\n");
57e28a84:	e59f010c 	ldr	r0, [pc, #268]	; 57e28b98 <eth_initialize+0x19c>
57e28a88:	ebff826f 	bl	57e0944c <printf>

	if (!eth_devices) {
57e28a8c:	e59f60e4 	ldr	r6, [pc, #228]	; 57e28b78 <eth_initialize+0x17c>
57e28a90:	e5964004 	ldr	r4, [r6, #4]
57e28a94:	e3540000 	cmp	r4, #0
57e28a98:	1a000005 	bne	57e28ab4 <eth_initialize+0xb8>
		puts("No ethernet found.\n");
57e28a9c:	e59f00f8 	ldr	r0, [pc, #248]	; 57e28b9c <eth_initialize+0x1a0>
57e28aa0:	ebff825f 	bl	57e09424 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
57e28aa4:	e3e0003f 	mvn	r0, #63	; 0x3f
57e28aa8:	ebff97ad 	bl	57e0e964 <__show_boot_progress>
		copy_filename(BootFile, s, sizeof(BootFile));
}

int eth_initialize(bd_t *bis)
{
	int num_devices = 0;
57e28aac:	e1a05004 	mov	r5, r4
57e28ab0:	ea00002e 	b	57e28b70 <eth_initialize+0x174>
	if (!eth_devices) {
		puts("No ethernet found.\n");
		bootstage_error(BOOTSTAGE_ID_NET_ETH_START);
	} else {
		struct eth_device *dev = eth_devices;
		char *ethprime = getenv("ethprime");
57e28ab4:	e59f00e4 	ldr	r0, [pc, #228]	; 57e28ba0 <eth_initialize+0x1a4>
57e28ab8:	ebff7b0a 	bl	57e076e8 <getenv>
57e28abc:	e1a07000 	mov	r7, r0
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
57e28ac0:	e3a00041 	mov	r0, #65	; 0x41
57e28ac4:	ebff97a6 	bl	57e0e964 <__show_boot_progress>
		copy_filename(BootFile, s, sizeof(BootFile));
}

int eth_initialize(bd_t *bis)
{
	int num_devices = 0;
57e28ac8:	e3a05000 	mov	r5, #0
		struct eth_device *dev = eth_devices;
		char *ethprime = getenv("ethprime");

		bootstage_mark(BOOTSTAGE_ID_NET_ETH_INIT);
		do {
			if (dev->index)
57e28acc:	e5943038 	ldr	r3, [r4, #56]	; 0x38
57e28ad0:	e3530000 	cmp	r3, #0
57e28ad4:	0a000001 	beq	57e28ae0 <eth_initialize+0xe4>
				puts(", ");
57e28ad8:	e59f00c4 	ldr	r0, [pc, #196]	; 57e28ba4 <eth_initialize+0x1a8>
57e28adc:	ebff8250 	bl	57e09424 <puts>

			printf("%s", dev->name);
57e28ae0:	e59f00c0 	ldr	r0, [pc, #192]	; 57e28ba8 <eth_initialize+0x1ac>
57e28ae4:	e1a01004 	mov	r1, r4
57e28ae8:	ebff8257 	bl	57e0944c <printf>

			if (ethprime && strcmp(dev->name, ethprime) == 0) {
57e28aec:	e3570000 	cmp	r7, #0
57e28af0:	0a000007 	beq	57e28b14 <eth_initialize+0x118>
57e28af4:	e1a00004 	mov	r0, r4
57e28af8:	e1a01007 	mov	r1, r7
57e28afc:	ebffed28 	bl	57e23fa4 <strcmp>
57e28b00:	e3500000 	cmp	r0, #0
57e28b04:	1a000002 	bne	57e28b14 <eth_initialize+0x118>
				eth_current = dev;
				puts(" [PRIME]");
57e28b08:	e59f009c 	ldr	r0, [pc, #156]	; 57e28bac <eth_initialize+0x1b0>
				puts(", ");

			printf("%s", dev->name);

			if (ethprime && strcmp(dev->name, ethprime) == 0) {
				eth_current = dev;
57e28b0c:	e5864000 	str	r4, [r6]
				puts(" [PRIME]");
57e28b10:	ebff8243 	bl	57e09424 <puts>
			}

			if (strchr(dev->name, ' '))
57e28b14:	e1a00004 	mov	r0, r4
57e28b18:	e3a01020 	mov	r1, #32
57e28b1c:	ebffed3e 	bl	57e2401c <strchr>
57e28b20:	e3500000 	cmp	r0, #0
57e28b24:	0a000001 	beq	57e28b30 <eth_initialize+0x134>
				puts("\nWarning: eth device name has a space!"
57e28b28:	e59f0080 	ldr	r0, [pc, #128]	; 57e28bb0 <eth_initialize+0x1b4>
57e28b2c:	ebff823c 	bl	57e09424 <puts>
					"\n");

			if (eth_write_hwaddr(dev, "eth", dev->index))
57e28b30:	e1a00004 	mov	r0, r4
57e28b34:	e59f1078 	ldr	r1, [pc, #120]	; 57e28bb4 <eth_initialize+0x1b8>
57e28b38:	e5942038 	ldr	r2, [r4, #56]	; 0x38
57e28b3c:	ebfffef4 	bl	57e28714 <eth_write_hwaddr>
57e28b40:	e3500000 	cmp	r0, #0
57e28b44:	0a000001 	beq	57e28b50 <eth_initialize+0x154>
				puts("\nWarning: failed to set MAC address\n");
57e28b48:	e59f0068 	ldr	r0, [pc, #104]	; 57e28bb8 <eth_initialize+0x1bc>
57e28b4c:	ebff8234 	bl	57e09424 <puts>

			dev = dev->next;
57e28b50:	e5944034 	ldr	r4, [r4, #52]	; 0x34
			num_devices++;
		} while (dev != eth_devices);
57e28b54:	e5963004 	ldr	r3, [r6, #4]

			if (eth_write_hwaddr(dev, "eth", dev->index))
				puts("\nWarning: failed to set MAC address\n");

			dev = dev->next;
			num_devices++;
57e28b58:	e2855001 	add	r5, r5, #1
		} while (dev != eth_devices);
57e28b5c:	e1540003 	cmp	r4, r3
57e28b60:	1affffd9 	bne	57e28acc <eth_initialize+0xd0>

		eth_current_changed();
57e28b64:	ebfffe49 	bl	57e28490 <eth_current_changed>
		putc('\n');
57e28b68:	e3a0000a 	mov	r0, #10
57e28b6c:	ebff8222 	bl	57e093fc <putc>
	}

	return num_devices;
}
57e28b70:	e1a00005 	mov	r0, r5
57e28b74:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e28b78:	57e7971c 	.word	0x57e7971c
57e28b7c:	57e2f001 	.word	0x57e2f001
57e28b80:	57e79780 	.word	0x57e79780
57e28b84:	57e2b77c 	.word	0x57e2b77c
57e28b88:	57e28488 	.word	0x57e28488
57e28b8c:	57e359d3 	.word	0x57e359d3
57e28b90:	57e28488 	.word	0x57e28488
57e28b94:	57e359f4 	.word	0x57e359f4
57e28b98:	57e35a13 	.word	0x57e35a13
57e28b9c:	57e35b58 	.word	0x57e35b58
57e28ba0:	57e35a2f 	.word	0x57e35a2f
57e28ba4:	57e314d7 	.word	0x57e314d7
57e28ba8:	57e308f5 	.word	0x57e308f5
57e28bac:	57e35a38 	.word	0x57e35a38
57e28bb0:	57e35a41 	.word	0x57e35a41
57e28bb4:	57e35a69 	.word	0x57e35a69
57e28bb8:	57e35a6d 	.word	0x57e35a6d

57e28bbc <eth_halt>:

	return -1;
}

void eth_halt(void)
{
57e28bbc:	e92d4010 	push	{r4, lr}
	if (!eth_current)
57e28bc0:	e59f4020 	ldr	r4, [pc, #32]	; 57e28be8 <eth_halt+0x2c>
57e28bc4:	e5940000 	ldr	r0, [r4]
57e28bc8:	e3500000 	cmp	r0, #0
57e28bcc:	08bd8010 	popeq	{r4, pc}
		return;

	eth_current->halt(eth_current);
57e28bd0:	e590302c 	ldr	r3, [r0, #44]	; 0x2c
57e28bd4:	e12fff33 	blx	r3

	eth_current->state = ETH_STATE_PASSIVE;
57e28bd8:	e5943000 	ldr	r3, [r4]
57e28bdc:	e3a02001 	mov	r2, #1
57e28be0:	e583201c 	str	r2, [r3, #28]
57e28be4:	e8bd8010 	pop	{r4, pc}
57e28be8:	57e7971c 	.word	0x57e7971c

57e28bec <eth_send>:
}

int eth_send(void *packet, int length)
{
57e28bec:	e92d4008 	push	{r3, lr}
	if (!eth_current)
57e28bf0:	e59f3028 	ldr	r3, [pc, #40]	; 57e28c20 <eth_send+0x34>

	eth_current->state = ETH_STATE_PASSIVE;
}

int eth_send(void *packet, int length)
{
57e28bf4:	e1a0c000 	mov	ip, r0
	if (!eth_current)
57e28bf8:	e5930000 	ldr	r0, [r3]

	eth_current->state = ETH_STATE_PASSIVE;
}

int eth_send(void *packet, int length)
{
57e28bfc:	e1a02001 	mov	r2, r1
	if (!eth_current)
57e28c00:	e3500000 	cmp	r0, #0
57e28c04:	0a000003 	beq	57e28c18 <eth_send+0x2c>
		return -1;

	return eth_current->send(eth_current, packet, length);
57e28c08:	e5903024 	ldr	r3, [r0, #36]	; 0x24
57e28c0c:	e1a0100c 	mov	r1, ip
57e28c10:	e12fff33 	blx	r3
57e28c14:	e8bd8008 	pop	{r3, pc}
}

int eth_send(void *packet, int length)
{
	if (!eth_current)
		return -1;
57e28c18:	e3e00000 	mvn	r0, #0

	return eth_current->send(eth_current, packet, length);
}
57e28c1c:	e8bd8008 	pop	{r3, pc}
57e28c20:	57e7971c 	.word	0x57e7971c

57e28c24 <eth_rx>:

int eth_rx(void)
{
57e28c24:	e92d4008 	push	{r3, lr}
	if (!eth_current)
57e28c28:	e59f301c 	ldr	r3, [pc, #28]	; 57e28c4c <eth_rx+0x28>
57e28c2c:	e5930000 	ldr	r0, [r3]
57e28c30:	e3500000 	cmp	r0, #0
57e28c34:	0a000002 	beq	57e28c44 <eth_rx+0x20>
		return -1;

	return eth_current->recv(eth_current);
57e28c38:	e5903028 	ldr	r3, [r0, #40]	; 0x28
57e28c3c:	e12fff33 	blx	r3
57e28c40:	e8bd8008 	pop	{r3, pc}
}

int eth_rx(void)
{
	if (!eth_current)
		return -1;
57e28c44:	e3e00000 	mvn	r0, #0

	return eth_current->recv(eth_current);
}
57e28c48:	e8bd8008 	pop	{r3, pc}
57e28c4c:	57e7971c 	.word	0x57e7971c

57e28c50 <eth_try_another>:
	return length;
}
#endif /* CONFIG_API */

void eth_try_another(int first_restart)
{
57e28c50:	e92d4010 	push	{r4, lr}
57e28c54:	e1a04000 	mov	r4, r0

	/*
	 * Do not rotate between network interfaces when
	 * 'ethrotate' variable is set to 'no'.
	 */
	ethrotate = getenv("ethrotate");
57e28c58:	e59f005c 	ldr	r0, [pc, #92]	; 57e28cbc <eth_try_another+0x6c>
57e28c5c:	ebff7aa1 	bl	57e076e8 <getenv>
	if ((ethrotate != NULL) && (strcmp(ethrotate, "no") == 0))
57e28c60:	e3500000 	cmp	r0, #0
57e28c64:	0a000003 	beq	57e28c78 <eth_try_another+0x28>
57e28c68:	e59f1050 	ldr	r1, [pc, #80]	; 57e28cc0 <eth_try_another+0x70>
57e28c6c:	ebffeccc 	bl	57e23fa4 <strcmp>
57e28c70:	e3500000 	cmp	r0, #0
57e28c74:	08bd8010 	popeq	{r4, pc}
		return;

	if (!eth_current)
57e28c78:	e59f2044 	ldr	r2, [pc, #68]	; 57e28cc4 <eth_try_another+0x74>
57e28c7c:	e5923000 	ldr	r3, [r2]
57e28c80:	e3530000 	cmp	r3, #0
57e28c84:	08bd8010 	popeq	{r4, pc}
		return;

	if (first_restart)
57e28c88:	e3540000 	cmp	r4, #0
		first_failed = eth_current;
57e28c8c:	1582300c 	strne	r3, [r2, #12]

	eth_current = eth_current->next;
57e28c90:	e59f402c 	ldr	r4, [pc, #44]	; 57e28cc4 <eth_try_another+0x74>
57e28c94:	e5933034 	ldr	r3, [r3, #52]	; 0x34
57e28c98:	e5843000 	str	r3, [r4]

	eth_current_changed();
57e28c9c:	ebfffdfb 	bl	57e28490 <eth_current_changed>

	if (first_failed == eth_current)
57e28ca0:	e594200c 	ldr	r2, [r4, #12]
57e28ca4:	e5943000 	ldr	r3, [r4]
57e28ca8:	e1520003 	cmp	r2, r3
		NetRestartWrap = 1;
57e28cac:	059f3014 	ldreq	r3, [pc, #20]	; 57e28cc8 <eth_try_another+0x78>
57e28cb0:	03a02001 	moveq	r2, #1
57e28cb4:	05832000 	streq	r2, [r3]
57e28cb8:	e8bd8010 	pop	{r4, pc}
57e28cbc:	57e35a92 	.word	0x57e35a92
57e28cc0:	57e2ea0d 	.word	0x57e2ea0d
57e28cc4:	57e7971c 	.word	0x57e7971c
57e28cc8:	57e79754 	.word	0x57e79754

57e28ccc <eth_init>:

#endif


int eth_init(bd_t *bis)
{
57e28ccc:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct eth_device *old_current, *dev;

	if (!eth_current) {
57e28cd0:	e59f70ac 	ldr	r7, [pc, #172]	; 57e28d84 <eth_init+0xb8>

#endif


int eth_init(bd_t *bis)
{
57e28cd4:	e1a06000 	mov	r6, r0
	struct eth_device *old_current, *dev;

	if (!eth_current) {
57e28cd8:	e5973000 	ldr	r3, [r7]
57e28cdc:	e3530000 	cmp	r3, #0
		puts("No ethernet found.\n");
		return -1;
	}

	/* Sync environment with network devices */
	dev = eth_devices;
57e28ce0:	15974004 	ldrne	r4, [r7, #4]

int eth_init(bd_t *bis)
{
	struct eth_device *old_current, *dev;

	if (!eth_current) {
57e28ce4:	1a000002 	bne	57e28cf4 <eth_init+0x28>
		puts("No ethernet found.\n");
57e28ce8:	e59f0098 	ldr	r0, [pc, #152]	; 57e28d88 <eth_init+0xbc>
57e28cec:	ebff81cc 	bl	57e09424 <puts>
57e28cf0:	ea000021 	b	57e28d7c <eth_init+0xb0>
	/* Sync environment with network devices */
	dev = eth_devices;
	do {
		uchar env_enetaddr[6];

		if (eth_getenv_enetaddr_by_index("eth", dev->index,
57e28cf4:	e59f0090 	ldr	r0, [pc, #144]	; 57e28d8c <eth_init+0xc0>
57e28cf8:	e5941038 	ldr	r1, [r4, #56]	; 0x38
57e28cfc:	e1a0200d 	mov	r2, sp
57e28d00:	ebfffe35 	bl	57e285dc <eth_getenv_enetaddr_by_index>
57e28d04:	e3500000 	cmp	r0, #0
57e28d08:	0a000003 	beq	57e28d1c <eth_init+0x50>
						 env_enetaddr))
			memcpy(dev->enetaddr, env_enetaddr, 6);
57e28d0c:	e2840010 	add	r0, r4, #16
57e28d10:	e1a0100d 	mov	r1, sp
57e28d14:	e3a02006 	mov	r2, #6
57e28d18:	ebffed7b 	bl	57e2430c <memcpy>

		dev = dev->next;
57e28d1c:	e5944034 	ldr	r4, [r4, #52]	; 0x34
	} while (dev != eth_devices);
57e28d20:	e5972004 	ldr	r2, [r7, #4]
57e28d24:	e59f3058 	ldr	r3, [pc, #88]	; 57e28d84 <eth_init+0xb8>
57e28d28:	e1540002 	cmp	r4, r2
57e28d2c:	1afffff0 	bne	57e28cf4 <eth_init+0x28>

	old_current = eth_current;
57e28d30:	e5935000 	ldr	r5, [r3]
	do {
		debug("Trying %s\n", eth_current->name);

		if (eth_current->init(eth_current, bis) >= 0) {
57e28d34:	e1a04003 	mov	r4, r3
57e28d38:	e5940000 	ldr	r0, [r4]
57e28d3c:	e1a01006 	mov	r1, r6
57e28d40:	e5903020 	ldr	r3, [r0, #32]
57e28d44:	e12fff33 	blx	r3
57e28d48:	e3500000 	cmp	r0, #0
57e28d4c:	ba000005 	blt	57e28d68 <eth_init+0x9c>
			eth_current->state = ETH_STATE_ACTIVE;
57e28d50:	e59f302c 	ldr	r3, [pc, #44]	; 57e28d84 <eth_init+0xb8>
57e28d54:	e3a02002 	mov	r2, #2
57e28d58:	e5933000 	ldr	r3, [r3]

			return 0;
57e28d5c:	e3a00000 	mov	r0, #0
	old_current = eth_current;
	do {
		debug("Trying %s\n", eth_current->name);

		if (eth_current->init(eth_current, bis) >= 0) {
			eth_current->state = ETH_STATE_ACTIVE;
57e28d60:	e583201c 	str	r2, [r3, #28]

			return 0;
57e28d64:	ea000005 	b	57e28d80 <eth_init+0xb4>
		}
		debug("FAIL\n");

		eth_try_another(0);
57e28d68:	e3a00000 	mov	r0, #0
57e28d6c:	ebffffb7 	bl	57e28c50 <eth_try_another>
	} while (old_current != eth_current);
57e28d70:	e5943000 	ldr	r3, [r4]
57e28d74:	e1550003 	cmp	r5, r3
57e28d78:	1affffee 	bne	57e28d38 <eth_init+0x6c>

	return -1;
57e28d7c:	e3e00000 	mvn	r0, #0
}
57e28d80:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
57e28d84:	57e7971c 	.word	0x57e7971c
57e28d88:	57e35b58 	.word	0x57e35b58
57e28d8c:	57e35a69 	.word	0x57e35a69

57e28d90 <eth_set_current>:
	if (first_failed == eth_current)
		NetRestartWrap = 1;
}

void eth_set_current(void)
{
57e28d90:	e92d4070 	push	{r4, r5, r6, lr}
	static char *act;
	static int  env_changed_id;
	struct eth_device *old_current;
	int	env_id;

	if (!eth_current)	/* XXX no current */
57e28d94:	e59f4080 	ldr	r4, [pc, #128]	; 57e28e1c <eth_set_current+0x8c>
57e28d98:	e5943000 	ldr	r3, [r4]
57e28d9c:	e3530000 	cmp	r3, #0
57e28da0:	08bd8070 	popeq	{r4, r5, r6, pc}
		return;

	env_id = get_env_id();
57e28da4:	ebff793d 	bl	57e072a0 <get_env_id>
	if ((act == NULL) || (env_changed_id != env_id)) {
57e28da8:	e5943010 	ldr	r3, [r4, #16]
	int	env_id;

	if (!eth_current)	/* XXX no current */
		return;

	env_id = get_env_id();
57e28dac:	e1a05000 	mov	r5, r0
	if ((act == NULL) || (env_changed_id != env_id)) {
57e28db0:	e3530000 	cmp	r3, #0
57e28db4:	0a000002 	beq	57e28dc4 <eth_set_current+0x34>
57e28db8:	e5943014 	ldr	r3, [r4, #20]
57e28dbc:	e1530000 	cmp	r3, r0
57e28dc0:	0a000004 	beq	57e28dd8 <eth_set_current+0x48>
		act = getenv("ethact");
57e28dc4:	e59f0054 	ldr	r0, [pc, #84]	; 57e28e20 <eth_set_current+0x90>
57e28dc8:	ebff7a46 	bl	57e076e8 <getenv>
57e28dcc:	e59f3048 	ldr	r3, [pc, #72]	; 57e28e1c <eth_set_current+0x8c>
57e28dd0:	e5830010 	str	r0, [r3, #16]
		env_changed_id = env_id;
57e28dd4:	e5835014 	str	r5, [r3, #20]
	}
	if (act != NULL) {
57e28dd8:	e59f403c 	ldr	r4, [pc, #60]	; 57e28e1c <eth_set_current+0x8c>
57e28ddc:	e5943010 	ldr	r3, [r4, #16]
57e28de0:	e3530000 	cmp	r3, #0
57e28de4:	0a00000a 	beq	57e28e14 <eth_set_current+0x84>
		old_current = eth_current;
57e28de8:	e5945000 	ldr	r5, [r4]
		do {
			if (strcmp(eth_current->name, act) == 0)
57e28dec:	e5940000 	ldr	r0, [r4]
57e28df0:	e5941010 	ldr	r1, [r4, #16]
57e28df4:	ebffec6a 	bl	57e23fa4 <strcmp>
57e28df8:	e3500000 	cmp	r0, #0
57e28dfc:	08bd8070 	popeq	{r4, r5, r6, pc}
				return;
			eth_current = eth_current->next;
57e28e00:	e5943000 	ldr	r3, [r4]
57e28e04:	e5933034 	ldr	r3, [r3, #52]	; 0x34
		} while (old_current != eth_current);
57e28e08:	e1550003 	cmp	r5, r3
	if (act != NULL) {
		old_current = eth_current;
		do {
			if (strcmp(eth_current->name, act) == 0)
				return;
			eth_current = eth_current->next;
57e28e0c:	e5843000 	str	r3, [r4]
		} while (old_current != eth_current);
57e28e10:	1afffff5 	bne	57e28dec <eth_set_current+0x5c>
	}

	eth_current_changed();
}
57e28e14:	e8bd4070 	pop	{r4, r5, r6, lr}
				return;
			eth_current = eth_current->next;
		} while (old_current != eth_current);
	}

	eth_current_changed();
57e28e18:	eafffd9c 	b	57e28490 <eth_current_changed>
57e28e1c:	57e7971c 	.word	0x57e7971c
57e28e20:	57e35901 	.word	0x57e35901

57e28e24 <eth_get_name>:
}

char *eth_get_name(void)
{
	return eth_current ? eth_current->name : "unknown";
57e28e24:	e59f3010 	ldr	r3, [pc, #16]	; 57e28e3c <eth_get_name+0x18>
57e28e28:	e5930000 	ldr	r0, [r3]
}
57e28e2c:	e59f300c 	ldr	r3, [pc, #12]	; 57e28e40 <eth_get_name+0x1c>
57e28e30:	e3500000 	cmp	r0, #0
57e28e34:	01a00003 	moveq	r0, r3
57e28e38:	e12fff1e 	bx	lr
57e28e3c:	57e7971c 	.word	0x57e7971c
57e28e40:	57e35a9c 	.word	0x57e35a9c

57e28e44 <startAgainTimeout>:
extern enum net_loop_state net_state;

static inline void net_set_state(enum net_loop_state state)
{
	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
57e28e44:	e59f3008 	ldr	r3, [pc, #8]	; 57e28e54 <startAgainTimeout+0x10>
57e28e48:	e3a02001 	mov	r2, #1
57e28e4c:	e5832000 	str	r2, [r3]

static void
startAgainTimeout(void)
{
	net_set_state(NETLOOP_RESTART);
}
57e28e50:	e12fff1e 	bx	lr
57e28e54:	57e79734 	.word	0x57e79734

57e28e58 <dummy_handler>:

static void dummy_handler(uchar *pkt, unsigned dport,
			IPaddr_t sip, unsigned sport,
			unsigned len)
{
}
57e28e58:	e12fff1e 	bx	lr

57e28e5c <net_auto_load>:
/*
 * Check if autoload is enabled. If so, use either NFS or TFTP to download
 * the boot file.
 */
void net_auto_load(void)
{
57e28e5c:	e92d4010 	push	{r4, lr}
#if defined(CONFIG_CMD_NFS)
	const char *s = getenv("autoload");
57e28e60:	e59f004c 	ldr	r0, [pc, #76]	; 57e28eb4 <net_auto_load+0x58>
57e28e64:	ebff7a1f 	bl	57e076e8 <getenv>

	if (s != NULL && strcmp(s, "NFS") == 0) {
57e28e68:	e3500000 	cmp	r0, #0
57e28e6c:	0a000005 	beq	57e28e88 <net_auto_load+0x2c>
57e28e70:	e59f1040 	ldr	r1, [pc, #64]	; 57e28eb8 <net_auto_load+0x5c>
57e28e74:	ebffec4a 	bl	57e23fa4 <strcmp>
57e28e78:	e3500000 	cmp	r0, #0
57e28e7c:	1a000001 	bne	57e28e88 <net_auto_load+0x2c>
		 */
		net_set_state(NETLOOP_SUCCESS);
		return;
	}
	TftpStart(TFTPGET);
}
57e28e80:	e8bd4010 	pop	{r4, lr}

	if (s != NULL && strcmp(s, "NFS") == 0) {
		/*
		 * Use NFS to load the bootfile.
		 */
		NfsStart();
57e28e84:	ea0006dc 	b	57e2a9fc <NfsStart>
		return;
	}
#endif
	if (getenv_yesno("autoload") == 0) {
57e28e88:	e59f0024 	ldr	r0, [pc, #36]	; 57e28eb4 <net_auto_load+0x58>
57e28e8c:	ebff87bf 	bl	57e0ad90 <getenv_yesno>
57e28e90:	e3500000 	cmp	r0, #0
57e28e94:	1a000003 	bne	57e28ea8 <net_auto_load+0x4c>
57e28e98:	e59f301c 	ldr	r3, [pc, #28]	; 57e28ebc <net_auto_load+0x60>
57e28e9c:	e3a02002 	mov	r2, #2
57e28ea0:	e5832000 	str	r2, [r3]
		 */
		net_set_state(NETLOOP_SUCCESS);
		return;
	}
	TftpStart(TFTPGET);
}
57e28ea4:	e8bd8010 	pop	{r4, pc}
		 * Do not use TFTP to load the bootfile.
		 */
		net_set_state(NETLOOP_SUCCESS);
		return;
	}
	TftpStart(TFTPGET);
57e28ea8:	e3a00003 	mov	r0, #3
}
57e28eac:	e8bd4010 	pop	{r4, lr}
		 * Do not use TFTP to load the bootfile.
		 */
		net_set_state(NETLOOP_SUCCESS);
		return;
	}
	TftpStart(TFTPGET);
57e28eb0:	ea000943 	b	57e2b3c4 <TftpStart>
57e28eb4:	57e35aa4 	.word	0x57e35aa4
57e28eb8:	57e35aad 	.word	0x57e35aad
57e28ebc:	57e79734 	.word	0x57e79734

57e28ec0 <net_get_udp_handler>:
}

rxhand_f *net_get_udp_handler(void)
{
	return udp_packet_handler;
}
57e28ec0:	e59f3004 	ldr	r3, [pc, #4]	; 57e28ecc <net_get_udp_handler+0xc>
57e28ec4:	e5930004 	ldr	r0, [r3, #4]
57e28ec8:	e12fff1e 	bx	lr
57e28ecc:	57e79734 	.word	0x57e79734

57e28ed0 <net_set_udp_handler>:

void net_set_udp_handler(rxhand_f *f)
{
	debug_cond(DEBUG_INT_STATE, "--- NetLoop UDP handler set (%p)\n", f);
	if (f == NULL)
57e28ed0:	e3500000 	cmp	r0, #0
57e28ed4:	e59f300c 	ldr	r3, [pc, #12]	; 57e28ee8 <net_set_udp_handler+0x18>
		udp_packet_handler = dummy_handler;
57e28ed8:	059f200c 	ldreq	r2, [pc, #12]	; 57e28eec <net_set_udp_handler+0x1c>
	else
		udp_packet_handler = f;
57e28edc:	15830004 	strne	r0, [r3, #4]

void net_set_udp_handler(rxhand_f *f)
{
	debug_cond(DEBUG_INT_STATE, "--- NetLoop UDP handler set (%p)\n", f);
	if (f == NULL)
		udp_packet_handler = dummy_handler;
57e28ee0:	05832004 	streq	r2, [r3, #4]
57e28ee4:	e12fff1e 	bx	lr
57e28ee8:	57e79734 	.word	0x57e79734
57e28eec:	57e28e58 	.word	0x57e28e58

57e28ef0 <net_get_arp_handler>:
}

rxhand_f *net_get_arp_handler(void)
{
	return arp_packet_handler;
}
57e28ef0:	e59f3004 	ldr	r3, [pc, #4]	; 57e28efc <net_get_arp_handler+0xc>
57e28ef4:	e5930008 	ldr	r0, [r3, #8]
57e28ef8:	e12fff1e 	bx	lr
57e28efc:	57e79734 	.word	0x57e79734

57e28f00 <net_set_arp_handler>:

void net_set_arp_handler(rxhand_f *f)
{
	debug_cond(DEBUG_INT_STATE, "--- NetLoop ARP handler set (%p)\n", f);
	if (f == NULL)
57e28f00:	e3500000 	cmp	r0, #0
57e28f04:	e59f300c 	ldr	r3, [pc, #12]	; 57e28f18 <net_set_arp_handler+0x18>
		arp_packet_handler = dummy_handler;
57e28f08:	059f200c 	ldreq	r2, [pc, #12]	; 57e28f1c <net_set_arp_handler+0x1c>
	else
		arp_packet_handler = f;
57e28f0c:	15830008 	strne	r0, [r3, #8]

void net_set_arp_handler(rxhand_f *f)
{
	debug_cond(DEBUG_INT_STATE, "--- NetLoop ARP handler set (%p)\n", f);
	if (f == NULL)
		arp_packet_handler = dummy_handler;
57e28f10:	05832008 	streq	r2, [r3, #8]
57e28f14:	e12fff1e 	bx	lr
57e28f18:	57e79734 	.word	0x57e79734
57e28f1c:	57e28e58 	.word	0x57e28e58

57e28f20 <NetSetTimeout>:
}
#endif

void
NetSetTimeout(ulong iv, thand_f *f)
{
57e28f20:	e92d4038 	push	{r3, r4, r5, lr}
57e28f24:	e59f402c 	ldr	r4, [pc, #44]	; 57e28f58 <NetSetTimeout+0x38>
	if (iv == 0) {
57e28f28:	e2505000 	subs	r5, r0, #0
		debug_cond(DEBUG_INT_STATE,
			"--- NetLoop timeout handler cancelled\n");
		timeHandler = (thand_f *)0;
57e28f2c:	0584500c 	streq	r5, [r4, #12]
#endif

void
NetSetTimeout(ulong iv, thand_f *f)
{
	if (iv == 0) {
57e28f30:	08bd8038 	popeq	{r3, r4, r5, pc}
		timeHandler = (thand_f *)0;
	} else {
		debug_cond(DEBUG_INT_STATE,
			"--- NetLoop timeout handler set (%p)\n", f);
		timeHandler = f;
		timeStart = get_timer(0);
57e28f34:	e3a00000 	mov	r0, #0
			"--- NetLoop timeout handler cancelled\n");
		timeHandler = (thand_f *)0;
	} else {
		debug_cond(DEBUG_INT_STATE,
			"--- NetLoop timeout handler set (%p)\n", f);
		timeHandler = f;
57e28f38:	e584100c 	str	r1, [r4, #12]
		timeStart = get_timer(0);
57e28f3c:	ebff5ef2 	bl	57e00b0c <get_timer>
		timeDelta = iv * CONFIG_SYS_HZ / 1000;
57e28f40:	e3a01ffa 	mov	r1, #1000	; 0x3e8
		timeHandler = (thand_f *)0;
	} else {
		debug_cond(DEBUG_INT_STATE,
			"--- NetLoop timeout handler set (%p)\n", f);
		timeHandler = f;
		timeStart = get_timer(0);
57e28f44:	e5840010 	str	r0, [r4, #16]
		timeDelta = iv * CONFIG_SYS_HZ / 1000;
57e28f48:	e0000591 	mul	r0, r1, r5
57e28f4c:	eb000a17 	bl	57e2b7b0 <__udivsi3>
57e28f50:	e5840014 	str	r0, [r4, #20]
57e28f54:	e8bd8038 	pop	{r3, r4, r5, pc}
57e28f58:	57e79734 	.word	0x57e79734

57e28f5c <NetStartAgain>:
{
	net_set_state(NETLOOP_RESTART);
}

void NetStartAgain(void)
{
57e28f5c:	e92d4070 	push	{r4, r5, r6, lr}
	char *nretry;
	int retry_forever = 0;
	unsigned long retrycnt = 0;

	nretry = getenv("netretry");
57e28f60:	e59f00e8 	ldr	r0, [pc, #232]	; 57e29050 <NetStartAgain+0xf4>
57e28f64:	ebff79df 	bl	57e076e8 <getenv>
	if (nretry) {
57e28f68:	e2504000 	subs	r4, r0, #0
57e28f6c:	0a00001a 	beq	57e28fdc <NetStartAgain+0x80>
		if (!strcmp(nretry, "yes"))
57e28f70:	e59f10dc 	ldr	r1, [pc, #220]	; 57e29054 <NetStartAgain+0xf8>
57e28f74:	ebffec0a 	bl	57e23fa4 <strcmp>
57e28f78:	e3500000 	cmp	r0, #0
57e28f7c:	0a000016 	beq	57e28fdc <NetStartAgain+0x80>
			retry_forever = 1;
		else if (!strcmp(nretry, "no"))
57e28f80:	e1a00004 	mov	r0, r4
57e28f84:	e59f10cc 	ldr	r1, [pc, #204]	; 57e29058 <NetStartAgain+0xfc>
57e28f88:	ebffec05 	bl	57e23fa4 <strcmp>
57e28f8c:	e3500000 	cmp	r0, #0
57e28f90:	0a000009 	beq	57e28fbc <NetStartAgain+0x60>
			retrycnt = 0;
		else if (!strcmp(nretry, "once"))
57e28f94:	e1a00004 	mov	r0, r4
57e28f98:	e59f10bc 	ldr	r1, [pc, #188]	; 57e2905c <NetStartAgain+0x100>
57e28f9c:	ebffec00 	bl	57e23fa4 <strcmp>
57e28fa0:	e3500000 	cmp	r0, #0
			retrycnt = 1;
57e28fa4:	03a00001 	moveq	r0, #1
	if (nretry) {
		if (!strcmp(nretry, "yes"))
			retry_forever = 1;
		else if (!strcmp(nretry, "no"))
			retrycnt = 0;
		else if (!strcmp(nretry, "once"))
57e28fa8:	0a000003 	beq	57e28fbc <NetStartAgain+0x60>
			retrycnt = 1;
		else
			retrycnt = simple_strtoul(nretry, NULL, 0);
57e28fac:	e3a01000 	mov	r1, #0
57e28fb0:	e1a00004 	mov	r0, r4
57e28fb4:	e1a02001 	mov	r2, r1
57e28fb8:	ebfff039 	bl	57e250a4 <simple_strtoul>
	} else
		retry_forever = 1;

	if ((!retry_forever) && (NetTryCount >= retrycnt)) {
57e28fbc:	e59f409c 	ldr	r4, [pc, #156]	; 57e29060 <NetStartAgain+0x104>
57e28fc0:	e5943018 	ldr	r3, [r4, #24]
57e28fc4:	e1530000 	cmp	r3, r0
57e28fc8:	3a000003 	bcc	57e28fdc <NetStartAgain+0x80>
		eth_halt();
57e28fcc:	ebfffefa 	bl	57e28bbc <eth_halt>
57e28fd0:	e3a03003 	mov	r3, #3
57e28fd4:	e5843000 	str	r3, [r4]
57e28fd8:	e8bd8070 	pop	{r4, r5, r6, pc}
		net_set_state(NETLOOP_FAIL);
		return;
	}

	NetTryCount++;
57e28fdc:	e59f507c 	ldr	r5, [pc, #124]	; 57e29060 <NetStartAgain+0x104>
57e28fe0:	e5953018 	ldr	r3, [r5, #24]
57e28fe4:	e2833001 	add	r3, r3, #1
57e28fe8:	e5853018 	str	r3, [r5, #24]

	eth_halt();
57e28fec:	ebfffef2 	bl	57e28bbc <eth_halt>
#if !defined(CONFIG_NET_DO_NOT_TRY_ANOTHER)
	eth_try_another(!NetRestarted);
57e28ff0:	e595001c 	ldr	r0, [r5, #28]
57e28ff4:	e2700001 	rsbs	r0, r0, #1
57e28ff8:	33a00000 	movcc	r0, #0
57e28ffc:	ebffff13 	bl	57e28c50 <eth_try_another>
#endif
	eth_init(gd->bd);
57e29000:	e5980000 	ldr	r0, [r8]
57e29004:	ebffff30 	bl	57e28ccc <eth_init>
	if (NetRestartWrap) {
57e29008:	e5953020 	ldr	r3, [r5, #32]
57e2900c:	e3530000 	cmp	r3, #0
57e29010:	03a03001 	moveq	r3, #1
57e29014:	0a00000b 	beq	57e29048 <NetStartAgain+0xec>
		NetRestartWrap = 0;
		if (NetDevExists) {
57e29018:	e5953024 	ldr	r3, [r5, #36]	; 0x24
#if !defined(CONFIG_NET_DO_NOT_TRY_ANOTHER)
	eth_try_another(!NetRestarted);
#endif
	eth_init(gd->bd);
	if (NetRestartWrap) {
		NetRestartWrap = 0;
57e2901c:	e3a04000 	mov	r4, #0
		if (NetDevExists) {
57e29020:	e1530004 	cmp	r3, r4
#if !defined(CONFIG_NET_DO_NOT_TRY_ANOTHER)
	eth_try_another(!NetRestarted);
#endif
	eth_init(gd->bd);
	if (NetRestartWrap) {
		NetRestartWrap = 0;
57e29024:	e5854020 	str	r4, [r5, #32]
57e29028:	03a03003 	moveq	r3, #3
		if (NetDevExists) {
57e2902c:	0a000005 	beq	57e29048 <NetStartAgain+0xec>
			NetSetTimeout(10000UL, startAgainTimeout);
57e29030:	e59f002c 	ldr	r0, [pc, #44]	; 57e29064 <NetStartAgain+0x108>
57e29034:	e59f102c 	ldr	r1, [pc, #44]	; 57e29068 <NetStartAgain+0x10c>
57e29038:	ebffffb8 	bl	57e28f20 <NetSetTimeout>
			net_set_udp_handler(NULL);
57e2903c:	e1a00004 	mov	r0, r4
			net_set_state(NETLOOP_FAIL);
		}
	} else {
		net_set_state(NETLOOP_RESTART);
	}
}
57e29040:	e8bd4070 	pop	{r4, r5, r6, lr}
	eth_init(gd->bd);
	if (NetRestartWrap) {
		NetRestartWrap = 0;
		if (NetDevExists) {
			NetSetTimeout(10000UL, startAgainTimeout);
			net_set_udp_handler(NULL);
57e29044:	eaffffa1 	b	57e28ed0 <net_set_udp_handler>
57e29048:	e5853000 	str	r3, [r5]
57e2904c:	e8bd8070 	pop	{r4, r5, r6, pc}
57e29050:	57e35ab1 	.word	0x57e35ab1
57e29054:	57e2ea4b 	.word	0x57e2ea4b
57e29058:	57e2ea0d 	.word	0x57e2ea0d
57e2905c:	57e35aba 	.word	0x57e35aba
57e29060:	57e79734 	.word	0x57e79734
57e29064:	00002710 	.word	0x00002710
57e29068:	57e28e44 	.word	0x57e28e44

57e2906c <net_clear_handlers>:

	return;
}

static void net_clear_handlers(void)
{
57e2906c:	e92d4010 	push	{r4, lr}
	net_set_udp_handler(NULL);
57e29070:	e3a00000 	mov	r0, #0
57e29074:	ebffff95 	bl	57e28ed0 <net_set_udp_handler>
	net_set_arp_handler(NULL);
57e29078:	e3a00000 	mov	r0, #0
57e2907c:	ebffff9f 	bl	57e28f00 <net_set_arp_handler>
	NetSetTimeout(0, NULL);
57e29080:	e3a00000 	mov	r0, #0
57e29084:	e1a01000 	mov	r1, r0
}
57e29088:	e8bd4010 	pop	{r4, lr}

static void net_clear_handlers(void)
{
	net_set_udp_handler(NULL);
	net_set_arp_handler(NULL);
	NetSetTimeout(0, NULL);
57e2908c:	eaffffa3 	b	57e28f20 <NetSetTimeout>

57e29090 <NetCksum>:
NetCksum(uchar *ptr, int len)
{
	ulong	xsum;
	ushort *p = (ushort *)ptr;

	xsum = 0;
57e29090:	e3a03000 	mov	r3, #0
	while (len-- > 0)
57e29094:	ea000002 	b	57e290a4 <NetCksum+0x14>
		xsum += *p++;
57e29098:	e0d020b2 	ldrh	r2, [r0], #2
57e2909c:	e2411001 	sub	r1, r1, #1
57e290a0:	e0833002 	add	r3, r3, r2
{
	ulong	xsum;
	ushort *p = (ushort *)ptr;

	xsum = 0;
	while (len-- > 0)
57e290a4:	e3510000 	cmp	r1, #0
57e290a8:	cafffffa 	bgt	57e29098 <NetCksum+0x8>
		xsum += *p++;
	xsum = (xsum & 0xffff) + (xsum >> 16);
57e290ac:	e1a02803 	lsl	r2, r3, #16
57e290b0:	e1a03823 	lsr	r3, r3, #16
57e290b4:	e0833822 	add	r3, r3, r2, lsr #16
	xsum = (xsum & 0xffff) + (xsum >> 16);
57e290b8:	e0833823 	add	r3, r3, r3, lsr #16
	return xsum & 0xffff;
57e290bc:	e1a00803 	lsl	r0, r3, #16
}
57e290c0:	e1a00820 	lsr	r0, r0, #16
57e290c4:	e12fff1e 	bx	lr

57e290c8 <NetCksumOk>:
}
/**********************************************************************/

int
NetCksumOk(uchar *ptr, int len)
{
57e290c8:	e92d4008 	push	{r3, lr}
	return !((NetCksum(ptr, len) + 1) & 0xfffe);
57e290cc:	ebffffef 	bl	57e29090 <NetCksum>
57e290d0:	e59f3010 	ldr	r3, [pc, #16]	; 57e290e8 <NetCksumOk+0x20>
57e290d4:	e2800001 	add	r0, r0, #1
57e290d8:	e0003003 	and	r3, r0, r3
}
57e290dc:	e2730001 	rsbs	r0, r3, #1
57e290e0:	33a00000 	movcc	r0, #0
57e290e4:	e8bd8008 	pop	{r3, pc}
57e290e8:	0000fffe 	.word	0x0000fffe

57e290ec <NetReceive>:
	}
}

void
NetReceive(uchar *inpkt, int len)
{
57e290ec:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
#endif
	ushort cti = 0, vlanid = VLAN_NONE, myvlanid, mynvlanid;

	debug_cond(DEBUG_NET_PKT, "packet received\n");

	NetRxPacket = inpkt;
57e290f0:	e59f3290 	ldr	r3, [pc, #656]	; 57e29388 <NetReceive+0x29c>
	NetRxPacketLen = len;
	et = (struct ethernet_hdr *)inpkt;

	/* too small packet? */
	if (len < ETHER_HDR_SIZE)
57e290f4:	e351000d 	cmp	r1, #13
	}
}

void
NetReceive(uchar *inpkt, int len)
{
57e290f8:	e1a05000 	mov	r5, r0
#endif
	ushort cti = 0, vlanid = VLAN_NONE, myvlanid, mynvlanid;

	debug_cond(DEBUG_NET_PKT, "packet received\n");

	NetRxPacket = inpkt;
57e290fc:	e5830028 	str	r0, [r3, #40]	; 0x28
	NetRxPacketLen = len;
57e29100:	e583102c 	str	r1, [r3, #44]	; 0x2c
	et = (struct ethernet_hdr *)inpkt;

	/* too small packet? */
	if (len < ETHER_HDR_SIZE)
57e29104:	9a00009e 	bls	57e29384 <NetReceive+0x298>
#if defined(CONFIG_CMD_CDP)
	/* keep track if packet is CDP */
	iscdp = is_cdp_packet(et->et_dest);
#endif

	myvlanid = ntohs(NetOurVLAN);
57e29108:	e59fc27c 	ldr	ip, [pc, #636]	; 57e2938c <NetReceive+0x2a0>
	if (myvlanid == (ushort)-1)
57e2910c:	e59f027c 	ldr	r0, [pc, #636]	; 57e29390 <NetReceive+0x2a4>
#if defined(CONFIG_CMD_CDP)
	/* keep track if packet is CDP */
	iscdp = is_cdp_packet(et->et_dest);
#endif

	myvlanid = ntohs(NetOurVLAN);
57e29110:	e1dc30b0 	ldrh	r3, [ip]
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
57e29114:	e1dcc0b2 	ldrh	ip, [ip, #2]
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
57e29118:	e1a02423 	lsr	r2, r3, #8
57e2911c:	e1822403 	orr	r2, r2, r3, lsl #8
57e29120:	e1a0442c 	lsr	r4, ip, #8
	/* keep track if packet is CDP */
	iscdp = is_cdp_packet(et->et_dest);
#endif

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
57e29124:	e59f3268 	ldr	r3, [pc, #616]	; 57e29394 <NetReceive+0x2a8>
57e29128:	e184c40c 	orr	ip, r4, ip, lsl #8
57e2912c:	e1a02802 	lsl	r2, r2, #16
57e29130:	e1a02822 	lsr	r2, r2, #16
57e29134:	e1a0c80c 	lsl	ip, ip, #16
57e29138:	e1520003 	cmp	r2, r3
57e2913c:	e1a0c82c 	lsr	ip, ip, #16
57e29140:	11a06002 	movne	r6, r2
57e29144:	01a06000 	moveq	r6, r0
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
	if (mynvlanid == (ushort)-1)
		mynvlanid = VLAN_NONE;
57e29148:	e15c0003 	cmp	ip, r3

	eth_proto = ntohs(et->et_protlen);
57e2914c:	e1d530bc 	ldrh	r3, [r5, #12]
	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
	if (mynvlanid == (ushort)-1)
		mynvlanid = VLAN_NONE;
57e29150:	01a0c000 	moveq	ip, r0
57e29154:	e1a04423 	lsr	r4, r3, #8
57e29158:	e1843403 	orr	r3, r4, r3, lsl #8

	eth_proto = ntohs(et->et_protlen);
57e2915c:	e1a03803 	lsl	r3, r3, #16

	if (eth_proto < 1514) {
57e29160:	e59f4230 	ldr	r4, [pc, #560]	; 57e29398 <NetReceive+0x2ac>
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
	if (mynvlanid == (ushort)-1)
		mynvlanid = VLAN_NONE;

	eth_proto = ntohs(et->et_protlen);
57e29164:	e1a03823 	lsr	r3, r3, #16

	if (eth_proto < 1514) {
57e29168:	e1530004 	cmp	r3, r4
57e2916c:	ca000007 	bgt	57e29190 <NetReceive+0xa4>
		struct e802_hdr *et802 = (struct e802_hdr *)et;
		/*
		 *	Got a 802.2 packet.  Check the other protocol field.
		 *	XXX VLAN over 802.2+SNAP not implemented!
		 */
		eth_proto = ntohs(et802->et_prot);
57e29170:	e1d531b4 	ldrh	r3, [r5, #20]

		ip = (struct ip_udp_hdr *)(inpkt + E802_HDR_SIZE);
57e29174:	e2854016 	add	r4, r5, #22
57e29178:	e1a02423 	lsr	r2, r3, #8
57e2917c:	e1823403 	orr	r3, r2, r3, lsl #8
		struct e802_hdr *et802 = (struct e802_hdr *)et;
		/*
		 *	Got a 802.2 packet.  Check the other protocol field.
		 *	XXX VLAN over 802.2+SNAP not implemented!
		 */
		eth_proto = ntohs(et802->et_prot);
57e29180:	e1a03803 	lsl	r3, r3, #16
57e29184:	e1a03823 	lsr	r3, r3, #16

		ip = (struct ip_udp_hdr *)(inpkt + E802_HDR_SIZE);
		len -= E802_HDR_SIZE;
57e29188:	e2412016 	sub	r2, r1, #22
57e2918c:	ea000014 	b	57e291e4 <NetReceive+0xf8>

	} else if (eth_proto != PROT_VLAN) {	/* normal packet */
57e29190:	e3530c81 	cmp	r3, #33024	; 0x8100
		ip = (struct ip_udp_hdr *)(inpkt + ETHER_HDR_SIZE);
57e29194:	1285400e 	addne	r4, r5, #14
		len -= ETHER_HDR_SIZE;
57e29198:	1241200e 	subne	r2, r1, #14
		eth_proto = ntohs(et802->et_prot);

		ip = (struct ip_udp_hdr *)(inpkt + E802_HDR_SIZE);
		len -= E802_HDR_SIZE;

	} else if (eth_proto != PROT_VLAN) {	/* normal packet */
57e2919c:	1a000010 	bne	57e291e4 <NetReceive+0xf8>
			(struct vlan_ethernet_hdr *)et;

		debug_cond(DEBUG_NET_PKT, "VLAN packet received\n");

		/* too small packet? */
		if (len < VLAN_ETHER_HDR_SIZE)
57e291a0:	e3510011 	cmp	r1, #17
57e291a4:	9a000076 	bls	57e29384 <NetReceive+0x298>
			return;

		/* if no VLAN active */
		if ((ntohs(NetOurVLAN) & VLAN_IDMASK) == VLAN_NONE
57e291a8:	e1a02a02 	lsl	r2, r2, #20
57e291ac:	e1500a22 	cmp	r0, r2, lsr #20
57e291b0:	0a000073 	beq	57e29384 <NetReceive+0x298>
				&& iscdp == 0
#endif
				)
			return;

		cti = ntohs(vet->vet_tag);
57e291b4:	e1d530be 	ldrh	r3, [r5, #14]
		vlanid = cti & VLAN_IDMASK;
		eth_proto = ntohs(vet->vet_type);

		ip = (struct ip_udp_hdr *)(inpkt + VLAN_ETHER_HDR_SIZE);
57e291b8:	e2854012 	add	r4, r5, #18
57e291bc:	e1a00423 	lsr	r0, r3, #8
57e291c0:	e1800403 	orr	r0, r0, r3, lsl #8
				)
			return;

		cti = ntohs(vet->vet_tag);
		vlanid = cti & VLAN_IDMASK;
		eth_proto = ntohs(vet->vet_type);
57e291c4:	e1d531b0 	ldrh	r3, [r5, #16]
#endif
				)
			return;

		cti = ntohs(vet->vet_tag);
		vlanid = cti & VLAN_IDMASK;
57e291c8:	e1a00a00 	lsl	r0, r0, #20
57e291cc:	e1a02423 	lsr	r2, r3, #8
57e291d0:	e1823403 	orr	r3, r2, r3, lsl #8
		eth_proto = ntohs(vet->vet_type);
57e291d4:	e1a03803 	lsl	r3, r3, #16
#endif
				)
			return;

		cti = ntohs(vet->vet_tag);
		vlanid = cti & VLAN_IDMASK;
57e291d8:	e1a00a20 	lsr	r0, r0, #20
		eth_proto = ntohs(vet->vet_type);
57e291dc:	e1a03823 	lsr	r3, r3, #16

		ip = (struct ip_udp_hdr *)(inpkt + VLAN_ETHER_HDR_SIZE);
		len -= VLAN_ETHER_HDR_SIZE;
57e291e0:	e2412012 	sub	r2, r1, #18
		cdp_receive((uchar *)ip, len);
		return;
	}
#endif

	if ((myvlanid & VLAN_IDMASK) != VLAN_NONE) {
57e291e4:	e1a01a06 	lsl	r1, r6, #20
57e291e8:	e59f61a0 	ldr	r6, [pc, #416]	; 57e29390 <NetReceive+0x2a4>
57e291ec:	e1a01a21 	lsr	r1, r1, #20
57e291f0:	e1510006 	cmp	r1, r6
57e291f4:	0a000004 	beq	57e2920c <NetReceive+0x120>
		if (vlanid == VLAN_NONE)
57e291f8:	e1500006 	cmp	r0, r6
			vlanid = (mynvlanid & VLAN_IDMASK);
57e291fc:	01a00a0c 	lsleq	r0, ip, #20
57e29200:	01a00a20 	lsreq	r0, r0, #20
		/* not matched? */
		if (vlanid != (myvlanid & VLAN_IDMASK))
57e29204:	e1500001 	cmp	r0, r1
57e29208:	1a00005d 	bne	57e29384 <NetReceive+0x298>
			return;
	}

	switch (eth_proto) {
57e2920c:	e3530b02 	cmp	r3, #2048	; 0x800
57e29210:	0a000006 	beq	57e29230 <NetReceive+0x144>
57e29214:	e59f1180 	ldr	r1, [pc, #384]	; 57e2939c <NetReceive+0x2b0>
57e29218:	e1530001 	cmp	r3, r1
57e2921c:	1a000058 	bne	57e29384 <NetReceive+0x298>

	case PROT_ARP:
		ArpReceive(et, ip, len);
57e29220:	e1a00005 	mov	r0, r5
57e29224:	e1a01004 	mov	r1, r4
57e29228:	ebfffa9d 	bl	57e27ca4 <ArpReceive>
		break;
57e2922c:	ea000054 	b	57e29384 <NetReceive+0x298>
		break;
#endif
	case PROT_IP:
		debug_cond(DEBUG_NET_PKT, "Got IP\n");
		/* Before we start poking the header, make sure it is there */
		if (len < IP_UDP_HDR_SIZE) {
57e29230:	e352001b 	cmp	r2, #27
57e29234:	9a000052 	bls	57e29384 <NetReceive+0x298>
			debug("len bad %d < %lu\n", len,
				(ulong)IP_UDP_HDR_SIZE);
			return;
		}
		/* Check the packet length */
		if (len < ntohs(ip->ip_len)) {
57e29238:	e1d430b2 	ldrh	r3, [r4, #2]
57e2923c:	e1a06423 	lsr	r6, r3, #8
57e29240:	e1866403 	orr	r6, r6, r3, lsl #8
57e29244:	e1a06806 	lsl	r6, r6, #16
57e29248:	e1a06826 	lsr	r6, r6, #16
57e2924c:	e1520006 	cmp	r2, r6
57e29250:	ba00004b 	blt	57e29384 <NetReceive+0x298>
		len = ntohs(ip->ip_len);
		debug_cond(DEBUG_NET_PKT, "len=%d, v=%02x\n",
			len, ip->ip_hl_v & 0xff);

		/* Can't deal with anything except IPv4 */
		if ((ip->ip_hl_v & 0xf0) != 0x40)
57e29254:	e5d43000 	ldrb	r3, [r4]
57e29258:	e20320f0 	and	r2, r3, #240	; 0xf0
57e2925c:	e3520040 	cmp	r2, #64	; 0x40
57e29260:	1a000047 	bne	57e29384 <NetReceive+0x298>
			return;
		/* Can't deal with IP options (headers != 20 bytes) */
		if ((ip->ip_hl_v & 0x0f) > 0x05)
57e29264:	e203300f 	and	r3, r3, #15
57e29268:	e3530005 	cmp	r3, #5
57e2926c:	ca000044 	bgt	57e29384 <NetReceive+0x298>
			return;
		/* Check the Checksum of the header */
		if (!NetCksumOk((uchar *)ip, IP_HDR_SIZE / 2)) {
57e29270:	e1a00004 	mov	r0, r4
57e29274:	e3a0100a 	mov	r1, #10
57e29278:	ebffff92 	bl	57e290c8 <NetCksumOk>
57e2927c:	e3500000 	cmp	r0, #0
57e29280:	0a00003f 	beq	57e29384 <NetReceive+0x298>
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
57e29284:	e3a02004 	mov	r2, #4
57e29288:	e28d000c 	add	r0, sp, #12
57e2928c:	e2841010 	add	r1, r4, #16
57e29290:	ebffec1d 	bl	57e2430c <memcpy>
			debug("checksum bad\n");
			return;
		}
		/* If it is not for us, ignore it */
		dst_ip = NetReadIP(&ip->ip_dst);
		if (NetOurIP && dst_ip != NetOurIP && dst_ip != 0xFFFFFFFF) {
57e29294:	e59f20ec 	ldr	r2, [pc, #236]	; 57e29388 <NetReceive+0x29c>
	return ip;
57e29298:	e59d300c 	ldr	r3, [sp, #12]
57e2929c:	e5922030 	ldr	r2, [r2, #48]	; 0x30
57e292a0:	e3520000 	cmp	r2, #0
57e292a4:	0a000002 	beq	57e292b4 <NetReceive+0x1c8>
57e292a8:	e1530002 	cmp	r3, r2
57e292ac:	13730001 	cmnne	r3, #1
57e292b0:	1a000033 	bne	57e29384 <NetReceive+0x298>
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
57e292b4:	e284100c 	add	r1, r4, #12
57e292b8:	e3a02004 	mov	r2, #4
57e292bc:	e28d000c 	add	r0, sp, #12
57e292c0:	ebffec11 	bl	57e2430c <memcpy>

#else /* !CONFIG_IP_DEFRAG */

static inline struct ip_udp_hdr *NetDefragment(struct ip_udp_hdr *ip, int *lenp)
{
	u16 ip_off = ntohs(ip->ip_off);
57e292c4:	e1d430b6 	ldrh	r3, [r4, #6]
	return ip;
57e292c8:	e59d200c 	ldr	r2, [sp, #12]
57e292cc:	e1a01423 	lsr	r1, r3, #8
57e292d0:	e1813403 	orr	r3, r1, r3, lsl #8
	if (!(ip_off & (IP_OFFS | IP_FLAGS_MFRAG)))
57e292d4:	e1b03903 	lsls	r3, r3, #18
57e292d8:	1a000029 	bne	57e29384 <NetReceive+0x298>
		 *
		 * Simon Glass <sjg@chromium.org>: We get an ICMP when
		 * we send a tftp packet to a dead connection, or when
		 * there is no server at the other end.
		 */
		if (ip->ip_p == IPPROTO_ICMP) {
57e292dc:	e5d43009 	ldrb	r3, [r4, #9]
57e292e0:	e3530001 	cmp	r3, #1
57e292e4:	1a00000f 	bne	57e29328 <NetReceive+0x23c>
static void receive_icmp(struct ip_udp_hdr *ip, int len,
			IPaddr_t src_ip, struct ethernet_hdr *et)
{
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;

	switch (icmph->type) {
57e292e8:	e5d42014 	ldrb	r2, [r4, #20]
 * @parma ip	IP packet containing the ICMP
 */
static void receive_icmp(struct ip_udp_hdr *ip, int len,
			IPaddr_t src_ip, struct ethernet_hdr *et)
{
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;
57e292ec:	e2843014 	add	r3, r4, #20

	switch (icmph->type) {
57e292f0:	e3520005 	cmp	r2, #5
57e292f4:	1a000006 	bne	57e29314 <NetReceive+0x228>
	case ICMP_REDIRECT:
		if (icmph->code != ICMP_REDIR_HOST)
57e292f8:	e5d33001 	ldrb	r3, [r3, #1]
57e292fc:	e3530001 	cmp	r3, #1
57e29300:	1a00001f 	bne	57e29384 <NetReceive+0x298>
			return;
		printf(" ICMP Host Redirect to %pI4 ",
57e29304:	e2841018 	add	r1, r4, #24
57e29308:	e59f0090 	ldr	r0, [pc, #144]	; 57e293a0 <NetReceive+0x2b4>
57e2930c:	ebff804e 	bl	57e0944c <printf>
57e29310:	ea00001b 	b	57e29384 <NetReceive+0x298>
			&icmph->un.gateway);
		break;
	default:
#if defined(CONFIG_CMD_PING)
		ping_receive(et, ip, len);
57e29314:	e1a00005 	mov	r0, r5
57e29318:	e1a01004 	mov	r1, r4
57e2931c:	e1a02006 	mov	r2, r6
57e29320:	eb000692 	bl	57e2ad70 <ping_receive>
57e29324:	ea000016 	b	57e29384 <NetReceive+0x298>
		 * there is no server at the other end.
		 */
		if (ip->ip_p == IPPROTO_ICMP) {
			receive_icmp(ip, len, src_ip, et);
			return;
		} else if (ip->ip_p != IPPROTO_UDP) {	/* Only UDP packets */
57e29328:	e3530011 	cmp	r3, #17
57e2932c:	1a000014 	bne	57e29384 <NetReceive+0x298>
#endif
		/*
		 *	IP header OK.  Pass the packet to the current handler.
		 */
		(*udp_packet_handler)((uchar *)ip + IP_UDP_HDR_SIZE,
				ntohs(ip->udp_dst),
57e29330:	e1d411b6 	ldrh	r1, [r4, #22]
				src_ip,
				ntohs(ip->udp_src),
57e29334:	e1d431b4 	ldrh	r3, [r4, #20]
				ntohs(ip->udp_len) - UDP_HDR_SIZE);
57e29338:	e1d401b8 	ldrh	r0, [r4, #24]
57e2933c:	e1a0c421 	lsr	ip, r1, #8
57e29340:	e18c1401 	orr	r1, ip, r1, lsl #8
57e29344:	e1a0c423 	lsr	ip, r3, #8
57e29348:	e18c3403 	orr	r3, ip, r3, lsl #8
57e2934c:	e1a0c420 	lsr	ip, r0, #8
57e29350:	e18c0400 	orr	r0, ip, r0, lsl #8
57e29354:	e1a00800 	lsl	r0, r0, #16
57e29358:	e1a00820 	lsr	r0, r0, #16
					ntohs(ip->udp_len) - UDP_HDR_SIZE);
#endif
		/*
		 *	IP header OK.  Pass the packet to the current handler.
		 */
		(*udp_packet_handler)((uchar *)ip + IP_UDP_HDR_SIZE,
57e2935c:	e2400008 	sub	r0, r0, #8
57e29360:	e58d0000 	str	r0, [sp]
57e29364:	e59f001c 	ldr	r0, [pc, #28]	; 57e29388 <NetReceive+0x29c>
57e29368:	e1a01801 	lsl	r1, r1, #16
57e2936c:	e1a03803 	lsl	r3, r3, #16
57e29370:	e590c004 	ldr	ip, [r0, #4]
57e29374:	e1a01821 	lsr	r1, r1, #16
57e29378:	e284001c 	add	r0, r4, #28
57e2937c:	e1a03823 	lsr	r3, r3, #16
57e29380:	e12fff3c 	blx	ip
				src_ip,
				ntohs(ip->udp_src),
				ntohs(ip->udp_len) - UDP_HDR_SIZE);
		break;
	}
}
57e29384:	e8bd807f 	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
57e29388:	57e79734 	.word	0x57e79734
57e2938c:	57e37bc0 	.word	0x57e37bc0
57e29390:	00000fff 	.word	0x00000fff
57e29394:	0000ffff 	.word	0x0000ffff
57e29398:	000005e9 	.word	0x000005e9
57e2939c:	00000806 	.word	0x00000806
57e293a0:	57e35abf 	.word	0x57e35abf

57e293a4 <NetEthHdrSize>:
int
NetEthHdrSize(void)
{
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
57e293a4:	e59f3030 	ldr	r3, [pc, #48]	; 57e293dc <NetEthHdrSize+0x38>
57e293a8:	e1d330b0 	ldrh	r3, [r3]
57e293ac:	e1a02423 	lsr	r2, r3, #8
57e293b0:	e1822403 	orr	r2, r2, r3, lsl #8
57e293b4:	e1a02802 	lsl	r2, r2, #16
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
57e293b8:	e59f3020 	ldr	r3, [pc, #32]	; 57e293e0 <NetEthHdrSize+0x3c>
57e293bc:	e3720801 	cmn	r2, #65536	; 0x10000
57e293c0:	11a02822 	lsrne	r2, r2, #16
57e293c4:	01a02003 	moveq	r2, r3

	return ((myvlanid & VLAN_IDMASK) == VLAN_NONE) ? ETHER_HDR_SIZE :
57e293c8:	e1a02a02 	lsl	r2, r2, #20
57e293cc:	e1530a22 	cmp	r3, r2, lsr #20
		VLAN_ETHER_HDR_SIZE;
}
57e293d0:	13a00012 	movne	r0, #18
57e293d4:	03a0000e 	moveq	r0, #14
57e293d8:	e12fff1e 	bx	lr
57e293dc:	57e37bc0 	.word	0x57e37bc0
57e293e0:	00000fff 	.word	0x00000fff

57e293e4 <NetSetEther>:

int
NetSetEther(uchar *xet, uchar * addr, uint prot)
{
57e293e4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct ethernet_hdr *et = (struct ethernet_hdr *)xet;
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
57e293e8:	e59f308c 	ldr	r3, [pc, #140]	; 57e2947c <NetSetEther+0x98>
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
57e293ec:	e59f508c 	ldr	r5, [pc, #140]	; 57e29480 <NetSetEther+0x9c>
NetSetEther(uchar *xet, uchar * addr, uint prot)
{
	struct ethernet_hdr *et = (struct ethernet_hdr *)xet;
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
57e293f0:	e1d330b0 	ldrh	r3, [r3]
		VLAN_ETHER_HDR_SIZE;
}

int
NetSetEther(uchar *xet, uchar * addr, uint prot)
{
57e293f4:	e1a04000 	mov	r4, r0
57e293f8:	e1a07423 	lsr	r7, r3, #8
57e293fc:	e1877403 	orr	r7, r7, r3, lsl #8
57e29400:	e1a07807 	lsl	r7, r7, #16
	struct ethernet_hdr *et = (struct ethernet_hdr *)xet;
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
57e29404:	e3770801 	cmn	r7, #65536	; 0x10000
57e29408:	11a07827 	lsrne	r7, r7, #16
57e2940c:	01a07005 	moveq	r7, r5
		VLAN_ETHER_HDR_SIZE;
}

int
NetSetEther(uchar *xet, uchar * addr, uint prot)
{
57e29410:	e1a06002 	mov	r6, r2
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;

	memcpy(et->et_dest, addr, 6);
	memcpy(et->et_src, NetOurEther, 6);
	if ((myvlanid & VLAN_IDMASK) == VLAN_NONE) {
57e29414:	e1a07a07 	lsl	r7, r7, #20

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;

	memcpy(et->et_dest, addr, 6);
57e29418:	e3a02006 	mov	r2, #6
57e2941c:	ebffebba 	bl	57e2430c <memcpy>
	memcpy(et->et_src, NetOurEther, 6);
	if ((myvlanid & VLAN_IDMASK) == VLAN_NONE) {
57e29420:	e1a07a27 	lsr	r7, r7, #20
	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;

	memcpy(et->et_dest, addr, 6);
	memcpy(et->et_src, NetOurEther, 6);
57e29424:	e2840006 	add	r0, r4, #6
57e29428:	e59f1054 	ldr	r1, [pc, #84]	; 57e29484 <NetSetEther+0xa0>
57e2942c:	e3a02006 	mov	r2, #6
57e29430:	ebffebb5 	bl	57e2430c <memcpy>
	if ((myvlanid & VLAN_IDMASK) == VLAN_NONE) {
57e29434:	e1570005 	cmp	r7, r5
57e29438:	e1a06806 	lsl	r6, r6, #16
57e2943c:	1a000004 	bne	57e29454 <NetSetEther+0x70>
57e29440:	e1a03c26 	lsr	r3, r6, #24
57e29444:	e1836426 	orr	r6, r3, r6, lsr #8
		et->et_protlen = htons(prot);
57e29448:	e1c460bc 	strh	r6, [r4, #12]
		return ETHER_HDR_SIZE;
57e2944c:	e3a0000e 	mov	r0, #14
57e29450:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	} else {
		struct vlan_ethernet_hdr *vet =
			(struct vlan_ethernet_hdr *)xet;

		vet->vet_vlan_type = htons(PROT_VLAN);
57e29454:	e3a03081 	mov	r3, #129	; 0x81
57e29458:	e1c430bc 	strh	r3, [r4, #12]
57e2945c:	e1a03427 	lsr	r3, r7, #8
57e29460:	e1837407 	orr	r7, r3, r7, lsl #8
57e29464:	e1a03c26 	lsr	r3, r6, #24
57e29468:	e1836426 	orr	r6, r3, r6, lsr #8
		vet->vet_tag = htons((0 << 5) | (myvlanid & VLAN_IDMASK));
57e2946c:	e1c470be 	strh	r7, [r4, #14]
		vet->vet_type = htons(prot);
57e29470:	e1c461b0 	strh	r6, [r4, #16]
		return VLAN_ETHER_HDR_SIZE;
57e29474:	e3a00012 	mov	r0, #18
	}
}
57e29478:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
57e2947c:	57e37bc0 	.word	0x57e37bc0
57e29480:	00000fff 	.word	0x00000fff
57e29484:	57e79768 	.word	0x57e79768

57e29488 <net_update_ether>:

int net_update_ether(struct ethernet_hdr *et, uchar *addr, uint prot)
{
57e29488:	e92d4038 	push	{r3, r4, r5, lr}
57e2948c:	e1a04000 	mov	r4, r0
57e29490:	e1a05002 	mov	r5, r2
	ushort protlen;

	memcpy(et->et_dest, addr, 6);
57e29494:	e3a02006 	mov	r2, #6
57e29498:	ebffeb9b 	bl	57e2430c <memcpy>
	memcpy(et->et_src, NetOurEther, 6);
57e2949c:	e3a02006 	mov	r2, #6
57e294a0:	e2840006 	add	r0, r4, #6
57e294a4:	e59f1064 	ldr	r1, [pc, #100]	; 57e29510 <net_update_ether+0x88>
57e294a8:	ebffeb97 	bl	57e2430c <memcpy>
	protlen = ntohs(et->et_protlen);
57e294ac:	e1d430bc 	ldrh	r3, [r4, #12]
57e294b0:	e1a02423 	lsr	r2, r3, #8
57e294b4:	e1823403 	orr	r3, r2, r3, lsl #8
57e294b8:	e1a03803 	lsl	r3, r3, #16
57e294bc:	e1a03823 	lsr	r3, r3, #16
	if (protlen == PROT_VLAN) {
57e294c0:	e3530c81 	cmp	r3, #33024	; 0x8100
57e294c4:	1a000005 	bne	57e294e0 <net_update_ether+0x58>
		struct vlan_ethernet_hdr *vet =
			(struct vlan_ethernet_hdr *)et;
		vet->vet_type = htons(prot);
57e294c8:	e1a05805 	lsl	r5, r5, #16
57e294cc:	e1a03c25 	lsr	r3, r5, #24
57e294d0:	e1835425 	orr	r5, r3, r5, lsr #8
57e294d4:	e1c451b0 	strh	r5, [r4, #16]
		return VLAN_ETHER_HDR_SIZE;
57e294d8:	e3a00012 	mov	r0, #18
57e294dc:	e8bd8038 	pop	{r3, r4, r5, pc}
	} else if (protlen > 1514) {
57e294e0:	e59f202c 	ldr	r2, [pc, #44]	; 57e29514 <net_update_ether+0x8c>
57e294e4:	e1a05805 	lsl	r5, r5, #16
57e294e8:	e1530002 	cmp	r3, r2
57e294ec:	81a03c25 	lsrhi	r3, r5, #24
57e294f0:	91a03c25 	lsrls	r3, r5, #24
57e294f4:	81835425 	orrhi	r5, r3, r5, lsr #8
57e294f8:	91835425 	orrls	r5, r3, r5, lsr #8
		et->et_protlen = htons(prot);
57e294fc:	81c450bc 	strhhi	r5, [r4, #12]
		return ETHER_HDR_SIZE;
57e29500:	83a0000e 	movhi	r0, #14
	} else {
		/* 802.2 + SNAP */
		struct e802_hdr *et802 = (struct e802_hdr *)et;
		et802->et_prot = htons(prot);
57e29504:	91c451b4 	strhls	r5, [r4, #20]
		return E802_HDR_SIZE;
57e29508:	93a00016 	movls	r0, #22
	}
}
57e2950c:	e8bd8038 	pop	{r3, r4, r5, pc}
57e29510:	57e79768 	.word	0x57e79768
57e29514:	000005ea 	.word	0x000005ea

57e29518 <net_set_ip_header>:

void net_set_ip_header(uchar *pkt, IPaddr_t dest, IPaddr_t source)
{
57e29518:	e92d4013 	push	{r0, r1, r4, lr}

	/*
	 *	Construct an IP header.
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
57e2951c:	e3a03045 	mov	r3, #69	; 0x45
		return E802_HDR_SIZE;
	}
}

void net_set_ip_header(uchar *pkt, IPaddr_t dest, IPaddr_t source)
{
57e29520:	e58d1004 	str	r1, [sp, #4]
57e29524:	e28d1008 	add	r1, sp, #8
57e29528:	e5212008 	str	r2, [r1, #-8]!

	/*
	 *	Construct an IP header.
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
57e2952c:	e5c03000 	strb	r3, [r0]
	ip->ip_tos   = 0;
	ip->ip_len   = htons(IP_HDR_SIZE);
57e29530:	e3a02b05 	mov	r2, #5120	; 0x1400
	/*
	 *	Construct an IP header.
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
	ip->ip_tos   = 0;
57e29534:	e3a03000 	mov	r3, #0
		return E802_HDR_SIZE;
	}
}

void net_set_ip_header(uchar *pkt, IPaddr_t dest, IPaddr_t source)
{
57e29538:	e1a04000 	mov	r4, r0
	/*
	 *	Construct an IP header.
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
	ip->ip_tos   = 0;
57e2953c:	e5c03001 	strb	r3, [r0, #1]
	ip->ip_len   = htons(IP_HDR_SIZE);
57e29540:	e1c020b2 	strh	r2, [r0, #2]
	ip->ip_id    = htons(NetIPID++);
57e29544:	e59f0050 	ldr	r0, [pc, #80]	; 57e2959c <net_set_ip_header+0x84>
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy((void *)to, from, sizeof(IPaddr_t));
57e29548:	e1a0100d 	mov	r1, sp
57e2954c:	e590c03c 	ldr	ip, [r0, #60]	; 0x3c
	ip->ip_off   = htons(IP_FLAGS_DFRAG);	/* Don't fragment */
	ip->ip_ttl   = 255;
	ip->ip_sum   = 0;
57e29550:	e1c430ba 	strh	r3, [r4, #10]
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
	ip->ip_tos   = 0;
	ip->ip_len   = htons(IP_HDR_SIZE);
	ip->ip_id    = htons(NetIPID++);
57e29554:	e1a0280c 	lsl	r2, ip, #16
57e29558:	e28cc001 	add	ip, ip, #1
57e2955c:	e580c03c 	str	ip, [r0, #60]	; 0x3c
57e29560:	e1a00c22 	lsr	r0, r2, #24
57e29564:	e1802422 	orr	r2, r0, r2, lsr #8
57e29568:	e1c420b4 	strh	r2, [r4, #4]
	ip->ip_off   = htons(IP_FLAGS_DFRAG);	/* Don't fragment */
57e2956c:	e3a02040 	mov	r2, #64	; 0x40
57e29570:	e1c420b6 	strh	r2, [r4, #6]
	ip->ip_ttl   = 255;
57e29574:	e3e02000 	mvn	r2, #0
57e29578:	e5c42008 	strb	r2, [r4, #8]
57e2957c:	e284000c 	add	r0, r4, #12
57e29580:	e2822005 	add	r2, r2, #5
57e29584:	ebffeb60 	bl	57e2430c <memcpy>
57e29588:	e2840010 	add	r0, r4, #16
57e2958c:	e28d1004 	add	r1, sp, #4
57e29590:	e3a02004 	mov	r2, #4
57e29594:	ebffeb5c 	bl	57e2430c <memcpy>
	ip->ip_sum   = 0;
	/* already in network byte order */
	NetCopyIP((void *)&ip->ip_src, &source);
	/* already in network byte order */
	NetCopyIP((void *)&ip->ip_dst, &dest);
}
57e29598:	e8bd801c 	pop	{r2, r3, r4, pc}
57e2959c:	57e79734 	.word	0x57e79734

57e295a0 <net_set_udp_header>:

void net_set_udp_header(uchar *pkt, IPaddr_t dest, int dport, int sport,
			int len)
{
57e295a0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e295a4:	e59d6018 	ldr	r6, [sp, #24]
57e295a8:	e1a05002 	mov	r5, r2
	/*
	 *	If the data is an odd number of bytes, zero the
	 *	byte after the last byte so that the checksum
	 *	will work.
	 */
	if (len & 1)
57e295ac:	e3160001 	tst	r6, #1
		pkt[IP_UDP_HDR_SIZE + len] = 0;
57e295b0:	13a02000 	movne	r2, #0
	NetCopyIP((void *)&ip->ip_dst, &dest);
}

void net_set_udp_header(uchar *pkt, IPaddr_t dest, int dport, int sport,
			int len)
{
57e295b4:	e1a07003 	mov	r7, r3
	 *	If the data is an odd number of bytes, zero the
	 *	byte after the last byte so that the checksum
	 *	will work.
	 */
	if (len & 1)
		pkt[IP_UDP_HDR_SIZE + len] = 0;
57e295b8:	10803006 	addne	r3, r0, r6
57e295bc:	15c3201c 	strbne	r2, [r3, #28]

	net_set_ip_header(pkt, dest, NetOurIP);
57e295c0:	e59f307c 	ldr	r3, [pc, #124]	; 57e29644 <net_set_udp_header+0xa4>
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
57e295c4:	e1a06806 	lsl	r6, r6, #16
	 *	will work.
	 */
	if (len & 1)
		pkt[IP_UDP_HDR_SIZE + len] = 0;

	net_set_ip_header(pkt, dest, NetOurIP);
57e295c8:	e5932030 	ldr	r2, [r3, #48]	; 0x30
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
57e295cc:	e1a0a826 	lsr	sl, r6, #16
57e295d0:	e2866707 	add	r6, r6, #1835008	; 0x1c0000
	NetCopyIP((void *)&ip->ip_dst, &dest);
}

void net_set_udp_header(uchar *pkt, IPaddr_t dest, int dport, int sport,
			int len)
{
57e295d4:	e1a04000 	mov	r4, r0
	 *	will work.
	 */
	if (len & 1)
		pkt[IP_UDP_HDR_SIZE + len] = 0;

	net_set_ip_header(pkt, dest, NetOurIP);
57e295d8:	ebffffce 	bl	57e29518 <net_set_ip_header>
57e295dc:	e1a03c26 	lsr	r3, r6, #24
57e295e0:	e1836426 	orr	r6, r3, r6, lsr #8
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
	ip->ip_p     = IPPROTO_UDP;
57e295e4:	e3a03011 	mov	r3, #17
57e295e8:	e5c43009 	strb	r3, [r4, #9]
	 */
	if (len & 1)
		pkt[IP_UDP_HDR_SIZE + len] = 0;

	net_set_ip_header(pkt, dest, NetOurIP);
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
57e295ec:	e1c460b2 	strh	r6, [r4, #2]
	ip->ip_p     = IPPROTO_UDP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
57e295f0:	e1a00004 	mov	r0, r4
57e295f4:	e3a0100a 	mov	r1, #10
57e295f8:	ebfffea4 	bl	57e29090 <NetCksum>

	ip->udp_src  = htons(sport);
57e295fc:	e1a07807 	lsl	r7, r7, #16
57e29600:	e1a03c27 	lsr	r3, r7, #24
	ip->udp_dst  = htons(dport);
57e29604:	e1a05805 	lsl	r5, r5, #16
	ip->udp_len  = htons(UDP_HDR_SIZE + len);
57e29608:	e28aa008 	add	sl, sl, #8
57e2960c:	e1837427 	orr	r7, r3, r7, lsr #8
57e29610:	e1a0a80a 	lsl	sl, sl, #16
57e29614:	e1a03c25 	lsr	r3, r5, #24
57e29618:	e1835425 	orr	r5, r3, r5, lsr #8
57e2961c:	e1a03c2a 	lsr	r3, sl, #24
57e29620:	e183a42a 	orr	sl, r3, sl, lsr #8
		pkt[IP_UDP_HDR_SIZE + len] = 0;

	net_set_ip_header(pkt, dest, NetOurIP);
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
	ip->ip_p     = IPPROTO_UDP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
57e29624:	e1e00000 	mvn	r0, r0

	ip->udp_src  = htons(sport);
	ip->udp_dst  = htons(dport);
	ip->udp_len  = htons(UDP_HDR_SIZE + len);
	ip->udp_xsum = 0;
57e29628:	e3a03000 	mov	r3, #0
		pkt[IP_UDP_HDR_SIZE + len] = 0;

	net_set_ip_header(pkt, dest, NetOurIP);
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
	ip->ip_p     = IPPROTO_UDP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
57e2962c:	e1c400ba 	strh	r0, [r4, #10]

	ip->udp_src  = htons(sport);
57e29630:	e1c471b4 	strh	r7, [r4, #20]
	ip->udp_dst  = htons(dport);
57e29634:	e1c451b6 	strh	r5, [r4, #22]
	ip->udp_len  = htons(UDP_HDR_SIZE + len);
57e29638:	e1c4a1b8 	strh	sl, [r4, #24]
	ip->udp_xsum = 0;
57e2963c:	e1c431ba 	strh	r3, [r4, #26]
}
57e29640:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e29644:	57e79734 	.word	0x57e79734

57e29648 <NetSendUDPPacket>:
	}
}

int NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport,
		int payload_len)
{
57e29648:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
57e2964c:	e1a0a003 	mov	sl, r3
	int eth_hdr_size;
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
57e29650:	e59f30d4 	ldr	r3, [pc, #212]	; 57e2972c <NetSendUDPPacket+0xe4>
	}
}

int NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport,
		int payload_len)
{
57e29654:	e1a04000 	mov	r4, r0
	int eth_hdr_size;
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
57e29658:	e5937040 	ldr	r7, [r3, #64]	; 0x40
	}
}

int NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport,
		int payload_len)
{
57e2965c:	e1a05001 	mov	r5, r1
	int eth_hdr_size;
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
57e29660:	e3570000 	cmp	r7, #0
	}
}

int NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport,
		int payload_len)
{
57e29664:	e1a09002 	mov	r9, r2
57e29668:	e59db028 	ldr	fp, [sp, #40]	; 0x28
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
		return -1;
57e2966c:	03e00000 	mvneq	r0, #0
	int eth_hdr_size;
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
57e29670:	0a00002c 	beq	57e29728 <NetSendUDPPacket+0xe0>
		return -1;

	/* convert to new style broadcast */
	if (dest == 0)
57e29674:	e3510000 	cmp	r1, #0
		dest = 0xFFFFFFFF;
57e29678:	03e05000 	mvneq	r5, #0

	/* if broadcast, make the ether address a broadcast and don't do ARP */
	if (dest == 0xFFFFFFFF)
		ether = NetBcastAddr;
57e2967c:	059f40ac 	ldreq	r4, [pc, #172]	; 57e29730 <NetSendUDPPacket+0xe8>
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
		return -1;

	/* convert to new style broadcast */
	if (dest == 0)
57e29680:	0a000002 	beq	57e29690 <NetSendUDPPacket+0x48>
		dest = 0xFFFFFFFF;

	/* if broadcast, make the ether address a broadcast and don't do ARP */
	if (dest == 0xFFFFFFFF)
		ether = NetBcastAddr;
57e29684:	e59f30a4 	ldr	r3, [pc, #164]	; 57e29730 <NetSendUDPPacket+0xe8>
57e29688:	e3750001 	cmn	r5, #1
57e2968c:	01a04003 	moveq	r4, r3

	pkt = (uchar *)NetTxPacket;

	eth_hdr_size = NetSetEther(pkt, ether, PROT_IP);
57e29690:	e1a00007 	mov	r0, r7
57e29694:	e1a01004 	mov	r1, r4
57e29698:	e3a02b02 	mov	r2, #2048	; 0x800
57e2969c:	ebffff50 	bl	57e293e4 <NetSetEther>
57e296a0:	e1a06000 	mov	r6, r0
	pkt += eth_hdr_size;
	net_set_udp_header(pkt, dest, dport, sport, payload_len);
57e296a4:	e0870000 	add	r0, r7, r0
	pkt_hdr_size = eth_hdr_size + IP_UDP_HDR_SIZE;

	/* if MAC address was not discovered yet, do an ARP request */
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {
57e296a8:	e59f707c 	ldr	r7, [pc, #124]	; 57e2972c <NetSendUDPPacket+0xe4>

	pkt = (uchar *)NetTxPacket;

	eth_hdr_size = NetSetEther(pkt, ether, PROT_IP);
	pkt += eth_hdr_size;
	net_set_udp_header(pkt, dest, dport, sport, payload_len);
57e296ac:	e1a01005 	mov	r1, r5
57e296b0:	e1a02009 	mov	r2, r9
57e296b4:	e1a0300a 	mov	r3, sl
57e296b8:	e58db000 	str	fp, [sp]
57e296bc:	ebffffb7 	bl	57e295a0 <net_set_udp_header>
	pkt_hdr_size = eth_hdr_size + IP_UDP_HDR_SIZE;

	/* if MAC address was not discovered yet, do an ARP request */
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {
57e296c0:	e2871044 	add	r1, r7, #68	; 0x44
57e296c4:	e1a00004 	mov	r0, r4
57e296c8:	e3a02006 	mov	r2, #6
57e296cc:	ebffeb41 	bl	57e243d8 <memcmp>
	pkt = (uchar *)NetTxPacket;

	eth_hdr_size = NetSetEther(pkt, ether, PROT_IP);
	pkt += eth_hdr_size;
	net_set_udp_header(pkt, dest, dport, sport, payload_len);
	pkt_hdr_size = eth_hdr_size + IP_UDP_HDR_SIZE;
57e296d0:	e286601c 	add	r6, r6, #28

	/* if MAC address was not discovered yet, do an ARP request */
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {
57e296d4:	e3500000 	cmp	r0, #0
57e296d8:	e086100b 	add	r1, r6, fp
57e296dc:	1a00000e 	bne	57e2971c <NetSendUDPPacket+0xd4>
		debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &dest);

		/* save the ip and eth addr for the packet to send after arp */
		NetArpWaitPacketIP = dest;
57e296e0:	e59f304c 	ldr	r3, [pc, #76]	; 57e29734 <NetSendUDPPacket+0xec>
57e296e4:	e5835000 	str	r5, [r3]
		NetArpWaitPacketMAC = ether;
57e296e8:	e59f3048 	ldr	r3, [pc, #72]	; 57e29738 <NetSendUDPPacket+0xf0>
57e296ec:	e5834000 	str	r4, [r3]

		/* size of the waiting packet */
		NetArpWaitTxPacketSize = pkt_hdr_size + payload_len;
57e296f0:	e59f3044 	ldr	r3, [pc, #68]	; 57e2973c <NetSendUDPPacket+0xf4>

		/* and do the ARP request */
		NetArpWaitTry = 1;
57e296f4:	e3a04001 	mov	r4, #1
		/* save the ip and eth addr for the packet to send after arp */
		NetArpWaitPacketIP = dest;
		NetArpWaitPacketMAC = ether;

		/* size of the waiting packet */
		NetArpWaitTxPacketSize = pkt_hdr_size + payload_len;
57e296f8:	e5831000 	str	r1, [r3]

		/* and do the ARP request */
		NetArpWaitTry = 1;
57e296fc:	e59f303c 	ldr	r3, [pc, #60]	; 57e29740 <NetSendUDPPacket+0xf8>
57e29700:	e5834000 	str	r4, [r3]
		NetArpWaitTimerStart = get_timer(0);
57e29704:	ebff5d00 	bl	57e00b0c <get_timer>
57e29708:	e59f3034 	ldr	r3, [pc, #52]	; 57e29744 <NetSendUDPPacket+0xfc>
57e2970c:	e5830000 	str	r0, [r3]
		ArpRequest();
57e29710:	ebfff927 	bl	57e27bb4 <ArpRequest>
		return 1;	/* waiting */
57e29714:	e1a00004 	mov	r0, r4
57e29718:	ea000002 	b	57e29728 <NetSendUDPPacket+0xe0>
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
57e2971c:	e5970040 	ldr	r0, [r7, #64]	; 0x40
57e29720:	ebfffd31 	bl	57e28bec <eth_send>
	} else {
		debug_cond(DEBUG_DEV_PKT, "sending UDP to %pI4/%pM\n",
			&dest, ether);
		NetSendPacket(NetTxPacket, pkt_hdr_size + payload_len);
		return 0;	/* transmitted */
57e29724:	e3a00000 	mov	r0, #0
	}
}
57e29728:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e2972c:	57e79734 	.word	0x57e79734
57e29730:	57e37bc4 	.word	0x57e37bc4
57e29734:	57e790bc 	.word	0x57e790bc
57e29738:	57e790b8 	.word	0x57e790b8
57e2973c:	57e790c4 	.word	0x57e790c4
57e29740:	57e79710 	.word	0x57e79710
57e29744:	57e7970c 	.word	0x57e7970c

57e29748 <copy_filename>:
	ip->udp_xsum = 0;
}

void copy_filename(char *dst, const char *src, int size)
{
	if (*src && (*src == '"')) {
57e29748:	e5d13000 	ldrb	r3, [r1]
57e2974c:	e3530022 	cmp	r3, #34	; 0x22
		++src;
57e29750:	02811001 	addeq	r1, r1, #1
		--size;
57e29754:	02422001 	subeq	r2, r2, #1
57e29758:	ea000000 	b	57e29760 <copy_filename+0x18>
	}

	while ((--size > 0) && *src && (*src != '"'))
		*dst++ = *src++;
57e2975c:	e4c03001 	strb	r3, [r0], #1
	if (*src && (*src == '"')) {
		++src;
		--size;
	}

	while ((--size > 0) && *src && (*src != '"'))
57e29760:	e2422001 	sub	r2, r2, #1
57e29764:	e3520000 	cmp	r2, #0
57e29768:	da000004 	ble	57e29780 <copy_filename+0x38>
57e2976c:	e4d13001 	ldrb	r3, [r1], #1
57e29770:	e3530000 	cmp	r3, #0
57e29774:	0a000001 	beq	57e29780 <copy_filename+0x38>
57e29778:	e3530022 	cmp	r3, #34	; 0x22
57e2977c:	1afffff6 	bne	57e2975c <copy_filename+0x14>
		*dst++ = *src++;
	*dst = '\0';
57e29780:	e3a03000 	mov	r3, #0
57e29784:	e5c03000 	strb	r3, [r0]
}
57e29788:	e12fff1e 	bx	lr

57e2978c <on_bootfile>:
/**********************************************************************/

static int on_bootfile(const char *name, const char *value, enum env_op op,
	int flags)
{
	switch (op) {
57e2978c:	e3520000 	cmp	r2, #0

/**********************************************************************/

static int on_bootfile(const char *name, const char *value, enum env_op op,
	int flags)
{
57e29790:	e92d4008 	push	{r3, lr}
	switch (op) {
57e29794:	0a000001 	beq	57e297a0 <on_bootfile+0x14>
57e29798:	e3520002 	cmp	r2, #2
57e2979c:	1a000002 	bne	57e297ac <on_bootfile+0x20>
	case env_op_create:
	case env_op_overwrite:
		copy_filename(BootFile, value, sizeof(BootFile));
57e297a0:	e59f000c 	ldr	r0, [pc, #12]	; 57e297b4 <on_bootfile+0x28>
57e297a4:	e3a02080 	mov	r2, #128	; 0x80
57e297a8:	ebffffe6 	bl	57e29748 <copy_filename>
	default:
		break;
	}

	return 0;
}
57e297ac:	e3a00000 	mov	r0, #0
57e297b0:	e8bd8008 	pop	{r3, pc}
57e297b4:	57e79780 	.word	0x57e79780

57e297b8 <random_port>:
 * make port a little random (1024-17407)
 * This keeps the math somewhat trivial to compute, and seems to work with
 * all supported protocols/clients/servers
 */
unsigned int random_port(void)
{
57e297b8:	e92d4008 	push	{r3, lr}
	return 1024 + (get_timer(0) % 0x4000);
57e297bc:	e3a00000 	mov	r0, #0
57e297c0:	ebff5cd1 	bl	57e00b0c <get_timer>
57e297c4:	e1a00900 	lsl	r0, r0, #18
57e297c8:	e1a00920 	lsr	r0, r0, #18
}
57e297cc:	e2800b01 	add	r0, r0, #1024	; 0x400
57e297d0:	e8bd8008 	pop	{r3, pc}

57e297d4 <ip_to_string>:
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
57e297d4:	e1a03c00 	lsl	r3, r0, #24
#endif

void ip_to_string(IPaddr_t x, char *s)
{
57e297d8:	e92d4007 	push	{r0, r1, r2, lr}
57e297dc:	e1833c20 	orr	r3, r3, r0, lsr #24
57e297e0:	e20028ff 	and	r2, r0, #16711680	; 0xff0000
57e297e4:	e2000cff 	and	r0, r0, #65280	; 0xff00
57e297e8:	e1830400 	orr	r0, r3, r0, lsl #8
57e297ec:	e1802422 	orr	r2, r0, r2, lsr #8
	x = ntohl(x);
	sprintf(s, "%d.%d.%d.%d",
		(int) ((x >> 24) & 0xff),
		(int) ((x >> 16) & 0xff),
		(int) ((x >> 8) & 0xff), (int) ((x >> 0) & 0xff)
57e297f0:	e1a00422 	lsr	r0, r2, #8
#endif

void ip_to_string(IPaddr_t x, char *s)
{
	x = ntohl(x);
	sprintf(s, "%d.%d.%d.%d",
57e297f4:	e20000ff 	and	r0, r0, #255	; 0xff
57e297f8:	e1a03822 	lsr	r3, r2, #16
57e297fc:	e58d0000 	str	r0, [sp]
57e29800:	e20200ff 	and	r0, r2, #255	; 0xff
57e29804:	e58d0004 	str	r0, [sp, #4]
57e29808:	e1a02c22 	lsr	r2, r2, #24
57e2980c:	e1a00001 	mov	r0, r1
57e29810:	e20330ff 	and	r3, r3, #255	; 0xff
57e29814:	e59f1004 	ldr	r1, [pc, #4]	; 57e29820 <ip_to_string+0x4c>
57e29818:	ebffeeca 	bl	57e25348 <sprintf>
		(int) ((x >> 24) & 0xff),
		(int) ((x >> 16) & 0xff),
		(int) ((x >> 8) & 0xff), (int) ((x >> 0) & 0xff)
	);
}
57e2981c:	e8bd800e 	pop	{r1, r2, r3, pc}
57e29820:	57e35adc 	.word	0x57e35adc

57e29824 <VLAN_to_string>:
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
57e29824:	e1a03420 	lsr	r3, r0, #8
57e29828:	e1833400 	orr	r3, r3, r0, lsl #8
57e2982c:	e1a03803 	lsl	r3, r3, #16

void VLAN_to_string(ushort x, char *s)
{
	x = ntohs(x);

	if (x == (ushort)-1)
57e29830:	e3730801 	cmn	r3, #65536	; 0x10000
57e29834:	e1a02823 	lsr	r2, r3, #16
57e29838:	0a000002 	beq	57e29848 <VLAN_to_string+0x24>
		x = VLAN_NONE;

	if (x == VLAN_NONE)
57e2983c:	e59f3024 	ldr	r3, [pc, #36]	; 57e29868 <VLAN_to_string+0x44>
57e29840:	e1520003 	cmp	r2, r3
57e29844:	1a000002 	bne	57e29854 <VLAN_to_string+0x30>
		strcpy(s, "none");
57e29848:	e1a00001 	mov	r0, r1
57e2984c:	e59f1018 	ldr	r1, [pc, #24]	; 57e2986c <VLAN_to_string+0x48>
57e29850:	eaffe9a2 	b	57e23ee0 <strcpy>
	else
		sprintf(s, "%d", x & VLAN_IDMASK);
57e29854:	e1a00001 	mov	r0, r1
57e29858:	e1a02a02 	lsl	r2, r2, #20
57e2985c:	e59f100c 	ldr	r1, [pc, #12]	; 57e29870 <VLAN_to_string+0x4c>
57e29860:	e1a02a22 	lsr	r2, r2, #20
57e29864:	eaffeeb7 	b	57e25348 <sprintf>
57e29868:	00000fff 	.word	0x00000fff
57e2986c:	57e326ce 	.word	0x57e326ce
57e29870:	57e32b73 	.word	0x57e32b73

57e29874 <string_to_VLAN>:
}

ushort string_to_VLAN(const char *s)
{
57e29874:	e92d4008 	push	{r3, lr}
	ushort id;

	if (s == NULL)
57e29878:	e2503000 	subs	r3, r0, #0
57e2987c:	0a00000e 	beq	57e298bc <string_to_VLAN+0x48>
		return htons(VLAN_NONE);

	if (*s < '0' || *s > '9')
57e29880:	e5d33000 	ldrb	r3, [r3]
57e29884:	e2433030 	sub	r3, r3, #48	; 0x30
57e29888:	e3530009 	cmp	r3, #9
		id = VLAN_NONE;
57e2988c:	859f0030 	ldrhi	r0, [pc, #48]	; 57e298c4 <string_to_VLAN+0x50>
	ushort id;

	if (s == NULL)
		return htons(VLAN_NONE);

	if (*s < '0' || *s > '9')
57e29890:	8a000004 	bhi	57e298a8 <string_to_VLAN+0x34>
		id = VLAN_NONE;
	else
		id = (ushort)simple_strtoul(s, NULL, 10);
57e29894:	e3a01000 	mov	r1, #0
57e29898:	e3a0200a 	mov	r2, #10
57e2989c:	ebffee00 	bl	57e250a4 <simple_strtoul>
57e298a0:	e1a00800 	lsl	r0, r0, #16
57e298a4:	e1a00820 	lsr	r0, r0, #16
57e298a8:	e1a03420 	lsr	r3, r0, #8
57e298ac:	e1830400 	orr	r0, r3, r0, lsl #8
57e298b0:	e1a00800 	lsl	r0, r0, #16
57e298b4:	e1a00820 	lsr	r0, r0, #16
57e298b8:	e8bd8008 	pop	{r3, pc}
ushort string_to_VLAN(const char *s)
{
	ushort id;

	if (s == NULL)
		return htons(VLAN_NONE);
57e298bc:	e59f0004 	ldr	r0, [pc, #4]	; 57e298c8 <string_to_VLAN+0x54>
		id = VLAN_NONE;
	else
		id = (ushort)simple_strtoul(s, NULL, 10);

	return htons(id);
}
57e298c0:	e8bd8008 	pop	{r3, pc}
57e298c4:	00000fff 	.word	0x00000fff
57e298c8:	0000ff0f 	.word	0x0000ff0f

57e298cc <getenv_VLAN>:

ushort getenv_VLAN(char *var)
{
57e298cc:	e92d4010 	push	{r4, lr}
	return string_to_VLAN(getenv(var));
57e298d0:	ebff7784 	bl	57e076e8 <getenv>
}
57e298d4:	e8bd4010 	pop	{r4, lr}
	return htons(id);
}

ushort getenv_VLAN(char *var)
{
	return string_to_VLAN(getenv(var));
57e298d8:	eaffffe5 	b	57e29874 <string_to_VLAN>

57e298dc <NetInitLoop>:
	}
	TftpStart(TFTPGET);
}

static void NetInitLoop(void)
{
57e298dc:	e92d4070 	push	{r4, r5, r6, lr}
	static int env_changed_id;
	int env_id = get_env_id();
57e298e0:	ebff766e 	bl	57e072a0 <get_env_id>

	/* update only when the environment has changed */
	if (env_changed_id != env_id) {
57e298e4:	e59f4088 	ldr	r4, [pc, #136]	; 57e29974 <NetInitLoop+0x98>
}

static void NetInitLoop(void)
{
	static int env_changed_id;
	int env_id = get_env_id();
57e298e8:	e1a05000 	mov	r5, r0

	/* update only when the environment has changed */
	if (env_changed_id != env_id) {
57e298ec:	e59430cc 	ldr	r3, [r4, #204]	; 0xcc
57e298f0:	e1530000 	cmp	r3, r0
57e298f4:	0a000017 	beq	57e29958 <NetInitLoop+0x7c>

/* lib/net_utils.c */
#include <net.h>
static inline IPaddr_t getenv_IPaddr(char *var)
{
	return string_to_ip(getenv(var));
57e298f8:	e59f0078 	ldr	r0, [pc, #120]	; 57e29978 <NetInitLoop+0x9c>
57e298fc:	ebff7779 	bl	57e076e8 <getenv>
57e29900:	ebffe8f8 	bl	57e23ce8 <string_to_ip>
		NetOurIP = getenv_IPaddr("ipaddr");
57e29904:	e5840030 	str	r0, [r4, #48]	; 0x30
57e29908:	e59f006c 	ldr	r0, [pc, #108]	; 57e2997c <NetInitLoop+0xa0>
57e2990c:	ebff7775 	bl	57e076e8 <getenv>
57e29910:	ebffe8f4 	bl	57e23ce8 <string_to_ip>
		NetOurGatewayIP = getenv_IPaddr("gatewayip");
57e29914:	e58400d0 	str	r0, [r4, #208]	; 0xd0
57e29918:	e59f0060 	ldr	r0, [pc, #96]	; 57e29980 <NetInitLoop+0xa4>
57e2991c:	ebff7771 	bl	57e076e8 <getenv>
57e29920:	ebffe8f0 	bl	57e23ce8 <string_to_ip>
		NetOurSubnetMask = getenv_IPaddr("netmask");
57e29924:	e58400d4 	str	r0, [r4, #212]	; 0xd4
57e29928:	e59f0054 	ldr	r0, [pc, #84]	; 57e29984 <NetInitLoop+0xa8>
57e2992c:	ebff776d 	bl	57e076e8 <getenv>
57e29930:	ebffe8ec 	bl	57e23ce8 <string_to_ip>
		NetServerIP = getenv_IPaddr("serverip");
57e29934:	e58400d8 	str	r0, [r4, #216]	; 0xd8
		NetOurNativeVLAN = getenv_VLAN("nvlan");
57e29938:	e59f0048 	ldr	r0, [pc, #72]	; 57e29988 <NetInitLoop+0xac>
57e2993c:	ebffffe2 	bl	57e298cc <getenv_VLAN>
57e29940:	e59f6044 	ldr	r6, [pc, #68]	; 57e2998c <NetInitLoop+0xb0>
57e29944:	e1c600b2 	strh	r0, [r6, #2]
		NetOurVLAN = getenv_VLAN("vlan");
57e29948:	e59f0040 	ldr	r0, [pc, #64]	; 57e29990 <NetInitLoop+0xb4>
57e2994c:	ebffffde 	bl	57e298cc <getenv_VLAN>
#if defined(CONFIG_CMD_DNS)
		NetOurDNSIP = getenv_IPaddr("dnsip");
#endif
		env_changed_id = env_id;
57e29950:	e58450cc 	str	r5, [r4, #204]	; 0xcc
		NetOurIP = getenv_IPaddr("ipaddr");
		NetOurGatewayIP = getenv_IPaddr("gatewayip");
		NetOurSubnetMask = getenv_IPaddr("netmask");
		NetServerIP = getenv_IPaddr("serverip");
		NetOurNativeVLAN = getenv_VLAN("nvlan");
		NetOurVLAN = getenv_VLAN("vlan");
57e29954:	e1c600b0 	strh	r0, [r6]
#if defined(CONFIG_CMD_DNS)
		NetOurDNSIP = getenv_IPaddr("dnsip");
#endif
		env_changed_id = env_id;
	}
	memcpy(NetOurEther, eth_get_dev()->enetaddr, 6);
57e29958:	e59f3034 	ldr	r3, [pc, #52]	; 57e29994 <NetInitLoop+0xb8>
57e2995c:	e59f0034 	ldr	r0, [pc, #52]	; 57e29998 <NetInitLoop+0xbc>
57e29960:	e5931000 	ldr	r1, [r3]
57e29964:	e3a02006 	mov	r2, #6
57e29968:	e2811010 	add	r1, r1, #16

	return;
}
57e2996c:	e8bd4070 	pop	{r4, r5, r6, lr}
#if defined(CONFIG_CMD_DNS)
		NetOurDNSIP = getenv_IPaddr("dnsip");
#endif
		env_changed_id = env_id;
	}
	memcpy(NetOurEther, eth_get_dev()->enetaddr, 6);
57e29970:	eaffea65 	b	57e2430c <memcpy>
57e29974:	57e79734 	.word	0x57e79734
57e29978:	57e2e444 	.word	0x57e2e444
57e2997c:	57e30c83 	.word	0x57e30c83
57e29980:	57e30c8d 	.word	0x57e30c8d
57e29984:	57e2f024 	.word	0x57e2f024
57e29988:	57e35ae8 	.word	0x57e35ae8
57e2998c:	57e37bc0 	.word	0x57e37bc0
57e29990:	57e35ae9 	.word	0x57e35ae9
57e29994:	57e7971c 	.word	0x57e7971c
57e29998:	57e79768 	.word	0x57e79768

57e2999c <net_init>:
{
	net_clear_handlers();
}

void net_init(void)
{
57e2999c:	e92d4010 	push	{r4, lr}
	static int first_call = 1;

	if (first_call) {
57e299a0:	e59f4054 	ldr	r4, [pc, #84]	; 57e299fc <net_init+0x60>
57e299a4:	e594300c 	ldr	r3, [r4, #12]
57e299a8:	e3530000 	cmp	r3, #0
57e299ac:	0a000010 	beq	57e299f4 <net_init+0x58>
		 *	Setup packet buffers, aligned correctly.
		 */
		int i;

		NetTxPacket = &PktBuf[0] + (PKTALIGN - 1);
		NetTxPacket -= (ulong)NetTxPacket % PKTALIGN;
57e299b0:	e59f3048 	ldr	r3, [pc, #72]	; 57e29a00 <net_init+0x64>
57e299b4:	e59f2048 	ldr	r2, [pc, #72]	; 57e29a04 <net_init+0x68>
57e299b8:	e3c3303f 	bic	r3, r3, #63	; 0x3f
57e299bc:	e5823040 	str	r3, [r2, #64]	; 0x40
		for (i = 0; i < PKTBUFSRX; i++)
			NetRxPackets[i] = NetTxPacket + (i + 1) * PKTSIZE_ALIGN;
57e299c0:	e59f2040 	ldr	r2, [pc, #64]	; 57e29a08 <net_init+0x6c>
57e299c4:	e2831c06 	add	r1, r3, #1536	; 0x600
57e299c8:	e50210dc 	str	r1, [r2, #-220]	; 0xdc
57e299cc:	e2831b03 	add	r1, r3, #3072	; 0xc00
57e299d0:	e50210d8 	str	r1, [r2, #-216]	; 0xd8
57e299d4:	e2831c12 	add	r1, r3, #4608	; 0x1200
57e299d8:	e2833b06 	add	r3, r3, #6144	; 0x1800
57e299dc:	e50230d0 	str	r3, [r2, #-208]	; 0xd0
57e299e0:	e50210d4 	str	r1, [r2, #-212]	; 0xd4

		ArpInit();
57e299e4:	ebfff833 	bl	57e27ab8 <ArpInit>
		net_clear_handlers();
57e299e8:	ebfffd9f 	bl	57e2906c <net_clear_handlers>

		/* Only need to setup buffer pointers once. */
		first_call = 0;
57e299ec:	e3a03000 	mov	r3, #0
57e299f0:	e584300c 	str	r3, [r4, #12]
	}

	NetInitLoop();
}
57e299f4:	e8bd4010 	pop	{r4, lr}

		/* Only need to setup buffer pointers once. */
		first_call = 0;
	}

	NetInitLoop();
57e299f8:	eaffffb7 	b	57e298dc <NetInitLoop>
57e299fc:	57e37bc0 	.word	0x57e37bc0
57e29a00:	57e7984f 	.word	0x57e7984f
57e29a04:	57e79734 	.word	0x57e79734
57e29a08:	57e7b72c 	.word	0x57e7b72c

57e29a0c <NetLoop>:
/*
 *	Main network processing loop.
 */

int NetLoop(enum proto_t protocol)
{
57e29a0c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	bd_t *bd = gd->bd;
	int ret = -1;

	NetRestarted = 0;
57e29a10:	e59f42bc 	ldr	r4, [pc, #700]	; 57e29cd4 <NetLoop+0x2c8>
57e29a14:	e3a06000 	mov	r6, #0
	NetDevExists = 0;
	NetTryCount = 1;
57e29a18:	e3a09001 	mov	r9, #1
/*
 *	Main network processing loop.
 */

int NetLoop(enum proto_t protocol)
{
57e29a1c:	e24dd020 	sub	sp, sp, #32
	bd_t *bd = gd->bd;
	int ret = -1;

	NetRestarted = 0;
57e29a20:	e584601c 	str	r6, [r4, #28]
	NetDevExists = 0;
57e29a24:	e5846024 	str	r6, [r4, #36]	; 0x24
	NetTryCount = 1;
57e29a28:	e5849018 	str	r9, [r4, #24]
/*
 *	Main network processing loop.
 */

int NetLoop(enum proto_t protocol)
{
57e29a2c:	e1a05000 	mov	r5, r0
	bd_t *bd = gd->bd;
57e29a30:	e5987000 	ldr	r7, [r8]
	NetDevExists = 0;
	NetTryCount = 1;
	debug_cond(DEBUG_INT_STATE, "--- NetLoop Entry\n");

	bootstage_mark_name(BOOTSTAGE_ID_ETH_START, "eth_start");
	net_init();
57e29a34:	ebffffd8 	bl	57e2999c <net_init>
	if (eth_is_on_demand_init() || protocol != NETCONS) {
		eth_halt();
57e29a38:	ebfffc5f 	bl	57e28bbc <eth_halt>
		eth_set_current();
57e29a3c:	ebfffcd3 	bl	57e28d90 <eth_set_current>
		if (eth_init(bd) < 0) {
57e29a40:	e1a00007 	mov	r0, r7
57e29a44:	ebfffca0 	bl	57e28ccc <eth_init>
57e29a48:	e1500006 	cmp	r0, r6
57e29a4c:	ba00009e 	blt	57e29ccc <NetLoop+0x2c0>
{
	switch (protocol) {
		/* Fall through */
#if defined(CONFIG_CMD_PING)
	case PING:
		if (NetPingIP == 0) {
57e29a50:	e59f7280 	ldr	r7, [pc, #640]	; 57e29cd8 <NetLoop+0x2cc>
		/* network device not configured */
		break;

	case 0:
		NetDevExists = 1;
		NetBootFileXferSize = 0;
57e29a54:	e59fb280 	ldr	fp, [pc, #640]	; 57e29cdc <NetLoop+0x2d0>
extern enum net_loop_state net_state;

static inline void net_set_state(enum net_loop_state state)
{
	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
57e29a58:	e1a0a006 	mov	sl, r6
57e29a5c:	e584a000 	str	sl, [r4]
	 *	Start the ball rolling with the given start function.  From
	 *	here on, this code is a state machine driven by received
	 *	packets and timer events.
	 */
	debug_cond(DEBUG_INT_STATE, "--- NetLoop Init\n");
	NetInitLoop();
57e29a60:	ebffff9d 	bl	57e298dc <NetInitLoop>

/**********************************************************************/

static int net_check_prereq(enum proto_t protocol)
{
	switch (protocol) {
57e29a64:	e355000d 	cmp	r5, #13
57e29a68:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
57e29a6c:	ea000031 	b	57e29b38 <NetLoop+0x12c>
57e29a70:	57e29adc 	.word	0x57e29adc
57e29a74:	57e29b38 	.word	0x57e29b38
57e29a78:	57e29b38 	.word	0x57e29b38
57e29a7c:	57e29abc 	.word	0x57e29abc
57e29a80:	57e29adc 	.word	0x57e29adc
57e29a84:	57e29aa8 	.word	0x57e29aa8
57e29a88:	57e29b38 	.word	0x57e29b38
57e29a8c:	57e29abc 	.word	0x57e29abc
57e29a90:	57e29adc 	.word	0x57e29adc
57e29a94:	57e29acc 	.word	0x57e29acc
57e29a98:	57e29b38 	.word	0x57e29b38
57e29a9c:	57e29acc 	.word	0x57e29acc
57e29aa0:	57e29abc 	.word	0x57e29abc
57e29aa4:	57e29adc 	.word	0x57e29adc
		/* Fall through */
#if defined(CONFIG_CMD_PING)
	case PING:
		if (NetPingIP == 0) {
57e29aa8:	e5973000 	ldr	r3, [r7]
57e29aac:	e3530000 	cmp	r3, #0
57e29ab0:	1a000005 	bne	57e29acc <NetLoop+0xc0>
			puts("*** ERROR: ping address not given\n");
57e29ab4:	e59f0224 	ldr	r0, [pc, #548]	; 57e29ce0 <NetLoop+0x2d4>
57e29ab8:	ea000015 	b	57e29b14 <NetLoop+0x108>
#if defined(CONFIG_CMD_NFS)
	case NFS:
#endif
	case TFTPGET:
	case TFTPPUT:
		if (NetServerIP == 0) {
57e29abc:	e59430d8 	ldr	r3, [r4, #216]	; 0xd8
57e29ac0:	e3530000 	cmp	r3, #0
			puts("*** ERROR: `serverip' not set\n");
57e29ac4:	059f0218 	ldreq	r0, [pc, #536]	; 57e29ce4 <NetLoop+0x2d8>
57e29ac8:	0a000011 	beq	57e29b14 <NetLoop+0x108>
#endif
		/* Fall through */

	case NETCONS:
	case TFTPSRV:
		if (NetOurIP == 0) {
57e29acc:	e5943030 	ldr	r3, [r4, #48]	; 0x30
57e29ad0:	e3530000 	cmp	r3, #0
			puts("*** ERROR: `ipaddr' not set\n");
57e29ad4:	059f020c 	ldreq	r0, [pc, #524]	; 57e29ce8 <NetLoop+0x2dc>
57e29ad8:	0a00000d 	beq	57e29b14 <NetLoop+0x108>
#endif
	case BOOTP:
	case CDP:
	case DHCP:
	case LINKLOCAL:
		if (memcmp(NetOurEther, "\0\0\0\0\0\0", 6) == 0) {
57e29adc:	e59f0208 	ldr	r0, [pc, #520]	; 57e29cec <NetLoop+0x2e0>
57e29ae0:	e59f1208 	ldr	r1, [pc, #520]	; 57e29cf0 <NetLoop+0x2e4>
57e29ae4:	e3a02006 	mov	r2, #6
57e29ae8:	ebffea3a 	bl	57e243d8 <memcmp>
57e29aec:	e3500000 	cmp	r0, #0
57e29af0:	1a000010 	bne	57e29b38 <NetLoop+0x12c>
			int num = eth_get_dev_index();
57e29af4:	ebfffaff 	bl	57e286f8 <eth_get_dev_index>

			switch (num) {
57e29af8:	e3700001 	cmn	r0, #1
	case BOOTP:
	case CDP:
	case DHCP:
	case LINKLOCAL:
		if (memcmp(NetOurEther, "\0\0\0\0\0\0", 6) == 0) {
			int num = eth_get_dev_index();
57e29afc:	e1a01000 	mov	r1, r0

			switch (num) {
57e29b00:	0a000002 	beq	57e29b10 <NetLoop+0x104>
57e29b04:	e3500000 	cmp	r0, #0
57e29b08:	0a000003 	beq	57e29b1c <NetLoop+0x110>
57e29b0c:	ea000005 	b	57e29b28 <NetLoop+0x11c>
			case -1:
				puts("*** ERROR: No ethernet found.\n");
57e29b10:	e59f01dc 	ldr	r0, [pc, #476]	; 57e29cf4 <NetLoop+0x2e8>
57e29b14:	ebff7e42 	bl	57e09424 <puts>
57e29b18:	ea00006b 	b	57e29ccc <NetLoop+0x2c0>
				return 1;
			case 0:
				puts("*** ERROR: `ethaddr' not set\n");
57e29b1c:	e59f01d4 	ldr	r0, [pc, #468]	; 57e29cf8 <NetLoop+0x2ec>
57e29b20:	ebff7e3f 	bl	57e09424 <puts>
57e29b24:	ea000001 	b	57e29b30 <NetLoop+0x124>
				break;
			default:
				printf("*** ERROR: `eth%daddr' not set\n",
57e29b28:	e59f01cc 	ldr	r0, [pc, #460]	; 57e29cfc <NetLoop+0x2f0>
57e29b2c:	ebff7e46 	bl	57e0944c <printf>
					num);
				break;
			}

			NetStartAgain();
57e29b30:	ebfffd09 	bl	57e28f5c <NetStartAgain>
57e29b34:	ea000017 	b	57e29b98 <NetLoop+0x18c>
	case 2:
		/* network device not configured */
		break;

	case 0:
		NetDevExists = 1;
57e29b38:	e5849024 	str	r9, [r4, #36]	; 0x24
		NetBootFileXferSize = 0;
57e29b3c:	e50b60cc 	str	r6, [fp, #-204]	; 0xcc
		switch (protocol) {
57e29b40:	e3550007 	cmp	r5, #7
57e29b44:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
57e29b48:	ea000012 	b	57e29b98 <NetLoop+0x18c>
57e29b4c:	57e29b78 	.word	0x57e29b78
57e29b50:	57e29b98 	.word	0x57e29b98
57e29b54:	57e29b98 	.word	0x57e29b98
57e29b58:	57e29b6c 	.word	0x57e29b6c
57e29b5c:	57e29b98 	.word	0x57e29b98
57e29b60:	57e29b8c 	.word	0x57e29b8c
57e29b64:	57e29b98 	.word	0x57e29b98
57e29b68:	57e29b94 	.word	0x57e29b94
		case TFTPGET:
#ifdef CONFIG_CMD_TFTPPUT
		case TFTPPUT:
#endif
			/* always use ARP to get server ethernet address */
			TftpStart(protocol);
57e29b6c:	e3a00003 	mov	r0, #3
57e29b70:	eb000613 	bl	57e2b3c4 <TftpStart>
			break;
57e29b74:	ea000007 	b	57e29b98 <NetLoop+0x18c>
			DhcpRequest();		/* Basically same as BOOTP */
			break;
#endif

		case BOOTP:
			BootpTry = 0;
57e29b78:	e59f2180 	ldr	r2, [pc, #384]	; 57e29d00 <NetLoop+0x2f4>
			NetOurIP = 0;
57e29b7c:	e5846030 	str	r6, [r4, #48]	; 0x30
			DhcpRequest();		/* Basically same as BOOTP */
			break;
#endif

		case BOOTP:
			BootpTry = 0;
57e29b80:	e5826000 	str	r6, [r2]
			NetOurIP = 0;
			BootpRequest();
57e29b84:	ebfff9ab 	bl	57e28238 <BootpRequest>
			break;
57e29b88:	ea000002 	b	57e29b98 <NetLoop+0x18c>
			RarpRequest();
			break;
#endif
#if defined(CONFIG_CMD_PING)
		case PING:
			ping_start();
57e29b8c:	eb00042d 	bl	57e2ac48 <ping_start>
			break;
57e29b90:	ea000000 	b	57e29b98 <NetLoop+0x18c>
#endif
#if defined(CONFIG_CMD_NFS)
		case NFS:
			NfsStart();
57e29b94:	eb000398 	bl	57e2a9fc <NfsStart>
#endif
		/*
		 *	Check the ethernet for a new packet.  The ethernet
		 *	receive routine will process it.
		 */
		eth_rx();
57e29b98:	ebfffc21 	bl	57e28c24 <eth_rx>

		/*
		 *	Abort if ctrl-c was pressed.
		 */
		if (ctrlc()) {
57e29b9c:	ebff7e4f 	bl	57e094e0 <ctrlc>
57e29ba0:	e3500000 	cmp	r0, #0
57e29ba4:	e58d0004 	str	r0, [sp, #4]
57e29ba8:	0a000007 	beq	57e29bcc <NetLoop+0x1c0>
			/* cancel any ARP that may not have completed */
			NetArpWaitPacketIP = 0;
57e29bac:	e59f3150 	ldr	r3, [pc, #336]	; 57e29d04 <NetLoop+0x2f8>
57e29bb0:	e3a02000 	mov	r2, #0
57e29bb4:	e5832000 	str	r2, [r3]
	NetSetTimeout(0, NULL);
}

static void net_cleanup_loop(void)
{
	net_clear_handlers();
57e29bb8:	ebfffd2b 	bl	57e2906c <net_clear_handlers>
		if (ctrlc()) {
			/* cancel any ARP that may not have completed */
			NetArpWaitPacketIP = 0;

			net_cleanup_loop();
			eth_halt();
57e29bbc:	ebfffbfe 	bl	57e28bbc <eth_halt>
			/* Invalidate the last protocol */
			eth_set_last_protocol(BOOTP);

			puts("\nAbort\n");
57e29bc0:	e59f0140 	ldr	r0, [pc, #320]	; 57e29d08 <NetLoop+0x2fc>
57e29bc4:	ebff7e16 	bl	57e09424 <puts>
57e29bc8:	ea00003c 	b	57e29cc0 <NetLoop+0x2b4>
			   messages are directed to stderr */
			debug_cond(DEBUG_INT_STATE, "--- NetLoop Abort!\n");
			goto done;
		}

		ArpTimeoutCheck();
57e29bcc:	ebfff817 	bl	57e27c30 <ArpTimeoutCheck>

		/*
		 *	Check for a timeout, and run the timeout handler
		 *	if we have one.
		 */
		if (timeHandler && ((get_timer(0) - timeStart) > timeDelta)) {
57e29bd0:	e594300c 	ldr	r3, [r4, #12]
57e29bd4:	e3530000 	cmp	r3, #0
57e29bd8:	0a00000a 	beq	57e29c08 <NetLoop+0x1fc>
57e29bdc:	e59d0004 	ldr	r0, [sp, #4]
57e29be0:	ebff5bc9 	bl	57e00b0c <get_timer>
57e29be4:	e5943010 	ldr	r3, [r4, #16]
57e29be8:	e5942014 	ldr	r2, [r4, #20]
57e29bec:	e0633000 	rsb	r3, r3, r0
57e29bf0:	e1530002 	cmp	r3, r2
57e29bf4:	9a000003 	bls	57e29c08 <NetLoop+0x1fc>
			}
#endif /* CONFIG_SYS_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
			debug_cond(DEBUG_INT_STATE, "--- NetLoop timeout\n");
			x = timeHandler;
			timeHandler = (thand_f *)0;
57e29bf8:	e59d2004 	ldr	r2, [sp, #4]
				status_led_set(STATUS_LED_RED, STATUS_LED_ON);
			}
#endif /* CONFIG_SYS_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
			debug_cond(DEBUG_INT_STATE, "--- NetLoop timeout\n");
			x = timeHandler;
57e29bfc:	e594300c 	ldr	r3, [r4, #12]
			timeHandler = (thand_f *)0;
57e29c00:	e584200c 	str	r2, [r4, #12]
			(*x)();
57e29c04:	e12fff33 	blx	r3
		}


		switch (net_state) {
57e29c08:	e5943000 	ldr	r3, [r4]
57e29c0c:	e3530002 	cmp	r3, #2
57e29c10:	0a000006 	beq	57e29c30 <NetLoop+0x224>
57e29c14:	e3530003 	cmp	r3, #3
57e29c18:	0a000027 	beq	57e29cbc <NetLoop+0x2b0>
57e29c1c:	e3530001 	cmp	r3, #1
57e29c20:	1affffdc 	bne	57e29b98 <NetLoop+0x18c>

		case NETLOOP_RESTART:
			NetRestarted = 1;
57e29c24:	e59f20a8 	ldr	r2, [pc, #168]	; 57e29cd4 <NetLoop+0x2c8>
57e29c28:	e582301c 	str	r3, [r2, #28]
			goto restart;
57e29c2c:	eaffff8a 	b	57e29a5c <NetLoop+0x50>

		case NETLOOP_SUCCESS:
			net_cleanup_loop();
			if (NetBootFileXferSize > 0) {
57e29c30:	e59f60a4 	ldr	r6, [pc, #164]	; 57e29cdc <NetLoop+0x2d0>
	NetSetTimeout(0, NULL);
}

static void net_cleanup_loop(void)
{
	net_clear_handlers();
57e29c34:	ebfffd0c 	bl	57e2906c <net_clear_handlers>
			NetRestarted = 1;
			goto restart;

		case NETLOOP_SUCCESS:
			net_cleanup_loop();
			if (NetBootFileXferSize > 0) {
57e29c38:	e51610cc 	ldr	r1, [r6, #-204]	; 0xcc
57e29c3c:	e3510000 	cmp	r1, #0
57e29c40:	0a000012 	beq	57e29c90 <NetLoop+0x284>
				char buf[20];
				printf("Bytes transferred = %ld (%lx hex)\n",
					NetBootFileXferSize,
					NetBootFileXferSize);
				sprintf(buf, "%lX", NetBootFileXferSize);
57e29c44:	e28d400c 	add	r4, sp, #12

		case NETLOOP_SUCCESS:
			net_cleanup_loop();
			if (NetBootFileXferSize > 0) {
				char buf[20];
				printf("Bytes transferred = %ld (%lx hex)\n",
57e29c48:	e1a02001 	mov	r2, r1
57e29c4c:	e59f00b8 	ldr	r0, [pc, #184]	; 57e29d0c <NetLoop+0x300>
57e29c50:	ebff7dfd 	bl	57e0944c <printf>
					NetBootFileXferSize,
					NetBootFileXferSize);
				sprintf(buf, "%lX", NetBootFileXferSize);
57e29c54:	e51620cc 	ldr	r2, [r6, #-204]	; 0xcc
57e29c58:	e59f10b0 	ldr	r1, [pc, #176]	; 57e29d10 <NetLoop+0x304>
57e29c5c:	e1a00004 	mov	r0, r4
57e29c60:	ebffedb8 	bl	57e25348 <sprintf>
				setenv("filesize", buf);
57e29c64:	e1a01004 	mov	r1, r4
57e29c68:	e59f00a4 	ldr	r0, [pc, #164]	; 57e29d14 <NetLoop+0x308>
57e29c6c:	ebff758f 	bl	57e072b0 <setenv>

				sprintf(buf, "%lX", (unsigned long)load_addr);
57e29c70:	e59f30a0 	ldr	r3, [pc, #160]	; 57e29d18 <NetLoop+0x30c>
57e29c74:	e59f1094 	ldr	r1, [pc, #148]	; 57e29d10 <NetLoop+0x304>
57e29c78:	e1a00004 	mov	r0, r4
57e29c7c:	e5932000 	ldr	r2, [r3]
57e29c80:	ebffedb0 	bl	57e25348 <sprintf>
				setenv("fileaddr", buf);
57e29c84:	e59f0090 	ldr	r0, [pc, #144]	; 57e29d1c <NetLoop+0x310>
57e29c88:	e1a01004 	mov	r1, r4
57e29c8c:	ebff7587 	bl	57e072b0 <setenv>
			}
			if (protocol != NETCONS)
57e29c90:	e3550009 	cmp	r5, #9
57e29c94:	0a000001 	beq	57e29ca0 <NetLoop+0x294>
				eth_halt();
57e29c98:	ebfffbc7 	bl	57e28bbc <eth_halt>
57e29c9c:	ea000003 	b	57e29cb0 <NetLoop+0x2a4>
	return 0;
}
/* Set passive state */
static inline __attribute__((always_inline)) void eth_halt_state_only(void)
{
	eth_get_dev()->state = ETH_STATE_PASSIVE;
57e29ca0:	e59f3078 	ldr	r3, [pc, #120]	; 57e29d20 <NetLoop+0x314>
57e29ca4:	e3a02001 	mov	r2, #1
57e29ca8:	e5933000 	ldr	r3, [r3]
57e29cac:	e583201c 	str	r2, [r3, #28]
			else
				eth_halt_state_only();

			eth_set_last_protocol(protocol);

			ret = NetBootFileXferSize;
57e29cb0:	e59f3024 	ldr	r3, [pc, #36]	; 57e29cdc <NetLoop+0x2d0>
57e29cb4:	e51300cc 	ldr	r0, [r3, #-204]	; 0xcc
			debug_cond(DEBUG_INT_STATE, "--- NetLoop Success!\n");
			goto done;
57e29cb8:	ea000001 	b	57e29cc4 <NetLoop+0x2b8>
	NetSetTimeout(0, NULL);
}

static void net_cleanup_loop(void)
{
	net_clear_handlers();
57e29cbc:	ebfffcea 	bl	57e2906c <net_clear_handlers>
 */

int NetLoop(enum proto_t protocol)
{
	bd_t *bd = gd->bd;
	int ret = -1;
57e29cc0:	e3e00000 	mvn	r0, #0
	/* Clear out the handlers */
	net_set_udp_handler(NULL);
	net_set_icmp_handler(NULL);
#endif
	return ret;
}
57e29cc4:	e28dd020 	add	sp, sp, #32
57e29cc8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	NetInitLoop();

	switch (net_check_prereq(protocol)) {
	case 1:
		/* network not configured */
		eth_halt();
57e29ccc:	ebfffbba 	bl	57e28bbc <eth_halt>
57e29cd0:	eafffffa 	b	57e29cc0 <NetLoop+0x2b4>
57e29cd4:	57e79734 	.word	0x57e79734
57e29cd8:	57e7bfa4 	.word	0x57e7bfa4
57e29cdc:	57e7b72c 	.word	0x57e7b72c
57e29ce0:	57e35aee 	.word	0x57e35aee
57e29ce4:	57e35b11 	.word	0x57e35b11
57e29ce8:	57e35b30 	.word	0x57e35b30
57e29cec:	57e79768 	.word	0x57e79768
57e29cf0:	57e2dfd8 	.word	0x57e2dfd8
57e29cf4:	57e35b4d 	.word	0x57e35b4d
57e29cf8:	57e35b6c 	.word	0x57e35b6c
57e29cfc:	57e35b8a 	.word	0x57e35b8a
57e29d00:	57e79718 	.word	0x57e79718
57e29d04:	57e790bc 	.word	0x57e790bc
57e29d08:	57e35baa 	.word	0x57e35baa
57e29d0c:	57e35bb2 	.word	0x57e35bb2
57e29d10:	57e2ea10 	.word	0x57e2ea10
57e29d14:	57e2ea14 	.word	0x57e2ea14
57e29d18:	57e36e60 	.word	0x57e36e60
57e29d1c:	57e31cde 	.word	0x57e31cde
57e29d20:	57e7971c 	.word	0x57e7971c

57e29d24 <basename>:
	return 0;
}

static char*
basename(char *path)
{
57e29d24:	e92d4010 	push	{r4, lr}
57e29d28:	e1a04000 	mov	r4, r0
	char *fname;

	fname = path + strlen(path) - 1;
57e29d2c:	ebffe8c7 	bl	57e24050 <strlen>
57e29d30:	e2403001 	sub	r3, r0, #1
57e29d34:	e0843003 	add	r3, r4, r3
	while (fname >= path) {
57e29d38:	ea000005 	b	57e29d54 <basename+0x30>
		if (*fname == '/') {
57e29d3c:	e5d32000 	ldrb	r2, [r3]
57e29d40:	e2403001 	sub	r3, r0, #1
57e29d44:	e352002f 	cmp	r2, #47	; 0x2f
57e29d48:	1a000001 	bne	57e29d54 <basename+0x30>
			fname++;
57e29d4c:	e2800001 	add	r0, r0, #1
			break;
57e29d50:	e8bd8010 	pop	{r4, pc}
basename(char *path)
{
	char *fname;

	fname = path + strlen(path) - 1;
	while (fname >= path) {
57e29d54:	e1530004 	cmp	r3, r4
		if (*fname == '/') {
			fname++;
			break;
57e29d58:	e1a00003 	mov	r0, r3
basename(char *path)
{
	char *fname;

	fname = path + strlen(path) - 1;
	while (fname >= path) {
57e29d5c:	2afffff6 	bcs	57e29d3c <basename+0x18>
			break;
		}
		fname--;
	}
	return fname;
}
57e29d60:	e8bd8010 	pop	{r4, pc}

57e29d64 <rpc_add_credentials>:

/**************************************************************************
RPC_ADD_CREDENTIALS - Add RPC authentication/verifier entries
**************************************************************************/
static long *rpc_add_credentials(long *p)
{
57e29d64:	e92d4030 	push	{r4, r5, lr}
57e29d68:	e24ddf41 	sub	sp, sp, #260	; 0x104
57e29d6c:	e1a04000 	mov	r4, r0
	int hl;
	int hostnamelen;
	char hostname[256];

	strcpy(hostname, "");
57e29d70:	e59f10d8 	ldr	r1, [pc, #216]	; 57e29e50 <rpc_add_credentials+0xec>
57e29d74:	e1a0000d 	mov	r0, sp
57e29d78:	ebffe858 	bl	57e23ee0 <strcpy>
	hostnamelen = strlen(hostname);
57e29d7c:	e1a0000d 	mov	r0, sp
57e29d80:	ebffe8b2 	bl	57e24050 <strlen>
57e29d84:	e1a02000 	mov	r2, r0
	 * AUTH_UNIX (also accepts an empty hostname field in the AUTH_UNIX
	 * scheme).  To be safe, use AUTH_UNIX and pass the hostname if we have
	 * it (if the BOOTP/DHCP reply didn't give one, just use an empty
	 * hostname).  */

	hl = (hostnamelen + 3) & ~3;
57e29d88:	e2800003 	add	r0, r0, #3

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
57e29d8c:	e1a03004 	mov	r3, r4
57e29d90:	e3a01401 	mov	r1, #16777216	; 0x1000000
	 * AUTH_UNIX (also accepts an empty hostname field in the AUTH_UNIX
	 * scheme).  To be safe, use AUTH_UNIX and pass the hostname if we have
	 * it (if the BOOTP/DHCP reply didn't give one, just use an empty
	 * hostname).  */

	hl = (hostnamelen + 3) & ~3;
57e29d94:	e3c05003 	bic	r5, r0, #3

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
57e29d98:	e4831004 	str	r1, [r3], #4
	*p++ = htonl(hl+20);		/* auth length */
57e29d9c:	e2851014 	add	r1, r5, #20
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
57e29da0:	e1a0cc01 	lsl	ip, r1, #24
57e29da4:	e18ccc21 	orr	ip, ip, r1, lsr #24
57e29da8:	e201ecff 	and	lr, r1, #65280	; 0xff00
57e29dac:	e18cc40e 	orr	ip, ip, lr, lsl #8
57e29db0:	e20118ff 	and	r1, r1, #16711680	; 0xff0000
57e29db4:	e18c1421 	orr	r1, ip, r1, lsr #8
57e29db8:	e5841004 	str	r1, [r4, #4]
	*p++ = htonl(0);		/* stamp */
57e29dbc:	e3a01000 	mov	r1, #0

	hl = (hostnamelen + 3) & ~3;

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
	*p++ = htonl(hl+20);		/* auth length */
57e29dc0:	e2834004 	add	r4, r3, #4
	*p++ = htonl(0);		/* stamp */
57e29dc4:	e5831004 	str	r1, [r3, #4]
57e29dc8:	e1a03c02 	lsl	r3, r2, #24
57e29dcc:	e202ccff 	and	ip, r2, #65280	; 0xff00
57e29dd0:	e1833c22 	orr	r3, r3, r2, lsr #24
57e29dd4:	e183340c 	orr	r3, r3, ip, lsl #8
57e29dd8:	e202c8ff 	and	ip, r2, #16711680	; 0xff0000
57e29ddc:	e183342c 	orr	r3, r3, ip, lsr #8
	*p++ = htonl(hostnamelen);	/* hostname string */
	if (hostnamelen & 3)
57e29de0:	e3120003 	tst	r2, #3

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
	*p++ = htonl(hl+20);		/* auth length */
	*p++ = htonl(0);		/* stamp */
	*p++ = htonl(hostnamelen);	/* hostname string */
57e29de4:	e5843004 	str	r3, [r4, #4]
57e29de8:	e2844008 	add	r4, r4, #8
	if (hostnamelen & 3)
57e29dec:	0a000003 	beq	57e29e00 <rpc_add_credentials+0x9c>
		*(p + hostnamelen / 4) = 0; /* add zero padding */
57e29df0:	e1520001 	cmp	r2, r1
57e29df4:	a1a00002 	movge	r0, r2
57e29df8:	e1a00140 	asr	r0, r0, #2
57e29dfc:	e7841100 	str	r1, [r4, r0, lsl #2]
	memcpy(p, hostname, hostnamelen);
57e29e00:	e1a0100d 	mov	r1, sp
57e29e04:	e1a00004 	mov	r0, r4
57e29e08:	ebffe93f 	bl	57e2430c <memcpy>
	p += hl / 4;
57e29e0c:	e2853003 	add	r3, r5, #3
57e29e10:	e3550000 	cmp	r5, #0
57e29e14:	b1a05003 	movlt	r5, r3
57e29e18:	e1a05145 	asr	r5, r5, #2
57e29e1c:	e0842105 	add	r2, r4, r5, lsl #2
	*p++ = 0;			/* uid */
57e29e20:	e3a03000 	mov	r3, #0
57e29e24:	e2821004 	add	r1, r2, #4
57e29e28:	e7843105 	str	r3, [r4, r5, lsl #2]
	*p++ = 0;			/* gid */
57e29e2c:	e5823004 	str	r3, [r2, #4]
57e29e30:	e2812004 	add	r2, r1, #4
	*p++ = 0;			/* auxiliary gid list */
57e29e34:	e2820004 	add	r0, r2, #4
57e29e38:	e5813004 	str	r3, [r1, #4]

	/* Provide an AUTH_NONE verifier.  */
	*p++ = 0;			/* AUTH_NONE */
57e29e3c:	e5823004 	str	r3, [r2, #4]
	*p++ = 0;			/* auth length */
57e29e40:	e5803004 	str	r3, [r0, #4]

	return p;
}
57e29e44:	e2800008 	add	r0, r0, #8
57e29e48:	e28ddf41 	add	sp, sp, #260	; 0x104
57e29e4c:	e8bd8030 	pop	{r4, r5, pc}
57e29e50:	57e302de 	.word	0x57e302de

57e29e54 <rpc_lookup_reply>:
Handlers for the reply from server
**************************************************************************/

static int
rpc_lookup_reply(int prog, uchar *pkt, unsigned len)
{
57e29e54:	e92d4010 	push	{r4, lr}
57e29e58:	e24ddb02 	sub	sp, sp, #2048	; 0x800
57e29e5c:	e1a04000 	mov	r4, r0
	struct rpc_t rpc_pkt;

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
57e29e60:	e1a0000d 	mov	r0, sp
57e29e64:	ebffe928 	bl	57e2430c <memcpy>

	debug("%s\n", __func__);

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
57e29e68:	e59d3000 	ldr	r3, [sp]
57e29e6c:	e1a02c03 	lsl	r2, r3, #24
57e29e70:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e29e74:	e1822c23 	orr	r2, r2, r3, lsr #24
57e29e78:	e1822401 	orr	r2, r2, r1, lsl #8
57e29e7c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e29e80:	e1823423 	orr	r3, r2, r3, lsr #8
57e29e84:	e59f2098 	ldr	r2, [pc, #152]	; 57e29f24 <rpc_lookup_reply+0xd0>
57e29e88:	e5921000 	ldr	r1, [r2]
57e29e8c:	e1530001 	cmp	r3, r1
57e29e90:	1a000020 	bne	57e29f18 <rpc_lookup_reply+0xc4>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
57e29e94:	e59d3008 	ldr	r3, [sp, #8]
57e29e98:	e3530000 	cmp	r3, #0
57e29e9c:	1a00001d 	bne	57e29f18 <rpc_lookup_reply+0xc4>
57e29ea0:	e59d300c 	ldr	r3, [sp, #12]
57e29ea4:	e3530000 	cmp	r3, #0
57e29ea8:	1a00001a 	bne	57e29f18 <rpc_lookup_reply+0xc4>
	    rpc_pkt.u.reply.verifier ||
57e29eac:	e59d0014 	ldr	r0, [sp, #20]
57e29eb0:	e3500000 	cmp	r0, #0
57e29eb4:	1a000017 	bne	57e29f18 <rpc_lookup_reply+0xc4>
	    rpc_pkt.u.reply.astatus)
		return -1;

	switch (prog) {
57e29eb8:	e59f3068 	ldr	r3, [pc, #104]	; 57e29f28 <rpc_lookup_reply+0xd4>
57e29ebc:	e1540003 	cmp	r4, r3
57e29ec0:	0a00000b 	beq	57e29ef4 <rpc_lookup_reply+0xa0>
57e29ec4:	e2833002 	add	r3, r3, #2
57e29ec8:	e1540003 	cmp	r4, r3
57e29ecc:	1a000012 	bne	57e29f1c <rpc_lookup_reply+0xc8>
	case PROG_MOUNT:
		NfsSrvMountPort = ntohl(rpc_pkt.u.reply.data[0]);
57e29ed0:	e59d3018 	ldr	r3, [sp, #24]
57e29ed4:	e1a01c03 	lsl	r1, r3, #24
57e29ed8:	e1811c23 	orr	r1, r1, r3, lsr #24
57e29edc:	e203ccff 	and	ip, r3, #65280	; 0xff00
57e29ee0:	e181140c 	orr	r1, r1, ip, lsl #8
57e29ee4:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e29ee8:	e1813423 	orr	r3, r1, r3, lsr #8
57e29eec:	e5823004 	str	r3, [r2, #4]
		break;
57e29ef0:	ea000009 	b	57e29f1c <rpc_lookup_reply+0xc8>
	case PROG_NFS:
		NfsSrvNfsPort = ntohl(rpc_pkt.u.reply.data[0]);
57e29ef4:	e59d3018 	ldr	r3, [sp, #24]
57e29ef8:	e1a01c03 	lsl	r1, r3, #24
57e29efc:	e1811c23 	orr	r1, r1, r3, lsr #24
57e29f00:	e203ccff 	and	ip, r3, #65280	; 0xff00
57e29f04:	e181140c 	orr	r1, r1, ip, lsl #8
57e29f08:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e29f0c:	e1813423 	orr	r3, r1, r3, lsr #8
57e29f10:	e5823008 	str	r3, [r2, #8]
		break;
57e29f14:	ea000000 	b	57e29f1c <rpc_lookup_reply+0xc8>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus)
		return -1;
57e29f18:	e3e00000 	mvn	r0, #0
		NfsSrvNfsPort = ntohl(rpc_pkt.u.reply.data[0]);
		break;
	}

	return 0;
}
57e29f1c:	e28ddb02 	add	sp, sp, #2048	; 0x800
57e29f20:	e8bd8010 	pop	{r4, pc}
57e29f24:	57e7b6f4 	.word	0x57e7b6f4
57e29f28:	000186a3 	.word	0x000186a3

57e29f2c <rpc_req>:
	unsigned long id;
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
57e29f2c:	e59fc10c 	ldr	ip, [pc, #268]	; 57e2a040 <rpc_req+0x114>
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)
{
57e29f30:	e92d4070 	push	{r4, r5, r6, lr}
57e29f34:	e1a04000 	mov	r4, r0
	unsigned long id;
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
57e29f38:	e59c0000 	ldr	r0, [ip]
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)
{
57e29f3c:	e24ddb02 	sub	sp, sp, #2048	; 0x800
	unsigned long id;
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
57e29f40:	e2800001 	add	r0, r0, #1
57e29f44:	e58c0000 	str	r0, [ip]
57e29f48:	e1a0cc00 	lsl	ip, r0, #24
57e29f4c:	e200ecff 	and	lr, r0, #65280	; 0xff00
57e29f50:	e18ccc20 	orr	ip, ip, r0, lsr #24
57e29f54:	e18cc40e 	orr	ip, ip, lr, lsl #8
57e29f58:	e20008ff 	and	r0, r0, #16711680	; 0xff0000
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)
{
57e29f5c:	e24dd008 	sub	sp, sp, #8
57e29f60:	e18c0420 	orr	r0, ip, r0, lsr #8
57e29f64:	e1a0cc04 	lsl	ip, r4, #24
57e29f68:	e204ecff 	and	lr, r4, #65280	; 0xff00
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
	pkt.u.call.id = htonl(id);
57e29f6c:	e58d0008 	str	r0, [sp, #8]
57e29f70:	e18ccc24 	orr	ip, ip, r4, lsr #24
	pkt.u.call.type = htonl(MSG_CALL);
57e29f74:	e3a00000 	mov	r0, #0
57e29f78:	e18cc40e 	orr	ip, ip, lr, lsl #8
57e29f7c:	e58d000c 	str	r0, [sp, #12]
57e29f80:	e204e8ff 	and	lr, r4, #16711680	; 0xff0000
	pkt.u.call.rpcvers = htonl(2);	/* use RPC version 2 */
57e29f84:	e2800402 	add	r0, r0, #33554432	; 0x2000000
57e29f88:	e18cc42e 	orr	ip, ip, lr, lsr #8
57e29f8c:	e58d0010 	str	r0, [sp, #16]
	pkt.u.call.prog = htonl(rpc_prog);
	pkt.u.call.vers = htonl(2);	/* portmapper is version 2 */
57e29f90:	e58d0018 	str	r0, [sp, #24]
57e29f94:	e1a00c01 	lsl	r0, r1, #24
57e29f98:	e1800c21 	orr	r0, r0, r1, lsr #24

	id = ++rpc_id;
	pkt.u.call.id = htonl(id);
	pkt.u.call.type = htonl(MSG_CALL);
	pkt.u.call.rpcvers = htonl(2);	/* use RPC version 2 */
	pkt.u.call.prog = htonl(rpc_prog);
57e29f9c:	e58dc014 	str	ip, [sp, #20]
57e29fa0:	e201ccff 	and	ip, r1, #65280	; 0xff00
57e29fa4:	e180040c 	orr	r0, r0, ip, lsl #8
57e29fa8:	e20118ff 	and	r1, r1, #16711680	; 0xff0000
57e29fac:	e1801421 	orr	r1, r0, r1, lsr #8
	pkt.u.call.vers = htonl(2);	/* portmapper is version 2 */
	pkt.u.call.proc = htonl(rpc_proc);
	p = (uint32_t *)&(pkt.u.call.data);

	if (datalen)
57e29fb0:	e2535000 	subs	r5, r3, #0
	pkt.u.call.id = htonl(id);
	pkt.u.call.type = htonl(MSG_CALL);
	pkt.u.call.rpcvers = htonl(2);	/* use RPC version 2 */
	pkt.u.call.prog = htonl(rpc_prog);
	pkt.u.call.vers = htonl(2);	/* portmapper is version 2 */
	pkt.u.call.proc = htonl(rpc_proc);
57e29fb4:	e58d101c 	str	r1, [sp, #28]
	p = (uint32_t *)&(pkt.u.call.data);

	if (datalen)
57e29fb8:	0a000004 	beq	57e29fd0 <rpc_req+0xa4>
		memcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));
57e29fbc:	e28d0008 	add	r0, sp, #8
57e29fc0:	e1a01002 	mov	r1, r2
57e29fc4:	e2800018 	add	r0, r0, #24
57e29fc8:	e1a02105 	lsl	r2, r5, #2
57e29fcc:	ebffe8ce 	bl	57e2430c <memcpy>

	pktlen = (char *)p + datalen*sizeof(uint32_t) - (char *)&pkt;

	memcpy((char *)NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE,
57e29fd0:	e59f306c 	ldr	r3, [pc, #108]	; 57e2a044 <rpc_req+0x118>
	p = (uint32_t *)&(pkt.u.call.data);

	if (datalen)
		memcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));

	pktlen = (char *)p + datalen*sizeof(uint32_t) - (char *)&pkt;
57e29fd4:	e1a05105 	lsl	r5, r5, #2

	memcpy((char *)NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE,
57e29fd8:	e5936000 	ldr	r6, [r3]
57e29fdc:	ebfffcf0 	bl	57e293a4 <NetEthHdrSize>
	p = (uint32_t *)&(pkt.u.call.data);

	if (datalen)
		memcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));

	pktlen = (char *)p + datalen*sizeof(uint32_t) - (char *)&pkt;
57e29fe0:	e2855018 	add	r5, r5, #24

	memcpy((char *)NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE,
57e29fe4:	e280001c 	add	r0, r0, #28
57e29fe8:	e1a02005 	mov	r2, r5
57e29fec:	e0860000 	add	r0, r6, r0
57e29ff0:	e28d1008 	add	r1, sp, #8
57e29ff4:	ebffe8c4 	bl	57e2430c <memcpy>
		(char *)&pkt, pktlen);

	if (rpc_prog == PROG_PORTMAP)
57e29ff8:	e59f3048 	ldr	r3, [pc, #72]	; 57e2a048 <rpc_req+0x11c>
57e29ffc:	e1540003 	cmp	r4, r3
		sport = SUNRPC_PORT;
57e2a000:	03a0206f 	moveq	r2, #111	; 0x6f
	pktlen = (char *)p + datalen*sizeof(uint32_t) - (char *)&pkt;

	memcpy((char *)NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE,
		(char *)&pkt, pktlen);

	if (rpc_prog == PROG_PORTMAP)
57e2a004:	0a000004 	beq	57e2a01c <rpc_req+0xf0>
		sport = SUNRPC_PORT;
	else if (rpc_prog == PROG_MOUNT)
57e2a008:	e2833005 	add	r3, r3, #5
57e2a00c:	e1540003 	cmp	r4, r3
57e2a010:	e59f3028 	ldr	r3, [pc, #40]	; 57e2a040 <rpc_req+0x114>
		sport = NfsSrvMountPort;
57e2a014:	05932004 	ldreq	r2, [r3, #4]
	else
		sport = NfsSrvNfsPort;
57e2a018:	15932008 	ldrne	r2, [r3, #8]

	NetSendUDPPacket(NetServerEther, NfsServerIP, sport, NfsOurPort,
57e2a01c:	e59f301c 	ldr	r3, [pc, #28]	; 57e2a040 <rpc_req+0x114>
57e2a020:	e58d5000 	str	r5, [sp]
57e2a024:	e593100c 	ldr	r1, [r3, #12]
57e2a028:	e59f001c 	ldr	r0, [pc, #28]	; 57e2a04c <rpc_req+0x120>
57e2a02c:	e5933010 	ldr	r3, [r3, #16]
57e2a030:	ebfffd84 	bl	57e29648 <NetSendUDPPacket>
		pktlen);
}
57e2a034:	e28dd008 	add	sp, sp, #8
57e2a038:	e28ddb02 	add	sp, sp, #2048	; 0x800
57e2a03c:	e8bd8070 	pop	{r4, r5, r6, pc}
57e2a040:	57e7b6f4 	.word	0x57e7b6f4
57e2a044:	57e79774 	.word	0x57e79774
57e2a048:	000186a0 	.word	0x000186a0
57e2a04c:	57e7b6ec 	.word	0x57e7b6ec

57e2a050 <rpc_lookup_req>:
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_lookup_req(int prog, int ver)
{
57e2a050:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
57e2a054:	e1a02c00 	lsl	r2, r0, #24
57e2a058:	e200ccff 	and	ip, r0, #65280	; 0xff00
57e2a05c:	e1822c20 	orr	r2, r2, r0, lsr #24
57e2a060:	e182240c 	orr	r2, r2, ip, lsl #8
57e2a064:	e20008ff 	and	r0, r0, #16711680	; 0xff0000
57e2a068:	e24dd044 	sub	sp, sp, #68	; 0x44
57e2a06c:	e1820420 	orr	r0, r2, r0, lsr #8
57e2a070:	e1a02c01 	lsl	r2, r1, #24
	uint32_t data[16];

	data[0] = 0; data[1] = 0;	/* auth credential */
	data[2] = 0; data[3] = 0;	/* auth verifier */
	data[4] = htonl(prog);
57e2a074:	e58d0010 	str	r0, [sp, #16]
57e2a078:	e1822c21 	orr	r2, r2, r1, lsr #24
57e2a07c:	e2010cff 	and	r0, r1, #65280	; 0xff00
57e2a080:	e1822400 	orr	r2, r2, r0, lsl #8
57e2a084:	e20118ff 	and	r1, r1, #16711680	; 0xff0000
static void
rpc_lookup_req(int prog, int ver)
{
	uint32_t data[16];

	data[0] = 0; data[1] = 0;	/* auth credential */
57e2a088:	e3a03000 	mov	r3, #0
57e2a08c:	e1821421 	orr	r1, r2, r1, lsr #8
	data[2] = 0; data[3] = 0;	/* auth verifier */
	data[4] = htonl(prog);
	data[5] = htonl(ver);
	data[6] = htonl(17);	/* IP_UDP */
57e2a090:	e3a02411 	mov	r2, #285212672	; 0x11000000
static void
rpc_lookup_req(int prog, int ver)
{
	uint32_t data[16];

	data[0] = 0; data[1] = 0;	/* auth credential */
57e2a094:	e58d3000 	str	r3, [sp]
57e2a098:	e58d3004 	str	r3, [sp, #4]
	data[2] = 0; data[3] = 0;	/* auth verifier */
57e2a09c:	e58d3008 	str	r3, [sp, #8]
57e2a0a0:	e58d300c 	str	r3, [sp, #12]
	data[4] = htonl(prog);
	data[5] = htonl(ver);
57e2a0a4:	e58d1014 	str	r1, [sp, #20]
	data[6] = htonl(17);	/* IP_UDP */
57e2a0a8:	e58d2018 	str	r2, [sp, #24]
	data[7] = 0;
57e2a0ac:	e58d301c 	str	r3, [sp, #28]

	rpc_req(PROG_PORTMAP, PORTMAP_GETPORT, data, 8);
57e2a0b0:	e59f0014 	ldr	r0, [pc, #20]	; 57e2a0cc <rpc_lookup_req+0x7c>
57e2a0b4:	e3a01003 	mov	r1, #3
57e2a0b8:	e1a0200d 	mov	r2, sp
57e2a0bc:	e2833008 	add	r3, r3, #8
57e2a0c0:	ebffff99 	bl	57e29f2c <rpc_req>
}
57e2a0c4:	e28dd044 	add	sp, sp, #68	; 0x44
57e2a0c8:	e8bd8000 	pop	{pc}
57e2a0cc:	000186a0 	.word	0x000186a0

57e2a0d0 <nfs_mount_req>:
/**************************************************************************
NFS_MOUNT - Mount an NFS Filesystem
**************************************************************************/
static void
nfs_mount_req(char *path)
{
57e2a0d0:	e92d4070 	push	{r4, r5, r6, lr}
57e2a0d4:	e24dda01 	sub	sp, sp, #4096	; 0x1000
57e2a0d8:	e1a06000 	mov	r6, r0
	uint32_t data[1024];
	uint32_t *p;
	int len;
	int pathlen;

	pathlen = strlen(path);
57e2a0dc:	ebffe7db 	bl	57e24050 <strlen>
57e2a0e0:	e1a04000 	mov	r4, r0

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
57e2a0e4:	e1a0000d 	mov	r0, sp
57e2a0e8:	ebffff1d 	bl	57e29d64 <rpc_add_credentials>
57e2a0ec:	e1a03c04 	lsl	r3, r4, #24
57e2a0f0:	e2042cff 	and	r2, r4, #65280	; 0xff00
57e2a0f4:	e1833c24 	orr	r3, r3, r4, lsr #24
57e2a0f8:	e1833402 	orr	r3, r3, r2, lsl #8
57e2a0fc:	e20428ff 	and	r2, r4, #16711680	; 0xff0000
57e2a100:	e1833422 	orr	r3, r3, r2, lsr #8

	*p++ = htonl(pathlen);
57e2a104:	e1a05000 	mov	r5, r0
	if (pathlen & 3)
57e2a108:	e3140003 	tst	r4, #3
	pathlen = strlen(path);

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);

	*p++ = htonl(pathlen);
57e2a10c:	e4853004 	str	r3, [r5], #4
	if (pathlen & 3)
57e2a110:	0a000005 	beq	57e2a12c <nfs_mount_req+0x5c>
		*(p + pathlen / 4) = 0;
57e2a114:	e3540000 	cmp	r4, #0
57e2a118:	e2843003 	add	r3, r4, #3
57e2a11c:	a1a03004 	movge	r3, r4
57e2a120:	e1a03143 	asr	r3, r3, #2
57e2a124:	e3a02000 	mov	r2, #0
57e2a128:	e7852103 	str	r2, [r5, r3, lsl #2]
	memcpy(p, path, pathlen);
57e2a12c:	e1a01006 	mov	r1, r6
57e2a130:	e1a02004 	mov	r2, r4
57e2a134:	e1a00005 	mov	r0, r5
57e2a138:	ebffe873 	bl	57e2430c <memcpy>
	p += (pathlen + 3) / 4;
57e2a13c:	e2943003 	adds	r3, r4, #3
57e2a140:	42844006 	addmi	r4, r4, #6
57e2a144:	51a04003 	movpl	r4, r3
57e2a148:	e3c44003 	bic	r4, r4, #3

	len = (uint32_t *)p - (uint32_t *)&(data[0]);

	rpc_req(PROG_MOUNT, MOUNT_ADDENTRY, data, len);
57e2a14c:	e1a0200d 	mov	r2, sp

	*p++ = htonl(pathlen);
	if (pathlen & 3)
		*(p + pathlen / 4) = 0;
	memcpy(p, path, pathlen);
	p += (pathlen + 3) / 4;
57e2a150:	e0855004 	add	r5, r5, r4

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
57e2a154:	e0623005 	rsb	r3, r2, r5

	rpc_req(PROG_MOUNT, MOUNT_ADDENTRY, data, len);
57e2a158:	e59f0010 	ldr	r0, [pc, #16]	; 57e2a170 <nfs_mount_req+0xa0>
57e2a15c:	e3a01001 	mov	r1, #1
57e2a160:	e1a03143 	asr	r3, r3, #2
57e2a164:	ebffff70 	bl	57e29f2c <rpc_req>
}
57e2a168:	e28dda01 	add	sp, sp, #4096	; 0x1000
57e2a16c:	e8bd8070 	pop	{r4, r5, r6, pc}
57e2a170:	000186a5 	.word	0x000186a5

57e2a174 <nfs_umountall_req>:
/**************************************************************************
NFS_UMOUNTALL - Unmount all our NFS Filesystems on the Server
**************************************************************************/
static void
nfs_umountall_req(void)
{
57e2a174:	e92d4010 	push	{r4, lr}
	uint32_t data[1024];
	uint32_t *p;
	int len;

	if ((NfsSrvMountPort == -1) || (!fs_mounted))
57e2a178:	e59f3044 	ldr	r3, [pc, #68]	; 57e2a1c4 <nfs_umountall_req+0x50>
/**************************************************************************
NFS_UMOUNTALL - Unmount all our NFS Filesystems on the Server
**************************************************************************/
static void
nfs_umountall_req(void)
{
57e2a17c:	e24dda01 	sub	sp, sp, #4096	; 0x1000
	uint32_t data[1024];
	uint32_t *p;
	int len;

	if ((NfsSrvMountPort == -1) || (!fs_mounted))
57e2a180:	e5932004 	ldr	r2, [r3, #4]
57e2a184:	e3720001 	cmn	r2, #1
57e2a188:	0a00000b 	beq	57e2a1bc <nfs_umountall_req+0x48>
57e2a18c:	e5933014 	ldr	r3, [r3, #20]
57e2a190:	e3530000 	cmp	r3, #0
57e2a194:	0a000008 	beq	57e2a1bc <nfs_umountall_req+0x48>
		/* Nothing mounted, nothing to umount */
		return;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
57e2a198:	e1a0000d 	mov	r0, sp
57e2a19c:	ebfffef0 	bl	57e29d64 <rpc_add_credentials>

	if ((NfsSrvMountPort == -1) || (!fs_mounted))
		/* Nothing mounted, nothing to umount */
		return;

	p = &(data[0]);
57e2a1a0:	e1a0400d 	mov	r4, sp
	p = (uint32_t *)rpc_add_credentials((long *)p);

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
57e2a1a4:	e0643000 	rsb	r3, r4, r0

	rpc_req(PROG_MOUNT, MOUNT_UMOUNTALL, data, len);
57e2a1a8:	e3a01004 	mov	r1, #4
57e2a1ac:	e59f0014 	ldr	r0, [pc, #20]	; 57e2a1c8 <nfs_umountall_req+0x54>
57e2a1b0:	e1a0200d 	mov	r2, sp
57e2a1b4:	e1a03143 	asr	r3, r3, #2
57e2a1b8:	ebffff5b 	bl	57e29f2c <rpc_req>
}
57e2a1bc:	e28dda01 	add	sp, sp, #4096	; 0x1000
57e2a1c0:	e8bd8010 	pop	{r4, pc}
57e2a1c4:	57e7b6f4 	.word	0x57e7b6f4
57e2a1c8:	000186a5 	.word	0x000186a5

57e2a1cc <nfs_lookup_req>:
/**************************************************************************
NFS_LOOKUP - Lookup Pathname
**************************************************************************/
static void
nfs_lookup_req(char *fname)
{
57e2a1cc:	e92d4070 	push	{r4, r5, r6, lr}
57e2a1d0:	e24dda01 	sub	sp, sp, #4096	; 0x1000
57e2a1d4:	e1a06000 	mov	r6, r0
	uint32_t data[1024];
	uint32_t *p;
	int len;
	int fnamelen;

	fnamelen = strlen(fname);
57e2a1d8:	ebffe79c 	bl	57e24050 <strlen>
57e2a1dc:	e1a04000 	mov	r4, r0

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
57e2a1e0:	e1a0000d 	mov	r0, sp
57e2a1e4:	ebfffede 	bl	57e29d64 <rpc_add_credentials>

	memcpy(p, dirfh, NFS_FHSIZE);
57e2a1e8:	e3a02020 	mov	r2, #32
57e2a1ec:	e59f1088 	ldr	r1, [pc, #136]	; 57e2a27c <nfs_lookup_req+0xb0>
	int fnamelen;

	fnamelen = strlen(fname);

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
57e2a1f0:	e1a05000 	mov	r5, r0

	memcpy(p, dirfh, NFS_FHSIZE);
57e2a1f4:	ebffe844 	bl	57e2430c <memcpy>
57e2a1f8:	e1a03c04 	lsl	r3, r4, #24
57e2a1fc:	e2042cff 	and	r2, r4, #65280	; 0xff00
57e2a200:	e1833c24 	orr	r3, r3, r4, lsr #24
57e2a204:	e1833402 	orr	r3, r3, r2, lsl #8
57e2a208:	e20428ff 	and	r2, r4, #16711680	; 0xff0000
57e2a20c:	e1833422 	orr	r3, r3, r2, lsr #8
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(fnamelen);
	if (fnamelen & 3)
57e2a210:	e3140003 	tst	r4, #3
	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);

	memcpy(p, dirfh, NFS_FHSIZE);
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(fnamelen);
57e2a214:	e5853020 	str	r3, [r5, #32]
57e2a218:	e2855024 	add	r5, r5, #36	; 0x24
	if (fnamelen & 3)
57e2a21c:	0a000005 	beq	57e2a238 <nfs_lookup_req+0x6c>
		*(p + fnamelen / 4) = 0;
57e2a220:	e3540000 	cmp	r4, #0
57e2a224:	e2843003 	add	r3, r4, #3
57e2a228:	a1a03004 	movge	r3, r4
57e2a22c:	e1a03143 	asr	r3, r3, #2
57e2a230:	e3a02000 	mov	r2, #0
57e2a234:	e7852103 	str	r2, [r5, r3, lsl #2]
	memcpy(p, fname, fnamelen);
57e2a238:	e1a01006 	mov	r1, r6
57e2a23c:	e1a02004 	mov	r2, r4
57e2a240:	e1a00005 	mov	r0, r5
57e2a244:	ebffe830 	bl	57e2430c <memcpy>
	p += (fnamelen + 3) / 4;
57e2a248:	e2943003 	adds	r3, r4, #3
57e2a24c:	42844006 	addmi	r4, r4, #6
57e2a250:	51a04003 	movpl	r4, r3
57e2a254:	e3c44003 	bic	r4, r4, #3

	len = (uint32_t *)p - (uint32_t *)&(data[0]);

	rpc_req(PROG_NFS, NFS_LOOKUP, data, len);
57e2a258:	e1a0200d 	mov	r2, sp
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(fnamelen);
	if (fnamelen & 3)
		*(p + fnamelen / 4) = 0;
	memcpy(p, fname, fnamelen);
	p += (fnamelen + 3) / 4;
57e2a25c:	e0855004 	add	r5, r5, r4

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
57e2a260:	e0623005 	rsb	r3, r2, r5

	rpc_req(PROG_NFS, NFS_LOOKUP, data, len);
57e2a264:	e59f0014 	ldr	r0, [pc, #20]	; 57e2a280 <nfs_lookup_req+0xb4>
57e2a268:	e3a01004 	mov	r1, #4
57e2a26c:	e1a03143 	asr	r3, r3, #2
57e2a270:	ebffff2d 	bl	57e29f2c <rpc_req>
}
57e2a274:	e28dda01 	add	sp, sp, #4096	; 0x1000
57e2a278:	e8bd8070 	pop	{r4, r5, r6, pc}
57e2a27c:	57e7b70c 	.word	0x57e7b70c
57e2a280:	000186a3 	.word	0x000186a3

57e2a284 <nfs_read_req>:
/**************************************************************************
NFS_READ - Read File on NFS Server
**************************************************************************/
static void
nfs_read_req(int offset, int readlen)
{
57e2a284:	e92d40f0 	push	{r4, r5, r6, r7, lr}
57e2a288:	e24dda01 	sub	sp, sp, #4096	; 0x1000
57e2a28c:	e24dd004 	sub	sp, sp, #4
57e2a290:	e1a06000 	mov	r6, r0
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
57e2a294:	e1a0000d 	mov	r0, sp
/**************************************************************************
NFS_READ - Read File on NFS Server
**************************************************************************/
static void
nfs_read_req(int offset, int readlen)
{
57e2a298:	e1a05001 	mov	r5, r1
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
57e2a29c:	ebfffeb0 	bl	57e29d64 <rpc_add_credentials>

	memcpy(p, filefh, NFS_FHSIZE);
57e2a2a0:	e59f1074 	ldr	r1, [pc, #116]	; 57e2a31c <nfs_read_req+0x98>
57e2a2a4:	e3a02020 	mov	r2, #32
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
57e2a2a8:	e1a04000 	mov	r4, r0

	memcpy(p, filefh, NFS_FHSIZE);
57e2a2ac:	ebffe816 	bl	57e2430c <memcpy>
57e2a2b0:	e1a03c06 	lsl	r3, r6, #24
57e2a2b4:	e2062cff 	and	r2, r6, #65280	; 0xff00
57e2a2b8:	e1833c26 	orr	r3, r3, r6, lsr #24
57e2a2bc:	e1833402 	orr	r3, r3, r2, lsl #8
57e2a2c0:	e20668ff 	and	r6, r6, #16711680	; 0xff0000
57e2a2c4:	e1836426 	orr	r6, r3, r6, lsr #8
57e2a2c8:	e1a03c05 	lsl	r3, r5, #24
57e2a2cc:	e2052cff 	and	r2, r5, #65280	; 0xff00
57e2a2d0:	e1833c25 	orr	r3, r3, r5, lsr #24
57e2a2d4:	e1833402 	orr	r3, r3, r2, lsl #8
57e2a2d8:	e20558ff 	and	r5, r5, #16711680	; 0xff0000
57e2a2dc:	e1835425 	orr	r5, r3, r5, lsr #8
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(offset);
	*p++ = htonl(readlen);
	*p++ = 0;
57e2a2e0:	e3a03000 	mov	r3, #0
{
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
57e2a2e4:	e1a0700d 	mov	r7, sp
	p = (uint32_t *)rpc_add_credentials((long *)p);

	memcpy(p, filefh, NFS_FHSIZE);
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(offset);
57e2a2e8:	e5846020 	str	r6, [r4, #32]
	*p++ = htonl(readlen);
57e2a2ec:	e5845024 	str	r5, [r4, #36]	; 0x24
	*p++ = 0;
57e2a2f0:	e5843028 	str	r3, [r4, #40]	; 0x28
57e2a2f4:	e284402c 	add	r4, r4, #44	; 0x2c

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
57e2a2f8:	e0673004 	rsb	r3, r7, r4

	rpc_req(PROG_NFS, NFS_READ, data, len);
57e2a2fc:	e59f001c 	ldr	r0, [pc, #28]	; 57e2a320 <nfs_read_req+0x9c>
57e2a300:	e3a01006 	mov	r1, #6
57e2a304:	e1a0200d 	mov	r2, sp
57e2a308:	e1a03143 	asr	r3, r3, #2
57e2a30c:	ebffff06 	bl	57e29f2c <rpc_req>
}
57e2a310:	e28dd004 	add	sp, sp, #4
57e2a314:	e28dda01 	add	sp, sp, #4096	; 0x1000
57e2a318:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
57e2a31c:	57e7b72c 	.word	0x57e7b72c
57e2a320:	000186a3 	.word	0x000186a3

57e2a324 <nfs_readlink_req>:
 * In case of successful readlink(), the dirname is manipulated,
 * so that inside the nfs() function a recursion can be done.
 **************************************************************************/
static void
nfs_readlink_req(void)
{
57e2a324:	e92d4030 	push	{r4, r5, lr}
57e2a328:	e24dda01 	sub	sp, sp, #4096	; 0x1000
57e2a32c:	e24dd004 	sub	sp, sp, #4
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
57e2a330:	e1a0000d 	mov	r0, sp
57e2a334:	ebfffe8a 	bl	57e29d64 <rpc_add_credentials>
57e2a338:	e1a05000 	mov	r5, r0
{
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
57e2a33c:	e1a0400d 	mov	r4, sp
	p = (uint32_t *)rpc_add_credentials((long *)p);

	memcpy(p, filefh, NFS_FHSIZE);
57e2a340:	e59f102c 	ldr	r1, [pc, #44]	; 57e2a374 <nfs_readlink_req+0x50>
57e2a344:	e3a02020 	mov	r2, #32
	p += (NFS_FHSIZE / 4);
57e2a348:	e2855020 	add	r5, r5, #32
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);

	memcpy(p, filefh, NFS_FHSIZE);
57e2a34c:	ebffe7ee 	bl	57e2430c <memcpy>
	p += (NFS_FHSIZE / 4);

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
57e2a350:	e0643005 	rsb	r3, r4, r5

	rpc_req(PROG_NFS, NFS_READLINK, data, len);
57e2a354:	e59f001c 	ldr	r0, [pc, #28]	; 57e2a378 <nfs_readlink_req+0x54>
57e2a358:	e3a01005 	mov	r1, #5
57e2a35c:	e1a0200d 	mov	r2, sp
57e2a360:	e1a03143 	asr	r3, r3, #2
57e2a364:	ebfffef0 	bl	57e29f2c <rpc_req>
}
57e2a368:	e28dd004 	add	sp, sp, #4
57e2a36c:	e28dda01 	add	sp, sp, #4096	; 0x1000
57e2a370:	e8bd8030 	pop	{r4, r5, pc}
57e2a374:	57e7b72c 	.word	0x57e7b72c
57e2a378:	000186a3 	.word	0x000186a3

57e2a37c <NfsSend>:
static void
NfsSend(void)
{
	debug("%s\n", __func__);

	switch (NfsState) {
57e2a37c:	e59f307c 	ldr	r3, [pc, #124]	; 57e2a400 <NfsSend+0x84>
57e2a380:	e5933058 	ldr	r3, [r3, #88]	; 0x58
57e2a384:	e2433001 	sub	r3, r3, #1
57e2a388:	e3530006 	cmp	r3, #6
57e2a38c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e2a390:	ea000019 	b	57e2a3fc <NfsSend+0x80>
57e2a394:	57e2a3b0 	.word	0x57e2a3b0
57e2a398:	57e2a3bc 	.word	0x57e2a3bc
57e2a39c:	57e2a3c8 	.word	0x57e2a3c8
57e2a3a0:	57e2a3d4 	.word	0x57e2a3d4
57e2a3a4:	57e2a3d8 	.word	0x57e2a3d8
57e2a3a8:	57e2a3e4 	.word	0x57e2a3e4
57e2a3ac:	57e2a3f8 	.word	0x57e2a3f8
	case STATE_PRCLOOKUP_PROG_MOUNT_REQ:
		rpc_lookup_req(PROG_MOUNT, 1);
57e2a3b0:	e59f004c 	ldr	r0, [pc, #76]	; 57e2a404 <NfsSend+0x88>
57e2a3b4:	e3a01001 	mov	r1, #1
57e2a3b8:	ea000001 	b	57e2a3c4 <NfsSend+0x48>
		break;
	case STATE_PRCLOOKUP_PROG_NFS_REQ:
		rpc_lookup_req(PROG_NFS, 2);
57e2a3bc:	e59f0044 	ldr	r0, [pc, #68]	; 57e2a408 <NfsSend+0x8c>
57e2a3c0:	e3a01002 	mov	r1, #2
57e2a3c4:	eaffff21 	b	57e2a050 <rpc_lookup_req>
		break;
	case STATE_MOUNT_REQ:
		nfs_mount_req(nfs_path);
57e2a3c8:	e59f3030 	ldr	r3, [pc, #48]	; 57e2a400 <NfsSend+0x84>
57e2a3cc:	e593005c 	ldr	r0, [r3, #92]	; 0x5c
57e2a3d0:	eaffff3e 	b	57e2a0d0 <nfs_mount_req>
		break;
	case STATE_UMOUNT_REQ:
		nfs_umountall_req();
57e2a3d4:	eaffff66 	b	57e2a174 <nfs_umountall_req>
		break;
	case STATE_LOOKUP_REQ:
		nfs_lookup_req(nfs_filename);
57e2a3d8:	e59f3020 	ldr	r3, [pc, #32]	; 57e2a400 <NfsSend+0x84>
57e2a3dc:	e5930060 	ldr	r0, [r3, #96]	; 0x60
57e2a3e0:	eaffff79 	b	57e2a1cc <nfs_lookup_req>
		break;
	case STATE_READ_REQ:
		nfs_read_req(nfs_offset, nfs_len);
57e2a3e4:	e59f3020 	ldr	r3, [pc, #32]	; 57e2a40c <NfsSend+0x90>
57e2a3e8:	e5930000 	ldr	r0, [r3]
57e2a3ec:	e59f300c 	ldr	r3, [pc, #12]	; 57e2a400 <NfsSend+0x84>
57e2a3f0:	e5931064 	ldr	r1, [r3, #100]	; 0x64
57e2a3f4:	eaffffa2 	b	57e2a284 <nfs_read_req>
		break;
	case STATE_READLINK_REQ:
		nfs_readlink_req();
57e2a3f8:	eaffffc9 	b	57e2a324 <nfs_readlink_req>
57e2a3fc:	e12fff1e 	bx	lr
57e2a400:	57e7b6f4 	.word	0x57e7b6f4
57e2a404:	000186a5 	.word	0x000186a5
57e2a408:	000186a3 	.word	0x000186a3
57e2a40c:	57e37bd0 	.word	0x57e37bd0

57e2a410 <NfsTimeout>:
**************************************************************************/

static void
NfsTimeout(void)
{
	if (++NfsTimeoutCount > NFS_RETRY_COUNT) {
57e2a410:	e59f2040 	ldr	r2, [pc, #64]	; 57e2a458 <NfsTimeout+0x48>
Interfaces of U-BOOT
**************************************************************************/

static void
NfsTimeout(void)
{
57e2a414:	e92d4010 	push	{r4, lr}
	if (++NfsTimeoutCount > NFS_RETRY_COUNT) {
57e2a418:	e5923068 	ldr	r3, [r2, #104]	; 0x68
57e2a41c:	e2833001 	add	r3, r3, #1
57e2a420:	e353001e 	cmp	r3, #30
57e2a424:	e5823068 	str	r3, [r2, #104]	; 0x68
57e2a428:	da000003 	ble	57e2a43c <NfsTimeout+0x2c>
		puts("\nRetry count exceeded; starting again\n");
57e2a42c:	e59f0028 	ldr	r0, [pc, #40]	; 57e2a45c <NfsTimeout+0x4c>
57e2a430:	ebff7bfb 	bl	57e09424 <puts>
	} else {
		puts("T ");
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
		NfsSend();
	}
}
57e2a434:	e8bd4010 	pop	{r4, lr}
static void
NfsTimeout(void)
{
	if (++NfsTimeoutCount > NFS_RETRY_COUNT) {
		puts("\nRetry count exceeded; starting again\n");
		NetStartAgain();
57e2a438:	eafffac7 	b	57e28f5c <NetStartAgain>
	} else {
		puts("T ");
57e2a43c:	e59f001c 	ldr	r0, [pc, #28]	; 57e2a460 <NfsTimeout+0x50>
57e2a440:	ebff7bf7 	bl	57e09424 <puts>
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
57e2a444:	e3a00e7d 	mov	r0, #2000	; 0x7d0
57e2a448:	e59f1014 	ldr	r1, [pc, #20]	; 57e2a464 <NfsTimeout+0x54>
57e2a44c:	ebfffab3 	bl	57e28f20 <NetSetTimeout>
		NfsSend();
	}
}
57e2a450:	e8bd4010 	pop	{r4, lr}
		puts("\nRetry count exceeded; starting again\n");
		NetStartAgain();
	} else {
		puts("T ");
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
		NfsSend();
57e2a454:	eaffffc8 	b	57e2a37c <NfsSend>
57e2a458:	57e7b6f4 	.word	0x57e7b6f4
57e2a45c:	57e358da 	.word	0x57e358da
57e2a460:	57e35bd5 	.word	0x57e35bd5
57e2a464:	57e2a410 	.word	0x57e2a410

57e2a468 <NfsHandler>:
	}
}

static void
NfsHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src, unsigned len)
{
57e2a468:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
57e2a46c:	e24ddb0a 	sub	sp, sp, #10240	; 0x2800
57e2a470:	e28d3a02 	add	r3, sp, #8192	; 0x2000
57e2a474:	e5932818 	ldr	r2, [r3, #2072]	; 0x818
	int rlen;

	debug("%s\n", __func__);

	if (dest != NfsOurPort)
57e2a478:	e59f3528 	ldr	r3, [pc, #1320]	; 57e2a9a8 <NfsHandler+0x540>
	}
}

static void
NfsHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src, unsigned len)
{
57e2a47c:	e1a05000 	mov	r5, r0
	int rlen;

	debug("%s\n", __func__);

	if (dest != NfsOurPort)
57e2a480:	e5930010 	ldr	r0, [r3, #16]
57e2a484:	e1510000 	cmp	r1, r0
57e2a488:	1a000144 	bne	57e2a9a0 <NfsHandler+0x538>
		return;

	switch (NfsState) {
57e2a48c:	e5933058 	ldr	r3, [r3, #88]	; 0x58
57e2a490:	e2433001 	sub	r3, r3, #1
57e2a494:	e3530006 	cmp	r3, #6
57e2a498:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e2a49c:	ea00013f 	b	57e2a9a0 <NfsHandler+0x538>
57e2a4a0:	57e2a4bc 	.word	0x57e2a4bc
57e2a4a4:	57e2a4d0 	.word	0x57e2a4d0
57e2a4a8:	57e2a4e4 	.word	0x57e2a4e4
57e2a4ac:	57e2a588 	.word	0x57e2a588
57e2a4b0:	57e2a624 	.word	0x57e2a624
57e2a4b4:	57e2a7cc 	.word	0x57e2a7cc
57e2a4b8:	57e2a6cc 	.word	0x57e2a6cc
	case STATE_PRCLOOKUP_PROG_MOUNT_REQ:
		rpc_lookup_reply(PROG_MOUNT, pkt, len);
57e2a4bc:	e59f04e8 	ldr	r0, [pc, #1256]	; 57e2a9ac <NfsHandler+0x544>
57e2a4c0:	e1a01005 	mov	r1, r5
57e2a4c4:	ebfffe62 	bl	57e29e54 <rpc_lookup_reply>
		NfsState = STATE_PRCLOOKUP_PROG_NFS_REQ;
57e2a4c8:	e3a02002 	mov	r2, #2
57e2a4cc:	ea000123 	b	57e2a960 <NfsHandler+0x4f8>
		NfsSend();
		break;

	case STATE_PRCLOOKUP_PROG_NFS_REQ:
		rpc_lookup_reply(PROG_NFS, pkt, len);
57e2a4d0:	e59f04d8 	ldr	r0, [pc, #1240]	; 57e2a9b0 <NfsHandler+0x548>
57e2a4d4:	e1a01005 	mov	r1, r5
57e2a4d8:	ebfffe5d 	bl	57e29e54 <rpc_lookup_reply>
		NfsState = STATE_MOUNT_REQ;
57e2a4dc:	e3a02003 	mov	r2, #3
57e2a4e0:	ea00011e 	b	57e2a960 <NfsHandler+0x4f8>
{
	struct rpc_t rpc_pkt;

	debug("%s\n", __func__);

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
57e2a4e4:	e28d4b06 	add	r4, sp, #6144	; 0x1800
57e2a4e8:	e1a01005 	mov	r1, r5
57e2a4ec:	e1a00004 	mov	r0, r4
57e2a4f0:	ebffe785 	bl	57e2430c <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
57e2a4f4:	e59f34b8 	ldr	r3, [pc, #1208]	; 57e2a9b4 <NfsHandler+0x54c>
57e2a4f8:	e28d2b0a 	add	r2, sp, #10240	; 0x2800
57e2a4fc:	e7923003 	ldr	r3, [r2, r3]
57e2a500:	e59f54a0 	ldr	r5, [pc, #1184]	; 57e2a9a8 <NfsHandler+0x540>
57e2a504:	e1a02c03 	lsl	r2, r3, #24
57e2a508:	e1822c23 	orr	r2, r2, r3, lsr #24
57e2a50c:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e2a510:	e1822401 	orr	r2, r2, r1, lsl #8
57e2a514:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e2a518:	e1823423 	orr	r3, r2, r3, lsr #8
57e2a51c:	e5952000 	ldr	r2, [r5]
57e2a520:	e1530002 	cmp	r3, r2
57e2a524:	1a000015 	bne	57e2a580 <NfsHandler+0x118>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
57e2a528:	e28d2a01 	add	r2, sp, #4096	; 0x1000
57e2a52c:	e5923808 	ldr	r3, [r2, #2056]	; 0x808
57e2a530:	e3530000 	cmp	r3, #0
57e2a534:	1a000011 	bne	57e2a580 <NfsHandler+0x118>
57e2a538:	e594300c 	ldr	r3, [r4, #12]
57e2a53c:	e3530000 	cmp	r3, #0
57e2a540:	1a00000e 	bne	57e2a580 <NfsHandler+0x118>
	    rpc_pkt.u.reply.verifier ||
57e2a544:	e5943014 	ldr	r3, [r4, #20]
57e2a548:	e3530000 	cmp	r3, #0
57e2a54c:	1a00000b 	bne	57e2a580 <NfsHandler+0x118>
	    rpc_pkt.u.reply.astatus  ||
57e2a550:	e5943018 	ldr	r3, [r4, #24]
57e2a554:	e3530000 	cmp	r3, #0
57e2a558:	1a000008 	bne	57e2a580 <NfsHandler+0x118>
	    rpc_pkt.u.reply.data[0])
		return -1;

	fs_mounted = 1;
57e2a55c:	e2833001 	add	r3, r3, #1
57e2a560:	e5853014 	str	r3, [r5, #20]
	memcpy(dirfh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);
57e2a564:	e2850018 	add	r0, r5, #24
57e2a568:	e284101c 	add	r1, r4, #28
57e2a56c:	e3a02020 	mov	r2, #32
57e2a570:	ebffe765 	bl	57e2430c <memcpy>
			puts("*** ERROR: Cannot mount\n");
			/* just to be sure... */
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			NfsState = STATE_LOOKUP_REQ;
57e2a574:	e3a03005 	mov	r3, #5
57e2a578:	e5853058 	str	r3, [r5, #88]	; 0x58
57e2a57c:	ea000106 	b	57e2a99c <NfsHandler+0x534>
		NfsSend();
		break;

	case STATE_MOUNT_REQ:
		if (nfs_mount_reply(pkt, len)) {
			puts("*** ERROR: Cannot mount\n");
57e2a580:	e59f0430 	ldr	r0, [pc, #1072]	; 57e2a9b8 <NfsHandler+0x550>
57e2a584:	ea00008e 	b	57e2a7c4 <NfsHandler+0x35c>
{
	struct rpc_t rpc_pkt;

	debug("%s\n", __func__);

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
57e2a588:	e1a01005 	mov	r1, r5
57e2a58c:	e28d0a02 	add	r0, sp, #8192	; 0x2000
57e2a590:	ebffe75d 	bl	57e2430c <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
57e2a594:	e28d2a02 	add	r2, sp, #8192	; 0x2000
57e2a598:	e5923000 	ldr	r3, [r2]
57e2a59c:	e59f4404 	ldr	r4, [pc, #1028]	; 57e2a9a8 <NfsHandler+0x540>
57e2a5a0:	e1a02c03 	lsl	r2, r3, #24
57e2a5a4:	e1822c23 	orr	r2, r2, r3, lsr #24
57e2a5a8:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e2a5ac:	e1822401 	orr	r2, r2, r1, lsl #8
57e2a5b0:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e2a5b4:	e1823423 	orr	r3, r2, r3, lsr #8
57e2a5b8:	e5942000 	ldr	r2, [r4]
57e2a5bc:	e1530002 	cmp	r3, r2
57e2a5c0:	1a000011 	bne	57e2a60c <NfsHandler+0x1a4>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
57e2a5c4:	e28d2a02 	add	r2, sp, #8192	; 0x2000
57e2a5c8:	e5923008 	ldr	r3, [r2, #8]
57e2a5cc:	e3530000 	cmp	r3, #0
57e2a5d0:	1a00000d 	bne	57e2a60c <NfsHandler+0x1a4>
57e2a5d4:	e592300c 	ldr	r3, [r2, #12]
57e2a5d8:	e3530000 	cmp	r3, #0
57e2a5dc:	1a00000a 	bne	57e2a60c <NfsHandler+0x1a4>
	    rpc_pkt.u.reply.verifier ||
57e2a5e0:	e5921014 	ldr	r1, [r2, #20]
57e2a5e4:	e3510000 	cmp	r1, #0
57e2a5e8:	1a000007 	bne	57e2a60c <NfsHandler+0x1a4>
	    rpc_pkt.u.reply.astatus)
		return -1;

	fs_mounted = 0;
	memset(dirfh, 0, sizeof(dirfh));
57e2a5ec:	e3a02020 	mov	r2, #32
	if (rpc_pkt.u.reply.rstatus  ||
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus)
		return -1;

	fs_mounted = 0;
57e2a5f0:	e5841014 	str	r1, [r4, #20]
	memset(dirfh, 0, sizeof(dirfh));
57e2a5f4:	e2840018 	add	r0, r4, #24
57e2a5f8:	ebffe71f 	bl	57e2427c <memset>
	case STATE_UMOUNT_REQ:
		if (nfs_umountall_reply(pkt, len)) {
			puts("*** ERROR: Cannot umount\n");
			net_set_state(NETLOOP_FAIL);
		} else {
			puts("\ndone\n");
57e2a5fc:	e59f03b8 	ldr	r0, [pc, #952]	; 57e2a9bc <NfsHandler+0x554>
57e2a600:	ebff7b87 	bl	57e09424 <puts>
extern enum net_loop_state net_state;

static inline void net_set_state(enum net_loop_state state)
{
	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
57e2a604:	e594206c 	ldr	r2, [r4, #108]	; 0x6c
57e2a608:	ea000002 	b	57e2a618 <NfsHandler+0x1b0>
		}
		break;

	case STATE_UMOUNT_REQ:
		if (nfs_umountall_reply(pkt, len)) {
			puts("*** ERROR: Cannot umount\n");
57e2a60c:	e59f03ac 	ldr	r0, [pc, #940]	; 57e2a9c0 <NfsHandler+0x558>
57e2a610:	ebff7b83 	bl	57e09424 <puts>
57e2a614:	e3a02003 	mov	r2, #3
57e2a618:	e59f33a4 	ldr	r3, [pc, #932]	; 57e2a9c4 <NfsHandler+0x55c>
57e2a61c:	e5832000 	str	r2, [r3]
57e2a620:	ea0000de 	b	57e2a9a0 <NfsHandler+0x538>
{
	struct rpc_t rpc_pkt;

	debug("%s\n", __func__);

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
57e2a624:	e28d4a01 	add	r4, sp, #4096	; 0x1000
57e2a628:	e1a01005 	mov	r1, r5
57e2a62c:	e1a00004 	mov	r0, r4
57e2a630:	ebffe735 	bl	57e2430c <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
57e2a634:	e59f338c 	ldr	r3, [pc, #908]	; 57e2a9c8 <NfsHandler+0x560>
57e2a638:	e28d2b0a 	add	r2, sp, #10240	; 0x2800
57e2a63c:	e7923003 	ldr	r3, [r2, r3]
57e2a640:	e59f5360 	ldr	r5, [pc, #864]	; 57e2a9a8 <NfsHandler+0x540>
57e2a644:	e1a02c03 	lsl	r2, r3, #24
57e2a648:	e1822c23 	orr	r2, r2, r3, lsr #24
57e2a64c:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e2a650:	e1822401 	orr	r2, r2, r1, lsl #8
57e2a654:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e2a658:	e1823423 	orr	r3, r2, r3, lsr #8
57e2a65c:	e5952000 	ldr	r2, [r5]
57e2a660:	e1530002 	cmp	r3, r2
57e2a664:	1a000016 	bne	57e2a6c4 <NfsHandler+0x25c>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
57e2a668:	e5943008 	ldr	r3, [r4, #8]
57e2a66c:	e3530000 	cmp	r3, #0
57e2a670:	1a000013 	bne	57e2a6c4 <NfsHandler+0x25c>
57e2a674:	e594300c 	ldr	r3, [r4, #12]
57e2a678:	e3530000 	cmp	r3, #0
57e2a67c:	1a000010 	bne	57e2a6c4 <NfsHandler+0x25c>
	    rpc_pkt.u.reply.verifier ||
57e2a680:	e5943014 	ldr	r3, [r4, #20]
57e2a684:	e3530000 	cmp	r3, #0
57e2a688:	1a00000d 	bne	57e2a6c4 <NfsHandler+0x25c>
	    rpc_pkt.u.reply.astatus  ||
57e2a68c:	e5946018 	ldr	r6, [r4, #24]
57e2a690:	e3560000 	cmp	r6, #0
57e2a694:	1a00000a 	bne	57e2a6c4 <NfsHandler+0x25c>
	    rpc_pkt.u.reply.data[0])
		return -1;

	memcpy(filefh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);
57e2a698:	e2850038 	add	r0, r5, #56	; 0x38
57e2a69c:	e284101c 	add	r1, r4, #28
57e2a6a0:	e3a02020 	mov	r2, #32
57e2a6a4:	ebffe718 	bl	57e2430c <memcpy>
		if (nfs_lookup_reply(pkt, len)) {
			puts("*** ERROR: File lookup fail\n");
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			NfsState = STATE_READ_REQ;
57e2a6a8:	e3a03006 	mov	r3, #6
57e2a6ac:	e5853058 	str	r3, [r5, #88]	; 0x58
			nfs_offset = 0;
57e2a6b0:	e59f3314 	ldr	r3, [pc, #788]	; 57e2a9cc <NfsHandler+0x564>
57e2a6b4:	e5836000 	str	r6, [r3]
			nfs_len = NFS_READ_SIZE;
57e2a6b8:	e3a03b01 	mov	r3, #1024	; 0x400
57e2a6bc:	e5853064 	str	r3, [r5, #100]	; 0x64
57e2a6c0:	ea0000b5 	b	57e2a99c <NfsHandler+0x534>
		}
		break;

	case STATE_LOOKUP_REQ:
		if (nfs_lookup_reply(pkt, len)) {
			puts("*** ERROR: File lookup fail\n");
57e2a6c4:	e59f0304 	ldr	r0, [pc, #772]	; 57e2a9d0 <NfsHandler+0x568>
57e2a6c8:	ea00003d 	b	57e2a7c4 <NfsHandler+0x35c>
	struct rpc_t rpc_pkt;
	int rlen;

	debug("%s\n", __func__);

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
57e2a6cc:	e28d6b02 	add	r6, sp, #2048	; 0x800
57e2a6d0:	e1a01005 	mov	r1, r5
57e2a6d4:	e1a00006 	mov	r0, r6
57e2a6d8:	ebffe70b 	bl	57e2430c <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
57e2a6dc:	e59f32f0 	ldr	r3, [pc, #752]	; 57e2a9d4 <NfsHandler+0x56c>
57e2a6e0:	e28d2b0a 	add	r2, sp, #10240	; 0x2800
57e2a6e4:	e7923003 	ldr	r3, [r2, r3]
57e2a6e8:	e59f42b8 	ldr	r4, [pc, #696]	; 57e2a9a8 <NfsHandler+0x540>
57e2a6ec:	e1a02c03 	lsl	r2, r3, #24
57e2a6f0:	e1822c23 	orr	r2, r2, r3, lsr #24
57e2a6f4:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e2a6f8:	e1822401 	orr	r2, r2, r1, lsl #8
57e2a6fc:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e2a700:	e1823423 	orr	r3, r2, r3, lsr #8
57e2a704:	e5942000 	ldr	r2, [r4]
57e2a708:	e1530002 	cmp	r3, r2
57e2a70c:	1a00002b 	bne	57e2a7c0 <NfsHandler+0x358>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
57e2a710:	e5963008 	ldr	r3, [r6, #8]
57e2a714:	e3530000 	cmp	r3, #0
57e2a718:	1a000028 	bne	57e2a7c0 <NfsHandler+0x358>
57e2a71c:	e596300c 	ldr	r3, [r6, #12]
57e2a720:	e3530000 	cmp	r3, #0
57e2a724:	1a000025 	bne	57e2a7c0 <NfsHandler+0x358>
	    rpc_pkt.u.reply.verifier ||
57e2a728:	e5963014 	ldr	r3, [r6, #20]
57e2a72c:	e3530000 	cmp	r3, #0
57e2a730:	1a000022 	bne	57e2a7c0 <NfsHandler+0x358>
	    rpc_pkt.u.reply.astatus  ||
57e2a734:	e5967018 	ldr	r7, [r6, #24]
57e2a738:	e3570000 	cmp	r7, #0
57e2a73c:	1a00001f 	bne	57e2a7c0 <NfsHandler+0x358>
	    rpc_pkt.u.reply.data[0])
		return -1;

	rlen = ntohl(rpc_pkt.u.reply.data[1]); /* new path length */
57e2a740:	e596301c 	ldr	r3, [r6, #28]
57e2a744:	e1a05c03 	lsl	r5, r3, #24
57e2a748:	e1855c23 	orr	r5, r5, r3, lsr #24
57e2a74c:	e2032cff 	and	r2, r3, #65280	; 0xff00
57e2a750:	e1855402 	orr	r5, r5, r2, lsl #8
57e2a754:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e2a758:	e1855423 	orr	r5, r5, r3, lsr #8

	if (*((char *)&(rpc_pkt.u.reply.data[2])) != '/') {
57e2a75c:	e5f63020 	ldrb	r3, [r6, #32]!
57e2a760:	e353002f 	cmp	r3, #47	; 0x2f
57e2a764:	0a00000e 	beq	57e2a7a4 <NfsHandler+0x33c>
		int pathlen;
		strcat(nfs_path, "/");
57e2a768:	e59f1268 	ldr	r1, [pc, #616]	; 57e2a9d8 <NfsHandler+0x570>
57e2a76c:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
57e2a770:	ebffe5eb 	bl	57e23f24 <strcat>
		pathlen = strlen(nfs_path);
57e2a774:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
57e2a778:	ebffe634 	bl	57e24050 <strlen>
57e2a77c:	e1a0a000 	mov	sl, r0
		memcpy(nfs_path + pathlen, (uchar *)&(rpc_pkt.u.reply.data[2]),
57e2a780:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
57e2a784:	e1a02005 	mov	r2, r5
57e2a788:	e080000a 	add	r0, r0, sl
57e2a78c:	e1a01006 	mov	r1, r6
57e2a790:	ebffe6dd 	bl	57e2430c <memcpy>
			rlen);
		nfs_path[pathlen + rlen] = 0;
57e2a794:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
57e2a798:	e0835005 	add	r5, r3, r5
57e2a79c:	e7c5700a 	strb	r7, [r5, sl]
57e2a7a0:	ea000071 	b	57e2a96c <NfsHandler+0x504>
	} else {
		memcpy(nfs_path, (uchar *)&(rpc_pkt.u.reply.data[2]), rlen);
57e2a7a4:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
57e2a7a8:	e1a01006 	mov	r1, r6
57e2a7ac:	e1a02005 	mov	r2, r5
57e2a7b0:	ebffe6d5 	bl	57e2430c <memcpy>
		nfs_path[rlen] = 0;
57e2a7b4:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
57e2a7b8:	e7c37005 	strb	r7, [r3, r5]
57e2a7bc:	ea00006a 	b	57e2a96c <NfsHandler+0x504>
		}
		break;

	case STATE_READLINK_REQ:
		if (nfs_readlink_reply(pkt, len)) {
			puts("*** ERROR: Symlink fail\n");
57e2a7c0:	e59f0214 	ldr	r0, [pc, #532]	; 57e2a9dc <NfsHandler+0x574>
57e2a7c4:	ebff7b16 	bl	57e09424 <puts>
57e2a7c8:	ea000063 	b	57e2a95c <NfsHandler+0x4f4>
	struct rpc_t rpc_pkt;
	int rlen;

	debug("%s\n", __func__);

	memcpy((uchar *)&rpc_pkt, pkt, sizeof(rpc_pkt.u.reply));
57e2a7cc:	e1a01005 	mov	r1, r5
57e2a7d0:	e3a02064 	mov	r2, #100	; 0x64
57e2a7d4:	e1a0000d 	mov	r0, sp
57e2a7d8:	ebffe6cb 	bl	57e2430c <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
57e2a7dc:	e59f31fc 	ldr	r3, [pc, #508]	; 57e2a9e0 <NfsHandler+0x578>
57e2a7e0:	e28d2b0a 	add	r2, sp, #10240	; 0x2800
57e2a7e4:	e7923003 	ldr	r3, [r2, r3]
	struct rpc_t rpc_pkt;
	int rlen;

	debug("%s\n", __func__);

	memcpy((uchar *)&rpc_pkt, pkt, sizeof(rpc_pkt.u.reply));
57e2a7e8:	e1a0400d 	mov	r4, sp
57e2a7ec:	e1a02c03 	lsl	r2, r3, #24
57e2a7f0:	e1822c23 	orr	r2, r2, r3, lsr #24
57e2a7f4:	e2031cff 	and	r1, r3, #65280	; 0xff00
57e2a7f8:	e1822401 	orr	r2, r2, r1, lsl #8
57e2a7fc:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e2a800:	e1823423 	orr	r3, r2, r3, lsr #8

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
57e2a804:	e59f219c 	ldr	r2, [pc, #412]	; 57e2a9a8 <NfsHandler+0x540>
57e2a808:	e5922000 	ldr	r2, [r2]
57e2a80c:	e1530002 	cmp	r3, r2
		return -1;
57e2a810:	13e04000 	mvnne	r4, #0

	debug("%s\n", __func__);

	memcpy((uchar *)&rpc_pkt, pkt, sizeof(rpc_pkt.u.reply));

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
57e2a814:	1a00003f 	bne	57e2a918 <NfsHandler+0x4b0>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
57e2a818:	e5943008 	ldr	r3, [r4, #8]
57e2a81c:	e3530000 	cmp	r3, #0
57e2a820:	1a00003b 	bne	57e2a914 <NfsHandler+0x4ac>
57e2a824:	e594300c 	ldr	r3, [r4, #12]
57e2a828:	e3530000 	cmp	r3, #0
57e2a82c:	1a000005 	bne	57e2a848 <NfsHandler+0x3e0>
	    rpc_pkt.u.reply.verifier ||
57e2a830:	e5943014 	ldr	r3, [r4, #20]
57e2a834:	e3530000 	cmp	r3, #0
57e2a838:	1a000002 	bne	57e2a848 <NfsHandler+0x3e0>
	    rpc_pkt.u.reply.astatus  ||
57e2a83c:	e5943018 	ldr	r3, [r4, #24]
57e2a840:	e3530000 	cmp	r3, #0
57e2a844:	0a00000b 	beq	57e2a878 <NfsHandler+0x410>
	    rpc_pkt.u.reply.data[0]) {
		if (rpc_pkt.u.reply.rstatus)
			return -9999;
		if (rpc_pkt.u.reply.astatus)
57e2a848:	e59d2014 	ldr	r2, [sp, #20]
57e2a84c:	e3520000 	cmp	r2, #0
57e2a850:	1a00002f 	bne	57e2a914 <NfsHandler+0x4ac>
			return -9999;
		return -ntohl(rpc_pkt.u.reply.data[0]);
57e2a854:	e59d3018 	ldr	r3, [sp, #24]
57e2a858:	e1a04c03 	lsl	r4, r3, #24
57e2a85c:	e1844c23 	orr	r4, r4, r3, lsr #24
57e2a860:	e2032cff 	and	r2, r3, #65280	; 0xff00
57e2a864:	e1844402 	orr	r4, r4, r2, lsl #8
57e2a868:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e2a86c:	e1844423 	orr	r4, r4, r3, lsr #8
57e2a870:	e2644000 	rsb	r4, r4, #0
57e2a874:	ea000027 	b	57e2a918 <NfsHandler+0x4b0>
	}

	if ((nfs_offset != 0) && !((nfs_offset) %
57e2a878:	e59f314c 	ldr	r3, [pc, #332]	; 57e2a9cc <NfsHandler+0x564>
57e2a87c:	e5930000 	ldr	r0, [r3]
57e2a880:	e3500000 	cmp	r0, #0
57e2a884:	0a000005 	beq	57e2a8a0 <NfsHandler+0x438>
57e2a888:	e59f1154 	ldr	r1, [pc, #340]	; 57e2a9e4 <NfsHandler+0x57c>
57e2a88c:	eb0004d2 	bl	57e2bbdc <__aeabi_idivmod>
57e2a890:	e3510000 	cmp	r1, #0
57e2a894:	1a000001 	bne	57e2a8a0 <NfsHandler+0x438>
			(NFS_READ_SIZE / 2 * 10 * HASHES_PER_LINE)))
		puts("\n\t ");
57e2a898:	e59f0148 	ldr	r0, [pc, #328]	; 57e2a9e8 <NfsHandler+0x580>
57e2a89c:	ebff7ae0 	bl	57e09424 <puts>
	if (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))
57e2a8a0:	e59f3124 	ldr	r3, [pc, #292]	; 57e2a9cc <NfsHandler+0x564>
57e2a8a4:	e3a01b05 	mov	r1, #5120	; 0x1400
57e2a8a8:	e5930000 	ldr	r0, [r3]
57e2a8ac:	eb0004ca 	bl	57e2bbdc <__aeabi_idivmod>
57e2a8b0:	e3510000 	cmp	r1, #0
57e2a8b4:	1a000001 	bne	57e2a8c0 <NfsHandler+0x458>
		putc('#');
57e2a8b8:	e3a00023 	mov	r0, #35	; 0x23
57e2a8bc:	ebff7ace 	bl	57e093fc <putc>

	rlen = ntohl(rpc_pkt.u.reply.data[18]);
57e2a8c0:	e59d3060 	ldr	r3, [sp, #96]	; 0x60
			return -1;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_NFS */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
57e2a8c4:	e2851064 	add	r1, r5, #100	; 0x64
57e2a8c8:	e1a04c03 	lsl	r4, r3, #24
57e2a8cc:	e2032cff 	and	r2, r3, #65280	; 0xff00
57e2a8d0:	e1844c23 	orr	r4, r4, r3, lsr #24
57e2a8d4:	e1844402 	orr	r4, r4, r2, lsl #8
57e2a8d8:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
57e2a8dc:	e1844423 	orr	r4, r4, r3, lsr #8
57e2a8e0:	e59f2104 	ldr	r2, [pc, #260]	; 57e2a9ec <NfsHandler+0x584>
		puts("\n\t ");
	if (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))
		putc('#');

	rlen = ntohl(rpc_pkt.u.reply.data[18]);
	if (store_block((uchar *)pkt + sizeof(rpc_pkt.u.reply),
57e2a8e4:	e59f30e0 	ldr	r3, [pc, #224]	; 57e2a9cc <NfsHandler+0x564>
			return -1;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_NFS */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
57e2a8e8:	e5920000 	ldr	r0, [r2]
		puts("\n\t ");
	if (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))
		putc('#');

	rlen = ntohl(rpc_pkt.u.reply.data[18]);
	if (store_block((uchar *)pkt + sizeof(rpc_pkt.u.reply),
57e2a8ec:	e5933000 	ldr	r3, [r3]
			return -1;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_NFS */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
57e2a8f0:	e1a02004 	mov	r2, r4
57e2a8f4:	e0830000 	add	r0, r3, r0
static char nfs_path_buff[2048];

static inline int
store_block(uchar *src, unsigned offset, unsigned len)
{
	ulong newsize = offset + len;
57e2a8f8:	e0846003 	add	r6, r4, r3
			return -1;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_NFS */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
57e2a8fc:	ebffe682 	bl	57e2430c <memcpy>
	}

	if (NetBootFileXferSize < (offset+len))
57e2a900:	e59f30e8 	ldr	r3, [pc, #232]	; 57e2a9f0 <NfsHandler+0x588>
57e2a904:	e5932000 	ldr	r2, [r3]
57e2a908:	e1520006 	cmp	r2, r6
		NetBootFileXferSize = newsize;
57e2a90c:	35836000 	strcc	r6, [r3]
57e2a910:	ea000000 	b	57e2a918 <NfsHandler+0x4b0>
	    rpc_pkt.u.reply.astatus  ||
	    rpc_pkt.u.reply.data[0]) {
		if (rpc_pkt.u.reply.rstatus)
			return -9999;
		if (rpc_pkt.u.reply.astatus)
			return -9999;
57e2a914:	e59f40d8 	ldr	r4, [pc, #216]	; 57e2a9f4 <NfsHandler+0x58c>
		}
		break;

	case STATE_READ_REQ:
		rlen = nfs_read_reply(pkt, len);
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
57e2a918:	e3a00e7d 	mov	r0, #2000	; 0x7d0
57e2a91c:	e59f10d4 	ldr	r1, [pc, #212]	; 57e2a9f8 <NfsHandler+0x590>
57e2a920:	ebfff97e 	bl	57e28f20 <NetSetTimeout>
		if (rlen > 0) {
57e2a924:	e3540000 	cmp	r4, #0
			nfs_offset += rlen;
57e2a928:	c59f309c 	ldrgt	r3, [pc, #156]	; 57e2a9cc <NfsHandler+0x564>
57e2a92c:	c5932000 	ldrgt	r2, [r3]
57e2a930:	c0844002 	addgt	r4, r4, r2
57e2a934:	c5834000 	strgt	r4, [r3]
57e2a938:	ca000017 	bgt	57e2a99c <NfsHandler+0x534>
			NfsSend();
		} else if ((rlen == -NFSERR_ISDIR) || (rlen == -NFSERR_INVAL)) {
57e2a93c:	e2843016 	add	r3, r4, #22
57e2a940:	e3530001 	cmp	r3, #1
			/* symbolic link */
			NfsState = STATE_READLINK_REQ;
57e2a944:	93a02007 	movls	r2, #7
		rlen = nfs_read_reply(pkt, len);
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
		if (rlen > 0) {
			nfs_offset += rlen;
			NfsSend();
		} else if ((rlen == -NFSERR_ISDIR) || (rlen == -NFSERR_INVAL)) {
57e2a948:	9a000004 	bls	57e2a960 <NfsHandler+0x4f8>
			/* symbolic link */
			NfsState = STATE_READLINK_REQ;
			NfsSend();
		} else {
			if (!rlen)
57e2a94c:	e3540000 	cmp	r4, #0
				nfs_download_state = NETLOOP_SUCCESS;
57e2a950:	059f3050 	ldreq	r3, [pc, #80]	; 57e2a9a8 <NfsHandler+0x540>
57e2a954:	03a02002 	moveq	r2, #2
57e2a958:	0583206c 	streq	r2, [r3, #108]	; 0x6c
			NfsState = STATE_UMOUNT_REQ;
57e2a95c:	e3a02004 	mov	r2, #4
57e2a960:	e59f3040 	ldr	r3, [pc, #64]	; 57e2a9a8 <NfsHandler+0x540>
57e2a964:	e5832058 	str	r2, [r3, #88]	; 0x58
57e2a968:	ea00000b 	b	57e2a99c <NfsHandler+0x534>
			puts("*** ERROR: Symlink fail\n");
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			debug("Symlink --> %s\n", nfs_path);
			nfs_filename = basename(nfs_path);
57e2a96c:	e59f4034 	ldr	r4, [pc, #52]	; 57e2a9a8 <NfsHandler+0x540>
57e2a970:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
57e2a974:	ebfffcea 	bl	57e29d24 <basename>
			nfs_path     = dirname(nfs_path);
57e2a978:	e594505c 	ldr	r5, [r4, #92]	; 0x5c
			puts("*** ERROR: Symlink fail\n");
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			debug("Symlink --> %s\n", nfs_path);
			nfs_filename = basename(nfs_path);
57e2a97c:	e5840060 	str	r0, [r4, #96]	; 0x60
static char*
dirname(char *path)
{
	char *fname;

	fname = basename(path);
57e2a980:	e1a00005 	mov	r0, r5
57e2a984:	ebfffce6 	bl	57e29d24 <basename>
	--fname;
	*fname = '\0';
57e2a988:	e3a03000 	mov	r3, #0
57e2a98c:	e5403001 	strb	r3, [r0, #-1]
		} else {
			debug("Symlink --> %s\n", nfs_path);
			nfs_filename = basename(nfs_path);
			nfs_path     = dirname(nfs_path);

			NfsState = STATE_MOUNT_REQ;
57e2a990:	e2833003 	add	r3, r3, #3
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			debug("Symlink --> %s\n", nfs_path);
			nfs_filename = basename(nfs_path);
			nfs_path     = dirname(nfs_path);
57e2a994:	e584505c 	str	r5, [r4, #92]	; 0x5c

			NfsState = STATE_MOUNT_REQ;
57e2a998:	e5843058 	str	r3, [r4, #88]	; 0x58
			NfsSend();
57e2a99c:	ebfffe76 	bl	57e2a37c <NfsSend>
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		}
		break;
	}
}
57e2a9a0:	e28ddb0a 	add	sp, sp, #10240	; 0x2800
57e2a9a4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
57e2a9a8:	57e7b6f4 	.word	0x57e7b6f4
57e2a9ac:	000186a5 	.word	0x000186a5
57e2a9b0:	000186a3 	.word	0x000186a3
57e2a9b4:	fffff000 	.word	0xfffff000
57e2a9b8:	57e35bd8 	.word	0x57e35bd8
57e2a9bc:	57e35bf1 	.word	0x57e35bf1
57e2a9c0:	57e35bf8 	.word	0x57e35bf8
57e2a9c4:	57e79734 	.word	0x57e79734
57e2a9c8:	ffffe800 	.word	0xffffe800
57e2a9cc:	57e37bd0 	.word	0x57e37bd0
57e2a9d0:	57e35c12 	.word	0x57e35c12
57e2a9d4:	ffffe000 	.word	0xffffe000
57e2a9d8:	57e352e2 	.word	0x57e352e2
57e2a9dc:	57e35c2f 	.word	0x57e35c2f
57e2a9e0:	ffffd800 	.word	0xffffd800
57e2a9e4:	00051400 	.word	0x00051400
57e2a9e8:	57e35c48 	.word	0x57e35c48
57e2a9ec:	57e36e60 	.word	0x57e36e60
57e2a9f0:	57e7b660 	.word	0x57e7b660
57e2a9f4:	ffffd8f1 	.word	0xffffd8f1
57e2a9f8:	57e2a410 	.word	0x57e2a410

57e2a9fc <NfsStart>:


void
NfsStart(void)
{
57e2a9fc:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
	debug("%s\n", __func__);
	nfs_download_state = NETLOOP_FAIL;
57e2aa00:	e59f41d4 	ldr	r4, [pc, #468]	; 57e2abdc <NfsStart+0x1e0>
57e2aa04:	e3a03003 	mov	r3, #3
57e2aa08:	e584306c 	str	r3, [r4, #108]	; 0x6c

	NfsServerIP = NetServerIP;
57e2aa0c:	e59f31cc 	ldr	r3, [pc, #460]	; 57e2abe0 <NfsStart+0x1e4>
		net_set_state(NETLOOP_FAIL);
		puts("*** ERROR: Fail allocate memory\n");
		return;
	}

	if (BootFile[0] == '\0') {
57e2aa10:	e59f51cc 	ldr	r5, [pc, #460]	; 57e2abe4 <NfsStart+0x1e8>
NfsStart(void)
{
	debug("%s\n", __func__);
	nfs_download_state = NETLOOP_FAIL;

	NfsServerIP = NetServerIP;
57e2aa14:	e5933000 	ldr	r3, [r3]
57e2aa18:	e584300c 	str	r3, [r4, #12]
	nfs_path = (char *)nfs_path_buff;
57e2aa1c:	e2843070 	add	r3, r4, #112	; 0x70
57e2aa20:	e584305c 	str	r3, [r4, #92]	; 0x5c
		net_set_state(NETLOOP_FAIL);
		puts("*** ERROR: Fail allocate memory\n");
		return;
	}

	if (BootFile[0] == '\0') {
57e2aa24:	e5d53000 	ldrb	r3, [r5]
57e2aa28:	e3530000 	cmp	r3, #0
57e2aa2c:	1a000012 	bne	57e2aa7c <NfsStart+0x80>
		sprintf(default_filename, "/nfsroot/%02X%02X%02X%02X.img",
57e2aa30:	e59f31b0 	ldr	r3, [pc, #432]	; 57e2abe8 <NfsStart+0x1ec>
57e2aa34:	e5931000 	ldr	r1, [r3]
			NetOurIP & 0xFF,
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
57e2aa38:	e1a00821 	lsr	r0, r1, #16
		puts("*** ERROR: Fail allocate memory\n");
		return;
	}

	if (BootFile[0] == '\0') {
		sprintf(default_filename, "/nfsroot/%02X%02X%02X%02X.img",
57e2aa3c:	e20120ff 	and	r2, r1, #255	; 0xff
57e2aa40:	e1a03421 	lsr	r3, r1, #8
57e2aa44:	e20000ff 	and	r0, r0, #255	; 0xff
57e2aa48:	e1a01c21 	lsr	r1, r1, #24
57e2aa4c:	e88d0003 	stm	sp, {r0, r1}
57e2aa50:	e20330ff 	and	r3, r3, #255	; 0xff
57e2aa54:	e2840e87 	add	r0, r4, #2160	; 0x870
57e2aa58:	e59f118c 	ldr	r1, [pc, #396]	; 57e2abec <NfsStart+0x1f0>
57e2aa5c:	ebffea39 	bl	57e25348 <sprintf>
			NetOurIP & 0xFF,
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
			(NetOurIP >> 24) & 0xFF);
		strcpy(nfs_path, default_filename);
57e2aa60:	e2841e87 	add	r1, r4, #2160	; 0x870
57e2aa64:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
57e2aa68:	ebffe51c 	bl	57e23ee0 <strcpy>

		printf("*** Warning: no boot file name; using '%s'\n",
57e2aa6c:	e594105c 	ldr	r1, [r4, #92]	; 0x5c
57e2aa70:	e59f0178 	ldr	r0, [pc, #376]	; 57e2abf0 <NfsStart+0x1f4>
57e2aa74:	ebff7a74 	bl	57e0944c <printf>
57e2aa78:	ea00000c 	b	57e2aab0 <NfsStart+0xb4>
			nfs_path);
	} else {
		char *p = BootFile;

		p = strchr(p, ':');
57e2aa7c:	e3a0103a 	mov	r1, #58	; 0x3a
57e2aa80:	e1a00005 	mov	r0, r5
57e2aa84:	ebffe564 	bl	57e2401c <strchr>

		if (p != NULL) {
57e2aa88:	e2506000 	subs	r6, r0, #0
			NfsServerIP = string_to_ip(BootFile);
			++p;
			strcpy(nfs_path, p);
		} else {
			strcpy(nfs_path, BootFile);
57e2aa8c:	0594005c 	ldreq	r0, [r4, #92]	; 0x5c
57e2aa90:	01a01005 	moveq	r1, r5
	} else {
		char *p = BootFile;

		p = strchr(p, ':');

		if (p != NULL) {
57e2aa94:	0a000004 	beq	57e2aaac <NfsStart+0xb0>
			NfsServerIP = string_to_ip(BootFile);
57e2aa98:	e1a00005 	mov	r0, r5
57e2aa9c:	ebffe491 	bl	57e23ce8 <string_to_ip>
57e2aaa0:	e584000c 	str	r0, [r4, #12]
			++p;
			strcpy(nfs_path, p);
57e2aaa4:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
57e2aaa8:	e2861001 	add	r1, r6, #1
		} else {
			strcpy(nfs_path, BootFile);
57e2aaac:	ebffe50b 	bl	57e23ee0 <strcpy>
		}
	}

	nfs_filename = basename(nfs_path);
57e2aab0:	e59f5124 	ldr	r5, [pc, #292]	; 57e2abdc <NfsStart+0x1e0>
57e2aab4:	e595005c 	ldr	r0, [r5, #92]	; 0x5c
57e2aab8:	ebfffc99 	bl	57e29d24 <basename>
	nfs_path     = dirname(nfs_path);
57e2aabc:	e595405c 	ldr	r4, [r5, #92]	; 0x5c
		} else {
			strcpy(nfs_path, BootFile);
		}
	}

	nfs_filename = basename(nfs_path);
57e2aac0:	e5850060 	str	r0, [r5, #96]	; 0x60
static char*
dirname(char *path)
{
	char *fname;

	fname = basename(path);
57e2aac4:	e1a00004 	mov	r0, r4
57e2aac8:	ebfffc95 	bl	57e29d24 <basename>
	--fname;
	*fname = '\0';
57e2aacc:	e3a03000 	mov	r3, #0
57e2aad0:	e5403001 	strb	r3, [r0, #-1]
			strcpy(nfs_path, BootFile);
		}
	}

	nfs_filename = basename(nfs_path);
	nfs_path     = dirname(nfs_path);
57e2aad4:	e585405c 	str	r4, [r5, #92]	; 0x5c

	printf("Using %s device\n", eth_get_name());
57e2aad8:	ebfff8d1 	bl	57e28e24 <eth_get_name>

	printf("File transfer via NFS from server %pI4"
57e2aadc:	e59f4104 	ldr	r4, [pc, #260]	; 57e2abe8 <NfsStart+0x1ec>
	}

	nfs_filename = basename(nfs_path);
	nfs_path     = dirname(nfs_path);

	printf("Using %s device\n", eth_get_name());
57e2aae0:	e1a01000 	mov	r1, r0
57e2aae4:	e59f0108 	ldr	r0, [pc, #264]	; 57e2abf4 <NfsStart+0x1f8>
57e2aae8:	ebff7a57 	bl	57e0944c <printf>

	printf("File transfer via NFS from server %pI4"
57e2aaec:	e285100c 	add	r1, r5, #12
57e2aaf0:	e59f0100 	ldr	r0, [pc, #256]	; 57e2abf8 <NfsStart+0x1fc>
57e2aaf4:	e1a02004 	mov	r2, r4
57e2aaf8:	ebff7a53 	bl	57e0944c <printf>
		"; our IP address is %pI4", &NfsServerIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
57e2aafc:	e59f10f8 	ldr	r1, [pc, #248]	; 57e2abfc <NfsStart+0x200>
57e2ab00:	e5913000 	ldr	r3, [r1]
57e2ab04:	e3530000 	cmp	r3, #0
57e2ab08:	0a00000c 	beq	57e2ab40 <NfsStart+0x144>
57e2ab0c:	e59f30ec 	ldr	r3, [pc, #236]	; 57e2ac00 <NfsStart+0x204>
57e2ab10:	e5933000 	ldr	r3, [r3]
57e2ab14:	e3530000 	cmp	r3, #0
57e2ab18:	0a000008 	beq	57e2ab40 <NfsStart+0x144>
		IPaddr_t OurNet	    = NetOurIP	  & NetOurSubnetMask;
		IPaddr_t ServerNet  = NetServerIP & NetOurSubnetMask;
57e2ab1c:	e59f00bc 	ldr	r0, [pc, #188]	; 57e2abe0 <NfsStart+0x1e4>
	printf("File transfer via NFS from server %pI4"
		"; our IP address is %pI4", &NfsServerIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
		IPaddr_t OurNet	    = NetOurIP	  & NetOurSubnetMask;
57e2ab20:	e5942000 	ldr	r2, [r4]
		IPaddr_t ServerNet  = NetServerIP & NetOurSubnetMask;
57e2ab24:	e5900000 	ldr	r0, [r0]
	printf("File transfer via NFS from server %pI4"
		"; our IP address is %pI4", &NfsServerIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
		IPaddr_t OurNet	    = NetOurIP	  & NetOurSubnetMask;
57e2ab28:	e0032002 	and	r2, r3, r2
		IPaddr_t ServerNet  = NetServerIP & NetOurSubnetMask;
57e2ab2c:	e0033000 	and	r3, r3, r0

		if (OurNet != ServerNet)
57e2ab30:	e1520003 	cmp	r2, r3
57e2ab34:	0a000001 	beq	57e2ab40 <NfsStart+0x144>
			printf("; sending through gateway %pI4",
57e2ab38:	e59f00c4 	ldr	r0, [pc, #196]	; 57e2ac04 <NfsStart+0x208>
57e2ab3c:	ebff7a42 	bl	57e0944c <printf>
				&NetOurGatewayIP);
	}
	printf("\nFilename '%s/%s'.", nfs_path, nfs_filename);
57e2ab40:	e59f3094 	ldr	r3, [pc, #148]	; 57e2abdc <NfsStart+0x1e0>

	if (NetBootFileSize) {
57e2ab44:	e59f40bc 	ldr	r4, [pc, #188]	; 57e2ac08 <NfsStart+0x20c>

		if (OurNet != ServerNet)
			printf("; sending through gateway %pI4",
				&NetOurGatewayIP);
	}
	printf("\nFilename '%s/%s'.", nfs_path, nfs_filename);
57e2ab48:	e593105c 	ldr	r1, [r3, #92]	; 0x5c
57e2ab4c:	e59f00b8 	ldr	r0, [pc, #184]	; 57e2ac0c <NfsStart+0x210>
57e2ab50:	e5932060 	ldr	r2, [r3, #96]	; 0x60
57e2ab54:	ebff7a3c 	bl	57e0944c <printf>

	if (NetBootFileSize) {
57e2ab58:	e1d410b0 	ldrh	r1, [r4]
57e2ab5c:	e3510000 	cmp	r1, #0
57e2ab60:	0a000007 	beq	57e2ab84 <NfsStart+0x188>
		printf(" Size is 0x%x Bytes = ", NetBootFileSize<<9);
57e2ab64:	e1a01481 	lsl	r1, r1, #9
57e2ab68:	e59f00a0 	ldr	r0, [pc, #160]	; 57e2ac10 <NfsStart+0x214>
57e2ab6c:	ebff7a36 	bl	57e0944c <printf>
		print_size(NetBootFileSize<<9, "");
57e2ab70:	e1d400b0 	ldrh	r0, [r4]
57e2ab74:	e59f2098 	ldr	r2, [pc, #152]	; 57e2ac14 <NfsStart+0x218>
57e2ab78:	e1a00480 	lsl	r0, r0, #9
57e2ab7c:	e1a01fc0 	asr	r1, r0, #31
57e2ab80:	ebffddba 	bl	57e22270 <print_size>
	}
	printf("\nLoad address: 0x%lx\n"
57e2ab84:	e59f308c 	ldr	r3, [pc, #140]	; 57e2ac18 <NfsStart+0x21c>
57e2ab88:	e59f008c 	ldr	r0, [pc, #140]	; 57e2ac1c <NfsStart+0x220>
57e2ab8c:	e5931000 	ldr	r1, [r3]
57e2ab90:	ebff7a2d 	bl	57e0944c <printf>
		"Loading: *\b", load_addr);

	NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
57e2ab94:	e59f1084 	ldr	r1, [pc, #132]	; 57e2ac20 <NfsStart+0x224>
57e2ab98:	e3a00e7d 	mov	r0, #2000	; 0x7d0
57e2ab9c:	ebfff8df 	bl	57e28f20 <NetSetTimeout>
	net_set_udp_handler(NfsHandler);
57e2aba0:	e59f007c 	ldr	r0, [pc, #124]	; 57e2ac24 <NfsStart+0x228>
57e2aba4:	ebfff8c9 	bl	57e28ed0 <net_set_udp_handler>

	NfsTimeoutCount = 0;
57e2aba8:	e59f302c 	ldr	r3, [pc, #44]	; 57e2abdc <NfsStart+0x1e0>
	NfsState = STATE_PRCLOOKUP_PROG_MOUNT_REQ;
57e2abac:	e3a02001 	mov	r2, #1
		"Loading: *\b", load_addr);

	NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
	net_set_udp_handler(NfsHandler);

	NfsTimeoutCount = 0;
57e2abb0:	e3a01000 	mov	r1, #0
	NfsState = STATE_PRCLOOKUP_PROG_MOUNT_REQ;
57e2abb4:	e5832058 	str	r2, [r3, #88]	; 0x58

	/*NfsOurPort = 4096 + (get_ticks() % 3072);*/
	/*FIX ME !!!*/
	NfsOurPort = 1000;
57e2abb8:	e3a02ffa 	mov	r2, #1000	; 0x3e8
57e2abbc:	e5832010 	str	r2, [r3, #16]
		"Loading: *\b", load_addr);

	NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
	net_set_udp_handler(NfsHandler);

	NfsTimeoutCount = 0;
57e2abc0:	e5831068 	str	r1, [r3, #104]	; 0x68
	/*NfsOurPort = 4096 + (get_ticks() % 3072);*/
	/*FIX ME !!!*/
	NfsOurPort = 1000;

	/* zero out server ether in case the server ip has changed */
	memset(NetServerEther, 0, 6);
57e2abc4:	e3a02006 	mov	r2, #6
57e2abc8:	e59f0058 	ldr	r0, [pc, #88]	; 57e2ac28 <NfsStart+0x22c>
57e2abcc:	ebffe5aa 	bl	57e2427c <memset>

	NfsSend();
}
57e2abd0:	e28dd008 	add	sp, sp, #8
57e2abd4:	e8bd4070 	pop	{r4, r5, r6, lr}
	NfsOurPort = 1000;

	/* zero out server ether in case the server ip has changed */
	memset(NetServerEther, 0, 6);

	NfsSend();
57e2abd8:	eafffde7 	b	57e2a37c <NfsSend>
57e2abdc:	57e7b6f4 	.word	0x57e7b6f4
57e2abe0:	57e7980c 	.word	0x57e7980c
57e2abe4:	57e79780 	.word	0x57e79780
57e2abe8:	57e79764 	.word	0x57e79764
57e2abec:	57e35c4c 	.word	0x57e35c4c
57e2abf0:	57e35c6a 	.word	0x57e35c6a
57e2abf4:	57e35c96 	.word	0x57e35c96
57e2abf8:	57e35ca7 	.word	0x57e35ca7
57e2abfc:	57e79804 	.word	0x57e79804
57e2ac00:	57e79808 	.word	0x57e79808
57e2ac04:	57e35ce6 	.word	0x57e35ce6
57e2ac08:	57e7b6e8 	.word	0x57e7b6e8
57e2ac0c:	57e35d05 	.word	0x57e35d05
57e2ac10:	57e35d18 	.word	0x57e35d18
57e2ac14:	57e302de 	.word	0x57e302de
57e2ac18:	57e36e60 	.word	0x57e36e60
57e2ac1c:	57e35d2f 	.word	0x57e35d2f
57e2ac20:	57e2a410 	.word	0x57e2a410
57e2ac24:	57e2a468 	.word	0x57e2a468
57e2ac28:	57e7b6ec 	.word	0x57e7b6ec

57e2ac2c <ping_timeout>:
	ArpRequest();
	return 1;	/* waiting */
}

static void ping_timeout(void)
{
57e2ac2c:	e92d4008 	push	{r3, lr}
	eth_halt();
57e2ac30:	ebfff7e1 	bl	57e28bbc <eth_halt>
57e2ac34:	e59f3008 	ldr	r3, [pc, #8]	; 57e2ac44 <ping_timeout+0x18>
57e2ac38:	e3a02003 	mov	r2, #3
57e2ac3c:	e5832000 	str	r2, [r3]
	net_set_state(NETLOOP_FAIL);	/* we did not get the reply */
}
57e2ac40:	e8bd8008 	pop	{r3, pc}
57e2ac44:	57e79734 	.word	0x57e79734

57e2ac48 <ping_start>:

void ping_start(void)
{
57e2ac48:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	printf("Using %s device\n", eth_get_name());
57e2ac4c:	ebfff874 	bl	57e28e24 <eth_get_name>

	/* XXX always send arp request */

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;
57e2ac50:	e59f60ec 	ldr	r6, [pc, #236]	; 57e2ad44 <ping_start+0xfc>
	net_set_state(NETLOOP_FAIL);	/* we did not get the reply */
}

void ping_start(void)
{
	printf("Using %s device\n", eth_get_name());
57e2ac54:	e1a01000 	mov	r1, r0
57e2ac58:	e59f00e8 	ldr	r0, [pc, #232]	; 57e2ad48 <ping_start+0x100>
57e2ac5c:	ebff79fa 	bl	57e0944c <printf>
	NetSetTimeout(10000UL, ping_timeout);
57e2ac60:	e59f00e4 	ldr	r0, [pc, #228]	; 57e2ad4c <ping_start+0x104>
57e2ac64:	e59f10e4 	ldr	r1, [pc, #228]	; 57e2ad50 <ping_start+0x108>
57e2ac68:	ebfff8ac 	bl	57e28f20 <NetSetTimeout>

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
57e2ac6c:	e59f40e0 	ldr	r4, [pc, #224]	; 57e2ad54 <ping_start+0x10c>

	/* XXX always send arp request */

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;
57e2ac70:	e5962000 	ldr	r2, [r6]
57e2ac74:	e59f30dc 	ldr	r3, [pc, #220]	; 57e2ad58 <ping_start+0x110>

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
57e2ac78:	e5940000 	ldr	r0, [r4]

	/* XXX always send arp request */

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;
57e2ac7c:	e5832000 	str	r2, [r3]

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
57e2ac80:	e59f10d4 	ldr	r1, [pc, #212]	; 57e2ad5c <ping_start+0x114>
57e2ac84:	e3a02b02 	mov	r2, #2048	; 0x800
57e2ac88:	ebfff9d5 	bl	57e293e4 <NetSetEther>
	pkt = (uchar *)NetTxPacket + eth_hdr_size;
57e2ac8c:	e5944000 	ldr	r4, [r4]
	 *	Construct an IP and ICMP header.
	 */
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);

	net_set_ip_header(pkt, dest, NetOurIP);
57e2ac90:	e59f30c8 	ldr	r3, [pc, #200]	; 57e2ad60 <ping_start+0x118>
	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
	pkt = (uchar *)NetTxPacket + eth_hdr_size;
57e2ac94:	e0844000 	add	r4, r4, r0
	 *	Construct an IP and ICMP header.
	 */
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);

	net_set_ip_header(pkt, dest, NetOurIP);
57e2ac98:	e5932000 	ldr	r2, [r3]
57e2ac9c:	e5961000 	ldr	r1, [r6]

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
57e2aca0:	e1a07000 	mov	r7, r0
	 *	Construct an IP and ICMP header.
	 */
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);

	net_set_ip_header(pkt, dest, NetOurIP);
57e2aca4:	e1a00004 	mov	r0, r4
57e2aca8:	ebfffa1a 	bl	57e29518 <net_set_ip_header>

	ip->ip_len   = htons(IP_ICMP_HDR_SIZE);
	ip->ip_p     = IPPROTO_ICMP;
57e2acac:	e3a0a001 	mov	sl, #1
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);

	net_set_ip_header(pkt, dest, NetOurIP);

	ip->ip_len   = htons(IP_ICMP_HDR_SIZE);
57e2acb0:	e3a03b07 	mov	r3, #7168	; 0x1c00
57e2acb4:	e1c430b2 	strh	r3, [r4, #2]
	ip->ip_p     = IPPROTO_ICMP;
57e2acb8:	e5c4a009 	strb	sl, [r4, #9]
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
57e2acbc:	e1a00004 	mov	r0, r4
57e2acc0:	e3a0100a 	mov	r1, #10
57e2acc4:	ebfff8f1 	bl	57e29090 <NetCksum>

	icmp->type = ICMP_ECHO_REQUEST;
57e2acc8:	e3a03008 	mov	r3, #8

	net_set_ip_header(pkt, dest, NetOurIP);

	ip->ip_len   = htons(IP_ICMP_HDR_SIZE);
	ip->ip_p     = IPPROTO_ICMP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
57e2accc:	e1e00000 	mvn	r0, r0
{
	/*
	 *	Construct an IP and ICMP header.
	 */
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);
57e2acd0:	e2845014 	add	r5, r4, #20

	net_set_ip_header(pkt, dest, NetOurIP);

	ip->ip_len   = htons(IP_ICMP_HDR_SIZE);
	ip->ip_p     = IPPROTO_ICMP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
57e2acd4:	e1c400ba 	strh	r0, [r4, #10]

	icmp->type = ICMP_ECHO_REQUEST;
57e2acd8:	e5c43014 	strb	r3, [r4, #20]
	icmp->code = 0;
57e2acdc:	e3a04000 	mov	r4, #0
57e2ace0:	e5c54001 	strb	r4, [r5, #1]
	icmp->checksum = 0;
	icmp->un.echo.id = 0;
	icmp->un.echo.sequence = htons(PingSeqNo++);
57e2ace4:	e1d630b4 	ldrh	r3, [r6, #4]
	icmp->checksum = ~NetCksum((uchar *)icmp, ICMP_HDR_SIZE	>> 1);
57e2ace8:	e3a01004 	mov	r1, #4

	icmp->type = ICMP_ECHO_REQUEST;
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->un.echo.id = 0;
	icmp->un.echo.sequence = htons(PingSeqNo++);
57e2acec:	e083200a 	add	r2, r3, sl
57e2acf0:	e1c620b4 	strh	r2, [r6, #4]
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
57e2acf4:	e1a02423 	lsr	r2, r3, #8
57e2acf8:	e1823403 	orr	r3, r2, r3, lsl #8
57e2acfc:	e1c530b6 	strh	r3, [r5, #6]
	ip->ip_p     = IPPROTO_ICMP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);

	icmp->type = ICMP_ECHO_REQUEST;
	icmp->code = 0;
	icmp->checksum = 0;
57e2ad00:	e1c540b2 	strh	r4, [r5, #2]
	icmp->un.echo.id = 0;
57e2ad04:	e1c540b4 	strh	r4, [r5, #4]
	icmp->un.echo.sequence = htons(PingSeqNo++);
	icmp->checksum = ~NetCksum((uchar *)icmp, ICMP_HDR_SIZE	>> 1);
57e2ad08:	e1a00005 	mov	r0, r5
57e2ad0c:	ebfff8df 	bl	57e29090 <NetCksum>
	pkt = (uchar *)NetTxPacket + eth_hdr_size;

	set_icmp_header(pkt, NetPingIP);

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;
57e2ad10:	e59f304c 	ldr	r3, [pc, #76]	; 57e2ad64 <ping_start+0x11c>
	icmp->type = ICMP_ECHO_REQUEST;
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->un.echo.id = 0;
	icmp->un.echo.sequence = htons(PingSeqNo++);
	icmp->checksum = ~NetCksum((uchar *)icmp, ICMP_HDR_SIZE	>> 1);
57e2ad14:	e1e00000 	mvn	r0, r0
	pkt = (uchar *)NetTxPacket + eth_hdr_size;

	set_icmp_header(pkt, NetPingIP);

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;
57e2ad18:	e287701c 	add	r7, r7, #28
	icmp->type = ICMP_ECHO_REQUEST;
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->un.echo.id = 0;
	icmp->un.echo.sequence = htons(PingSeqNo++);
	icmp->checksum = ~NetCksum((uchar *)icmp, ICMP_HDR_SIZE	>> 1);
57e2ad1c:	e1c500b2 	strh	r0, [r5, #2]
	pkt = (uchar *)NetTxPacket + eth_hdr_size;

	set_icmp_header(pkt, NetPingIP);

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;
57e2ad20:	e5837000 	str	r7, [r3]

	/* and do the ARP request */
	NetArpWaitTry = 1;
57e2ad24:	e59f303c 	ldr	r3, [pc, #60]	; 57e2ad68 <ping_start+0x120>
	NetArpWaitTimerStart = get_timer(0);
57e2ad28:	e1a00004 	mov	r0, r4

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;

	/* and do the ARP request */
	NetArpWaitTry = 1;
57e2ad2c:	e583a000 	str	sl, [r3]
	NetArpWaitTimerStart = get_timer(0);
57e2ad30:	ebff5775 	bl	57e00b0c <get_timer>
57e2ad34:	e59f3030 	ldr	r3, [pc, #48]	; 57e2ad6c <ping_start+0x124>
57e2ad38:	e5830000 	str	r0, [r3]
{
	printf("Using %s device\n", eth_get_name());
	NetSetTimeout(10000UL, ping_timeout);

	ping_send();
}
57e2ad3c:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;

	/* and do the ARP request */
	NetArpWaitTry = 1;
	NetArpWaitTimerStart = get_timer(0);
	ArpRequest();
57e2ad40:	eafff39b 	b	57e27bb4 <ArpRequest>
57e2ad44:	57e7bfa4 	.word	0x57e7bfa4
57e2ad48:	57e35c96 	.word	0x57e35c96
57e2ad4c:	00002710 	.word	0x00002710
57e2ad50:	57e2ac2c 	.word	0x57e2ac2c
57e2ad54:	57e79774 	.word	0x57e79774
57e2ad58:	57e790bc 	.word	0x57e790bc
57e2ad5c:	57e79778 	.word	0x57e79778
57e2ad60:	57e79764 	.word	0x57e79764
57e2ad64:	57e790c4 	.word	0x57e790c4
57e2ad68:	57e79710 	.word	0x57e79710
57e2ad6c:	57e7970c 	.word	0x57e7970c

57e2ad70 <ping_receive>:

	ping_send();
}

void ping_receive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
57e2ad70:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;
	IPaddr_t src_ip;
	int eth_hdr_size;

	switch (icmph->type) {
57e2ad74:	e5d13014 	ldrb	r3, [r1, #20]

	ping_send();
}

void ping_receive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
57e2ad78:	e1a07000 	mov	r7, r0
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;
	IPaddr_t src_ip;
	int eth_hdr_size;

	switch (icmph->type) {
57e2ad7c:	e3530000 	cmp	r3, #0

	ping_send();
}

void ping_receive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
57e2ad80:	e1a04001 	mov	r4, r1
57e2ad84:	e1a09002 	mov	r9, r2
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;
57e2ad88:	e2816014 	add	r6, r1, #20
	IPaddr_t src_ip;
	int eth_hdr_size;

	switch (icmph->type) {
57e2ad8c:	0a000002 	beq	57e2ad9c <ping_receive+0x2c>
57e2ad90:	e3530008 	cmp	r3, #8
57e2ad94:	1a00002c 	bne	57e2ae4c <ping_receive+0xdc>
57e2ad98:	ea00000b 	b	57e2adcc <ping_receive+0x5c>
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
57e2ad9c:	e3a02004 	mov	r2, #4
57e2ada0:	e28d0004 	add	r0, sp, #4
57e2ada4:	e281100c 	add	r1, r1, #12
57e2ada8:	ebffe557 	bl	57e2430c <memcpy>
	case ICMP_ECHO_REPLY:
		src_ip = NetReadIP((void *)&ip->ip_src);
		if (src_ip == NetPingIP)
57e2adac:	e59f309c 	ldr	r3, [pc, #156]	; 57e2ae50 <ping_receive+0xe0>
57e2adb0:	e59d2004 	ldr	r2, [sp, #4]
57e2adb4:	e5933000 	ldr	r3, [r3]
57e2adb8:	e1520003 	cmp	r2, r3
extern enum net_loop_state net_state;

static inline void net_set_state(enum net_loop_state state)
{
	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
57e2adbc:	059f3090 	ldreq	r3, [pc, #144]	; 57e2ae54 <ping_receive+0xe4>
57e2adc0:	03a02002 	moveq	r2, #2
57e2adc4:	05832000 	streq	r2, [r3]
57e2adc8:	ea00001f 	b	57e2ae4c <ping_receive+0xdc>
			net_set_state(NETLOOP_SUCCESS);
		return;
	case ICMP_ECHO_REQUEST:
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_IP);
57e2adcc:	e2801006 	add	r1, r0, #6
57e2add0:	e3a02b02 	mov	r2, #2048	; 0x800
57e2add4:	ebfff9ab 	bl	57e29488 <net_update_ether>

		debug_cond(DEBUG_DEV_PKT, "Got ICMP ECHO REQUEST, return "
			"%d bytes\n", eth_hdr_size + len);

		ip->ip_sum = 0;
57e2add8:	e3a05000 	mov	r5, #0
		ip->ip_off = 0;
		NetCopyIP((void *)&ip->ip_dst, &ip->ip_src);
57e2addc:	e284a00c 	add	sl, r4, #12
		src_ip = NetReadIP((void *)&ip->ip_src);
		if (src_ip == NetPingIP)
			net_set_state(NETLOOP_SUCCESS);
		return;
	case ICMP_ECHO_REQUEST:
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_IP);
57e2ade0:	e1a0b000 	mov	fp, r0
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy((void *)to, from, sizeof(IPaddr_t));
57e2ade4:	e1a0100a 	mov	r1, sl
57e2ade8:	e3a02004 	mov	r2, #4

		debug_cond(DEBUG_DEV_PKT, "Got ICMP ECHO REQUEST, return "
			"%d bytes\n", eth_hdr_size + len);

		ip->ip_sum = 0;
57e2adec:	e1c450ba 	strh	r5, [r4, #10]
		ip->ip_off = 0;
57e2adf0:	e1c450b6 	strh	r5, [r4, #6]
57e2adf4:	e2840010 	add	r0, r4, #16
57e2adf8:	ebffe543 	bl	57e2430c <memcpy>
57e2adfc:	e3a02004 	mov	r2, #4
57e2ae00:	e59f1050 	ldr	r1, [pc, #80]	; 57e2ae58 <ping_receive+0xe8>
57e2ae04:	e1a0000a 	mov	r0, sl
57e2ae08:	ebffe53f 	bl	57e2430c <memcpy>
		NetCopyIP((void *)&ip->ip_dst, &ip->ip_src);
		NetCopyIP((void *)&ip->ip_src, &NetOurIP);
		ip->ip_sum = ~NetCksum((uchar *)ip,
57e2ae0c:	e3a0100a 	mov	r1, #10
57e2ae10:	e1a00004 	mov	r0, r4
57e2ae14:	ebfff89d 	bl	57e29090 <NetCksum>
				       IP_HDR_SIZE >> 1);

		icmph->type = ICMP_ECHO_REPLY;
		icmph->checksum = 0;
		icmph->checksum = ~NetCksum((uchar *)icmph,
			(len - IP_HDR_SIZE) >> 1);
57e2ae18:	e2491014 	sub	r1, r9, #20

		ip->ip_sum = 0;
		ip->ip_off = 0;
		NetCopyIP((void *)&ip->ip_dst, &ip->ip_src);
		NetCopyIP((void *)&ip->ip_src, &NetOurIP);
		ip->ip_sum = ~NetCksum((uchar *)ip,
57e2ae1c:	e1e00000 	mvn	r0, r0
57e2ae20:	e1c400ba 	strh	r0, [r4, #10]
				       IP_HDR_SIZE >> 1);

		icmph->type = ICMP_ECHO_REPLY;
		icmph->checksum = 0;
		icmph->checksum = ~NetCksum((uchar *)icmph,
57e2ae24:	e1a010a1 	lsr	r1, r1, #1
		NetCopyIP((void *)&ip->ip_dst, &ip->ip_src);
		NetCopyIP((void *)&ip->ip_src, &NetOurIP);
		ip->ip_sum = ~NetCksum((uchar *)ip,
				       IP_HDR_SIZE >> 1);

		icmph->type = ICMP_ECHO_REPLY;
57e2ae28:	e5c45014 	strb	r5, [r4, #20]
		icmph->checksum = 0;
57e2ae2c:	e1c650b2 	strh	r5, [r6, #2]
		icmph->checksum = ~NetCksum((uchar *)icmph,
57e2ae30:	e1a00006 	mov	r0, r6
57e2ae34:	ebfff895 	bl	57e29090 <NetCksum>
57e2ae38:	e1e00000 	mvn	r0, r0
57e2ae3c:	e1c600b2 	strh	r0, [r6, #2]
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
57e2ae40:	e08b1009 	add	r1, fp, r9
57e2ae44:	e1a00007 	mov	r0, r7
57e2ae48:	ebfff767 	bl	57e28bec <eth_send>
		NetSendPacket((uchar *)et, eth_hdr_size + len);
		return;
/*	default:
		return;*/
	}
}
57e2ae4c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
57e2ae50:	57e7bfa4 	.word	0x57e7bfa4
57e2ae54:	57e79734 	.word	0x57e79734
57e2ae58:	57e79764 	.word	0x57e79764

57e2ae5c <TftpSend>:
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE;
57e2ae5c:	e59f3170 	ldr	r3, [pc, #368]	; 57e2afd4 <TftpSend+0x178>
	net_set_state(NETLOOP_SUCCESS);
}

static void
TftpSend(void)
{
57e2ae60:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE;
57e2ae64:	e5935000 	ldr	r5, [r3]
57e2ae68:	ebfff94d 	bl	57e293a4 <NetEthHdrSize>

	switch (TftpState) {
57e2ae6c:	e59f3164 	ldr	r3, [pc, #356]	; 57e2afd8 <TftpSend+0x17c>
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE;
57e2ae70:	e280001c 	add	r0, r0, #28

	switch (TftpState) {
57e2ae74:	e5933000 	ldr	r3, [r3]
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE;
57e2ae78:	e0854000 	add	r4, r5, r0

	switch (TftpState) {
57e2ae7c:	e2433001 	sub	r3, r3, #1
57e2ae80:	e3530006 	cmp	r3, #6
57e2ae84:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
57e2ae88:	ea000048 	b	57e2afb0 <TftpSend+0x154>
57e2ae8c:	57e2aea8 	.word	0x57e2aea8
57e2ae90:	57e2af40 	.word	0x57e2af40
57e2ae94:	57e2af68 	.word	0x57e2af68
57e2ae98:	57e2af8c 	.word	0x57e2af8c
57e2ae9c:	57e2af40 	.word	0x57e2af40
57e2aea0:	57e2af40 	.word	0x57e2af40
57e2aea4:	57e2aea8 	.word	0x57e2aea8
		s = (ushort *)pkt;
#ifdef CONFIG_CMD_TFTPPUT
		*s++ = htons(TftpState == STATE_SEND_RRQ ? TFTP_RRQ :
			TFTP_WRQ);
#else
		*s++ = htons(TFTP_RRQ);
57e2aea8:	e3a03c01 	mov	r3, #256	; 0x100
57e2aeac:	e18530b0 	strh	r3, [r5, r0]
57e2aeb0:	e2845002 	add	r5, r4, #2
#endif
		pkt = (uchar *)s;
		strcpy((char *)pkt, tftp_filename);
57e2aeb4:	e59f1120 	ldr	r1, [pc, #288]	; 57e2afdc <TftpSend+0x180>
57e2aeb8:	e1a00005 	mov	r0, r5
57e2aebc:	ebffe407 	bl	57e23ee0 <strcpy>
		pkt += strlen(tftp_filename) + 1;
57e2aec0:	e59f0114 	ldr	r0, [pc, #276]	; 57e2afdc <TftpSend+0x180>
57e2aec4:	ebffe461 	bl	57e24050 <strlen>
57e2aec8:	e2800001 	add	r0, r0, #1
57e2aecc:	e0855000 	add	r5, r5, r0
		strcpy((char *)pkt, "octet");
57e2aed0:	e1a00005 	mov	r0, r5
57e2aed4:	e59f1104 	ldr	r1, [pc, #260]	; 57e2afe0 <TftpSend+0x184>
		pkt += 5 /*strlen("octet")*/ + 1;
		strcpy((char *)pkt, "timeout");
		pkt += 7 /*strlen("timeout")*/ + 1;
		sprintf((char *)pkt, "%lu", TftpTimeoutMSecs / 1000);
57e2aed8:	e59f6104 	ldr	r6, [pc, #260]	; 57e2afe4 <TftpSend+0x188>
		*s++ = htons(TFTP_RRQ);
#endif
		pkt = (uchar *)s;
		strcpy((char *)pkt, tftp_filename);
		pkt += strlen(tftp_filename) + 1;
		strcpy((char *)pkt, "octet");
57e2aedc:	ebffe3ff 	bl	57e23ee0 <strcpy>
		pkt += 5 /*strlen("octet")*/ + 1;
		strcpy((char *)pkt, "timeout");
57e2aee0:	e2850006 	add	r0, r5, #6
57e2aee4:	e59f10fc 	ldr	r1, [pc, #252]	; 57e2afe8 <TftpSend+0x18c>
57e2aee8:	ebffe3fc 	bl	57e23ee0 <strcpy>
		pkt += 7 /*strlen("timeout")*/ + 1;
		sprintf((char *)pkt, "%lu", TftpTimeoutMSecs / 1000);
57e2aeec:	e5960000 	ldr	r0, [r6]
57e2aef0:	e3a01ffa 	mov	r1, #1000	; 0x3e8
57e2aef4:	eb00022d 	bl	57e2b7b0 <__udivsi3>
		strcpy((char *)pkt, tftp_filename);
		pkt += strlen(tftp_filename) + 1;
		strcpy((char *)pkt, "octet");
		pkt += 5 /*strlen("octet")*/ + 1;
		strcpy((char *)pkt, "timeout");
		pkt += 7 /*strlen("timeout")*/ + 1;
57e2aef8:	e285500e 	add	r5, r5, #14
		sprintf((char *)pkt, "%lu", TftpTimeoutMSecs / 1000);
57e2aefc:	e1a02000 	mov	r2, r0
57e2af00:	e59f10e4 	ldr	r1, [pc, #228]	; 57e2afec <TftpSend+0x190>
57e2af04:	e1a00005 	mov	r0, r5
57e2af08:	ebffe90e 	bl	57e25348 <sprintf>
		debug("send option \"timeout %s\"\n", (char *)pkt);
		pkt += strlen((char *)pkt) + 1;
57e2af0c:	e1a00005 	mov	r0, r5
57e2af10:	ebffe44e 	bl	57e24050 <strlen>
57e2af14:	e2800001 	add	r0, r0, #1
57e2af18:	e0855000 	add	r5, r5, r0
#ifdef CONFIG_TFTP_TSIZE
		pkt += sprintf((char *)pkt, "tsize%c%lu%c",
				0, NetBootFileXferSize, 0);
#endif
		/* try for more effic. blk size */
		pkt += sprintf((char *)pkt, "blksize%c%d%c",
57e2af1c:	e3a02000 	mov	r2, #0
57e2af20:	e1a00005 	mov	r0, r5
57e2af24:	e1d630b4 	ldrh	r3, [r6, #4]
57e2af28:	e59f10c0 	ldr	r1, [pc, #192]	; 57e2aff0 <TftpSend+0x194>
57e2af2c:	e58d2000 	str	r2, [sp]
57e2af30:	ebffe904 	bl	57e25348 <sprintf>
57e2af34:	e0855000 	add	r5, r5, r0
				pkt += sprintf((char *)pkt, "multicast%c%c",
					0, 0);
			}
		}
#endif /* CONFIG_MCAST_TFTP */
		len = pkt - xp;
57e2af38:	e0644005 	rsb	r4, r4, r5
		break;
57e2af3c:	ea00001c 	b	57e2afb4 <TftpSend+0x158>

	case STATE_RECV_WRQ:
	case STATE_DATA:
		xp = pkt;
		s = (ushort *)pkt;
		s[0] = htons(TFTP_ACK);
57e2af40:	e3a03b01 	mov	r3, #1024	; 0x400
57e2af44:	e18530b0 	strh	r3, [r5, r0]
		s[1] = htons(TftpBlock);
57e2af48:	e59f3088 	ldr	r3, [pc, #136]	; 57e2afd8 <TftpSend+0x17c>
57e2af4c:	e5933084 	ldr	r3, [r3, #132]	; 0x84
57e2af50:	e1a03803 	lsl	r3, r3, #16
57e2af54:	e1a02c23 	lsr	r2, r3, #24
57e2af58:	e1823423 	orr	r3, r2, r3, lsr #8
57e2af5c:	e1c430b2 	strh	r3, [r4, #2]
			s[0] = htons(TFTP_DATA);
			pkt += loaded;
			TftpFinalBlock = (loaded < toload);
		}
#endif
		len = pkt - xp;
57e2af60:	e3a04004 	mov	r4, #4
		break;
57e2af64:	ea000012 	b	57e2afb4 <TftpSend+0x158>

	case STATE_TOO_LARGE:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
57e2af68:	e3a03c05 	mov	r3, #1280	; 0x500
57e2af6c:	e18530b0 	strh	r3, [r5, r0]
			*s++ = htons(3);
57e2af70:	e3a03c03 	mov	r3, #768	; 0x300
57e2af74:	e1c430b2 	strh	r3, [r4, #2]

		pkt = (uchar *)s;
		strcpy((char *)pkt, "File too large");
57e2af78:	e2840004 	add	r0, r4, #4
57e2af7c:	e59f1070 	ldr	r1, [pc, #112]	; 57e2aff4 <TftpSend+0x198>
57e2af80:	ebffe3d6 	bl	57e23ee0 <strcpy>
		pkt += 14 /*strlen("File too large")*/ + 1;
		len = pkt - xp;
57e2af84:	e3a04013 	mov	r4, #19
		break;
57e2af88:	ea000009 	b	57e2afb4 <TftpSend+0x158>

	case STATE_BAD_MAGIC:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
57e2af8c:	e3a03c05 	mov	r3, #1280	; 0x500
57e2af90:	e18530b0 	strh	r3, [r5, r0]
		*s++ = htons(2);
57e2af94:	e3a03c02 	mov	r3, #512	; 0x200
57e2af98:	e1c430b2 	strh	r3, [r4, #2]
		pkt = (uchar *)s;
		strcpy((char *)pkt, "File has bad magic");
57e2af9c:	e2840004 	add	r0, r4, #4
57e2afa0:	e59f1050 	ldr	r1, [pc, #80]	; 57e2aff8 <TftpSend+0x19c>
57e2afa4:	ebffe3cd 	bl	57e23ee0 <strcpy>
		pkt += 18 /*strlen("File has bad magic")*/ + 1;
		len = pkt - xp;
57e2afa8:	e3a04017 	mov	r4, #23
		break;
57e2afac:	ea000000 	b	57e2afb4 <TftpSend+0x158>
static void
TftpSend(void)
{
	uchar *pkt;
	uchar *xp;
	int len = 0;
57e2afb0:	e3a04000 	mov	r4, #0
		pkt += 18 /*strlen("File has bad magic")*/ + 1;
		len = pkt - xp;
		break;
	}

	NetSendUDPPacket(NetServerEther, TftpRemoteIP, TftpRemotePort,
57e2afb4:	e59f301c 	ldr	r3, [pc, #28]	; 57e2afd8 <TftpSend+0x17c>
57e2afb8:	e58d4000 	str	r4, [sp]
57e2afbc:	e5931088 	ldr	r1, [r3, #136]	; 0x88
57e2afc0:	e593208c 	ldr	r2, [r3, #140]	; 0x8c
57e2afc4:	e59f0030 	ldr	r0, [pc, #48]	; 57e2affc <TftpSend+0x1a0>
57e2afc8:	e5933090 	ldr	r3, [r3, #144]	; 0x90
57e2afcc:	ebfff99d 	bl	57e29648 <NetSendUDPPacket>
			 TftpOurPort, len);
}
57e2afd0:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
57e2afd4:	57e79774 	.word	0x57e79774
57e2afd8:	57e7bfac 	.word	0x57e7bfac
57e2afdc:	57e7bfb0 	.word	0x57e7bfb0
57e2afe0:	57e35d50 	.word	0x57e35d50
57e2afe4:	57e37bd4 	.word	0x57e37bd4
57e2afe8:	57e35e32 	.word	0x57e35e32
57e2afec:	57e35403 	.word	0x57e35403
57e2aff0:	57e35d56 	.word	0x57e35d56
57e2aff4:	57e35d64 	.word	0x57e35d64
57e2aff8:	57e35d73 	.word	0x57e35d73
57e2affc:	57e7b6ec 	.word	0x57e7b6ec

57e2b000 <TftpTimeout>:
}


static void
TftpTimeout(void)
{
57e2b000:	e92d4070 	push	{r4, r5, r6, lr}
	if (++TftpTimeoutCount > TftpTimeoutCountMax) {
57e2b004:	e59f4054 	ldr	r4, [pc, #84]	; 57e2b060 <TftpTimeout+0x60>
57e2b008:	e59f5054 	ldr	r5, [pc, #84]	; 57e2b064 <TftpTimeout+0x64>
57e2b00c:	e5943094 	ldr	r3, [r4, #148]	; 0x94
57e2b010:	e5952008 	ldr	r2, [r5, #8]
57e2b014:	e2833001 	add	r3, r3, #1
57e2b018:	e1530002 	cmp	r3, r2
57e2b01c:	e5843094 	str	r3, [r4, #148]	; 0x94
57e2b020:	da000004 	ble	57e2b038 <TftpTimeout+0x38>
 *
 * @param msg	Message to print for user
 */
static void restart(const char *msg)
{
	printf("\n%s; starting again\n", msg);
57e2b024:	e59f103c 	ldr	r1, [pc, #60]	; 57e2b068 <TftpTimeout+0x68>
57e2b028:	e59f003c 	ldr	r0, [pc, #60]	; 57e2b06c <TftpTimeout+0x6c>
57e2b02c:	ebff7906 	bl	57e0944c <printf>
		puts("T ");
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
		if (TftpState != STATE_RECV_WRQ)
			TftpSend();
	}
}
57e2b030:	e8bd4070 	pop	{r4, r5, r6, lr}
{
	printf("\n%s; starting again\n", msg);
#ifdef CONFIG_MCAST_TFTP
	mcast_cleanup();
#endif
	NetStartAgain();
57e2b034:	eafff7c8 	b	57e28f5c <NetStartAgain>
TftpTimeout(void)
{
	if (++TftpTimeoutCount > TftpTimeoutCountMax) {
		restart("Retry count exceeded");
	} else {
		puts("T ");
57e2b038:	e59f0030 	ldr	r0, [pc, #48]	; 57e2b070 <TftpTimeout+0x70>
57e2b03c:	ebff78f8 	bl	57e09424 <puts>
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
57e2b040:	e5950000 	ldr	r0, [r5]
57e2b044:	e59f1028 	ldr	r1, [pc, #40]	; 57e2b074 <TftpTimeout+0x74>
57e2b048:	ebfff7b4 	bl	57e28f20 <NetSetTimeout>
		if (TftpState != STATE_RECV_WRQ)
57e2b04c:	e5943000 	ldr	r3, [r4]
57e2b050:	e3530006 	cmp	r3, #6
57e2b054:	08bd8070 	popeq	{r4, r5, r6, pc}
			TftpSend();
	}
}
57e2b058:	e8bd4070 	pop	{r4, r5, r6, lr}
		restart("Retry count exceeded");
	} else {
		puts("T ");
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
		if (TftpState != STATE_RECV_WRQ)
			TftpSend();
57e2b05c:	eaffff7e 	b	57e2ae5c <TftpSend>
57e2b060:	57e7bfac 	.word	0x57e7bfac
57e2b064:	57e37bd4 	.word	0x57e37bd4
57e2b068:	57e35d9b 	.word	0x57e35d9b
57e2b06c:	57e35d86 	.word	0x57e35d86
57e2b070:	57e35bd5 	.word	0x57e35bd5
57e2b074:	57e2b000 	.word	0x57e2b000

57e2b078 <TftpHandler>:
#endif

static void
TftpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	    unsigned len)
{
57e2b078:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
57e2b07c:	e1a06003 	mov	r6, r3
	ushort proto;
	ushort *s;
	int i;

	if (dest != TftpOurPort) {
57e2b080:	e59f3300 	ldr	r3, [pc, #768]	; 57e2b388 <TftpHandler+0x310>
#endif

static void
TftpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	    unsigned len)
{
57e2b084:	e1a04000 	mov	r4, r0
	ushort proto;
	ushort *s;
	int i;

	if (dest != TftpOurPort) {
57e2b088:	e5932090 	ldr	r2, [r3, #144]	; 0x90
#endif

static void
TftpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	    unsigned len)
{
57e2b08c:	e59d5018 	ldr	r5, [sp, #24]
	ushort proto;
	ushort *s;
	int i;

	if (dest != TftpOurPort) {
57e2b090:	e1510002 	cmp	r1, r2
57e2b094:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
		if (Multicast
		 && (!Mcast_port || (dest != Mcast_port)))
#endif
			return;
	}
	if (TftpState != STATE_SEND_RRQ && src != TftpRemotePort &&
57e2b098:	e5932000 	ldr	r2, [r3]
57e2b09c:	e3520001 	cmp	r2, #1
57e2b0a0:	0a000006 	beq	57e2b0c0 <TftpHandler+0x48>
57e2b0a4:	e593308c 	ldr	r3, [r3, #140]	; 0x8c
57e2b0a8:	e1560003 	cmp	r6, r3
57e2b0ac:	0a000003 	beq	57e2b0c0 <TftpHandler+0x48>
57e2b0b0:	e3520006 	cmp	r2, #6
57e2b0b4:	0a000001 	beq	57e2b0c0 <TftpHandler+0x48>
	    TftpState != STATE_RECV_WRQ && TftpState != STATE_SEND_WRQ)
57e2b0b8:	e3520007 	cmp	r2, #7
57e2b0bc:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
		return;

	if (len < 2)
57e2b0c0:	e3550001 	cmp	r5, #1
57e2b0c4:	98bd81f0 	popls	{r4, r5, r6, r7, r8, pc}
		return;
	len -= 2;
	/* warning: don't use increment (++) in ntohs() macros!! */
	s = (ushort *)pkt;
	proto = *s++;
57e2b0c8:	e1a07004 	mov	r7, r4
57e2b0cc:	e0d730b2 	ldrh	r3, [r7], #2
	    TftpState != STATE_RECV_WRQ && TftpState != STATE_SEND_WRQ)
		return;

	if (len < 2)
		return;
	len -= 2;
57e2b0d0:	e2455002 	sub	r5, r5, #2
57e2b0d4:	e1a02423 	lsr	r2, r3, #8
57e2b0d8:	e1823403 	orr	r3, r2, r3, lsl #8
	/* warning: don't use increment (++) in ntohs() macros!! */
	s = (ushort *)pkt;
	proto = *s++;
	pkt = (uchar *)s;
	switch (ntohs(proto)) {
57e2b0dc:	e1a03803 	lsl	r3, r3, #16
57e2b0e0:	e1a03823 	lsr	r3, r3, #16
57e2b0e4:	e3530005 	cmp	r3, #5
57e2b0e8:	0a00008b 	beq	57e2b31c <TftpHandler+0x2a4>
57e2b0ec:	e3530006 	cmp	r3, #6
57e2b0f0:	0a000002 	beq	57e2b100 <TftpHandler+0x88>
57e2b0f4:	e3530003 	cmp	r3, #3
57e2b0f8:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
57e2b0fc:	ea000016 	b	57e2b15c <TftpHandler+0xe4>

	case TFTP_OACK:
		debug("Got OACK: %s %s\n",
			pkt,
			pkt + strlen((char *)pkt) + 1);
		TftpState = STATE_OACK;
57e2b100:	e59f3280 	ldr	r3, [pc, #640]	; 57e2b388 <TftpHandler+0x310>
57e2b104:	e3a02005 	mov	r2, #5
		TftpRemotePort = src;
57e2b108:	e583608c 	str	r6, [r3, #140]	; 0x8c
	}
}
#endif

static void
TftpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
57e2b10c:	e1a04007 	mov	r4, r7

	case TFTP_OACK:
		debug("Got OACK: %s %s\n",
			pkt,
			pkt + strlen((char *)pkt) + 1);
		TftpState = STATE_OACK;
57e2b110:	e5832000 	str	r2, [r3]
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i = 0; i+8 < len; i++) {
57e2b114:	e3a06008 	mov	r6, #8
			if (strcmp((char *)pkt+i, "blksize") == 0) {
				TftpBlkSize = (unsigned short)
57e2b118:	e59f726c 	ldr	r7, [pc, #620]	; 57e2b38c <TftpHandler+0x314>
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i = 0; i+8 < len; i++) {
57e2b11c:	ea00000a 	b	57e2b14c <TftpHandler+0xd4>
			if (strcmp((char *)pkt+i, "blksize") == 0) {
57e2b120:	e59f1268 	ldr	r1, [pc, #616]	; 57e2b390 <TftpHandler+0x318>
57e2b124:	e1a00004 	mov	r0, r4
57e2b128:	ebffe39d 	bl	57e23fa4 <strcmp>
57e2b12c:	e2501000 	subs	r1, r0, #0
57e2b130:	1a000003 	bne	57e2b144 <TftpHandler+0xcc>
				TftpBlkSize = (unsigned short)
					simple_strtoul((char *)pkt+i+8, NULL,
57e2b134:	e2840008 	add	r0, r4, #8
57e2b138:	e3a0200a 	mov	r2, #10
57e2b13c:	ebffe7d8 	bl	57e250a4 <simple_strtoul>
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i = 0; i+8 < len; i++) {
			if (strcmp((char *)pkt+i, "blksize") == 0) {
				TftpBlkSize = (unsigned short)
57e2b140:	e1c700bc 	strh	r0, [r7, #12]
57e2b144:	e2866001 	add	r6, r6, #1
57e2b148:	e2844001 	add	r4, r4, #1
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i = 0; i+8 < len; i++) {
57e2b14c:	e1560005 	cmp	r6, r5
57e2b150:	3afffff2 	bcc	57e2b120 <TftpHandler+0xa8>
			NetStartAgain();
			break;
		}
		break;
	}
}
57e2b154:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
			/* Get ready to send the first block */
			TftpState = STATE_DATA;
			TftpBlock++;
		}
#endif
		TftpSend(); /* Send ACK or first data block */
57e2b158:	eaffff3f 	b	57e2ae5c <TftpSend>
		break;
	case TFTP_DATA:
		if (len < 2)
57e2b15c:	e3550001 	cmp	r5, #1
57e2b160:	98bd81f0 	popls	{r4, r5, r6, r7, r8, pc}
			return;
		len -= 2;
		TftpBlock = ntohs(*(ushort *)pkt);
57e2b164:	e1d430b2 	ldrh	r3, [r4, #2]
57e2b168:	e1a04423 	lsr	r4, r3, #8
57e2b16c:	e1844403 	orr	r4, r4, r3, lsl #8
57e2b170:	e1a04804 	lsl	r4, r4, #16
57e2b174:	e1a04824 	lsr	r4, r4, #16
57e2b178:	e59f3208 	ldr	r3, [pc, #520]	; 57e2b388 <TftpHandler+0x310>
	 * RFC1350 specifies that the first data packet will
	 * have sequence number 1. If we receive a sequence
	 * number of 0 this means that there was a wrap
	 * around of the (16 bit) counter.
	 */
	if (TftpBlock == 0) {
57e2b17c:	e3540000 	cmp	r4, #0
		break;
	case TFTP_DATA:
		if (len < 2)
			return;
		len -= 2;
		TftpBlock = ntohs(*(ushort *)pkt);
57e2b180:	e5834084 	str	r4, [r3, #132]	; 0x84
	 * RFC1350 specifies that the first data packet will
	 * have sequence number 1. If we receive a sequence
	 * number of 0 this means that there was a wrap
	 * around of the (16 bit) counter.
	 */
	if (TftpBlock == 0) {
57e2b184:	1a000009 	bne	57e2b1b0 <TftpHandler+0x138>
		TftpBlockWrap++;
57e2b188:	e5932098 	ldr	r2, [r3, #152]	; 0x98
		TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
		TftpTimeoutCount = 0; /* we've done well, reset thhe timeout */
57e2b18c:	e5834094 	str	r4, [r3, #148]	; 0x94
	 * have sequence number 1. If we receive a sequence
	 * number of 0 this means that there was a wrap
	 * around of the (16 bit) counter.
	 */
	if (TftpBlock == 0) {
		TftpBlockWrap++;
57e2b190:	e2822001 	add	r2, r2, #1
57e2b194:	e5832098 	str	r2, [r3, #152]	; 0x98
		TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
57e2b198:	e59f21ec 	ldr	r2, [pc, #492]	; 57e2b38c <TftpHandler+0x314>
57e2b19c:	e1d210bc 	ldrh	r1, [r2, #12]
57e2b1a0:	e593209c 	ldr	r2, [r3, #156]	; 0x9c
57e2b1a4:	e0822801 	add	r2, r2, r1, lsl #16
57e2b1a8:	e583209c 	str	r2, [r3, #156]	; 0x9c
57e2b1ac:	ea00000e 	b	57e2b1ec <TftpHandler+0x174>
			TftpNumchars++;
		}
	} else
#endif
	{
		if (((TftpBlock - 1) % 10) == 0)
57e2b1b0:	e2440001 	sub	r0, r4, #1
57e2b1b4:	e3a0100a 	mov	r1, #10
57e2b1b8:	eb0001f7 	bl	57e2b99c <__aeabi_uidivmod>
57e2b1bc:	e3510000 	cmp	r1, #0
57e2b1c0:	1a000002 	bne	57e2b1d0 <TftpHandler+0x158>
			putc('#');
57e2b1c4:	e3a00023 	mov	r0, #35	; 0x23
57e2b1c8:	ebff788b 	bl	57e093fc <putc>
57e2b1cc:	ea000006 	b	57e2b1ec <TftpHandler+0x174>
		else if ((TftpBlock % (10 * HASHES_PER_LINE)) == 0)
57e2b1d0:	e1a00004 	mov	r0, r4
57e2b1d4:	e59f11b8 	ldr	r1, [pc, #440]	; 57e2b394 <TftpHandler+0x31c>
57e2b1d8:	eb0001ef 	bl	57e2b99c <__aeabi_uidivmod>
57e2b1dc:	e3510000 	cmp	r1, #0
57e2b1e0:	1a000001 	bne	57e2b1ec <TftpHandler+0x174>
			puts("\n\t ");
57e2b1e4:	e59f01ac 	ldr	r0, [pc, #428]	; 57e2b398 <TftpHandler+0x320>
57e2b1e8:	ebff788d 	bl	57e09424 <puts>
		update_block_number();

		if (TftpState == STATE_SEND_RRQ)
			debug("Server did not acknowledge timeout option!\n");

		if (TftpState == STATE_SEND_RRQ || TftpState == STATE_OACK ||
57e2b1ec:	e59f3194 	ldr	r3, [pc, #404]	; 57e2b388 <TftpHandler+0x310>
57e2b1f0:	e5933000 	ldr	r3, [r3]
57e2b1f4:	e3530001 	cmp	r3, #1
57e2b1f8:	13530005 	cmpne	r3, #5
57e2b1fc:	0a000001 	beq	57e2b208 <TftpHandler+0x190>
57e2b200:	e3530006 	cmp	r3, #6
57e2b204:	1a00000d 	bne	57e2b240 <TftpHandler+0x1c8>
		    TftpState == STATE_RECV_WRQ) {
			/* first block received */
			TftpState = STATE_DATA;
57e2b208:	e59f3178 	ldr	r3, [pc, #376]	; 57e2b388 <TftpHandler+0x310>
57e2b20c:	e3a02002 	mov	r2, #2
#ifdef CONFIG_MCAST_TFTP
			if (Multicast) { /* start!=1 common if mcast */
				TftpLastBlock = TftpBlock - 1;
			} else
#endif
			if (TftpBlock != 1) {	/* Assertion */
57e2b210:	e5931084 	ldr	r1, [r3, #132]	; 0x84
			debug("Server did not acknowledge timeout option!\n");

		if (TftpState == STATE_SEND_RRQ || TftpState == STATE_OACK ||
		    TftpState == STATE_RECV_WRQ) {
			/* first block received */
			TftpState = STATE_DATA;
57e2b214:	e5832000 	str	r2, [r3]
#ifdef CONFIG_MCAST_TFTP
			if (Multicast) { /* start!=1 common if mcast */
				TftpLastBlock = TftpBlock - 1;
			} else
#endif
			if (TftpBlock != 1) {	/* Assertion */
57e2b218:	e3510001 	cmp	r1, #1
}

/* Clear our state ready for a new transfer */
static void new_transfer(void)
{
	TftpLastBlock = 0;
57e2b21c:	e3a02000 	mov	r2, #0

		if (TftpState == STATE_SEND_RRQ || TftpState == STATE_OACK ||
		    TftpState == STATE_RECV_WRQ) {
			/* first block received */
			TftpState = STATE_DATA;
			TftpRemotePort = src;
57e2b220:	e583608c 	str	r6, [r3, #140]	; 0x8c
}

/* Clear our state ready for a new transfer */
static void new_transfer(void)
{
	TftpLastBlock = 0;
57e2b224:	e58320a0 	str	r2, [r3, #160]	; 0xa0
	TftpBlockWrap = 0;
57e2b228:	e5832098 	str	r2, [r3, #152]	; 0x98
	TftpBlockWrapOffset = 0;
57e2b22c:	e583209c 	str	r2, [r3, #156]	; 0x9c
#ifdef CONFIG_MCAST_TFTP
			if (Multicast) { /* start!=1 common if mcast */
				TftpLastBlock = TftpBlock - 1;
			} else
#endif
			if (TftpBlock != 1) {	/* Assertion */
57e2b230:	0a000002 	beq	57e2b240 <TftpHandler+0x1c8>
				printf("\nTFTP error: "
57e2b234:	e59f0160 	ldr	r0, [pc, #352]	; 57e2b39c <TftpHandler+0x324>
57e2b238:	ebff7883 	bl	57e0944c <printf>
57e2b23c:	ea00004f 	b	57e2b380 <TftpHandler+0x308>
				NetStartAgain();
				break;
			}
		}

		if (TftpBlock == TftpLastBlock) {
57e2b240:	e59f4140 	ldr	r4, [pc, #320]	; 57e2b388 <TftpHandler+0x310>
57e2b244:	e5943084 	ldr	r3, [r4, #132]	; 0x84
57e2b248:	e59420a0 	ldr	r2, [r4, #160]	; 0xa0
57e2b24c:	e1530002 	cmp	r3, r2
57e2b250:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
			 */
			break;
		}

		TftpLastBlock = TftpBlock;
		TftpTimeoutCountMax = TIMEOUT_COUNT;
57e2b254:	e59f6130 	ldr	r6, [pc, #304]	; 57e2b38c <TftpHandler+0x314>
			 *	Same block again; ignore it.
			 */
			break;
		}

		TftpLastBlock = TftpBlock;
57e2b258:	e58430a0 	str	r3, [r4, #160]	; 0xa0
		TftpTimeoutCountMax = TIMEOUT_COUNT;
57e2b25c:	e3a0300a 	mov	r3, #10
57e2b260:	e5863008 	str	r3, [r6, #8]
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
57e2b264:	e5960000 	ldr	r0, [r6]
57e2b268:	e59f1130 	ldr	r1, [pc, #304]	; 57e2b3a0 <TftpHandler+0x328>
57e2b26c:	ebfff72b 	bl	57e28f20 <NetSetTimeout>

		store_block(TftpBlock - 1, pkt + 2, len);
57e2b270:	e5943084 	ldr	r3, [r4, #132]	; 0x84
#endif	/* CONFIG_MCAST_TFTP */

static inline void
store_block(int block, uchar *src, unsigned len)
{
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
57e2b274:	e1d610bc 	ldrh	r1, [r6, #12]
57e2b278:	e594209c 	ldr	r2, [r4, #156]	; 0x9c

		TftpLastBlock = TftpBlock;
		TftpTimeoutCountMax = TIMEOUT_COUNT;
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);

		store_block(TftpBlock - 1, pkt + 2, len);
57e2b27c:	e2433001 	sub	r3, r3, #1
#endif	/* CONFIG_MCAST_TFTP */

static inline void
store_block(int block, uchar *src, unsigned len)
{
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
57e2b280:	e0232391 	mla	r3, r1, r3, r2
			return;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_TFTP */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
57e2b284:	e59f2118 	ldr	r2, [pc, #280]	; 57e2b3a4 <TftpHandler+0x32c>
		TftpSend(); /* Send ACK or first data block */
		break;
	case TFTP_DATA:
		if (len < 2)
			return;
		len -= 2;
57e2b288:	e2455002 	sub	r5, r5, #2
			return;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_TFTP */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
57e2b28c:	e5920000 	ldr	r0, [r2]
57e2b290:	e2871002 	add	r1, r7, #2
57e2b294:	e0830000 	add	r0, r3, r0
57e2b298:	e1a02005 	mov	r2, r5

static inline void
store_block(int block, uchar *src, unsigned len)
{
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
	ulong newsize = offset + len;
57e2b29c:	e0856003 	add	r6, r5, r3
			return;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_TFTP */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
57e2b2a0:	ebffe419 	bl	57e2430c <memcpy>
#ifdef CONFIG_MCAST_TFTP
	if (Multicast)
		ext2_set_bit(block, Bitmap);
#endif

	if (NetBootFileXferSize < newsize)
57e2b2a4:	e59f30fc 	ldr	r3, [pc, #252]	; 57e2b3a8 <TftpHandler+0x330>
57e2b2a8:	e5932000 	ldr	r2, [r3]
57e2b2ac:	e1520006 	cmp	r2, r6
		NetBootFileXferSize = newsize;
57e2b2b0:	35836000 	strcc	r6, [r3]
				}
				TftpLastBlock = TftpBlock;
			}
		}
#endif
		TftpSend();
57e2b2b4:	ebfffee8 	bl	57e2ae5c <TftpSend>
				mcast_cleanup();
				net_set_state(NETLOOP_SUCCESS);
			}
		} else
#endif
		if (len < TftpBlkSize)
57e2b2b8:	e59f30cc 	ldr	r3, [pc, #204]	; 57e2b38c <TftpHandler+0x314>
57e2b2bc:	e1d330bc 	ldrh	r3, [r3, #12]
57e2b2c0:	e1550003 	cmp	r5, r3
57e2b2c4:	28bd81f0 	popcs	{r4, r5, r6, r7, r8, pc}
	while (TftpTsize && TftpNumchars < 49) {
		putc('#');
		TftpNumchars++;
	}
#endif
	time_start = get_timer(time_start);
57e2b2c8:	e59f40b8 	ldr	r4, [pc, #184]	; 57e2b388 <TftpHandler+0x310>
57e2b2cc:	e59400a4 	ldr	r0, [r4, #164]	; 0xa4
57e2b2d0:	ebff560d 	bl	57e00b0c <get_timer>
	if (time_start > 0) {
57e2b2d4:	e3500000 	cmp	r0, #0
	while (TftpTsize && TftpNumchars < 49) {
		putc('#');
		TftpNumchars++;
	}
#endif
	time_start = get_timer(time_start);
57e2b2d8:	e58400a4 	str	r0, [r4, #164]	; 0xa4
	if (time_start > 0) {
57e2b2dc:	0a00000a 	beq	57e2b30c <TftpHandler+0x294>
		puts("\n\t ");	/* Line up with "Loading: " */
57e2b2e0:	e59f00b0 	ldr	r0, [pc, #176]	; 57e2b398 <TftpHandler+0x320>
57e2b2e4:	ebff784e 	bl	57e09424 <puts>
		print_size(NetBootFileXferSize /
57e2b2e8:	e59f30b8 	ldr	r3, [pc, #184]	; 57e2b3a8 <TftpHandler+0x330>
57e2b2ec:	e59410a4 	ldr	r1, [r4, #164]	; 0xa4
57e2b2f0:	e5930000 	ldr	r0, [r3]
57e2b2f4:	eb00012d 	bl	57e2b7b0 <__udivsi3>
57e2b2f8:	e3a03ffa 	mov	r3, #1000	; 0x3e8
57e2b2fc:	e0000093 	mul	r0, r3, r0
57e2b300:	e3a01000 	mov	r1, #0
57e2b304:	e59f20a0 	ldr	r2, [pc, #160]	; 57e2b3ac <TftpHandler+0x334>
57e2b308:	ebffdbd8 	bl	57e22270 <print_size>
			time_start * 1000, "/s");
	}
	puts("\ndone\n");
57e2b30c:	e59f009c 	ldr	r0, [pc, #156]	; 57e2b3b0 <TftpHandler+0x338>
57e2b310:	ebff7843 	bl	57e09424 <puts>
extern enum net_loop_state net_state;

static inline void net_set_state(enum net_loop_state state)
{
	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
57e2b314:	e3a02002 	mov	r2, #2
57e2b318:	ea000013 	b	57e2b36c <TftpHandler+0x2f4>
			tftp_complete();
		break;

	case TFTP_ERROR:
		printf("\nTFTP error: '%s' (%d)\n",
		       pkt + 2, ntohs(*(ushort *)pkt));
57e2b31c:	e1d430b2 	ldrh	r3, [r4, #2]
		if (len < TftpBlkSize)
			tftp_complete();
		break;

	case TFTP_ERROR:
		printf("\nTFTP error: '%s' (%d)\n",
57e2b320:	e59f008c 	ldr	r0, [pc, #140]	; 57e2b3b4 <TftpHandler+0x33c>
57e2b324:	e1a02423 	lsr	r2, r3, #8
57e2b328:	e1822403 	orr	r2, r2, r3, lsl #8
57e2b32c:	e1a02802 	lsl	r2, r2, #16
57e2b330:	e1a02822 	lsr	r2, r2, #16
57e2b334:	e2871002 	add	r1, r7, #2
57e2b338:	ebff7843 	bl	57e0944c <printf>
		       pkt + 2, ntohs(*(ushort *)pkt));

		switch (ntohs(*(ushort *)pkt)) {
57e2b33c:	e1d430b2 	ldrh	r3, [r4, #2]
57e2b340:	e1a02423 	lsr	r2, r3, #8
57e2b344:	e1823403 	orr	r3, r2, r3, lsl #8
57e2b348:	e1a03803 	lsl	r3, r3, #16
57e2b34c:	e1a03823 	lsr	r3, r3, #16
57e2b350:	e2433001 	sub	r3, r3, #1
57e2b354:	e3530001 	cmp	r3, #1
57e2b358:	8a000006 	bhi	57e2b378 <TftpHandler+0x300>
		case TFTP_ERR_FILE_NOT_FOUND:
		case TFTP_ERR_ACCESS_DENIED:
			puts("Not retrying...\n");
57e2b35c:	e59f0054 	ldr	r0, [pc, #84]	; 57e2b3b8 <TftpHandler+0x340>
57e2b360:	ebff782f 	bl	57e09424 <puts>
			eth_halt();
57e2b364:	ebfff614 	bl	57e28bbc <eth_halt>
57e2b368:	e3a02003 	mov	r2, #3
57e2b36c:	e59f3048 	ldr	r3, [pc, #72]	; 57e2b3bc <TftpHandler+0x344>
57e2b370:	e5832000 	str	r2, [r3]
57e2b374:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		case TFTP_ERR_DISK_FULL:
		case TFTP_ERR_UNEXPECTED_OPCODE:
		case TFTP_ERR_UNKNOWN_TRANSFER_ID:
		case TFTP_ERR_FILE_ALREADY_EXISTS:
		default:
			puts("Starting again\n\n");
57e2b378:	e59f0040 	ldr	r0, [pc, #64]	; 57e2b3c0 <TftpHandler+0x348>
57e2b37c:	ebff7828 	bl	57e09424 <puts>
			NetStartAgain();
			break;
		}
		break;
	}
}
57e2b380:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
		default:
			puts("Starting again\n\n");
#ifdef CONFIG_MCAST_TFTP
			mcast_cleanup();
#endif
			NetStartAgain();
57e2b384:	eafff6f4 	b	57e28f5c <NetStartAgain>
57e2b388:	57e7bfac 	.word	0x57e7bfac
57e2b38c:	57e37bd4 	.word	0x57e37bd4
57e2b390:	57e35db0 	.word	0x57e35db0
57e2b394:	0000028a 	.word	0x0000028a
57e2b398:	57e35c48 	.word	0x57e35c48
57e2b39c:	57e35db8 	.word	0x57e35db8
57e2b3a0:	57e2b000 	.word	0x57e2b000
57e2b3a4:	57e36e60 	.word	0x57e36e60
57e2b3a8:	57e7b660 	.word	0x57e7b660
57e2b3ac:	57e31548 	.word	0x57e31548
57e2b3b0:	57e35bf1 	.word	0x57e35bf1
57e2b3b4:	57e35df7 	.word	0x57e35df7
57e2b3b8:	57e35e0f 	.word	0x57e35e0f
57e2b3bc:	57e79734 	.word	0x57e79734
57e2b3c0:	57e35de6 	.word	0x57e35de6

57e2b3c4 <TftpStart>:
	}
}


void TftpStart(enum proto_t protocol)
{
57e2b3c4:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}

	/*
	 * Allow the user to choose TFTP blocksize and timeout.
	 * TFTP protocol has a minimal timeout of 1 second.
	 */
	ep = getenv("tftpblocksize");
57e2b3c8:	e59f027c 	ldr	r0, [pc, #636]	; 57e2b64c <TftpStart+0x288>
57e2b3cc:	ebff70c5 	bl	57e076e8 <getenv>
	if (ep != NULL)
57e2b3d0:	e3500000 	cmp	r0, #0
57e2b3d4:	0a000004 	beq	57e2b3ec <TftpStart+0x28>
		TftpBlkSizeOption = simple_strtol(ep, NULL, 10);
57e2b3d8:	e3a01000 	mov	r1, #0
57e2b3dc:	e3a0200a 	mov	r2, #10
57e2b3e0:	ebffe778 	bl	57e251c8 <simple_strtol>
57e2b3e4:	e59f3264 	ldr	r3, [pc, #612]	; 57e2b650 <TftpStart+0x28c>
57e2b3e8:	e1c300b4 	strh	r0, [r3, #4]

	ep = getenv("tftptimeout");
57e2b3ec:	e59f0260 	ldr	r0, [pc, #608]	; 57e2b654 <TftpStart+0x290>
57e2b3f0:	ebff70bc 	bl	57e076e8 <getenv>
	if (ep != NULL)
57e2b3f4:	e3500000 	cmp	r0, #0
57e2b3f8:	0a000004 	beq	57e2b410 <TftpStart+0x4c>
		TftpTimeoutMSecs = simple_strtol(ep, NULL, 10);
57e2b3fc:	e3a01000 	mov	r1, #0
57e2b400:	e3a0200a 	mov	r2, #10
57e2b404:	ebffe76f 	bl	57e251c8 <simple_strtol>
57e2b408:	e59f3240 	ldr	r3, [pc, #576]	; 57e2b650 <TftpStart+0x28c>
57e2b40c:	e5830000 	str	r0, [r3]

	if (TftpTimeoutMSecs < 1000) {
57e2b410:	e59f4238 	ldr	r4, [pc, #568]	; 57e2b650 <TftpStart+0x28c>
57e2b414:	e5941000 	ldr	r1, [r4]
57e2b418:	e3510ffa 	cmp	r1, #1000	; 0x3e8
57e2b41c:	2a000003 	bcs	57e2b430 <TftpStart+0x6c>
		printf("TFTP timeout (%ld ms) too low, "
57e2b420:	e59f0230 	ldr	r0, [pc, #560]	; 57e2b658 <TftpStart+0x294>
57e2b424:	ebff7808 	bl	57e0944c <printf>
			"set minimum = 1000 ms\n",
			TftpTimeoutMSecs);
		TftpTimeoutMSecs = 1000;
57e2b428:	e3a03ffa 	mov	r3, #1000	; 0x3e8
57e2b42c:	e5843000 	str	r3, [r4]

	debug("TFTP blocksize = %i, timeout = %ld ms\n",
		TftpBlkSizeOption, TftpTimeoutMSecs);

	TftpRemoteIP = NetServerIP;
	if (BootFile[0] == '\0') {
57e2b430:	e59f6224 	ldr	r6, [pc, #548]	; 57e2b65c <TftpStart+0x298>
	}

	debug("TFTP blocksize = %i, timeout = %ld ms\n",
		TftpBlkSizeOption, TftpTimeoutMSecs);

	TftpRemoteIP = NetServerIP;
57e2b434:	e59f3224 	ldr	r3, [pc, #548]	; 57e2b660 <TftpStart+0x29c>
	if (BootFile[0] == '\0') {
57e2b438:	e5d65000 	ldrb	r5, [r6]
	}

	debug("TFTP blocksize = %i, timeout = %ld ms\n",
		TftpBlkSizeOption, TftpTimeoutMSecs);

	TftpRemoteIP = NetServerIP;
57e2b43c:	e59f4220 	ldr	r4, [pc, #544]	; 57e2b664 <TftpStart+0x2a0>
57e2b440:	e5933000 	ldr	r3, [r3]
	if (BootFile[0] == '\0') {
57e2b444:	e3550000 	cmp	r5, #0
	}

	debug("TFTP blocksize = %i, timeout = %ld ms\n",
		TftpBlkSizeOption, TftpTimeoutMSecs);

	TftpRemoteIP = NetServerIP;
57e2b448:	e5843088 	str	r3, [r4, #136]	; 0x88
	if (BootFile[0] == '\0') {
57e2b44c:	1a000014 	bne	57e2b4a4 <TftpStart+0xe0>
		sprintf(default_filename, "%02X%02X%02X%02X.img",
57e2b450:	e59f3210 	ldr	r3, [pc, #528]	; 57e2b668 <TftpStart+0x2a4>
57e2b454:	e5931000 	ldr	r1, [r3]
			NetOurIP & 0xFF,
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
57e2b458:	e1a00821 	lsr	r0, r1, #16
	debug("TFTP blocksize = %i, timeout = %ld ms\n",
		TftpBlkSizeOption, TftpTimeoutMSecs);

	TftpRemoteIP = NetServerIP;
	if (BootFile[0] == '\0') {
		sprintf(default_filename, "%02X%02X%02X%02X.img",
57e2b45c:	e20120ff 	and	r2, r1, #255	; 0xff
57e2b460:	e1a03421 	lsr	r3, r1, #8
57e2b464:	e20000ff 	and	r0, r0, #255	; 0xff
57e2b468:	e1a01c21 	lsr	r1, r1, #24
57e2b46c:	e88d0003 	stm	sp, {r0, r1}
57e2b470:	e20330ff 	and	r3, r3, #255	; 0xff
57e2b474:	e28400a8 	add	r0, r4, #168	; 0xa8
57e2b478:	e59f11ec 	ldr	r1, [pc, #492]	; 57e2b66c <TftpStart+0x2a8>
57e2b47c:	ebffe7b1 	bl	57e25348 <sprintf>
			NetOurIP & 0xFF,
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
			(NetOurIP >> 24) & 0xFF);

		strncpy(tftp_filename, default_filename, MAX_LEN);
57e2b480:	e28410a8 	add	r1, r4, #168	; 0xa8
57e2b484:	e2840004 	add	r0, r4, #4
57e2b488:	e3a02080 	mov	r2, #128	; 0x80
57e2b48c:	ebffe29a 	bl	57e23efc <strncpy>
		tftp_filename[MAX_LEN-1] = 0;
57e2b490:	e5c45083 	strb	r5, [r4, #131]	; 0x83

		printf("*** Warning: no boot file name; using '%s'\n",
57e2b494:	e2841004 	add	r1, r4, #4
57e2b498:	e59f01d0 	ldr	r0, [pc, #464]	; 57e2b670 <TftpStart+0x2ac>
57e2b49c:	ebff77ea 	bl	57e0944c <printf>
57e2b4a0:	ea000013 	b	57e2b4f4 <TftpStart+0x130>
			tftp_filename);
	} else {
		char *p = strchr(BootFile, ':');
57e2b4a4:	e1a00006 	mov	r0, r6
57e2b4a8:	e3a0103a 	mov	r1, #58	; 0x3a
57e2b4ac:	ebffe2da 	bl	57e2401c <strchr>

		if (p == NULL) {
57e2b4b0:	e2505000 	subs	r5, r0, #0
57e2b4b4:	1a000005 	bne	57e2b4d0 <TftpStart+0x10c>
			strncpy(tftp_filename, BootFile, MAX_LEN);
57e2b4b8:	e2840004 	add	r0, r4, #4
57e2b4bc:	e1a01006 	mov	r1, r6
57e2b4c0:	e3a02080 	mov	r2, #128	; 0x80
57e2b4c4:	ebffe28c 	bl	57e23efc <strncpy>
			tftp_filename[MAX_LEN-1] = 0;
57e2b4c8:	e5c45083 	strb	r5, [r4, #131]	; 0x83
57e2b4cc:	ea000008 	b	57e2b4f4 <TftpStart+0x130>
		} else {
			TftpRemoteIP = string_to_ip(BootFile);
57e2b4d0:	e1a00006 	mov	r0, r6
57e2b4d4:	ebffe203 	bl	57e23ce8 <string_to_ip>
			strncpy(tftp_filename, p + 1, MAX_LEN);
57e2b4d8:	e2851001 	add	r1, r5, #1

		if (p == NULL) {
			strncpy(tftp_filename, BootFile, MAX_LEN);
			tftp_filename[MAX_LEN-1] = 0;
		} else {
			TftpRemoteIP = string_to_ip(BootFile);
57e2b4dc:	e5840088 	str	r0, [r4, #136]	; 0x88
			strncpy(tftp_filename, p + 1, MAX_LEN);
57e2b4e0:	e3a02080 	mov	r2, #128	; 0x80
57e2b4e4:	e2840004 	add	r0, r4, #4
57e2b4e8:	ebffe283 	bl	57e23efc <strncpy>
			tftp_filename[MAX_LEN-1] = 0;
57e2b4ec:	e3a03000 	mov	r3, #0
57e2b4f0:	e5c43083 	strb	r3, [r4, #131]	; 0x83
		}
	}

	printf("Using %s device\n", eth_get_name());
57e2b4f4:	ebfff64a 	bl	57e28e24 <eth_get_name>
	printf("TFTP %s server %pI4; our IP address is %pI4",
57e2b4f8:	e59f4164 	ldr	r4, [pc, #356]	; 57e2b664 <TftpStart+0x2a0>
57e2b4fc:	e59f5164 	ldr	r5, [pc, #356]	; 57e2b668 <TftpStart+0x2a4>
			strncpy(tftp_filename, p + 1, MAX_LEN);
			tftp_filename[MAX_LEN-1] = 0;
		}
	}

	printf("Using %s device\n", eth_get_name());
57e2b500:	e1a01000 	mov	r1, r0
57e2b504:	e59f0168 	ldr	r0, [pc, #360]	; 57e2b674 <TftpStart+0x2b0>
57e2b508:	ebff77cf 	bl	57e0944c <printf>
	printf("TFTP %s server %pI4; our IP address is %pI4",
57e2b50c:	e59f1164 	ldr	r1, [pc, #356]	; 57e2b678 <TftpStart+0x2b4>
57e2b510:	e1a03005 	mov	r3, r5
57e2b514:	e59f0160 	ldr	r0, [pc, #352]	; 57e2b67c <TftpStart+0x2b8>
57e2b518:	e2842088 	add	r2, r4, #136	; 0x88
57e2b51c:	ebff77ca 	bl	57e0944c <printf>
		"from",
#endif
		&TftpRemoteIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
57e2b520:	e59f1158 	ldr	r1, [pc, #344]	; 57e2b680 <TftpStart+0x2bc>
57e2b524:	e5913000 	ldr	r3, [r1]
57e2b528:	e3530000 	cmp	r3, #0
57e2b52c:	0a00000b 	beq	57e2b560 <TftpStart+0x19c>
57e2b530:	e59f314c 	ldr	r3, [pc, #332]	; 57e2b684 <TftpStart+0x2c0>
57e2b534:	e5933000 	ldr	r3, [r3]
57e2b538:	e3530000 	cmp	r3, #0
57e2b53c:	0a000007 	beq	57e2b560 <TftpStart+0x19c>
		IPaddr_t OurNet	= NetOurIP    & NetOurSubnetMask;
57e2b540:	e5952000 	ldr	r2, [r5]
		IPaddr_t RemoteNet	= TftpRemoteIP & NetOurSubnetMask;
57e2b544:	e5940088 	ldr	r0, [r4, #136]	; 0x88
#endif
		&TftpRemoteIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
		IPaddr_t OurNet	= NetOurIP    & NetOurSubnetMask;
57e2b548:	e0032002 	and	r2, r3, r2
		IPaddr_t RemoteNet	= TftpRemoteIP & NetOurSubnetMask;
57e2b54c:	e0033000 	and	r3, r3, r0

		if (OurNet != RemoteNet)
57e2b550:	e1520003 	cmp	r2, r3
57e2b554:	0a000001 	beq	57e2b560 <TftpStart+0x19c>
			printf("; sending through gateway %pI4",
57e2b558:	e59f0128 	ldr	r0, [pc, #296]	; 57e2b688 <TftpStart+0x2c4>
57e2b55c:	ebff77ba 	bl	57e0944c <printf>
			       &NetOurGatewayIP);
	}
	putc('\n');
57e2b560:	e3a0000a 	mov	r0, #10

	printf("Filename '%s'.", tftp_filename);

	if (NetBootFileSize) {
57e2b564:	e59f4120 	ldr	r4, [pc, #288]	; 57e2b68c <TftpStart+0x2c8>

		if (OurNet != RemoteNet)
			printf("; sending through gateway %pI4",
			       &NetOurGatewayIP);
	}
	putc('\n');
57e2b568:	ebff77a3 	bl	57e093fc <putc>

	printf("Filename '%s'.", tftp_filename);
57e2b56c:	e59f111c 	ldr	r1, [pc, #284]	; 57e2b690 <TftpStart+0x2cc>
57e2b570:	e59f011c 	ldr	r0, [pc, #284]	; 57e2b694 <TftpStart+0x2d0>
57e2b574:	ebff77b4 	bl	57e0944c <printf>

	if (NetBootFileSize) {
57e2b578:	e1d410b0 	ldrh	r1, [r4]
57e2b57c:	e3510000 	cmp	r1, #0
57e2b580:	0a000007 	beq	57e2b5a4 <TftpStart+0x1e0>
		printf(" Size is 0x%x Bytes = ", NetBootFileSize<<9);
57e2b584:	e1a01481 	lsl	r1, r1, #9
57e2b588:	e59f0108 	ldr	r0, [pc, #264]	; 57e2b698 <TftpStart+0x2d4>
57e2b58c:	ebff77ae 	bl	57e0944c <printf>
		print_size(NetBootFileSize<<9, "");
57e2b590:	e1d400b0 	ldrh	r0, [r4]
57e2b594:	e59f2100 	ldr	r2, [pc, #256]	; 57e2b69c <TftpStart+0x2d8>
57e2b598:	e1a00480 	lsl	r0, r0, #9
57e2b59c:	e1a01fc0 	asr	r1, r0, #31
57e2b5a0:	ebffdb32 	bl	57e22270 <print_size>
	}

	putc('\n');
57e2b5a4:	e3a0000a 	mov	r0, #10
57e2b5a8:	ebff7793 	bl	57e093fc <putc>
		TftpState = STATE_SEND_WRQ;
		new_transfer();
	} else
#endif
	{
		printf("Load address: 0x%lx\n", load_addr);
57e2b5ac:	e59f30ec 	ldr	r3, [pc, #236]	; 57e2b6a0 <TftpStart+0x2dc>
57e2b5b0:	e59f00ec 	ldr	r0, [pc, #236]	; 57e2b6a4 <TftpStart+0x2e0>
57e2b5b4:	e5931000 	ldr	r1, [r3]
57e2b5b8:	ebff77a3 	bl	57e0944c <printf>
		puts("Loading: *\b");
		TftpState = STATE_SEND_RRQ;
57e2b5bc:	e59f50a0 	ldr	r5, [pc, #160]	; 57e2b664 <TftpStart+0x2a0>
		new_transfer();
	} else
#endif
	{
		printf("Load address: 0x%lx\n", load_addr);
		puts("Loading: *\b");
57e2b5c0:	e59f00e0 	ldr	r0, [pc, #224]	; 57e2b6a8 <TftpStart+0x2e4>
57e2b5c4:	ebff7796 	bl	57e09424 <puts>
		TftpState = STATE_SEND_RRQ;
57e2b5c8:	e3a03001 	mov	r3, #1
57e2b5cc:	e5853000 	str	r3, [r5]
	}

	time_start = get_timer(0);
57e2b5d0:	e3a00000 	mov	r0, #0
57e2b5d4:	ebff554c 	bl	57e00b0c <get_timer>
	TftpTimeoutCountMax = TftpRRQTimeoutCountMax;
57e2b5d8:	e59f4070 	ldr	r4, [pc, #112]	; 57e2b650 <TftpStart+0x28c>

	NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
57e2b5dc:	e59f10c8 	ldr	r1, [pc, #200]	; 57e2b6ac <TftpStart+0x2e8>
		puts("Loading: *\b");
		TftpState = STATE_SEND_RRQ;
	}

	time_start = get_timer(0);
	TftpTimeoutCountMax = TftpRRQTimeoutCountMax;
57e2b5e0:	e5943010 	ldr	r3, [r4, #16]
		printf("Load address: 0x%lx\n", load_addr);
		puts("Loading: *\b");
		TftpState = STATE_SEND_RRQ;
	}

	time_start = get_timer(0);
57e2b5e4:	e58500a4 	str	r0, [r5, #164]	; 0xa4
	TftpTimeoutCountMax = TftpRRQTimeoutCountMax;
57e2b5e8:	e5843008 	str	r3, [r4, #8]

	NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
57e2b5ec:	e5940000 	ldr	r0, [r4]
57e2b5f0:	ebfff64a 	bl	57e28f20 <NetSetTimeout>
	net_set_udp_handler(TftpHandler);
57e2b5f4:	e59f00b4 	ldr	r0, [pc, #180]	; 57e2b6b0 <TftpStart+0x2ec>
57e2b5f8:	ebfff634 	bl	57e28ed0 <net_set_udp_handler>
#ifdef CONFIG_CMD_TFTPPUT
	net_set_icmp_handler(icmp_handler);
#endif
	TftpRemotePort = WELL_KNOWN_PORT;
	TftpTimeoutCount = 0;
57e2b5fc:	e3a06000 	mov	r6, #0
	NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
	net_set_udp_handler(TftpHandler);
#ifdef CONFIG_CMD_TFTPPUT
	net_set_icmp_handler(icmp_handler);
#endif
	TftpRemotePort = WELL_KNOWN_PORT;
57e2b600:	e3a03045 	mov	r3, #69	; 0x45
57e2b604:	e585308c 	str	r3, [r5, #140]	; 0x8c
	TftpTimeoutCount = 0;
57e2b608:	e5856094 	str	r6, [r5, #148]	; 0x94
	/* Use a pseudo-random port unless a specific port is set */
	TftpOurPort = 1024 + (get_timer(0) % 3072);
57e2b60c:	e1a00006 	mov	r0, r6
57e2b610:	ebff553d 	bl	57e00b0c <get_timer>
57e2b614:	e3a01b03 	mov	r1, #3072	; 0xc00
57e2b618:	eb0000df 	bl	57e2b99c <__aeabi_uidivmod>
57e2b61c:	e2811b01 	add	r1, r1, #1024	; 0x400
57e2b620:	e5851090 	str	r1, [r5, #144]	; 0x90
		TftpRemotePort = simple_strtol(ep, NULL, 10);
	ep = getenv("tftpsrcp");
	if (ep != NULL)
		TftpOurPort = simple_strtol(ep, NULL, 10);
#endif
	TftpBlock = 0;
57e2b624:	e5856084 	str	r6, [r5, #132]	; 0x84

	/* zero out server ether in case the server ip has changed */
	memset(NetServerEther, 0, 6);
57e2b628:	e1a01006 	mov	r1, r6
57e2b62c:	e3a02006 	mov	r2, #6
57e2b630:	e59f007c 	ldr	r0, [pc, #124]	; 57e2b6b4 <TftpStart+0x2f0>
57e2b634:	ebffe310 	bl	57e2427c <memset>
	/* Revert TftpBlkSize to dflt */
	TftpBlkSize = TFTP_BLOCK_SIZE;
57e2b638:	e3a03c02 	mov	r3, #512	; 0x200
57e2b63c:	e1c430bc 	strh	r3, [r4, #12]
	TftpTsize = 0;
	TftpNumchars = 0;
#endif

	TftpSend();
}
57e2b640:	e28dd008 	add	sp, sp, #8
57e2b644:	e8bd4070 	pop	{r4, r5, r6, lr}
#ifdef CONFIG_TFTP_TSIZE
	TftpTsize = 0;
	TftpNumchars = 0;
#endif

	TftpSend();
57e2b648:	eafffe03 	b	57e2ae5c <TftpSend>
57e2b64c:	57e35e20 	.word	0x57e35e20
57e2b650:	57e37bd4 	.word	0x57e37bd4
57e2b654:	57e35e2e 	.word	0x57e35e2e
57e2b658:	57e35e3a 	.word	0x57e35e3a
57e2b65c:	57e79780 	.word	0x57e79780
57e2b660:	57e7980c 	.word	0x57e7980c
57e2b664:	57e7bfac 	.word	0x57e7bfac
57e2b668:	57e79764 	.word	0x57e79764
57e2b66c:	57e35c55 	.word	0x57e35c55
57e2b670:	57e35c6a 	.word	0x57e35c6a
57e2b674:	57e35c96 	.word	0x57e35c96
57e2b678:	57e35e9c 	.word	0x57e35e9c
57e2b67c:	57e35e70 	.word	0x57e35e70
57e2b680:	57e79804 	.word	0x57e79804
57e2b684:	57e79808 	.word	0x57e79808
57e2b688:	57e35ce6 	.word	0x57e35ce6
57e2b68c:	57e7b6e8 	.word	0x57e7b6e8
57e2b690:	57e7bfb0 	.word	0x57e7bfb0
57e2b694:	57e35ea1 	.word	0x57e35ea1
57e2b698:	57e35d18 	.word	0x57e35d18
57e2b69c:	57e302de 	.word	0x57e302de
57e2b6a0:	57e36e60 	.word	0x57e36e60
57e2b6a4:	57e35eb0 	.word	0x57e35eb0
57e2b6a8:	57e35d44 	.word	0x57e35d44
57e2b6ac:	57e2b000 	.word	0x57e2b000
57e2b6b0:	57e2b078 	.word	0x57e2b078
57e2b6b4:	57e7b6ec 	.word	0x57e7b6ec

57e2b6b8 <board_init>:
 * Miscellaneous platform dependent initialisations
 */

static void cs8900_pre_init(void)
{
	SROM_BW_REG &= ~(0xf << 4);
57e2b6b8:	e3a03207 	mov	r3, #1879048192	; 0x70000000
57e2b6bc:	e5932000 	ldr	r2, [r3]
	SROM_BW_REG |= 4 | 8 | 1;

	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;

	return 0;
}
57e2b6c0:	e3a00000 	mov	r0, #0
 * Miscellaneous platform dependent initialisations
 */

static void cs8900_pre_init(void)
{
	SROM_BW_REG &= ~(0xf << 4);
57e2b6c4:	e3c220f0 	bic	r2, r2, #240	; 0xf0
57e2b6c8:	e5832000 	str	r2, [r3]
	SROM_BW_REG |= (1 << 7) | (1 << 6) | (1 << 4);
57e2b6cc:	e5932000 	ldr	r2, [r3]
57e2b6d0:	e38220d0 	orr	r2, r2, #208	; 0xd0
57e2b6d4:	e5832000 	str	r2, [r3]
	SROM_BC1_REG = ((CS8900_Tacs << 28) + (CS8900_Tcos << 24) +
57e2b6d8:	e59f201c 	ldr	r2, [pc, #28]	; 57e2b6fc <board_init+0x44>
57e2b6dc:	e5832008 	str	r2, [r3, #8]
	cs8900_pre_init();

	/* NOR-flash in SROM0 */

	/* Enable WAIT */
	SROM_BW_REG |= 4 | 8 | 1;
57e2b6e0:	e5932000 	ldr	r2, [r3]
57e2b6e4:	e382200d 	orr	r2, r2, #13
57e2b6e8:	e5832000 	str	r2, [r3]

	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
57e2b6ec:	e5983000 	ldr	r3, [r8]
57e2b6f0:	e59f2008 	ldr	r2, [pc, #8]	; 57e2b700 <board_init+0x48>
57e2b6f4:	e5832008 	str	r2, [r3, #8]

	return 0;
}
57e2b6f8:	e12fff1e 	bx	lr
57e2b6fc:	040e1460 	.word	0x040e1460
57e2b700:	50000100 	.word	0x50000100

57e2b704 <dram_init_banksize>:

void dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
57e2b704:	e5982000 	ldr	r2, [r8]
57e2b708:	e3a01205 	mov	r1, #1342177280	; 0x50000000
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
57e2b70c:	e5983000 	ldr	r3, [r8]
	return 0;
}

void dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
57e2b710:	e5821018 	str	r1, [r2, #24]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
57e2b714:	e3a02302 	mov	r2, #134217728	; 0x8000000
57e2b718:	e583201c 	str	r2, [r3, #28]
}
57e2b71c:	e12fff1e 	bx	lr

57e2b720 <dram_init>:

int dram_init(void)
{
57e2b720:	e92d4010 	push	{r4, lr}
	gd->ram_size = get_ram_size((long *)CONFIG_SYS_SDRAM_BASE,
57e2b724:	e3a01302 	mov	r1, #134217728	; 0x8000000
57e2b728:	e3a00205 	mov	r0, #1342177280	; 0x50000000
57e2b72c:	e1a04008 	mov	r4, r8
57e2b730:	ebff8f7e 	bl	57e0f530 <get_ram_size>
57e2b734:	e5840038 	str	r0, [r4, #56]	; 0x38
				PHYS_SDRAM_1_SIZE);

	return 0;
}
57e2b738:	e3a00000 	mov	r0, #0
57e2b73c:	e8bd8010 	pop	{r4, pc}

57e2b740 <checkboard>:

#ifdef CONFIG_DISPLAY_BOARDINFO
int checkboard(void)
{
57e2b740:	e92d4008 	push	{r3, lr}
	printf("Board:   SMDK6400\n");
57e2b744:	e59f0008 	ldr	r0, [pc, #8]	; 57e2b754 <checkboard+0x14>
57e2b748:	ebff773f 	bl	57e0944c <printf>
	return 0;
}
57e2b74c:	e3a00000 	mov	r0, #0
57e2b750:	e8bd8008 	pop	{r3, pc}
57e2b754:	57e35ec5 	.word	0x57e35ec5

57e2b758 <board_flash_get_legacy>:
}
#endif

ulong board_flash_get_legacy (ulong base, int banknum, flash_info_t *info)
{
	if (banknum == 0) {	/* non-CFI boot flash */
57e2b758:	e3510000 	cmp	r1, #0
		info->portwidth = FLASH_CFI_16BIT;
57e2b75c:	03a03002 	moveq	r3, #2
57e2b760:	05c230d4 	strbeq	r3, [r2, #212]	; 0xd4
		info->chipwidth = FLASH_CFI_BY16;
57e2b764:	05c230d5 	strbeq	r3, [r2, #213]	; 0xd5
		info->interface = FLASH_CFI_X16;
57e2b768:	03a03001 	moveq	r3, #1
57e2b76c:	01c23eba 	strheq	r3, [r2, #234]	; 0xea
		return 1;
57e2b770:	03a00001 	moveq	r0, #1
	} else
		return 0;
57e2b774:	13a00000 	movne	r0, #0
}
57e2b778:	e12fff1e 	bx	lr

57e2b77c <board_eth_init>:
#ifdef CONFIG_CMD_NET
int board_eth_init(bd_t *bis)
{
	int rc = 0;
#ifdef CONFIG_CS8900
	rc = cs8900_initialize(0, CONFIG_CS8900_BASE);
57e2b77c:	e59f1004 	ldr	r1, [pc, #4]	; 57e2b788 <board_eth_init+0xc>
57e2b780:	e3a00000 	mov	r0, #0
57e2b784:	eaffc546 	b	57e1cca4 <cs8900_initialize>
57e2b788:	18800300 	.word	0x18800300

57e2b78c <raise>:
 */

#include <common.h>

int raise (int signum)
{
57e2b78c:	e1a01000 	mov	r1, r0
57e2b790:	e92d4008 	push	{r3, lr}
	/* Even if printf() is available, it's large. Punt it for SPL builds */
#if !defined(CONFIG_SPL_BUILD)
	printf("raise: Signal # %d caught\n", signum);
57e2b794:	e59f0008 	ldr	r0, [pc, #8]	; 57e2b7a4 <raise+0x18>
57e2b798:	ebff772b 	bl	57e0944c <printf>
#endif
	return 0;
}
57e2b79c:	e3a00000 	mov	r0, #0
57e2b7a0:	e8bd8008 	pop	{r3, pc}
57e2b7a4:	57e35ed8 	.word	0x57e35ed8

57e2b7a8 <__aeabi_unwind_cpp_pr0>:

/* Dummy function to avoid linker complaints */
void __aeabi_unwind_cpp_pr0(void)
{
};
57e2b7a8:	e12fff1e 	bx	lr

57e2b7ac <__aeabi_unwind_cpp_pr1>:

void __aeabi_unwind_cpp_pr1(void)
{
};
57e2b7ac:	e12fff1e 	bx	lr

57e2b7b0 <__udivsi3>:
57e2b7b0:	e2512001 	subs	r2, r1, #1
57e2b7b4:	012fff1e 	bxeq	lr
57e2b7b8:	3a000074 	bcc	57e2b990 <__udivsi3+0x1e0>
57e2b7bc:	e1500001 	cmp	r0, r1
57e2b7c0:	9a00006b 	bls	57e2b974 <__udivsi3+0x1c4>
57e2b7c4:	e1110002 	tst	r1, r2
57e2b7c8:	0a00006c 	beq	57e2b980 <__udivsi3+0x1d0>
57e2b7cc:	e16f3f10 	clz	r3, r0
57e2b7d0:	e16f2f11 	clz	r2, r1
57e2b7d4:	e0423003 	sub	r3, r2, r3
57e2b7d8:	e273301f 	rsbs	r3, r3, #31
57e2b7dc:	10833083 	addne	r3, r3, r3, lsl #1
57e2b7e0:	e3a02000 	mov	r2, #0
57e2b7e4:	108ff103 	addne	pc, pc, r3, lsl #2
57e2b7e8:	e320f000 	nop	{0}
57e2b7ec:	e1500f81 	cmp	r0, r1, lsl #31
57e2b7f0:	e0a22002 	adc	r2, r2, r2
57e2b7f4:	20400f81 	subcs	r0, r0, r1, lsl #31
57e2b7f8:	e1500f01 	cmp	r0, r1, lsl #30
57e2b7fc:	e0a22002 	adc	r2, r2, r2
57e2b800:	20400f01 	subcs	r0, r0, r1, lsl #30
57e2b804:	e1500e81 	cmp	r0, r1, lsl #29
57e2b808:	e0a22002 	adc	r2, r2, r2
57e2b80c:	20400e81 	subcs	r0, r0, r1, lsl #29
57e2b810:	e1500e01 	cmp	r0, r1, lsl #28
57e2b814:	e0a22002 	adc	r2, r2, r2
57e2b818:	20400e01 	subcs	r0, r0, r1, lsl #28
57e2b81c:	e1500d81 	cmp	r0, r1, lsl #27
57e2b820:	e0a22002 	adc	r2, r2, r2
57e2b824:	20400d81 	subcs	r0, r0, r1, lsl #27
57e2b828:	e1500d01 	cmp	r0, r1, lsl #26
57e2b82c:	e0a22002 	adc	r2, r2, r2
57e2b830:	20400d01 	subcs	r0, r0, r1, lsl #26
57e2b834:	e1500c81 	cmp	r0, r1, lsl #25
57e2b838:	e0a22002 	adc	r2, r2, r2
57e2b83c:	20400c81 	subcs	r0, r0, r1, lsl #25
57e2b840:	e1500c01 	cmp	r0, r1, lsl #24
57e2b844:	e0a22002 	adc	r2, r2, r2
57e2b848:	20400c01 	subcs	r0, r0, r1, lsl #24
57e2b84c:	e1500b81 	cmp	r0, r1, lsl #23
57e2b850:	e0a22002 	adc	r2, r2, r2
57e2b854:	20400b81 	subcs	r0, r0, r1, lsl #23
57e2b858:	e1500b01 	cmp	r0, r1, lsl #22
57e2b85c:	e0a22002 	adc	r2, r2, r2
57e2b860:	20400b01 	subcs	r0, r0, r1, lsl #22
57e2b864:	e1500a81 	cmp	r0, r1, lsl #21
57e2b868:	e0a22002 	adc	r2, r2, r2
57e2b86c:	20400a81 	subcs	r0, r0, r1, lsl #21
57e2b870:	e1500a01 	cmp	r0, r1, lsl #20
57e2b874:	e0a22002 	adc	r2, r2, r2
57e2b878:	20400a01 	subcs	r0, r0, r1, lsl #20
57e2b87c:	e1500981 	cmp	r0, r1, lsl #19
57e2b880:	e0a22002 	adc	r2, r2, r2
57e2b884:	20400981 	subcs	r0, r0, r1, lsl #19
57e2b888:	e1500901 	cmp	r0, r1, lsl #18
57e2b88c:	e0a22002 	adc	r2, r2, r2
57e2b890:	20400901 	subcs	r0, r0, r1, lsl #18
57e2b894:	e1500881 	cmp	r0, r1, lsl #17
57e2b898:	e0a22002 	adc	r2, r2, r2
57e2b89c:	20400881 	subcs	r0, r0, r1, lsl #17
57e2b8a0:	e1500801 	cmp	r0, r1, lsl #16
57e2b8a4:	e0a22002 	adc	r2, r2, r2
57e2b8a8:	20400801 	subcs	r0, r0, r1, lsl #16
57e2b8ac:	e1500781 	cmp	r0, r1, lsl #15
57e2b8b0:	e0a22002 	adc	r2, r2, r2
57e2b8b4:	20400781 	subcs	r0, r0, r1, lsl #15
57e2b8b8:	e1500701 	cmp	r0, r1, lsl #14
57e2b8bc:	e0a22002 	adc	r2, r2, r2
57e2b8c0:	20400701 	subcs	r0, r0, r1, lsl #14
57e2b8c4:	e1500681 	cmp	r0, r1, lsl #13
57e2b8c8:	e0a22002 	adc	r2, r2, r2
57e2b8cc:	20400681 	subcs	r0, r0, r1, lsl #13
57e2b8d0:	e1500601 	cmp	r0, r1, lsl #12
57e2b8d4:	e0a22002 	adc	r2, r2, r2
57e2b8d8:	20400601 	subcs	r0, r0, r1, lsl #12
57e2b8dc:	e1500581 	cmp	r0, r1, lsl #11
57e2b8e0:	e0a22002 	adc	r2, r2, r2
57e2b8e4:	20400581 	subcs	r0, r0, r1, lsl #11
57e2b8e8:	e1500501 	cmp	r0, r1, lsl #10
57e2b8ec:	e0a22002 	adc	r2, r2, r2
57e2b8f0:	20400501 	subcs	r0, r0, r1, lsl #10
57e2b8f4:	e1500481 	cmp	r0, r1, lsl #9
57e2b8f8:	e0a22002 	adc	r2, r2, r2
57e2b8fc:	20400481 	subcs	r0, r0, r1, lsl #9
57e2b900:	e1500401 	cmp	r0, r1, lsl #8
57e2b904:	e0a22002 	adc	r2, r2, r2
57e2b908:	20400401 	subcs	r0, r0, r1, lsl #8
57e2b90c:	e1500381 	cmp	r0, r1, lsl #7
57e2b910:	e0a22002 	adc	r2, r2, r2
57e2b914:	20400381 	subcs	r0, r0, r1, lsl #7
57e2b918:	e1500301 	cmp	r0, r1, lsl #6
57e2b91c:	e0a22002 	adc	r2, r2, r2
57e2b920:	20400301 	subcs	r0, r0, r1, lsl #6
57e2b924:	e1500281 	cmp	r0, r1, lsl #5
57e2b928:	e0a22002 	adc	r2, r2, r2
57e2b92c:	20400281 	subcs	r0, r0, r1, lsl #5
57e2b930:	e1500201 	cmp	r0, r1, lsl #4
57e2b934:	e0a22002 	adc	r2, r2, r2
57e2b938:	20400201 	subcs	r0, r0, r1, lsl #4
57e2b93c:	e1500181 	cmp	r0, r1, lsl #3
57e2b940:	e0a22002 	adc	r2, r2, r2
57e2b944:	20400181 	subcs	r0, r0, r1, lsl #3
57e2b948:	e1500101 	cmp	r0, r1, lsl #2
57e2b94c:	e0a22002 	adc	r2, r2, r2
57e2b950:	20400101 	subcs	r0, r0, r1, lsl #2
57e2b954:	e1500081 	cmp	r0, r1, lsl #1
57e2b958:	e0a22002 	adc	r2, r2, r2
57e2b95c:	20400081 	subcs	r0, r0, r1, lsl #1
57e2b960:	e1500001 	cmp	r0, r1
57e2b964:	e0a22002 	adc	r2, r2, r2
57e2b968:	20400001 	subcs	r0, r0, r1
57e2b96c:	e1a00002 	mov	r0, r2
57e2b970:	e12fff1e 	bx	lr
57e2b974:	03a00001 	moveq	r0, #1
57e2b978:	13a00000 	movne	r0, #0
57e2b97c:	e12fff1e 	bx	lr
57e2b980:	e16f2f11 	clz	r2, r1
57e2b984:	e262201f 	rsb	r2, r2, #31
57e2b988:	e1a00230 	lsr	r0, r0, r2
57e2b98c:	e12fff1e 	bx	lr
57e2b990:	e3500000 	cmp	r0, #0
57e2b994:	13e00000 	mvnne	r0, #0
57e2b998:	ea0000ac 	b	57e2bc50 <__aeabi_ldiv0>

57e2b99c <__aeabi_uidivmod>:
57e2b99c:	e3510000 	cmp	r1, #0
57e2b9a0:	0afffffa 	beq	57e2b990 <__udivsi3+0x1e0>
57e2b9a4:	e92d4003 	push	{r0, r1, lr}
57e2b9a8:	ebffff80 	bl	57e2b7b0 <__udivsi3>
57e2b9ac:	e8bd4006 	pop	{r1, r2, lr}
57e2b9b0:	e0030092 	mul	r3, r2, r0
57e2b9b4:	e0411003 	sub	r1, r1, r3
57e2b9b8:	e12fff1e 	bx	lr

57e2b9bc <__divsi3>:
57e2b9bc:	e3510000 	cmp	r1, #0
57e2b9c0:	0a000081 	beq	57e2bbcc <.divsi3_skip_div0_test+0x208>

57e2b9c4 <.divsi3_skip_div0_test>:
57e2b9c4:	e020c001 	eor	ip, r0, r1
57e2b9c8:	42611000 	rsbmi	r1, r1, #0
57e2b9cc:	e2512001 	subs	r2, r1, #1
57e2b9d0:	0a000070 	beq	57e2bb98 <.divsi3_skip_div0_test+0x1d4>
57e2b9d4:	e1b03000 	movs	r3, r0
57e2b9d8:	42603000 	rsbmi	r3, r0, #0
57e2b9dc:	e1530001 	cmp	r3, r1
57e2b9e0:	9a00006f 	bls	57e2bba4 <.divsi3_skip_div0_test+0x1e0>
57e2b9e4:	e1110002 	tst	r1, r2
57e2b9e8:	0a000071 	beq	57e2bbb4 <.divsi3_skip_div0_test+0x1f0>
57e2b9ec:	e16f2f13 	clz	r2, r3
57e2b9f0:	e16f0f11 	clz	r0, r1
57e2b9f4:	e0402002 	sub	r2, r0, r2
57e2b9f8:	e272201f 	rsbs	r2, r2, #31
57e2b9fc:	10822082 	addne	r2, r2, r2, lsl #1
57e2ba00:	e3a00000 	mov	r0, #0
57e2ba04:	108ff102 	addne	pc, pc, r2, lsl #2
57e2ba08:	e320f000 	nop	{0}
57e2ba0c:	e1530f81 	cmp	r3, r1, lsl #31
57e2ba10:	e0a00000 	adc	r0, r0, r0
57e2ba14:	20433f81 	subcs	r3, r3, r1, lsl #31
57e2ba18:	e1530f01 	cmp	r3, r1, lsl #30
57e2ba1c:	e0a00000 	adc	r0, r0, r0
57e2ba20:	20433f01 	subcs	r3, r3, r1, lsl #30
57e2ba24:	e1530e81 	cmp	r3, r1, lsl #29
57e2ba28:	e0a00000 	adc	r0, r0, r0
57e2ba2c:	20433e81 	subcs	r3, r3, r1, lsl #29
57e2ba30:	e1530e01 	cmp	r3, r1, lsl #28
57e2ba34:	e0a00000 	adc	r0, r0, r0
57e2ba38:	20433e01 	subcs	r3, r3, r1, lsl #28
57e2ba3c:	e1530d81 	cmp	r3, r1, lsl #27
57e2ba40:	e0a00000 	adc	r0, r0, r0
57e2ba44:	20433d81 	subcs	r3, r3, r1, lsl #27
57e2ba48:	e1530d01 	cmp	r3, r1, lsl #26
57e2ba4c:	e0a00000 	adc	r0, r0, r0
57e2ba50:	20433d01 	subcs	r3, r3, r1, lsl #26
57e2ba54:	e1530c81 	cmp	r3, r1, lsl #25
57e2ba58:	e0a00000 	adc	r0, r0, r0
57e2ba5c:	20433c81 	subcs	r3, r3, r1, lsl #25
57e2ba60:	e1530c01 	cmp	r3, r1, lsl #24
57e2ba64:	e0a00000 	adc	r0, r0, r0
57e2ba68:	20433c01 	subcs	r3, r3, r1, lsl #24
57e2ba6c:	e1530b81 	cmp	r3, r1, lsl #23
57e2ba70:	e0a00000 	adc	r0, r0, r0
57e2ba74:	20433b81 	subcs	r3, r3, r1, lsl #23
57e2ba78:	e1530b01 	cmp	r3, r1, lsl #22
57e2ba7c:	e0a00000 	adc	r0, r0, r0
57e2ba80:	20433b01 	subcs	r3, r3, r1, lsl #22
57e2ba84:	e1530a81 	cmp	r3, r1, lsl #21
57e2ba88:	e0a00000 	adc	r0, r0, r0
57e2ba8c:	20433a81 	subcs	r3, r3, r1, lsl #21
57e2ba90:	e1530a01 	cmp	r3, r1, lsl #20
57e2ba94:	e0a00000 	adc	r0, r0, r0
57e2ba98:	20433a01 	subcs	r3, r3, r1, lsl #20
57e2ba9c:	e1530981 	cmp	r3, r1, lsl #19
57e2baa0:	e0a00000 	adc	r0, r0, r0
57e2baa4:	20433981 	subcs	r3, r3, r1, lsl #19
57e2baa8:	e1530901 	cmp	r3, r1, lsl #18
57e2baac:	e0a00000 	adc	r0, r0, r0
57e2bab0:	20433901 	subcs	r3, r3, r1, lsl #18
57e2bab4:	e1530881 	cmp	r3, r1, lsl #17
57e2bab8:	e0a00000 	adc	r0, r0, r0
57e2babc:	20433881 	subcs	r3, r3, r1, lsl #17
57e2bac0:	e1530801 	cmp	r3, r1, lsl #16
57e2bac4:	e0a00000 	adc	r0, r0, r0
57e2bac8:	20433801 	subcs	r3, r3, r1, lsl #16
57e2bacc:	e1530781 	cmp	r3, r1, lsl #15
57e2bad0:	e0a00000 	adc	r0, r0, r0
57e2bad4:	20433781 	subcs	r3, r3, r1, lsl #15
57e2bad8:	e1530701 	cmp	r3, r1, lsl #14
57e2badc:	e0a00000 	adc	r0, r0, r0
57e2bae0:	20433701 	subcs	r3, r3, r1, lsl #14
57e2bae4:	e1530681 	cmp	r3, r1, lsl #13
57e2bae8:	e0a00000 	adc	r0, r0, r0
57e2baec:	20433681 	subcs	r3, r3, r1, lsl #13
57e2baf0:	e1530601 	cmp	r3, r1, lsl #12
57e2baf4:	e0a00000 	adc	r0, r0, r0
57e2baf8:	20433601 	subcs	r3, r3, r1, lsl #12
57e2bafc:	e1530581 	cmp	r3, r1, lsl #11
57e2bb00:	e0a00000 	adc	r0, r0, r0
57e2bb04:	20433581 	subcs	r3, r3, r1, lsl #11
57e2bb08:	e1530501 	cmp	r3, r1, lsl #10
57e2bb0c:	e0a00000 	adc	r0, r0, r0
57e2bb10:	20433501 	subcs	r3, r3, r1, lsl #10
57e2bb14:	e1530481 	cmp	r3, r1, lsl #9
57e2bb18:	e0a00000 	adc	r0, r0, r0
57e2bb1c:	20433481 	subcs	r3, r3, r1, lsl #9
57e2bb20:	e1530401 	cmp	r3, r1, lsl #8
57e2bb24:	e0a00000 	adc	r0, r0, r0
57e2bb28:	20433401 	subcs	r3, r3, r1, lsl #8
57e2bb2c:	e1530381 	cmp	r3, r1, lsl #7
57e2bb30:	e0a00000 	adc	r0, r0, r0
57e2bb34:	20433381 	subcs	r3, r3, r1, lsl #7
57e2bb38:	e1530301 	cmp	r3, r1, lsl #6
57e2bb3c:	e0a00000 	adc	r0, r0, r0
57e2bb40:	20433301 	subcs	r3, r3, r1, lsl #6
57e2bb44:	e1530281 	cmp	r3, r1, lsl #5
57e2bb48:	e0a00000 	adc	r0, r0, r0
57e2bb4c:	20433281 	subcs	r3, r3, r1, lsl #5
57e2bb50:	e1530201 	cmp	r3, r1, lsl #4
57e2bb54:	e0a00000 	adc	r0, r0, r0
57e2bb58:	20433201 	subcs	r3, r3, r1, lsl #4
57e2bb5c:	e1530181 	cmp	r3, r1, lsl #3
57e2bb60:	e0a00000 	adc	r0, r0, r0
57e2bb64:	20433181 	subcs	r3, r3, r1, lsl #3
57e2bb68:	e1530101 	cmp	r3, r1, lsl #2
57e2bb6c:	e0a00000 	adc	r0, r0, r0
57e2bb70:	20433101 	subcs	r3, r3, r1, lsl #2
57e2bb74:	e1530081 	cmp	r3, r1, lsl #1
57e2bb78:	e0a00000 	adc	r0, r0, r0
57e2bb7c:	20433081 	subcs	r3, r3, r1, lsl #1
57e2bb80:	e1530001 	cmp	r3, r1
57e2bb84:	e0a00000 	adc	r0, r0, r0
57e2bb88:	20433001 	subcs	r3, r3, r1
57e2bb8c:	e35c0000 	cmp	ip, #0
57e2bb90:	42600000 	rsbmi	r0, r0, #0
57e2bb94:	e12fff1e 	bx	lr
57e2bb98:	e13c0000 	teq	ip, r0
57e2bb9c:	42600000 	rsbmi	r0, r0, #0
57e2bba0:	e12fff1e 	bx	lr
57e2bba4:	33a00000 	movcc	r0, #0
57e2bba8:	01a00fcc 	asreq	r0, ip, #31
57e2bbac:	03800001 	orreq	r0, r0, #1
57e2bbb0:	e12fff1e 	bx	lr
57e2bbb4:	e16f2f11 	clz	r2, r1
57e2bbb8:	e262201f 	rsb	r2, r2, #31
57e2bbbc:	e35c0000 	cmp	ip, #0
57e2bbc0:	e1a00233 	lsr	r0, r3, r2
57e2bbc4:	42600000 	rsbmi	r0, r0, #0
57e2bbc8:	e12fff1e 	bx	lr
57e2bbcc:	e3500000 	cmp	r0, #0
57e2bbd0:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
57e2bbd4:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
57e2bbd8:	ea00001c 	b	57e2bc50 <__aeabi_ldiv0>

57e2bbdc <__aeabi_idivmod>:
57e2bbdc:	e3510000 	cmp	r1, #0
57e2bbe0:	0afffff9 	beq	57e2bbcc <.divsi3_skip_div0_test+0x208>
57e2bbe4:	e92d4003 	push	{r0, r1, lr}
57e2bbe8:	ebffff75 	bl	57e2b9c4 <.divsi3_skip_div0_test>
57e2bbec:	e8bd4006 	pop	{r1, r2, lr}
57e2bbf0:	e0030092 	mul	r3, r2, r0
57e2bbf4:	e0411003 	sub	r1, r1, r3
57e2bbf8:	e12fff1e 	bx	lr

57e2bbfc <__lshrdi3>:
57e2bbfc:	e2523020 	subs	r3, r2, #32
57e2bc00:	e262c020 	rsb	ip, r2, #32
57e2bc04:	41a00230 	lsrmi	r0, r0, r2
57e2bc08:	51a00331 	lsrpl	r0, r1, r3
57e2bc0c:	41800c11 	orrmi	r0, r0, r1, lsl ip
57e2bc10:	e1a01231 	lsr	r1, r1, r2
57e2bc14:	e12fff1e 	bx	lr

57e2bc18 <__ashrdi3>:
57e2bc18:	e2523020 	subs	r3, r2, #32
57e2bc1c:	e262c020 	rsb	ip, r2, #32
57e2bc20:	41a00230 	lsrmi	r0, r0, r2
57e2bc24:	51a00351 	asrpl	r0, r1, r3
57e2bc28:	41800c11 	orrmi	r0, r0, r1, lsl ip
57e2bc2c:	e1a01251 	asr	r1, r1, r2
57e2bc30:	e12fff1e 	bx	lr

57e2bc34 <__ashldi3>:
57e2bc34:	e2523020 	subs	r3, r2, #32
57e2bc38:	e262c020 	rsb	ip, r2, #32
57e2bc3c:	41a01211 	lslmi	r1, r1, r2
57e2bc40:	51a01310 	lslpl	r1, r0, r3
57e2bc44:	41811c30 	orrmi	r1, r1, r0, lsr ip
57e2bc48:	e1a00210 	lsl	r0, r0, r2
57e2bc4c:	e12fff1e 	bx	lr

57e2bc50 <__aeabi_ldiv0>:
57e2bc50:	e92d4002 	push	{r1, lr}
57e2bc54:	e3a00008 	mov	r0, #8
57e2bc58:	ebfffecb 	bl	57e2b78c <raise>
57e2bc5c:	e8bd8002 	pop	{r1, pc}
